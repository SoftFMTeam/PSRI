12,BLOCK,-1,,<empty>,1,,1,1,,ANY
15,BLOCK,-1,,"{
    return vlc_strerror_c(errnum);
}",1,,30,2,,void
23,BLOCK,-1,,"{
    static __thread char android_buf[100];
    strerror_r(errnum, android_buf, 100);
    return android_buf;
}",1,,35,2,,void
55,BLOCK,-1,,<empty>,1,,1,1,,ANY
80,BLOCK,1,,<empty>,14,,51,1,,void
91,BLOCK,-1,,"{
    jfieldID id = (*env)->GetStaticFieldID(env, clazz, psz_name,
                                           ""Ljava/lang/String;"");
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        return NULL;
    }

    jstring jstr = (*env)->GetStaticObjectField(env, clazz, id);

    const char *psz_str = (*env)->GetStringUTFChars(env, jstr, 0);
    if (psz_str == NULL)
        return NULL;

    char *psz_strdup = strdup(psz_str);

    (*env)->ReleaseStringUTFChars(env, jstr, psz_str);
    (*env)->DeleteLocalRef(env, jstr);

    return psz_strdup;
}",1,,55,4,,void
111,BLOCK,-1,,"{
        (*env)->ExceptionClear(env);
        return NULL;
    }",5,,59,2,,void
146,BLOCK,-1,,<empty>,9,,68,2,,void
176,BLOCK,-1,,"{
    (void) reserved;

    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
        free(ppsz_generic_names[i]);

    JNIEnv* env = NULL;
    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return;

    if (fields.Environment.clazz)
        (*env)->DeleteGlobalRef(env, fields.Environment.clazz);

    if (fields.System.clazz)
        (*env)->DeleteGlobalRef(env, fields.System.clazz);
}",1,,80,3,,void
181,BLOCK,-1,,<empty>,5,,83,1,,void
189,BLOCK,1,,<empty>,,,,1,,void
219,BLOCK,-1,,<empty>,9,,88,2,,void
227,BLOCK,-1,,<empty>,9,,91,2,,void
245,BLOCK,-1,,<empty>,9,,94,2,,void
262,BLOCK,-1,,"{
    s_jvm = vm;
    JNIEnv* env = NULL;

    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return -1;

    jclass clazz = (*env)->FindClass(env, ""android/os/Environment"");
    if ((*env)->ExceptionCheck(env))
        return -1;

    static const char *ppsz_env_names[GENERIC_DIR_COUNT] = {
        NULL,                   /* VLC_DESKTOP_DIR */
        ""DIRECTORY_DOWNLOADS"",  /* VLC_DOWNLOAD_DIR */
        NULL,                   /* VLC_TEMPLATES_DIR */
        NULL,                   /* VLC_PUBLICSHARE_DIR */
        ""DIRECTORY_DOCUMENTS"",  /* VLC_DOCUMENTS_DIR */
        ""DIRECTORY_MUSIC"",      /* VLC_MUSIC_DIR */
        ""DIRECTORY_PICTURES"",   /* VLC_PICTURES_DIR */
        ""DIRECTORY_MOVIES"",     /* VLC_VIDEOS_DIR */
    };
    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
    {
        if (ppsz_env_names[i] != NULL)
            ppsz_generic_names[i] = get_java_string(env, clazz,
                                                   ppsz_env_names[i]);
 ...",1,,102,3,,void
284,BLOCK,-1,,<empty>,9,,107,2,,void
305,BLOCK,-1,,<empty>,9,,111,2,,void
322,BLOCK,-1,,<empty>,5,,123,1,,void
330,BLOCK,1,,<empty>,,,,1,,void
338,BLOCK,4,,"{
        if (ppsz_env_names[i] != NULL)
            ppsz_generic_names[i] = get_java_string(env, clazz,
                                                   ppsz_env_names[i]);
    }",5,,124,4,,void
345,BLOCK,-1,,<empty>,13,,126,2,,void
391,BLOCK,-1,,<empty>,9,,136,2,,void
431,BLOCK,-1,,<empty>,9,,144,2,,void
456,BLOCK,-1,,<empty>,9,,149,2,,void
498,BLOCK,-1,,<empty>,9,,160,2,,void
516,BLOCK,-1,,"{
}",1,,167,2,,void
523,BLOCK,-1,,"{
    (void)i_argc; (void)pp_argv;
    assert(s_jvm != NULL);
    var_Create(p_libvlc, ""android-jvm"", VLC_VAR_ADDRESS);
    var_SetAddress(p_libvlc, ""android-jvm"", s_jvm);
}",1,,172,4,,void
547,BLOCK,-1,,"{
    char *psz_home = getenv(""HOME"");
    if (psz_home == NULL)
        goto fallback;

    if (psz_dir == NULL)
        return strdup(psz_home);

    char *psz_fullpath;
    if (asprintf(&psz_fullpath, ""%s/%s"", psz_home, psz_dir) == -1)
        goto fallback;
    if (vlc_mkdir(psz_fullpath, 0700) == -1 && errno != EEXIST)
    {
        free(psz_fullpath);
        goto fallback;
    }
    return psz_fullpath;

fallback:
    return psz_default_dir != NULL ? strdup(psz_default_dir) : NULL;
}",1,,180,3,,void
557,BLOCK,-1,,<empty>,9,,183,2,,void
563,BLOCK,-1,,<empty>,9,,186,2,,void
578,BLOCK,-1,,<empty>,9,,190,2,,void
591,BLOCK,-1,,"{
        free(psz_fullpath);
        goto fallback;
    }",5,,192,2,,void
610,BLOCK,-1,,"{
    JNIEnv *env;
    if ((*s_jvm)->GetEnv(s_jvm, (void **)&env, JNI_VERSION_1_2) != JNI_OK)
    {
        /* attach the thread to the Java VM */
        JavaVMAttachArgs args;

        args.version = JNI_VERSION_1_2;
        args.name = ""config_GetGenericDir"";
        args.group = NULL;

        if ((*s_jvm)->AttachCurrentThread(s_jvm, &env, &args) != JNI_OK)
            return NULL;
        *p_detach = true;
    }
    else
        *p_detach = false;
    return env;
}",1,,203,2,,void
626,BLOCK,-1,,"{
        /* attach the thread to the Java VM */
        JavaVMAttachArgs args;

        args.version = JNI_VERSION_1_2;
        args.name = ""config_GetGenericDir"";
        args.group = NULL;

        if ((*s_jvm)->AttachCurrentThread(s_jvm, &env, &args) != JNI_OK)
            return NULL;
        *p_detach = true;
    }",5,,206,2,,void
656,BLOCK,-1,,<empty>,13,,215,2,,void
664,BLOCK,-1,,<empty>,9,,219,1,,void
675,BLOCK,-1,,"{
    if (b_detach)
        (*s_jvm)->DetachCurrentThread(s_jvm);
}",1,,224,2,,void
678,BLOCK,-1,,<empty>,9,,226,2,,void
689,BLOCK,-1,,"{
    JNIEnv *env;
    bool b_detach;
    char *psz_ret = NULL;

    env = get_env(&b_detach);
    if (env == NULL)
        return NULL;

    jstring jname= (*env)->NewStringUTF(env, psz_name);
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        jname = NULL;
    }
    if (jname == NULL)
        goto error;

    jobject jfile = (*env)->CallStaticObjectMethod(env,
                        fields.Environment.clazz,
                        fields.Environment.getExternalStoragePublicDirectory,
                        jname);
    (*env)->DeleteLocalRef(env, jname);
    if (jfile == NULL)
        goto error;

    jstring jpath = (*env)->CallObjectMethod(env, jfile,
                                             fields.File.getAbsolutePath);
    (*env)->DeleteLocalRef(env, jfile);

    const char *psz_path = (*env)->GetStringUTFChars(env, jpath, 0);
    if (psz_path == NULL)
        goto error;
    psz_ret = strdup(psz_path);
    (*env)->ReleaseStringUTFCha...",1,,230,2,,void
705,BLOCK,-1,,<empty>,9,,237,2,,void
725,BLOCK,-1,,"{
        (*env)->ExceptionClear(env);
        jname = NULL;
    }",5,,241,2,,void
739,BLOCK,-1,,<empty>,9,,246,2,,void
772,BLOCK,-1,,<empty>,9,,254,2,,void
811,BLOCK,-1,,<empty>,9,,262,2,,void
841,BLOCK,-1,,"{
    switch (type)
    {
        case VLC_DATA_DIR:
            return config_GetHomeDir("".share"",
                ""/sdcard/Android/data/org.videolan.vlc"");
        case VLC_CACHE_DIR:
            return config_GetHomeDir("".cache"",
                ""/sdcard/Android/data/org.videolan.vlc/cache"");
        case VLC_HOME_DIR:
            return config_GetHomeDir(NULL, NULL);
        case VLC_CONFIG_DIR:
            return config_GetHomeDir("".config"", NULL);

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
        case VLC_MUSIC_DIR:
        case VLC_PICTURES_DIR:
        case VLC_VIDEOS_DIR:
        {
            assert(type >= VLC_DESKTOP_DIR && type <= VLC_VIDEOS_DIR);
            const char *psz_name = ppsz_generic_names[type - VLC_DESKTOP_DIR];
            if (psz_name != NULL)
                return config_GetGenericDir(psz_name);
        }
    }
    return NULL;
}",1,,273,2,,void
844,BLOCK,-1,,"{
        case VLC_DATA_DIR:
            return config_GetHomeDir("".share"",
                ""/sdcard/Android/data/org.videolan.vlc"");
        case VLC_CACHE_DIR:
            return config_GetHomeDir("".cache"",
                ""/sdcard/Android/data/org.videolan.vlc/cache"");
        case VLC_HOME_DIR:
            return config_GetHomeDir(NULL, NULL);
        case VLC_CONFIG_DIR:
            return config_GetHomeDir("".config"", NULL);

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
        case VLC_MUSIC_DIR:
        case VLC_PICTURES_DIR:
        case VLC_VIDEOS_DIR:
        {
            assert(type >= VLC_DESKTOP_DIR && type <= VLC_VIDEOS_DIR);
            const char *psz_name = ppsz_generic_names[type - VLC_DESKTOP_DIR];
            if (psz_name != NULL)
                return config_GetGenericDir(psz_name);
        }
    }",5,,275,2,,void
885,BLOCK,29,,"{
            assert(type >= VLC_DESKTOP_DIR && type <= VLC_VIDEOS_DIR);
            const char *psz_name = ppsz_generic_names[type - VLC_DESKTOP_DIR];
            if (psz_name != NULL)
                return config_GetGenericDir(psz_name);
        }",9,,295,29,,void
906,BLOCK,-1,,<empty>,17,,299,2,,void
916,BLOCK,-1,,"{
    VLC_UNUSED(url);
    JNIEnv *env;
    bool b_detach;
    char *psz_ret = NULL;
    const char *psz_host = NULL, *psz_port = NULL;
    jstring jhost = NULL, jport = NULL;

    env = get_env(&b_detach);
    if (env == NULL)
        return NULL;

    /* Fetch ""http.proxyHost"" property */
    jstring jkey = (*env)->NewStringUTF(env, ""http.proxyHost"");
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        jkey = NULL;
    }
    if (jkey == NULL)
        goto end;

    jhost = (*env)->CallStaticObjectMethod(env, fields.System.clazz,
                                           fields.System.getProperty, jkey);
    (*env)->DeleteLocalRef(env, jkey);
    if (jhost == NULL)
        goto end;

    psz_host = (*env)->GetStringUTFChars(env, jhost, 0);
    /* Ensure the property is valid */
    if (psz_host == NULL || psz_host[0] == '\0')
        goto end;

    /* Fetch ""http.proxyPort"" property (only if ""http.proxyHost"" is valid) */
    jkey = (*env)->NewSt...",1,,316,2,,void
950,BLOCK,-1,,<empty>,9,,326,2,,void
970,BLOCK,-1,,"{
        (*env)->ExceptionClear(env);
        jkey = NULL;
    }",5,,331,2,,void
984,BLOCK,-1,,<empty>,9,,336,2,,void
1016,BLOCK,-1,,<empty>,9,,342,2,,void
1038,BLOCK,-1,,<empty>,9,,347,2,,void
1056,BLOCK,-1,,"{
        (*env)->ExceptionClear(env);
        jkey = NULL;
    }",5,,352,2,,void
1070,BLOCK,-1,,<empty>,9,,357,2,,void
1102,BLOCK,-1,,"{
        psz_port = (*env)->GetStringUTFChars(env, jport, 0);
        if (psz_port != NULL && (psz_port[0] == '\0' || psz_port[0] == '0'))
        {
            (*env)->ReleaseStringUTFChars(env, jport, psz_port);
            psz_port = NULL;
        }
    }",5,,365,2,,void
1129,BLOCK,-1,,"{
            (*env)->ReleaseStringUTFChars(env, jport, psz_port);
            psz_port = NULL;
        }",9,,368,2,,void
1162,BLOCK,-1,,<empty>,9,,379,2,,void
1171,BLOCK,-1,,<empty>,9,,383,2,,void
1184,BLOCK,-1,,<empty>,9,,385,2,,void
1196,BLOCK,-1,,<empty>,9,,387,2,,void
1209,BLOCK,-1,,<empty>,9,,389,2,,void
1251,BLOCK,-1,,<empty>,1,,1,1,,ANY
1258,BLOCK,-1,,"{
    char buf[1000];
    const char *msg;

    switch (strerror_r (error, buf, sizeof (buf)))
    {
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }

    fprintf(stderr, ""LibVLC fatal error %s (%d) in thread %lu ""
            ""at %s:%u in %s\n Error message: %s\n"",
            action, error, vlc_thread_id (), file, line, function, msg);
    fflush (stderr);
}",1,,51,6,,void
1267,BLOCK,-1,,"{
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }",5,,56,2,,void
1301,BLOCK,-1,,"{
    pthread_mutexattr_t attr;

    pthread_mutexattr_init (&attr);
#ifdef NDEBUG
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);
#else
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_ERRORCHECK);
#endif
    pthread_mutex_init (p_mutex, &attr);
    pthread_mutexattr_destroy( &attr );
}",1,,86,2,,void
1321,BLOCK,-1,,"{
    pthread_mutexattr_t attr;

    pthread_mutexattr_init (&attr);
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init (p_mutex, &attr);
    pthread_mutexattr_destroy( &attr );
}",1,,100,2,,void
1341,BLOCK,-1,,"{
    int val = pthread_mutex_destroy( p_mutex );
    VLC_THREAD_ASSERT (""destroying mutex"");
}",1,,111,2,,void
1348,BLOCK,1,,<empty>,,,,3,,void
1350,BLOCK,-1,,"VLC_THREAD_ASSERT (""destroying mutex"")",5,,113,1,,void
1354,BLOCK,-1,,"VLC_THREAD_ASSERT (""destroying mutex"")",5,,113,2,,void
1370,BLOCK,-1,,"{
    int val = pthread_mutex_lock( p_mutex );
    VLC_THREAD_ASSERT (""locking mutex"");
}",1,,124,2,,void
1377,BLOCK,1,,<empty>,,,,3,,void
1379,BLOCK,-1,,"VLC_THREAD_ASSERT (""locking mutex"")",5,,126,1,,void
1383,BLOCK,-1,,"VLC_THREAD_ASSERT (""locking mutex"")",5,,126,2,,void
1398,BLOCK,-1,,"{
    int val = pthread_mutex_trylock( p_mutex );

    if (val != EBUSY)
        VLC_THREAD_ASSERT (""locking mutex"");
    return val;
}",1,,130,2,,void
1408,BLOCK,-1,,<empty>,9,,134,2,,void
1410,BLOCK,1,,<empty>,,,,3,,void
1412,BLOCK,-1,,"VLC_THREAD_ASSERT (""locking mutex"")",9,,134,1,,void
1416,BLOCK,-1,,"VLC_THREAD_ASSERT (""locking mutex"")",9,,134,2,,void
1433,BLOCK,-1,,"{
    int val = pthread_mutex_unlock( p_mutex );
    VLC_THREAD_ASSERT (""unlocking mutex"");
}",1,,139,2,,void
1440,BLOCK,1,,<empty>,,,,3,,void
1442,BLOCK,-1,,"VLC_THREAD_ASSERT (""unlocking mutex"")",5,,141,1,,void
1446,BLOCK,-1,,"VLC_THREAD_ASSERT (""unlocking mutex"")",5,,141,2,,void
1464,BLOCK,-1,,<empty>,,,,2,,<empty>
1477,BLOCK,-1,,"{
    return thread;
}",1,,165,2,,void
1484,BLOCK,-1,,"{
    (void)p_libvlc;
}",1,,170,2,,void
1492,BLOCK,-1,,"{
    struct vlc_thread *th = data;

    /* release thread handle */
    vlc_mutex_destroy(&th->wait.lock);
    free(th);
}",1,,176,2,,void
1510,BLOCK,-1,,"{
    vlc_thread_t th = data;

    thread = th;

    vlc_cleanup_push(clean_detached_thread, th);
    th->entry(th->data);
    vlc_cleanup_pop();
    clean_detached_thread(th);
    return NULL;
}",1,,185,2,,void
1537,BLOCK,-1,,"{
    vlc_thread_t th = data;

    vlc_sem_post(&th->finished);
}",1,,198,2,,void
1551,BLOCK,-1,,"{
    vlc_thread_t th = data;
    void *ret;

    vlc_cleanup_push(finish_joinable_thread, th);
    thread = th;
    ret = th->entry(th->data);
    vlc_cleanup_pop();
    vlc_sem_post(&th->finished);

    return ret;
}",1,,205,2,,void
1587,BLOCK,-1,,"{
    vlc_thread_t thread = malloc (sizeof (*thread));
    if (unlikely(thread == NULL))
        return ENOMEM;

    int ret;

    sigset_t oldset;
    {
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }

    if (!detach)
        vlc_sem_init(&thread->finished, 0);
    atomic_store(&thread->killed, false);
    thread->killable = true;
    thread->entry = entry;
    thread->data = data;
    thread->wait.addr = NULL;
    vlc_mutex_init(&thread->wait.lock);

    pthread_attr_t attr;
    pthread_attr_init (&attr);
    pthread_attr_setdetachstate (&attr, detach ? PTHREAD_CREATE_DETACHED
                                               : PTHREAD_CREATE_JOINABLE);

    ret = pthread_create (&thread->thread, &attr,
            ...",1,,220,5,,void
1600,BLOCK,-1,,<empty>,9,,223,2,,void
1605,BLOCK,6,,"{
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }",5,,228,6,,void
1639,BLOCK,-1,,<empty>,9,,241,2,,void
1727,BLOCK,-1,,"{
    (void) priority;
    return vlc_clone_attr (th, entry, data, false);
}",1,,265,5,,void
1742,BLOCK,-1,,"{
    vlc_sem_wait (&handle->finished);
    vlc_sem_destroy (&handle->finished);

    int val = pthread_join (handle->thread, result);
    VLC_THREAD_ASSERT (""joining thread"");
    clean_detached_thread(handle);
}",1,,271,3,,void
1762,BLOCK,1,,<empty>,,,,3,,void
1764,BLOCK,-1,,"VLC_THREAD_ASSERT (""joining thread"")",5,,276,1,,void
1768,BLOCK,-1,,"VLC_THREAD_ASSERT (""joining thread"")",5,,276,2,,void
1788,BLOCK,-1,,"{
    vlc_thread_t dummy;
    if (th == NULL)
        th = &dummy;

    (void) priority;
    return vlc_clone_attr (th, entry, data, true);
}",1,,282,5,,void
1794,BLOCK,-1,,<empty>,9,,285,2,,void
1813,BLOCK,-1,,"{
    (void) th; (void) priority;
    return VLC_SUCCESS;
}",1,,292,3,,void
1826,BLOCK,-1,,"{
    atomic_int *addr;

    atomic_store(&thread_id->killed, true);

    vlc_mutex_lock(&thread_id->wait.lock);
    addr = thread_id->wait.addr;
    if (addr != NULL)
    {
        atomic_fetch_or_explicit(addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(addr);
    }
    vlc_mutex_unlock(&thread_id->wait.lock);
}",1,,298,2,,void
1852,BLOCK,-1,,"{
        atomic_fetch_or_explicit(addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(addr);
    }",5,,306,2,,void
1870,BLOCK,-1,,"{
    if (!thread) /* not created by VLC, can't be cancelled */
        return true;

    int oldstate = thread->killable;
    thread->killable = false;
    return oldstate;
}",1,,314,2,,void
1874,BLOCK,-1,,<empty>,9,,316,2,,void
1894,BLOCK,-1,,"{
    if (!thread) /* not created by VLC, can't be cancelled */
        return;

    thread->killable = state;
}",1,,324,2,,void
1898,BLOCK,-1,,<empty>,9,,326,2,,void
1909,BLOCK,-1,,"{
    if (!thread) /* not created by VLC, can't be cancelled */
        return;
    if (!thread->killable)
        return;
    if (!atomic_load(&thread->killed))
        return;

    pthread_exit(NULL);
}",1,,332,2,,void
1913,BLOCK,-1,,<empty>,9,,334,2,,void
1920,BLOCK,-1,,<empty>,9,,336,2,,void
1929,BLOCK,-1,,<empty>,9,,338,2,,void
1937,BLOCK,-1,,"{
    vlc_thread_t th = vlc_thread_self();
    va_list ap;

    if (th == NULL)
        return;

    va_start(ap, cmd);
    switch (cmd)
    {
        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == NULL);
            th->wait.addr = addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }

        case VLC_CANCEL_ADDR_CLEAR:
        {
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == addr);
            th->wait.addr = NULL;
            (void) addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }

        default:
            vlc_assert_unreachable ();
    }
    va_end(ap);
}",1,,344,2,,void
1947,BLOCK,-1,,<empty>,9,,349,2,,void
1954,BLOCK,-1,,"{
        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == NULL);
            th->wait.addr = addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }

        case VLC_CANCEL_ADDR_CLEAR:
        {
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == addr);
            th->wait.addr = NULL;
            (void) addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }

        default:
            vlc_assert_unreachable ();
    }",5,,353,2,,void
1957,BLOCK,3,,"{
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == NULL);
            th->wait.addr = addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }",9,,355,3,,void
1991,BLOCK,6,,"{
            void *addr = va_arg(ap, void *);

            vlc_mutex_lock(&th->wait.lock);
            assert(th->wait.addr == addr);
            th->wait.addr = NULL;
            (void) addr;
            vlc_mutex_unlock(&th->wait.lock);
            break;
        }",9,,366,6,,void
2035,BLOCK,-1,,"{
    return pthread_key_create (key, destr);
}",1,,386,3,,void
2044,BLOCK,-1,,"{
    pthread_key_delete (*p_tls);
}",1,,391,2,,void
2053,BLOCK,-1,,"{
    return pthread_setspecific (key, value);
}",1,,396,3,,void
2062,BLOCK,-1,,"{
    return pthread_getspecific (key);
}",1,,401,2,,void
2070,BLOCK,-1,,"{
    struct timespec ts;

    if (unlikely(clock_gettime (CLOCK_MONOTONIC, &ts) != 0))
        abort ();

    return (INT64_C(1000000) * ts.tv_sec) + (ts.tv_nsec / 1000);
}",1,,407,2,,void
2080,BLOCK,-1,,<empty>,9,,411,2,,void
2099,BLOCK,-1,,"{
    return sysconf(_SC_NPROCESSORS_ONLN);
}",1,,419,2,,void
2113,BLOCK,-1,,<empty>,1,,1,1,,ANY
2119,BLOCK,-1,,<empty>,,,,1,,<empty>
2175,BLOCK,-1,,"{
    return &((aout_instance_t *)aout)->owner;
}",1,,106,2,,void
2188,BLOCK,-1,,<empty>,,,,3,,<empty>
2194,BLOCK,-1,,<empty>,,,,3,,<empty>
2200,BLOCK,-1,,<empty>,,,,3,,<empty>
2206,BLOCK,-1,,<empty>,,,,3,,<empty>
2211,BLOCK,-1,,<empty>,,,,2,,<empty>
2216,BLOCK,-1,,<empty>,,,,2,,<empty>
2221,BLOCK,-1,,<empty>,,,,2,,<empty>
2228,BLOCK,-1,,<empty>,,,,4,,<empty>
2234,BLOCK,-1,,<empty>,,,,3,,<empty>
2240,BLOCK,-1,,<empty>,,,,3,,<empty>
2247,BLOCK,-1,,<empty>,,,,4,,<empty>
2253,BLOCK,-1,,<empty>,,,,3,,<empty>
2258,BLOCK,-1,,<empty>,,,,2,,<empty>
2263,BLOCK,-1,,<empty>,,,,2,,<empty>
2268,BLOCK,-1,,<empty>,,,,2,,<empty>
2276,BLOCK,-1,,<empty>,,,,5,,<empty>
2285,BLOCK,-1,,<empty>,,,,6,,<empty>
2293,BLOCK,-1,,<empty>,,,,5,,<empty>
2298,BLOCK,-1,,<empty>,,,,2,,<empty>
2305,BLOCK,-1,,<empty>,,,,4,,<empty>
2312,BLOCK,-1,,<empty>,,,,4,,<empty>
2319,BLOCK,-1,,<empty>,,,,4,,<empty>
2325,BLOCK,-1,,<empty>,,,,3,,<empty>
2331,BLOCK,-1,,<empty>,,,,3,,<empty>
2336,BLOCK,-1,,"{
    aout_RequestRestart(aout, AOUT_RESTART_FILTERS);
}",1,,163,2,,void
2344,BLOCK,-1,,"{
    static const uint32_t wave_channels[] = {
        AOUT_CHAN_LEFT, AOUT_CHAN_RIGHT, AOUT_CHAN_CENTER,
        AOUT_CHAN_LFE, AOUT_CHAN_REARLEFT, AOUT_CHAN_REARRIGHT,
        AOUT_CHAN_MIDDLELEFT, AOUT_CHAN_MIDDLERIGHT, AOUT_CHAN_REARCENTER };

    fmt->i_physical_channels = 0;
    for (int i = 0; i < fmt->i_channels && i < AOUT_CHAN_MAX; ++i)
        fmt->i_physical_channels |= wave_channels[i];
    aout_FormatPrepare(fmt);
}",1,,168,2,,void
2364,BLOCK,-1,,<empty>,5,,175,1,,void
2393,BLOCK,-1,,<empty>,,,,2,,<empty>
2399,BLOCK,-1,,<empty>,,,,3,,<empty>
2418,BLOCK,-1,,<empty>,1,,1,1,,ANY
2421,BLOCK,-1,,"{
    switch( vlc_fourcc_GetCodec( AUDIO_ES, i_format ) )
    {
    case VLC_CODEC_U8:
    case VLC_CODEC_S8:
    case VLC_CODEC_ALAW:
    case VLC_CODEC_MULAW:
        return 8;

    case VLC_CODEC_U16L:
    case VLC_CODEC_S16L:
    case VLC_CODEC_U16B:
    case VLC_CODEC_S16B:
        return 16;

    case VLC_CODEC_U24L:
    case VLC_CODEC_S24L:
    case VLC_CODEC_U24B:
    case VLC_CODEC_S24B:
        return 24;

    case VLC_CODEC_S24L32:
    case VLC_CODEC_S24B32:
    case VLC_CODEC_U32L:
    case VLC_CODEC_U32B:
    case VLC_CODEC_S32L:
    case VLC_CODEC_S32B:
    case VLC_CODEC_F32L:
    case VLC_CODEC_F32B:
        return 32;

    case VLC_CODEC_F64L:
    case VLC_CODEC_F64B:
        return 64;

    default:
        /* For these formats the caller has to indicate the parameters
         * by hand. */
        return 0;
    }
}",1,,43,2,,void
2426,BLOCK,-1,,"{
    case VLC_CODEC_U8:
    case VLC_CODEC_S8:
    case VLC_CODEC_ALAW:
    case VLC_CODEC_MULAW:
        return 8;

    case VLC_CODEC_U16L:
    case VLC_CODEC_S16L:
    case VLC_CODEC_U16B:
    case VLC_CODEC_S16B:
        return 16;

    case VLC_CODEC_U24L:
    case VLC_CODEC_S24L:
    case VLC_CODEC_U24B:
    case VLC_CODEC_S24B:
        return 24;

    case VLC_CODEC_S24L32:
    case VLC_CODEC_S24B32:
    case VLC_CODEC_U32L:
    case VLC_CODEC_U32B:
    case VLC_CODEC_S32L:
    case VLC_CODEC_S32B:
    case VLC_CODEC_F32L:
    case VLC_CODEC_F32B:
        return 32;

    case VLC_CODEC_F64L:
    case VLC_CODEC_F64B:
        return 64;

    default:
        /* For these formats the caller has to indicate the parameters
         * by hand. */
        return 0;
    }",5,,45,2,,void
2488,BLOCK,-1,,"{

    unsigned i_channels = aout_FormatNbChannels( p_format );
    if( i_channels > 0 )
        p_format->i_channels = i_channels;
    p_format->i_bitspersample = aout_BitsPerSample( p_format->i_format );
    if( p_format->i_bitspersample > 0 )
    {
        p_format->i_bytes_per_frame = ( p_format->i_bitspersample / 8 )
                                    * p_format->i_channels;
        p_format->i_frame_length = 1;
    }
}",1,,89,2,,void
2498,BLOCK,-1,,<empty>,9,,93,2,,void
2518,BLOCK,-1,,"{
        p_format->i_bytes_per_frame = ( p_format->i_bitspersample / 8 )
                                    * p_format->i_channels;
        p_format->i_frame_length = 1;
    }",5,,96,2,,void
2541,BLOCK,-1,,"{
    if (p_format->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        return ""Ambisonics"";

    /* AUDIO_CHANNEL_TYPE_BITMAP */
    switch ( p_format->i_physical_channels )
    {
    case AOUT_CHAN_LEFT:
    case AOUT_CHAN_RIGHT:
    case AOUT_CHAN_CENTER:
        if ( (p_format->i_physical_channels & AOUT_CHAN_CENTER)
              || (p_format->i_physical_channels
                   & (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
            return ""Mono"";
        else if ( p_format->i_physical_channels & AOUT_CHAN_LEFT )
            return ""Left"";
        return ""Right"";
    case AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT:
        if ( p_format->i_chan_mode & AOUT_CHANMODE_DOLBYSTEREO )
            return ""Dolby"";
        else if ( p_format->i_chan_mode & AOUT_CHANMODE_DUALMONO )
            return ""Dual-mono"";
        else if ( p_format->i_physical_channels == AOUT_CHAN_CENTER )
            return ""Stereo/Mono"";
        else if ( !(p_format->i_physical_channels & AOUT_CHAN_RIGHT) )
         ...",1,,107,2,,void
2548,BLOCK,-1,,<empty>,9,,109,2,,void
2555,BLOCK,-1,,"{
    case AOUT_CHAN_LEFT:
    case AOUT_CHAN_RIGHT:
    case AOUT_CHAN_CENTER:
        if ( (p_format->i_physical_channels & AOUT_CHAN_CENTER)
              || (p_format->i_physical_channels
                   & (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
            return ""Mono"";
        else if ( p_format->i_physical_channels & AOUT_CHAN_LEFT )
            return ""Left"";
        return ""Right"";
    case AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT:
        if ( p_format->i_chan_mode & AOUT_CHANMODE_DOLBYSTEREO )
            return ""Dolby"";
        else if ( p_format->i_chan_mode & AOUT_CHANMODE_DUALMONO )
            return ""Dual-mono"";
        else if ( p_format->i_physical_channels == AOUT_CHAN_CENTER )
            return ""Stereo/Mono"";
        else if ( !(p_format->i_physical_channels & AOUT_CHAN_RIGHT) )
            return ""Stereo/Left"";
        else if ( !(p_format->i_physical_channels & AOUT_CHAN_LEFT) )
            return ""Stereo/Right"";
        return ""Stereo"";
    case AOUT_CHAN_LEFT | A...",5,,113,2,,void
2576,BLOCK,-1,,<empty>,13,,120,2,,void
2580,BLOCK,-1,,<empty>,14,,121,1,,void
2587,BLOCK,-1,,<empty>,13,,122,2,,void
2602,BLOCK,-1,,<empty>,13,,126,2,,void
2606,BLOCK,-1,,<empty>,14,,127,1,,void
2613,BLOCK,-1,,<empty>,13,,128,2,,void
2617,BLOCK,-1,,<empty>,14,,129,1,,void
2624,BLOCK,-1,,<empty>,13,,130,2,,void
2628,BLOCK,-1,,<empty>,14,,131,1,,void
2636,BLOCK,-1,,<empty>,13,,132,2,,void
2640,BLOCK,-1,,<empty>,14,,133,1,,void
2648,BLOCK,-1,,<empty>,13,,134,2,,void
2741,BLOCK,-1,,<empty>,13,,160,2,,void
2745,BLOCK,-1,,<empty>,14,,161,1,,void
2752,BLOCK,-1,,<empty>,13,,162,2,,void
2769,BLOCK,-1,,<empty>,13,,166,2,,void
2773,BLOCK,-1,,<empty>,14,,167,1,,void
2780,BLOCK,-1,,<empty>,13,,168,2,,void
2784,BLOCK,-1,,<empty>,14,,169,1,,void
2791,BLOCK,-1,,<empty>,13,,170,2,,void
2795,BLOCK,-1,,<empty>,14,,171,1,,void
2803,BLOCK,-1,,<empty>,13,,172,2,,void
2807,BLOCK,-1,,<empty>,14,,173,1,,void
2815,BLOCK,-1,,<empty>,13,,174,2,,void
3012,BLOCK,-1,,"{
    msg_Dbg( obj, ""%s '%4.4s' %d Hz %s frame=%d samples/%d bytes"", psz_text,
             (char *)&p_format->i_format, p_format->i_rate,
             aout_FormatPrintChannels( p_format ),
             p_format->i_frame_length, p_format->i_bytes_per_frame );
}",1,,231,4,,void
3041,BLOCK,-1,,"{
    msg_Dbg( obj, ""%s '%4.4s'->'%4.4s' %d Hz->%d Hz %s->%s"",
             psz_text,
             (char *)&p_format1->i_format, (char *)&p_format2->i_format,
             p_format1->i_rate, p_format2->i_rate,
             aout_FormatPrintChannels( p_format1 ),
             aout_FormatPrintChannels( p_format2 ) );
}",1,,245,5,,void
3075,BLOCK,-1,,"{
    static_assert(AOUT_CHAN_MAX <= (sizeof (mask) * CHAR_BIT), ""Missing bits"");

    unsigned channels = 0;

    if( chans_in == NULL )
        chans_in = pi_vlc_chan_order_wg4;
    if( chans_out == NULL )
        chans_out = pi_vlc_chan_order_wg4;

    for( unsigned i = 0; chans_in[i]; i++ )
    {
        const uint32_t chan = chans_in[i];
        if( !(mask & chan) )
            continue;

        unsigned index = 0;
        for( unsigned j = 0; chan != chans_out[j]; j++ )
            if( mask & chans_out[j] )
                index++;

        table[channels++] = index;
    }

    for( unsigned i = 0; i < channels; i++ )
        if( table[i] != i )
            return channels;
    return 0;
}",1,,260,5,,void
3092,BLOCK,-1,,<empty>,9,,266,2,,void
3100,BLOCK,-1,,<empty>,9,,268,2,,void
3105,BLOCK,-1,,<empty>,5,,270,1,,void
3115,BLOCK,4,,"{
        const uint32_t chan = chans_in[i];
        if( !(mask & chan) )
            continue;

        unsigned index = 0;
        for( unsigned j = 0; chan != chans_out[j]; j++ )
            if( mask & chans_out[j] )
                index++;

        table[channels++] = index;
    }",5,,271,4,,void
3127,BLOCK,-1,,<empty>,13,,274,2,,void
3134,BLOCK,-1,,<empty>,9,,277,1,,void
3152,BLOCK,-1,,<empty>,17,,279,2,,void
3162,BLOCK,-1,,<empty>,5,,284,1,,void
3178,BLOCK,-1,,<empty>,13,,286,2,,void
3191,BLOCK,-1,,"{
    if( unlikely(bytes == 0) )
        return;

    assert( channels != 0 );

    /* The audio formats supported in audio output are inlined. For other
     * formats (used in demuxers and muxers), memcpy() is used to avoid
     * breaking type punning. */
#define REORDER_TYPE(type) \
do { \
    const size_t frames = (bytes / sizeof (type)) / channels; \
    type *buf = ptr; \
\
    for( size_t i = 0; i < frames; i++ ) \
    { \
        type tmp[AOUT_CHAN_MAX]; \
\
        for( size_t j = 0; j < channels; j++ ) \
            tmp[chans_table[j]] = buf[j]; \
        memcpy( buf, tmp, sizeof (type) * channels ); \
        buf += channels; \
    } \
} while(0)

    if( likely(channels <= AOUT_CHAN_MAX) )
    {
        switch( fourcc )
        {
            case VLC_CODEC_U8:   REORDER_TYPE(uint8_t); return;
            case VLC_CODEC_S16N: REORDER_TYPE(int16_t); return;
            case VLC_CODEC_FL32: REORDER_TYPE(float);   return;
            case VLC_CODEC_S32N: REORDER_TYPE(int32_...",1,,303,6,,void
3197,BLOCK,-1,,<empty>,9,,305,2,,void
3208,BLOCK,-1,,"{
        switch( fourcc )
        {
            case VLC_CODEC_U8:   REORDER_TYPE(uint8_t); return;
            case VLC_CODEC_S16N: REORDER_TYPE(int16_t); return;
            case VLC_CODEC_FL32: REORDER_TYPE(float);   return;
            case VLC_CODEC_S32N: REORDER_TYPE(int32_t); return;
            case VLC_CODEC_FL64: REORDER_TYPE(double);  return;
        }
    }",5,,329,2,,void
3211,BLOCK,-1,,"{
            case VLC_CODEC_U8:   REORDER_TYPE(uint8_t); return;
            case VLC_CODEC_S16N: REORDER_TYPE(int16_t); return;
            case VLC_CODEC_FL32: REORDER_TYPE(float);   return;
            case VLC_CODEC_S32N: REORDER_TYPE(int32_t); return;
            case VLC_CODEC_FL64: REORDER_TYPE(double);  return;
        }",9,,331,2,,void
3219,BLOCK,1,,<empty>,,,,8,,void
3221,BLOCK,-1,,REORDER_TYPE(uint8_t),34,,332,1,,void
3236,BLOCK,-1,,<empty>,34,,332,1,,void
3246,BLOCK,4,,REORDER_TYPE(uint8_t),34,,332,4,,void
3249,BLOCK,-1,,<empty>,34,,332,1,,void
3287,BLOCK,1,,<empty>,,,,8,,void
3289,BLOCK,-1,,REORDER_TYPE(int16_t),34,,333,1,,void
3304,BLOCK,-1,,<empty>,34,,333,1,,void
3314,BLOCK,4,,REORDER_TYPE(int16_t),34,,333,4,,void
3317,BLOCK,-1,,<empty>,34,,333,1,,void
3355,BLOCK,1,,<empty>,,,,8,,void
3357,BLOCK,-1,,REORDER_TYPE(float),34,,334,1,,void
3372,BLOCK,-1,,<empty>,34,,334,1,,void
3382,BLOCK,4,,REORDER_TYPE(float),34,,334,4,,void
3385,BLOCK,-1,,<empty>,34,,334,1,,void
3423,BLOCK,1,,<empty>,,,,8,,void
3425,BLOCK,-1,,REORDER_TYPE(int32_t),34,,335,1,,void
3440,BLOCK,-1,,<empty>,34,,335,1,,void
3450,BLOCK,4,,REORDER_TYPE(int32_t),34,,335,4,,void
3453,BLOCK,-1,,<empty>,34,,335,1,,void
3491,BLOCK,1,,<empty>,,,,8,,void
3493,BLOCK,-1,,REORDER_TYPE(double),34,,336,1,,void
3508,BLOCK,-1,,<empty>,34,,336,1,,void
3518,BLOCK,4,,REORDER_TYPE(double),34,,336,4,,void
3521,BLOCK,-1,,<empty>,34,,336,1,,void
3580,BLOCK,-1,,<empty>,5,,346,1,,void
3590,BLOCK,4,,"{
        unsigned char tmp[256 * 8];

        for( size_t j = 0; j < channels; j++ )
             memcpy( tmp + size * chans_table[j], buf + size * j, size );
         memcpy( buf, tmp, size * channels );
         buf += size * channels;
    }",5,,347,4,,void
3593,BLOCK,-1,,<empty>,9,,350,1,,void
3636,BLOCK,-1,,"{
#define INTERLEAVE_TYPE(type) \
do { \
    type *d = dst; \
    for( size_t i = 0; i < chans; i++ ) { \
        const type *s = srcv[i]; \
        for( size_t j = 0, k = 0; j < samples; j++, k += chans ) \
            d[k] = *(s++); \
        d++; \
    } \
} while(0)

    switch( fourcc )
    {
        case VLC_CODEC_U8:   INTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: INTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: INTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: INTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: INTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }
#undef INTERLEAVE_TYPE
}",1,,369,6,,void
3639,BLOCK,-1,,"{
        case VLC_CODEC_U8:   INTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: INTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: INTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: INTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: INTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }",5,,382,2,,void
3645,BLOCK,1,,<empty>,,,,4,,void
3647,BLOCK,-1,,INTERLEAVE_TYPE(uint8_t),30,,383,1,,void
3653,BLOCK,-1,,<empty>,30,,383,1,,void
3663,BLOCK,4,,INTERLEAVE_TYPE(uint8_t),30,,383,4,,void
3671,BLOCK,-1,,<empty>,30,,383,1,,void
3705,BLOCK,1,,<empty>,,,,4,,void
3707,BLOCK,-1,,INTERLEAVE_TYPE(int16_t),30,,384,1,,void
3713,BLOCK,-1,,<empty>,30,,384,1,,void
3723,BLOCK,4,,INTERLEAVE_TYPE(int16_t),30,,384,4,,void
3731,BLOCK,-1,,<empty>,30,,384,1,,void
3765,BLOCK,1,,<empty>,,,,4,,void
3767,BLOCK,-1,,INTERLEAVE_TYPE(float),30,,385,1,,void
3773,BLOCK,-1,,<empty>,30,,385,1,,void
3783,BLOCK,4,,INTERLEAVE_TYPE(float),30,,385,4,,void
3791,BLOCK,-1,,<empty>,30,,385,1,,void
3825,BLOCK,1,,<empty>,,,,4,,void
3827,BLOCK,-1,,INTERLEAVE_TYPE(int32_t),30,,386,1,,void
3833,BLOCK,-1,,<empty>,30,,386,1,,void
3843,BLOCK,4,,INTERLEAVE_TYPE(int32_t),30,,386,4,,void
3851,BLOCK,-1,,<empty>,30,,386,1,,void
3885,BLOCK,1,,<empty>,,,,4,,void
3887,BLOCK,-1,,INTERLEAVE_TYPE(double),30,,387,1,,void
3893,BLOCK,-1,,<empty>,30,,387,1,,void
3903,BLOCK,4,,INTERLEAVE_TYPE(double),30,,387,4,,void
3911,BLOCK,-1,,<empty>,30,,387,1,,void
3950,BLOCK,-1,,"{
#define DEINTERLEAVE_TYPE(type) \
do { \
    type *d = dst; \
    const type *s = src; \
    for( size_t i = 0; i < chans; i++ ) { \
        for( size_t j = 0, k = 0; j < samples; j++, k += chans ) \
            *(d++) = s[k]; \
        s++; \
    } \
} while(0)

    switch( fourcc )
    {
        case VLC_CODEC_U8:   DEINTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: DEINTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: DEINTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: DEINTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: DEINTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }
#undef DEINTERLEAVE_TYPE
}",1,,405,6,,void
3953,BLOCK,-1,,"{
        case VLC_CODEC_U8:   DEINTERLEAVE_TYPE(uint8_t);  break;
        case VLC_CODEC_S16N: DEINTERLEAVE_TYPE(int16_t);  break;
        case VLC_CODEC_FL32: DEINTERLEAVE_TYPE(float);    break;
        case VLC_CODEC_S32N: DEINTERLEAVE_TYPE(int32_t);  break;
        case VLC_CODEC_FL64: DEINTERLEAVE_TYPE(double);   break;
        default:             vlc_assert_unreachable();
    }",5,,418,2,,void
3959,BLOCK,1,,<empty>,,,,4,,void
3961,BLOCK,-1,,DEINTERLEAVE_TYPE(uint8_t),30,,419,1,,void
3971,BLOCK,-1,,<empty>,30,,419,1,,void
3981,BLOCK,4,,DEINTERLEAVE_TYPE(uint8_t),30,,419,4,,void
3983,BLOCK,-1,,<empty>,30,,419,1,,void
4017,BLOCK,1,,<empty>,,,,4,,void
4019,BLOCK,-1,,DEINTERLEAVE_TYPE(int16_t),30,,420,1,,void
4029,BLOCK,-1,,<empty>,30,,420,1,,void
4039,BLOCK,4,,DEINTERLEAVE_TYPE(int16_t),30,,420,4,,void
4041,BLOCK,-1,,<empty>,30,,420,1,,void
4075,BLOCK,1,,<empty>,,,,4,,void
4077,BLOCK,-1,,DEINTERLEAVE_TYPE(float),30,,421,1,,void
4087,BLOCK,-1,,<empty>,30,,421,1,,void
4097,BLOCK,4,,DEINTERLEAVE_TYPE(float),30,,421,4,,void
4099,BLOCK,-1,,<empty>,30,,421,1,,void
4133,BLOCK,1,,<empty>,,,,4,,void
4135,BLOCK,-1,,DEINTERLEAVE_TYPE(int32_t),30,,422,1,,void
4145,BLOCK,-1,,<empty>,30,,422,1,,void
4155,BLOCK,4,,DEINTERLEAVE_TYPE(int32_t),30,,422,4,,void
4157,BLOCK,-1,,<empty>,30,,422,1,,void
4191,BLOCK,1,,<empty>,,,,4,,void
4193,BLOCK,-1,,DEINTERLEAVE_TYPE(double),30,,423,1,,void
4203,BLOCK,-1,,<empty>,30,,423,1,,void
4213,BLOCK,4,,DEINTERLEAVE_TYPE(double),30,,423,4,,void
4215,BLOCK,-1,,<empty>,30,,423,1,,void
4256,BLOCK,-1,,"{
    for( int i = 0; i < i_sample_count; i++ )
    {
        for( int j = 0; j < i_dst_channels; j++ )
            memcpy( &pi_dst[j * i_bytes], &pi_src[pi_selection[j] * i_bytes], i_bytes );
        pi_dst += i_dst_channels * i_bytes;
        pi_src += i_src_channels * i_bytes;
    }
}",1,,436,8,,void
4258,BLOCK,-1,,<empty>,5,,437,1,,void
4268,BLOCK,4,,"{
        for( int j = 0; j < i_dst_channels; j++ )
            memcpy( &pi_dst[j * i_bytes], &pi_src[pi_selection[j] * i_bytes], i_bytes );
        pi_dst += i_dst_channels * i_bytes;
        pi_src += i_src_channels * i_bytes;
    }",5,,438,4,,void
4270,BLOCK,-1,,<empty>,9,,439,1,,void
4316,BLOCK,-1,,"{
    /* It does not work in place */
    assert( p_dst != p_src );

    /* Force the compiler to inline for the specific cases so it can optimize */
    if( i_bits_per_sample == 8 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 1 );
    else  if( i_bits_per_sample == 16 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 2 );
    else  if( i_bits_per_sample == 32 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 4 );
    else  if( i_bits_per_sample == 64 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 8 );
}",1,,449,8,,void
4325,BLOCK,-1,,<empty>,9,,455,2,,void
4335,BLOCK,-1,,<empty>,11,,456,1,,void
4340,BLOCK,-1,,<empty>,9,,457,2,,void
4350,BLOCK,-1,,<empty>,11,,458,1,,void
4355,BLOCK,-1,,<empty>,9,,459,2,,void
4365,BLOCK,-1,,<empty>,11,,460,1,,void
4370,BLOCK,-1,,<empty>,9,,461,2,,void
4388,BLOCK,-1,,"{
    static_assert(AOUT_CHAN_MAX <= (sizeof (*pi_order_dst) * CHAR_BIT),
                  ""Missing bits"");

    uint32_t i_layout = 0;
    int i_out = 0;
    int pi_index[AOUT_CHAN_MAX];

    /* */
    if( !pi_order_dst )
        pi_order_dst = pi_vlc_chan_order_wg4;

    /* */
    for( int i = 0; i < i_channels; i++ )
    {
        /* Ignore unknown or duplicated channels or not present in output */
        if( !pi_order_src[i] || (i_layout & pi_order_src[i]) )
            continue;

        for( int j = 0; j < AOUT_CHAN_MAX; j++ )
        {
            if( pi_order_dst[j] == pi_order_src[i] )
            {
                assert( i_out < AOUT_CHAN_MAX );
                pi_index[i_out++] = i;
                i_layout |= pi_order_src[i];
                break;
            }
        }
    }

    /* */
    for( int i = 0, j = 0; i < AOUT_CHAN_MAX; i++ )
    {
        for( int k = 0; k < i_out; k++ )
        {
            if( pi_order_dst[i] == pi_order_src[pi_index[k]] )
          ...",1,,468,7,,void
4410,BLOCK,-1,,<empty>,9,,478,2,,void
4415,BLOCK,-1,,<empty>,5,,481,1,,void
4425,BLOCK,4,,"{
        /* Ignore unknown or duplicated channels or not present in output */
        if( !pi_order_src[i] || (i_layout & pi_order_src[i]) )
            continue;

        for( int j = 0; j < AOUT_CHAN_MAX; j++ )
        {
            if( pi_order_dst[j] == pi_order_src[i] )
            {
                assert( i_out < AOUT_CHAN_MAX );
                pi_index[i_out++] = i;
                i_layout |= pi_order_src[i];
                break;
            }
        }
    }",5,,482,4,,void
4437,BLOCK,-1,,<empty>,13,,485,2,,void
4440,BLOCK,-1,,<empty>,9,,487,1,,void
4450,BLOCK,4,,"{
            if( pi_order_dst[j] == pi_order_src[i] )
            {
                assert( i_out < AOUT_CHAN_MAX );
                pi_index[i_out++] = i;
                i_layout |= pi_order_src[i];
                break;
            }
        }",9,,488,4,,void
4459,BLOCK,-1,,"{
                assert( i_out < AOUT_CHAN_MAX );
                pi_index[i_out++] = i;
                i_layout |= pi_order_src[i];
                break;
            }",13,,490,2,,void
4477,BLOCK,-1,,<empty>,5,,500,1,,void
4491,BLOCK,4,,"{
        for( int k = 0; k < i_out; k++ )
        {
            if( pi_order_dst[i] == pi_order_src[pi_index[k]] )
            {
                pi_selection[j++] = pi_index[k];
                break;
            }
        }
    }",5,,501,4,,void
4493,BLOCK,-1,,<empty>,9,,502,1,,void
4503,BLOCK,4,,"{
            if( pi_order_dst[i] == pi_order_src[pi_index[k]] )
            {
                pi_selection[j++] = pi_index[k];
                break;
            }
        }",9,,503,4,,void
4514,BLOCK,-1,,"{
                pi_selection[j++] = pi_index[k];
                break;
            }",13,,505,2,,void
4533,BLOCK,-1,,<empty>,5,,515,1,,void
4543,BLOCK,4,,"{
        if( pi_selection[i] != i )
            return true;
    }",5,,516,4,,void
4550,BLOCK,-1,,<empty>,13,,518,2,,void
4561,BLOCK,-1,,"{
    static const struct {
        const char psz_name[10];
        int        i_order;
    } filter[] = {
        { ""equalizer"",  0 },
    };
    for( unsigned i = 0; i < ARRAY_SIZE(filter); i++ )
    {
        if( !strcmp( filter[i].psz_name, psz_name ) )
            return filter[i].i_order;
    }
    return INT_MAX;
}",1,,525,2,,void
4570,BLOCK,-1,,<empty>,5,,532,1,,void
4581,BLOCK,4,,"{
        if( !strcmp( filter[i].psz_name, psz_name ) )
            return filter[i].i_order;
    }",5,,533,4,,void
4591,BLOCK,-1,,<empty>,13,,535,2,,void
4608,BLOCK,-1,,"{
    if( *psz_name == '\0' )
        return false;

    char *psz_list;
    if( p_aout )
    {
        psz_list = var_GetString( p_aout, psz_variable );
    }
    else
    {
        psz_list = var_InheritString( p_obj, psz_variable );
    }

    /* Split the string into an array of filters */
    int i_count = 1;
    for( char *p = psz_list; p && *p; p++ )
        i_count += *p == ':';
    i_count += b_add;

    const char **ppsz_filter = calloc( i_count, sizeof(*ppsz_filter) );
    if( !ppsz_filter )
    {
        free( psz_list );
        return false;
    }
    bool b_present = false;
    i_count = 0;
    for( char *p = psz_list; p && *p; )
    {
        char *psz_end = strchr(p, ':');
        if( psz_end )
            *psz_end++ = '\0';
        else
            psz_end = p + strlen(p);
        if( *p )
        {
            b_present |= !strcmp( p, psz_name );
            ppsz_filter[i_count++] = p;
        }
        p = psz_end;
    }
    if( b_present == b_add )
    {
       ...",1,,546,6,,void
4614,BLOCK,-1,,<empty>,9,,548,2,,void
4620,BLOCK,-1,,"{
        psz_list = var_GetString( p_aout, psz_variable );
    }",5,,552,2,,void
4627,BLOCK,-1,,"{
        psz_list = var_InheritString( p_obj, psz_variable );
    }",5,,556,1,,void
4638,BLOCK,-1,,<empty>,5,,562,1,,void
4669,BLOCK,-1,,"{
        free( psz_list );
        return false;
    }",5,,568,2,,void
4682,BLOCK,-1,,<empty>,5,,574,1,,void
4691,BLOCK,4,,"{
        char *psz_end = strchr(p, ':');
        if( psz_end )
            *psz_end++ = '\0';
        else
            psz_end = p + strlen(p);
        if( *p )
        {
            b_present |= !strcmp( p, psz_name );
            ppsz_filter[i_count++] = p;
        }
        p = psz_end;
    }",5,,575,4,,void
4700,BLOCK,-1,,<empty>,13,,578,2,,void
4707,BLOCK,-1,,<empty>,13,,580,1,,void
4717,BLOCK,-1,,"{
            b_present |= !strcmp( p, psz_name );
            ppsz_filter[i_count++] = p;
        }",9,,582,2,,void
4737,BLOCK,-1,,"{
        free( ppsz_filter );
        free( psz_list );
        return false;
    }",5,,589,2,,void
4746,BLOCK,-1,,"{
        int i_order = FilterOrder( psz_name );
        int i;
        for( i = 0; i < i_count; i++ )
        {
            if( FilterOrder( ppsz_filter[i] ) > i_order )
                break;
        }
        if( i < i_count )
            memmove( &ppsz_filter[i+1], &ppsz_filter[i], (i_count - i) * sizeof(*ppsz_filter) );
        ppsz_filter[i] = psz_name;
        i_count++;
    }",5,,596,2,,void
4754,BLOCK,-1,,<empty>,9,,599,1,,void
4763,BLOCK,4,,"{
            if( FilterOrder( ppsz_filter[i] ) > i_order )
                break;
        }",9,,600,4,,void
4771,BLOCK,-1,,<empty>,17,,602,2,,void
4777,BLOCK,-1,,<empty>,13,,605,2,,void
4804,BLOCK,-1,,"{
        for( int i = 0; i < i_count; i++ )
        {
            if( !strcmp( ppsz_filter[i], psz_name ) )
                ppsz_filter[i] = """";
        }
    }",5,,610,1,,void
4806,BLOCK,-1,,<empty>,9,,611,1,,void
4816,BLOCK,4,,"{
            if( !strcmp( ppsz_filter[i], psz_name ) )
                ppsz_filter[i] = """";
        }",9,,612,4,,void
4824,BLOCK,-1,,<empty>,17,,614,2,,void
4835,BLOCK,-1,,<empty>,5,,618,1,,void
4864,BLOCK,-1,,"{
        free( ppsz_filter );
        free( psz_list );
        return false;
    }",5,,624,2,,void
4876,BLOCK,-1,,<empty>,5,,631,1,,void
4886,BLOCK,4,,"{
        if( *ppsz_filter[i] == '\0' )
            continue;
        if( *psz_new )
            strcat( psz_new, "":"" );
        strcat( psz_new, ppsz_filter[i] );
    }",5,,632,4,,void
4894,BLOCK,-1,,<empty>,13,,634,2,,void
4899,BLOCK,-1,,<empty>,13,,636,2,,void
4918,BLOCK,-1,,<empty>,9,,644,2,,void
4947,BLOCK,-1,,<empty>,1,,1,1,,ANY
4953,BLOCK,-1,,"{
    if( p_format->i_bitspersample > 0 )
    {
        /* Sanitize audio format, input need to have a valid physical channels
         * layout or a valid number of channels. */
        int i_map_channels = aout_FormatNbChannels( p_format );
        if( ( i_map_channels == 0 && p_format->i_channels == 0 )
           || i_map_channels > AOUT_CHAN_MAX || p_format->i_channels > INPUT_CHAN_MAX )
        {
            msg_Err( p_aout, ""invalid audio channels count"" );
            return -1;
        }
    }

    if( p_format->i_rate > 384000 )
    {
        msg_Err( p_aout, ""excessive audio sample frequency (%u)"",
                 p_format->i_rate );
        return -1;
    }
    if( p_format->i_rate < 4000 )
    {
        msg_Err( p_aout, ""too low audio sample frequency (%u)"",
                 p_format->i_rate );
        return -1;
    }

    aout_owner_t *owner = aout_owner(p_aout);

    /* TODO: reduce lock scope depending on decoder's real need */
    aout_OutputLock (p_aout);

    /*...",1,,47,5,,void
4960,BLOCK,-1,,"{
        /* Sanitize audio format, input need to have a valid physical channels
         * layout or a valid number of channels. */
        int i_map_channels = aout_FormatNbChannels( p_format );
        if( ( i_map_channels == 0 && p_format->i_channels == 0 )
           || i_map_channels > AOUT_CHAN_MAX || p_format->i_channels > INPUT_CHAN_MAX )
        {
            msg_Err( p_aout, ""invalid audio channels count"" );
            return -1;
        }
    }",5,,49,2,,void
4986,BLOCK,-1,,"{
            msg_Err( p_aout, ""invalid audio channels count"" );
            return -1;
        }",9,,55,2,,void
4999,BLOCK,-1,,"{
        msg_Err( p_aout, ""excessive audio sample frequency (%u)"",
                 p_format->i_rate );
        return -1;
    }",5,,62,2,,void
5015,BLOCK,-1,,"{
        msg_Err( p_aout, ""too low audio sample frequency (%u)"",
                 p_format->i_rate );
        return -1;
    }",5,,68,2,,void
5039,BLOCK,1,,<empty>,,,,3,,void
5077,BLOCK,1,,<empty>,34,,88,1,,void
5100,BLOCK,-1,,<empty>,9,,92,2,,void
5136,BLOCK,-1,,"{
        aout_OutputDelete (p_aout);
error:
        aout_volume_Delete (owner->volume);
        owner->volume = NULL;
        aout_OutputUnlock (p_aout);
        return -1;
    }",5,,100,2,,void
5203,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->mixer_format.i_format)
    {
        aout_FiltersDelete (aout, owner->filters);
        aout_OutputDelete (aout);
    }
    aout_volume_Delete (owner->volume);
    owner->volume = NULL;
    aout_OutputUnlock (aout);
}",1,,125,2,,void
5217,BLOCK,-1,,"{
        aout_FiltersDelete (aout, owner->filters);
        aout_OutputDelete (aout);
    }",5,,130,2,,void
5240,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    int status = AOUT_DEC_SUCCESS;
    int restart = atomic_exchange (&owner->restart, 0);
    if (unlikely(restart))
    {
        if (owner->mixer_format.i_format)
            aout_FiltersDelete (aout, owner->filters);

        if (restart & AOUT_RESTART_OUTPUT)
        {   /* Reinitializes the output */
            msg_Dbg (aout, ""restarting output..."");
            if (owner->mixer_format.i_format)
                aout_OutputDelete (aout);
            owner->mixer_format = owner->input_format;
            owner->filters_cfg = AOUT_FILTERS_CFG_INIT;
            if (aout_OutputNew (aout, &owner->mixer_format, &owner->filters_cfg))
                owner->mixer_format.i_format = 0;
            aout_volume_SetFormat (owner->volume,
                                   owner->mixer_format.i_format);

            /* Notify the decoder that the aout changed in order to try a new
             * suitable codec (like an HDMI audio format). Howe...",1,,140,2,,void
5250,BLOCK,1,,<empty>,,,,1,,void
5264,BLOCK,-1,,"{
        if (owner->mixer_format.i_format)
            aout_FiltersDelete (aout, owner->filters);

        if (restart & AOUT_RESTART_OUTPUT)
        {   /* Reinitializes the output */
            msg_Dbg (aout, ""restarting output..."");
            if (owner->mixer_format.i_format)
                aout_OutputDelete (aout);
            owner->mixer_format = owner->input_format;
            owner->filters_cfg = AOUT_FILTERS_CFG_INIT;
            if (aout_OutputNew (aout, &owner->mixer_format, &owner->filters_cfg))
                owner->mixer_format.i_format = 0;
            aout_volume_SetFormat (owner->volume,
                                   owner->mixer_format.i_format);

            /* Notify the decoder that the aout changed in order to try a new
             * suitable codec (like an HDMI audio format). However, keep the
             * same codec if the aout was restarted because of a stereo-mode
             * change from the user. */
            if (restart == AOUT_RESTART...",5,,146,2,,void
5271,BLOCK,-1,,<empty>,13,,148,2,,void
5281,BLOCK,-1,,"{   /* Reinitializes the output */
            msg_Dbg (aout, ""restarting output..."");
            if (owner->mixer_format.i_format)
                aout_OutputDelete (aout);
            owner->mixer_format = owner->input_format;
            owner->filters_cfg = AOUT_FILTERS_CFG_INIT;
            if (aout_OutputNew (aout, &owner->mixer_format, &owner->filters_cfg))
                owner->mixer_format.i_format = 0;
            aout_volume_SetFormat (owner->volume,
                                   owner->mixer_format.i_format);

            /* Notify the decoder that the aout changed in order to try a new
             * suitable codec (like an HDMI audio format). However, keep the
             * same codec if the aout was restarted because of a stereo-mode
             * change from the user. */
            if (restart == AOUT_RESTART_OUTPUT)
                status = AOUT_DEC_CHANGED;
        }",9,,151,2,,void
5291,BLOCK,-1,,<empty>,17,,154,2,,void
5317,BLOCK,-1,,<empty>,17,,158,2,,void
5338,BLOCK,-1,,<empty>,17,,167,2,,void
5342,BLOCK,1,,<empty>,,,,1,,void
5367,BLOCK,-1,,"{
            owner->filters = aout_FiltersNew (aout, &owner->input_format,
                                              &owner->mixer_format,
                                              &owner->request_vout,
                                              &owner->filters_cfg);
            if (owner->filters == NULL)
            {
                aout_OutputDelete (aout);
                owner->mixer_format.i_format = 0;
            }
        }",9,,175,2,,void
5396,BLOCK,-1,,"{
                aout_OutputDelete (aout);
                owner->mixer_format.i_format = 0;
            }",13,,181,2,,void
5415,BLOCK,1,,<empty>,,,,1,,void
5422,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);
    atomic_fetch_or (&owner->restart, mode);
    msg_Dbg (aout, ""restart requested (%u)"", mode);
}",1,,198,3,,void
5442,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    owner->sync.resamp_type = AOUT_RESAMPLING_NONE;
    aout_FiltersAdjustResampling (owner->filters, 0);
}",1,,209,2,,void
5466,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);
    const audio_sample_format_t *fmt = &owner->mixer_format;
    size_t frames = (fmt->i_rate * length) / CLOCK_FREQ;

    block_t *block = block_Alloc (frames * fmt->i_bytes_per_frame
                                  / fmt->i_frame_length);
    if (unlikely(block == NULL))
        return; /* uho! */

    msg_Dbg (aout, ""inserting %zu zeroes"", frames);
    memset (block->p_buffer, 0, block->i_buffer);
    block->i_nb_samples = frames;
    block->i_pts = pts;
    block->i_dts = pts;
    block->i_length = length;
    aout_OutputPlay (aout, block);
}",1,,217,4,,void
5507,BLOCK,-1,,<empty>,9,,225,2,,void
5550,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);
    mtime_t drift;

    /**
     * Depending on the drift between the actual and intended playback times,
     * the audio core may ignore the drift, trigger upsampling or downsampling,
     * insert silence or even discard samples.
     * Future VLC versions may instead adjust the input rate.
     *
     * The audio output plugin is responsible for estimating its actual
     * playback time, or rather the estimated time when the next sample will
     * be played. (The actual playback time is always the current time, that is
     * to say mdate(). It is not an useful statistic.)
     *
     * Most audio output plugins can estimate the delay until playback of
     * the next sample to be written to the buffer, or equally the time until
     * all samples in the buffer will have been played. Then:
     *    pts = mdate() + delay
     */
    if (aout_OutputTimeGet (aout, &drift) != 0)
        return; /* nothing can be done if timing is unk...",1,,238,4,,void
5564,BLOCK,-1,,<empty>,9,,259,2,,void
5589,BLOCK,-1,,"{
        if (!owner->sync.discontinuity)
            msg_Warn (aout, ""playback way too late (%""PRId64""): ""
                      ""flushing buffers"", drift);
        else
            msg_Dbg (aout, ""playback too late (%""PRId64""): ""
                     ""flushing buffers"", drift);
        aout_OutputFlush (aout, false);

        aout_StopResampling (aout);
        owner->sync.end = VLC_TS_INVALID;
        owner->sync.discontinuity = true;

        /* Now the output might be too early... Recheck. */
        if (aout_OutputTimeGet (aout, &drift) != 0)
            return; /* nothing can be done if timing is unknown */
        drift += mdate () - dec_pts;
    }",5,,270,2,,void
5618,BLOCK,-1,,<empty>,13,,285,2,,void
5643,BLOCK,-1,,"{
        if (!owner->sync.discontinuity)
            msg_Warn (aout, ""playback way too early (%""PRId64""): ""
                      ""playing silence"", drift);
        aout_DecSilence (aout, -drift, dec_pts);

        aout_StopResampling (aout);
        owner->sync.discontinuity = true;
        drift = 0;
    }",5,,293,2,,void
5668,BLOCK,-1,,<empty>,9,,305,2,,void
5683,BLOCK,-1,,"{
        msg_Warn (aout, ""playback too late (%""PRId64""): up-sampling"",
                  drift);
        owner->sync.resamp_type = AOUT_RESAMPLING_UP;
        owner->sync.resamp_start_drift = +drift;
    }",5,,310,2,,void
5713,BLOCK,-1,,"{
        msg_Warn (aout, ""playback too early (%""PRId64""): down-sampling"",
                  drift);
        owner->sync.resamp_type = AOUT_RESAMPLING_DOWN;
        owner->sync.resamp_start_drift = -drift;
    }",5,,318,2,,void
5738,BLOCK,-1,,<empty>,9,,326,2,,void
5751,BLOCK,-1,,"{   /* If the drift is ever increasing, then something is seriously wrong.
         * Cease resampling and hope for the best. */
        msg_Warn (aout, ""timing screwed (drift: %""PRId64"" us): ""
                  ""stopping resampling"", drift);
        aout_StopResampling (aout);
        return;
    }",5,,329,2,,void
5782,BLOCK,-1,,<empty>,9,,345,2,,void
5794,BLOCK,-1,,"{   /* Everything is back to normal: stop resampling. */
        owner->sync.resamp_type = AOUT_RESAMPLING_NONE;
        msg_Dbg (aout, ""resampling stopped (drift: %""PRId64"" us)"", drift);
    }",5,,348,2,,void
5809,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    assert (input_rate >= INPUT_RATE_DEFAULT / AOUT_MAX_INPUT_RATE);
    assert (input_rate <= INPUT_RATE_DEFAULT * AOUT_MAX_INPUT_RATE);
    assert (block->i_pts >= VLC_TS_0);

    block->i_length = CLOCK_FREQ * block->i_nb_samples
                                 / owner->input_format.i_rate;

    aout_OutputLock (aout);
    int ret = aout_CheckReady (aout);
    if (unlikely(ret == AOUT_DEC_FAILED))
        goto drop; /* Pipeline is unrecoverably broken :-( */

    const mtime_t now = mdate (), advance = block->i_pts - now;
    if (advance < -AOUT_MAX_PTS_DELAY)
    {   /* Late buffer can be caused by bugs in the decoder, by scheduling
         * latency spikes (excessive load, SIGSTOP, etc.) or if buffering is
         * insufficient. We assume the PTS is wrong and play the buffer anyway:
         * Hopefully video has encountered a similar PTS problem as audio. */
        msg_Warn (aout, ""buffer too late (%""PRId64"" us): dropped"", a...",1,,358,4,,void
5821,BLOCK,1,,<empty>,,,,1,,void
5829,BLOCK,1,,<empty>,,,,1,,void
5864,BLOCK,1,,<empty>,,,,1,,void
5866,BLOCK,-1,,<empty>,9,,371,2,,void
5885,BLOCK,-1,,"{   /* Late buffer can be caused by bugs in the decoder, by scheduling
         * latency spikes (excessive load, SIGSTOP, etc.) or if buffering is
         * insufficient. We assume the PTS is wrong and play the buffer anyway:
         * Hopefully video has encountered a similar PTS problem as audio. */
        msg_Warn (aout, ""buffer too late (%""PRId64"" us): dropped"", advance);
        goto drop;
    }",5,,375,2,,void
5892,BLOCK,-1,,"{   /* Early buffers can only be caused by bugs in the decoder. */
        msg_Err (aout, ""buffer too early (%""PRId64"" us): dropped"", advance);
        goto drop;
    }",5,,383,2,,void
5901,BLOCK,-1,,<empty>,9,,388,2,,void
5918,BLOCK,-1,,"{
        vlc_mutex_lock (&owner->vp.lock);
        aout_FiltersChangeViewpoint (owner->filters, &owner->vp.value);
        vlc_mutex_unlock (&owner->vp.lock);
    }",5,,391,2,,void
5955,BLOCK,-1,,<empty>,9,,399,2,,void
6028,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    *lost = atomic_exchange(&owner->buffers_lost, 0);
    *played = atomic_exchange(&owner->buffers_played, 0);
}",1,,425,4,,void
6058,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->sync.end != VLC_TS_INVALID)
    {
        if (paused)
            owner->sync.end -= date;
        else
            owner->sync.end += date;
    }
    if (owner->mixer_format.i_format)
        aout_OutputPause (aout, paused, date);
    aout_OutputUnlock (aout);
}",1,,433,4,,void
6074,BLOCK,-1,,"{
        if (paused)
            owner->sync.end -= date;
        else
            owner->sync.end += date;
    }",5,,438,2,,void
6077,BLOCK,-1,,<empty>,13,,440,2,,void
6086,BLOCK,-1,,<empty>,13,,442,1,,void
6100,BLOCK,-1,,<empty>,9,,445,2,,void
6112,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    owner->sync.end = VLC_TS_INVALID;
    if (owner->mixer_format.i_format)
    {
        if (wait)
        {
            block_t *block = aout_FiltersDrain (owner->filters);
            if (block)
                aout_OutputPlay (aout, block);
        }
        else
            aout_FiltersFlush (owner->filters);
        aout_OutputFlush (aout, wait);
    }
    aout_OutputUnlock (aout);
}",1,,450,3,,void
6133,BLOCK,-1,,"{
        if (wait)
        {
            block_t *block = aout_FiltersDrain (owner->filters);
            if (block)
                aout_OutputPlay (aout, block);
        }
        else
            aout_FiltersFlush (owner->filters);
        aout_OutputFlush (aout, wait);
    }",5,,456,2,,void
6136,BLOCK,-1,,"{
            block_t *block = aout_FiltersDrain (owner->filters);
            if (block)
                aout_OutputPlay (aout, block);
        }",9,,458,2,,void
6146,BLOCK,-1,,<empty>,17,,461,2,,void
6151,BLOCK,-1,,<empty>,13,,464,1,,void
6166,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->vp.lock);
    owner->vp.value = *p_viewpoint;
    atomic_store(&owner->vp.update, true);
    vlc_mutex_unlock (&owner->vp.lock);
}",1,,472,3,,void
6232,BLOCK,-1,,<empty>,1,,1,1,,ANY
6242,BLOCK,-1,,"{
    filter_t *filter = vlc_custom_create (obj, sizeof (*filter), type);
    if (unlikely(filter == NULL))
        return NULL;

    filter->owner.sys = owner;
    filter->p_cfg = cfg;
    filter->fmt_in.audio = *infmt;
    filter->fmt_in.i_codec = infmt->i_format;
    filter->fmt_out.audio = *outfmt;
    filter->fmt_out.i_codec = outfmt->i_format;

#ifndef NDEBUG
    /* Assure that infmt/oufmt are well prepared and that channels
     * configurations are valid*/
    if( infmt->i_physical_channels != 0 )
        assert( aout_FormatNbChannels( infmt ) == infmt->i_channels );
    if( outfmt->i_physical_channels != 0 )
        assert( aout_FormatNbChannels( outfmt ) == outfmt->i_channels );
#endif

    filter->p_module = module_need (filter, type, name, false);

#ifndef NDEBUG
    if (filter->p_module == NULL || const_fmt)
    {
        /* If probing failed, formats shall not have been modified. */
        assert (AOUT_FMTS_IDENTICAL(&filter->fmt_in.audio, infmt));
        assert (AOU...",1,,50,9,,void
6257,BLOCK,-1,,<empty>,9,,53,2,,void
6312,BLOCK,-1,,<empty>,9,,66,2,,void
6326,BLOCK,-1,,<empty>,9,,68,2,,void
6351,BLOCK,-1,,"{
        /* If probing failed, formats shall not have been modified. */
        assert (AOUT_FMTS_IDENTICAL(&filter->fmt_in.audio, infmt));
        assert (AOUT_FMTS_IDENTICAL(&filter->fmt_out.audio, outfmt));
    }",5,,75,2,,void
6376,BLOCK,-1,,"{
        vlc_object_release (filter);
        filter = NULL;
    }",5,,83,2,,void
6383,BLOCK,-1,,<empty>,9,,88,1,,void
6398,BLOCK,-1,,"{
    return CreateFilter (obj, ""audio converter"", NULL, NULL, infmt, outfmt,
                         NULL, true);
}",1,,95,4,,void
6415,BLOCK,-1,,"{
    return CreateFilter (obj, ""audio resampler"", ""$audio-resampler"", NULL,
                         infmt, outfmt, NULL, true);
}",1,,103,4,,void
6431,BLOCK,-1,,"{
    for( unsigned i = 0; i < n; i++ )
    {
        filter_t *p_filter = filters[i];

        module_unneed( p_filter, p_filter->p_module );
        vlc_object_release( p_filter );
    }
}",1,,112,3,,void
6433,BLOCK,-1,,<empty>,5,,113,1,,void
6443,BLOCK,4,,"{
        filter_t *p_filter = filters[i];

        module_unneed( p_filter, p_filter->p_module );
        vlc_object_release( p_filter );
    }",5,,114,4,,void
6463,BLOCK,-1,,"{
    audio_sample_format_t output = *fmt;

    assert (codec != fmt->i_format);
    output.i_format = codec;
    aout_FormatPrepare (&output);

    filter_t *filter = FindConverter (obj, fmt, &output);
    if (filter != NULL)
        *fmt = output;
    return filter;
}",1,,124,4,,void
6495,BLOCK,-1,,<empty>,9,,133,2,,void
6512,BLOCK,-1,,"{
    aout_FormatsPrint (obj, ""conversion:"", infmt, outfmt);
    max -= *count;
    filters += *count;

    /* There is a lot of second guessing on what the conversion plugins can
     * and cannot do. This seems hardly avoidable, the conversion problem need
     * to be reduced somehow. */
    audio_sample_format_t input = *infmt;
    unsigned n = 0;

    if (!AOUT_FMT_LINEAR(&input))
    {
        msg_Err(obj, ""Can't convert non linear input"");
        return -1;
    }

    /* Remix channels */
    if (infmt->i_physical_channels != outfmt->i_physical_channels
     || infmt->i_chan_mode != outfmt->i_chan_mode
     || infmt->channel_type != outfmt->channel_type)
    {   /* Remixing currently requires FL32... TODO: S16N */
        if (input.i_format != VLC_CODEC_FL32)
        {
            if (n == max)
                goto overflow;

            filter_t *f = TryFormat (obj, VLC_CODEC_FL32, &input);
            if (f == NULL)
            {
                msg_Err (obj, ""cannot find ...",1,,152,8,,void
6518,BLOCK,1,,<empty>,,,,5,,void
6547,BLOCK,-1,,"{
        msg_Err(obj, ""Can't convert non linear input"");
        return -1;
    }",5,,164,2,,void
6578,BLOCK,-1,,"{   /* Remixing currently requires FL32... TODO: S16N */
        if (input.i_format != VLC_CODEC_FL32)
        {
            if (n == max)
                goto overflow;

            filter_t *f = TryFormat (obj, VLC_CODEC_FL32, &input);
            if (f == NULL)
            {
                msg_Err (obj, ""cannot find %s for conversion pipeline"",
                         ""pre-mix converter"");
                goto error;
            }

            filters[n++] = f;
        }

        if (n == max)
            goto overflow;

        audio_sample_format_t output;
        output.i_format = input.i_format;
        output.i_rate = input.i_rate;
        output.i_physical_channels = outfmt->i_physical_channels;
        output.channel_type = outfmt->channel_type;
        output.i_chan_mode = outfmt->i_chan_mode;
        aout_FormatPrepare (&output);

        const char *filter_type =
            infmt->channel_type != outfmt->channel_type ?
            ""audio renderer"" : ""audio converter""...",5,,173,2,,void
6585,BLOCK,-1,,"{
            if (n == max)
                goto overflow;

            filter_t *f = TryFormat (obj, VLC_CODEC_FL32, &input);
            if (f == NULL)
            {
                msg_Err (obj, ""cannot find %s for conversion pipeline"",
                         ""pre-mix converter"");
                goto error;
            }

            filters[n++] = f;
        }",9,,175,2,,void
6590,BLOCK,-1,,<empty>,17,,177,2,,void
6604,BLOCK,-1,,"{
                msg_Err (obj, ""cannot find %s for conversion pipeline"",
                         ""pre-mix converter"");
                goto error;
            }",13,,181,2,,void
6620,BLOCK,-1,,<empty>,13,,191,2,,void
6680,BLOCK,-1,,<empty>,13,,207,2,,void
6701,BLOCK,-1,,<empty>,13,,211,2,,void
6708,BLOCK,-1,,"{
            msg_Err (obj, ""cannot find %s for conversion pipeline"",
                     ""remixer"");
            goto error;
        }",9,,214,2,,void
6731,BLOCK,-1,,"{   /* Resampling works with any linear format, but may be ugly. */
        if (n == max)
            goto overflow;

        audio_sample_format_t output = input;
        output.i_rate = outfmt->i_rate;

        filter_t *f = FindConverter (obj, &input, &output);
        if (f == NULL)
        {
            msg_Err (obj, ""cannot find %s for conversion pipeline"",
                     ""resampler"");
            goto error;
        }

        input = output;
        filters[n++] = f;
    }",5,,226,2,,void
6736,BLOCK,-1,,<empty>,13,,228,2,,void
6762,BLOCK,-1,,"{
            msg_Err (obj, ""cannot find %s for conversion pipeline"",
                     ""resampler"");
            goto error;
        }",9,,235,2,,void
6785,BLOCK,-1,,"{
        if (max == 0)
            goto overflow;

        filter_t *f = TryFormat (obj, outfmt->i_format, &input);
        if (f == NULL)
        {
            msg_Err (obj, ""cannot find %s for conversion pipeline"",
                     ""post-mix converter"");
            goto error;
        }
        filters[n++] = f;
    }",5,,247,2,,void
6790,BLOCK,-1,,<empty>,13,,249,2,,void
6806,BLOCK,-1,,"{
            msg_Err (obj, ""cannot find %s for conversion pipeline"",
                     ""post-mix converter"");
            goto error;
        }",9,,253,2,,void
6852,BLOCK,-1,,"{
    /* TODO: use filter chain */
    for (unsigned i = 0; (i < count) && (block != NULL); i++)
    {
        filter_t *filter = filters[i];

        /* Please note that p_block->i_nb_samples & i_buffer
         * shall be set by the filter plug-in. */
        block = filter->pf_audio_filter (filter, block);
    }
    return block;
}",1,,279,4,,void
6854,BLOCK,-1,,<empty>,5,,281,1,,void
6868,BLOCK,4,,"{
        filter_t *filter = filters[i];

        /* Please note that p_block->i_nb_samples & i_buffer
         * shall be set by the filter plug-in. */
        block = filter->pf_audio_filter (filter, block);
    }",5,,282,4,,void
6890,BLOCK,-1,,"{
    block_t *chain = NULL;

    for (unsigned i = 0; i < count; i++)
    {
        filter_t *filter = filters[i];

        block_t *block = filter_DrainAudio (filter);
        if (block)
        {
            /* If there is a drained block, filter it through the following
             * chain of filters  */
            if (i + 1 < count)
                block = aout_FiltersPipelinePlay (&filters[i + 1],
                                                  count - i - 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }
    }

    if (chain)
        return block_ChainGather(chain);
    else
        return NULL;
}",1,,298,3,,void
6896,BLOCK,-1,,<empty>,5,,301,1,,void
6906,BLOCK,4,,"{
        filter_t *filter = filters[i];

        block_t *block = filter_DrainAudio (filter);
        if (block)
        {
            /* If there is a drained block, filter it through the following
             * chain of filters  */
            if (i + 1 < count)
                block = aout_FiltersPipelinePlay (&filters[i + 1],
                                                  count - i - 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }
    }",5,,302,4,,void
6920,BLOCK,-1,,"{
            /* If there is a drained block, filter it through the following
             * chain of filters  */
            if (i + 1 < count)
                block = aout_FiltersPipelinePlay (&filters[i + 1],
                                                  count - i - 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }",9,,307,2,,void
6927,BLOCK,-1,,<empty>,17,,311,2,,void
6945,BLOCK,-1,,<empty>,17,,314,2,,void
6952,BLOCK,-1,,<empty>,9,,319,2,,void
6957,BLOCK,-1,,<empty>,9,,321,1,,void
6965,BLOCK,-1,,"{
    for (unsigned i = 0; i < count; i++)
        filter_Flush (filters[i]);
}",1,,329,3,,void
6967,BLOCK,-1,,<empty>,5,,330,1,,void
6987,BLOCK,-1,,"{
    for (unsigned i = 0; i < count; i++)
        filter_ChangeViewpoint (filters[i], vp);
}",1,,337,4,,void
6989,BLOCK,-1,,<empty>,5,,338,1,,void
7013,BLOCK,-1,,<empty>,,,,1,,<empty>
7016,BLOCK,1,,<empty>,,,,1,,void
7026,BLOCK,-1,,"{
    const char *mode = newval.psz_string;

    if (!*mode)
        mode = ""none"";
    /* FIXME: This ugly hack enforced by visual effect-list, as is the need for
     * separate ""visual"" (external) and ""audio-visual"" (internal) variables...
     * The visual plugin should have one submodule per effect instead. */
    if (strcasecmp (mode, ""none"") && strcasecmp (mode, ""goom"")
     && strcasecmp (mode, ""projectm"") && strcasecmp (mode, ""vsxu"")
     && strcasecmp (mode, ""glspectrum""))
    {
        var_Create (obj, ""effect-list"", VLC_VAR_STRING);
        var_SetString (obj, ""effect-list"", mode);
        mode = ""visual"";
    }

    var_SetString (obj, ""audio-visual"", mode);
    aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) oldval; (void) data;
    return VLC_SUCCESS;
}",1,,360,6,,void
7037,BLOCK,-1,,<empty>,9,,364,2,,void
7061,BLOCK,-1,,"{
        var_Create (obj, ""effect-list"", VLC_VAR_STRING);
        var_SetString (obj, ""effect-list"", mode);
        mode = ""visual"";
    }",5,,371,2,,void
7098,BLOCK,-1,,"{
    /* NOTE: This only works from aout_filters_t.
     * If you want to use visualization filters from another place, you will
     * need to add a new pf_aout_request_vout callback or store a pointer
     * to aout_request_vout_t inside filter_t (i.e. a level of indirection). */
    const aout_request_vout_t *req = filter->owner.sys;
    char *visual = var_InheritString (filter->obj.parent, ""audio-visual"");
    /* NOTE: Disable recycling to always close the filter vout because OpenGL
     * visualizations do not use this function to ask for a context. */
    bool recycle = false;
    free (visual);

    return req->pf_request_vout (req->p_private, vout, fmt, recycle);
}",1,,385,4,,void
7145,BLOCK,-1,,"{
    const unsigned max = sizeof (filters->tab) / sizeof (filters->tab[0]);
    if (filters->count >= max)
    {
        msg_Err (obj, ""maximum of %u filters reached"", max);
        return -1;
    }

    filter_t *filter = CreateFilter (obj, type, name,
                                     (void *)owner, infmt, outfmt, cfg, false);
    if (filter == NULL)
    {
        msg_Err (obj, ""cannot add user %s \""%s\"" (skipped)"", type, name);
        return -1;
    }

    /* convert to the filter input format if necessary */
    if (aout_FiltersPipelineCreate (obj, filters->tab, &filters->count,
                                    max - 1, infmt, &filter->fmt_in.audio, false))
    {
        msg_Err (filter, ""cannot add user %s \""%s\"" (skipped)"", type, name);
        module_unneed (filter, filter->p_module);
        vlc_object_release (filter);
        return -1;
    }

    assert (filters->count < max);
    filters->tab[filters->count] = filter;
    filters->count++;
    *infmt = filter->fm...",1,,405,9,,void
7166,BLOCK,-1,,"{
        msg_Err (obj, ""maximum of %u filters reached"", max);
        return -1;
    }",5,,408,2,,void
7192,BLOCK,-1,,"{
        msg_Err (obj, ""cannot add user %s \""%s\"" (skipped)"", type, name);
        return -1;
    }",5,,416,2,,void
7222,BLOCK,-1,,"{
        msg_Err (filter, ""cannot add user %s \""%s\"" (skipped)"", type, name);
        module_unneed (filter, filter->p_module);
        vlc_object_release (filter);
        return -1;
    }",5,,424,2,,void
7275,BLOCK,-1,,"{
    char *name;
    config_chain_t *cfg;

    /* The remap audio filter use a different order than wg4 */
    static const uint8_t wg4_to_remap[] = { 0, 2, 6, 7, 3, 5, 4, 1, 8 };
    int remap[AOUT_CHAN_MAX];
    bool needed = false;
    for (int i = 0; i < AOUT_CHAN_MAX; ++i)
    {
        if (wg4_remap[i] != i)
            needed = true;
        remap[i] = wg4_remap[i] >= 0 ? wg4_to_remap[wg4_remap[i]] : -1;
    }
    if (!needed)
        return 0;

    char *str;
    int ret = asprintf(&str, ""remap{channel-left=%d,channel-right=%d,""
                       ""channel-middleleft=%d,channel-middleright=%d,""
                       ""channel-rearleft=%d,channel-rearright=%d,""
                       ""channel-rearcenter=%d,channel-center=%d,""
                       ""channel-lfe=%d,normalize=false}"",
                       remap[0], remap[1], remap[2], remap[3], remap[4],
                       remap[5], remap[6], remap[7], remap[8]);
    if (ret == -1)
        return -1;

    free(config...",1,,442,6,,void
7297,BLOCK,-1,,<empty>,5,,450,1,,void
7307,BLOCK,4,,"{
        if (wg4_remap[i] != i)
            needed = true;
        remap[i] = wg4_remap[i] >= 0 ? wg4_to_remap[wg4_remap[i]] : -1;
    }",5,,451,4,,void
7314,BLOCK,-1,,<empty>,13,,453,2,,void
7338,BLOCK,-1,,<empty>,9,,457,2,,void
7381,BLOCK,-1,,<empty>,9,,468,2,,void
7400,BLOCK,-1,,<empty>,9,,472,2,,void
7413,BLOCK,-1,,<empty>,9,,475,1,,void
7424,BLOCK,-1,,<empty>,9,,480,2,,void
7437,BLOCK,-1,,"{
    aout_filters_t *filters = malloc (sizeof (*filters));
    if (unlikely(filters == NULL))
        return NULL;

    filters->rate_filter = NULL;
    filters->resampler = NULL;
    filters->resampling = 0;
    filters->count = 0;

    /* Prepare format structure */
    aout_FormatPrint (obj, ""input"", infmt);
    audio_sample_format_t input_format = *infmt;
    audio_sample_format_t output_format = *outfmt;

    /* Callbacks (before reading values and also before return statement) */
    if (request_vout != NULL)
        var_AddCallback (obj, ""visual"", VisualizationCallback, NULL);

    if (!AOUT_FMT_LINEAR(outfmt))
    {   /* Non-linear output: just convert formats, no filters/visu */
        if (!AOUT_FMTS_IDENTICAL(infmt, outfmt))
        {
            aout_FormatsPrint (obj, ""pass-through:"", infmt, outfmt);
            filters->tab[0] = FindConverter(obj, infmt, outfmt);
            if (filters->tab[0] == NULL)
            {
                msg_Err (obj, ""cannot setup pass-th...",1,,505,6,,void
7450,BLOCK,-1,,<empty>,9,,508,2,,void
7491,BLOCK,-1,,<empty>,9,,522,2,,void
7501,BLOCK,-1,,"{   /* Non-linear output: just convert formats, no filters/visu */
        if (!AOUT_FMTS_IDENTICAL(infmt, outfmt))
        {
            aout_FormatsPrint (obj, ""pass-through:"", infmt, outfmt);
            filters->tab[0] = FindConverter(obj, infmt, outfmt);
            if (filters->tab[0] == NULL)
            {
                msg_Err (obj, ""cannot setup pass-through"");
                goto error;
            }
            filters->count++;
        }
        return filters;
    }",5,,525,2,,void
7507,BLOCK,-1,,"{
            aout_FormatsPrint (obj, ""pass-through:"", infmt, outfmt);
            filters->tab[0] = FindConverter(obj, infmt, outfmt);
            if (filters->tab[0] == NULL)
            {
                msg_Err (obj, ""cannot setup pass-through"");
                goto error;
            }
            filters->count++;
        }",9,,527,2,,void
7513,BLOCK,1,,<empty>,,,,5,,void
7538,BLOCK,-1,,"{
                msg_Err (obj, ""cannot setup pass-through"");
                goto error;
            }",13,,531,2,,void
7554,BLOCK,-1,,"{
        msg_Warn (obj, ""No output channel mask, cannot setup filters"");
        goto error;
    }",5,,540,2,,void
7573,BLOCK,-1,,"{
        /* Do the channel type conversion before any filters since audio
         * converters and filters handle only AUDIO_CHANNEL_TYPE_BITMAP */

        /* convert to the output format (minus resampling) if necessary */
        output_format.i_rate = input_format.i_rate;
        if (aout_FiltersPipelineCreate (obj, filters->tab, &filters->count,
                                  AOUT_MAX_FILTERS, &input_format, &output_format,
                                  cfg->headphones))
        {
            msg_Warn (obj, ""cannot setup audio renderer pipeline"");
            /* Fallback to bitmap without any conversions */
            input_format.channel_type = AUDIO_CHANNEL_TYPE_BITMAP;
            aout_FormatPrepare(&input_format);
        }
        else
            input_format = output_format;
    }",5,,547,2,,void
7592,BLOCK,1,,<empty>,,,,1,,void
7601,BLOCK,-1,,"{
            msg_Warn (obj, ""cannot setup audio renderer pipeline"");
            /* Fallback to bitmap without any conversions */
            input_format.channel_type = AUDIO_CHANNEL_TYPE_BITMAP;
            aout_FormatPrepare(&input_format);
        }",9,,556,2,,void
7614,BLOCK,-1,,<empty>,13,,563,1,,void
7624,BLOCK,-1,,"{
        /* The input channel map is unknown, use the WAVE one and add a
         * converter that will drop extra channels that are not handled by VLC
         * */
        msg_Info(obj, ""unknown channel map, using the WAVE channel layout."");

        assert(input_format.i_channels > 0);
        audio_sample_format_t input_phys_format = input_format;
        aout_SetWavePhysicalChannels(&input_phys_format);

        filter_t *f = FindConverter (obj, &input_format, &input_phys_format);
        if (f == NULL)
        {
            msg_Err (obj, ""cannot find channel converter"");
            goto error;
        }

        input_format = input_phys_format;
        filters->tab[filters->count++] = f;
    }",5,,567,2,,void
7654,BLOCK,-1,,"{
            msg_Err (obj, ""cannot find channel converter"");
            goto error;
        }",9,,579,2,,void
7682,BLOCK,-1,,"{
        if (AppendFilter(obj, ""audio filter"", ""scaletempo"",
                         filters, NULL, &input_format, &output_format, NULL) == 0)
            filters->rate_filter = filters->tab[filters->count - 1];
    }",5,,592,2,,void
7697,BLOCK,-1,,<empty>,13,,595,2,,void
7715,BLOCK,-1,,"{
        AppendRemapFilter(obj, filters, &input_format, &output_format,
                          cfg->remap);

        if (input_format.i_channels > 2 && cfg->headphones)
            AppendFilter(obj, ""audio filter"", ""binauralizer"", filters, NULL,
                    &input_format, &output_format, NULL);
    }",5,,599,2,,void
7736,BLOCK,-1,,<empty>,13,,604,2,,void
7758,BLOCK,-1,,"{
        char *p = str, *name;
        while ((name = strsep (&p, "" :"")) != NULL)
        {
            AppendFilter(obj, ""audio filter"", name, filters,
                         NULL, &input_format, &output_format, NULL);
        }
        free (str);
    }",5,,611,2,,void
7773,BLOCK,-1,,"{
            AppendFilter(obj, ""audio filter"", name, filters,
                         NULL, &input_format, &output_format, NULL);
        }",9,,614,2,,void
7791,BLOCK,-1,,"{
        char *visual = var_InheritString (obj, ""audio-visual"");
        if (visual != NULL && strcasecmp (visual, ""none""))
            AppendFilter(obj, ""visualization"", visual, filters,
                         request_vout, &input_format, &output_format, NULL);
        free (visual);
    }",5,,622,2,,void
7806,BLOCK,-1,,<empty>,13,,625,2,,void
7838,BLOCK,1,,<empty>,,,,1,,void
7845,BLOCK,-1,,"{
        msg_Err (obj, ""cannot setup filtering pipeline"");
        goto error;
    }",5,,634,2,,void
7889,BLOCK,-1,,"{
        msg_Err (obj, ""cannot setup a resampler"");
        goto error;
    }",5,,646,2,,void
7900,BLOCK,-1,,<empty>,9,,651,2,,void
7922,BLOCK,-1,,<empty>,9,,658,2,,void
7937,BLOCK,-1,,"{
    if (filters->resampler != NULL)
        aout_FiltersPipelineDestroy (&filters->resampler, 1);
    aout_FiltersPipelineDestroy (filters->tab, filters->count);
    if (obj != NULL)
        var_DelCallback (obj, ""visual"", VisualizationCallback, NULL);
    free (filters);
}",1,,673,3,,void
7944,BLOCK,-1,,<empty>,9,,675,2,,void
7962,BLOCK,-1,,<empty>,9,,678,2,,void
7974,BLOCK,-1,,"{
    return (filters->resampler != NULL);
}",1,,683,2,,void
7986,BLOCK,-1,,"{
    if (filters->resampler == NULL)
        return false;

    if (adjust)
        filters->resampling += adjust;
    else
        filters->resampling = 0;
    return filters->resampling != 0;
}",1,,688,3,,void
7993,BLOCK,-1,,<empty>,9,,690,2,,void
7998,BLOCK,-1,,<empty>,9,,693,2,,void
8005,BLOCK,-1,,<empty>,9,,695,1,,void
8023,BLOCK,-1,,"{
    int nominal_rate = 0;

    if (rate != INPUT_RATE_DEFAULT)
    {
        filter_t *rate_filter = filters->rate_filter;

        if (rate_filter == NULL)
            goto drop; /* Without linear, non-nominal rate is impossible. */

        /* Override input rate */
        nominal_rate = rate_filter->fmt_in.audio.i_rate;
        rate_filter->fmt_in.audio.i_rate =
            (nominal_rate * INPUT_RATE_DEFAULT) / rate;
    }

    block = aout_FiltersPipelinePlay (filters->tab, filters->count, block);
    if (filters->resampler != NULL)
    {   /* NOTE: the resampler needs to run even if resampling is 0.
         * The decoder and output rates can still be different. */
        filters->resampler->fmt_in.audio.i_rate += filters->resampling;
        block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;
    }

    if (nominal_rate != 0)
    {   /* Restore input rate */
        assert (filters->rate_...",1,,700,4,,void
8032,BLOCK,-1,,"{
        filter_t *rate_filter = filters->rate_filter;

        if (rate_filter == NULL)
            goto drop; /* Without linear, non-nominal rate is impossible. */

        /* Override input rate */
        nominal_rate = rate_filter->fmt_in.audio.i_rate;
        rate_filter->fmt_in.audio.i_rate =
            (nominal_rate * INPUT_RATE_DEFAULT) / rate;
    }",5,,704,2,,void
8043,BLOCK,-1,,<empty>,13,,708,2,,void
8083,BLOCK,-1,,"{   /* NOTE: the resampler needs to run even if resampling is 0.
         * The decoder and output rates can still be different. */
        filters->resampler->fmt_in.audio.i_rate += filters->resampling;
        block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;
    }",5,,718,2,,void
8123,BLOCK,-1,,"{   /* Restore input rate */
        assert (filters->rate_filter != NULL);
        filters->rate_filter->fmt_in.audio.i_rate = nominal_rate;
    }",5,,726,2,,void
8152,BLOCK,-1,,"{
    /* Drain the filters pipeline */
    block_t *block = aout_FiltersPipelineDrain (filters->tab, filters->count);

    if (filters->resampler != NULL)
    {
        block_t *chain = NULL;

        filters->resampler->fmt_in.audio.i_rate += filters->resampling;

        if (block)
        {
            /* Resample the drained block from the filters pipeline */
            block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }

        /* Drain the resampler filter */
        block = aout_FiltersPipelineDrain (&filters->resampler, 1);
        if (block)
            block_ChainAppend (&chain, block);

        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;

        return chain ? block_ChainGather (chain) : NULL;
    }
    else
        return block;
}",1,,738,2,,void
8169,BLOCK,-1,,"{
        block_t *chain = NULL;

        filters->resampler->fmt_in.audio.i_rate += filters->resampling;

        if (block)
        {
            /* Resample the drained block from the filters pipeline */
            block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }

        /* Drain the resampler filter */
        block = aout_FiltersPipelineDrain (&filters->resampler, 1);
        if (block)
            block_ChainAppend (&chain, block);

        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;

        return chain ? block_ChainGather (chain) : NULL;
    }",5,,743,2,,void
8189,BLOCK,-1,,"{
            /* Resample the drained block from the filters pipeline */
            block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }",9,,749,2,,void
8201,BLOCK,-1,,<empty>,17,,753,2,,void
8216,BLOCK,-1,,<empty>,13,,759,2,,void
8241,BLOCK,-1,,<empty>,9,,766,1,,void
8248,BLOCK,-1,,"{
    aout_FiltersPipelineFlush (filters->tab, filters->count);

    if (filters->resampler != NULL)
        aout_FiltersPipelineFlush (&filters->resampler, 1);
}",1,,770,2,,void
8262,BLOCK,-1,,<empty>,9,,774,2,,void
8274,BLOCK,-1,,"{
    aout_FiltersPipelineChangeViewpoint (filters->tab, filters->count, vp);
}",1,,779,3,,void
8305,BLOCK,-1,,<empty>,1,,1,1,,ANY
8315,BLOCK,-1,,<empty>,,,,1,,<empty>
8322,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
}",1,,50,2,,void
8333,BLOCK,1,,<empty>,,,,3,,void
8344,BLOCK,-1,,<empty>,,,,2,,<empty>
8353,BLOCK,-1,,"{
    vlc_object_t *dst = data;

    (void) src; (void) prev;
    return var_Set (dst, name, value);
}",1,,60,6,,void
8377,BLOCK,-1,,"{
    vlc_object_t *dst = data;

    (void) src; (void) name; (void) prev;
    return var_Set (dst, ""audio-device"", value);
}",1,,69,6,,void
8401,BLOCK,-1,,"{
    var_SetFloat (aout, ""volume"", volume);
}",1,,87,3,,void
8411,BLOCK,-1,,"{
    var_SetBool (aout, ""mute"", mute);
}",1,,92,3,,void
8421,BLOCK,-1,,"{
    (cork ? var_IncInteger : var_DecInteger) (aout->obj.parent, ""corks"");
}",1,,97,3,,void
8438,BLOCK,-1,,"{
    var_SetString (aout, ""device"", (id != NULL) ? id : """");
}",1,,102,3,,void
8454,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);
    aout_dev_t *dev, **pp = &owner->dev.list;

    vlc_mutex_lock (&owner->dev.lock);
    while ((dev = *pp) != NULL)
    {
        if (!strcmp (id, dev->id))
            break;
        pp = &dev->next;
    }

    if (name != NULL)
    {
        if (dev == NULL) /* Added device */
        {
            dev = malloc (sizeof (*dev) + strlen (id));
            if (unlikely(dev == NULL))
                goto out;
            dev->next = NULL;
            strcpy (dev->id, id);
            *pp = dev;
            owner->dev.count++;
        }
        else /* Modified device */
            free (dev->name);
        dev->name = strdup (name);
    }
    else
    {
        if (dev != NULL) /* Removed device */
        {
            owner->dev.count--;
            *pp = dev->next;
            free (dev->name);
            free (dev);
        }
    }
out:
    vlc_mutex_unlock (&owner->dev.lock);
}",1,,108,4,,void
8484,BLOCK,-1,,"{
        if (!strcmp (id, dev->id))
            break;
        pp = &dev->next;
    }",5,,114,2,,void
8492,BLOCK,-1,,<empty>,13,,116,2,,void
8504,BLOCK,-1,,"{
        if (dev == NULL) /* Added device */
        {
            dev = malloc (sizeof (*dev) + strlen (id));
            if (unlikely(dev == NULL))
                goto out;
            dev->next = NULL;
            strcpy (dev->id, id);
            *pp = dev;
            owner->dev.count++;
        }
        else /* Modified device */
            free (dev->name);
        dev->name = strdup (name);
    }",5,,121,2,,void
8509,BLOCK,-1,,"{
            dev = malloc (sizeof (*dev) + strlen (id));
            if (unlikely(dev == NULL))
                goto out;
            dev->next = NULL;
            strcpy (dev->id, id);
            *pp = dev;
            owner->dev.count++;
        }",9,,123,2,,void
8524,BLOCK,-1,,<empty>,17,,126,2,,void
8547,BLOCK,-1,,<empty>,13,,133,1,,void
8559,BLOCK,-1,,"{
        if (dev != NULL) /* Removed device */
        {
            owner->dev.count--;
            *pp = dev->next;
            free (dev->name);
            free (dev);
        }
    }",5,,137,1,,void
8564,BLOCK,-1,,"{
            owner->dev.count--;
            *pp = dev->next;
            free (dev->name);
            free (dev);
        }",9,,139,2,,void
8596,BLOCK,-1,,"{
    aout_RequestRestart (aout, mode);
}",1,,151,3,,void
8605,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputAssertLocked (aout);
    aout_volume_SetVolume (owner->volume, gain);
    /* XXX: ideally, return -1 if format cannot be amplified */
    return 0;
}",1,,156,3,,void
8628,BLOCK,-1,,"{
    if (strcmp(prev.psz_string, cur.psz_string))
        aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) data;
    return VLC_SUCCESS;
}",1,,167,6,,void
8637,BLOCK,-1,,<empty>,9,,169,2,,void
8658,BLOCK,-1,,"{
    audio_output_t *aout = (audio_output_t *)obj;
    (void)varname; (void)oldval; (void)newval; (void)data;

    aout_RestartRequest (aout, AOUT_RESTART_STEREOMODE);
    return 0;
}",1,,176,6,,void
8690,BLOCK,-1,,"{
    if( cur.p_address != NULL )
        aout_ChangeViewpoint((audio_output_t *)obj, cur.p_address );
    (void) var; (void) data; (void) prev;
    return VLC_SUCCESS;
}",1,,186,6,,void
8697,BLOCK,-1,,<empty>,9,,188,2,,void
8720,BLOCK,-1,,"{
    vlc_value_t val, text;

    audio_output_t *aout = vlc_custom_create (parent, sizeof (aout_instance_t),
                                              ""audio output"");
    if (unlikely(aout == NULL))
        return NULL;

    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_init (&owner->lock);
    vlc_mutex_init (&owner->req.lock);
    vlc_mutex_init (&owner->dev.lock);
    vlc_mutex_init (&owner->vp.lock);
    vlc_viewpoint_init (&owner->vp.value);
    atomic_init (&owner->vp.update, false);
    owner->req.device = (char *)unset_str;
    owner->req.volume = -1.f;
    owner->req.mute = -1;

    vlc_object_set_destructor (aout, aout_Destructor);

    /* Audio output module callbacks */
    var_Create (aout, ""volume"", VLC_VAR_FLOAT);
    var_AddCallback (aout, ""volume"", var_Copy, parent);
    var_Create (aout, ""mute"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT);
    var_AddCallback (aout, ""mute"", var_Copy, parent);
    var_Create (aout, ""device"", VLC_VAR_STRING);
    var_AddCallbac...",1,,198,2,,void
8728,BLOCK,1,,<empty>,,,,2,,void
8740,BLOCK,-1,,<empty>,9,,204,2,,void
8817,BLOCK,1,,<empty>,,,,4,,void
8944,BLOCK,-1,,"{
        msg_Err (aout, ""no suitable audio output module"");
        vlc_object_release (aout);
        return NULL;
    }",5,,246,2,,void
9079,BLOCK,-1,,"{
        val.psz_string = (char *)""goom"";
        text.psz_string = (char *)""Goom"";
        var_Change (aout, ""visual"", VLC_VAR_ADDCHOICE, &val, &text);
    }",5,,279,2,,void
9105,BLOCK,-1,,"{
        val.psz_string = (char *)""projectm"";
        text.psz_string = (char*)""projectM"";
        var_Change (aout, ""visual"", VLC_VAR_ADDCHOICE, &val, &text);
    }",5,,286,2,,void
9131,BLOCK,-1,,"{
        val.psz_string = (char *)""vsxu"";
        text.psz_string = (char*)""Vovoid VSXu"";
        var_Change (aout, ""visual"", VLC_VAR_ADDCHOICE, &val, &text);
    }",5,,293,2,,void
9157,BLOCK,-1,,"{
        val.psz_string = (char *)""glspectrum"";
        text.psz_string = (char*)""3D spectrum"";
        var_Change (aout, ""visual"", VLC_VAR_ADDCHOICE, &val, &text);
    }",5,,300,2,,void
9189,BLOCK,-1,,"{
        var_SetString (aout, ""visual"", str);
        free (str);
    }",5,,307,2,,void
9276,BLOCK,-1,,<empty>,9,,331,2,,void
9278,BLOCK,-1,,<empty>,9,,331,1,,void
9290,BLOCK,4,,"{
            val.psz_string = (char *)cfg->list.psz[i];
            text.psz_string = vlc_gettext(cfg->list_text[i]);
            var_Change (aout, ""audio-replay-gain-mode"", VLC_VAR_ADDCHOICE,
                            &val, &text);
        }",9,,332,4,,void
9378,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    module_unneed (aout, owner->module);
    /* Protect against late call from intf.c */
    aout->volume_set = NULL;
    aout->mute_set = NULL;
    aout->device_select = NULL;
    aout_OutputUnlock (aout);

    var_DelCallback (aout, ""viewpoint"", ViewpointCallback, NULL);
    var_DelCallback (aout, ""audio-filter"", FilterCallback, NULL);
    var_DelCallback (aout, ""device"", var_CopyDevice, aout->obj.parent);
    var_DelCallback (aout, ""mute"", var_Copy, aout->obj.parent);
    var_SetFloat (aout, ""volume"", -1.f);
    var_DelCallback (aout, ""volume"", var_Copy, aout->obj.parent);
    var_DelCallback (aout, ""stereo-mode"", StereoModeCallback, NULL);
    vlc_object_release (aout);
}",1,,360,2,,void
9461,BLOCK,-1,,"{
    audio_output_t *aout = (audio_output_t *)obj;
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_destroy (&owner->dev.lock);
    for (aout_dev_t *dev = owner->dev.list, *next; dev != NULL; dev = next)
    {
        next = dev->next;
        free (dev->name);
        free (dev);
    }

    assert (owner->req.device == unset_str);
    vlc_mutex_destroy (&owner->vp.lock);
    vlc_mutex_destroy (&owner->req.lock);
    vlc_mutex_destroy (&owner->lock);
}",1,,385,2,,void
9481,BLOCK,-1,,<empty>,5,,390,1,,void
9497,BLOCK,4,,"{
        next = dev->next;
        free (dev->name);
        free (dev);
    }",5,,391,4,,void
9545,BLOCK,-1,,"{
    /* Fill Stereo mode choices */
    var_Change (aout, ""stereo-mode"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    vlc_value_t val, txt, default_val = { .i_int = AOUT_VAR_CHAN_UNSET };
    val.i_int = 0;

    if (!AOUT_FMT_LINEAR(fmt) || i_nb_input_channels == 1)
        return;

    val.i_int = AOUT_VAR_CHAN_MONO;
    txt.psz_string = _(""Mono"");
    var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);

    if (i_nb_input_channels != 2)
    {
        val.i_int = AOUT_VAR_CHAN_UNSET;
        txt.psz_string = _(""Original"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);
    }
    if (fmt->i_chan_mode & AOUT_CHANMODE_DOLBYSTEREO)
    {
        val.i_int = AOUT_VAR_CHAN_DOLBYS;
        txt.psz_string = _(""Dolby Surround"");
    }
    else
    {
        val.i_int = AOUT_VAR_CHAN_STEREO;
        txt.psz_string = _(""Stereo"");
    }
    var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);

    if (i_nb_input_channels == 2)
    {
        default...",1,,409,7,,void
9558,BLOCK,1,,<empty>,43,,412,1,,void
9575,BLOCK,-1,,<empty>,9,,416,2,,void
9600,BLOCK,-1,,"{
        val.i_int = AOUT_VAR_CHAN_UNSET;
        txt.psz_string = _(""Original"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);
    }",5,,423,2,,void
9626,BLOCK,-1,,"{
        val.i_int = AOUT_VAR_CHAN_DOLBYS;
        txt.psz_string = _(""Dolby Surround"");
    }",5,,429,2,,void
9639,BLOCK,-1,,"{
        val.i_int = AOUT_VAR_CHAN_STEREO;
        txt.psz_string = _(""Stereo"");
    }",5,,434,1,,void
9663,BLOCK,-1,,"{
        default_val.i_int = val.i_int; /* Stereo or Dolby Surround */

        val.i_int = AOUT_VAR_CHAN_LEFT;
        txt.psz_string = _(""Left"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);
        val.i_int = AOUT_VAR_CHAN_RIGHT;
        txt.psz_string = _(""Right"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);

        val.i_int = AOUT_VAR_CHAN_RSTEREO;
        txt.psz_string = _(""Reverse stereo"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);
    }",5,,441,2,,void
9736,BLOCK,-1,,"{
        val.i_int = AOUT_VAR_CHAN_HEADPHONES;
        txt.psz_string = _(""Headphones"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);

        if (i_forced_stereo_mode == AOUT_VAR_CHAN_UNSET
         && aout->current_sink_info.headphones)
        {
            i_forced_stereo_mode = AOUT_VAR_CHAN_HEADPHONES;
            default_val.i_int = val.i_int;
            var_Change (aout, ""stereo-mode"", VLC_VAR_SETVALUE, &default_val,
                        NULL);
        }
    }",5,,458,2,,void
9766,BLOCK,-1,,"{
            i_forced_stereo_mode = AOUT_VAR_CHAN_HEADPHONES;
            default_val.i_int = val.i_int;
            var_Change (aout, ""stereo-mode"", VLC_VAR_SETVALUE, &default_val,
                        NULL);
        }",9,,465,2,,void
9786,BLOCK,-1,,"{
        case AOUT_VAR_CHAN_RSTEREO:
            filters_cfg->remap[AOUT_CHANIDX_LEFT] = AOUT_CHANIDX_RIGHT;
            filters_cfg->remap[AOUT_CHANIDX_RIGHT] = AOUT_CHANIDX_LEFT;
            break;
        case AOUT_VAR_CHAN_STEREO:
            break;
        case AOUT_VAR_CHAN_LEFT:
            filters_cfg->remap[AOUT_CHANIDX_RIGHT] = AOUT_CHANIDX_DISABLE;
            break;
        case AOUT_VAR_CHAN_RIGHT:
            filters_cfg->remap[AOUT_CHANIDX_LEFT] = AOUT_CHANIDX_DISABLE;
            break;
        case AOUT_VAR_CHAN_DOLBYS:
            fmt->i_chan_mode = AOUT_CHANMODE_DOLBYSTEREO;
            break;
        case AOUT_VAR_CHAN_HEADPHONES:
            filters_cfg->headphones = true;
            break;
        case AOUT_VAR_CHAN_MONO:
            /* Remix all channels into one */
            for (size_t i = 0; i < AOUT_CHANIDX_MAX; ++ i)
                filters_cfg->remap[i] = AOUT_CHANIDX_LEFT;
            break;
        default:
            if (i_nb_input_channels == 2
...",5,,475,2,,void
9846,BLOCK,-1,,<empty>,13,,496,1,,void
9875,BLOCK,-1,,"{   /* Go directly to the left channel. */
                filters_cfg->remap[AOUT_CHANIDX_RIGHT] = AOUT_CHANIDX_DISABLE;
                default_val.i_int = val.i_int = AOUT_VAR_CHAN_LEFT;
            }",13,,502,2,,void
9906,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);

    audio_channel_type_t input_chan_type = fmt->channel_type;
    int i_forced_stereo_mode = AOUT_VAR_CHAN_UNSET;
    unsigned i_nb_input_channels = fmt->i_channels;

    /* Ideally, the audio filters would be created before the audio output,
     * and the ideal audio format would be the output of the filters chain.
     * But that scheme would not really play well with digital pass-through. */
    if (AOUT_FMT_LINEAR(fmt))
    {
        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_BITMAP
         && aout_FormatNbChannels(fmt) == 0)
        {
            /* The output channel map is unknown, use the WAVE one. */
            assert(fmt->i_channels > 0);
            aout_SetWavePhysicalChannels(fmt);
        }

        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        {
            /* Set the maximum of channels to render ambisonics contents. The
             * aout module will still be free to select less channels in order
        ...",1,,519,4,,void
9928,BLOCK,-1,,"{
        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_BITMAP
         && aout_FormatNbChannels(fmt) == 0)
        {
            /* The output channel map is unknown, use the WAVE one. */
            assert(fmt->i_channels > 0);
            aout_SetWavePhysicalChannels(fmt);
        }

        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        {
            /* Set the maximum of channels to render ambisonics contents. The
             * aout module will still be free to select less channels in order
             * to respect the sink setup. */
            fmt->i_physical_channels = AOUT_CHANS_7_1;
        }

        /* Try to stay in integer domain if possible for no/slow FPU. */
        fmt->i_format = (fmt->i_bitspersample > 16) ? VLC_CODEC_FL32
                                                    : VLC_CODEC_S16N;

        i_forced_stereo_mode = var_GetInteger (aout, ""stereo-mode"");
        if (i_forced_stereo_mode != AOUT_VAR_CHAN_UNSET)
        {
            if (i_fo...",5,,530,2,,void
9940,BLOCK,-1,,"{
            /* The output channel map is unknown, use the WAVE one. */
            assert(fmt->i_channels > 0);
            aout_SetWavePhysicalChannels(fmt);
        }",9,,533,2,,void
9955,BLOCK,-1,,"{
            /* Set the maximum of channels to render ambisonics contents. The
             * aout module will still be free to select less channels in order
             * to respect the sink setup. */
            fmt->i_physical_channels = AOUT_CHANS_7_1;
        }",9,,540,2,,void
9982,BLOCK,-1,,"{
            if (i_forced_stereo_mode == AOUT_VAR_CHAN_LEFT
             || i_forced_stereo_mode == AOUT_VAR_CHAN_RIGHT)
                fmt->i_physical_channels = AOUT_CHAN_CENTER;
            else
                fmt->i_physical_channels = AOUT_CHANS_STEREO;
        }",9,,553,2,,void
9991,BLOCK,-1,,<empty>,17,,556,2,,void
9998,BLOCK,-1,,<empty>,17,,558,1,,void
10025,BLOCK,-1,,"{
        msg_Err (aout, ""module not functional"");
        return -1;
    }",5,,568,2,,void
10063,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);

    if (aout->stop != NULL)
        aout->stop (aout);
}",1,,588,2,,void
10072,BLOCK,-1,,<empty>,9,,592,2,,void
10083,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);

    if (aout->time_get == NULL)
        return -1;
    return aout->time_get (aout, delay);
}",1,,596,3,,void
10092,BLOCK,-1,,<empty>,9,,600,2,,void
10108,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);
#ifndef NDEBUG
    aout_owner_t *owner = aout_owner (aout);
    assert (owner->mixer_format.i_frame_length > 0);
    assert (block->i_buffer == 0 || block->i_buffer / block->i_nb_samples ==
            owner->mixer_format.i_bytes_per_frame /
            owner->mixer_format.i_frame_length);
#endif
    aout->play (aout, block);
}",1,,610,3,,void
10162,BLOCK,-1,,"{
    if (pause)
        aout_OutputFlush (aout, false);
    (void) date;
}",1,,623,4,,void
10165,BLOCK,-1,,<empty>,9,,625,2,,void
10178,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);
    ((aout->pause != NULL) ? aout->pause : PauseDefault) (aout, pause, date);
}",1,,637,4,,void
10200,BLOCK,-1,,"{
    aout_OutputAssertLocked( aout );
    aout->flush (aout, wait);
}",1,,651,3,,void
10214,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);
    return (aout->volume_set != NULL) ? aout->volume_set (aout, vol) : -1;
}",1,,657,3,,void
10237,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);
    return (aout->mute_set != NULL) ? aout->mute_set (aout, mute) : -1;
}",1,,663,3,,void
10260,BLOCK,-1,,"{
    aout_OutputAssertLocked (aout);
    return (aout->device_select != NULL) ? aout->device_select (aout, id) : -1;
}",1,,669,3,,void
10282,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->lock);
}",1,,675,2,,void
10297,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    return vlc_mutex_trylock (&owner->lock);
}",1,,682,2,,void
10313,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
    vlc_mutex_lock (&owner->req.lock);

    if (owner->req.device != unset_str)
    {
        aout_OutputDeviceSet (aout, owner->req.device);
        free (owner->req.device);
        owner->req.device = (char *)unset_str;
    }

    if (owner->req.volume >= 0.f)
    {
        aout_OutputVolumeSet (aout, owner->req.volume);
        owner->req.volume = -1.f;
    }

    if (owner->req.mute >= 0)
    {
        aout_OutputMuteSet (aout, owner->req.mute);
        owner->req.mute = -1;
    }

    vlc_mutex_unlock (&owner->lock);
    /* If another thread is blocked waiting for owner->req.lock at this point,
     * this aout_OutputUnlock() call will not see and apply its change request.
     * The other thread will need to apply the change request itself, which
     * implies it is able to (try-)lock owner->lock. Therefore this thread must
     * release owner->lock _before_ owner->req.lock. Do not reorder...",1,,689,2,,void
10324,BLOCK,1,,<empty>,,,,3,,void
10346,BLOCK,-1,,"{
        aout_OutputDeviceSet (aout, owner->req.device);
        free (owner->req.device);
        owner->req.device = (char *)unset_str;
    }",5,,696,2,,void
10377,BLOCK,-1,,"{
        aout_OutputVolumeSet (aout, owner->req.volume);
        owner->req.volume = -1.f;
    }",5,,703,2,,void
10401,BLOCK,-1,,"{
        aout_OutputMuteSet (aout, owner->req.mute);
        owner->req.mute = -1;
    }",5,,709,2,,void
10433,BLOCK,-1,,"{
    return var_GetFloat (aout, ""volume"");
}",1,,729,2,,void
10443,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    assert (vol >= 0.f);
    vlc_mutex_lock (&owner->req.lock);
    owner->req.volume = vol;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",1,,739,3,,void
10479,BLOCK,-1,,<empty>,9,,748,2,,void
10490,BLOCK,-1,,"{
    int ret = -1;
    float stepSize = var_InheritFloat (aout, ""volume-step"") / (float)AOUT_VOLUME_DEFAULT;
    float delta = value * stepSize;
    float vol = aout_VolumeGet (aout);

    if (vol >= 0.f)
    {
        vol += delta;
        if (vol < 0.f)
            vol = 0.f;
        if (vol > 2.f)
            vol = 2.f;
        vol = (roundf (vol / stepSize)) * stepSize;
        if (volp != NULL)
            *volp = vol;
        ret = aout_VolumeSet (aout, vol);
    }
    return ret;
}",1,,758,4,,void
10521,BLOCK,-1,,"{
        vol += delta;
        if (vol < 0.f)
            vol = 0.f;
        if (vol > 2.f)
            vol = 2.f;
        vol = (roundf (vol / stepSize)) * stepSize;
        if (volp != NULL)
            *volp = vol;
        ret = aout_VolumeSet (aout, vol);
    }",5,,765,2,,void
10529,BLOCK,-1,,<empty>,13,,768,2,,void
10537,BLOCK,-1,,<empty>,13,,770,2,,void
10553,BLOCK,-1,,<empty>,13,,773,2,,void
10569,BLOCK,-1,,"{
    return var_InheritBool (aout, ""mute"");
}",1,,784,2,,void
10579,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->req.lock);
    owner->req.mute = mute;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",1,,793,3,,void
10611,BLOCK,-1,,<empty>,9,,801,2,,void
10620,BLOCK,-1,,"{
    return var_GetNonEmptyString (aout, ""device"");
}",1,,811,2,,void
10630,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);

    char *dev = NULL;
    if (id != NULL)
    {
        dev = strdup (id);
        if (unlikely(dev == NULL))
            return -1;
    }

    vlc_mutex_lock (&owner->req.lock);
    if (owner->req.device != unset_str)
        free (owner->req.device);
    owner->req.device = dev;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",1,,821,3,,void
10644,BLOCK,-1,,"{
        dev = strdup (id);
        if (unlikely(dev == NULL))
            return -1;
    }",5,,826,2,,void
10654,BLOCK,-1,,<empty>,13,,829,2,,void
10673,BLOCK,-1,,<empty>,9,,834,2,,void
10699,BLOCK,-1,,<empty>,9,,839,2,,void
10710,BLOCK,-1,,"{
    aout_owner_t *owner = aout_owner (aout);
    char **tabid, **tabname;
    unsigned i = 0;

    vlc_mutex_lock (&owner->dev.lock);
    tabid = vlc_alloc (owner->dev.count, sizeof (*tabid));
    tabname = vlc_alloc (owner->dev.count, sizeof (*tabname));

    if (unlikely(tabid == NULL || tabname == NULL))
        goto error;

    *ids = tabid;
    *names = tabname;

    for (aout_dev_t *dev = owner->dev.list; dev != NULL; dev = dev->next)
    {
        tabid[i] = strdup(dev->id);
        if (unlikely(tabid[i] == NULL))
            goto error;

        tabname[i] = strdup(dev->name);
        if (unlikely(tabname[i] == NULL))
        {
            free(tabid[i]);
            goto error;
        }

        i++;
    }
    vlc_mutex_unlock (&owner->dev.lock);

    return i;

error:
    vlc_mutex_unlock(&owner->dev.lock);
    while (i > 0)
    {
        i--;
        free(tabname[i]);
        free(tabid[i]);
    }
    free(tabname);
    free(tabid);
    return -1;
}",1,,855,4,,void
10760,BLOCK,-1,,<empty>,9,,865,2,,void
10771,BLOCK,-1,,<empty>,5,,870,1,,void
10788,BLOCK,4,,"{
        tabid[i] = strdup(dev->id);
        if (unlikely(tabid[i] == NULL))
            goto error;

        tabname[i] = strdup(dev->name);
        if (unlikely(tabname[i] == NULL))
        {
            free(tabid[i]);
            goto error;
        }

        i++;
    }",5,,871,4,,void
10804,BLOCK,-1,,<empty>,13,,874,2,,void
10821,BLOCK,-1,,"{
            free(tabid[i]);
            goto error;
        }",9,,878,2,,void
10850,BLOCK,-1,,"{
        i--;
        free(tabname[i]);
        free(tabid[i]);
    }",5,,892,2,,void
10892,BLOCK,-1,,<empty>,1,,1,1,,ANY
10905,BLOCK,-1,,<empty>,,,,6,,<empty>
10911,BLOCK,-1,,"{
    aout_volume_t *vol = vlc_custom_create(parent, sizeof (aout_volume_t),
                                           ""volume"");
    if (unlikely(vol == NULL))
        return NULL;
    vol->module = NULL;
    vol->output_factor = 1.f;

    //audio_volume_t *obj = &vol->object;

    /* Gain */
    if (gain != NULL)
        memcpy(&vol->replay_gain, gain, sizeof (vol->replay_gain));
    else
        memset(&vol->replay_gain, 0, sizeof (vol->replay_gain));

    var_AddCallback(parent, ""audio-replay-gain-mode"",
                    ReplayGainCallback, vol);
    var_TriggerCallback(parent, ""audio-replay-gain-mode"");

    return vol;
}",1,,54,3,,void
10925,BLOCK,-1,,<empty>,9,,58,2,,void
10942,BLOCK,-1,,<empty>,9,,66,2,,void
10954,BLOCK,-1,,<empty>,9,,68,1,,void
10980,BLOCK,-1,,"{
    if (unlikely(vol == NULL))
        return -1;

    audio_volume_t *obj = &vol->object;
    if (vol->module != NULL)
    {
        if (obj->format == format)
        {
            msg_Dbg (obj, ""retaining sample format"");
            return 0;
        }
        msg_Dbg (obj, ""changing sample format"");
        module_unneed(obj, vol->module);
    }

    obj->format = format;
    vol->module = module_need(obj, ""audio volume"", NULL, false);
    if (vol->module == NULL)
        return -1;
    return 0;
}",1,,81,3,,void
10986,BLOCK,-1,,<empty>,9,,83,2,,void
11003,BLOCK,-1,,"{
        if (obj->format == format)
        {
            msg_Dbg (obj, ""retaining sample format"");
            return 0;
        }
        msg_Dbg (obj, ""changing sample format"");
        module_unneed(obj, vol->module);
    }",5,,87,2,,void
11010,BLOCK,-1,,"{
            msg_Dbg (obj, ""retaining sample format"");
            return 0;
        }",9,,89,2,,void
11044,BLOCK,-1,,<empty>,9,,100,2,,void
11054,BLOCK,-1,,"{
    if (vol == NULL)
        return;

    audio_volume_t *obj = &vol->object;

    if (vol->module != NULL)
        module_unneed(obj, vol->module);
    var_DelCallback(obj->obj.parent, ""audio-replay-gain-mode"",
                    ReplayGainCallback, vol);
    vlc_object_release(obj);
}",1,,108,2,,void
11059,BLOCK,-1,,<empty>,9,,110,2,,void
11074,BLOCK,-1,,<empty>,9,,115,2,,void
11096,BLOCK,-1,,"{
    if (unlikely(vol == NULL))
        return;

    vol->output_factor = factor;
}",1,,122,3,,void
11102,BLOCK,-1,,<empty>,9,,124,2,,void
11114,BLOCK,-1,,"{
    if (unlikely(vol == NULL) || vol->module == NULL)
        return -1;

    float amp = vol->output_factor
              * vlc_atomic_load_float (&vol->gain_factor);

    vol->object.amplify(&vol->object, block, amp);
    return 0;
}",1,,133,3,,void
11126,BLOCK,-1,,<empty>,9,,135,2,,void
11162,BLOCK,-1,,"{
    unsigned mode = AUDIO_REPLAY_GAIN_MAX;

    if (likely(str != NULL))
    {   /* Find selectrf mode */
        if (!strcmp (str, ""track""))
            mode = AUDIO_REPLAY_GAIN_TRACK;
        else
        if (!strcmp (str, ""album""))
            mode = AUDIO_REPLAY_GAIN_ALBUM;
    }

    /* */
    float multiplier;

    if (mode == AUDIO_REPLAY_GAIN_MAX)
    {
        multiplier = 1.f;
    }
    else
    {
        float gain;

        /* If the selectrf mode is not available, prefer the other one */
        if (!replay_gain->pb_gain[mode] && replay_gain->pb_gain[!mode])
            mode = !mode;

        if (replay_gain->pb_gain[mode])
            gain = replay_gain->pf_gain[mode]
                 + var_InheritFloat (obj, ""audio-replay-gain-preamp"");
        else
            gain = var_InheritFloat (obj, ""audio-replay-gain-default"");

        multiplier = powf (10.f, gain / 20.f);

        if (var_InheritBool (obj, ""audio-replay-gain-peak-protection""))
            multiplier = fm...",1,,147,4,,void
11172,BLOCK,-1,,"{   /* Find selectrf mode */
        if (!strcmp (str, ""track""))
            mode = AUDIO_REPLAY_GAIN_TRACK;
        else
        if (!strcmp (str, ""album""))
            mode = AUDIO_REPLAY_GAIN_ALBUM;
    }",5,,151,2,,void
11178,BLOCK,-1,,<empty>,13,,153,2,,void
11183,BLOCK,-1,,<empty>,9,,155,1,,void
11189,BLOCK,-1,,<empty>,13,,156,2,,void
11198,BLOCK,-1,,"{
        multiplier = 1.f;
    }",5,,163,2,,void
11203,BLOCK,-1,,"{
        float gain;

        /* If the selectrf mode is not available, prefer the other one */
        if (!replay_gain->pb_gain[mode] && replay_gain->pb_gain[!mode])
            mode = !mode;

        if (replay_gain->pb_gain[mode])
            gain = replay_gain->pf_gain[mode]
                 + var_InheritFloat (obj, ""audio-replay-gain-preamp"");
        else
            gain = var_InheritFloat (obj, ""audio-replay-gain-default"");

        multiplier = powf (10.f, gain / 20.f);

        if (var_InheritBool (obj, ""audio-replay-gain-peak-protection""))
            multiplier = fminf (multiplier, replay_gain->pb_peak[mode]
                                            ? 1.f / replay_gain->pf_peak[mode]
                                            : 1.f);
    }",5,,167,1,,void
11219,BLOCK,-1,,<empty>,13,,172,2,,void
11230,BLOCK,-1,,<empty>,13,,175,2,,void
11243,BLOCK,-1,,<empty>,13,,178,1,,void
11260,BLOCK,-1,,<empty>,13,,183,2,,void
11294,BLOCK,-1,,"{
    aout_volume_t *vol = data;
    float multiplier = aout_ReplayGainSelect(obj, val.psz_string,
                                             &vol->replay_gain);
    vlc_atomic_store_float (&vol->gain_factor, multiplier);
    VLC_UNUSED(var); VLC_UNUSED(oldval);
    return VLC_SUCCESS;
}",1,,196,6,,void
11343,BLOCK,-1,,<empty>,1,,1,1,,ANY
11346,BLOCK,-1,,"{
    return c == '\'' || c == '""' || c == '\\';
}",1,,46,2,,void
11363,BLOCK,-1,,"{
    if( !psz )
        return false;
    return psz[0] == '\\' && IsEscapeNeeded( psz[1] );
}",1,,50,2,,void
11367,BLOCK,-1,,<empty>,9,,52,2,,void
11385,BLOCK,-1,,"{
    return c == ' ' || c == '\t';
}",1,,56,2,,void
11398,BLOCK,-1,,"{
    const char *p = psz_string;
    char c;

    if( !psz_string )
        return NULL;

    /* Look for a opening character */
    SKIPSPACE( p );

    for( ;; p++)
    {
        if( *p == '\0' || *p == ',' || *p == '}' )
            return p;

        if( *p == '{' || *p == '""' || *p == '\'' )
            break;
    }

    /* Set c to the closing character */
    if( *p == '{' )
        c = '}';
    else
        c = *p;
    p++;

    /* Search the closing character, handle nested {..} */
    for( ;; )
    {
        if( *p == '\0')
            return p;

        if( IsEscape( p ) )
            p += 2;
        else if( *p == c )
            return ++p;
        else if( *p == '{' && c == '}' )
            p = ChainGetEnd( p );
        else
            p++;
    }
}",1,,72,2,,void
11407,BLOCK,-1,,<empty>,9,,77,2,,void
11412,BLOCK,1,,<empty>,,,,4,,void
11419,BLOCK,-1,,<empty>,5,,82,1,,void
11422,BLOCK,4,,"{
        if( *p == '\0' || *p == ',' || *p == '}' )
            return p;

        if( *p == '{' || *p == '""' || *p == '\'' )
            break;
    }",5,,83,4,,void
11438,BLOCK,-1,,<empty>,13,,85,2,,void
11456,BLOCK,-1,,<empty>,13,,88,2,,void
11463,BLOCK,-1,,<empty>,9,,93,2,,void
11468,BLOCK,-1,,<empty>,9,,95,1,,void
11476,BLOCK,-1,,<empty>,5,,99,1,,void
11477,BLOCK,4,,"{
        if( *p == '\0')
            return p;

        if( IsEscape( p ) )
            p += 2;
        else if( *p == c )
            return ++p;
        else if( *p == '{' && c == '}' )
            p = ChainGetEnd( p );
        else
            p++;
    }",5,,100,4,,void
11483,BLOCK,-1,,<empty>,13,,102,2,,void
11489,BLOCK,-1,,<empty>,13,,105,2,,void
11494,BLOCK,-1,,<empty>,14,,106,1,,void
11500,BLOCK,-1,,<empty>,13,,107,2,,void
11505,BLOCK,-1,,<empty>,14,,108,1,,void
11515,BLOCK,-1,,<empty>,13,,109,2,,void
11521,BLOCK,-1,,<empty>,13,,111,1,,void
11528,BLOCK,-1,,"{
    const char *p = *ppsz_string;

    char *psz_value = NULL;
    const char *end;
    bool b_keep_brackets = (*p == '{');

    if( *p == '=' )
        p++;

    end = ChainGetEnd( p );
    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        /* Skip heading and trailing spaces.
         * This ain't necessary but will avoid simple
         * user mistakes. */
        SKIPSPACE( p );
    }

    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        if( *p == '\'' || *p == '""' || ( !b_keep_brackets && *p == '{' ) )
        {
            p++;

            if( *(end-1) != '\'' && *(end-1) == '""' )
                SKIPTRAILINGSPACE( p, end );

            if( end - 1 <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end -1 - p );
        }
        else
        {
            SKIPTRAILINGSPACE( p, end );
            if( end <= p )
                psz_value = NULL;
            else
              ...",1,,120,2,,void
11551,BLOCK,-1,,<empty>,9,,128,2,,void
11562,BLOCK,-1,,"{
        psz_value = NULL;
    }",5,,132,2,,void
11567,BLOCK,-1,,"{
        /* Skip heading and trailing spaces.
         * This ain't necessary but will avoid simple
         * user mistakes. */
        SKIPSPACE( p );
    }",5,,136,1,,void
11570,BLOCK,1,,<empty>,,,,4,,void
11580,BLOCK,-1,,"{
        psz_value = NULL;
    }",5,,144,2,,void
11585,BLOCK,-1,,"{
        if( *p == '\'' || *p == '""' || ( !b_keep_brackets && *p == '{' ) )
        {
            p++;

            if( *(end-1) != '\'' && *(end-1) == '""' )
                SKIPTRAILINGSPACE( p, end );

            if( end - 1 <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end -1 - p );
        }
        else
        {
            SKIPTRAILINGSPACE( p, end );
            if( end <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end - p );
        }
    }",5,,148,1,,void
11604,BLOCK,-1,,"{
            p++;

            if( *(end-1) != '\'' && *(end-1) == '""' )
                SKIPTRAILINGSPACE( p, end );

            if( end - 1 <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end -1 - p );
        }",9,,150,2,,void
11621,BLOCK,-1,,<empty>,17,,154,2,,void
11625,BLOCK,1,,<empty>,,,,7,,void
11627,BLOCK,-1,,"SKIPTRAILINGSPACE( p, end )",17,,154,1,,void
11647,BLOCK,-1,,<empty>,17,,157,2,,void
11652,BLOCK,-1,,<empty>,17,,159,1,,void
11663,BLOCK,-1,,"{
            SKIPTRAILINGSPACE( p, end );
            if( end <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end - p );
        }",9,,162,1,,void
11667,BLOCK,1,,<empty>,,,,7,,void
11669,BLOCK,-1,,"SKIPTRAILINGSPACE( p, end )",13,,163,1,,void
11687,BLOCK,-1,,<empty>,17,,165,2,,void
11692,BLOCK,-1,,<empty>,17,,167,1,,void
11702,BLOCK,-1,,<empty>,9,,173,2,,void
11716,BLOCK,-1,,"{
    config_chain_t **pp_next = pp_cfg;
    bool first = true;
    do
    {
        if (!first)
            psz_opts++; /* skip previous delimiter */
        SKIPSPACE( psz_opts );

        first = false;

        /* Look for the end of the name (,={}_space_) */
        size_t len = strcspn( psz_opts, ""=,{} \t"" );
        if( len == 0 )
            continue; /* ignore empty parameter */

        /* Append the new parameter */
        config_chain_t *p_cfg = malloc( sizeof(*p_cfg) );
        if( !p_cfg )
            break;
        p_cfg->psz_name = strndup( psz_opts, len );
        psz_opts += len;
        p_cfg->psz_value = NULL;
        p_cfg->p_next = NULL;

        *pp_next = p_cfg;
        pp_next = &p_cfg->p_next;

        /* Extract the option value */
        SKIPSPACE( psz_opts );
        if( strchr( ""={"", *psz_opts ) )
        {
            p_cfg->psz_value = ChainGetValue( &psz_opts );
            SKIPSPACE( psz_opts );
        }
    }
    while( !memchr( ""}"", *psz_opts, ...",1,,182,3,,void
11726,BLOCK,-1,,"{
        if (!first)
            psz_opts++; /* skip previous delimiter */
        SKIPSPACE( psz_opts );

        first = false;

        /* Look for the end of the name (,={}_space_) */
        size_t len = strcspn( psz_opts, ""=,{} \t"" );
        if( len == 0 )
            continue; /* ignore empty parameter */

        /* Append the new parameter */
        config_chain_t *p_cfg = malloc( sizeof(*p_cfg) );
        if( !p_cfg )
            break;
        p_cfg->psz_name = strndup( psz_opts, len );
        psz_opts += len;
        p_cfg->psz_value = NULL;
        p_cfg->p_next = NULL;

        *pp_next = p_cfg;
        pp_next = &p_cfg->p_next;

        /* Extract the option value */
        SKIPSPACE( psz_opts );
        if( strchr( ""={"", *psz_opts ) )
        {
            p_cfg->psz_value = ChainGetValue( &psz_opts );
            SKIPSPACE( psz_opts );
        }
    }",5,,186,1,,void
11730,BLOCK,-1,,<empty>,13,,188,2,,void
11735,BLOCK,1,,<empty>,,,,2,,void
11754,BLOCK,-1,,<empty>,13,,196,2,,void
11766,BLOCK,-1,,<empty>,13,,201,2,,void
11800,BLOCK,1,,<empty>,,,,2,,void
11811,BLOCK,-1,,"{
            p_cfg->psz_value = ChainGetValue( &psz_opts );
            SKIPSPACE( psz_opts );
        }",9,,213,2,,void
11821,BLOCK,1,,<empty>,,,,2,,void
11836,BLOCK,-1,,<empty>,21,,220,2,,void
11841,BLOCK,1,,<empty>,,,,2,,void
11855,BLOCK,-1,,"{
    size_t len;

    *ppsz_name = NULL;
    *pp_cfg    = NULL;

    if( !psz_chain )
        return NULL;
    SKIPSPACE( psz_chain );

    /* Look for parameter (a {...} or :...) or end of name (space or nul) */
    len = strcspn( psz_chain, ""{: \t"" );
    *ppsz_name = strndup( psz_chain, len );
    psz_chain += len;

    /* Parse the parameters */
    SKIPSPACE( psz_chain );
    if( *psz_chain == '{' )
        psz_chain = config_ChainParseOptions( pp_cfg, psz_chain );

    if( *psz_chain == ':' )
        return strdup( psz_chain + 1 );

    return NULL;
}",1,,228,4,,void
11868,BLOCK,-1,,<empty>,9,,235,2,,void
11873,BLOCK,1,,<empty>,,,,2,,void
11895,BLOCK,1,,<empty>,,,,2,,void
11906,BLOCK,-1,,<empty>,9,,246,2,,void
11917,BLOCK,-1,,<empty>,9,,249,2,,void
11929,BLOCK,-1,,"{
    while( p_cfg != NULL )
    {
        config_chain_t *p_next;

        p_next = p_cfg->p_next;

        FREENULL( p_cfg->psz_name );
        FREENULL( p_cfg->psz_value );
        free( p_cfg );

        p_cfg = p_next;
    }
}",1,,255,2,,void
11934,BLOCK,-1,,"{
        config_chain_t *p_next;

        p_next = p_cfg->p_next;

        FREENULL( p_cfg->psz_name );
        FREENULL( p_cfg->psz_value );
        free( p_cfg );

        p_cfg = p_next;
    }",5,,257,2,,void
11961,BLOCK,-1,,"{
    if( psz_prefix == NULL ) psz_prefix = """";
    size_t plen = 1 + strlen( psz_prefix );

    /* First, var_Create all variables */
    for( size_t i = 0; ppsz_options[i] != NULL; i++ )
    {
        const char *optname = ppsz_options[i];
        if (optname[0] == '*')
            optname++;

        char name[plen + strlen( optname )];
        snprintf( name, sizeof (name), ""%s%s"", psz_prefix, optname );
        if( var_Create( p_this, name,
                        config_GetType( name ) | VLC_VAR_DOINHERIT ) )
            return /* VLC_xxx */;

        module_config_t* p_conf = config_FindConfig( name );
        if( p_conf )
        {
            switch( CONFIG_CLASS( p_conf->i_type ) )
            {
                case CONFIG_ITEM_INTEGER:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(vlc_value_t){ .i_int = p_conf->min.i },
                        &(vlc_value_t){ .i_int = p_conf->max.i } );
                    break;
              ...",1,,273,5,,void
11966,BLOCK,-1,,<empty>,30,,274,2,,void
11978,BLOCK,-1,,<empty>,5,,278,1,,void
11990,BLOCK,4,,"{
        const char *optname = ppsz_options[i];
        if (optname[0] == '*')
            optname++;

        char name[plen + strlen( optname )];
        snprintf( name, sizeof (name), ""%s%s"", psz_prefix, optname );
        if( var_Create( p_this, name,
                        config_GetType( name ) | VLC_VAR_DOINHERIT ) )
            return /* VLC_xxx */;

        module_config_t* p_conf = config_FindConfig( name );
        if( p_conf )
        {
            switch( CONFIG_CLASS( p_conf->i_type ) )
            {
                case CONFIG_ITEM_INTEGER:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(vlc_value_t){ .i_int = p_conf->min.i },
                        &(vlc_value_t){ .i_int = p_conf->max.i } );
                    break;
                case CONFIG_ITEM_FLOAT:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(vlc_value_t){ .f_float = p_conf->min.f },
                        &(vlc_valu...",5,,279,4,,void
12003,BLOCK,-1,,<empty>,13,,282,2,,void
12022,BLOCK,-1,,<empty>,13,,288,2,,void
12031,BLOCK,-1,,"{
            switch( CONFIG_CLASS( p_conf->i_type ) )
            {
                case CONFIG_ITEM_INTEGER:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(vlc_value_t){ .i_int = p_conf->min.i },
                        &(vlc_value_t){ .i_int = p_conf->max.i } );
                    break;
                case CONFIG_ITEM_FLOAT:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(vlc_value_t){ .f_float = p_conf->min.f },
                        &(vlc_value_t){ .f_float = p_conf->max.f } );
                    break;
            }
        }",9,,292,2,,void
12037,BLOCK,1,,<empty>,,,,3,,void
12044,BLOCK,-1,,"{
                case CONFIG_ITEM_INTEGER:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(vlc_value_t){ .i_int = p_conf->min.i },
                        &(vlc_value_t){ .i_int = p_conf->max.i } );
                    break;
                case CONFIG_ITEM_FLOAT:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(vlc_value_t){ .f_float = p_conf->min.f },
                        &(vlc_value_t){ .f_float = p_conf->max.f } );
                    break;
            }",13,,294,2,,void
12055,BLOCK,1,,<empty>,41,,297,1,,void
12067,BLOCK,1,,<empty>,41,,298,1,,void
12086,BLOCK,1,,<empty>,41,,302,1,,void
12098,BLOCK,1,,<empty>,41,,303,1,,void
12108,BLOCK,-1,,<empty>,5,,310,1,,void
12115,BLOCK,4,,"{
        vlc_value_t val;
        bool b_yes = true;
        bool b_once = false;
        module_config_t *p_conf;
        int i_type;
        size_t i;

        if( cfg->psz_name == NULL || *cfg->psz_name == '\0' )
            continue;

        for( i = 0; ppsz_options[i] != NULL; i++ )
        {
            if( !strcmp( ppsz_options[i], cfg->psz_name ) )
            {
                break;
            }
            if( ( !strncmp( cfg->psz_name, ""no-"", 3 ) &&
                  !strcmp( ppsz_options[i], cfg->psz_name + 3 ) ) ||
                ( !strncmp( cfg->psz_name, ""no"", 2 ) &&
                  !strcmp( ppsz_options[i], cfg->psz_name + 2 ) ) )
            {
                b_yes = false;
                break;
            }

            if( *ppsz_options[i] == '*' &&
                !strcmp( &ppsz_options[i][1], cfg->psz_name ) )
            {
                b_once = true;
                break;
            }

        }

        if( ppsz_options[i] == NULL )
        {
   ...",5,,311,4,,void
12141,BLOCK,-1,,<empty>,13,,320,2,,void
12144,BLOCK,-1,,<empty>,9,,322,1,,void
12155,BLOCK,4,,"{
            if( !strcmp( ppsz_options[i], cfg->psz_name ) )
            {
                break;
            }
            if( ( !strncmp( cfg->psz_name, ""no-"", 3 ) &&
                  !strcmp( ppsz_options[i], cfg->psz_name + 3 ) ) ||
                ( !strncmp( cfg->psz_name, ""no"", 2 ) &&
                  !strcmp( ppsz_options[i], cfg->psz_name + 2 ) ) )
            {
                b_yes = false;
                break;
            }

            if( *ppsz_options[i] == '*' &&
                !strcmp( &ppsz_options[i][1], cfg->psz_name ) )
            {
                b_once = true;
                break;
            }

        }",9,,323,4,,void
12165,BLOCK,-1,,"{
                break;
            }",13,,325,2,,void
12205,BLOCK,-1,,"{
                b_yes = false;
                break;
            }",13,,332,2,,void
12229,BLOCK,-1,,"{
                b_once = true;
                break;
            }",13,,339,2,,void
12240,BLOCK,-1,,"{
            msg_Warn( p_this, ""option %s is unknown"", cfg->psz_name );
            continue;
        }",9,,347,2,,void
12275,BLOCK,-1,,"{
            if( p_conf->b_removed )
            {
                msg_Err( p_this, ""Option %s is not supported anymore."",
                         name );
                /* TODO: this should return an error and end option parsing
                 * ... but doing this would change the VLC API and all the
                 * modules so i'll do it later */
                continue;
            }
        }",9,,364,2,,void
12280,BLOCK,-1,,"{
                msg_Err( p_this, ""Option %s is not supported anymore."",
                         name );
                /* TODO: this should return an error and end option parsing
                 * ... but doing this would change the VLC API and all the
                 * modules so i'll do it later */
                continue;
            }",13,,366,2,,void
12293,BLOCK,-1,,"{
            msg_Warn( p_this, ""unknown option %s (value=%s)"",
                      cfg->psz_name, cfg->psz_value );
            continue;
        }",9,,380,2,,void
12314,BLOCK,-1,,"{
            msg_Warn( p_this, ""missing value for option %s"", cfg->psz_name );
            continue;
        }",9,,387,2,,void
12328,BLOCK,-1,,"{
            msg_Warn( p_this, ""*option_name need to be a string option"" );
            continue;
        }",9,,392,2,,void
12335,BLOCK,-1,,"{
            case VLC_VAR_BOOL:
                val.b_bool = b_yes;
                break;
            case VLC_VAR_INTEGER:
                val.i_int = strtoll( cfg->psz_value ? cfg->psz_value : ""0"",
                                     NULL, 0 );
                break;
            case VLC_VAR_FLOAT:
                val.f_float = us_atof( cfg->psz_value ? cfg->psz_value : ""0"" );
                break;
            case VLC_VAR_STRING:
                val.psz_string = cfg->psz_value;
                break;
            default:
                msg_Warn( p_this, ""unhandled config var type (%d)"", i_type );
                memset( &val, 0, sizeof( vlc_value_t ) );
                break;
        }",9,,398,2,,void
12402,BLOCK,-1,,"{
            vlc_value_t val2;

            var_Get( p_this, psz_name, &val2 );
            if( *val2.psz_string )
            {
                free( val2.psz_string );
                msg_Dbg( p_this, ""ignoring option %s (not first occurrence)"", psz_name );
                continue;
            }
            free( val2.psz_string );
        }",9,,418,2,,void
12414,BLOCK,-1,,"{
                free( val2.psz_string );
                msg_Dbg( p_this, ""ignoring option %s (not first occurrence)"", psz_name );
                continue;
            }",13,,423,2,,void
12448,BLOCK,-1,,"{
    config_chain_t *p_dst = NULL;
    config_chain_t **pp_last = &p_dst;

    for( ; p_src != NULL; p_src = p_src->p_next )
    {
        config_chain_t *p = malloc( sizeof(*p) );
        if( !p )
            break;
        p->p_next    = NULL;
        p->psz_name  = p_src->psz_name  ? strdup( p_src->psz_name )  : NULL;
        p->psz_value = p_src->psz_value ? strdup( p_src->psz_value ) : NULL;

        *pp_last = p;
        pp_last = &p->p_next;
    }
    return p_dst;
}",1,,437,2,,void
12459,BLOCK,-1,,<empty>,5,,441,1,,void
12468,BLOCK,4,,"{
        config_chain_t *p = malloc( sizeof(*p) );
        if( !p )
            break;
        p->p_next    = NULL;
        p->psz_name  = p_src->psz_name  ? strdup( p_src->psz_name )  : NULL;
        p->psz_value = p_src->psz_value ? strdup( p_src->psz_value ) : NULL;

        *pp_last = p;
        pp_last = &p->p_next;
    }",5,,442,4,,void
12479,BLOCK,-1,,<empty>,13,,445,2,,void
12528,BLOCK,-1,,"{
    char *psz_src = psz_string;
    char *psz_dst = psz_string;
    if( !psz_src )
        return NULL;

    while( *psz_src )
    {
        if( IsEscape( psz_src ) )
            psz_src++;
        *psz_dst++ = *psz_src++;
    }
    *psz_dst = '\0';

    return psz_string;
}",1,,457,2,,void
12540,BLOCK,-1,,<empty>,9,,461,2,,void
12546,BLOCK,-1,,"{
        if( IsEscape( psz_src ) )
            psz_src++;
        *psz_dst++ = *psz_src++;
    }",5,,464,2,,void
12550,BLOCK,-1,,<empty>,13,,466,2,,void
12570,BLOCK,-1,,"{
    size_t length = 0;

    if( str == NULL )
        return NULL;

    for( const char *p = str; *p; p++ )
        length += IsEscapeNeeded( *p ) ? 2 : 1;

    char *ret = malloc( length + 1 ), *dst = ret;

    if( unlikely( !ret ) )
        return NULL;

    for( const char *p = str; *p; p++ )
    {
        if( IsEscapeNeeded( *p ) )
            *dst++ = '\\';
        *dst++ = *p;
    }
    *dst = '\0';;
    return ret;
}",1,,475,2,,void
12579,BLOCK,-1,,<empty>,9,,479,2,,void
12583,BLOCK,-1,,<empty>,5,,481,1,,void
12615,BLOCK,-1,,<empty>,9,,487,2,,void
12619,BLOCK,-1,,<empty>,5,,489,1,,void
12628,BLOCK,4,,"{
        if( IsEscapeNeeded( *p ) )
            *dst++ = '\\';
        *dst++ = *p;
    }",5,,490,4,,void
12633,BLOCK,-1,,<empty>,13,,492,2,,void
12679,BLOCK,-1,,<empty>,1,,1,1,,ANY
12685,BLOCK,-1,,"{
    int i_cmd, i_index, i_opts, i_shortopts, flag, i_verbose = 0;
    struct vlc_option *p_longopts;
    const char **argv_copy = NULL;
#define b_ignore_errors (pindex == NULL)

    /* Short options */
    const module_config_t *pp_shortopts[256];
    char *psz_shortopts;

    /*
     * Generate the longopts and shortopts structures used by getopt_long
     */

    i_opts = 0;
    for (const vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
        /* count the number of exported configuration options (to allocate
         * longopts). We also need to allocate space for two options when
         * dealing with boolean to allow for --foo and --no-foo */
        i_opts += p->conf.count + 2 * p->conf.booleans;

    p_longopts = vlc_alloc( i_opts + 1, sizeof(*p_longopts)  );
    if( p_longopts == NULL )
        return -1;

    psz_shortopts = malloc( 2 * i_opts + 1 );
    if( psz_shortopts == NULL )
    {
        free( p_longopts );
        return -1;
    }

    /* If we are requ...",1,,60,5,,void
12706,BLOCK,-1,,<empty>,5,,75,1,,void
12747,BLOCK,-1,,<empty>,9,,83,2,,void
12763,BLOCK,-1,,"{
        free( p_longopts );
        return -1;
    }",5,,87,2,,void
12771,BLOCK,1,,<empty>,,,,1,,void
12775,BLOCK,-1,,"{
        argv_copy = vlc_alloc( i_argc, sizeof(char *) );
        if( argv_copy == NULL )
        {
            free( psz_shortopts );
            free( p_longopts );
            return -1;
        }
        memcpy( argv_copy, ppsz_argv, i_argc * sizeof(char *) );
        ppsz_argv = argv_copy;
    }",5,,96,2,,void
12786,BLOCK,-1,,"{
            free( psz_shortopts );
            free( p_longopts );
            return -1;
        }",9,,99,2,,void
12808,BLOCK,-1,,<empty>,5,,109,1,,void
12817,BLOCK,4,,"{
        pp_shortopts[i_index] = NULL;
    }",5,,110,4,,void
12827,BLOCK,-1,,<empty>,5,,116,1,,void
12840,BLOCK,4,,"{
        for (const module_config_t *p_item = p->conf.items,
                                   *p_end = p_item + p->conf.size;
             p_item < p_end;
             p_item++)
        {
            /* Ignore hints */
            if( !CONFIG_ITEM(p_item->i_type) )
                continue;

            /* Add item to long options */
            p_longopts[i_index].name = strdup( p_item->psz_name );
            if( p_longopts[i_index].name == NULL ) continue;
            p_longopts[i_index].flag = &flag;
            p_longopts[i_index].val = 0;

            if( CONFIG_CLASS(p_item->i_type) != CONFIG_ITEM_BOOL )
                p_longopts[i_index].has_arg = true;
            else
            /* Booleans also need --no-foo and --nofoo options */
            {
                char *psz_name;

                p_longopts[i_index].has_arg = false;
                i_index++;

                if( asprintf( &psz_name, ""no%s"", p_item->psz_name ) == -1 )
                    continue;
      ...",5,,117,4,,void
12842,BLOCK,-1,,<empty>,9,,118,1,,void
12866,BLOCK,4,,"{
            /* Ignore hints */
            if( !CONFIG_ITEM(p_item->i_type) )
                continue;

            /* Add item to long options */
            p_longopts[i_index].name = strdup( p_item->psz_name );
            if( p_longopts[i_index].name == NULL ) continue;
            p_longopts[i_index].flag = &flag;
            p_longopts[i_index].val = 0;

            if( CONFIG_CLASS(p_item->i_type) != CONFIG_ITEM_BOOL )
                p_longopts[i_index].has_arg = true;
            else
            /* Booleans also need --no-foo and --nofoo options */
            {
                char *psz_name;

                p_longopts[i_index].has_arg = false;
                i_index++;

                if( asprintf( &psz_name, ""no%s"", p_item->psz_name ) == -1 )
                    continue;
                p_longopts[i_index].name = psz_name;
                p_longopts[i_index].has_arg = false;
                p_longopts[i_index].flag = &flag;
                p_longopts[i_index].val...",9,,122,4,,void
12873,BLOCK,-1,,<empty>,17,,125,2,,void
12893,BLOCK,-1,,<empty>,52,,129,2,,void
12916,BLOCK,1,,<empty>,,,,2,,void
12924,BLOCK,-1,,<empty>,17,,134,2,,void
12933,BLOCK,-1,,"{
                char *psz_name;

                p_longopts[i_index].has_arg = false;
                i_index++;

                if( asprintf( &psz_name, ""no%s"", p_item->psz_name ) == -1 )
                    continue;
                p_longopts[i_index].name = psz_name;
                p_longopts[i_index].has_arg = false;
                p_longopts[i_index].flag = &flag;
                p_longopts[i_index].val = 1;
                i_index++;

                if( asprintf( &psz_name, ""no-%s"", p_item->psz_name ) == -1 )
                    continue;
                p_longopts[i_index].name = psz_name;
                p_longopts[i_index].has_arg = false;
                p_longopts[i_index].flag = &flag;
                p_longopts[i_index].val = 1;
            }",13,,137,1,,void
12955,BLOCK,-1,,<empty>,21,,144,2,,void
12999,BLOCK,-1,,<empty>,21,,152,2,,void
13036,BLOCK,-1,,"{
                pp_shortopts[(int)p_item->i_short] = p_item;
                psz_shortopts[i_shortopts] = p_item->i_short;
                i_shortopts++;
                if( p_item->i_type != CONFIG_ITEM_BOOL
                 && p_item->i_short != 'v' )
                {
                    psz_shortopts[i_shortopts] = ':';
                    i_shortopts++;
                }
            }",13,,162,2,,void
13067,BLOCK,-1,,"{
                    psz_shortopts[i_shortopts] = ':';
                    i_shortopts++;
                }",17,,168,2,,void
13117,BLOCK,-1,,"{
        /* A long option has been recognized */
        if( i_cmd == 0 )
        {
            module_config_t *p_conf;
            const char *psz_name = p_longopts[i_index].name;

            /* Check if we deal with a --nofoo or --no-foo long option */
            if( flag ) psz_name += psz_name[2] == '-' ? 3 : 2;

            /* Store the configuration option */
            p_conf = config_FindConfig( psz_name );
            if( p_conf )
            {
                /* Check if the option is deprecated */
                if( p_conf->b_removed )
                {
                    fprintf(stderr,
                            ""Warning: option --%s no longer exists.\n"",
                            psz_name);
                    continue;
                }

                switch( CONFIG_CLASS(p_conf->i_type) )
                {
                    case CONFIG_ITEM_STRING:
                        var_Create( p_this, psz_name, VLC_VAR_STRING );
                        var_SetStri...",5,,190,2,,void
13122,BLOCK,-1,,"{
            module_config_t *p_conf;
            const char *psz_name = p_longopts[i_index].name;

            /* Check if we deal with a --nofoo or --no-foo long option */
            if( flag ) psz_name += psz_name[2] == '-' ? 3 : 2;

            /* Store the configuration option */
            p_conf = config_FindConfig( psz_name );
            if( p_conf )
            {
                /* Check if the option is deprecated */
                if( p_conf->b_removed )
                {
                    fprintf(stderr,
                            ""Warning: option --%s no longer exists.\n"",
                            psz_name);
                    continue;
                }

                switch( CONFIG_CLASS(p_conf->i_type) )
                {
                    case CONFIG_ITEM_STRING:
                        var_Create( p_this, psz_name, VLC_VAR_STRING );
                        var_SetString( p_this, psz_name, state.arg );
                        break;
                 ...",9,,193,2,,void
13134,BLOCK,-1,,<empty>,24,,198,2,,void
13151,BLOCK,-1,,"{
                /* Check if the option is deprecated */
                if( p_conf->b_removed )
                {
                    fprintf(stderr,
                            ""Warning: option --%s no longer exists.\n"",
                            psz_name);
                    continue;
                }

                switch( CONFIG_CLASS(p_conf->i_type) )
                {
                    case CONFIG_ITEM_STRING:
                        var_Create( p_this, psz_name, VLC_VAR_STRING );
                        var_SetString( p_this, psz_name, state.arg );
                        break;
                    case CONFIG_ITEM_INTEGER:
                        var_Create( p_this, psz_name, VLC_VAR_INTEGER );
                        var_Change( p_this, psz_name, VLC_VAR_SETMINMAX,
                            &(vlc_value_t){ .i_int = p_conf->min.i },
                            &(vlc_value_t){ .i_int = p_conf->max.i } );
                        var_SetInteger( p_this, psz_name,
  ...",13,,203,2,,void
13156,BLOCK,-1,,"{
                    fprintf(stderr,
                            ""Warning: option --%s no longer exists.\n"",
                            psz_name);
                    continue;
                }",17,,206,2,,void
13167,BLOCK,1,,<empty>,,,,3,,void
13174,BLOCK,-1,,"{
                    case CONFIG_ITEM_STRING:
                        var_Create( p_this, psz_name, VLC_VAR_STRING );
                        var_SetString( p_this, psz_name, state.arg );
                        break;
                    case CONFIG_ITEM_INTEGER:
                        var_Create( p_this, psz_name, VLC_VAR_INTEGER );
                        var_Change( p_this, psz_name, VLC_VAR_SETMINMAX,
                            &(vlc_value_t){ .i_int = p_conf->min.i },
                            &(vlc_value_t){ .i_int = p_conf->max.i } );
                        var_SetInteger( p_this, psz_name,
                                        strtoll(state.arg, NULL, 0));
                        break;
                    case CONFIG_ITEM_FLOAT:
                        var_Create( p_this, psz_name, VLC_VAR_FLOAT );
                        var_Change( p_this, psz_name, VLC_VAR_SETMINMAX,
                            &(vlc_value_t){ .f_float = p_conf->min.f },
                        ...",17,,214,2,,void
13202,BLOCK,1,,<empty>,45,,222,1,,void
13214,BLOCK,1,,<empty>,45,,223,1,,void
13246,BLOCK,1,,<empty>,45,,230,1,,void
13258,BLOCK,1,,<empty>,45,,231,1,,void
13293,BLOCK,-1,,"{
            const char *name = pp_shortopts[i_cmd]->psz_name;
            switch( CONFIG_CLASS(pp_shortopts[i_cmd]->i_type) )
            {
                case CONFIG_ITEM_STRING:
                    var_Create( p_this, name, VLC_VAR_STRING );
                    var_SetString( p_this, name, state.arg );
                    break;
                case CONFIG_ITEM_INTEGER:
                    var_Create( p_this, name, VLC_VAR_INTEGER );
                    if( i_cmd == 'v' )
                    {
                        i_verbose++; /* -v */
                        var_SetInteger( p_this, name, i_verbose );
                    }
                    else
                    {
                        var_SetInteger( p_this, name,
                                        strtoll(state.arg, NULL, 0) );
                    }
                    break;
                case CONFIG_ITEM_BOOL:
                    var_Create( p_this, name, VLC_VAR_BOOL );
                    var_SetBool( p_t...",9,,245,2,,void
13309,BLOCK,1,,<empty>,,,,4,,void
13318,BLOCK,-1,,"{
                case CONFIG_ITEM_STRING:
                    var_Create( p_this, name, VLC_VAR_STRING );
                    var_SetString( p_this, name, state.arg );
                    break;
                case CONFIG_ITEM_INTEGER:
                    var_Create( p_this, name, VLC_VAR_INTEGER );
                    if( i_cmd == 'v' )
                    {
                        i_verbose++; /* -v */
                        var_SetInteger( p_this, name, i_verbose );
                    }
                    else
                    {
                        var_SetInteger( p_this, name,
                                        strtoll(state.arg, NULL, 0) );
                    }
                    break;
                case CONFIG_ITEM_BOOL:
                    var_Create( p_this, name, VLC_VAR_BOOL );
                    var_SetBool( p_this, name, true );
                    break;
            }",13,,248,2,,void
13342,BLOCK,-1,,"{
                        i_verbose++; /* -v */
                        var_SetInteger( p_this, name, i_verbose );
                    }",21,,256,2,,void
13350,BLOCK,-1,,"{
                        var_SetInteger( p_this, name,
                                        strtoll(state.arg, NULL, 0) );
                    }",21,,261,1,,void
13376,BLOCK,1,,<empty>,,,,1,,void
13380,BLOCK,-1,,"{
            fputs( ""vlc: unknown option""
                     "" or missing mandatory argument "", stderr );
            if( state.opt )
            {
                fprintf( stderr, ""`-%c'\n"", state.opt );
            }
            else
            {
                fprintf( stderr, ""`%s'\n"", ppsz_argv[state.ind-1] );
            }
            fputs( ""Try `vlc --help' for more information.\n"", stderr );
            goto out;
        }",9,,277,2,,void
13388,BLOCK,-1,,"{
                fprintf( stderr, ""`-%c'\n"", state.opt );
            }",13,,281,2,,void
13396,BLOCK,-1,,"{
                fprintf( stderr, ""`%s'\n"", ppsz_argv[state.ind-1] );
            }",13,,285,1,,void
13418,BLOCK,-1,,<empty>,9,,295,2,,void
13427,BLOCK,-1,,<empty>,5,,298,1,,void
13460,BLOCK,-1,,<empty>,1,,1,1,,ANY
13464,BLOCK,-1,,<empty>,,,,3,,<empty>
13469,BLOCK,-1,,<empty>,,,,2,,<empty>
13475,BLOCK,-1,,<empty>,,,,3,,<empty>
13483,BLOCK,-1,,<empty>,,,,5,,<empty>
13488,BLOCK,-1,,<empty>,,,,2,,<empty>
13493,BLOCK,-1,,<empty>,,,,2,,<empty>
13498,BLOCK,-1,,<empty>,,,,2,,<empty>
13503,BLOCK,-1,,<empty>,,,,2,,<empty>
13510,BLOCK,-1,,<empty>,,,,2,,<empty>
13537,BLOCK,-1,,<empty>,1,,1,1,,ANY
13548,BLOCK,-1,,"{
    return src ? strdup (src) : NULL;
}",1,,45,2,,void
13559,BLOCK,-1,,"{
    module_config_t *p_config = config_FindConfig(psz_name);

    /* sanity checks */
    if( !p_config )
    {
        return 0;
    }

    switch( CONFIG_CLASS(p_config->i_type) )
    {
        case CONFIG_ITEM_FLOAT:
            return VLC_VAR_FLOAT;
        case CONFIG_ITEM_INTEGER:
            return VLC_VAR_INTEGER;
        case CONFIG_ITEM_BOOL:
            return VLC_VAR_BOOL;
        case CONFIG_ITEM_STRING:
            return VLC_VAR_STRING;
        default:
            return 0;
    }
}",1,,55,2,,void
13568,BLOCK,-1,,"{
        return 0;
    }",5,,60,2,,void
13576,BLOCK,1,,<empty>,,,,3,,void
13583,BLOCK,-1,,"{
        case CONFIG_ITEM_FLOAT:
            return VLC_VAR_FLOAT;
        case CONFIG_ITEM_INTEGER:
            return VLC_VAR_INTEGER;
        case CONFIG_ITEM_BOOL:
            return VLC_VAR_BOOL;
        case CONFIG_ITEM_STRING:
            return VLC_VAR_STRING;
        default:
            return 0;
    }",5,,65,2,,void
13607,BLOCK,-1,,"{
    module_config_t *p_config = config_FindConfig( name );
    return p_config != NULL && p_config->b_safe;
}",1,,80,2,,void
13626,BLOCK,-1,,"{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    int64_t val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.i;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",1,,94,3,,void
13635,BLOCK,-1,,"{
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }",5,,99,2,,void
13648,BLOCK,1,,<empty>,,,,3,,void
13677,BLOCK,-1,,"{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigFloatType(p_config->i_type));

    float val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.f;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",1,,122,3,,void
13686,BLOCK,-1,,"{
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }",5,,129,2,,void
13699,BLOCK,1,,<empty>,,,,3,,void
13726,BLOCK,-1,,"{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return NULL;
    }

    assert(IsConfigStringType (p_config->i_type));

    /* return a copy of the string */
    vlc_rwlock_rdlock (&config_lock);
    char *psz_value = strdupnull (p_config->value.psz);
    vlc_rwlock_unlock (&config_lock);

    return psz_value;
}",1,,157,3,,void
13735,BLOCK,-1,,"{
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return NULL;
    }",5,,164,2,,void
13747,BLOCK,1,,<empty>,,,,3,,void
13778,BLOCK,-1,,"{
    module_config_t *p_config = config_FindConfig( psz_name );


    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigStringType(p_config->i_type));

    char *str, *oldstr;
    if ((psz_value != NULL) && *psz_value)
        str = strdup (psz_value);
    else
        str = NULL;

    vlc_rwlock_wrlock (&config_lock);
    oldstr = (char *)p_config->value.psz;
    p_config->value.psz = str;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);

    free (oldstr);
}",1,,189,4,,void
13787,BLOCK,-1,,"{
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }",5,,195,2,,void
13798,BLOCK,1,,<empty>,,,,3,,void
13815,BLOCK,-1,,<empty>,9,,204,2,,void
13821,BLOCK,-1,,<empty>,9,,206,1,,void
13858,BLOCK,-1,,"{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    if (i_value < p_config->min.i)
        i_value = p_config->min.i;
    if (i_value > p_config->max.i)
        i_value = p_config->max.i;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.i = i_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",1,,227,4,,void
13867,BLOCK,-1,,"{
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }",5,,232,2,,void
13878,BLOCK,1,,<empty>,,,,3,,void
13894,BLOCK,-1,,<empty>,9,,240,2,,void
13910,BLOCK,-1,,<empty>,9,,242,2,,void
13940,BLOCK,-1,,"{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigFloatType(p_config->i_type));

    /* if f_min == f_max == 0, then do not use them */
    if ((p_config->min.f == 0.f) && (p_config->max.f == 0.f))
        ;
    else if (f_value < p_config->min.f)
        f_value = p_config->min.f;
    else if (f_value > p_config->max.f)
        f_value = p_config->max.f;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.f = f_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",1,,259,4,,void
13949,BLOCK,-1,,"{
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }",5,,264,2,,void
13960,BLOCK,1,,<empty>,,,,3,,void
13982,BLOCK,-1,,<empty>,9,,273,2,,void
13984,BLOCK,-1,,<empty>,10,,274,1,,void
13993,BLOCK,-1,,<empty>,9,,275,2,,void
14002,BLOCK,-1,,<empty>,10,,276,1,,void
14011,BLOCK,-1,,<empty>,9,,277,2,,void
14042,BLOCK,-1,,"{
    *values = NULL;
    *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        msg_Warn (obj, ""option %s does not exist"", name);
        errno = ENOENT;
        return -1;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.i_cb == NULL)
            return 0;
        return cfg->list.i_cb(obj, name, values, texts);
    }

    int64_t *vals = vlc_alloc (count, sizeof (*vals));
    char **txts = vlc_alloc (count, sizeof (*txts));
    if (vals == NULL || txts == NULL)
    {
        errno = ENOMEM;
        goto error;
    }

    for (size_t i = 0; i < count; i++)
    {
        vals[i] = cfg->list.i[i];
        /* FIXME: use module_gettext() instead */
        txts[i] = strdup ((cfg->list_text[i] != NULL)
                                       ? vlc_gettext (cfg->list_text[i]) : """");
        ...",1,,295,5,,void
14060,BLOCK,-1,,"{
        msg_Warn (obj, ""option %s does not exist"", name);
        errno = ENOENT;
        return -1;
    }",5,,301,2,,void
14081,BLOCK,-1,,"{
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.i_cb == NULL)
            return 0;
        return cfg->list.i_cb(obj, name, values, texts);
    }",5,,309,2,,void
14088,BLOCK,-1,,"{
            errno = EIO;
            return -1;
        }",9,,311,2,,void
14103,BLOCK,-1,,<empty>,13,,317,2,,void
14141,BLOCK,-1,,"{
        errno = ENOMEM;
        goto error;
    }",5,,324,2,,void
14147,BLOCK,-1,,<empty>,5,,329,1,,void
14157,BLOCK,4,,"{
        vals[i] = cfg->list.i[i];
        /* FIXME: use module_gettext() instead */
        txts[i] = strdup ((cfg->list_text[i] != NULL)
                                       ? vlc_gettext (cfg->list_text[i]) : """");
        if (unlikely(txts[i] == NULL))
        {
            for (int j = i - 1; j >= 0; --j)
                free(txts[j]);
            errno = ENOMEM;
            goto error;
        }
    }",5,,330,4,,void
14196,BLOCK,-1,,"{
            for (int j = i - 1; j >= 0; --j)
                free(txts[j]);
            errno = ENOMEM;
            goto error;
        }",9,,336,2,,void
14198,BLOCK,-1,,<empty>,13,,337,1,,void
14242,BLOCK,-1,,"{
    module_t **list;
    ssize_t n = module_list_cap (&list, cap);
    if (unlikely(n < 0))
    {
        *values = *texts = NULL;
        return n;
    }

    char **vals = xmalloc ((n + 2) * sizeof (*vals));
    char **txts = xmalloc ((n + 2) * sizeof (*txts));

    vals[0] = xstrdup (""any"");
    txts[0] = xstrdup (_(""Automatic""));

    for (ssize_t i = 0; i < n; i++)
    {
        vals[i + 1] = xstrdup (module_get_object (list[i]));
        txts[i + 1] = xstrdup (module_gettext (list[i],
                               module_get_name (list[i], true)));
    }

    vals[n + 1] = xstrdup (""none"");
    txts[n + 1] = xstrdup (_(""Disable""));

    *values = vals;
    *texts = txts;
    module_list_free (list);
    return n + 2;
}",1,,357,4,,void
14256,BLOCK,-1,,"{
        *values = *texts = NULL;
        return n;
    }",5,,361,2,,void
14302,BLOCK,-1,,<empty>,5,,372,1,,void
14312,BLOCK,4,,"{
        vals[i + 1] = xstrdup (module_get_object (list[i]));
        txts[i + 1] = xstrdup (module_gettext (list[i],
                               module_get_name (list[i], true)));
    }",5,,373,4,,void
14378,BLOCK,-1,,"{
    *values = *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        errno = ENOENT;
        return -1;
    }

    switch (cfg->i_type)
    {
        case CONFIG_ITEM_MODULE:
            return config_ListModules (cfg->psz_type, values, texts);
        default:
            if (!IsConfigStringType (cfg->i_type))
            {
                errno = EINVAL;
                return -1;
            }
            break;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.psz_cb == NULL)
            return 0;
        return cfg->list.psz_cb(obj, name, values, texts);
    }

    char **vals = xmalloc (sizeof (*vals) * count);
    char **txts = xmalloc (sizeof (*txts) * count);

    for (size_t i = 0; i < count; i++)
    {
        vals[i] = xstrdup ((cfg->list.psz[i] != NULL) ? cfg->list.psz[i] ...",1,,399,5,,void
14395,BLOCK,-1,,"{
        errno = ENOENT;
        return -1;
    }",5,,404,2,,void
14406,BLOCK,-1,,"{
        case CONFIG_ITEM_MODULE:
            return config_ListModules (cfg->psz_type, values, texts);
        default:
            if (!IsConfigStringType (cfg->i_type))
            {
                errno = EINVAL;
                return -1;
            }
            break;
    }",5,,410,2,,void
14423,BLOCK,1,,<empty>,,,,3,,void
14431,BLOCK,-1,,"{
                errno = EINVAL;
                return -1;
            }",13,,415,2,,void
14449,BLOCK,-1,,"{
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.psz_cb == NULL)
            return 0;
        return cfg->list.psz_cb(obj, name, values, texts);
    }",5,,424,2,,void
14456,BLOCK,-1,,"{
            errno = EIO;
            return -1;
        }",9,,426,2,,void
14471,BLOCK,-1,,<empty>,13,,432,2,,void
14504,BLOCK,-1,,<empty>,5,,439,1,,void
14514,BLOCK,4,,"{
        vals[i] = xstrdup ((cfg->list.psz[i] != NULL) ? cfg->list.psz[i] : """");
        /* FIXME: use module_gettext() instead */
        txts[i] = xstrdup ((cfg->list_text[i] != NULL)
                                       ? vlc_gettext (cfg->list_text[i]) : """");
    }",5,,440,4,,void
14573,BLOCK,-1,,"{
    const module_config_t *const *ca = a, *const *cb = b;

    return strcmp ((*ca)->psz_name, (*cb)->psz_name);
}",1,,453,3,,void
14597,BLOCK,-1,,"{
    const module_config_t *const *conf = elem;

    return strcmp (key, (*conf)->psz_name);
}",1,,460,3,,void
14622,BLOCK,-1,,"{
    vlc_plugin_t *p;
    size_t nconf = 0;

    for (p = vlc_plugins; p != NULL; p = p->next)
         nconf += p->conf.size;

    module_config_t **clist = vlc_alloc (nconf, sizeof (*clist));
    if (unlikely(clist == NULL))
        return VLC_ENOMEM;

    nconf = 0;
    for (p = vlc_plugins; p != NULL; p = p->next)
    {
        module_config_t *item, *end;

        for (item = p->conf.items, end = item + p->conf.size;
             item < end;
             item++)
        {
            if (!CONFIG_ITEM(item->i_type))
                continue; /* ignore hints */
            clist[nconf++] = item;
        }
    }

    qsort (clist, nconf, sizeof (*clist), confcmp);

    config.list = clist;
    config.count = nconf;
    return VLC_SUCCESS;
}",1,,476,2,,void
14629,BLOCK,-1,,<empty>,5,,480,1,,void
14661,BLOCK,-1,,<empty>,9,,485,2,,void
14668,BLOCK,-1,,<empty>,5,,488,1,,void
14680,BLOCK,4,,"{
        module_config_t *item, *end;

        for (item = p->conf.items, end = item + p->conf.size;
             item < end;
             item++)
        {
            if (!CONFIG_ITEM(item->i_type))
                continue; /* ignore hints */
            clist[nconf++] = item;
        }
    }",5,,489,4,,void
14684,BLOCK,-1,,<empty>,9,,492,1,,void
14707,BLOCK,4,,"{
            if (!CONFIG_ITEM(item->i_type))
                continue; /* ignore hints */
            clist[nconf++] = item;
        }",9,,495,4,,void
14714,BLOCK,-1,,<empty>,17,,497,2,,void
14745,BLOCK,-1,,"{
    module_config_t **clist;

    clist = config.list;
    config.list = NULL;
    config.count = 0;

    free (clist);
}",1,,510,2,,void
14768,BLOCK,-1,,"{
    if (unlikely(name == NULL))
        return NULL;

    module_config_t *const *p;
    p = bsearch (name, config.list, config.count, sizeof (*p), confnamecmp);
    return p ? *p : NULL;
}",1,,524,2,,void
14774,BLOCK,-1,,<empty>,9,,526,2,,void
14803,BLOCK,-1,,"{
    for (size_t j = 0; j < confsize; j++)
    {
        module_config_t *p_item = &tab[j];

        if (IsConfigStringType (p_item->i_type))
        {
            free (p_item->value.psz);
            if (p_item->list_count)
                free (p_item->list.psz);
        }

        free (p_item->list_text);
    }

    free (tab);
}",1,,539,3,,void
14805,BLOCK,-1,,<empty>,5,,540,1,,void
14815,BLOCK,4,,"{
        module_config_t *p_item = &tab[j];

        if (IsConfigStringType (p_item->i_type))
        {
            free (p_item->value.psz);
            if (p_item->list_count)
                free (p_item->list.psz);
        }

        free (p_item->list_text);
    }",5,,541,4,,void
14828,BLOCK,1,,<empty>,,,,3,,void
14836,BLOCK,-1,,"{
            free (p_item->value.psz);
            if (p_item->list_count)
                free (p_item->list.psz);
        }",9,,545,2,,void
14847,BLOCK,-1,,<empty>,17,,548,2,,void
14864,BLOCK,-1,,"{
    vlc_rwlock_wrlock (&config_lock);
    for (vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
    {
        for (size_t i = 0; i < p->conf.size; i++ )
        {
            module_config_t *p_config = p->conf.items + i;

            if (IsConfigIntegerType (p_config->i_type))
                p_config->value.i = p_config->orig.i;
            else
            if (IsConfigFloatType (p_config->i_type))
                p_config->value.f = p_config->orig.f;
            else
            if (IsConfigStringType (p_config->i_type))
            {
                free ((char *)p_config->value.psz);
                p_config->value.psz =
                        strdupnull (p_config->orig.psz);
            }
        }
    }
    vlc_rwlock_unlock (&config_lock);

    VLC_UNUSED(p_this);
}",1,,562,2,,void
14869,BLOCK,-1,,<empty>,5,,564,1,,void
14882,BLOCK,4,,"{
        for (size_t i = 0; i < p->conf.size; i++ )
        {
            module_config_t *p_config = p->conf.items + i;

            if (IsConfigIntegerType (p_config->i_type))
                p_config->value.i = p_config->orig.i;
            else
            if (IsConfigFloatType (p_config->i_type))
                p_config->value.f = p_config->orig.f;
            else
            if (IsConfigStringType (p_config->i_type))
            {
                free ((char *)p_config->value.psz);
                p_config->value.psz =
                        strdupnull (p_config->orig.psz);
            }
        }
    }",5,,565,4,,void
14884,BLOCK,-1,,<empty>,9,,566,1,,void
14898,BLOCK,4,,"{
            module_config_t *p_config = p->conf.items + i;

            if (IsConfigIntegerType (p_config->i_type))
                p_config->value.i = p_config->orig.i;
            else
            if (IsConfigFloatType (p_config->i_type))
                p_config->value.f = p_config->orig.f;
            else
            if (IsConfigStringType (p_config->i_type))
            {
                free ((char *)p_config->value.psz);
                p_config->value.psz =
                        strdupnull (p_config->orig.psz);
            }
        }",9,,567,4,,void
14914,BLOCK,1,,<empty>,,,,3,,void
14922,BLOCK,-1,,<empty>,17,,571,2,,void
14935,BLOCK,-1,,<empty>,13,,573,1,,void
14941,BLOCK,1,,<empty>,,,,3,,void
14947,BLOCK,-1,,<empty>,17,,574,2,,void
14960,BLOCK,-1,,<empty>,13,,576,1,,void
14966,BLOCK,1,,<empty>,,,,3,,void
14974,BLOCK,-1,,"{
                free ((char *)p_config->value.psz);
                p_config->value.psz =
                        strdupnull (p_config->orig.psz);
            }",13,,577,2,,void
15042,BLOCK,-1,,<empty>,1,,1,1,,ANY
15045,BLOCK,-1,,"{
    return src ? strdup (src) : NULL;
}",1,,52,2,,void
15056,BLOCK,-1,,"{
    char *psz_file = var_CreateGetNonEmptyString( obj, ""config"" );
    var_Destroy( obj, ""config"" );
    if( psz_file == NULL )
    {
        char *psz_dir = config_GetUserDir( VLC_CONFIG_DIR );

        if( asprintf( &psz_file, ""%s"" DIR_SEP CONFIG_FILE, psz_dir ) == -1 )
            psz_file = NULL;
        free( psz_dir );
    }
    return psz_file;
}",1,,60,2,,void
15070,BLOCK,-1,,"{
        char *psz_dir = config_GetUserDir( VLC_CONFIG_DIR );

        if( asprintf( &psz_file, ""%s"" DIR_SEP CONFIG_FILE, psz_dir ) == -1 )
            psz_file = NULL;
        free( psz_dir );
    }",5,,64,2,,void
15078,BLOCK,-1,,<empty>,13,,68,2,,void
15090,BLOCK,-1,,"{
    char *psz_filename = config_GetConfigFile( p_obj );
    if( psz_filename == NULL )
        return NULL;

    msg_Dbg( p_obj, ""opening config file (%s)"", psz_filename );

    FILE *p_stream = vlc_fopen( psz_filename, ""rt"" );
    if( p_stream == NULL && errno != ENOENT )
    {
        msg_Err( p_obj, ""cannot open config file (%s): %s"",
                 psz_filename, vlc_strerror_c(errno) );

    }
#if !( defined(_WIN32) || defined(__APPLE__) || defined(__OS2__) )
    else if( p_stream == NULL && errno == ENOENT )
    {
        /* This is the fallback for pre XDG Base Directory
         * Specification configs */
        char *home = config_GetUserDir(VLC_HOME_DIR);
        char *psz_old;

        if( home != NULL
         && asprintf( &psz_old, ""%s/.vlc/"" CONFIG_FILE,
                      home ) != -1 )
        {
            p_stream = vlc_fopen( psz_old, ""rt"" );
            if( p_stream )
            {
                /* Old config file found. We want to write it at the
      ...",1,,75,2,,void
15100,BLOCK,-1,,<empty>,9,,78,2,,void
15121,BLOCK,-1,,"{
        msg_Err( p_obj, ""cannot open config file (%s): %s"",
                 psz_filename, vlc_strerror_c(errno) );

    }",5,,84,2,,void
15129,BLOCK,-1,,<empty>,10,,90,1,,void
15138,BLOCK,-1,,"{
        /* This is the fallback for pre XDG Base Directory
         * Specification configs */
        char *home = config_GetUserDir(VLC_HOME_DIR);
        char *psz_old;

        if( home != NULL
         && asprintf( &psz_old, ""%s/.vlc/"" CONFIG_FILE,
                      home ) != -1 )
        {
            p_stream = vlc_fopen( psz_old, ""rt"" );
            if( p_stream )
            {
                /* Old config file found. We want to write it at the
                 * new location now. */
                msg_Info( p_obj, ""Found old config file at %s. ""
                          ""VLC will now use %s."", psz_old, psz_filename );
                char *psz_readme;
                if( asprintf(&psz_readme,""%s/.vlc/README"",
                             home ) != -1 )
                {
                    FILE *p_readme = vlc_fopen( psz_readme, ""wt"" );
                    if( p_readme )
                    {
                        fprintf( p_readme, ""The VLC media player ""
      ...",5,,91,2,,void
15158,BLOCK,-1,,"{
            p_stream = vlc_fopen( psz_old, ""rt"" );
            if( p_stream )
            {
                /* Old config file found. We want to write it at the
                 * new location now. */
                msg_Info( p_obj, ""Found old config file at %s. ""
                          ""VLC will now use %s."", psz_old, psz_filename );
                char *psz_readme;
                if( asprintf(&psz_readme,""%s/.vlc/README"",
                             home ) != -1 )
                {
                    FILE *p_readme = vlc_fopen( psz_readme, ""wt"" );
                    if( p_readme )
                    {
                        fprintf( p_readme, ""The VLC media player ""
                                 ""configuration folder has moved to comply\n""
                                 ""with the XDG Base Directory Specification ""
                                 ""version 0.6. Your\nconfiguration has been ""
                                 ""copied to the new location:\n%s\nYou ca...",9,,100,2,,void
15166,BLOCK,-1,,"{
                /* Old config file found. We want to write it at the
                 * new location now. */
                msg_Info( p_obj, ""Found old config file at %s. ""
                          ""VLC will now use %s."", psz_old, psz_filename );
                char *psz_readme;
                if( asprintf(&psz_readme,""%s/.vlc/README"",
                             home ) != -1 )
                {
                    FILE *p_readme = vlc_fopen( psz_readme, ""wt"" );
                    if( p_readme )
                    {
                        fprintf( p_readme, ""The VLC media player ""
                                 ""configuration folder has moved to comply\n""
                                 ""with the XDG Base Directory Specification ""
                                 ""version 0.6. Your\nconfiguration has been ""
                                 ""copied to the new location:\n%s\nYou can ""
                                 ""delete this directory and all its contents."",
        ...",13,,103,2,,void
15182,BLOCK,-1,,"{
                    FILE *p_readme = vlc_fopen( psz_readme, ""wt"" );
                    if( p_readme )
                    {
                        fprintf( p_readme, ""The VLC media player ""
                                 ""configuration folder has moved to comply\n""
                                 ""with the XDG Base Directory Specification ""
                                 ""version 0.6. Your\nconfiguration has been ""
                                 ""copied to the new location:\n%s\nYou can ""
                                 ""delete this directory and all its contents."",
                                  psz_filename);
                        fclose( p_readme );
                    }
                    free( psz_readme );
                }",17,,111,2,,void
15191,BLOCK,-1,,"{
                        fprintf( p_readme, ""The VLC media player ""
                                 ""configuration folder has moved to comply\n""
                                 ""with the XDG Base Directory Specification ""
                                 ""version 0.6. Your\nconfiguration has been ""
                                 ""copied to the new location:\n%s\nYou can ""
                                 ""delete this directory and all its contents."",
                                  psz_filename);
                        fclose( p_readme );
                    }",21,,114,2,,void
15214,BLOCK,-1,,"{
    char *end;
    long long l;

    errno = 0;
    l = strtoll (str, &end, 0);

    if (!errno)
    {
#if (LLONG_MAX > 0x7fffffffffffffffLL)
        if (l > 0x7fffffffffffffffLL
         || l < -0x8000000000000000LL)
            errno = ERANGE;
#endif
        if (*end)
            errno = EINVAL;
    }
    return l;
}",1,,142,2,,void
15230,BLOCK,-1,,"{
#if (LLONG_MAX > 0x7fffffffffffffffLL)
        if (l > 0x7fffffffffffffffLL
         || l < -0x8000000000000000LL)
            errno = ERANGE;
#endif
        if (*end)
            errno = EINVAL;
    }",5,,150,2,,void
15234,BLOCK,-1,,<empty>,13,,157,2,,void
15244,BLOCK,-1,,"{
    FILE *file;

    file = config_OpenConfigFile (p_this);
    if (file == NULL)
        return VLC_EGENERIC;

    /* Skip UTF-8 Byte Order Mark if present */
    char bom[3];
    if (fread (bom, 1, 3, file) != 3 || memcmp (bom, ""\xEF\xBB\xBF"", 3))
        rewind (file); /* no BOM, rewind */

    char *line = NULL;
    size_t bufsize;
    ssize_t linelen;

    /* Ensure consistent number formatting... */
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t baseloc = uselocale (loc);

    vlc_rwlock_wrlock (&config_lock);
    while ((linelen = getline (&line, &bufsize, file)) != -1)
    {
        line[linelen - 1] = '\0'; /* trim newline */

        /* Ignore comments, section and empty lines */
        if (memchr (""#["", line[0], 3) != NULL)
            continue;

        /* look for option name */
        const char *psz_option_name = line;

        char *ptr = strchr (line, '=');
        if (ptr == NULL)
            continue; /* syntax error */
        *ptr = ...",1,,170,2,,void
15254,BLOCK,-1,,<empty>,9,,175,2,,void
15271,BLOCK,-1,,<empty>,9,,180,2,,void
15307,BLOCK,-1,,"{
        line[linelen - 1] = '\0'; /* trim newline */

        /* Ignore comments, section and empty lines */
        if (memchr (""#["", line[0], 3) != NULL)
            continue;

        /* look for option name */
        const char *psz_option_name = line;

        char *ptr = strchr (line, '=');
        if (ptr == NULL)
            continue; /* syntax error */
        *ptr = '\0';

        module_config_t *item = config_FindConfig(psz_option_name);
        if (item == NULL)
            continue;

        const char *psz_option_value = ptr + 1;
        switch (CONFIG_CLASS(item->i_type))
        {
            case CONFIG_ITEM_BOOL:
            case CONFIG_ITEM_INTEGER:
            {
                int64_t l;

                errno = 0;
                l = vlc_strtoi (psz_option_value);
                if ((l > item->max.i) || (l < item->min.i))
                    errno = ERANGE;
                if (errno)
                    msg_Warn (p_this, ""Integer value (%s) for %s: %s"",
  ...",5,,192,2,,void
15324,BLOCK,-1,,<empty>,13,,197,2,,void
15340,BLOCK,-1,,<empty>,13,,204,2,,void
15355,BLOCK,-1,,<empty>,13,,209,2,,void
15368,BLOCK,1,,<empty>,,,,3,,void
15375,BLOCK,-1,,"{
            case CONFIG_ITEM_BOOL:
            case CONFIG_ITEM_INTEGER:
            {
                int64_t l;

                errno = 0;
                l = vlc_strtoi (psz_option_value);
                if ((l > item->max.i) || (l < item->min.i))
                    errno = ERANGE;
                if (errno)
                    msg_Warn (p_this, ""Integer value (%s) for %s: %s"",
                              psz_option_value, psz_option_name,
                              vlc_strerror_c(errno));
                else
                    item->value.i = l;
                break;
            }

            case CONFIG_ITEM_FLOAT:
                if (!*psz_option_value)
                    break;                    /* ignore empty option */
                item->value.f = (float)atof (psz_option_value);
                break;

            default:
                free (item->value.psz);
                item->value.psz = strdupnull (psz_option_value);
                break;
        }",9,,213,2,,void
15380,BLOCK,5,,"{
                int64_t l;

                errno = 0;
                l = vlc_strtoi (psz_option_value);
                if ((l > item->max.i) || (l < item->min.i))
                    errno = ERANGE;
                if (errno)
                    msg_Warn (p_this, ""Integer value (%s) for %s: %s"",
                              psz_option_value, psz_option_name,
                              vlc_strerror_c(errno));
                else
                    item->value.i = l;
                break;
            }",13,,216,5,,void
15405,BLOCK,-1,,<empty>,21,,222,2,,void
15411,BLOCK,-1,,<empty>,21,,224,2,,void
15420,BLOCK,-1,,<empty>,21,,228,1,,void
15435,BLOCK,-1,,<empty>,21,,234,2,,void
15472,BLOCK,-1,,"{
        msg_Err (p_this, ""error reading configuration: %s"",
                 vlc_strerror_c(errno));
        clearerr (file);
    }",5,,248,2,,void
15488,BLOCK,-1,,"{
        uselocale (baseloc);
        freelocale (loc);
    }",5,,256,2,,void
15500,BLOCK,-1,,"{
    if( !psz_dirname || !*psz_dirname ) return -1;

    if( vlc_mkdir( psz_dirname, 0700 ) == 0 )
        return 0;

    switch( errno )
    {
        case EEXIST:
            return 0;

        case ENOENT:
        {
            /* Let's try to create the parent directory */
            char psz_parent[strlen( psz_dirname ) + 1], *psz_end;
            strcpy( psz_parent, psz_dirname );

            psz_end = strrchr( psz_parent, DIR_SEP_CHAR );
            if( psz_end && psz_end != psz_parent )
            {
                *psz_end = '\0';
                if( config_CreateDir( p_this, psz_parent ) == 0 )
                {
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }
            }
        }
    }

    msg_Warn( p_this, ""could not create %s: %s"", psz_dirname,
              vlc_strerror_c(errno) );
    return -1;
}",1,,267,3,,void
15508,BLOCK,-1,,<empty>,41,,268,2,,void
15518,BLOCK,-1,,<empty>,9,,271,2,,void
15523,BLOCK,-1,,"{
        case EEXIST:
            return 0;

        case ENOENT:
        {
            /* Let's try to create the parent directory */
            char psz_parent[strlen( psz_dirname ) + 1], *psz_end;
            strcpy( psz_parent, psz_dirname );

            psz_end = strrchr( psz_parent, DIR_SEP_CHAR );
            if( psz_end && psz_end != psz_parent )
            {
                *psz_end = '\0';
                if( config_CreateDir( p_this, psz_parent ) == 0 )
                {
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }
            }
        }
    }",5,,274,2,,void
15530,BLOCK,6,,"{
            /* Let's try to create the parent directory */
            char psz_parent[strlen( psz_dirname ) + 1], *psz_end;
            strcpy( psz_parent, psz_dirname );

            psz_end = strrchr( psz_parent, DIR_SEP_CHAR );
            if( psz_end && psz_end != psz_parent )
            {
                *psz_end = '\0';
                if( config_CreateDir( p_this, psz_parent ) == 0 )
                {
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }
            }
        }",9,,279,6,,void
15547,BLOCK,-1,,"{
                *psz_end = '\0';
                if( config_CreateDir( p_this, psz_parent ) == 0 )
                {
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }
            }",13,,286,2,,void
15558,BLOCK,-1,,"{
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }",17,,289,2,,void
15564,BLOCK,-1,,<empty>,25,,291,2,,void
15585,BLOCK,-1,,"{
    va_list ap;
    int ret;

    if (desc == NULL)
        desc = ""?"";

    if (fprintf (file, ""# %s (%s)\n%s%s="", desc, vlc_gettext (type),
                 comment ? ""#"" : """", name) < 0)
        return -1;

    va_start (ap, fmt);
    ret = vfprintf (file, fmt, ap);
    va_end (ap);
    if (ret < 0)
        return -1;

    if (fputs (""\n\n"", file) == EOF)
        return -1;
    return 0;
}",1,,305,7,,void
15592,BLOCK,-1,,<empty>,9,,310,2,,void
15610,BLOCK,-1,,<empty>,9,,314,2,,void
15629,BLOCK,-1,,<empty>,9,,320,2,,void
15639,BLOCK,-1,,<empty>,9,,323,2,,void
15649,BLOCK,-1,,"{
    char *psz_configdir = config_GetUserDir (VLC_CONFIG_DIR);
    if (psz_configdir == NULL)
        return -1;

    int ret = config_CreateDir (obj, psz_configdir);
    free (psz_configdir);
    return ret;
}",1,,329,2,,void
15659,BLOCK,-1,,<empty>,9,,332,2,,void
15677,BLOCK,-1,,"{

    if( config_PrepareDir( p_this ) )
    {
        msg_Err( p_this, ""no configuration directory"" );
        return -1;
    }

    /*
     * Save module config in file
     */
    char *temporary;
    char *permanent = config_GetConfigFile (p_this);
    if (permanent == NULL)
        return -1;
    if (asprintf (&temporary, ""%s.%u"", permanent, getpid ()) == -1)
    {
        free (permanent);
        return -1;
    }
    else
    {
        struct stat st;

        /* Some users make vlcrc read-only to prevent changes.
         * The atomic replacement scheme breaks this ""feature"",
         * so we check for read-only by hand. */
        if (stat (permanent, &st) == 0 && !(st.st_mode & S_IWUSR))
        {
            msg_Err (p_this, ""configuration file is read-only"");
            goto error;
        }
    }

    /* Configuration lock must be taken before vlcrc serializer below. */
    vlc_rwlock_rdlock (&config_lock);

    /* The temporary configuration file is per-PID. Therefore...",1,,345,2,,void
15681,BLOCK,-1,,"{
        msg_Err( p_this, ""no configuration directory"" );
        return -1;
    }",5,,348,2,,void
15698,BLOCK,-1,,<empty>,9,,359,2,,void
15712,BLOCK,-1,,"{
        free (permanent);
        return -1;
    }",5,,361,2,,void
15719,BLOCK,-1,,"{
        struct stat st;

        /* Some users make vlcrc read-only to prevent changes.
         * The atomic replacement scheme breaks this ""feature"",
         * so we check for read-only by hand. */
        if (stat (permanent, &st) == 0 && !(st.st_mode & S_IWUSR))
        {
            msg_Err (p_this, ""configuration file is read-only"");
            goto error;
        }
    }",5,,366,1,,void
15735,BLOCK,-1,,"{
            msg_Err (p_this, ""configuration file is read-only"");
            goto error;
        }",9,,373,2,,void
15768,BLOCK,-1,,"{
        vlc_rwlock_unlock (&config_lock);
        vlc_mutex_unlock (&lock);
        goto error;
    }",5,,389,2,,void
15786,BLOCK,-1,,"{
        msg_Err (p_this, ""cannot create configuration file: %s"",
                 vlc_strerror_c(errno));
        vlc_rwlock_unlock (&config_lock);
        vlc_close (fd);
        vlc_mutex_unlock (&lock);
        goto error;
    }",5,,396,2,,void
15815,BLOCK,-1,,<empty>,5,,424,1,,void
15828,BLOCK,4,,"{
        module_t *p_parser = p->module;
        module_config_t *p_item, *p_end;

        if (p->conf.count == 0)
            continue;

        fprintf( file, ""[%s]"", module_get_object (p_parser) );
        if( p_parser->psz_longname )
            fprintf( file, "" # %s\n\n"", p_parser->psz_longname );
        else
            fprintf( file, ""\n\n"" );

        for (p_item = p->conf.items, p_end = p_item + p->conf.size;
             p_item < p_end;
             p_item++)
        {
            if (!CONFIG_ITEM(p_item->i_type)   /* ignore hint */
             || p_item->b_removed              /* ignore deprecated option */
             || p_item->b_unsaveable)          /* ignore volatile option */
                continue;

            if (IsConfigIntegerType (p_item->i_type))
            {
                int64_t val = p_item->value.i;
                config_Write (file, p_item->psz_text,
                             (CONFIG_CLASS(p_item->i_type) == CONFIG_ITEM_BOOL)
                ...",5,,425,4,,void
15845,BLOCK,-1,,<empty>,13,,430,2,,void
15856,BLOCK,-1,,<empty>,13,,434,2,,void
15864,BLOCK,-1,,<empty>,13,,436,1,,void
15869,BLOCK,-1,,<empty>,9,,438,1,,void
15892,BLOCK,4,,"{
            if (!CONFIG_ITEM(p_item->i_type)   /* ignore hint */
             || p_item->b_removed              /* ignore deprecated option */
             || p_item->b_unsaveable)          /* ignore volatile option */
                continue;

            if (IsConfigIntegerType (p_item->i_type))
            {
                int64_t val = p_item->value.i;
                config_Write (file, p_item->psz_text,
                             (CONFIG_CLASS(p_item->i_type) == CONFIG_ITEM_BOOL)
                                  ? N_(""boolean"") : N_(""integer""),
                              val == p_item->orig.i,
                              p_item->psz_name, ""%""PRId64, val);
            }
            else
            if (IsConfigFloatType (p_item->i_type))
            {
                float val = p_item->value.f;
                config_Write (file, p_item->psz_text, N_(""float""),
                              val == p_item->orig.f,
                              p_item->psz_name, ""%f"",...",9,,441,4,,void
15907,BLOCK,-1,,<empty>,17,,445,2,,void
15914,BLOCK,1,,<empty>,,,,3,,void
15922,BLOCK,-1,,"{
                int64_t val = p_item->value.i;
                config_Write (file, p_item->psz_text,
                             (CONFIG_CLASS(p_item->i_type) == CONFIG_ITEM_BOOL)
                                  ? N_(""boolean"") : N_(""integer""),
                              val == p_item->orig.i,
                              p_item->psz_name, ""%""PRId64, val);
            }",13,,448,2,,void
15933,BLOCK,-1,,<empty>,13,,457,1,,void
15939,BLOCK,1,,<empty>,,,,3,,void
15945,BLOCK,-1,,"{
                float val = p_item->value.f;
                config_Write (file, p_item->psz_text, N_(""float""),
                              val == p_item->orig.f,
                              p_item->psz_name, ""%f"", val);
            }",13,,458,2,,void
15974,BLOCK,-1,,"{
                const char *psz_value = p_item->value.psz;
                bool modified;

                assert (IsConfigStringType (p_item->i_type));

                modified = !!strcmp (psz_value ? psz_value : """",
                                     p_item->orig.psz ? p_item->orig.psz : """");
                config_Write (file, p_item->psz_text, N_(""string""),
                              !modified, p_item->psz_name, ""%s"",
                              psz_value ? psz_value : """");
            }",13,,465,1,,void
15989,BLOCK,1,,<empty>,,,,3,,void
16044,BLOCK,-1,,"{
        uselocale (baseloc);
        freelocale (loc);
    }",5,,482,2,,void
16054,BLOCK,-1,,"{
        vlc_unlink (temporary);
        vlc_mutex_unlock (&lock);
        msg_Err (p_this, ""cannot write configuration file"");
        fclose (file);
        goto error;
    }",5,,492,2,,void
16072,BLOCK,-1,,<empty>,9,,507,2,,void
16098,BLOCK,-1,,"{
    int ret = 0;

    assert( p_this );

    vlc_rwlock_rdlock (&config_lock);
    if (config_dirty)
    {
        /* Note: this will get the read lock recursively. Ok. */
        ret = config_SaveConfigFile (p_this);
        config_dirty = (ret != 0);
    }
    vlc_rwlock_unlock (&config_lock);

    return ret;
}",1,,526,2,,void
16110,BLOCK,-1,,"{
        /* Note: this will get the read lock recursively. Ok. */
        ret = config_SaveConfigFile (p_this);
        config_dirty = (ret != 0);
    }",5,,533,2,,void
16141,BLOCK,-1,,<empty>,1,,1,1,,ANY
16145,BLOCK,-1,,"{
    int bottom = state->first_nonopt;
    int middle = state->last_nonopt;
    int top = state->ind;
    char *tem;

    /* Exchange the shorter segment with the far end of the longer segment.
       That puts the shorter segment into the right place.
       It leaves the longer segment in the right place overall,
       but it consists of two parts that need to be swapped next.  */

    while (top > middle && middle > bottom)
    {
        if (top - middle > middle - bottom)
        {
            /* Bottom segment is the short one.  */
            int len = middle - bottom;
            register int i;

            /* Swap it with the top part of the top segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[top - (middle - bottom) + i];
                argv[top - (middle - bottom) + i] = tem;
            }
            /* Exclude the moved bottom segment from further swapping.  */
           ...",1,,42,3,,void
16173,BLOCK,-1,,"{
        if (top - middle > middle - bottom)
        {
            /* Bottom segment is the short one.  */
            int len = middle - bottom;
            register int i;

            /* Swap it with the top part of the top segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[top - (middle - bottom) + i];
                argv[top - (middle - bottom) + i] = tem;
            }
            /* Exclude the moved bottom segment from further swapping.  */
            top -= len;
        }
        else
        {
            /* Top segment is the short one.  */
            int len = top - middle;
            register int i;

            /* Swap it with the bottom part of the bottom segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[middle + i];
                argv[middle + i] = tem;
            }
       ...",5,,54,2,,void
16182,BLOCK,-1,,"{
            /* Bottom segment is the short one.  */
            int len = middle - bottom;
            register int i;

            /* Swap it with the top part of the top segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[top - (middle - bottom) + i];
                argv[top - (middle - bottom) + i] = tem;
            }
            /* Exclude the moved bottom segment from further swapping.  */
            top -= len;
        }",9,,56,2,,void
16191,BLOCK,-1,,<empty>,13,,62,1,,void
16200,BLOCK,4,,"{
                tem = argv[bottom + i];
                argv[bottom + i] = argv[top - (middle - bottom) + i];
                argv[top - (middle - bottom) + i] = tem;
            }",13,,63,4,,void
16238,BLOCK,-1,,"{
            /* Top segment is the short one.  */
            int len = top - middle;
            register int i;

            /* Swap it with the bottom part of the bottom segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[middle + i];
                argv[middle + i] = tem;
            }
            /* Exclude the moved top segment from further swapping.  */
            bottom += len;
        }",9,,72,1,,void
16247,BLOCK,-1,,<empty>,13,,78,1,,void
16256,BLOCK,4,,"{
                tem = argv[bottom + i];
                argv[bottom + i] = argv[middle + i];
                argv[middle + i] = tem;
            }",13,,79,4,,void
16312,BLOCK,-1,,"{
    state->arg = NULL;

    if (state->ind == 0)
    {
        /* Initialize the internal data when the first call is made.  */
        /* Start processing options with ARGV-element 1 (since ARGV-element 0
           is the program name); the sequence of previously skipped
           non-option ARGV-elements is empty.  */
        state->first_nonopt = state->last_nonopt = state->ind = 1;
        state->nextchar = NULL;
    }

#define NONOPTION_P (argv[state->ind][0] != '-' || argv[state->ind][1] == '\0')

    if (state->nextchar == NULL || *state->nextchar == '\0')
    {
        /* Advance to the next ARGV-element.  */

        /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
           moved back by the user (who may also have changed the arguments).  */
        if (state->last_nonopt > state->ind)
            state->last_nonopt = state->ind;
        if (state->first_nonopt > state->ind)
            state->first_nonopt = state->ind;

        /* If we have jus...",1,,150,7,,void
16324,BLOCK,-1,,"{
        /* Initialize the internal data when the first call is made.  */
        /* Start processing options with ARGV-element 1 (since ARGV-element 0
           is the program name); the sequence of previously skipped
           non-option ARGV-elements is empty.  */
        state->first_nonopt = state->last_nonopt = state->ind = 1;
        state->nextchar = NULL;
    }",5,,154,2,,void
16356,BLOCK,-1,,"{
        /* Advance to the next ARGV-element.  */

        /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
           moved back by the user (who may also have changed the arguments).  */
        if (state->last_nonopt > state->ind)
            state->last_nonopt = state->ind;
        if (state->first_nonopt > state->ind)
            state->first_nonopt = state->ind;

        /* If we have just processed some options following some non-options,
           exchange them so that the options come first.  */

        if (state->first_nonopt != state->last_nonopt
            && state->last_nonopt != state->ind)
            exchange((char **) argv, state);
        else if (state->last_nonopt != state->ind)
            state->first_nonopt = state->ind;

        /* Skip any additional non-options
           and extend the range of non-options previously skipped.  */

        while (state->ind < argc && NONOPTION_P)
            state->ind++;
        state->last_nonopt ...",5,,166,2,,void
16365,BLOCK,-1,,<empty>,13,,172,2,,void
16381,BLOCK,-1,,<empty>,13,,174,2,,void
16405,BLOCK,-1,,<empty>,13,,181,2,,void
16412,BLOCK,-1,,<empty>,14,,182,1,,void
16421,BLOCK,-1,,<empty>,13,,183,2,,void
16437,BLOCK,1,,<empty>,,,,1,,void
16483,BLOCK,-1,,"{
            state->ind++;

            if (state->first_nonopt != state->last_nonopt
                && state->last_nonopt != state->ind)
                exchange((char **) argv, state);
            else if (state->first_nonopt == state->last_nonopt)
                state->first_nonopt = state->ind;
            state->last_nonopt = argc;

            state->ind = argc;
        }",9,,198,2,,void
16504,BLOCK,-1,,<empty>,17,,203,2,,void
16511,BLOCK,-1,,<empty>,18,,204,1,,void
16520,BLOCK,-1,,<empty>,17,,205,2,,void
16544,BLOCK,-1,,"{
            /* Set the next-arg-index to point at the non-options
               that we previously skipped, so the caller will digest them.  */
            if (state->first_nonopt != state->last_nonopt)
                state->ind = state->first_nonopt;
            return -1;
        }",9,,215,2,,void
16553,BLOCK,-1,,<empty>,17,,219,2,,void
16566,BLOCK,1,,<empty>,,,,1,,void
16586,BLOCK,-1,,"{
            state->arg = argv[state->ind++];
            return 1;
        }",9,,227,2,,void
16630,BLOCK,-1,,"{
        char *nameend;
        const struct vlc_option *p;
        const struct vlc_option *pfound = NULL;
        int exact = 0;
        int ambig = 0;
        int indfound = -1;
        int option_index;

        for (nameend = state->nextchar; *nameend && *nameend != '='; nameend++)
            /* Do nothing.  */ ;

        /* Test all long options for either exact match
           or abbreviated matches.  */
        for (p = longopts, option_index = 0; p->name; p++, option_index++)
            if (!strncmp(p->name, state->nextchar, nameend - state->nextchar))
            {
                if ((unsigned int) (nameend - state->nextchar)
                    == (unsigned int) strlen(p->name))
                {
                    /* Exact match found.  */
                    pfound = p;
                    indfound = option_index;
                    exact = 1;
                    break;
                }
                else if (pfound == NULL)
                {
                 ...",5,,244,2,,void
16652,BLOCK,-1,,<empty>,9,,253,1,,void
16668,BLOCK,-1,,<empty>,9,,258,1,,void
16698,BLOCK,-1,,"{
                if ((unsigned int) (nameend - state->nextchar)
                    == (unsigned int) strlen(p->name))
                {
                    /* Exact match found.  */
                    pfound = p;
                    indfound = option_index;
                    exact = 1;
                    break;
                }
                else if (pfound == NULL)
                {
                    /* First nonexact match found.  */
                    pfound = p;
                    indfound = option_index;
                }
                else
                    /* Second or later nonexact match found.  */
                    ambig = 1;
            }",13,,260,2,,void
16714,BLOCK,-1,,"{
                    /* Exact match found.  */
                    pfound = p;
                    indfound = option_index;
                    exact = 1;
                    break;
                }",17,,263,2,,void
16726,BLOCK,-1,,<empty>,22,,270,1,,void
16731,BLOCK,-1,,"{
                    /* First nonexact match found.  */
                    pfound = p;
                    indfound = option_index;
                }",17,,271,2,,void
16739,BLOCK,-1,,<empty>,21,,278,1,,void
16748,BLOCK,-1,,"{
            state->nextchar += strlen(state->nextchar);
            state->ind++;
            state->opt = 0;
            return '?';
        }",9,,282,2,,void
16772,BLOCK,-1,,"{
            option_index = indfound;
            state->ind++;
            if (*nameend)
            {
                if (pfound->has_arg)
                    state->arg = nameend + 1;
                else
                {
                    state->nextchar += strlen(state->nextchar);

                    state->opt = pfound->val;
                    return '?';
                }
            }
            else if (pfound->has_arg)
            {
                if (state->ind < argc)
                    state->arg = argv[state->ind++];
                else
                {
                    state->nextchar += strlen(state->nextchar);
                    state->opt = pfound->val;
                    return optstring[0] == ':' ? ':' : '?';
                }
            }
            state->nextchar += strlen(state->nextchar);
            if (longind != NULL)
                *longind = option_index;
            if (pfound->flag)
            {
                *(pfound->flag) = pf...",9,,290,2,,void
16783,BLOCK,-1,,"{
                if (pfound->has_arg)
                    state->arg = nameend + 1;
                else
                {
                    state->nextchar += strlen(state->nextchar);

                    state->opt = pfound->val;
                    return '?';
                }
            }",13,,294,2,,void
16788,BLOCK,-1,,<empty>,21,,296,2,,void
16797,BLOCK,-1,,"{
                    state->nextchar += strlen(state->nextchar);

                    state->opt = pfound->val;
                    return '?';
                }",17,,298,1,,void
16816,BLOCK,-1,,<empty>,18,,305,1,,void
16821,BLOCK,-1,,"{
                if (state->ind < argc)
                    state->arg = argv[state->ind++];
                else
                {
                    state->nextchar += strlen(state->nextchar);
                    state->opt = pfound->val;
                    return optstring[0] == ':' ? ':' : '?';
                }
            }",13,,306,2,,void
16828,BLOCK,-1,,<empty>,21,,308,2,,void
16840,BLOCK,-1,,"{
                    state->nextchar += strlen(state->nextchar);
                    state->opt = pfound->val;
                    return optstring[0] == ':' ? ':' : '?';
                }",17,,310,1,,void
16877,BLOCK,-1,,<empty>,17,,318,2,,void
16886,BLOCK,-1,,"{
                *(pfound->flag) = pfound->val;
                return 0;
            }",13,,320,2,,void
16919,BLOCK,5,,"{
        char c = *(state->nextchar)++;
        char *temp = strchr(optstring, c);

        /* Increment `optind' when we start to process its last character.  */
        if (*state->nextchar == '\0')
            ++state->ind;

        if (temp == NULL || c == ':')
        {
            state->opt = c;
            return '?';
        }
        /* Convenience. Treat POSIX -W foo same as long option --foo */
        if (temp[0] == 'W' && temp[1] == ';')
        {
            char *nameend;
            const struct vlc_option *p;
            const struct vlc_option *pfound = NULL;
            int exact = 0;
            int ambig = 0;
            int indfound = 0;
            int option_index;

            /* This is an option that requires an argument.  */
            if (*state->nextchar != '\0')
            {
                state->arg = state->nextchar;
                /* If we end this ARGV-element by taking the rest as an arg,
                   we must advance to the next elemen...",5,,335,5,,void
16941,BLOCK,-1,,<empty>,13,,341,2,,void
16954,BLOCK,-1,,"{
            state->opt = c;
            return '?';
        }",9,,344,2,,void
16974,BLOCK,-1,,"{
            char *nameend;
            const struct vlc_option *p;
            const struct vlc_option *pfound = NULL;
            int exact = 0;
            int ambig = 0;
            int indfound = 0;
            int option_index;

            /* This is an option that requires an argument.  */
            if (*state->nextchar != '\0')
            {
                state->arg = state->nextchar;
                /* If we end this ARGV-element by taking the rest as an arg,
                   we must advance to the next element now.  */
                state->ind++;
            }
            else if (state->ind == argc)
            {
                state->opt = c;
                if (optstring[0] == ':')
                    c = ':';
                else
                    c = '?';
                return c;
            }
            else
                /* We already incremented `optind' once;
                   increment it again when taking next ARGV-elt as argument.  */
        ...",9,,350,2,,void
17001,BLOCK,-1,,"{
                state->arg = state->nextchar;
                /* If we end this ARGV-element by taking the rest as an arg,
                   we must advance to the next element now.  */
                state->ind++;
            }",13,,361,2,,void
17014,BLOCK,-1,,<empty>,18,,367,1,,void
17021,BLOCK,-1,,"{
                state->opt = c;
                if (optstring[0] == ':')
                    c = ':';
                else
                    c = '?';
                return c;
            }",13,,368,2,,void
17033,BLOCK,-1,,<empty>,21,,371,2,,void
17038,BLOCK,-1,,<empty>,21,,373,1,,void
17045,BLOCK,-1,,<empty>,17,,379,1,,void
17057,BLOCK,-1,,<empty>,13,,384,1,,void
17077,BLOCK,-1,,<empty>,13,,389,1,,void
17107,BLOCK,-1,,"{
                    if ((unsigned int) (nameend - state->nextchar)
                        == strlen(p->name))
                    {
                        /* Exact match found.  */
                        pfound = p;
                        indfound = option_index;
                        exact = 1;
                        break;
                    }
                    else if (pfound == NULL)
                    {
                        /* First nonexact match found.  */
                        pfound = p;
                        indfound = option_index;
                    }
                    else
                        /* Second or later nonexact match found.  */
                        ambig = 1;
                }",17,,391,2,,void
17121,BLOCK,-1,,"{
                        /* Exact match found.  */
                        pfound = p;
                        indfound = option_index;
                        exact = 1;
                        break;
                    }",21,,394,2,,void
17133,BLOCK,-1,,<empty>,26,,401,1,,void
17138,BLOCK,-1,,"{
                        /* First nonexact match found.  */
                        pfound = p;
                        indfound = option_index;
                    }",21,,402,2,,void
17146,BLOCK,-1,,<empty>,25,,409,1,,void
17155,BLOCK,-1,,"{
                state->nextchar += strlen(state->nextchar);
                state->ind++;
                return '?';
            }",13,,412,2,,void
17174,BLOCK,-1,,"{
                option_index = indfound;
                if (*nameend)
                {
                    if (pfound->has_arg)
                        state->arg = nameend + 1;
                    else
                    {
                        state->nextchar += strlen(state->nextchar);
                        return '?';
                    }
                }
                else if (pfound->has_arg)
                {
                    if (state->ind < argc)
                        state->arg = argv[state->ind++];
                    else
                    {
                        state->nextchar += strlen(state->nextchar);
                        return optstring[0] == ':' ? ':' : '?';
                    }
                }
                state->nextchar += strlen(state->nextchar);
                if (longind != NULL)
                    *longind = option_index;
                if (pfound->flag)
                {
                    *(pfound->flag) = pfound->val;
...",13,,418,2,,void
17181,BLOCK,-1,,"{
                    if (pfound->has_arg)
                        state->arg = nameend + 1;
                    else
                    {
                        state->nextchar += strlen(state->nextchar);
                        return '?';
                    }
                }",17,,421,2,,void
17186,BLOCK,-1,,<empty>,25,,423,2,,void
17195,BLOCK,-1,,"{
                        state->nextchar += strlen(state->nextchar);
                        return '?';
                    }",21,,425,1,,void
17207,BLOCK,-1,,<empty>,22,,430,1,,void
17212,BLOCK,-1,,"{
                    if (state->ind < argc)
                        state->arg = argv[state->ind++];
                    else
                    {
                        state->nextchar += strlen(state->nextchar);
                        return optstring[0] == ':' ? ':' : '?';
                    }
                }",17,,431,2,,void
17219,BLOCK,-1,,<empty>,25,,433,2,,void
17231,BLOCK,-1,,"{
                        state->nextchar += strlen(state->nextchar);
                        return optstring[0] == ':' ? ':' : '?';
                    }",21,,435,1,,void
17261,BLOCK,-1,,<empty>,21,,442,2,,void
17270,BLOCK,-1,,"{
                    *(pfound->flag) = pfound->val;
                    return 0;
                }",17,,444,2,,void
17298,BLOCK,-1,,"{
            /* This is an option that requires an argument.  */
            if (*state->nextchar != '\0')
            {
                state->arg = state->nextchar;
                /* If we end this ARGV-element by taking the rest as an arg,
                   we must advance to the next element now.  */
                state->ind++;
            }
            else if (state->ind == argc)
            {
                state->opt = c;
                if (optstring[0] == ':')
                    c = ':';
                else
                    c = '?';
            }
            else
                /* We already incremented `optind' once;
                   increment it again when taking next ARGV-elt as argument.  */
                state->arg = argv[state->ind++];
            state->nextchar = NULL;
        }",9,,454,2,,void
17306,BLOCK,-1,,"{
                state->arg = state->nextchar;
                /* If we end this ARGV-element by taking the rest as an arg,
                   we must advance to the next element now.  */
                state->ind++;
            }",13,,457,2,,void
17319,BLOCK,-1,,<empty>,18,,463,1,,void
17326,BLOCK,-1,,"{
                state->opt = c;
                if (optstring[0] == ':')
                    c = ':';
                else
                    c = '?';
            }",13,,464,2,,void
17338,BLOCK,-1,,<empty>,21,,467,2,,void
17343,BLOCK,-1,,<empty>,21,,469,1,,void
17348,BLOCK,-1,,<empty>,17,,474,1,,void
17410,BLOCK,-1,,<empty>,1,,1,1,,ANY
17414,BLOCK,-1,,<empty>,,,,3,,<empty>
17420,BLOCK,-1,,<empty>,,,,3,,<empty>
17425,BLOCK,-1,,<empty>,,,,2,,<empty>
17431,BLOCK,-1,,<empty>,,,,3,,<empty>
17436,BLOCK,-1,,"{
#ifdef TIOCGWINSZ
    struct winsize ws;

    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0)
        return ws.ws_col;
#endif
#ifdef WIOCGETD
    struct uwdata uw;

    if (ioctl(STDOUT_FILENO, WIOCGETD, &uw) == 0)
        return uw.uw_height / uw.uw_vs;
#endif
#if defined (_WIN32) && !VLC_WINSTORE_APP
    CONSOLE_SCREEN_BUFFER_INFO buf;

    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &buf))
        return buf.dwSize.X;
#endif
    return 80;
}",1,,67,2,,void
17443,BLOCK,-1,,"{
    char *str;

    /* Check for short help option */
    if (var_InheritBool (obj, ""help""))
    {
        Help (obj, ""help"");
        return true;
    }

    /* Check for version option */
    if (var_InheritBool (obj, ""version""))
    {
        Version();
        return true;
    }

    /* Check for help on modules */
    str = var_InheritString (obj, ""module"");
    if (str != NULL)
    {
        Help (obj, str);
        free (str);
        return true;
    }

    /* Check for full help option */
    if (var_InheritBool (obj, ""full-help""))
    {
        var_Create (obj, ""advanced"", VLC_VAR_BOOL);
        var_SetBool (obj, ""advanced"", true);
        var_Create (obj, ""help-verbose"", VLC_VAR_BOOL);
        var_SetBool (obj, ""help-verbose"", true);
        Help (obj, ""full-help"");
        return true;
    }

    /* Check for long help option */
    if (var_InheritBool (obj, ""longhelp""))
    {
        Help (obj, ""longhelp"");
        return true;
    }

    /* Check for module list opti...",1,,96,2,,void
17449,BLOCK,-1,,"{
        Help (obj, ""help"");
        return true;
    }",5,,101,2,,void
17459,BLOCK,-1,,"{
        Version();
        return true;
    }",5,,108,2,,void
17472,BLOCK,-1,,"{
        Help (obj, str);
        free (str);
        return true;
    }",5,,116,2,,void
17484,BLOCK,-1,,"{
        var_Create (obj, ""advanced"", VLC_VAR_BOOL);
        var_SetBool (obj, ""advanced"", true);
        var_Create (obj, ""help-verbose"", VLC_VAR_BOOL);
        var_SetBool (obj, ""help-verbose"", true);
        Help (obj, ""full-help"");
        return true;
    }",5,,124,2,,void
17510,BLOCK,-1,,"{
        Help (obj, ""longhelp"");
        return true;
    }",5,,135,2,,void
17520,BLOCK,-1,,"{
        ListModules (obj, false );
        return true;
    }",5,,142,2,,void
17530,BLOCK,-1,,"{
        ListModules (obj, true);
        return true;
    }",5,,148,2,,void
17542,BLOCK,-1,,"{
    putchar('\n');
    puts(_(""To get exhaustive help, use '-H'.""));
}",1,,162,2,,void
17558,BLOCK,-1,,"{
    ShowConsole();

    if( psz_help_name && !strcmp( psz_help_name, ""help"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, ""=core"" );
        print_help_on_full_help();
    }
    else if( psz_help_name && !strcmp( psz_help_name, ""longhelp"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
        print_help_on_full_help();
    }
    else if( psz_help_name && !strcmp( psz_help_name, ""full-help"" ) )
    {
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
    }
    else if( psz_help_name )
    {
        Usage( p_this, psz_help_name );
    }

    PauseConsole();
}",1,,202,3,,void
17560,BLOCK,1,,<empty>,,,,1,,void
17571,BLOCK,-1,,"{
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, ""=core"" );
        print_help_on_full_help();
    }",5,,206,2,,void
17581,BLOCK,-1,,<empty>,10,,211,1,,void
17589,BLOCK,-1,,"{
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
        print_help_on_full_help();
    }",5,,212,2,,void
17599,BLOCK,-1,,<empty>,10,,217,1,,void
17607,BLOCK,-1,,"{
        printf(_(vlc_usage), ""vlc"");
        Usage( p_this, NULL );
    }",5,,218,2,,void
17616,BLOCK,-1,,<empty>,10,,222,1,,void
17619,BLOCK,-1,,"{
        Usage( p_this, psz_help_name );
    }",5,,223,2,,void
17624,BLOCK,1,,<empty>,,,,1,,void
17635,BLOCK,-1,,"{
    const module_config_t *item = *sect;

    if (item == NULL)
        return;
    *sect = NULL;

    printf(color ? RED""   %s:\n""GRAY : ""   %s:\n"",
           module_gettext(m, item->psz_text));
    if (desc && item->psz_longtext != NULL)
        printf(color ? MAGENTA""   %s\n""GRAY : ""   %s\n"",
               module_gettext(m, item->psz_longtext));
}",1,,249,5,,void
17645,BLOCK,-1,,<empty>,9,,253,2,,void
17655,BLOCK,1,,<empty>,,,,1,,void
17671,BLOCK,-1,,<empty>,9,,259,2,,void
17676,BLOCK,1,,<empty>,,,,1,,void
17690,BLOCK,-1,,"{
    unsigned width = ConsoleWidth() - margin;

    if (color)
        fputs(BLUE, stdout);

    const char *word = str;
    int wordlen = 0, wordwidth = 0;
    unsigned offset = 0;
    bool newline = true;

    while (str[0])
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);
        if (unlikely(charlen == (size_t)-1))
            break;

        int charwidth = wcwidth(cp);
        if (charwidth < 0)
            charwidth = 0;

        str += charlen;

        if (iswspace(cp))
        {
            if (!newline)
            {
                putchar(' '); /* insert space */
                charwidth = 1;
            }
            fwrite(word, 1, wordlen, stdout); /* write complete word */
            word = str;
            wordlen = 0;
            wordwidth = 0;
            newline = false;
        }
        else
        {
            wordlen += charlen;
            wordwidth += charwidth;
        }

        offset += charwidth;
        if (offset >= width...",1,,264,4,,void
17699,BLOCK,-1,,<empty>,9,,268,2,,void
17702,BLOCK,1,,<empty>,,,,1,,void
17729,BLOCK,-1,,"{
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);
        if (unlikely(charlen == (size_t)-1))
            break;

        int charwidth = wcwidth(cp);
        if (charwidth < 0)
            charwidth = 0;

        str += charlen;

        if (iswspace(cp))
        {
            if (!newline)
            {
                putchar(' '); /* insert space */
                charwidth = 1;
            }
            fwrite(word, 1, wordlen, stdout); /* write complete word */
            word = str;
            wordlen = 0;
            wordwidth = 0;
            newline = false;
        }
        else
        {
            wordlen += charlen;
            wordwidth += charwidth;
        }

        offset += charwidth;
        if (offset >= width)
        {
            if (newline)
            {   /* overflow (word wider than line) */
                fwrite(word, 1, wordlen - charlen, stdout);
                word = str - charlen;
                wordlen = charlen;
        ...",5,,276,2,,void
17745,BLOCK,-1,,<empty>,13,,280,2,,void
17756,BLOCK,-1,,<empty>,13,,284,2,,void
17766,BLOCK,-1,,"{
            if (!newline)
            {
                putchar(' '); /* insert space */
                charwidth = 1;
            }
            fwrite(word, 1, wordlen, stdout); /* write complete word */
            word = str;
            wordlen = 0;
            wordwidth = 0;
            newline = false;
        }",9,,289,2,,void
17770,BLOCK,-1,,"{
                putchar(' '); /* insert space */
                charwidth = 1;
            }",13,,291,2,,void
17794,BLOCK,-1,,"{
            wordlen += charlen;
            wordwidth += charwidth;
        }",9,,302,1,,void
17808,BLOCK,-1,,"{
            if (newline)
            {   /* overflow (word wider than line) */
                fwrite(word, 1, wordlen - charlen, stdout);
                word = str - charlen;
                wordlen = charlen;
                wordwidth = charwidth;
            }
            printf(""\n%*s"", margin, """"); /* new line */
            offset = wordwidth;
            newline = true;
        }",9,,309,2,,void
17811,BLOCK,-1,,"{   /* overflow (word wider than line) */
                fwrite(word, 1, wordlen - charlen, stdout);
                word = str - charlen;
                wordlen = charlen;
                wordwidth = charwidth;
            }",13,,311,2,,void
17843,BLOCK,-1,,<empty>,9,,324,2,,void
17856,BLOCK,-1,,"{
    for (int total = 0;;)
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);

        if (charlen == 0)
            return total;
        if (charlen == (size_t)-1)
            return -1;
        str += charlen;

        int w = wcwidth(cp);
        if (w == -1)
            return -1;
        total += w;
    }
}",1,,329,2,,void
17858,BLOCK,-1,,<empty>,5,,330,1,,void
17863,BLOCK,4,,"{
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);

        if (charlen == 0)
            return total;
        if (charlen == (size_t)-1)
            return -1;
        str += charlen;

        int w = wcwidth(cp);
        if (w == -1)
            return -1;
        total += w;
    }",5,,331,4,,void
17876,BLOCK,-1,,<empty>,13,,336,2,,void
17885,BLOCK,-1,,<empty>,13,,338,2,,void
17902,BLOCK,-1,,<empty>,13,,343,2,,void
17918,BLOCK,-1,,"{
#ifndef _WIN32
# define OPTION_VALUE_SEP "" ""
#else
# define OPTION_VALUE_SEP ""=""
#endif
    const char *bra = OPTION_VALUE_SEP ""<"", *type, *ket = "">"";
    const char *prefix = NULL, *suffix = NULL;
    char *typebuf = NULL;

    switch (CONFIG_CLASS(item->i_type))
    {
        case 0: // hint class
            switch (item->i_type)
            {
                case CONFIG_HINT_CATEGORY:
                case CONFIG_HINT_USAGE:
                    printf(color ? GREEN ""\n %s\n"" GRAY : ""\n %s\n"",
                           module_gettext(m, item->psz_text));

                    if (desc && item->psz_longtext != NULL)
                        printf(color ? CYAN "" %s\n"" GRAY : "" %s\n"",
                               module_gettext(m, item->psz_longtext));
                    break;

                case CONFIG_SECTION:
                    *section = item;
                    break;
            }
            return;

        case CONFIG_ITEM_STRING:
        {
            type = _(""st...",1,,350,7,,void
17925,BLOCK,1,,<empty>,,,,1,,void
17947,BLOCK,1,,<empty>,,,,2,,void
17954,BLOCK,-1,,"{
        case 0: // hint class
            switch (item->i_type)
            {
                case CONFIG_HINT_CATEGORY:
                case CONFIG_HINT_USAGE:
                    printf(color ? GREEN ""\n %s\n"" GRAY : ""\n %s\n"",
                           module_gettext(m, item->psz_text));

                    if (desc && item->psz_longtext != NULL)
                        printf(color ? CYAN "" %s\n"" GRAY : "" %s\n"",
                               module_gettext(m, item->psz_longtext));
                    break;

                case CONFIG_SECTION:
                    *section = item;
                    break;
            }
            return;

        case CONFIG_ITEM_STRING:
        {
            type = _(""string"");

            char **ppsz_values, **ppsz_texts;

            ssize_t i_count = config_GetPszChoices(VLC_OBJECT(p_this), item->psz_name, &ppsz_values, &ppsz_texts);

            if (i_count > 0)
            {
                size_t len = 0;

                for (un...",5,,361,2,,void
17961,BLOCK,-1,,"{
                case CONFIG_HINT_CATEGORY:
                case CONFIG_HINT_USAGE:
                    printf(color ? GREEN ""\n %s\n"" GRAY : ""\n %s\n"",
                           module_gettext(m, item->psz_text));

                    if (desc && item->psz_longtext != NULL)
                        printf(color ? CYAN "" %s\n"" GRAY : "" %s\n"",
                               module_gettext(m, item->psz_longtext));
                    break;

                case CONFIG_SECTION:
                    *section = item;
                    break;
            }",13,,364,2,,void
17970,BLOCK,1,,<empty>,,,,1,,void
17986,BLOCK,-1,,<empty>,25,,371,2,,void
17991,BLOCK,1,,<empty>,,,,1,,void
18010,BLOCK,7,,"{
            type = _(""string"");

            char **ppsz_values, **ppsz_texts;

            ssize_t i_count = config_GetPszChoices(VLC_OBJECT(p_this), item->psz_name, &ppsz_values, &ppsz_texts);

            if (i_count > 0)
            {
                size_t len = 0;

                for (unsigned i = 0; i < i_count; i++)
                    len += strlen(ppsz_values[i]) + 1;

                typebuf = malloc(len);
                if (typebuf == NULL)
                    goto end_string;

                bra = OPTION_VALUE_SEP ""{"";
                type = typebuf;
                ket = ""}"";

                *typebuf = 0;
                for (unsigned i = 0; i < i_count; i++)
                {
                    if (i > 0)
                        strcat(typebuf, "","");
                    strcat(typebuf, ppsz_values[i]);
                }

            end_string:
                for (unsigned i = 0; i < i_count; i++)
                {
                    free(ppsz_values[i]);
   ...",9,,382,7,,void
18034,BLOCK,-1,,"{
                size_t len = 0;

                for (unsigned i = 0; i < i_count; i++)
                    len += strlen(ppsz_values[i]) + 1;

                typebuf = malloc(len);
                if (typebuf == NULL)
                    goto end_string;

                bra = OPTION_VALUE_SEP ""{"";
                type = typebuf;
                ket = ""}"";

                *typebuf = 0;
                for (unsigned i = 0; i < i_count; i++)
                {
                    if (i > 0)
                        strcat(typebuf, "","");
                    strcat(typebuf, ppsz_values[i]);
                }

            end_string:
                for (unsigned i = 0; i < i_count; i++)
                {
                    free(ppsz_values[i]);
                    free(ppsz_texts[i]);
                }
                free(ppsz_values);
                free(ppsz_texts);
            }",13,,390,2,,void
18040,BLOCK,-1,,<empty>,17,,393,1,,void
18066,BLOCK,-1,,<empty>,21,,398,2,,void
18071,BLOCK,1,,<empty>,,,,1,,void
18084,BLOCK,-1,,<empty>,17,,405,1,,void
18094,BLOCK,4,,"{
                    if (i > 0)
                        strcat(typebuf, "","");
                    strcat(typebuf, ppsz_values[i]);
                }",17,,406,4,,void
18099,BLOCK,-1,,<empty>,25,,408,2,,void
18110,BLOCK,-1,,<empty>,17,,413,1,,void
18120,BLOCK,4,,"{
                    free(ppsz_values[i]);
                    free(ppsz_texts[i]);
                }",17,,414,4,,void
18136,BLOCK,10,,"{
            type = _(""integer"");

            int64_t *pi_values;
            char **ppsz_texts;

            ssize_t i_count = config_GetIntChoices(VLC_OBJECT(p_this), item->psz_name, &pi_values, &ppsz_texts);

            if (i_count > 0)
            {
                size_t len = 0;

                for (unsigned i = 0; i < i_count; i++)
                    len += strlen(ppsz_texts[i])
                           + 4 * sizeof (int64_t) + 5;

                typebuf = malloc(len);
                if (typebuf == NULL)
                    goto end_integer;

                bra = OPTION_VALUE_SEP ""{"";
                type = typebuf;
                ket = ""}"";

                *typebuf = 0;
                for (unsigned i = 0; i < item->list_count; i++)
                {
                    if (i != 0)
                        strcat(typebuf, "", "");
                    sprintf(typebuf + strlen(typebuf), ""%""PRIi64"" (%s)"",
                            pi_values[i],
                      ...",9,,425,10,,void
18160,BLOCK,-1,,"{
                size_t len = 0;

                for (unsigned i = 0; i < i_count; i++)
                    len += strlen(ppsz_texts[i])
                           + 4 * sizeof (int64_t) + 5;

                typebuf = malloc(len);
                if (typebuf == NULL)
                    goto end_integer;

                bra = OPTION_VALUE_SEP ""{"";
                type = typebuf;
                ket = ""}"";

                *typebuf = 0;
                for (unsigned i = 0; i < item->list_count; i++)
                {
                    if (i != 0)
                        strcat(typebuf, "", "");
                    sprintf(typebuf + strlen(typebuf), ""%""PRIi64"" (%s)"",
                            pi_values[i],
                            ppsz_texts[i]);
                }

            end_integer:
                for (unsigned i = 0; i < i_count; i++)
                    free(ppsz_texts[i]);
                free(pi_values);
                free(ppsz_texts);
            }",13,,434,2,,void
18166,BLOCK,-1,,<empty>,17,,437,1,,void
18197,BLOCK,-1,,<empty>,21,,443,2,,void
18202,BLOCK,1,,<empty>,,,,1,,void
18215,BLOCK,-1,,<empty>,17,,450,1,,void
18227,BLOCK,4,,"{
                    if (i != 0)
                        strcat(typebuf, "", "");
                    sprintf(typebuf + strlen(typebuf), ""%""PRIi64"" (%s)"",
                            pi_values[i],
                            ppsz_texts[i]);
                }",17,,451,4,,void
18232,BLOCK,-1,,<empty>,25,,453,2,,void
18239,BLOCK,-1,,<empty>,17,,460,1,,void
18258,BLOCK,-1,,<empty>,18,,465,1,,void
18275,BLOCK,-1,,"{
                if (asprintf(&typebuf, ""%s [%""PRId64"" .. %""PRId64""]"",
                             type, item->min.i, item->max.i) >= 0)
                    type = typebuf;
                else
                    typebuf = NULL;
            }",13,,466,2,,void
18278,BLOCK,-1,,<empty>,21,,469,2,,void
18283,BLOCK,-1,,<empty>,21,,471,1,,void
18311,BLOCK,-1,,"{
                if (asprintf(&typebuf, ""%s [%f .. %f]"", type,
                             item->min.f, item->max.f) >= 0)
                    type = typebuf;
                else
                    typebuf = NULL;
            }",13,,478,2,,void
18330,BLOCK,-1,,<empty>,21,,481,2,,void
18335,BLOCK,-1,,<empty>,21,,483,1,,void
18379,BLOCK,-1,,<empty>,9,,502,2,,void
18387,BLOCK,-1,,<empty>,9,,504,1,,void
18397,BLOCK,1,,<empty>,,,,2,,void
18405,BLOCK,-1,,<empty>,9,,507,2,,void
18410,BLOCK,1,,<empty>,,,,1,,void
18425,BLOCK,-1,,<empty>,9,,511,1,,void
18430,BLOCK,1,,<empty>,,,,1,,void
18451,BLOCK,1,,<empty>,,,,1,,void
18470,BLOCK,1,,<empty>,,,,2,,void
18478,BLOCK,-1,,<empty>,9,,519,2,,void
18492,BLOCK,-1,,"{
        putchar('\n');
        offset = PADDING_SPACES + LINE_START;
    }",5,,521,2,,void
18499,BLOCK,1,,<empty>,,,,1,,void
18502,BLOCK,1,,<empty>,,,,1,,void
18516,BLOCK,1,,<empty>,,,,1,,void
18519,BLOCK,1,,<empty>,,,,1,,void
18526,BLOCK,-1,,"{
        printf(""%*s"", PADDING_SPACES + LINE_START, """");
        print_desc(suffix, PADDING_SPACES + LINE_START, color);
    }",5,,531,2,,void
18531,BLOCK,1,,<empty>,,,,1,,void
18534,BLOCK,1,,<empty>,,,,1,,void
18541,BLOCK,1,,<empty>,,,,1,,void
18544,BLOCK,1,,<empty>,,,,1,,void
18561,BLOCK,-1,,"{   /* Wrap long description */
        printf(""%*s"", LINE_START + 2, """");
        print_desc(module_gettext(m, item->psz_longtext),
                   LINE_START + 2, false);
    }",5,,537,2,,void
18566,BLOCK,1,,<empty>,,,,1,,void
18578,BLOCK,1,,<empty>,,,,1,,void
18590,BLOCK,-1,,"{
    if (pattern == NULL)
        return true;

    const char *objname = module_get_object(m);

    if (strict ? (strcmp(objname, pattern) == 0)
               : (strstr(objname, pattern) != NULL))
        return true;

    for (unsigned i = 0; i < m->i_shortcuts; i++)
    {
        const char *shortcut = m->pp_shortcuts[i];

        if (strict ? (strcmp(shortcut, pattern) == 0)
                   : (strstr(shortcut, pattern) != NULL))
            return true;
    }
    return false;
}",1,,547,4,,void
18595,BLOCK,-1,,<empty>,9,,549,2,,void
18616,BLOCK,-1,,<empty>,9,,555,2,,void
18620,BLOCK,-1,,<empty>,5,,557,1,,void
18632,BLOCK,4,,"{
        const char *shortcut = m->pp_shortcuts[i];

        if (strict ? (strcmp(shortcut, pattern) == 0)
                   : (strstr(shortcut, pattern) != NULL))
            return true;
    }",5,,558,4,,void
18654,BLOCK,-1,,<empty>,13,,563,2,,void
18664,BLOCK,-1,,"{
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        const module_config_t *item = plugin->conf.items + i;

        if (!CONFIG_ITEM(item->i_type))
            continue;
        if (item->b_removed)
            continue;
        if ((!advanced) && item->b_advanced)
            continue;
        return true;
    }
    return false;
}",1,,569,3,,void
18666,BLOCK,-1,,<empty>,5,,570,1,,void
18680,BLOCK,4,,"{
        const module_config_t *item = plugin->conf.items + i;

        if (!CONFIG_ITEM(item->i_type))
            continue;
        if (item->b_removed)
            continue;
        if ((!advanced) && item->b_advanced)
            continue;
        return true;
    }",5,,571,4,,void
18697,BLOCK,-1,,<empty>,13,,575,2,,void
18703,BLOCK,-1,,<empty>,13,,577,2,,void
18712,BLOCK,-1,,<empty>,13,,579,2,,void
18723,BLOCK,-1,,"{
    bool b_has_advanced = false;
    bool found = false;
    unsigned i_only_advanced = 0; /* Number of modules ignored because they
                               * only have advanced options */
    bool strict = false;
    if (psz_search != NULL && psz_search[0] == '=')
    {
        strict = true;
        psz_search++;
    }

    bool color = false;
#ifndef _WIN32
    if (isatty(STDOUT_FILENO))
        color = var_InheritBool(p_this, ""color"");
#endif

    const bool desc = var_InheritBool(p_this, ""help-verbose"");
    const bool advanced = var_InheritBool(p_this, ""advanced"");

    /* Enumerate the config for each module */
    for (const vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
    {
        const module_t *m = p->module;
        const module_config_t *section = NULL;
        const char *objname = module_get_object(m);

        if (p->conf.count == 0)
            continue; /* Ignore modules without config options */
        if (!module_match(m, psz_search, strict))...",1,,586,3,,void
18750,BLOCK,-1,,"{
        strict = true;
        psz_search++;
    }",5,,593,2,,void
18763,BLOCK,-1,,<empty>,9,,601,2,,void
18782,BLOCK,-1,,<empty>,5,,608,1,,void
18795,BLOCK,4,,"{
        const module_t *m = p->module;
        const module_config_t *section = NULL;
        const char *objname = module_get_object(m);

        if (p->conf.count == 0)
            continue; /* Ignore modules without config options */
        if (!module_match(m, psz_search, strict))
            continue;
        found = true;

        if (!plugin_show(p, advanced))
        {   /* Ignore plugins with only advanced config options if requested */
            i_only_advanced++;
            continue;
        }

        /* Print name of module */
        printf(color ? ""\n "" GREEN ""%s"" GRAY "" (%s)\n"" : ""\n %s (%s)\n"",
               module_gettext(m, m->psz_longname), objname);
        if (m->psz_help != NULL)
            printf(color ? CYAN"" %s\n""GRAY : "" %s\n"",
                   module_gettext(m, m->psz_help));

        /* Print module options */
        for (size_t j = 0; j < p->conf.size; j++)
        {
            const module_config_t *item = p->conf.items + j;

            if...",5,,609,4,,void
18819,BLOCK,-1,,<empty>,13,,615,2,,void
18827,BLOCK,-1,,<empty>,13,,617,2,,void
18837,BLOCK,-1,,"{   /* Ignore plugins with only advanced config options if requested */
            i_only_advanced++;
            continue;
        }",9,,621,2,,void
18858,BLOCK,-1,,<empty>,13,,630,2,,void
18863,BLOCK,1,,<empty>,,,,1,,void
18872,BLOCK,-1,,<empty>,9,,634,1,,void
18886,BLOCK,4,,"{
            const module_config_t *item = p->conf.items + j;

            if (item->b_removed)
                continue; /* Skip removed options */
            if (item->b_advanced && !advanced)
            {   /* Skip advanced options unless requested */
                b_has_advanced = true;
                continue;
            }
            print_item(p_this, m, item, &section, color, desc);
        }",9,,635,4,,void
18901,BLOCK,-1,,<empty>,17,,639,2,,void
18910,BLOCK,-1,,"{   /* Skip advanced options unless requested */
                b_has_advanced = true;
                continue;
            }",13,,641,2,,void
18925,BLOCK,-1,,<empty>,9,,650,2,,void
18939,BLOCK,-1,,"{
        printf(color ? ""\n"" WHITE ""%s"" GRAY "" "" : ""\n%s "", _( ""Note:"" ) );
        printf(vlc_ngettext(""%u module was not displayed because it only has ""
               ""advanced options.\n"", ""%u modules were not displayed because ""
               ""they only have advanced options.\n"", i_only_advanced),
               i_only_advanced);
    }",5,,654,2,,void
18954,BLOCK,-1,,<empty>,10,,661,1,,void
18958,BLOCK,-1,,<empty>,9,,662,2,,void
18971,BLOCK,-1,,"{
    bool color = false;

    ShowConsole();
#ifndef _WIN32
    if (isatty(STDOUT_FILENO))
        color = var_InheritBool(p_this, ""color"");
#else
    (void) p_this;
#endif

    /* List all modules */
    size_t count;
    module_t **list = module_list_get (&count);

    /* Enumerate each module */
    for (size_t j = 0; j < count; j++)
    {
        module_t *p_parser = list[j];
        const char *objname = module_get_object (p_parser);
        printf(color ? GREEN""  %-22s ""WHITE""%s\n""GRAY : ""  %-22s %s\n"",
               objname, module_gettext(p_parser, p_parser->psz_longname));

        if( b_verbose )
        {
            const char *const *pp_shortcuts = p_parser->pp_shortcuts;
            for( unsigned i = 0; i < p_parser->i_shortcuts; i++ )
                if( strcmp( pp_shortcuts[i], objname ) )
                    printf(color ? CYAN""   s %s\n""GRAY : ""   s %s\n"",
                           pp_shortcuts[i]);
            if (p_parser->psz_capability != NULL)
             ...",1,,674,3,,void
18977,BLOCK,1,,<empty>,,,,1,,void
18984,BLOCK,-1,,<empty>,9,,680,2,,void
18998,BLOCK,-1,,<empty>,5,,690,1,,void
19008,BLOCK,4,,"{
        module_t *p_parser = list[j];
        const char *objname = module_get_object (p_parser);
        printf(color ? GREEN""  %-22s ""WHITE""%s\n""GRAY : ""  %-22s %s\n"",
               objname, module_gettext(p_parser, p_parser->psz_longname));

        if( b_verbose )
        {
            const char *const *pp_shortcuts = p_parser->pp_shortcuts;
            for( unsigned i = 0; i < p_parser->i_shortcuts; i++ )
                if( strcmp( pp_shortcuts[i], objname ) )
                    printf(color ? CYAN""   s %s\n""GRAY : ""   s %s\n"",
                           pp_shortcuts[i]);
            if (p_parser->psz_capability != NULL)
                printf(color ? MAGENTA""   c %s (%d)\n""GRAY : ""   c %s (%d)\n"",
                       p_parser->psz_capability, p_parser->i_score);
        }
    }",5,,691,4,,void
19024,BLOCK,1,,<empty>,,,,1,,void
19035,BLOCK,-1,,"{
            const char *const *pp_shortcuts = p_parser->pp_shortcuts;
            for( unsigned i = 0; i < p_parser->i_shortcuts; i++ )
                if( strcmp( pp_shortcuts[i], objname ) )
                    printf(color ? CYAN""   s %s\n""GRAY : ""   s %s\n"",
                           pp_shortcuts[i]);
            if (p_parser->psz_capability != NULL)
                printf(color ? MAGENTA""   c %s (%d)\n""GRAY : ""   c %s (%d)\n"",
                       p_parser->psz_capability, p_parser->i_score);
        }",9,,698,2,,void
19043,BLOCK,-1,,<empty>,13,,700,1,,void
19061,BLOCK,-1,,<empty>,21,,702,2,,void
19066,BLOCK,1,,<empty>,,,,1,,void
19078,BLOCK,-1,,<empty>,17,,705,2,,void
19083,BLOCK,1,,<empty>,,,,1,,void
19095,BLOCK,1,,<empty>,,,,1,,void
19103,BLOCK,-1,,"{
    ShowConsole();
    printf(_(""VLC version %s (%s)\n""), VERSION_MESSAGE, psz_vlc_changeset);
    printf(_(""Compiled by %s on %s (%s)\n""), VLC_CompileBy(),
           VLC_CompileHost(), __DATE__"" ""__TIME__ );
    printf(_(""Compiler: %s\n""), VLC_Compiler());
    fputs(LICENSE_MSG, stdout);
    PauseConsole();
}",1,,719,2,,void
19105,BLOCK,1,,<empty>,,,,1,,void
19120,BLOCK,1,,<empty>,,,,1,,void
19130,BLOCK,1,,<empty>,,,,1,,void
19146,BLOCK,-1,,<empty>,1,,1,1,,ANY
19150,BLOCK,-1,,"{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }

    /* interface not found in the config, let's add it */
    if( psz_config && strlen( psz_config ) > 0 )
    {
        char *psz_newconfi...",1,,35,3,,void
19178,BLOCK,-1,,"{
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }",5,,45,2,,void
19185,BLOCK,-1,,"{
            free( psz_config );
            return;
        }",9,,47,2,,void
19196,BLOCK,-1,,<empty>,26,,52,2,,void
19210,BLOCK,-1,,"{
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }",5,,58,2,,void
19217,BLOCK,-1,,"{
            free( psz_config );
            return;
        }",9,,60,2,,void
19228,BLOCK,-1,,<empty>,26,,65,2,,void
19238,BLOCK,-1,,"{
        char *psz_newconfig;
        if( asprintf( &psz_newconfig, ""%s:%s"", psz_config, psz_intf ) != -1 )
        {
            config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
            free( psz_newconfig );
        }
    }",5,,70,2,,void
19250,BLOCK,-1,,"{
            config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
            free( psz_newconfig );
        }",9,,73,2,,void
19258,BLOCK,-1,,<empty>,9,,79,1,,void
19270,BLOCK,-1,,"{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_p...",1,,87,3,,void
19298,BLOCK,-1,,"{
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }",5,,97,2,,void
19305,BLOCK,-1,,"{
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }",9,,99,2,,void
19318,BLOCK,-1,,<empty>,35,,102,2,,void
19335,BLOCK,-1,,"{
                config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
                free( psz_newconfig );
            }",13,,105,2,,void
19350,BLOCK,-1,,<empty>,26,,112,2,,void
19364,BLOCK,-1,,"{
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""control"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }",5,,118,2,,void
19371,BLOCK,-1,,"{
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""control"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }",9,,120,2,,void
19384,BLOCK,-1,,<empty>,35,,123,2,,void
19401,BLOCK,-1,,"{
                config_PutPsz( libvlc, ""control"", psz_newconfig );
                free( psz_newconfig );
            }",13,,126,2,,void
19416,BLOCK,-1,,<empty>,26,,133,2,,void
19426,BLOCK,-1,,"{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    return false;
}",1,,144,3,,void
19454,BLOCK,-1,,"{
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }",5,,154,2,,void
19461,BLOCK,-1,,"{
            free( psz_config );
            return true;
        }",9,,156,2,,void
19473,BLOCK,-1,,<empty>,26,,161,2,,void
19487,BLOCK,-1,,"{
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }",5,,167,2,,void
19494,BLOCK,-1,,"{
            free( psz_config );
            return true;
        }",9,,169,2,,void
19506,BLOCK,-1,,<empty>,26,,174,2,,void
19519,BLOCK,-1,,<empty>,1,,1,1,,ANY
19540,BLOCK,-1,,<empty>,,,,7,,<empty>
19561,BLOCK,-1,,<empty>,1,,1,1,,ANY
19564,BLOCK,-1,,"{
    /* Get the full program path and name */
    /* First try to see if we are linked to the framework */
    for (unsigned i = 0; i < _dyld_image_count(); i++)
    {
        const char *psz_img_name = _dyld_get_image_name(i);
        const char *p = strstr( psz_img_name, ""VLCKit.framework/Versions/"" );

        /* Check for ""VLCKit.framework/Versions/Current/VLCKit"",
         * as well as ""VLCKit.framework/Versions/A/VLCKit"" and
         * ""VLC.framework/Versions/B/VLCKit"" */
        if (p != NULL) {
            /* Look for the next forward slash */
            p += 26; /* p_char += strlen("" VLCKit.framework/Versions/"" ) */
            p += strcspn( p, ""/"" );

            /* If the string ends with VLCKit then we've found a winner */
            if (!strcmp( p, ""/VLCKit""))
                return strdup( dirname(psz_img_name) );
        }

        /* Do we end by ""VLC""? If so we are the legacy VLC.app that doesn't
         * link to VLCKit. */
        size_t len = strlen(psz_img_n...",1,,40,2,,void
19566,BLOCK,-1,,<empty>,5,,43,1,,void
19576,BLOCK,4,,"{
        const char *psz_img_name = _dyld_get_image_name(i);
        const char *p = strstr( psz_img_name, ""VLCKit.framework/Versions/"" );

        /* Check for ""VLCKit.framework/Versions/Current/VLCKit"",
         * as well as ""VLCKit.framework/Versions/A/VLCKit"" and
         * ""VLC.framework/Versions/B/VLCKit"" */
        if (p != NULL) {
            /* Look for the next forward slash */
            p += 26; /* p_char += strlen("" VLCKit.framework/Versions/"" ) */
            p += strcspn( p, ""/"" );

            /* If the string ends with VLCKit then we've found a winner */
            if (!strcmp( p, ""/VLCKit""))
                return strdup( dirname(psz_img_name) );
        }

        /* Do we end by ""VLC""? If so we are the legacy VLC.app that doesn't
         * link to VLCKit. */
        size_t len = strlen(psz_img_name);
        if (len >= 3 && !strcmp( psz_img_name + len - 3, ""VLC""))
            return strdup( dirname(psz_img_name) );

        /* Do we end by ""VLC-Plugin""? oh, w...",5,,44,4,,void
19592,BLOCK,-1,,"{
            /* Look for the next forward slash */
            p += 26; /* p_char += strlen("" VLCKit.framework/Versions/"" ) */
            p += strcspn( p, ""/"" );

            /* If the string ends with VLCKit then we've found a winner */
            if (!strcmp( p, ""/VLCKit""))
                return strdup( dirname(psz_img_name) );
        }",24,,51,2,,void
19606,BLOCK,-1,,<empty>,17,,58,2,,void
19629,BLOCK,-1,,<empty>,13,,65,2,,void
19647,BLOCK,-1,,<empty>,13,,69,2,,void
19665,BLOCK,-1,,<empty>,13,,73,2,,void
19683,BLOCK,-1,,<empty>,13,,77,2,,void
19694,BLOCK,-1,,"{
        char *incompletepath = strdup(dirname( (char *)info.dli_fname ));
        char *path = NULL;
        asprintf(&path, ""%s/""PACKAGE, incompletepath);
        free(incompletepath);
        return path;
    }",37,,83,2,,void
19719,BLOCK,-1,,"{
    const char *path = getenv (""VLC_DATA_PATH"");
    if (path)
        return strdup (path);

    char *vlcpath = config_GetLibDir ();
    char *datadir;

    if (asprintf (&datadir, ""%s/share"", vlcpath) == -1)
        datadir = NULL;

    free (vlcpath);
    return datadir;
}",1,,96,2,,void
19727,BLOCK,-1,,<empty>,9,,99,2,,void
19745,BLOCK,-1,,<empty>,9,,105,2,,void
19757,BLOCK,-1,,"{
    const char *home = getenv (""HOME"");

    if (home == NULL)
        home = ""/tmp"";

    return strdup (home);
}",1,,112,2,,void
19767,BLOCK,-1,,<empty>,9,,116,2,,void
19778,BLOCK,-1,,"{
    const char *psz_path;
    switch (type) {
        case VLC_CONFIG_DIR:
            psz_path = ""%s/Library/Preferences/%s"";
            break;
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
            psz_path = ""%s/Library/Application Support/%s"";
            break;
        case VLC_CACHE_DIR:
            psz_path = ""%s/Library/Caches/%s"";
            break;
        default:
            vlc_assert_unreachable();
            break;
    }

    // Default fallback
    const char *fallback = ""org.videolan.vlc"";
    char *name = NULL;

    CFBundleRef mainBundle = CFBundleGetMainBundle();
    if (mainBundle) {
        CFStringRef identifierAsNS = CFBundleGetIdentifier(mainBundle);
        if (identifierAsNS) {
            CFIndex len = CFStringGetLength(identifierAsNS);
            CFIndex size = CFStringGetMaximumSizeForEncoding(len, kCFStringEncodingUTF8);
            char *identifier = calloc(len + 1, sizeof(char));
            if (identifier != NULL) {
            ...",1,,122,2,,void
19782,BLOCK,-1,,"{
        case VLC_CONFIG_DIR:
            psz_path = ""%s/Library/Preferences/%s"";
            break;
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
            psz_path = ""%s/Library/Application Support/%s"";
            break;
        case VLC_CACHE_DIR:
            psz_path = ""%s/Library/Caches/%s"";
            break;
        default:
            vlc_assert_unreachable();
            break;
    }",19,,124,2,,void
19820,BLOCK,-1,,"{
        CFStringRef identifierAsNS = CFBundleGetIdentifier(mainBundle);
        if (identifierAsNS) {
            CFIndex len = CFStringGetLength(identifierAsNS);
            CFIndex size = CFStringGetMaximumSizeForEncoding(len, kCFStringEncodingUTF8);
            char *identifier = calloc(len + 1, sizeof(char));
            if (identifier != NULL) {
                Boolean ret = CFStringGetCString(identifierAsNS, identifier, size, kCFStringEncodingUTF8);
                if (ret)
                    name = identifier;
                else
                    free(identifier);
            }
        }
    }",21,,145,2,,void
19828,BLOCK,-1,,"{
            CFIndex len = CFStringGetLength(identifierAsNS);
            CFIndex size = CFStringGetMaximumSizeForEncoding(len, kCFStringEncodingUTF8);
            char *identifier = calloc(len + 1, sizeof(char));
            if (identifier != NULL) {
                Boolean ret = CFStringGetCString(identifierAsNS, identifier, size, kCFStringEncodingUTF8);
                if (ret)
                    name = identifier;
                else
                    free(identifier);
            }
        }",29,,147,2,,void
19853,BLOCK,-1,,"{
                Boolean ret = CFStringGetCString(identifierAsNS, identifier, size, kCFStringEncodingUTF8);
                if (ret)
                    name = identifier;
                else
                    free(identifier);
            }",37,,151,2,,void
19864,BLOCK,-1,,<empty>,21,,154,2,,void
19869,BLOCK,-1,,<empty>,21,,156,1,,void
19890,BLOCK,-1,,<empty>,9,,164,2,,void
19904,BLOCK,-1,,"{
    const char *psz_path;
    switch (type) {
        case VLC_CONFIG_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
        case VLC_CACHE_DIR:
            return getAppDependentDir(type);

        case VLC_DESKTOP_DIR:
            psz_path = ""%s/Desktop"";
            break;
        case VLC_DOWNLOAD_DIR:
            psz_path = ""%s/Downloads"";
            break;
        case VLC_DOCUMENTS_DIR:
            psz_path = ""%s/Documents"";
            break;
        case VLC_MUSIC_DIR:
            psz_path = ""%s/Music"";
            break;
        case VLC_PICTURES_DIR:
            psz_path = ""%s/Pictures"";
            break;
        case VLC_VIDEOS_DIR:
            psz_path = ""%s/Movies"";
            break;
        case VLC_PUBLICSHARE_DIR:
            psz_path = ""%s/Public"";
            break;
        case VLC_HOME_DIR:
        default:
            psz_path = ""%s"";
    }
    char *psz_parent = config_GetHomeDir();
    char *psz_dir;
    if (asprintf( &psz_dir, psz_path,...",1,,172,2,,void
19908,BLOCK,-1,,"{
        case VLC_CONFIG_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
        case VLC_CACHE_DIR:
            return getAppDependentDir(type);

        case VLC_DESKTOP_DIR:
            psz_path = ""%s/Desktop"";
            break;
        case VLC_DOWNLOAD_DIR:
            psz_path = ""%s/Downloads"";
            break;
        case VLC_DOCUMENTS_DIR:
            psz_path = ""%s/Documents"";
            break;
        case VLC_MUSIC_DIR:
            psz_path = ""%s/Music"";
            break;
        case VLC_PICTURES_DIR:
            psz_path = ""%s/Pictures"";
            break;
        case VLC_VIDEOS_DIR:
            psz_path = ""%s/Movies"";
            break;
        case VLC_PUBLICSHARE_DIR:
            psz_path = ""%s/Public"";
            break;
        case VLC_HOME_DIR:
        default:
            psz_path = ""%s"";
    }",19,,174,2,,void
19982,BLOCK,-1,,<empty>,9,,209,2,,void
20004,BLOCK,-1,,<empty>,1,,1,1,,ANY
20007,BLOCK,-1,,"{
    /* We cannot simply use strerror() here, since it is not thread-safe. */
    if ((unsigned)errnum < (unsigned)sys_nerr)
        return sys_errlist[errnum];

    return _(""Unknown error"");
}",1,,32,2,,void
20016,BLOCK,-1,,<empty>,9,,35,2,,void
20028,BLOCK,-1,,"{
    return vlc_strerror_c(errnum);
}",1,,41,2,,void
20052,BLOCK,-1,,<empty>,1,,1,1,,ANY
20055,BLOCK,-1,,"{
    VLC_UNUSED(url);
    char *proxy_url = NULL;
    CFDictionaryRef dicRef = CFNetworkCopySystemProxySettings();
    if (NULL != dicRef) {
        const CFStringRef proxyCFstr = (const CFStringRef)CFDictionaryGetValue(
            dicRef, (const void*)kCFNetworkProxiesHTTPProxy);
        const CFNumberRef portCFnum = (const CFNumberRef)CFDictionaryGetValue(
            dicRef, (const void*)kCFNetworkProxiesHTTPPort);
        if (NULL != proxyCFstr && NULL != portCFnum) {
            int port = 0;
            if (!CFNumberGetValue(portCFnum, kCFNumberIntType, &port)) {
                CFRelease(dicRef);
                return NULL;
            }

            char host_buffer[4096];
            memset(host_buffer, 0, sizeof(host_buffer));
            if (CFStringGetCString(proxyCFstr, host_buffer, sizeof(host_buffer)
                                   - 1, kCFStringEncodingUTF8))
                asprintf(&proxy_url, ""http://%s:%d"", host_buffer, port);
        }

        CFRelease(d...",1,,46,2,,void
20070,BLOCK,-1,,"{
        const CFStringRef proxyCFstr = (const CFStringRef)CFDictionaryGetValue(
            dicRef, (const void*)kCFNetworkProxiesHTTPProxy);
        const CFNumberRef portCFnum = (const CFNumberRef)CFDictionaryGetValue(
            dicRef, (const void*)kCFNetworkProxiesHTTPPort);
        if (NULL != proxyCFstr && NULL != portCFnum) {
            int port = 0;
            if (!CFNumberGetValue(portCFnum, kCFNumberIntType, &port)) {
                CFRelease(dicRef);
                return NULL;
            }

            char host_buffer[4096];
            memset(host_buffer, 0, sizeof(host_buffer));
            if (CFStringGetCString(proxyCFstr, host_buffer, sizeof(host_buffer)
                                   - 1, kCFStringEncodingUTF8))
                asprintf(&proxy_url, ""http://%s:%d"", host_buffer, port);
        }

        CFRelease(dicRef);
    }",25,,50,2,,void
20099,BLOCK,-1,,"{
            int port = 0;
            if (!CFNumberGetValue(portCFnum, kCFNumberIntType, &port)) {
                CFRelease(dicRef);
                return NULL;
            }

            char host_buffer[4096];
            memset(host_buffer, 0, sizeof(host_buffer));
            if (CFStringGetCString(proxyCFstr, host_buffer, sizeof(host_buffer)
                                   - 1, kCFStringEncodingUTF8))
                asprintf(&proxy_url, ""http://%s:%d"", host_buffer, port);
        }",54,,55,2,,void
20111,BLOCK,-1,,"{
                CFRelease(dicRef);
                return NULL;
            }",72,,57,2,,void
20131,BLOCK,-1,,<empty>,17,,66,2,,void
20160,BLOCK,-1,,<empty>,1,,1,1,,ANY
20163,BLOCK,-1,,"{
#ifdef ENABLE_NLS
    /* Check if $LANG is set. */
    if( NULL == getenv(""LANG"") )
    {
        /*
           Retrieve the preferred language as chosen in  System Preferences.app
           (note that CFLocaleCopyCurrent() is not used because it returns the
            preferred locale not language)
        */
        CFArrayRef all_locales, preferred_locales;
        char psz_locale[50];

        all_locales = CFLocaleCopyAvailableLocaleIdentifiers();

        preferred_locales = CFBundleCopyLocalizationsForPreferences( all_locales, NULL );

        if ( preferred_locales )
        {
            if ( CFArrayGetCount( preferred_locales ) )
            {
                CFStringRef user_language_string_ref = CFArrayGetValueAtIndex( preferred_locales, 0 );
                CFStringGetCString( user_language_string_ref, psz_locale, sizeof(psz_locale), kCFStringEncodingUTF8 );
                setenv( ""LANG"", psz_locale, 1 );
            }
            CFRelease( preferred_locales );
  ...",1,,42,2,,void
20170,BLOCK,-1,,"{
    (void)p_this;
    (void)i_argc;
    (void)ppsz_argv;
}",1,,79,4,,void
20210,BLOCK,-1,,<empty>,1,,1,1,,ANY
20214,BLOCK,-1,,"{
    if (unlikely(mach_timebase_info (&vlc_clock_conversion_factor) != 0))
        abort ();
}",1,,48,2,,void
20222,BLOCK,-1,,<empty>,9,,50,2,,void
20232,BLOCK,-1,,"{
    lldiv_t d = lldiv (date, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return ts;
}",1,,59,2,,void
20261,BLOCK,-1,,"{
     fprintf (stderr, ""at %s:%u in %s\n"", file, line, fn);
     fflush (stderr); /* needed before switch to low-level I/O */
     void *stack[20];
     int len = backtrace (stack, sizeof (stack) / sizeof (stack[0]));
     backtrace_symbols_fd (stack, len, 2);
     fsync (2);
}",1,,68,4,,void
20297,BLOCK,-1,,"{
    int canc = vlc_savecancel ();
    fprintf (stderr, ""LibVLC fatal error %s (%d) in thread %lu "",
             action, error, vlc_thread_id ());
    vlc_trace (function, file, line);

    char buf[1000];
    const char *msg;

    switch (strerror_r (error, buf, sizeof (buf)))
    {
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }
    fprintf (stderr, "" Error message: %s\n"", msg);
    fflush (stderr);

    vlc_restorecancel (canc);
    abort ();
}",1,,82,6,,void
20320,BLOCK,-1,,"{
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }",5,,92,2,,void
20351,BLOCK,-1,,"{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
#ifdef NDEBUG
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);
#else
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_ERRORCHECK);
#endif
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,,119,2,,void
20358,BLOCK,-1,,<empty>,9,,123,2,,void
20370,BLOCK,-1,,<empty>,9,,130,2,,void
20379,BLOCK,-1,,"{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,,135,2,,void
20386,BLOCK,-1,,<empty>,9,,139,2,,void
20398,BLOCK,-1,,<empty>,9,,142,2,,void
20407,BLOCK,-1,,"{
    int val = pthread_mutex_destroy( p_mutex );
    VLC_THREAD_ASSERT (""destroying mutex"");
}",1,,148,2,,void
20414,BLOCK,1,,<empty>,,,,3,,void
20418,BLOCK,-1,,<empty>,5,,150,2,,void
20430,BLOCK,-1,,"{
    int val = pthread_mutex_lock( p_mutex );
    VLC_THREAD_ASSERT (""locking mutex"");
}",1,,169,2,,void
20437,BLOCK,1,,<empty>,,,,3,,void
20441,BLOCK,-1,,<empty>,5,,171,2,,void
20452,BLOCK,-1,,"{
    int val = pthread_mutex_trylock( p_mutex );

    if (val != EBUSY)
        VLC_THREAD_ASSERT (""locking mutex"");
    return val;
}",1,,175,2,,void
20462,BLOCK,-1,,<empty>,9,,179,2,,void
20464,BLOCK,1,,<empty>,,,,3,,void
20468,BLOCK,-1,,<empty>,9,,179,2,,void
20481,BLOCK,-1,,"{
    int val = pthread_mutex_unlock( p_mutex );
    /* FIXME: We can't check for the success of the unlock
     * here as due to a bug in Apple pthread implementation.
     * The `pthread_cond_wait` function does not behave like
     * it should According to POSIX, pthread_cond_wait is a
     * cancellation point and when a thread is cancelled while
     * in a condition wait, the mutex is re-acquired before
     * calling the first cancellation cleanup handler:
     *
     * > The effect is as if the thread were unblocked, allowed
     * > to execute up to the point of returning from the call to
     * > pthread_cond_timedwait() or pthread_cond_wait(), but at
     * > that point notices the cancellation request and instead
     * > of returning to the caller of pthread_cond_timedwait()
     * > or pthread_cond_wait(), starts the thread cancellation
     * > activities, which includes calling cancellation cleanup
     * > handlers.
     *
     * Unfortunately the mutex is not locke...",1,,184,2,,void
20491,BLOCK,-1,,<empty>,9,,213,2,,void
20493,BLOCK,1,,<empty>,,,,3,,void
20497,BLOCK,-1,,<empty>,9,,213,2,,void
20508,BLOCK,-1,,"{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",1,,218,2,,void
20514,BLOCK,-1,,<empty>,9,,220,2,,void
20520,BLOCK,-1,,"{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",1,,224,2,,void
20526,BLOCK,-1,,<empty>,9,,226,2,,void
20532,BLOCK,-1,,"{
    int val = pthread_cond_destroy (p_condvar);

    /* due to a faulty pthread implementation within Darwin 11 and
     * later condition variables cannot be destroyed without
     * terminating the application immediately.
     * This Darwin kernel issue is still present in version 13
     * and might not be resolved prior to Darwin 15.
     * radar://12496249
     *
     * To work-around this, we are just leaking the condition variable
     * which is acceptable due to VLC's low number of created variables
     * and its usually limited runtime.
     * Ideally, we should implement a re-useable pool.
     */
    if (val != 0) {
        #ifndef NDEBUG
        printf(""pthread_cond_destroy returned %i\n"", val);
        #endif

        if (val == EBUSY)
            return;
    }

    VLC_THREAD_ASSERT (""destroying condition"");
}",1,,230,2,,void
20542,BLOCK,-1,,"{
        #ifndef NDEBUG
        printf(""pthread_cond_destroy returned %i\n"", val);
        #endif

        if (val == EBUSY)
            return;
    }",19,,245,2,,void
20550,BLOCK,-1,,<empty>,13,,251,2,,void
20553,BLOCK,1,,<empty>,,,,3,,void
20557,BLOCK,-1,,<empty>,5,,254,2,,void
20568,BLOCK,-1,,"{
    int val = pthread_cond_signal (p_condvar);
    VLC_THREAD_ASSERT (""signaling condition variable"");
}",1,,258,2,,void
20575,BLOCK,1,,<empty>,,,,3,,void
20579,BLOCK,-1,,<empty>,5,,260,2,,void
20590,BLOCK,-1,,"{
    pthread_cond_broadcast (p_condvar);
}",1,,264,2,,void
20598,BLOCK,-1,,"{
    int val = pthread_cond_wait (p_condvar, p_mutex);
    VLC_THREAD_ASSERT (""waiting on condition"");
}",1,,269,3,,void
20606,BLOCK,1,,<empty>,,,,3,,void
20610,BLOCK,-1,,<empty>,5,,271,2,,void
20623,BLOCK,-1,,"{
    /* according to POSIX standards, cond_timedwait should be a cancellation point
     * Of course, Darwin does not care */
    pthread_testcancel();

    /*
     * mdate() is the monotonic clock, pthread_cond_timedwait expects
     * origin of gettimeofday(). Use timedwait_relative_np() instead.
     */
    mtime_t base = mdate();
    deadline -= base;
    if (deadline < 0)
        deadline = 0;

    struct timespec ts = mtime_to_ts(deadline);
    int val = pthread_cond_timedwait_relative_np(p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,,276,4,,void
20636,BLOCK,-1,,<empty>,9,,288,2,,void
20657,BLOCK,-1,,<empty>,9,,293,2,,void
20659,BLOCK,1,,<empty>,,,,3,,void
20663,BLOCK,-1,,<empty>,9,,293,2,,void
20678,BLOCK,-1,,"{
    /*
     * Note that both pthread_cond_timedwait_relative_np and pthread_cond_timedwait
     * convert the given timeout to a mach absolute deadline, with system startup
     * as the time origin. There is no way you can change this behaviour.
     *
     * For more details, see: https://devforums.apple.com/message/931605
     */

    pthread_testcancel();

    /*
     * FIXME: It is assumed, that in this case the system waits until the real
     * time deadline is passed, even if the real time is adjusted in between.
     * This is not fulfilled, as described above.
     */
    struct timespec ts = mtime_to_ts(deadline);
    int val = pthread_cond_timedwait(p_condvar, p_mutex, &ts);

    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,,300,4,,void
20697,BLOCK,-1,,<empty>,9,,320,2,,void
20699,BLOCK,1,,<empty>,,,,3,,void
20703,BLOCK,-1,,<empty>,9,,320,2,,void
20717,BLOCK,-1,,"{
    if (unlikely(semaphore_create(mach_task_self(), sem, SYNC_POLICY_FIFO, value) != KERN_SUCCESS))
        abort ();
}",1,,327,3,,void
20727,BLOCK,-1,,<empty>,9,,329,2,,void
20733,BLOCK,-1,,"{
    int val;

    if (likely(semaphore_destroy(mach_task_self(), *sem) == KERN_SUCCESS))
        return;

    val = EINVAL;

    VLC_THREAD_ASSERT (""destroying semaphore"");
}",1,,333,2,,void
20743,BLOCK,-1,,<empty>,9,,337,2,,void
20749,BLOCK,1,,<empty>,,,,3,,void
20753,BLOCK,-1,,<empty>,5,,341,2,,void
20764,BLOCK,-1,,"{
    int val;

    if (likely(semaphore_signal(*sem) == KERN_SUCCESS))
        return 0;

    val = EINVAL;

    if (unlikely(val != EOVERFLOW))
        VLC_THREAD_ASSERT (""unlocking semaphore"");
    return val;
}",1,,345,2,,void
20773,BLOCK,-1,,<empty>,9,,349,2,,void
20784,BLOCK,-1,,<empty>,9,,354,2,,void
20786,BLOCK,1,,<empty>,,,,3,,void
20790,BLOCK,-1,,<empty>,9,,354,2,,void
20803,BLOCK,-1,,"{
    int val;

    if (likely(semaphore_wait(*sem) == KERN_SUCCESS))
        return;

    val = EINVAL;

    VLC_THREAD_ASSERT (""locking semaphore"");
}",1,,359,2,,void
20812,BLOCK,-1,,<empty>,9,,363,2,,void
20818,BLOCK,1,,<empty>,,,,3,,void
20822,BLOCK,-1,,<empty>,5,,367,2,,void
20833,BLOCK,-1,,"{
    if (unlikely(pthread_rwlock_init (lock, NULL)))
        abort ();
}",1,,371,2,,void
20839,BLOCK,-1,,<empty>,9,,373,2,,void
20845,BLOCK,-1,,"{
    int val = pthread_rwlock_destroy (lock);
    VLC_THREAD_ASSERT (""destroying R/W lock"");
}",1,,377,2,,void
20852,BLOCK,1,,<empty>,,,,3,,void
20856,BLOCK,-1,,<empty>,5,,379,2,,void
20867,BLOCK,-1,,"{
    int val = pthread_rwlock_rdlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for reading"");
}",1,,383,2,,void
20874,BLOCK,1,,<empty>,,,,3,,void
20878,BLOCK,-1,,<empty>,5,,385,2,,void
20889,BLOCK,-1,,"{
    int val = pthread_rwlock_wrlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for writing"");
}",1,,389,2,,void
20896,BLOCK,1,,<empty>,,,,3,,void
20900,BLOCK,-1,,<empty>,5,,391,2,,void
20911,BLOCK,-1,,"{
    int val = pthread_rwlock_unlock (lock);
    VLC_THREAD_ASSERT (""releasing R/W lock"");
}",1,,395,2,,void
20918,BLOCK,1,,<empty>,,,,3,,void
20922,BLOCK,-1,,<empty>,5,,397,2,,void
20934,BLOCK,-1,,"{
    return pthread_key_create (key, destr);
}",1,,401,3,,void
20943,BLOCK,-1,,"{
    pthread_key_delete (*p_tls);
}",1,,406,2,,void
20952,BLOCK,-1,,"{
    return pthread_setspecific (key, value);
}",1,,411,3,,void
20961,BLOCK,-1,,"{
    return pthread_getspecific (key);
}",1,,416,2,,void
20969,BLOCK,-1,,"{
    (void) p_libvlc;
}",1,,421,2,,void
20981,BLOCK,-1,,"{
    int ret;

    sigset_t oldset;
    {
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }

    (void) priority;

#define VLC_STACKSIZE (128 * sizeof (void *) * 1024)

#ifdef VLC_STACKSIZE
    ret = pthread_attr_setstacksize (attr, VLC_STACKSIZE);
    assert (ret == 0); /* fails iif VLC_STACKSIZE is invalid */
#endif

    ret = pthread_create (th, attr, entry, data);
    pthread_sigmask (SIG_SETMASK, &oldset, NULL);
    pthread_attr_destroy (attr);
    return ret;
}",1,,427,6,,void
20984,BLOCK,3,,"{
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }",5,,431,3,,void
21023,BLOCK,1,,<empty>,,,,1,,void
21057,BLOCK,-1,,"{
    pthread_attr_t attr;

    pthread_attr_init (&attr);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,,460,5,,void
21075,BLOCK,-1,,"{
    int val = pthread_join (handle, result);
    VLC_THREAD_ASSERT (""joining thread"");
}",1,,468,3,,void
21083,BLOCK,1,,<empty>,,,,3,,void
21087,BLOCK,-1,,<empty>,5,,470,2,,void
21101,BLOCK,-1,,"{
    vlc_thread_t dummy;
    pthread_attr_t attr;

    if (th == NULL)
        th = &dummy;

    pthread_attr_init (&attr);
    pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,,475,5,,void
21108,BLOCK,-1,,<empty>,9,,480,2,,void
21132,BLOCK,-1,,"{
    return pthread_self ();
}",1,,488,2,,void
21139,BLOCK,-1,,"{
    return -1;
}",1,,493,2,,void
21148,BLOCK,-1,,"{
    (void) th; (void) priority;
    return VLC_SUCCESS;
}",1,,498,3,,void
21161,BLOCK,-1,,"{
    pthread_cancel (thread_id);
}",1,,504,2,,void
21168,BLOCK,-1,,"{
    int state;
    int val = pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);

    VLC_THREAD_ASSERT (""saving cancellation"");
    return state;
}",1,,509,2,,void
21178,BLOCK,1,,<empty>,,,,3,,void
21182,BLOCK,-1,,<empty>,5,,513,2,,void
21195,BLOCK,-1,,"{
#ifndef NDEBUG
    int oldstate, val;

    val = pthread_setcancelstate (state, &oldstate);
    VLC_THREAD_ASSERT (""restoring cancellation"");

    if (unlikely(oldstate != PTHREAD_CANCEL_DISABLE))
         vlc_thread_fatal (""restoring cancellation while not disabled"", EINVAL,
                           __func__, __FILE__, __LINE__);
#else
    pthread_setcancelstate (state, NULL);
#endif
}",1,,518,2,,void
21205,BLOCK,1,,<empty>,,,,3,,void
21209,BLOCK,-1,,<empty>,5,,523,2,,void
21221,BLOCK,-1,,<empty>,10,,526,2,,void
21227,BLOCK,1,,<empty>,,,,1,,void
21230,BLOCK,1,,<empty>,,,,1,,void
21236,BLOCK,-1,,"{
    pthread_testcancel ();
}",1,,534,2,,void
21242,BLOCK,-1,,"{
    (void) cmd;
    vlc_assert_unreachable ();
}",1,,539,2,,void
21251,BLOCK,-1,,"{
    vlc_clock_setup();
    uint64_t date = mach_absolute_time();

    /* denom is uint32_t, switch to 64 bits to prevent overflow. */
    uint64_t denom = vlc_clock_conversion_factor.denom;

    /* Switch to microsecs */
    denom *= 1000LL;

    /* Split the division to prevent overflow */
    lldiv_t d = lldiv (vlc_clock_conversion_factor.numer, denom);

    return (d.quot * date) + ((d.rem * date) / denom);
}",1,,545,2,,void
21253,BLOCK,1,,<empty>,,,,2,,void
21297,BLOCK,-1,,"{
    deadline -= mdate ();
    if (deadline > 0)
        msleep (deadline);
}",1,,563,2,,void
21305,BLOCK,-1,,<empty>,9,,566,2,,void
21312,BLOCK,-1,,"{
    struct timespec ts = mtime_to_ts (delay);

    /* nanosleep uses mach_absolute_time and mach_wait_until internally,
       but also handles kernel errors. Thus we use just this. */
    while (nanosleep (&ts, &ts) == -1)
        assert (errno == EINTR);
}",1,,571,2,,void
21335,BLOCK,-1,,"{
    return sysconf(_SC_NPROCESSORS_CONF);
}",1,,581,2,,void
21357,BLOCK,-1,,<empty>,1,,1,1,,ANY
22737,BLOCK,-1,,"{
    if( !inbuf || !(*inbuf) )
        return (size_t)(0);    /* Reset state requested */

    const char *iptr = *inbuf;
    const char *iend = iptr + *inbytesleft;
    unsigned char *optr = *outbuf;
    unsigned char *oend = optr + *outbytesleft;
    int err = 0;

    while ( iptr < iend )
    {
        unsigned char c1 = *iptr;
        uint_fast16_t ch = ucs4_table[c1];

        if( c1 >= 0xc1 && c1 <= 0xcf )
        {
            /* Composed character */
            if ( iptr + 1 >= iend )
            {
                err = EINVAL;
                break;    /* No next character */
            }

            unsigned char c2 = iptr[1];
            if ( c2 < 0x40 || c2 >= 0x80 ||
                 !(ch = to_ucs4_comb[c1 - 0xc1][c2 - 0x40]) )
            {
                err = EILSEQ;
                break;   /* Illegal combination */
            }
            iptr += 2;

        }
        else
        {
            if ( !ch )
            {
                err = EILSEQ;
         ...",1,,297,6,,void
22745,BLOCK,-1,,<empty>,9,,299,2,,void
22781,BLOCK,-1,,"{
        unsigned char c1 = *iptr;
        uint_fast16_t ch = ucs4_table[c1];

        if( c1 >= 0xc1 && c1 <= 0xcf )
        {
            /* Composed character */
            if ( iptr + 1 >= iend )
            {
                err = EINVAL;
                break;    /* No next character */
            }

            unsigned char c2 = iptr[1];
            if ( c2 < 0x40 || c2 >= 0x80 ||
                 !(ch = to_ucs4_comb[c1 - 0xc1][c2 - 0x40]) )
            {
                err = EILSEQ;
                break;   /* Illegal combination */
            }
            iptr += 2;

        }
        else
        {
            if ( !ch )
            {
                err = EILSEQ;
                break;
            }
            iptr++;
        }

        if( ch < 0x80 )
        {
            if( optr >= oend )
            {
                err = E2BIG;
                break;    /* No space in outbuf */
            }
            *optr++ = ch;
        }
        else if ( ch < 0x800 )...",5,,308,2,,void
22801,BLOCK,-1,,"{
            /* Composed character */
            if ( iptr + 1 >= iend )
            {
                err = EINVAL;
                break;    /* No next character */
            }

            unsigned char c2 = iptr[1];
            if ( c2 < 0x40 || c2 >= 0x80 ||
                 !(ch = to_ucs4_comb[c1 - 0xc1][c2 - 0x40]) )
            {
                err = EILSEQ;
                break;   /* Illegal combination */
            }
            iptr += 2;

        }",9,,313,2,,void
22808,BLOCK,-1,,"{
                err = EINVAL;
                break;    /* No next character */
            }",13,,316,2,,void
22840,BLOCK,-1,,"{
                err = EILSEQ;
                break;   /* Illegal combination */
            }",13,,324,2,,void
22849,BLOCK,-1,,"{
            if ( !ch )
            {
                err = EILSEQ;
                break;
            }
            iptr++;
        }",9,,332,1,,void
22853,BLOCK,-1,,"{
                err = EILSEQ;
                break;
            }",13,,334,2,,void
22864,BLOCK,-1,,"{
            if( optr >= oend )
            {
                err = E2BIG;
                break;    /* No space in outbuf */
            }
            *optr++ = ch;
        }",9,,342,2,,void
22869,BLOCK,-1,,"{
                err = E2BIG;
                break;    /* No space in outbuf */
            }",13,,344,2,,void
22880,BLOCK,-1,,<empty>,14,,350,1,,void
22885,BLOCK,-1,,"{
            if ( optr + 1 >= oend )
            {
                err = E2BIG;
                break;
            }

            optr[1] = 0x80 | (ch & 0x3f);
            optr[0] = 0xc0 | (ch >> 6);
            optr +=2;
        }",9,,351,2,,void
22892,BLOCK,-1,,"{
                err = E2BIG;
                break;
            }",13,,353,2,,void
22919,BLOCK,-1,,"{
            if ( optr + 2 >= oend )
            {
                err = E2BIG;
                break;
            }

            optr[2] = 0x80 | (ch & 0x3f);
            ch >>= 6;
            optr[1] = 0x80 | (ch & 0x3f);
            optr[0] = 0xe0 | (ch >> 6);
            optr += 3;
        }",9,,363,1,,void
22926,BLOCK,-1,,"{
                err = E2BIG;
                break;
            }",13,,365,2,,void
22986,BLOCK,-1,,"{
        errno = err;
        return (size_t)(-1);
    }",5,,384,2,,void
23002,BLOCK,-1,,"{
#ifndef __linux__
    if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937"") )
        return (vlc_iconv_t)(-2);
    else if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937-2"") )
        return (vlc_iconv_t)(-3);
#endif
#if defined(HAVE_ICONV)
# if defined(__OS2__) && defined(__INNOTEK_LIBC__)
    char tocode_ucs2[] = ""UCS-2LE"";
    char fromcode_ucs2[] = ""UCS-2LE"";
    os2_iconv_t *p_os2_iconv;

    /* Workaround for UTF-16 because OS/2 supports UCS-2 only not UTF-16 */
    if( !strncmp( tocode, ""UTF-16"", 6 ))
    {
        strncpy( tocode_ucs2 + 5, tocode + 6, 2 );
        tocode = tocode_ucs2;
    }

    if( !strncmp( fromcode, ""UTF-16"", 6 ))
    {
        strncpy( fromcode_ucs2 + 5, fromcode + 6, 2 );
        fromcode = fromcode_ucs2;
    }

    p_os2_iconv = ( os2_iconv_t * )iconv_open( tocode, fromcode );

    if( p_os2_iconv != ( iconv_t )(-1))
    {
        /* Mimic a behavior of GNU libiconv */
        uconv_attribute_t attr;

        UniQu...",1,,398,3,,void
23013,BLOCK,-1,,<empty>,9,,401,2,,void
23019,BLOCK,-1,,<empty>,10,,402,1,,void
23030,BLOCK,-1,,<empty>,9,,403,2,,void
23047,BLOCK,-1,,"{
    size_t ret;

#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
    {
        unsigned char *out = NULL;
        if (outbuf != NULL)
            out = (unsigned char *)*outbuf;

        const uint16_t *ucs4_table = ( cd == (vlc_iconv_t)(-2) ? ISO6937toUCS4 : ISO6937_2toUCS4 );

        ret = ISO6937toUTF8( inbuf, inbytesleft, &out, outbytesleft, ucs4_table );
        if (outbuf != NULL)
            *outbuf = (char *)out;
    }
    else
#endif
#if defined(HAVE_ICONV)
    {
        ICONV_CONST char *cin = NULL;
        if (inbuf != NULL)
            cin = (ICONV_CONST char *)*inbuf;

        ret = iconv( cd, &cin, inbytesleft, outbuf, outbytesleft );
        if (inbuf != NULL)
            *inbuf = cin;
    }
#else
        abort ();
#endif
    return ret;
}",1,,449,6,,void
23061,BLOCK,-1,,"{
        unsigned char *out = NULL;
        if (outbuf != NULL)
            out = (unsigned char *)*outbuf;

        const uint16_t *ucs4_table = ( cd == (vlc_iconv_t)(-2) ? ISO6937toUCS4 : ISO6937_2toUCS4 );

        ret = ISO6937toUTF8( inbuf, inbytesleft, &out, outbytesleft, ucs4_table );
        if (outbuf != NULL)
            *outbuf = (char *)out;
    }",5,,454,2,,void
23070,BLOCK,-1,,<empty>,13,,457,2,,void
23101,BLOCK,-1,,<empty>,13,,463,2,,void
23109,BLOCK,-1,,<empty>,9,,478,1,,void
23117,BLOCK,-1,,"{
#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
        return 0;
#endif
#if defined(HAVE_ICONV)
    return iconv_close( cd );
#else
    abort ();
#endif
}",1,,484,2,,void
23130,BLOCK,-1,,<empty>,9,,487,2,,void
23142,BLOCK,-1,,"{
    bool b_exact = 1;
    uint64_t i_gcd;

    if( i_den == 0 )
    {
        *pi_dst_nom = 0;
        *pi_dst_den = 1;
        return 1;
    }

    i_gcd = GCD( i_nom, i_den );
    i_nom /= i_gcd;
    i_den /= i_gcd;

    if( i_max == 0 ) i_max = INT64_C(0xFFFFFFFF);

    if( i_nom > i_max || i_den > i_max )
    {
        uint64_t i_a0_num = 0, i_a0_den = 1, i_a1_num = 1, i_a1_den = 0;
        b_exact = 0;

        for( ; ; )
        {
            uint64_t i_x = i_nom / i_den;
            uint64_t i_a2n = i_x * i_a1_num + i_a0_num;
            uint64_t i_a2d = i_x * i_a1_den + i_a0_den;

            if( i_a2n > i_max || i_a2d > i_max ) break;

            i_nom %= i_den;

            i_a0_num = i_a1_num; i_a0_den = i_a1_den;
            i_a1_num = i_a2n; i_a1_den = i_a2d;
            if( i_nom == 0 ) break;
            i_x = i_nom; i_nom = i_den; i_den = i_x;
        }
        i_nom = i_a1_num;
        i_den = i_a1_den;
    }

    *pi_dst_nom = i_nom;
    *pi_dst_den = i_den;

  ...",1,,502,6,,void
23152,BLOCK,-1,,"{
        *pi_dst_nom = 0;
        *pi_dst_den = 1;
        return 1;
    }",5,,507,2,,void
23178,BLOCK,-1,,<empty>,22,,517,2,,void
23191,BLOCK,-1,,"{
        uint64_t i_a0_num = 0, i_a0_den = 1, i_a1_num = 1, i_a1_den = 0;
        b_exact = 0;

        for( ; ; )
        {
            uint64_t i_x = i_nom / i_den;
            uint64_t i_a2n = i_x * i_a1_num + i_a0_num;
            uint64_t i_a2d = i_x * i_a1_den + i_a0_den;

            if( i_a2n > i_max || i_a2d > i_max ) break;

            i_nom %= i_den;

            i_a0_num = i_a1_num; i_a0_den = i_a1_den;
            i_a1_num = i_a2n; i_a1_den = i_a2d;
            if( i_nom == 0 ) break;
            i_x = i_nom; i_nom = i_den; i_den = i_x;
        }
        i_nom = i_a1_num;
        i_den = i_a1_den;
    }",5,,520,2,,void
23212,BLOCK,-1,,<empty>,9,,524,1,,void
23213,BLOCK,4,,"{
            uint64_t i_x = i_nom / i_den;
            uint64_t i_a2n = i_x * i_a1_num + i_a0_num;
            uint64_t i_a2d = i_x * i_a1_den + i_a0_den;

            if( i_a2n > i_max || i_a2d > i_max ) break;

            i_nom %= i_den;

            i_a0_num = i_a1_num; i_a0_den = i_a1_den;
            i_a1_num = i_a2n; i_a1_den = i_a2d;
            if( i_nom == 0 ) break;
            i_x = i_nom; i_nom = i_den; i_den = i_x;
        }",9,,525,4,,void
23244,BLOCK,-1,,<empty>,50,,530,2,,void
23265,BLOCK,-1,,<empty>,30,,536,2,,void
23320,BLOCK,-1,,<empty>,1,,1,1,,ANY
23323,BLOCK,-1,,"{
    char *url, *path;

    /* Prepending ""file://"" is a bit hackish. But then again, we do not want
     * to hard-code the list of schemes that use file paths in vlc_uri2path().
     */
    if (asprintf(&url, ""file://%s"", location) == -1)
        return NULL;

    path = vlc_uri2path (url);
    free (url);
    return path;
}",1,,43,2,,void
23335,BLOCK,-1,,<empty>,9,,50,2,,void
23350,BLOCK,-1,,"{
    module_unneed(access, access->p_module);
    free(access->psz_filepath);
    free(access->psz_name);
}",1,,58,2,,void
23371,BLOCK,-1,,"{
    char *redirv[MAX_REDIR];
    unsigned redirc = 0;

    stream_t *access = vlc_stream_CommonNew(parent, vlc_access_Destroy);
    if (unlikely(access == NULL))
        return NULL;

    access->p_input = input;
    access->psz_name = NULL;
    access->psz_url = strdup(mrl);
    access->psz_filepath = NULL;
    access->b_preparsing = preparsing;

    if (unlikely(access->psz_url == NULL))
        goto error;

    while (redirc < MAX_REDIR)
    {
        char *url = access->psz_url;
        msg_Dbg(access, ""creating access: %s"", url);

        const char *p = strstr(url, ""://"");
        if (p == NULL)
            goto error;

        access->psz_name = strndup(url, p - url);
        if (unlikely(access->psz_name == NULL))
            goto error;

        access->psz_location = p + 3;
        access->psz_filepath = get_path(access->psz_location);
        if (access->psz_filepath != NULL)
            msg_Dbg(access, "" (path: %s)"", access->psz_filepath);

        access->p_module = m...",1,,71,5,,void
23388,BLOCK,-1,,<empty>,9,,77,2,,void
23424,BLOCK,-1,,<empty>,9,,86,2,,void
23430,BLOCK,1,,<empty>,,,,1,,void
23432,BLOCK,-1,,"{
        char *url = access->psz_url;
        msg_Dbg(access, ""creating access: %s"", url);

        const char *p = strstr(url, ""://"");
        if (p == NULL)
            goto error;

        access->psz_name = strndup(url, p - url);
        if (unlikely(access->psz_name == NULL))
            goto error;

        access->psz_location = p + 3;
        access->psz_filepath = get_path(access->psz_location);
        if (access->psz_filepath != NULL)
            msg_Dbg(access, "" (path: %s)"", access->psz_filepath);

        access->p_module = module_need(access, ""access"", access->psz_name,
                                       true);
        if (access->p_module != NULL) /* success */
        {
            while (redirc > 0)
                free(redirv[--redirc]);

            assert(access->pf_control != NULL);
            return access;
        }

        if (access->psz_url == url) /* failure (no redirection) */
            goto error;

        /* redirection */
        msg_Dbg(acce...",5,,89,2,,void
23453,BLOCK,-1,,<empty>,13,,95,2,,void
23471,BLOCK,-1,,<empty>,13,,99,2,,void
23494,BLOCK,-1,,<empty>,13,,104,2,,void
23518,BLOCK,-1,,"{
            while (redirc > 0)
                free(redirv[--redirc]);

            assert(access->pf_control != NULL);
            return access;
        }",9,,109,2,,void
23542,BLOCK,-1,,<empty>,13,,118,2,,void
23557,BLOCK,-1,,<empty>,9,,124,1,,void
23576,BLOCK,-1,,"{
                msg_Err(access, ""redirection loop"");
                goto error;
            }",13,,126,2,,void
23628,BLOCK,-1,,"{
    return access_New(parent, NULL, false, mrl);
}",1,,147,3,,void
23641,BLOCK,-1,,"{
    VLC_UNUSED( p_access );

    switch( i_query )
    {
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool* ) = false;
            break;
        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;
        case STREAM_IS_DIRECTORY:
            break;
        default:
            return VLC_EGENERIC;
     }
     return VLC_SUCCESS;
}",1,,155,4,,void
23646,BLOCK,-1,,"{
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool* ) = false;
            break;
        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;
        case STREAM_IS_DIRECTORY:
            break;
        default:
            return VLC_EGENERIC;
     }",5,,159,2,,void
23674,BLOCK,-1,,"{
    (void) s; (void) p_node;
    return VLC_EGENERIC;;
}",1,,178,3,,void
23688,BLOCK,-1,,"{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;
    block_t * block;

    if (vlc_stream_Eof(access))
    {
        *eof = true;
        return NULL;
    }
    if (vlc_killed())
        return NULL;

    block = vlc_stream_ReadBlock(access);

    if (block != NULL && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes,
                     block->i_buffer, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return block;
}",1,,185,3,,void
23705,BLOCK,-1,,"{
        *eof = true;
        return NULL;
    }",5,,191,2,,void
23714,BLOCK,-1,,<empty>,9,,196,2,,void
23729,BLOCK,-1,,"{
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes,
                     block->i_buffer, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }",5,,201,2,,void
23785,BLOCK,-1,,"{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;

    if (vlc_stream_Eof(access))
        return 0;
    if (vlc_killed())
        return -1;

    ssize_t val = vlc_stream_ReadPartial(access, buf, len);

    if (val > 0 && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes, val, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return val;
}",1,,217,4,,void
23801,BLOCK,-1,,<empty>,9,,222,2,,void
23806,BLOCK,-1,,<empty>,9,,224,2,,void
23825,BLOCK,-1,,"{
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes, val, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }",5,,229,2,,void
23878,BLOCK,-1,,"{
    stream_t *access = s->p_sys;

    return access->pf_readdir(access, p_node);
}",1,,244,3,,void
23897,BLOCK,-1,,"{
    stream_t *access = s->p_sys;

    return vlc_stream_Seek(access, offset);
}",1,,252,3,,void
23914,BLOCK,-1,,"{
    stream_t *access = s->p_sys;

    return vlc_stream_vaControl(access, cmd, args);
}",1,,259,4,,void
23930,BLOCK,-1,,"{
    stream_t *access = s->p_sys;

    vlc_stream_Delete(access);
}",1,,266,2,,void
23946,BLOCK,-1,,"{
    stream_t *s = vlc_stream_CommonNew(parent, AStreamDestroy);
    if (unlikely(s == NULL))
        return NULL;

    stream_t *access = access_New(VLC_OBJECT(s), input, preparsing, url);
    if (access == NULL)
    {
        stream_CommonDelete(s);
        return NULL;
    }

    s->p_input = input;
    s->psz_url = strdup(access->psz_url);

    const char *cachename;

    if (access->pf_block != NULL)
    {
        s->pf_block = AStreamReadBlock;
        cachename = ""prefetch,cache_block"";
    }
    else
    if (access->pf_read != NULL)
    {
        s->pf_read = AStreamReadStream;
        cachename = ""prefetch,cache_read"";
    }
    else
    {
        cachename = NULL;
    }

    if (access->pf_readdir != NULL)
        s->pf_readdir = AStreamReadDir;
    else
        s->pf_readdir = AStreamNoReadDir;

    s->pf_seek    = AStreamSeek;
    s->pf_control = AStreamControl;
    s->p_sys      = access;

    if (cachename != NULL)
        s = stream_FilterChainNew(s, cachename);
    ...",1,,274,5,,void
23958,BLOCK,-1,,<empty>,9,,277,2,,void
23974,BLOCK,-1,,"{
        stream_CommonDelete(s);
        return NULL;
    }",5,,281,2,,void
23999,BLOCK,-1,,"{
        s->pf_block = AStreamReadBlock;
        cachename = ""prefetch,cache_block"";
    }",5,,292,2,,void
24009,BLOCK,-1,,<empty>,5,,297,1,,void
24016,BLOCK,-1,,"{
        s->pf_read = AStreamReadStream;
        cachename = ""prefetch,cache_read"";
    }",5,,298,2,,void
24026,BLOCK,-1,,"{
        cachename = NULL;
    }",5,,303,1,,void
24036,BLOCK,-1,,<empty>,9,,308,2,,void
24043,BLOCK,-1,,<empty>,9,,310,1,,void
24068,BLOCK,-1,,<empty>,9,,317,2,,void
24093,BLOCK,-1,,<empty>,1,,1,1,,ANY
24103,BLOCK,-1,,<empty>,,,,3,,<empty>
24108,BLOCK,-1,,<empty>,,,,2,,<empty>
24113,BLOCK,-1,,<empty>,,,,2,,<empty>
24119,BLOCK,-1,,<empty>,,,,3,,<empty>
24124,BLOCK,-1,,<empty>,,,,2,,<empty>
24130,BLOCK,-1,,<empty>,,,,3,,<empty>
24140,BLOCK,-1,,"{
    clock_point_t p = { .i_stream = i_stream, .i_system = i_system };
    return p;
}",1,,133,3,,void
24145,BLOCK,1,,<empty>,25,,134,1,,void
24149,BLOCK,2,,<empty>,47,,134,2,,void
24168,BLOCK,-1,,<empty>,,,,1,,<empty>
24171,BLOCK,1,,<empty>,,,,1,,void
24187,BLOCK,-1,,<empty>,,,,3,,<empty>
24193,BLOCK,-1,,<empty>,,,,3,,<empty>
24198,BLOCK,-1,,<empty>,,,,2,,<empty>
24203,BLOCK,-1,,"{
    input_clock_t *cl = malloc( sizeof(*cl) );
    if( !cl )
        return NULL;

    vlc_mutex_init( &cl->lock );
    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;

    cl->last = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );

    cl->i_ts_max = VLC_TS_INVALID;

    cl->i_buffering_duration = 0;

    cl->i_next_drift_update = VLC_TS_INVALID;
    AvgInit( &cl->drift, 10 );

    cl->late.i_index = 0;
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;

    cl->i_rate = i_rate;
    cl->i_pts_delay = 0;
    cl->b_paused = false;
    cl->i_pause_date = VLC_TS_INVALID;

    return cl;
}",1,,192,2,,void
24214,BLOCK,-1,,<empty>,9,,195,2,,void
24275,BLOCK,-1,,<empty>,5,,212,1,,void
24283,BLOCK,1,,<empty>,,,,1,,void
24322,BLOCK,-1,,"{
    AvgClean( &cl->drift );
    vlc_mutex_destroy( &cl->lock );
    free( cl );
}",1,,227,2,,void
24345,BLOCK,-1,,"{
    bool b_reset_reference = false;

    assert( i_ck_stream > VLC_TS_INVALID && i_ck_system > VLC_TS_INVALID );

    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        /* */
        b_reset_reference= true;
    }
    else if( cl->last.i_stream > VLC_TS_INVALID &&
             ( (cl->last.i_stream - i_ck_stream) > CR_MAX_GAP ||
               (cl->last.i_stream - i_ck_stream) < -CR_MAX_GAP ) )
    {
        /* Stream discontinuity, for which we haven't received a
         * warning from the stream control facilities (dd-edited
         * stream ?). */
        msg_Warn( p_log, ""clock gap, unexpected stream discontinuity"" );
        cl->i_ts_max = VLC_TS_INVALID;

        /* */
        msg_Warn( p_log, ""feeding synchro with a new reference point trying to recover from clock gap"" );
        b_reset_reference= true;
    }

    /* */
    if( b_reset_reference )
    {
        cl->i_next_drift_update = VLC_TS_INVALID;
        AvgReset( &cl->drift );

        /* Fe...",1,,243,8,,void
24368,BLOCK,-1,,"{
        /* */
        b_reset_reference= true;
    }",5,,251,2,,void
24373,BLOCK,-1,,<empty>,10,,255,1,,void
24393,BLOCK,1,,<empty>,,,,1,,void
24407,BLOCK,1,,<empty>,,,,1,,void
24411,BLOCK,-1,,"{
        /* Stream discontinuity, for which we haven't received a
         * warning from the stream control facilities (dd-edited
         * stream ?). */
        msg_Warn( p_log, ""clock gap, unexpected stream discontinuity"" );
        cl->i_ts_max = VLC_TS_INVALID;

        /* */
        msg_Warn( p_log, ""feeding synchro with a new reference point trying to recover from clock gap"" );
        b_reset_reference= true;
    }",5,,258,2,,void
24428,BLOCK,-1,,"{
        cl->i_next_drift_update = VLC_TS_INVALID;
        AvgReset( &cl->drift );

        /* Feed synchro with a new reference point. */
        cl->b_has_reference = true;
        cl->ref = clock_point_Create( i_ck_stream,
                                      __MAX( cl->i_ts_max + CR_MEAN_PTS_GAP, i_ck_system ) );
        cl->b_has_external_clock = false;
    }",5,,272,2,,void
24456,BLOCK,1,,<empty>,,,,1,,void
24473,BLOCK,-1,,"{
        const mtime_t i_converted = ClockSystemToStream( cl, i_ck_system );

        AvgUpdate( &cl->drift, i_converted - i_ck_stream );

        cl->i_next_drift_update = i_ck_system + CLOCK_FREQ/5; /* FIXME why that */
    }",5,,286,2,,void
24502,BLOCK,-1,,"{
        cl->i_buffering_duration = 0;
    }",5,,296,2,,void
24509,BLOCK,-1,,<empty>,10,,299,1,,void
24512,BLOCK,-1,,"{
        /* Try to bufferize more than necessary by reading
         * CR_BUFFERING_RATE/256 faster until we have CR_BUFFERING_TARGET.
         */
        const mtime_t i_duration = __MAX( i_ck_stream - cl->last.i_stream, 0 );

        cl->i_buffering_duration += ( i_duration * CR_BUFFERING_RATE + 255 ) / 256;
        if( cl->i_buffering_duration > CR_BUFFERING_TARGET )
            cl->i_buffering_duration = CR_BUFFERING_TARGET;
    }",5,,300,2,,void
24534,BLOCK,1,,<empty>,,,,1,,void
24544,BLOCK,1,,<empty>,,,,1,,void
24546,BLOCK,-1,,<empty>,13,,308,2,,void
24552,BLOCK,1,,<empty>,,,,1,,void
24593,BLOCK,-1,,"{
        cl->late.pi_value[cl->late.i_index] = i_late;
        cl->late.i_index = ( cl->late.i_index + 1 ) % INPUT_CLOCK_LATE_COUNT;
    }",5,,321,2,,void
24622,BLOCK,1,,<empty>,,,,1,,void
24633,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );

    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;
    cl->i_ts_max = VLC_TS_INVALID;

    vlc_mutex_unlock( &cl->lock );
}",1,,333,2,,void
24671,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );

    if( cl->b_has_reference )
    {
        /* Move the reference point (as if we were playing at the new rate
         * from the start */
        cl->ref.i_system = cl->last.i_system - (cl->last.i_system - cl->ref.i_system) * i_rate / cl->i_rate;
    }
    cl->i_rate = i_rate;

    vlc_mutex_unlock( &cl->lock );
}",1,,348,3,,void
24681,BLOCK,-1,,"{
        /* Move the reference point (as if we were playing at the new rate
         * from the start */
        cl->ref.i_system = cl->last.i_system - (cl->last.i_system - cl->ref.i_system) * i_rate / cl->i_rate;
    }",5,,352,2,,void
24727,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );
    assert( (!cl->b_paused) != (!b_paused) );

    if( cl->b_paused )
    {
        const mtime_t i_duration = i_date - cl->i_pause_date;

        if( cl->b_has_reference && i_duration > 0 )
        {
            cl->ref.i_system += i_duration;
            cl->last.i_system += i_duration;
        }
    }
    cl->i_pause_date = i_date;
    cl->b_paused = b_paused;

    vlc_mutex_unlock( &cl->lock );
}",1,,366,4,,void
24745,BLOCK,-1,,"{
        const mtime_t i_duration = i_date - cl->i_pause_date;

        if( cl->b_has_reference && i_duration > 0 )
        {
            cl->ref.i_system += i_duration;
            cl->last.i_system += i_duration;
        }
    }",5,,371,2,,void
24762,BLOCK,-1,,"{
            cl->ref.i_system += i_duration;
            cl->last.i_system += i_duration;
        }",9,,375,2,,void
24796,BLOCK,-1,,"{
    mtime_t i_wakeup = 0;

    vlc_mutex_lock( &cl->lock );

    /* Synchronized, we can wait */
    if( cl->b_has_reference )
        i_wakeup = ClockStreamToSystem( cl, cl->last.i_stream + AvgGet( &cl->drift ) - cl->i_buffering_duration );

    vlc_mutex_unlock( &cl->lock );

    return i_wakeup;
}",1,,390,2,,void
24810,BLOCK,-1,,<empty>,9,,397,2,,void
24846,BLOCK,-1,,"{
    assert( pi_ts0 );
    vlc_mutex_lock( &cl->lock );

    if( pi_rate )
        *pi_rate = cl->i_rate;

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        msg_Err(p_object, ""Timestamp conversion failed for %""PRId64"": ""
                ""no reference clock"", *pi_ts0);
        *pi_ts0 = VLC_TS_INVALID;
        if( pi_ts1 )
            *pi_ts1 = VLC_TS_INVALID;
        return VLC_EGENERIC;
    }

    /* */
    const mtime_t i_ts_buffering = cl->i_buffering_duration * cl->i_rate / INPUT_RATE_DEFAULT;
    const mtime_t i_ts_delay = cl->i_pts_delay + ClockGetTsOffset( cl );

    /* */
    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 = ClockStreamToSystem( cl, *pi_ts0 + AvgGet( &cl->drift ) );
        if( *pi_ts0 > cl->i_ts_max )
            cl->i_ts_max = *pi_ts0;
        *pi_ts0 += i_ts_delay;
    }

    /* XXX we do not update i_ts_max on purpose */
    if( pi_ts1 && *pi_ts1 > VLC_TS_INVALID )
    {
        *pi_ts1 = ClockStreamToSystem( cl, *...",1,,410,7,,void
24856,BLOCK,-1,,<empty>,9,,415,2,,void
24868,BLOCK,-1,,"{
        vlc_mutex_unlock( &cl->lock );
        msg_Err(p_object, ""Timestamp conversion failed for %""PRId64"": ""
                ""no reference clock"", *pi_ts0);
        *pi_ts0 = VLC_TS_INVALID;
        if( pi_ts1 )
            *pi_ts1 = VLC_TS_INVALID;
        return VLC_EGENERIC;
    }",5,,418,2,,void
24881,BLOCK,-1,,<empty>,13,,424,2,,void
24914,BLOCK,-1,,"{
        *pi_ts0 = ClockStreamToSystem( cl, *pi_ts0 + AvgGet( &cl->drift ) );
        if( *pi_ts0 > cl->i_ts_max )
            cl->i_ts_max = *pi_ts0;
        *pi_ts0 += i_ts_delay;
    }",5,,434,2,,void
24935,BLOCK,-1,,<empty>,13,,437,2,,void
24953,BLOCK,-1,,"{
        *pi_ts1 = ClockStreamToSystem( cl, *pi_ts1 + AvgGet( &cl->drift ) ) +
                  i_ts_delay;
    }",5,,443,2,,void
24983,BLOCK,-1,,"{
        if (*pi_ts0 >= mdate() + i_ts_delay + i_ts_buffering + i_ts_bound) {
            msg_Err(p_object,
                ""Timestamp conversion failed (delay %""PRId64"", buffering ""
                ""%""PRId64"", bound %""PRId64"")"",
                i_ts_delay, i_ts_buffering, i_ts_bound);
            return VLC_EGENERIC;
        }
    }",62,,451,2,,void
24995,BLOCK,-1,,"{
            msg_Err(p_object,
                ""Timestamp conversion failed (delay %""PRId64"", buffering ""
                ""%""PRId64"", bound %""PRId64"")"",
                i_ts_delay, i_ts_buffering, i_ts_bound);
            return VLC_EGENERIC;
        }",76,,452,2,,void
25005,BLOCK,-1,,"{
    int i_rate;

    vlc_mutex_lock( &cl->lock );
    i_rate = cl->i_rate;
    vlc_mutex_unlock( &cl->lock );

    return i_rate;
}",1,,467,2,,void
25032,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        return VLC_EGENERIC;
    }

    *pi_stream_start = cl->ref.i_stream;
    *pi_system_start = cl->ref.i_system;

    *pi_stream_duration = cl->last.i_stream - cl->ref.i_stream;
    *pi_system_duration = cl->last.i_system - cl->ref.i_system;

    vlc_mutex_unlock( &cl->lock );

    return VLC_SUCCESS;
}",1,,480,6,,void
25043,BLOCK,-1,,"{
        vlc_mutex_unlock( &cl->lock );
        return VLC_EGENERIC;
    }",5,,484,2,,void
25108,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );
    mtime_t i_offset;
    if( b_absolute )
    {
        i_offset = i_system - cl->ref.i_system - ClockGetTsOffset( cl );
    }
    else
    {
        if( !cl->b_has_external_clock )
        {
            cl->b_has_external_clock = true;
            cl->i_external_clock     = i_system;
        }
        i_offset = i_system - cl->i_external_clock;
    }

    cl->ref.i_system += i_offset;
    cl->last.i_system += i_offset;

    vlc_mutex_unlock( &cl->lock );
}",1,,501,4,,void
25121,BLOCK,-1,,"{
        i_offset = i_system - cl->ref.i_system - ClockGetTsOffset( cl );
    }",5,,507,2,,void
25135,BLOCK,-1,,"{
        if( !cl->b_has_external_clock )
        {
            cl->b_has_external_clock = true;
            cl->i_external_clock     = i_system;
        }
        i_offset = i_system - cl->i_external_clock;
    }",5,,511,1,,void
25141,BLOCK,-1,,"{
            cl->b_has_external_clock = true;
            cl->i_external_clock     = i_system;
        }",9,,513,2,,void
25184,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );

    *pi_system = cl->ref.i_system;
    if( pi_delay )
        *pi_delay  = cl->i_pts_delay;

    vlc_mutex_unlock( &cl->lock );
}",1,,527,4,,void
25204,BLOCK,-1,,<empty>,9,,534,2,,void
25222,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );

    /* Update late observations */
    const mtime_t i_delay_delta = i_pts_delay - cl->i_pts_delay;
    mtime_t pi_late[INPUT_CLOCK_LATE_COUNT];
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        pi_late[i] = __MAX( cl->late.pi_value[(cl->late.i_index + 1 + i)%INPUT_CLOCK_LATE_COUNT] - i_delay_delta, 0 );

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;
    cl->late.i_index = 0;

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
    {
        if( pi_late[i] <= 0 )
            continue;
        cl->late.pi_value[cl->late.i_index] = pi_late[i];
        cl->late.i_index = ( cl->late.i_index + 1 ) % INPUT_CLOCK_LATE_COUNT;
    }

    /* TODO always save the value, and when rebuffering use the new one if smaller
     * TODO when increasing -> force rebuffering
     */
    if( cl->i_pts_delay < i_pts_delay )
        cl->i_pts_delay = i_pts_delay;

    /* */
    if( i_cr_average < 10 )
        i_cr_a...",1,,542,4,,void
25238,BLOCK,-1,,<empty>,5,,548,1,,void
25246,BLOCK,1,,<empty>,,,,1,,void
25273,BLOCK,1,,<empty>,,,,1,,void
25278,BLOCK,-1,,<empty>,5,,551,1,,void
25286,BLOCK,1,,<empty>,,,,1,,void
25307,BLOCK,-1,,<empty>,5,,555,1,,void
25315,BLOCK,1,,<empty>,,,,1,,void
25319,BLOCK,4,,"{
        if( pi_late[i] <= 0 )
            continue;
        cl->late.pi_value[cl->late.i_index] = pi_late[i];
        cl->late.i_index = ( cl->late.i_index + 1 ) % INPUT_CLOCK_LATE_COUNT;
    }",5,,556,4,,void
25326,BLOCK,-1,,<empty>,13,,558,2,,void
25358,BLOCK,1,,<empty>,,,,1,,void
25366,BLOCK,-1,,<empty>,9,,567,2,,void
25376,BLOCK,-1,,<empty>,9,,571,2,,void
25388,BLOCK,-1,,<empty>,9,,574,2,,void
25404,BLOCK,-1,,"{
    vlc_mutex_lock( &cl->lock );

#if INPUT_CLOCK_LATE_COUNT != 3
#   error ""unsupported INPUT_CLOCK_LATE_COUNT""
#endif
    /* Find the median of the last late values
     * It works pretty well at rejecting bad values
     *
     * XXX we only increase pts_delay over time, decreasing it is
     * not that easy if we want to be robust.
     */
    const mtime_t *p = cl->late.pi_value;
    mtime_t i_late_median = p[0] + p[1] + p[2] - __MIN(__MIN(p[0],p[1]),p[2]) - __MAX(__MAX(p[0],p[1]),p[2]);
    mtime_t i_pts_delay = cl->i_pts_delay ;

    vlc_mutex_unlock( &cl->lock );

    return i_pts_delay + i_late_median;
}",1,,580,2,,void
25476,BLOCK,-1,,"{
    if( !cl->b_has_reference )
        return VLC_TS_INVALID;

    return ( i_stream - cl->ref.i_stream ) * cl->i_rate / INPUT_RATE_DEFAULT +
           cl->ref.i_system;
}",1,,605,3,,void
25482,BLOCK,-1,,<empty>,9,,607,2,,void
25510,BLOCK,-1,,"{
    assert( cl->b_has_reference );
    return ( i_system - cl->ref.i_system ) * INPUT_RATE_DEFAULT / cl->i_rate +
            cl->ref.i_stream;
}",1,,619,3,,void
25539,BLOCK,-1,,"{
    return cl->i_pts_delay * ( cl->i_rate - INPUT_RATE_DEFAULT ) / INPUT_RATE_DEFAULT;
}",1,,630,2,,void
25557,BLOCK,-1,,"{
    p_avg->i_divider = i_divider;
    AvgReset( p_avg );
}",1,,638,3,,void
25569,BLOCK,-1,,"{
    VLC_UNUSED(p_avg);
}",1,,643,2,,void
25576,BLOCK,-1,,"{
    p_avg->i_value = 0;
    p_avg->i_residue = 0;
    p_avg->i_count = 0;
}",1,,647,2,,void
25597,BLOCK,-1,,"{
    const int i_f0 = __MIN( p_avg->i_divider - 1, p_avg->i_count );
    const int i_f1 = p_avg->i_divider - i_f0;

    const mtime_t i_tmp = i_f0 * p_avg->i_value + i_f1 * i_value + p_avg->i_residue;

    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;

    p_avg->i_count++;
}",1,,653,3,,void
25660,BLOCK,-1,,"{
    return p_avg->i_value;
}",1,,665,2,,void
25670,BLOCK,-1,,"{
    const mtime_t i_tmp = p_avg->i_value * p_avg->i_divider + p_avg->i_residue;

    p_avg->i_divider = i_divider;
    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;
}",1,,669,3,,void
25718,BLOCK,-1,,<empty>,1,,1,1,,ANY
25723,BLOCK,-1,,<empty>,,,,2,,<empty>
25728,BLOCK,-1,,<empty>,,,,2,,<empty>
25739,BLOCK,-1,,<empty>,,,,8,,<empty>
25744,BLOCK,-1,,<empty>,,,,2,,<empty>
25749,BLOCK,-1,,<empty>,,,,2,,<empty>
25755,BLOCK,-1,,<empty>,,,,3,,<empty>
25762,BLOCK,-1,,<empty>,,,,4,,<empty>
25769,BLOCK,-1,,<empty>,,,,4,,<empty>
25776,BLOCK,-1,,<empty>,,,,4,,<empty>
25786,BLOCK,-1,,<empty>,,,,7,,<empty>
25791,BLOCK,-1,,<empty>,,,,2,,<empty>
25800,BLOCK,-1,,<empty>,,,,6,,<empty>
25807,BLOCK,-1,,<empty>,,,,4,,<empty>
25812,BLOCK,-1,,<empty>,,,,2,,<empty>
25841,BLOCK,-1,,<empty>,1,,1,1,,ANY
25844,BLOCK,-1,,<empty>,,,,2,,<empty>
25850,BLOCK,-1,,"{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = input_vaControl( p_input, i_query, args );
    va_end( args );

    return i_result;
}",1,,54,3,,void
25872,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    seekpoint_t *p_bkmk, ***ppp_bkmk;
    int i_bkmk = 0;
    int *pi_bkmk;

    int i_int, *pi_int;
    bool b_bool, *pb_bool;
    double f, *pf;
    int64_t i_64, *pi_64;

    char *psz;
    vlc_value_t val;

    switch( i_query )
    {
        case INPUT_GET_POSITION:
            pf = va_arg( args, double * );
            *pf = var_GetFloat( p_input, ""position"" );
            return VLC_SUCCESS;

        case INPUT_SET_POSITION:
            f = va_arg( args, double );
            return var_SetFloat( p_input, ""position"", f );

        case INPUT_GET_LENGTH:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""length"" );
            return VLC_SUCCESS;

        case INPUT_GET_TIME:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""time"" );
            return VLC_SUCCESS;

        case INPUT_SET_TIME:
            i_64 = va_arg( args, int64_t...",1,,66,4,,void
25897,BLOCK,-1,,"{
        case INPUT_GET_POSITION:
            pf = va_arg( args, double * );
            *pf = var_GetFloat( p_input, ""position"" );
            return VLC_SUCCESS;

        case INPUT_SET_POSITION:
            f = va_arg( args, double );
            return var_SetFloat( p_input, ""position"", f );

        case INPUT_GET_LENGTH:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""length"" );
            return VLC_SUCCESS;

        case INPUT_GET_TIME:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""time"" );
            return VLC_SUCCESS;

        case INPUT_SET_TIME:
            i_64 = va_arg( args, int64_t );
            return var_SetInteger( p_input, ""time"", i_64 );

        case INPUT_GET_RATE:
            pi_int = va_arg( args, int * );
            *pi_int = INPUT_RATE_DEFAULT / var_GetFloat( p_input, ""rate"" );
            return VLC_SUCCESS;

        case INPUT_SET_RATE:
            i_int =...",5,,81,2,,void
26069,BLOCK,78,,"{
            char *psz_cat = va_arg( args, char * );
            char *psz_name = va_arg( args, char * );
            char *psz_format = va_arg( args, char * );

            char *psz_value;

            if( vasprintf( &psz_value, psz_format, args ) == -1 )
                return VLC_EGENERIC;

            int i_ret = input_item_AddInfo( priv->p_item, psz_cat, psz_name,
                                            ""%s"", psz_value );
            free( psz_value );

            if( !priv->b_preparsing && !i_ret )
                input_SendEventMetaInfo( p_input );
            return i_ret;
        }",9,,154,78,,void
26083,BLOCK,-1,,<empty>,17,,162,2,,void
26107,BLOCK,-1,,<empty>,17,,169,2,,void
26116,BLOCK,83,,"{
            info_category_t *p_cat = va_arg( args, info_category_t * );

            if( i_query == INPUT_REPLACE_INFOS )
                input_item_ReplaceInfos( priv->p_item, p_cat );
            else
                input_item_MergeInfos( priv->p_item, p_cat );

            if( !priv->b_preparsing )
                input_SendEventMetaInfo( p_input );
            return VLC_SUCCESS;
        }",9,,174,83,,void
26122,BLOCK,-1,,<empty>,17,,178,2,,void
26129,BLOCK,-1,,<empty>,17,,180,1,,void
26140,BLOCK,-1,,<empty>,17,,183,2,,void
26147,BLOCK,86,,"{
            char *psz_cat = va_arg( args, char * );
            char *psz_name = va_arg( args, char * );

            int i_ret = input_item_DelInfo( priv->p_item, psz_cat, psz_name );

            if( !priv->b_preparsing && !i_ret )
                input_SendEventMetaInfo( p_input );
            return i_ret;
        }",9,,187,86,,void
26167,BLOCK,-1,,<empty>,17,,194,2,,void
26191,BLOCK,-1,,"{
                 if( asprintf( &p_bkmk->psz_name, _(""Bookmark %i""),
                               priv->i_bookmark ) == -1 )
                     p_bkmk->psz_name = NULL;
            }",13,,203,2,,void
26206,BLOCK,-1,,<empty>,22,,206,2,,void
26216,BLOCK,-1,,<empty>,17,,210,2,,void
26226,BLOCK,-1,,"{
                vlc_seekpoint_Delete( p_bkmk );
                p_bkmk = NULL;
            }",13,,212,1,,void
26263,BLOCK,-1,,"{
                p_bkmk = vlc_seekpoint_Duplicate( p_bkmk );
                if( p_bkmk )
                {
                    vlc_seekpoint_Delete( priv->pp_bookmark[i_bkmk] );
                    priv->pp_bookmark[i_bkmk] = p_bkmk;
                }
            }",13,,228,2,,void
26270,BLOCK,-1,,"{
                    vlc_seekpoint_Delete( priv->pp_bookmark[i_bkmk] );
                    priv->pp_bookmark[i_bkmk] = p_bkmk;
                }",17,,231,2,,void
26285,BLOCK,-1,,<empty>,18,,236,1,,void
26319,BLOCK,-1,,"{
                p_bkmk = priv->pp_bookmark[i_bkmk];
                TAB_REMOVE( priv->i_bookmark, priv->pp_bookmark, p_bkmk );
                vlc_seekpoint_Delete( p_bkmk );

                vlc_mutex_unlock( &priv->p_item->lock );

                UpdateBookmarksOption( p_input );

                return VLC_SUCCESS;
            }",13,,248,2,,void
26372,BLOCK,-1,,"{
                int i;

                *pi_bkmk = priv->i_bookmark;
                *ppp_bkmk = vlc_alloc( priv->i_bookmark, sizeof(seekpoint_t *) );
                for( i = 0; i < priv->i_bookmark; i++ )
                {
                    (*ppp_bkmk)[i] =
                        vlc_seekpoint_Duplicate( input_priv(p_input)->pp_bookmark[i] );
                }

                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_SUCCESS;
            }",13,,269,2,,void
26390,BLOCK,-1,,<empty>,17,,274,1,,void
26401,BLOCK,4,,"{
                    (*ppp_bkmk)[i] =
                        vlc_seekpoint_Duplicate( input_priv(p_input)->pp_bookmark[i] );
                }",17,,275,4,,void
26424,BLOCK,-1,,"{
                *ppp_bkmk = NULL;
                *pi_bkmk = 0;

                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_EGENERIC;
            }",13,,284,1,,void
26453,BLOCK,-1,,<empty>,13,,295,1,,void
26531,BLOCK,143,,"{
            input_title_t **p_title = va_arg( args, input_title_t ** );
            int *pi_req_title_offset = va_arg( args, int * );

            vlc_mutex_lock( &priv->p_item->lock );

            int i_current_title = var_GetInteger( p_input, ""title"" );
            if ( *pi_req_title_offset < 0 ) /* return current title if -1 */
                *pi_req_title_offset = i_current_title;

            if( priv->i_title && priv->i_title > *pi_req_title_offset )
            {
                *p_title = vlc_input_title_Duplicate( priv->title[*pi_req_title_offset] );
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_SUCCESS;
            }
            else
            {
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_EGENERIC;
            }
        }",9,,321,143,,void
26552,BLOCK,-1,,<empty>,17,,329,2,,void
26568,BLOCK,-1,,"{
                *p_title = vlc_input_title_Duplicate( priv->title[*pi_req_title_offset] );
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_SUCCESS;
            }",13,,332,2,,void
26589,BLOCK,-1,,"{
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_EGENERIC;
            }",13,,338,1,,void
26601,BLOCK,146,,"{
            vlc_mutex_lock( &priv->p_item->lock );
            unsigned count = priv->i_title;
            input_title_t **array = vlc_alloc( count, sizeof (*array) );

            if( count > 0 && unlikely(array == NULL) )
            {
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_ENOMEM;
            }

            for( unsigned i = 0; i < count; i++ )
                array[i] = vlc_input_title_Duplicate( priv->title[i] );

            vlc_mutex_unlock( &priv->p_item->lock );

            *va_arg( args, input_title_t *** ) = array;
            *va_arg( args, int * ) = count;
            return VLC_SUCCESS;
        }",9,,345,146,,void
26632,BLOCK,-1,,"{
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_ENOMEM;
            }",13,,351,2,,void
26643,BLOCK,-1,,<empty>,13,,356,1,,void
26676,BLOCK,149,,"{
            seekpoint_t ***array = va_arg( args, seekpoint_t *** );
            int *pi_title_to_fetch = va_arg( args, int * );

            vlc_mutex_lock( &priv->p_item->lock );

            if ( *pi_title_to_fetch < 0 ) /* query current title if -1 */
                *pi_title_to_fetch = var_GetInteger( p_input, ""title"" );

            if( priv->i_title == 0 || priv->i_title <= *pi_title_to_fetch )
            {
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_EGENERIC;
            }

            const input_title_t *p_title = priv->title[*pi_title_to_fetch];

            /* set arg2 to the number of seekpoints we found */
            const int i_chapters = p_title->i_seekpoint;
            *pi_title_to_fetch = i_chapters;

            if ( i_chapters == 0 )
            {
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_SUCCESS;
            }

            *array = calloc( p_title->i_seekpoint, sizeof(**array)...",9,,367,149,,void
26691,BLOCK,-1,,<empty>,17,,374,2,,void
26711,BLOCK,-1,,"{
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_EGENERIC;
            }",13,,377,2,,void
26744,BLOCK,-1,,"{
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_SUCCESS;
            }",13,,389,2,,void
26770,BLOCK,-1,,"{
                vlc_mutex_unlock( &priv->p_item->lock );
                return VLC_ENOMEM;
            }",13,,396,2,,void
26781,BLOCK,-1,,<empty>,13,,400,1,,void
26791,BLOCK,4,,"{
                (*array)[i] = vlc_seekpoint_Duplicate( p_title->seekpoint[i] );
            }",13,,401,4,,void
26814,BLOCK,152,,"{
            enum slave_type type =  (enum slave_type) va_arg( args, enum slave_type );
            psz = va_arg( args, char * );
            b_bool = va_arg( args, int );
            bool b_notify = va_arg( args, int );
            bool b_check_ext = va_arg( args, int );

            if( !psz || ( type != SLAVE_TYPE_SPU && type != SLAVE_TYPE_AUDIO ) )
                return VLC_EGENERIC;
            if( b_check_ext && type == SLAVE_TYPE_SPU &&
                !subtitles_Filter( psz ) )
                return VLC_EGENERIC;

            input_item_slave_t *p_slave =
                input_item_slave_New( psz, type, SLAVE_PRIORITY_USER );
            if( !p_slave )
                return VLC_ENOMEM;
            p_slave->b_forced = b_bool;

            val.p_address = p_slave;
            input_ControlPush( p_input, INPUT_CONTROL_ADD_SLAVE, &val );
            if( b_notify )
            {
                vout_thread_t *p_vout = input_GetVout( p_input );
                if( p_vout )
   ...",9,,411,152,,void
26836,BLOCK,-1,,<empty>,17,,419,2,,void
26849,BLOCK,-1,,<empty>,17,,422,2,,void
26862,BLOCK,-1,,<empty>,17,,427,2,,void
26882,BLOCK,-1,,"{
                vout_thread_t *p_vout = input_GetVout( p_input );
                if( p_vout )
                {
                    switch( type )
                    {
                        case SLAVE_TYPE_AUDIO:
                            vout_OSDMessage(p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"",
                                            vlc_gettext(""Audio track added""));
                            break;
                        case SLAVE_TYPE_SPU:
                            vout_OSDMessage(p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"",
                                            vlc_gettext(""Subtitle track added""));
                            break;
                    }
                    vlc_object_release( (vlc_object_t *)p_vout );
                }
            }",13,,433,2,,void
26890,BLOCK,-1,,"{
                    switch( type )
                    {
                        case SLAVE_TYPE_AUDIO:
                            vout_OSDMessage(p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"",
                                            vlc_gettext(""Audio track added""));
                            break;
                        case SLAVE_TYPE_SPU:
                            vout_OSDMessage(p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"",
                                            vlc_gettext(""Subtitle track added""));
                            break;
                    }
                    vlc_object_release( (vlc_object_t *)p_vout );
                }",17,,436,2,,void
26893,BLOCK,-1,,"{
                        case SLAVE_TYPE_AUDIO:
                            vout_OSDMessage(p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"",
                                            vlc_gettext(""Audio track added""));
                            break;
                        case SLAVE_TYPE_SPU:
                            vout_OSDMessage(p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"",
                                            vlc_gettext(""Subtitle track added""));
                            break;
                    }",21,,438,2,,void
26920,BLOCK,155,,"{
            input_attachment_t ***ppp_attachment = va_arg( args, input_attachment_t *** );
            int *pi_attachment = va_arg( args, int * );

            vlc_mutex_lock( &priv->p_item->lock );
            if( priv->i_attachment <= 0 )
            {
                vlc_mutex_unlock( &priv->p_item->lock );
                *ppp_attachment = NULL;
                *pi_attachment = 0;
                return VLC_EGENERIC;
            }
            *pi_attachment = priv->i_attachment;
            *ppp_attachment = vlc_alloc( priv->i_attachment, sizeof(input_attachment_t*));
            for( int i = 0; i < priv->i_attachment; i++ )
                (*ppp_attachment)[i] = vlc_input_attachment_Duplicate( priv->attachment[i] );

            vlc_mutex_unlock( &priv->p_item->lock );
            return VLC_SUCCESS;
        }",9,,455,155,,void
26936,BLOCK,-1,,"{
                vlc_mutex_unlock( &priv->p_item->lock );
                *ppp_attachment = NULL;
                *pi_attachment = 0;
                return VLC_EGENERIC;
            }",13,,461,2,,void
26970,BLOCK,-1,,<empty>,13,,469,1,,void
27004,BLOCK,158,,"{
            input_attachment_t **pp_attachment = va_arg( args, input_attachment_t ** );
            const char *psz_name = va_arg( args, const char * );

            vlc_mutex_lock( &priv->p_item->lock );
            for( int i = 0; i < priv->i_attachment; i++ )
            {
                if( !strcmp( priv->attachment[i]->psz_name, psz_name ) )
                {
                    *pp_attachment = vlc_input_attachment_Duplicate(priv->attachment[i] );
                    vlc_mutex_unlock( &priv->p_item->lock );
                    return VLC_SUCCESS;
                }
            }
            *pp_attachment = NULL;
            vlc_mutex_unlock( &priv->p_item->lock );
            return VLC_EGENERIC;
        }",9,,477,158,,void
27015,BLOCK,-1,,<empty>,13,,482,1,,void
27027,BLOCK,4,,"{
                if( !strcmp( priv->attachment[i]->psz_name, psz_name ) )
                {
                    *pp_attachment = vlc_input_attachment_Duplicate(priv->attachment[i] );
                    vlc_mutex_unlock( &priv->p_item->lock );
                    return VLC_SUCCESS;
                }
            }",13,,483,4,,void
27039,BLOCK,-1,,"{
                    *pp_attachment = vlc_input_attachment_Duplicate(priv->attachment[i] );
                    vlc_mutex_unlock( &priv->p_item->lock );
                    return VLC_SUCCESS;
                }",17,,485,2,,void
27105,BLOCK,178,,"{
            vlc_viewpoint_t *p_viewpoint = malloc( sizeof(*p_viewpoint) );
            if( unlikely(p_viewpoint == NULL) )
                return VLC_ENOMEM;
            val.p_address = p_viewpoint;
            *p_viewpoint = *va_arg( args, const vlc_viewpoint_t* );
            if ( i_query == INPUT_SET_INITIAL_VIEWPOINT )
                input_ControlPush( p_input, INPUT_CONTROL_SET_INITIAL_VIEWPOINT,
                                   &val );
            else if ( va_arg( args, int ) )
                input_ControlPush( p_input, INPUT_CONTROL_SET_VIEWPOINT, &val );
            else
                input_ControlPush( p_input, INPUT_CONTROL_UPDATE_VIEWPOINT, &val );
            return VLC_SUCCESS;
        }",9,,513,178,,void
27118,BLOCK,-1,,<empty>,17,,516,2,,void
27131,BLOCK,-1,,<empty>,17,,520,2,,void
27138,BLOCK,-1,,<empty>,18,,522,1,,void
27141,BLOCK,-1,,<empty>,17,,523,2,,void
27148,BLOCK,-1,,<empty>,17,,525,1,,void
27158,BLOCK,181,,"{
            audio_output_t *p_aout = input_resource_HoldAout( priv->p_resource );
            if( !p_aout )
                return VLC_EGENERIC;

            audio_output_t **pp_aout = va_arg( args, audio_output_t** );
            *pp_aout = p_aout;
            return VLC_SUCCESS;
        }",9,,530,181,,void
27169,BLOCK,-1,,<empty>,17,,533,2,,void
27181,BLOCK,184,,"{
            vout_thread_t ***ppp_vout = va_arg( args, vout_thread_t*** );
            size_t *pi_vout = va_arg( args, size_t * );

            input_resource_HoldVouts( priv->p_resource, ppp_vout, pi_vout );
            if( *pi_vout <= 0 )
                return VLC_EGENERIC;
            return VLC_SUCCESS;
        }",9,,541,184,,void
27195,BLOCK,-1,,<empty>,17,,547,2,,void
27202,BLOCK,187,,"{
            const int i_id = va_arg( args, int );
            vlc_object_t **pp_decoder = va_arg( args, vlc_object_t ** );
            vout_thread_t **pp_vout = va_arg( args, vout_thread_t ** );
            audio_output_t **pp_aout = va_arg( args, audio_output_t ** );

            return es_out_Control( priv->p_es_out_display,
                                   ES_OUT_GET_ES_OBJECTS_BY_ID, i_id,
                                   pp_decoder, pp_vout, pp_aout );
        }",9,,552,187,,void
27219,BLOCK,190,,"{
            mtime_t *pi_system = va_arg( args, mtime_t * );
            mtime_t *pi_delay  = va_arg( args, mtime_t * );
            return es_out_ControlGetPcrSystem( priv->p_es_out_display, pi_system, pi_delay );
        }",9,,564,190,,void
27231,BLOCK,193,,"{
            bool b_absolute = va_arg( args, int );
            mtime_t i_system = va_arg( args, mtime_t );
            return es_out_ControlModifyPcrSystem( priv->p_es_out_display, b_absolute, i_system );
        }",9,,571,193,,void
27250,BLOCK,196,,"{
            vlc_renderer_item_t* p_item = va_arg( args, vlc_renderer_item_t* );
            val.p_address = p_item ? vlc_renderer_item_hold( p_item ) : NULL;
            input_ControlPush( p_input, INPUT_CONTROL_SET_RENDERER, &val );
            return VLC_SUCCESS;
        }",9,,578,196,,void
27280,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    input_item_t* item = priv->p_item;
    struct vlc_memstream vstr;

    vlc_memstream_open( &vstr );
    vlc_memstream_puts( &vstr, ""bookmarks="" );

    vlc_mutex_lock( &item->lock );
    var_Change( p_input, ""bookmark"", VLC_VAR_CLEARCHOICES, 0, 0 );

    for( int i = 0; i < priv->i_bookmark; i++ )
    {
        seekpoint_t const* sp = priv->pp_bookmark[i];

        /* Add bookmark to choice-list */
        var_Change( p_input, ""bookmark"", VLC_VAR_ADDCHOICE,
                    &(vlc_value_t){ .i_int = i },
                    &(vlc_value_t){ .psz_string = sp->psz_name } );

        /* Append bookmark to option-buffer */
        /* TODO: escape inappropriate values */
        vlc_memstream_printf( &vstr, ""%s{name=%s,time=%.3f}"",
            i > 0 ? "","" : """", sp->psz_name, ( 1. * sp->i_time_offset ) / CLOCK_FREQ );
    }

    if( vlc_memstream_close( &vstr ) )
    {
        vlc_mutex_unlock( &item->lock );
        return;
 ...",1,,592,2,,void
27312,BLOCK,-1,,<empty>,5,,603,1,,void
27324,BLOCK,4,,"{
        seekpoint_t const* sp = priv->pp_bookmark[i];

        /* Add bookmark to choice-list */
        var_Change( p_input, ""bookmark"", VLC_VAR_ADDCHOICE,
                    &(vlc_value_t){ .i_int = i },
                    &(vlc_value_t){ .psz_string = sp->psz_name } );

        /* Append bookmark to option-buffer */
        /* TODO: escape inappropriate values */
        vlc_memstream_printf( &vstr, ""%s{name=%s,time=%.3f}"",
            i > 0 ? "","" : """", sp->psz_name, ( 1. * sp->i_time_offset ) / CLOCK_FREQ );
    }",5,,604,4,,void
27341,BLOCK,1,,<empty>,37,,609,1,,void
27349,BLOCK,1,,<empty>,37,,610,1,,void
27379,BLOCK,-1,,"{
        vlc_mutex_unlock( &item->lock );
        return;
    }",5,,619,2,,void
27408,BLOCK,-1,,<empty>,5,,634,1,,void
27416,BLOCK,4,,"{
        if( strncmp( *option, ""bookmarks="", 10 ) )
            ++option;
        else
        {
            free( *option );
            /* It might be tempting to optimize the below by overwriting
             * *option with the value of the last element, however; we want to
             * preserve the order of the other options (as behavior might
             * depend on it) */
            memmove( option, option + 1, ( --end - option ) * sizeof *end );
        }
    }",5,,635,4,,void
27423,BLOCK,-1,,<empty>,13,,637,2,,void
27427,BLOCK,-1,,"{
            free( *option );
            /* It might be tempting to optimize the below by overwriting
             * *option with the value of the last element, however; we want to
             * preserve the order of the other options (as behavior might
             * depend on it) */
            memmove( option, option + 1, ( --end - option ) * sizeof *end );
        }",9,,639,1,,void
27448,BLOCK,-1,,"{
        *end = vstr.ptr;
        item->i_options = end - orig_beg + 1;
        vlc_mutex_unlock( &item->lock );
    }",5,,650,2,,void
27470,BLOCK,-1,,"{
        vlc_mutex_unlock( &item->lock );
        input_item_AddOption( item, vstr.ptr, VLC_INPUT_OPTION_UNIQUE );
        free( vstr.ptr );
    }",5,,656,1,,void
27536,BLOCK,-1,,<empty>,1,,1,1,,ANY
27556,BLOCK,-1,,<empty>,,,,4,,<empty>
27590,BLOCK,-1,,<empty>,,,,1,,<empty>
27593,BLOCK,1,,<empty>,,,,1,,void
27603,BLOCK,-1,,"{
    p_dec->b_frame_drop_allowed = true;
    p_dec->i_extra_picture_buffers = 0;

    p_dec->pf_decode = NULL;
    p_dec->pf_get_cc = NULL;
    p_dec->pf_packetize = NULL;
    p_dec->pf_flush = NULL;

    es_format_Copy( &p_dec->fmt_in, p_fmt );
    es_format_Init( &p_dec->fmt_out, p_fmt->i_cat, 0 );

    /* Find a suitable decoder/packetizer module */
    if( !b_packetizer )
    {
        static const char caps[ES_CATEGORY_COUNT][16] = {
            [VIDEO_ES] = ""video decoder"",
            [AUDIO_ES] = ""audio decoder"",
            [SPU_ES] = ""spu decoder"",
        };
        p_dec->p_module = module_need( p_dec, caps[p_dec->fmt_in.i_cat],
                                       ""$codec"", false );
    }
    else
        p_dec->p_module = module_need( p_dec, ""packetizer"", ""$packetizer"", false );

    if( !p_dec->p_module )
    {
        es_format_Clean( &p_dec->fmt_in );
        return -1;
    }
    else
        return 0;
}",1,,159,4,,void
27652,BLOCK,-1,,"{
        static const char caps[ES_CATEGORY_COUNT][16] = {
            [VIDEO_ES] = ""video decoder"",
            [AUDIO_ES] = ""audio decoder"",
            [SPU_ES] = ""spu decoder"",
        };
        p_dec->p_module = module_need( p_dec, caps[p_dec->fmt_in.i_cat],
                                       ""$codec"", false );
    }",5,,173,2,,void
27657,BLOCK,1,,<empty>,13,,175,1,,void
27661,BLOCK,2,,<empty>,13,,176,2,,void
27665,BLOCK,3,,<empty>,13,,177,3,,void
27685,BLOCK,-1,,<empty>,9,,183,1,,void
27700,BLOCK,-1,,"{
        es_format_Clean( &p_dec->fmt_in );
        return -1;
    }",5,,186,2,,void
27710,BLOCK,-1,,<empty>,9,,191,1,,void
27717,BLOCK,-1,,"{
    if( p_dec->p_module )
    {
        module_unneed( p_dec, p_dec->p_module );
        p_dec->p_module = NULL;
    }

    if( p_dec->p_description )
    {
        vlc_meta_Delete( p_dec->p_description );
        p_dec->p_description = NULL;
    }

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );
}",1,,198,2,,void
27722,BLOCK,-1,,"{
        module_unneed( p_dec, p_dec->p_module );
        p_dec->p_module = NULL;
    }",5,,200,2,,void
27737,BLOCK,-1,,"{
        vlc_meta_Delete( p_dec->p_description );
        p_dec->p_description = NULL;
    }",5,,206,2,,void
27764,BLOCK,-1,,"{
    /* Copy p_fmt since it can be destroyed by UnloadDecoder */
    es_format_t fmt_in;
    if( es_format_Copy( &fmt_in, p_fmt ) != VLC_SUCCESS )
    {
        p_dec->p_owner->error = true;
        return VLC_EGENERIC;
    }

    /* Restart the decoder module */
    UnloadDecoder( p_dec );
    p_dec->p_owner->error = false;

    if( reload == RELOAD_DECODER_AOUT )
    {
        decoder_owner_sys_t *p_owner = p_dec->p_owner;
        assert( p_owner->fmt.i_cat == AUDIO_ES );
        audio_output_t *p_aout = p_owner->p_aout;

        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        if( p_aout )
        {
            aout_DecDelete( p_aout );
            input_resource_PutAout( p_owner->p_resource, p_aout );
        }
    }

    if( LoadDecoder( p_dec, b_packetizer, &fmt_in ) )
    {
        p_dec->p_owner->error = true;
        es_format_Clean( &fmt_in );
        return VLC_EGENERIC;
    }
    es_format_Clean( &fmt_...",1,,217,5,,void
27773,BLOCK,-1,,"{
        p_dec->p_owner->error = true;
        return VLC_EGENERIC;
    }",5,,221,2,,void
27796,BLOCK,-1,,"{
        decoder_owner_sys_t *p_owner = p_dec->p_owner;
        assert( p_owner->fmt.i_cat == AUDIO_ES );
        audio_output_t *p_aout = p_owner->p_aout;

        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        if( p_aout )
        {
            aout_DecDelete( p_aout );
            input_resource_PutAout( p_owner->p_resource, p_aout );
        }
    }",5,,231,2,,void
27834,BLOCK,-1,,"{
            aout_DecDelete( p_aout );
            input_resource_PutAout( p_owner->p_resource, p_aout );
        }",9,,240,2,,void
27848,BLOCK,-1,,"{
        p_dec->p_owner->error = true;
        es_format_Clean( &fmt_in );
        return VLC_EGENERIC;
    }",5,,247,2,,void
27870,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    es_format_Clean( &p_owner->fmt );
    es_format_Copy( &p_owner->fmt, &p_dec->fmt_out );

    /* Move p_description */
    if( p_dec->p_description != NULL )
    {
        if( p_owner->p_description != NULL )
            vlc_meta_Delete( p_owner->p_description );
        p_owner->p_description = p_dec->p_description;
        p_dec->p_description = NULL;
    }

    p_owner->b_fmt_description = true;
}",1,,257,2,,void
27902,BLOCK,-1,,"{
        if( p_owner->p_description != NULL )
            vlc_meta_Delete( p_owner->p_description );
        p_owner->p_description = p_dec->p_description;
        p_dec->p_description = NULL;
    }",5,,267,2,,void
27909,BLOCK,-1,,<empty>,13,,269,2,,void
27938,BLOCK,-1,,"{
    decoder_t *p_dec = p_private;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;
    video_format_t fmt;

    if (p_fmt != NULL)
    {
        fmt = *p_fmt;
        p_fmt = &fmt;
        video_format_AdjustColorSpace( &fmt );
    }

    p_vout = input_resource_RequestVout( p_owner->p_resource, p_vout, p_fmt, 1,
                                         b_recyle );
    if( p_input != NULL )
        input_SendEventVout( p_input );

    return p_vout;
}",1,,283,5,,void
27960,BLOCK,-1,,"{
        fmt = *p_fmt;
        p_fmt = &fmt;
        video_format_AdjustColorSpace( &fmt );
    }",5,,290,2,,void
27986,BLOCK,-1,,<empty>,9,,299,2,,void
27996,BLOCK,-1,,"{
    for( size_t i=0; i<AUDIO_REPLAY_GAIN_MAX; i++ )
    {
        if( a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] ||
            a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] )
            return true;
    }
    return false;
}",1,,306,3,,void
27998,BLOCK,-1,,<empty>,5,,307,1,,void
28008,BLOCK,4,,"{
        if( a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] ||
            a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] )
            return true;
    }",5,,308,4,,void
28057,BLOCK,-1,,<empty>,13,,313,2,,void
28066,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_aout &&
       ( !AOUT_FMTS_IDENTICAL(&p_dec->fmt_out.audio, &p_owner->fmt.audio) ||
         p_dec->fmt_out.i_codec != p_dec->fmt_out.audio.i_format ||
         p_dec->fmt_out.i_profile != p_owner->fmt.i_profile ) )
    {
        audio_output_t *p_aout = p_owner->p_aout;

        /* Parameters changed, restart the aout */
        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        aout_DecDelete( p_aout );

        input_resource_PutAout( p_owner->p_resource, p_aout );
    }

    /* Check if only replay gain has changed */
    if( aout_replaygain_changed( &p_dec->fmt_in.audio_replay_gain,
                                 &p_owner->fmt.audio_replay_gain ) )
    {
        p_dec->fmt_out.audio_replay_gain = p_dec->fmt_in.audio_replay_gain;
        if( p_owner->p_aout )
        {
            p_owner->fmt.audio_replay_gain = p_dec->fmt_in.audio_repla...",1,,319,2,,void
28118,BLOCK,-1,,"{
        audio_output_t *p_aout = p_owner->p_aout;

        /* Parameters changed, restart the aout */
        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        aout_DecDelete( p_aout );

        input_resource_PutAout( p_owner->p_resource, p_aout );
    }",5,,326,2,,void
28161,BLOCK,-1,,"{
        p_dec->fmt_out.audio_replay_gain = p_dec->fmt_in.audio_replay_gain;
        if( p_owner->p_aout )
        {
            p_owner->fmt.audio_replay_gain = p_dec->fmt_in.audio_replay_gain;
            var_TriggerCallback( p_owner->p_aout, ""audio-replay-gain-mode"" );
        }
    }",5,,341,2,,void
28177,BLOCK,-1,,"{
            p_owner->fmt.audio_replay_gain = p_dec->fmt_in.audio_replay_gain;
            var_TriggerCallback( p_owner->p_aout, ""audio-replay-gain-mode"" );
        }",9,,344,2,,void
28200,BLOCK,-1,,"{
        p_dec->fmt_out.audio.i_format = p_dec->fmt_out.i_codec;

        audio_sample_format_t format = p_dec->fmt_out.audio;
        aout_FormatPrepare( &format );

        const int i_force_dolby = var_InheritInteger( p_dec, ""force-dolby-surround"" );
        if( i_force_dolby &&
            format.i_physical_channels == (AOUT_CHAN_LEFT|AOUT_CHAN_RIGHT) )
        {
            if( i_force_dolby == 1 )
                format.i_chan_mode |= AOUT_CHANMODE_DOLBYSTEREO;
            else /* i_force_dolby == 2 */
                format.i_chan_mode &= ~AOUT_CHANMODE_DOLBYSTEREO;
        }

        aout_request_vout_t request_vout = {
            .pf_request_vout = aout_request_vout,
            .p_private = p_dec,
        };
        audio_output_t *p_aout;

        p_aout = input_resource_GetAout( p_owner->p_resource );
        if( p_aout )
        {
            /* TODO: 3.0 HACK: we need to put i_profile inside audio_format_t
             * for 4.0 */
            if( p_dec->fmt_out.i_co...",5,,351,2,,void
28241,BLOCK,-1,,"{
            if( i_force_dolby == 1 )
                format.i_chan_mode |= AOUT_CHANMODE_DOLBYSTEREO;
            else /* i_force_dolby == 2 */
                format.i_chan_mode &= ~AOUT_CHANMODE_DOLBYSTEREO;
        }",9,,360,2,,void
28246,BLOCK,-1,,<empty>,17,,362,2,,void
28253,BLOCK,-1,,<empty>,17,,364,1,,void
28264,BLOCK,1,,<empty>,13,,368,1,,void
28268,BLOCK,2,,<empty>,13,,369,2,,void
28281,BLOCK,-1,,"{
            /* TODO: 3.0 HACK: we need to put i_profile inside audio_format_t
             * for 4.0 */
            if( p_dec->fmt_out.i_codec == VLC_CODEC_DTS )
                var_SetBool( p_aout, ""dtshd"", p_dec->fmt_out.i_profile > 0 );

            if( aout_DecNew( p_aout, &format,
                             &p_dec->fmt_out.audio_replay_gain,
                             &request_vout ) )
            {
                input_resource_PutAout( p_owner->p_resource, p_aout );
                p_aout = NULL;
            }
        }",9,,375,2,,void
28290,BLOCK,-1,,<empty>,17,,379,2,,void
28314,BLOCK,-1,,"{
                input_resource_PutAout( p_owner->p_resource, p_aout );
                p_aout = NULL;
            }",13,,384,2,,void
28353,BLOCK,-1,,<empty>,13,,398,2,,void
28362,BLOCK,-1,,"{
            msg_Err( p_dec, ""failed to create audio output"" );
            return -1;
        }",9,,401,2,,void
28405,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_vout == NULL
     || p_dec->fmt_out.video.i_width != p_owner->fmt.video.i_width
     || p_dec->fmt_out.video.i_height != p_owner->fmt.video.i_height
     || p_dec->fmt_out.video.i_visible_width != p_owner->fmt.video.i_visible_width
     || p_dec->fmt_out.video.i_visible_height != p_owner->fmt.video.i_visible_height
     || p_dec->fmt_out.video.i_x_offset != p_owner->fmt.video.i_x_offset
     || p_dec->fmt_out.video.i_y_offset != p_owner->fmt.video.i_y_offset
     || p_dec->fmt_out.i_codec != p_owner->fmt.video.i_chroma
     || (int64_t)p_dec->fmt_out.video.i_sar_num * p_owner->fmt.video.i_sar_den !=
        (int64_t)p_dec->fmt_out.video.i_sar_den * p_owner->fmt.video.i_sar_num ||
        p_dec->fmt_out.video.orientation != p_owner->fmt.video.orientation ||
        p_dec->fmt_out.video.multiview_mode != p_owner->fmt.video.multiview_mode )
    {
        vout_thread_t *p_vout;

        if( !p_dec->fmt_out.video.i_...",1,,415,2,,void
28596,BLOCK,-1,,"{
        vout_thread_t *p_vout;

        if( !p_dec->fmt_out.video.i_width ||
            !p_dec->fmt_out.video.i_height ||
            p_dec->fmt_out.video.i_width < p_dec->fmt_out.video.i_visible_width ||
            p_dec->fmt_out.video.i_height < p_dec->fmt_out.video.i_visible_height )
        {
            /* Can't create a new vout without display size */
            return -1;
        }

        video_format_t fmt = p_dec->fmt_out.video;
        fmt.i_chroma = p_dec->fmt_out.i_codec;

        if( vlc_fourcc_IsYUV( fmt.i_chroma ) )
        {
            const vlc_chroma_description_t *dsc = vlc_fourcc_GetChromaDescription( fmt.i_chroma );
            for( unsigned int i = 0; dsc && i < dsc->plane_count; i++ )
            {
                while( fmt.i_width % dsc->p[i].w.den )
                    fmt.i_width++;
                while( fmt.i_height % dsc->p[i].h.den )
                    fmt.i_height++;
            }
        }

        if( !fmt.i_visible_width || !fmt.i_visible...",5,,430,2,,void
28648,BLOCK,-1,,"{
            /* Can't create a new vout without display size */
            return -1;
        }",9,,437,2,,void
28674,BLOCK,-1,,"{
            const vlc_chroma_description_t *dsc = vlc_fourcc_GetChromaDescription( fmt.i_chroma );
            for( unsigned int i = 0; dsc && i < dsc->plane_count; i++ )
            {
                while( fmt.i_width % dsc->p[i].w.den )
                    fmt.i_width++;
                while( fmt.i_height % dsc->p[i].h.den )
                    fmt.i_height++;
            }
        }",9,,446,2,,void
28683,BLOCK,-1,,<empty>,13,,448,1,,void
28697,BLOCK,4,,"{
                while( fmt.i_width % dsc->p[i].w.den )
                    fmt.i_width++;
                while( fmt.i_height % dsc->p[i].h.den )
                    fmt.i_height++;
            }",13,,449,4,,void
28744,BLOCK,-1,,"{
            if( p_dec->fmt_in.video.i_visible_width &&
                p_dec->fmt_in.video.i_visible_height )
            {
                fmt.i_visible_width  = p_dec->fmt_in.video.i_visible_width;
                fmt.i_visible_height = p_dec->fmt_in.video.i_visible_height;
                fmt.i_x_offset       = p_dec->fmt_in.video.i_x_offset;
                fmt.i_y_offset       = p_dec->fmt_in.video.i_y_offset;
            }
            else
            {
                fmt.i_visible_width  = fmt.i_width;
                fmt.i_visible_height = fmt.i_height;
                fmt.i_x_offset       = 0;
                fmt.i_y_offset       = 0;
            }
        }",9,,458,2,,void
28761,BLOCK,-1,,"{
                fmt.i_visible_width  = p_dec->fmt_in.video.i_visible_width;
                fmt.i_visible_height = p_dec->fmt_in.video.i_visible_height;
                fmt.i_x_offset       = p_dec->fmt_in.video.i_x_offset;
                fmt.i_y_offset       = p_dec->fmt_in.video.i_y_offset;
            }",13,,461,2,,void
28807,BLOCK,-1,,"{
                fmt.i_visible_width  = fmt.i_width;
                fmt.i_visible_height = fmt.i_height;
                fmt.i_x_offset       = 0;
                fmt.i_y_offset       = 0;
            }",13,,468,1,,void
28842,BLOCK,-1,,"{
            fmt.i_visible_height = 1080;
            if( !(fmt.i_sar_num % 136))
            {
                fmt.i_sar_num *= 135;
                fmt.i_sar_den *= 136;
            }
            msg_Warn( p_dec, ""Fixing broken HDTV stream (display_height=1088)"");
        }",9,,478,2,,void
28855,BLOCK,-1,,"{
                fmt.i_sar_num *= 135;
                fmt.i_sar_den *= 136;
            }",13,,481,2,,void
28879,BLOCK,-1,,"{
            fmt.i_sar_num = 1;
            fmt.i_sar_den = 1;
        }",9,,489,2,,void
28936,BLOCK,-1,,"{
        case VLC_CODEC_HEVC:
        case VLC_CODEC_H264:
        case VLC_CODEC_DIRAC: /* FIXME valid ? */
            dpb_size = 18;
            break;
        case VLC_CODEC_AV1:
            dpb_size = 10;
            break;
        case VLC_CODEC_VP5:
        case VLC_CODEC_VP6:
        case VLC_CODEC_VP6F:
        case VLC_CODEC_VP8:
            dpb_size = 3;
            break;
        default:
            dpb_size = 2;
            break;
        }",9,,507,2,,void
29023,BLOCK,-1,,<empty>,13,,539,2,,void
29032,BLOCK,-1,,"{
            msg_Err( p_dec, ""failed to create video output"" );
            return -1;
        }",9,,541,2,,void
29105,BLOCK,-1,,"{
        /* the format has changed but we don't need a new vout */
        vlc_mutex_lock( &p_owner->lock );
        DecoderUpdateFormatLocked( p_dec );
        vlc_mutex_unlock( &p_owner->lock );
    }",5,,554,2,,void
29124,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    assert( p_owner->p_vout );

    return vout_GetPicture( p_owner->p_vout );
}",1,,564,2,,void
29145,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = NULL;
    subpicture_t *p_subpic;
    int i_attempts = 30;

    while( i_attempts-- )
    {
        if( p_owner->error )
            break;

        p_vout = input_resource_HoldVout( p_owner->p_resource );
        if( p_vout )
            break;

        msleep( DECODER_SPU_VOUT_WAIT_DURATION );
    }

    if( !p_vout )
    {
        msg_Warn( p_dec, ""no vout found, dropping subpicture"" );
        return NULL;
    }

    if( p_owner->p_spu_vout != p_vout )
    {
        p_owner->i_spu_channel = vout_RegisterSubpictureChannel( p_vout );
        p_owner->i_spu_order = 0;
        p_owner->p_spu_vout = p_vout;
    }

    p_subpic = subpicture_New( p_updater );
    if( p_subpic )
    {
        p_subpic->i_channel = p_owner->i_spu_channel;
        p_subpic->i_order = p_owner->i_spu_order++;
        p_subpic->b_subtitle = true;
    }

    vlc_object_release( p_vout );

    return p_subpic;
}",1,,573,3,,void
29164,BLOCK,-1,,"{
        if( p_owner->error )
            break;

        p_vout = input_resource_HoldVout( p_owner->p_resource );
        if( p_vout )
            break;

        msleep( DECODER_SPU_VOUT_WAIT_DURATION );
    }",5,,580,2,,void
29169,BLOCK,-1,,<empty>,13,,582,2,,void
29179,BLOCK,-1,,<empty>,13,,586,2,,void
29183,BLOCK,1,,<empty>,,,,1,,void
29192,BLOCK,-1,,"{
        msg_Warn( p_dec, ""no vout found, dropping subpicture"" );
        return NULL;
    }",5,,592,2,,void
29204,BLOCK,-1,,"{
        p_owner->i_spu_channel = vout_RegisterSubpictureChannel( p_vout );
        p_owner->i_spu_order = 0;
        p_owner->p_spu_vout = p_vout;
    }",5,,598,2,,void
29227,BLOCK,-1,,"{
        p_subpic->i_channel = p_owner->i_spu_channel;
        p_subpic->i_order = p_owner->i_spu_order++;
        p_subpic->b_subtitle = true;
    }",5,,606,2,,void
29258,BLOCK,-1,,"{
    input_thread_t *p_input = p_dec->p_owner->p_input;

    if( unlikely(p_input == NULL) )
        return VLC_ENOOBJ;
    return input_Control( p_input, INPUT_GET_ATTACHMENTS,
                          ppp_attachment, pi_attachment );
}",1,,620,4,,void
29272,BLOCK,-1,,<empty>,9,,624,2,,void
29286,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->b_waiting || p_owner->paused )
        i_ts = VLC_TS_INVALID;
    vlc_mutex_unlock( &p_owner->lock );

    if( !p_owner->p_clock || i_ts <= VLC_TS_INVALID )
        return i_ts;

    if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_owner->p_clock, NULL, &i_ts, NULL, INT64_MAX ) ) {
        msg_Err(p_dec, ""Could not get display date for timestamp %""PRId64"""", i_ts);
        return VLC_TS_INVALID;
    }

    return i_ts;
}",1,,630,3,,void
29306,BLOCK,-1,,<empty>,9,,635,2,,void
29324,BLOCK,-1,,<empty>,9,,639,2,,void
29339,BLOCK,-1,,"{
        msg_Err(p_dec, ""Could not get display date for timestamp %""PRId64"""", i_ts);
        return VLC_TS_INVALID;
    }",102,,641,2,,void
29349,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !p_owner->p_clock )
        return INPUT_RATE_DEFAULT;
    return input_clock_GetRate( p_owner->p_clock );
}",1,,650,2,,void
29361,BLOCK,-1,,<empty>,9,,654,2,,void
29374,BLOCK,-1,,"{
    assert( dec->fmt_out.audio.i_frame_length > 0
         && dec->fmt_out.audio.i_bytes_per_frame  > 0 );

    size_t length = samples * dec->fmt_out.audio.i_bytes_per_frame
                            / dec->fmt_out.audio.i_frame_length;
    block_t *block = block_Alloc( length );
    if( likely(block != NULL) )
    {
        block->i_nb_samples = samples;
        block->i_pts = block->i_length = 0;
    }
    return block;
}",1,,662,3,,void
29425,BLOCK,-1,,"{
        block->i_nb_samples = samples;
        block->i_pts = block->i_length = 0;
    }",5,,670,2,,void
29447,BLOCK,-1,,"{
    subpicture_t *p_subpicture = p_decoder->pf_spu_buffer_new( p_decoder, p_dyn );
    if( !p_subpicture )
        msg_Warn( p_decoder, ""can't get output subpicture"" );
    return p_subpicture;
}",1,,679,3,,void
29460,BLOCK,-1,,<empty>,9,,682,2,,void
29470,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    /* Don't override reload if it's RELOAD_DECODER_AOUT */
    int expected = RELOAD_NO_REQUEST;
    atomic_compare_exchange_strong( &p_owner->reload, &expected, RELOAD_DECODER );
}",1,,687,2,,void
29495,BLOCK,-1,,"{
    if( !p_dec->pf_get_attachments )
        return VLC_EGENERIC;

    return p_dec->pf_get_attachments( p_dec, ppp_attachment, pi_attachment );
}",1,,699,4,,void
29501,BLOCK,-1,,<empty>,9,,701,2,,void
29517,BLOCK,-1,,"{
    if( !p_dec->pf_get_display_date )
        return VLC_TS_INVALID;

    return p_dec->pf_get_display_date( p_dec, i_ts );
}",1,,708,3,,void
29523,BLOCK,-1,,<empty>,9,,710,2,,void
29537,BLOCK,-1,,"{
    if( !p_dec->pf_get_display_rate )
        return INPUT_RATE_DEFAULT;

    return p_dec->pf_get_display_rate( p_dec );
}",1,,717,2,,void
29543,BLOCK,-1,,<empty>,9,,719,2,,void
29557,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->p_vout != NULL )
        vout_Cancel( p_owner->p_vout, b_abort );
    vlc_mutex_unlock( &p_owner->lock );
}",1,,725,3,,void
29575,BLOCK,-1,,<empty>,9,,730,2,,void
29590,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    for( ;; )
    {
        if( !p_owner->b_waiting || !p_owner->b_has_data )
            break;
        vlc_cond_wait( &p_owner->wait_request, &p_owner->lock );
    }
}",1,,735,2,,void
29603,BLOCK,-1,,<empty>,5,,740,1,,void
29604,BLOCK,4,,"{
        if( !p_owner->b_waiting || !p_owner->b_has_data )
            break;
        vlc_cond_wait( &p_owner->wait_request, &p_owner->lock );
    }",5,,741,4,,void
29615,BLOCK,-1,,<empty>,13,,743,2,,void
29631,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if (deadline - mdate() <= 0)
        return VLC_SUCCESS;

    vlc_fifo_Lock( p_owner->p_fifo );
    while( !p_owner->flushing
        && vlc_fifo_TimedWaitCond( p_owner->p_fifo, &p_owner->wait_timed,
                                   deadline ) == 0 );
    int ret = p_owner->flushing ? VLC_EGENERIC : VLC_SUCCESS;
    vlc_fifo_Unlock( p_owner->p_fifo );
    return ret;
}",1,,751,3,,void
29644,BLOCK,-1,,<empty>,9,,755,2,,void
29688,BLOCK,-1,,"{
    if( p->i_flags & BLOCK_FLAG_PREROLL )
        *pi_preroll = INT64_MAX;
    /* Check if we can use the packet for end of preroll */
    else if( (p->i_flags & BLOCK_FLAG_DISCONTINUITY) &&
             (p->i_buffer == 0 || (p->i_flags & BLOCK_FLAG_CORRUPTED)) )
        *pi_preroll = INT64_MAX;
    else if( p->i_dts > VLC_TS_INVALID )
        *pi_preroll = __MIN( *pi_preroll, p->i_dts );
    else if( p->i_pts > VLC_TS_INVALID )
        *pi_preroll = __MIN( *pi_preroll, p->i_pts );
}",1,,767,3,,void
29695,BLOCK,-1,,<empty>,9,,769,2,,void
29701,BLOCK,-1,,<empty>,10,,771,1,,void
29720,BLOCK,-1,,<empty>,9,,773,2,,void
29726,BLOCK,-1,,<empty>,10,,774,1,,void
29733,BLOCK,-1,,<empty>,9,,775,2,,void
29744,BLOCK,-1,,<empty>,10,,776,1,,void
29751,BLOCK,-1,,<empty>,9,,777,2,,void
29770,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_clock_t   *p_clock = p_owner->p_clock;

    vlc_assert_locked( &p_owner->lock );

    const mtime_t i_es_delay = p_owner->i_ts_delay;

    if( !p_clock )
        return;

    const bool b_ephemere = pi_ts1 && *pi_ts0 == *pi_ts1;
    int i_rate;

    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 += i_es_delay;
        if( pi_ts1 && *pi_ts1 > VLC_TS_INVALID )
            *pi_ts1 += i_es_delay;
        if( i_ts_bound != INT64_MAX )
            i_ts_bound += i_es_delay;
        if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_clock, &i_rate, pi_ts0, pi_ts1, i_ts_bound ) ) {
            const char *psz_name = module_get_name( p_dec->p_module, false );
            if( pi_ts1 != NULL )
                msg_Err(p_dec, ""Could not convert timestamps %""PRId64
                        "", %""PRId64"" for %s"", *pi_ts0, *pi_ts1, psz_name );
            else
                msg_Err(p_dec, ""Could not convert timestamp %""PRId64"" for %s""...",1,,782,7,,void
29797,BLOCK,-1,,<empty>,9,,791,2,,void
29815,BLOCK,-1,,"{
        *pi_ts0 += i_es_delay;
        if( pi_ts1 && *pi_ts1 > VLC_TS_INVALID )
            *pi_ts1 += i_es_delay;
        if( i_ts_bound != INT64_MAX )
            i_ts_bound += i_es_delay;
        if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_clock, &i_rate, pi_ts0, pi_ts1, i_ts_bound ) ) {
            const char *psz_name = module_get_name( p_dec->p_module, false );
            if( pi_ts1 != NULL )
                msg_Err(p_dec, ""Could not convert timestamps %""PRId64
                        "", %""PRId64"" for %s"", *pi_ts0, *pi_ts1, psz_name );
            else
                msg_Err(p_dec, ""Could not convert timestamp %""PRId64"" for %s"", *pi_ts0, psz_name );
            *pi_ts0 = VLC_TS_INVALID;
        }
    }",5,,797,2,,void
29827,BLOCK,-1,,<empty>,13,,800,2,,void
29836,BLOCK,-1,,<empty>,13,,802,2,,void
29850,BLOCK,-1,,"{
            const char *psz_name = module_get_name( p_dec->p_module, false );
            if( pi_ts1 != NULL )
                msg_Err(p_dec, ""Could not convert timestamps %""PRId64
                        "", %""PRId64"" for %s"", *pi_ts0, *pi_ts1, psz_name );
            else
                msg_Err(p_dec, ""Could not convert timestamp %""PRId64"" for %s"", *pi_ts0, psz_name );
            *pi_ts0 = VLC_TS_INVALID;
        }",104,,803,2,,void
29866,BLOCK,-1,,"{
        i_rate = input_clock_GetRate( p_clock );
    }",5,,814,1,,void
29882,BLOCK,-1,,<empty>,9,,820,2,,void
29889,BLOCK,-1,,<empty>,9,,823,2,,void
29905,BLOCK,-1,,<empty>,9,,827,2,,void
29916,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );

    p_owner->cc.desc = *p_desc;

    /* Fanout data to all decoders. We do not know if es_out
       selected 608 or 708. */
    uint64_t i_bitmap = p_owner->cc.desc.i_608_channels |
                        p_owner->cc.desc.i_708_channels;

    for( int i=0; i_bitmap > 0; i_bitmap >>= 1, i++ )
    {
        decoder_t *p_ccdec = p_owner->cc.pp_decoder[i];
        if( !p_ccdec )
            continue;

        if( i_bitmap > 1 )
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, block_Duplicate(p_cc) );
        }
        else
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, p_cc );
            p_cc = NULL; /* was last dec */
        }
    }

    vlc_mutex_unlock( &p_owner->lock );

    if( p_cc ) /* can have bitmap set but no created decs */
        block_Release( p_cc );
}",1,,929,4,,void
29955,BLOCK,-1,,<empty>,5,,941,1,,void
29969,BLOCK,4,,"{
        decoder_t *p_ccdec = p_owner->cc.pp_decoder[i];
        if( !p_ccdec )
            continue;

        if( i_bitmap > 1 )
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, block_Duplicate(p_cc) );
        }
        else
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, p_cc );
            p_cc = NULL; /* was last dec */
        }
    }",5,,942,4,,void
29983,BLOCK,-1,,<empty>,13,,945,2,,void
29989,BLOCK,-1,,"{
            block_FifoPut( p_ccdec->p_owner->p_fifo, block_Duplicate(p_cc) );
        }",9,,948,2,,void
29999,BLOCK,-1,,"{
            block_FifoPut( p_ccdec->p_owner->p_fifo, p_cc );
            p_cc = NULL; /* was last dec */
        }",9,,952,1,,void
30017,BLOCK,-1,,<empty>,9,,961,2,,void
30025,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    block_t *p_cc;
    decoder_cc_desc_t desc;

    /* Do not try retreiving CC if not wanted (sout) or cannot be retreived */
    if( !p_owner->cc.b_supported )
        return;

    assert( p_dec_cc->pf_get_cc != NULL );

    p_cc = p_dec_cc->pf_get_cc( p_dec_cc, &desc );
    if( !p_cc )
        return;
    DecoderPlayCc( p_dec, p_cc, &desc );
}",1,,965,3,,void
30041,BLOCK,-1,,<empty>,9,,972,2,,void
30061,BLOCK,-1,,<empty>,9,,978,2,,void
30074,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_videodec->p_owner;

    if( unlikely( p_cc != NULL ) )
    {
        if( p_owner->cc.b_supported &&
           ( !p_owner->p_packetizer || !p_owner->p_packetizer->pf_get_cc ) )
            DecoderPlayCc( p_videodec, p_cc, p_desc );
        else
            block_Release( p_cc );
    }
    return 0;
}",1,,984,4,,void
30086,BLOCK,-1,,"{
        if( p_owner->cc.b_supported &&
           ( !p_owner->p_packetizer || !p_owner->p_packetizer->pf_get_cc ) )
            DecoderPlayCc( p_videodec, p_cc, p_desc );
        else
            block_Release( p_cc );
    }",5,,988,2,,void
30105,BLOCK,-1,,<empty>,13,,991,2,,void
30111,BLOCK,-1,,<empty>,13,,993,1,,void
30122,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t  *p_vout = p_owner->p_vout;
    bool prerolled;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_picture->date )
    {
        vlc_mutex_unlock( &p_owner->lock );
        picture_Release( p_picture );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of video preroll"" );

        if( p_vout )
            vout_Flush( p_vout, VLC_TS_INVALID+1 );
    }

    if( p_picture->date <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated video buffer received"" );
        goto discard;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting && !p_owner->b_first )
    {
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }
    bool b_first_after_wait = p...",1,,1000,4,,void
30149,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_owner->lock );
        picture_Release( p_picture );
        return -1;
    }",5,,1007,2,,void
30180,BLOCK,-1,,"{
        msg_Dbg( p_dec, ""end of video preroll"" );

        if( p_vout )
            vout_Flush( p_vout, VLC_TS_INVALID+1 );
    }",5,,1018,2,,void
30186,BLOCK,-1,,<empty>,13,,1022,2,,void
30198,BLOCK,-1,,"{
        msg_Warn( p_dec, ""non-dated video buffer received"" );
        goto discard;
    }",5,,1026,2,,void
30217,BLOCK,-1,,"{
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }",5,,1035,2,,void
30244,BLOCK,-1,,"{
        assert( p_owner->b_first );
        msg_Dbg( p_dec, ""Received first picture"" );
        p_owner->b_first = false;
        p_picture->b_force = true;
    }",5,,1044,2,,void
30285,BLOCK,1,,<empty>,,,,1,,void
30311,BLOCK,-1,,<empty>,9,,1062,2,,void
30324,BLOCK,-1,,<empty>,9,,1067,2,,void
30336,BLOCK,-1,,"{
        if( i_rate != p_owner->i_last_rate || b_first_after_wait )
        {
            /* Be sure to not display old picture after our own */
            vout_Flush( p_vout, p_picture->date );
            p_owner->i_last_rate = i_rate;
        }
        vout_PutPicture( p_vout, p_picture );
    }",5,,1071,2,,void
30345,BLOCK,-1,,"{
            /* Be sure to not display old picture after our own */
            vout_Flush( p_vout, p_picture->date );
            p_owner->i_last_rate = i_rate;
        }",9,,1073,2,,void
30360,BLOCK,-1,,"{
        if( b_dated )
            msg_Warn( p_dec, ""early picture skipped"" );
        else
            msg_Warn( p_dec, ""non-dated video buffer received"" );
        goto discard;
    }",5,,1081,1,,void
30363,BLOCK,-1,,<empty>,13,,1083,2,,void
30368,BLOCK,-1,,<empty>,13,,1085,1,,void
30390,BLOCK,-1,,"{
    input_thread_t *p_input = p_owner->p_input;
    unsigned displayed = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_vout != NULL )
    {
        unsigned vout_lost = 0;

        vout_GetResetStatistic( p_owner->p_vout, &displayed, &vout_lost );
        lost += vout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
    stats_Update( input_priv(p_input)->counters.p_decoded_video, decoded, NULL );
    stats_Update( input_priv(p_input)->counters.p_lost_pictures, lost , NULL);
    stats_Update( input_priv(p_input)->counters.p_displayed_pictures, displayed, NULL);
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
}",1,,1098,4,,void
30405,BLOCK,-1,,<empty>,9,,1104,2,,void
30413,BLOCK,-1,,"{
        unsigned vout_lost = 0;

        vout_GetResetStatistic( p_owner->p_vout, &displayed, &vout_lost );
        lost += vout_lost;
    }",5,,1107,2,,void
30477,BLOCK,-1,,"{
    assert( p_pic );
    unsigned i_lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayVideo( p_dec, p_pic, &i_lost );

    p_owner->pf_update_stat( p_owner, 1, i_lost );
    return ret;
}",1,,1122,3,,void
30513,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool prerolled;

    assert( p_audio != NULL );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_audio->i_pts )
    {
        vlc_mutex_unlock( &p_owner->lock );
        block_Release( p_audio );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of audio preroll"" );

        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }

    /* */
    if( p_audio->i_pts <= VLC_TS_INVALID ) // FIXME --VLC_TS_INVALID verify audio_output/*
    {
        msg_Warn( p_dec, ""non-dated audio buffer received"" );
        *pi_lost_sum += 1;
        block_Release( p_audio );
        return 0;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->b_waiting )
    {
        p_owner->b_has_data = true;
        v...",1,,1135,4,,void
30538,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_owner->lock );
        block_Release( p_audio );
        return -1;
    }",5,,1143,2,,void
30569,BLOCK,-1,,"{
        msg_Dbg( p_dec, ""end of audio preroll"" );

        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }",5,,1154,2,,void
30577,BLOCK,-1,,<empty>,13,,1158,2,,void
30589,BLOCK,-1,,"{
        msg_Warn( p_dec, ""non-dated audio buffer received"" );
        *pi_lost_sum += 1;
        block_Release( p_audio );
        return 0;
    }",5,,1163,2,,void
30610,BLOCK,-1,,"{
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }",5,,1173,2,,void
30670,BLOCK,1,,<empty>,,,,1,,void
30677,BLOCK,1,,<empty>,,,,1,,void
30687,BLOCK,-1,,"{
        int status = aout_DecPlay( p_aout, p_audio, i_rate );
        if( status == AOUT_DEC_CHANGED )
        {
            /* Only reload the decoder */
            RequestReload( p_dec );
        }
        else if( status == AOUT_DEC_FAILED )
        {
            /* If we reload because the aout failed, we should release it. That
             * way, a next call to aout_update_format() won't re-use the
             * previous (failing) aout but will try to create a new one. */
            atomic_store( &p_owner->reload, RELOAD_DECODER_AOUT );
        }
    }",5,,1192,2,,void
30699,BLOCK,1,,<empty>,,,,1,,void
30701,BLOCK,-1,,"{
            /* Only reload the decoder */
            RequestReload( p_dec );
        }",9,,1195,2,,void
30705,BLOCK,-1,,<empty>,14,,1199,1,,void
30710,BLOCK,1,,<empty>,,,,1,,void
30712,BLOCK,-1,,"{
            /* If we reload because the aout failed, we should release it. That
             * way, a next call to aout_update_format() won't re-use the
             * previous (failing) aout but will try to create a new one. */
            atomic_store( &p_owner->reload, RELOAD_DECODER_AOUT );
        }",9,,1200,2,,void
30720,BLOCK,-1,,"{
        msg_Dbg( p_dec, ""discarded audio buffer"" );
        *pi_lost_sum += 1;
        block_Release( p_audio );
    }",5,,1208,1,,void
30738,BLOCK,-1,,"{
    input_thread_t *p_input = p_owner->p_input;
    unsigned played = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_aout != NULL )
    {
        unsigned aout_lost;

        aout_DecGetResetStats( p_owner->p_aout, &aout_lost, &played );
        lost += aout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    stats_Update( input_priv(p_input)->counters.p_lost_abuffers, lost, NULL );
    stats_Update( input_priv(p_input)->counters.p_played_abuffers, played, NULL );
    stats_Update( input_priv(p_input)->counters.p_decoded_audio, decoded, NULL );
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock);
}",1,,1218,4,,void
30753,BLOCK,-1,,<empty>,9,,1224,2,,void
30761,BLOCK,-1,,"{
        unsigned aout_lost;

        aout_DecGetResetStats( p_owner->p_aout, &aout_lost, &played );
        lost += aout_lost;
    }",5,,1227,2,,void
30822,BLOCK,-1,,"{
    unsigned lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayAudio( p_dec, p_aout_buf, &lost );

    p_owner->pf_update_stat( p_owner, 1, lost );

    return ret;
}",1,,1242,3,,void
30855,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = p_owner->p_spu_vout;

    /* */
    if( p_subpic->i_start <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated spu buffer received"" );
        subpicture_Delete( p_subpic );
        return;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting )
    {
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }

    DecoderWaitUnblock( p_dec );
    DecoderFixTs( p_dec, &p_subpic->i_start, &p_subpic->i_stop, NULL,
                  NULL, INT64_MAX );
    vlc_mutex_unlock( &p_owner->lock );

    if( p_subpic->i_start <= VLC_TS_INVALID
     || DecoderTimedWait( p_dec, p_subpic->i_start - SPU_MAX_PREPARE_TIME ) )
    {
        subpicture_Delete( p_subpic );
        return;
    }

    vout_PutSubpicture( p_vout, p_subpic );
}",1,,1254,3,,void
30874,BLOCK,-1,,"{
        msg_Warn( p_dec, ""non-dated spu buffer received"" );
        subpicture_Delete( p_subpic );
        return;
    }",5,,1260,2,,void
30890,BLOCK,-1,,"{
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }",5,,1270,2,,void
30935,BLOCK,-1,,"{
        subpicture_Delete( p_subpic );
        return;
    }",5,,1282,2,,void
30948,BLOCK,-1,,"{
    (void) p_owner; (void) decoded; (void) lost;
}",1,,1292,4,,void
30963,BLOCK,-1,,"{
    assert( p_spu );
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;

    if( p_input != NULL )
    {
        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_decoded_sub, 1, NULL );
        vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
    }

    int i_ret = -1;
    vout_thread_t *p_vout = input_resource_HoldVout( p_owner->p_resource );
    if( p_vout && p_owner->p_spu_vout == p_vout )
    {
        /* Preroll does not work very well with subtitle */
        vlc_mutex_lock( &p_owner->lock );
        if( p_spu->i_start > VLC_TS_INVALID &&
            p_spu->i_start < p_owner->i_preroll_end &&
            ( p_spu->i_stop <= VLC_TS_INVALID || p_spu->i_stop < p_owner->i_preroll_end ) )
        {
            vlc_mutex_unlock( &p_owner->lock );
            subpicture_Delete( p_spu );
        }
        else
        {
            vlc_mutex_unlock( &p...",1,,1297,3,,void
30982,BLOCK,-1,,"{
        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_decoded_sub, 1, NULL );
        vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
    }",5,,1303,2,,void
31028,BLOCK,-1,,"{
        /* Preroll does not work very well with subtitle */
        vlc_mutex_lock( &p_owner->lock );
        if( p_spu->i_start > VLC_TS_INVALID &&
            p_spu->i_start < p_owner->i_preroll_end &&
            ( p_spu->i_stop <= VLC_TS_INVALID || p_spu->i_stop < p_owner->i_preroll_end ) )
        {
            vlc_mutex_unlock( &p_owner->lock );
            subpicture_Delete( p_spu );
        }
        else
        {
            vlc_mutex_unlock( &p_owner->lock );
            DecoderPlaySpu( p_dec, p_spu );
            i_ret = 0;
        }
    }",5,,1312,2,,void
31062,BLOCK,-1,,"{
            vlc_mutex_unlock( &p_owner->lock );
            subpicture_Delete( p_spu );
        }",9,,1318,2,,void
31071,BLOCK,-1,,"{
            vlc_mutex_unlock( &p_owner->lock );
            DecoderPlaySpu( p_dec, p_spu );
            i_ret = 0;
        }",9,,1323,1,,void
31084,BLOCK,-1,,"{
        subpicture_Delete( p_spu );
    }",5,,1330,1,,void
31089,BLOCK,-1,,<empty>,9,,1334,2,,void
31099,BLOCK,-1,,<empty>,,,,3,,<empty>
31105,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = p_dec->pf_decode( p_dec, p_block );
    switch( ret )
    {
        case VLCDEC_SUCCESS:
            p_owner->pf_update_stat( p_owner, 1, 0 );
            break;
        case VLCDEC_ECRITICAL:
            p_owner->error = true;
            break;
        case VLCDEC_RELOAD:
            RequestReload( p_dec );
            if( unlikely( p_block == NULL ) )
                break;
            if( !( p_block->i_flags & BLOCK_FLAG_CORE_PRIVATE_RELOADED ) )
            {
                p_block->i_flags |= BLOCK_FLAG_CORE_PRIVATE_RELOADED;
                DecoderProcess( p_dec, p_block );
            }
            else /* We prefer loosing this block than an infinite recursion */
                block_Release( p_block );
            break;
        default:
            vlc_assert_unreachable();
    }
}",1,,1340,3,,void
31123,BLOCK,-1,,"{
        case VLCDEC_SUCCESS:
            p_owner->pf_update_stat( p_owner, 1, 0 );
            break;
        case VLCDEC_ECRITICAL:
            p_owner->error = true;
            break;
        case VLCDEC_RELOAD:
            RequestReload( p_dec );
            if( unlikely( p_block == NULL ) )
                break;
            if( !( p_block->i_flags & BLOCK_FLAG_CORE_PRIVATE_RELOADED ) )
            {
                p_block->i_flags |= BLOCK_FLAG_CORE_PRIVATE_RELOADED;
                DecoderProcess( p_dec, p_block );
            }
            else /* We prefer loosing this block than an infinite recursion */
                block_Release( p_block );
            break;
        default:
            vlc_assert_unreachable();
    }",5,,1345,2,,void
31151,BLOCK,-1,,<empty>,17,,1355,2,,void
31160,BLOCK,1,,<empty>,,,,1,,void
31164,BLOCK,-1,,"{
                p_block->i_flags |= BLOCK_FLAG_CORE_PRIVATE_RELOADED;
                DecoderProcess( p_dec, p_block );
            }",13,,1357,2,,void
31170,BLOCK,1,,<empty>,,,,1,,void
31178,BLOCK,-1,,<empty>,17,,1362,1,,void
31189,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->error )
        goto error;

    /* Here, the atomic doesn't prevent to miss a reload request.
     * DecoderProcess() can still be called after the decoder module or the
     * audio output requested a reload. This will only result in a drop of an
     * input block or an output buffer. */
    enum reload reload;
    if( ( reload = atomic_exchange( &p_owner->reload, RELOAD_NO_REQUEST ) ) )
    {
        msg_Warn( p_dec, ""Reloading the decoder module%s"",
                  reload == RELOAD_DECODER_AOUT ? "" and the audio output"" : """" );

        if( ReloadDecoder( p_dec, false, &p_dec->fmt_in, reload ) != VLC_SUCCESS )
            goto error;
    }

    bool packetize = p_owner->p_packetizer != NULL;
    if( p_block )
    {
        if( p_block->i_buffer <= 0 )
            goto error;

        vlc_mutex_lock( &p_owner->lock );
        DecoderUpdatePreroll( &p_owner->i_preroll_end, p_block );
        vlc_mutex_unlock...",1,,1376,3,,void
31200,BLOCK,-1,,<empty>,9,,1380,2,,void
31212,BLOCK,-1,,"{
        msg_Warn( p_dec, ""Reloading the decoder module%s"",
                  reload == RELOAD_DECODER_AOUT ? "" and the audio output"" : """" );

        if( ReloadDecoder( p_dec, false, &p_dec->fmt_in, reload ) != VLC_SUCCESS )
            goto error;
    }",5,,1388,2,,void
31233,BLOCK,-1,,<empty>,13,,1393,2,,void
31245,BLOCK,-1,,"{
        if( p_block->i_buffer <= 0 )
            goto error;

        vlc_mutex_lock( &p_owner->lock );
        DecoderUpdatePreroll( &p_owner->i_preroll_end, p_block );
        vlc_mutex_unlock( &p_owner->lock );
        if( unlikely( p_block->i_flags & BLOCK_FLAG_CORE_PRIVATE_RELOADED ) )
        {
            /* This block has already been packetized */
            packetize = false;
        }
    }",5,,1398,2,,void
31252,BLOCK,-1,,<empty>,13,,1400,2,,void
31277,BLOCK,1,,<empty>,,,,1,,void
31281,BLOCK,-1,,"{
            /* This block has already been packetized */
            packetize = false;
        }",9,,1406,2,,void
31287,BLOCK,-1,,"{
        block_t *p_packetized_block;
        block_t **pp_block = p_block ? &p_block : NULL;
        decoder_t *p_packetizer = p_owner->p_packetizer;

        while( (p_packetized_block =
                p_packetizer->pf_packetize( p_packetizer, pp_block ) ) )
        {
            if( !es_format_IsSimilar( &p_dec->fmt_in, &p_packetizer->fmt_out ) )
            {
                msg_Dbg( p_dec, ""restarting module due to input format change"");

                /* Drain the decoder module */
                DecoderDecode( p_dec, NULL );

                if( ReloadDecoder( p_dec, false, &p_packetizer->fmt_out,
                                   RELOAD_DECODER ) != VLC_SUCCESS )
                {
                    block_ChainRelease( p_packetized_block );
                    return;
                }
            }

            if( p_packetizer->pf_get_cc )
                PacketizerGetCc( p_dec, p_packetizer );

            while( p_packetized_block )
            {
                b...",5,,1420,2,,void
31312,BLOCK,-1,,"{
            if( !es_format_IsSimilar( &p_dec->fmt_in, &p_packetizer->fmt_out ) )
            {
                msg_Dbg( p_dec, ""restarting module due to input format change"");

                /* Drain the decoder module */
                DecoderDecode( p_dec, NULL );

                if( ReloadDecoder( p_dec, false, &p_packetizer->fmt_out,
                                   RELOAD_DECODER ) != VLC_SUCCESS )
                {
                    block_ChainRelease( p_packetized_block );
                    return;
                }
            }

            if( p_packetizer->pf_get_cc )
                PacketizerGetCc( p_dec, p_packetizer );

            while( p_packetized_block )
            {
                block_t *p_next = p_packetized_block->p_next;
                p_packetized_block->p_next = NULL;

                DecoderDecode( p_dec, p_packetized_block );
                if( p_owner->error )
                {
                    block_ChainRelease( p_next );
         ...",9,,1427,2,,void
31324,BLOCK,-1,,"{
                msg_Dbg( p_dec, ""restarting module due to input format change"");

                /* Drain the decoder module */
                DecoderDecode( p_dec, NULL );

                if( ReloadDecoder( p_dec, false, &p_packetizer->fmt_out,
                                   RELOAD_DECODER ) != VLC_SUCCESS )
                {
                    block_ChainRelease( p_packetized_block );
                    return;
                }
            }",13,,1429,2,,void
31342,BLOCK,-1,,"{
                    block_ChainRelease( p_packetized_block );
                    return;
                }",17,,1437,2,,void
31350,BLOCK,-1,,<empty>,17,,1444,2,,void
31356,BLOCK,-1,,"{
                block_t *p_next = p_packetized_block->p_next;
                p_packetized_block->p_next = NULL;

                DecoderDecode( p_dec, p_packetized_block );
                if( p_owner->error )
                {
                    block_ChainRelease( p_next );
                    return;
                }

                p_packetized_block = p_next;
            }",13,,1447,2,,void
31375,BLOCK,-1,,"{
                    block_ChainRelease( p_next );
                    return;
                }",17,,1453,2,,void
31385,BLOCK,-1,,<empty>,13,,1463,2,,void
31390,BLOCK,-1,,<empty>,9,,1466,1,,void
31398,BLOCK,-1,,<empty>,9,,1471,2,,void
31405,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    decoder_t *p_packetizer = p_owner->p_packetizer;

    if( p_owner->error )
        return;

    if( p_packetizer != NULL && p_packetizer->pf_flush != NULL )
        p_packetizer->pf_flush( p_packetizer );

    if ( p_dec->pf_flush != NULL )
        p_dec->pf_flush( p_dec );

    /* flush CC sub decoders */
    if( p_owner->cc.b_supported )
    {
        for( int i=0; i<MAX_CC_DECODERS; i++ )
        {
            decoder_t *p_subdec = p_owner->cc.pp_decoder[i];
            if( p_subdec && p_subdec->pf_flush )
                p_subdec->pf_flush( p_subdec );
        }
    }

#ifdef ENABLE_SOUT
    if ( p_owner->p_sout_input != NULL )
    {
        sout_InputFlush( p_owner->p_sout_input );
    }
#endif
    if( p_dec->fmt_out.i_cat == AUDIO_ES )
    {
        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }
    else if( p_dec->fmt_out.i_cat == VIDEO_ES )
    {
        if( p_owner->p_vout )
         ...",1,,1475,2,,void
31422,BLOCK,-1,,<empty>,9,,1480,2,,void
31434,BLOCK,-1,,<empty>,9,,1483,2,,void
31446,BLOCK,-1,,<empty>,9,,1486,2,,void
31458,BLOCK,-1,,"{
        for( int i=0; i<MAX_CC_DECODERS; i++ )
        {
            decoder_t *p_subdec = p_owner->cc.pp_decoder[i];
            if( p_subdec && p_subdec->pf_flush )
                p_subdec->pf_flush( p_subdec );
        }
    }",5,,1490,2,,void
31460,BLOCK,-1,,<empty>,9,,1491,1,,void
31468,BLOCK,1,,<empty>,,,,1,,void
31472,BLOCK,4,,"{
            decoder_t *p_subdec = p_owner->cc.pp_decoder[i];
            if( p_subdec && p_subdec->pf_flush )
                p_subdec->pf_flush( p_subdec );
        }",9,,1492,4,,void
31489,BLOCK,-1,,<empty>,17,,1495,2,,void
31503,BLOCK,-1,,"{
        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }",5,,1506,2,,void
31508,BLOCK,-1,,<empty>,13,,1508,2,,void
31515,BLOCK,-1,,<empty>,10,,1510,1,,void
31524,BLOCK,-1,,"{
        if( p_owner->p_vout )
            vout_Flush( p_owner->p_vout, VLC_TS_INVALID+1 );
    }",5,,1511,2,,void
31529,BLOCK,-1,,<empty>,13,,1513,2,,void
31538,BLOCK,-1,,<empty>,10,,1515,1,,void
31547,BLOCK,-1,,"{
        if( p_owner->p_spu_vout )
        {
            vout_thread_t *p_vout = input_resource_HoldVout( p_owner->p_resource );

            if( p_vout && p_owner->p_spu_vout == p_vout )
                vout_FlushSubpictureChannel( p_vout, p_owner->i_spu_channel );

            if( p_vout )
                vlc_object_release( p_vout );
        }
    }",5,,1516,2,,void
31552,BLOCK,-1,,"{
            vout_thread_t *p_vout = input_resource_HoldVout( p_owner->p_resource );

            if( p_vout && p_owner->p_spu_vout == p_vout )
                vout_FlushSubpictureChannel( p_vout, p_owner->i_spu_channel );

            if( p_vout )
                vlc_object_release( p_vout );
        }",9,,1518,2,,void
31568,BLOCK,-1,,<empty>,17,,1522,2,,void
31576,BLOCK,-1,,<empty>,17,,1525,2,,void
31598,BLOCK,-1,,"{
    decoder_t *p_dec = (decoder_t *)p_data;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool paused = false;

    /* The decoder's main loop */
    vlc_fifo_Lock( p_owner->p_fifo );
    vlc_fifo_CleanupPush( p_owner->p_fifo );

    for( ;; )
    {
        if( p_owner->flushing )
        {   /* Flush before/regardless of pause. We do not want to resume just
             * for the sake of flushing (glitches could otherwise happen). */
            int canc = vlc_savecancel();

            vlc_fifo_Unlock( p_owner->p_fifo );

            /* Flush the decoder (and the output) */
            DecoderProcessFlush( p_dec );

            vlc_fifo_Lock( p_owner->p_fifo );
            vlc_restorecancel( canc );

            /* Reset flushing after DecoderProcess in case input_DecoderFlush
             * is called again. This will avoid a second useless flush (but
             * harmless). */
            p_owner->flushing = false;

            continue;
        }

        if( paused...",1,,1540,2,,void
31624,BLOCK,-1,,<empty>,5,,1549,1,,void
31625,BLOCK,4,,"{
        if( p_owner->flushing )
        {   /* Flush before/regardless of pause. We do not want to resume just
             * for the sake of flushing (glitches could otherwise happen). */
            int canc = vlc_savecancel();

            vlc_fifo_Unlock( p_owner->p_fifo );

            /* Flush the decoder (and the output) */
            DecoderProcessFlush( p_dec );

            vlc_fifo_Lock( p_owner->p_fifo );
            vlc_restorecancel( canc );

            /* Reset flushing after DecoderProcess in case input_DecoderFlush
             * is called again. This will avoid a second useless flush (but
             * harmless). */
            p_owner->flushing = false;

            continue;
        }

        if( paused != p_owner->paused )
        {   /* Update playing/paused status of the output */
            int canc = vlc_savecancel();
            mtime_t date = p_owner->pause_date;

            paused = p_owner->paused;
            vlc_fifo_Unlock( p_owner->p_fifo );
...",5,,1550,4,,void
31630,BLOCK,-1,,"{   /* Flush before/regardless of pause. We do not want to resume just
             * for the sake of flushing (glitches could otherwise happen). */
            int canc = vlc_savecancel();

            vlc_fifo_Unlock( p_owner->p_fifo );

            /* Flush the decoder (and the output) */
            DecoderProcessFlush( p_dec );

            vlc_fifo_Lock( p_owner->p_fifo );
            vlc_restorecancel( canc );

            /* Reset flushing after DecoderProcess in case input_DecoderFlush
             * is called again. This will avoid a second useless flush (but
             * harmless). */
            p_owner->flushing = false;

            continue;
        }",9,,1552,2,,void
31659,BLOCK,-1,,"{   /* Update playing/paused status of the output */
            int canc = vlc_savecancel();
            mtime_t date = p_owner->pause_date;

            paused = p_owner->paused;
            vlc_fifo_Unlock( p_owner->p_fifo );

            /* NOTE: Only the audio and video outputs care about pause. */
            msg_Dbg( p_dec, ""toggling %s"", paused ? ""resume"" : ""pause"" );
            if( p_owner->p_vout != NULL )
                vout_ChangePause( p_owner->p_vout, paused, date );
            if( p_owner->p_aout != NULL )
                aout_DecChangePause( p_owner->p_aout, paused, date );

            vlc_restorecancel( canc );
            vlc_fifo_Lock( p_owner->p_fifo );
            continue;
        }",9,,1573,2,,void
31692,BLOCK,-1,,<empty>,17,,1583,2,,void
31705,BLOCK,-1,,<empty>,17,,1585,2,,void
31729,BLOCK,-1,,"{   /* Wait for resumption from pause */
            p_owner->b_idle = true;
            vlc_cond_signal( &p_owner->wait_acknowledge );
            vlc_fifo_Wait( p_owner->p_fifo );
            p_owner->b_idle = false;
            continue;
        }",9,,1593,2,,void
31767,BLOCK,-1,,"{
            if( likely(!p_owner->b_draining) )
            {   /* Wait for a block to decode (or a request to drain) */
                p_owner->b_idle = true;
                vlc_cond_signal( &p_owner->wait_acknowledge );
                vlc_fifo_Wait( p_owner->p_fifo );
                p_owner->b_idle = false;
                continue;
            }
            /* We have emptied the FIFO and there is a pending request to
             * drain. Pass p_block = NULL to decoder just once. */
        }",9,,1606,2,,void
31774,BLOCK,-1,,"{   /* Wait for a block to decode (or a request to drain) */
                p_owner->b_idle = true;
                vlc_cond_signal( &p_owner->wait_acknowledge );
                vlc_fifo_Wait( p_owner->p_fifo );
                p_owner->b_idle = false;
                continue;
            }",13,,1608,2,,void
31810,BLOCK,-1,,"{   /* Draining: the decoder is drained and all decoded buffers are
             * queued to the output at this point. Now drain the output. */
            if( p_owner->p_aout != NULL )
                aout_DecFlush( p_owner->p_aout, true );
        }",9,,1625,2,,void
31817,BLOCK,-1,,<empty>,17,,1628,2,,void
31838,BLOCK,-1,,"{
            p_owner->b_draining = false;
            p_owner->drained = true;
        }",9,,1635,2,,void
31873,BLOCK,-1,,"{
    decoder_t *p_dec;
    decoder_owner_sys_t *p_owner;

    p_dec = vlc_custom_create( p_parent, sizeof( *p_dec ), ""decoder"" );
    if( p_dec == NULL )
        return NULL;

    /* Allocate our private structure for the decoder */
    p_dec->p_owner = p_owner = malloc( sizeof( decoder_owner_sys_t ) );
    if( unlikely(p_owner == NULL) )
    {
        vlc_object_release( p_dec );
        return NULL;
    }
    p_owner->i_preroll_end = INT64_MIN;
    p_owner->i_last_rate = INPUT_RATE_DEFAULT;
    p_owner->p_input = p_input;
    p_owner->p_resource = p_resource;
    p_owner->p_aout = NULL;
    p_owner->p_vout = NULL;
    p_owner->p_spu_vout = NULL;
    p_owner->i_spu_channel = 0;
    p_owner->i_spu_order = 0;
    p_owner->p_sout = p_sout;
    p_owner->p_sout_input = NULL;
    p_owner->p_packetizer = NULL;

    p_owner->b_fmt_description = false;
    p_owner->p_description = NULL;

    p_owner->paused = false;
    p_owner->pause_date = VLC_TS_INVALID;
    p_owner->frames_countdown = ...",1,,1660,6,,void
31888,BLOCK,-1,,<empty>,9,,1666,2,,void
31905,BLOCK,-1,,"{
        vlc_object_release( p_dec );
        return NULL;
    }",5,,1671,2,,void
32062,BLOCK,-1,,"{
        free( p_owner );
        vlc_object_release( p_dec );
        return NULL;
    }",5,,1712,2,,void
32138,BLOCK,-1,,"{
        p_owner->p_packetizer =
            vlc_custom_create( p_parent, sizeof( decoder_t ), ""packetizer"" );
        if( p_owner->p_packetizer )
        {
            if( LoadDecoder( p_owner->p_packetizer, true, fmt ) )
            {
                vlc_object_release( p_owner->p_packetizer );
                p_owner->p_packetizer = NULL;
            }
            else
            {
                p_owner->p_packetizer->fmt_out.b_packetized = true;
                fmt = &p_owner->p_packetizer->fmt_out;
            }
        }
    }",5,,1736,2,,void
32152,BLOCK,-1,,"{
            if( LoadDecoder( p_owner->p_packetizer, true, fmt ) )
            {
                vlc_object_release( p_owner->p_packetizer );
                p_owner->p_packetizer = NULL;
            }
            else
            {
                p_owner->p_packetizer->fmt_out.b_packetized = true;
                fmt = &p_owner->p_packetizer->fmt_out;
            }
        }",9,,1740,2,,void
32160,BLOCK,-1,,"{
                vlc_object_release( p_owner->p_packetizer );
                p_owner->p_packetizer = NULL;
            }",13,,1742,2,,void
32171,BLOCK,-1,,"{
                p_owner->p_packetizer->fmt_out.b_packetized = true;
                fmt = &p_owner->p_packetizer->fmt_out;
            }",13,,1747,1,,void
32196,BLOCK,-1,,<empty>,9,,1756,2,,void
32205,BLOCK,-1,,"{
        case VIDEO_ES:
            p_dec->pf_queue_video = DecoderQueueVideo;
            p_dec->pf_queue_cc = DecoderQueueCc;
            p_owner->pf_update_stat = DecoderUpdateStatVideo;
            break;
        case AUDIO_ES:
            p_dec->pf_queue_audio = DecoderQueueAudio;
            p_owner->pf_update_stat = DecoderUpdateStatAudio;
            break;
        case SPU_ES:
            p_dec->pf_queue_sub = DecoderQueueSpu;
            p_owner->pf_update_stat = DecoderUpdateStatSpu;
            break;
        default:
            msg_Err( p_dec, ""unknown ES format"" );
            UnloadDecoder( p_dec );
            return p_dec;
    }",5,,1759,2,,void
32264,BLOCK,-1,,"{
        for( unsigned i = 0; i < AUDIO_REPLAY_GAIN_MAX; i++ )
        {
            if( !p_dec->fmt_out.audio_replay_gain.pb_peak[i] )
            {
                p_dec->fmt_out.audio_replay_gain.pb_peak[i] = fmt->audio_replay_gain.pb_peak[i];
                p_dec->fmt_out.audio_replay_gain.pf_peak[i] = fmt->audio_replay_gain.pf_peak[i];
            }
            if( !p_dec->fmt_out.audio_replay_gain.pb_gain[i] )
            {
                p_dec->fmt_out.audio_replay_gain.pb_gain[i] = fmt->audio_replay_gain.pb_gain[i];
                p_dec->fmt_out.audio_replay_gain.pf_gain[i] = fmt->audio_replay_gain.pf_gain[i];
            }
        }
    }",5,,1780,2,,void
32266,BLOCK,-1,,<empty>,9,,1781,1,,void
32276,BLOCK,4,,"{
            if( !p_dec->fmt_out.audio_replay_gain.pb_peak[i] )
            {
                p_dec->fmt_out.audio_replay_gain.pb_peak[i] = fmt->audio_replay_gain.pb_peak[i];
                p_dec->fmt_out.audio_replay_gain.pf_peak[i] = fmt->audio_replay_gain.pf_peak[i];
            }
            if( !p_dec->fmt_out.audio_replay_gain.pb_gain[i] )
            {
                p_dec->fmt_out.audio_replay_gain.pb_gain[i] = fmt->audio_replay_gain.pb_gain[i];
                p_dec->fmt_out.audio_replay_gain.pf_gain[i] = fmt->audio_replay_gain.pf_gain[i];
            }
        }",9,,1782,4,,void
32288,BLOCK,-1,,"{
                p_dec->fmt_out.audio_replay_gain.pb_peak[i] = fmt->audio_replay_gain.pb_peak[i];
                p_dec->fmt_out.audio_replay_gain.pf_peak[i] = fmt->audio_replay_gain.pf_peak[i];
            }",13,,1784,2,,void
32334,BLOCK,-1,,"{
                p_dec->fmt_out.audio_replay_gain.pb_gain[i] = fmt->audio_replay_gain.pb_gain[i];
                p_dec->fmt_out.audio_replay_gain.pf_gain[i] = fmt->audio_replay_gain.pf_gain[i];
            }",13,,1789,2,,void
32397,BLOCK,-1,,<empty>,5,,1801,1,,void
32405,BLOCK,1,,<empty>,,,,1,,void
32429,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    msg_Dbg( p_dec, ""killing decoder fourcc `%4.4s'"",
             (char*)&p_dec->fmt_in.i_codec );

    const bool b_flush_spu = p_dec->fmt_out.i_cat == SPU_ES;
    UnloadDecoder( p_dec );

    /* Free all packets still in the decoder fifo. */
    block_FifoRelease( p_owner->p_fifo );

    /* Cleanup */
    if( p_owner->p_aout )
    {
        /* TODO: REVISIT gap-less audio */
        aout_DecFlush( p_owner->p_aout, false );
        aout_DecDelete( p_owner->p_aout );
        input_resource_PutAout( p_owner->p_resource, p_owner->p_aout );
        if( p_owner->p_input != NULL )
            input_SendEventAout( p_owner->p_input );
    }
    if( p_owner->p_vout )
    {
        /* Reset the cancel state that was set before joining the decoder
         * thread */
        vout_Cancel( p_owner->p_vout, false );

        input_resource_RequestVout( p_owner->p_resource, p_owner->p_vout, NULL,
                                    0, true )...",1,,1814,2,,void
32467,BLOCK,-1,,"{
        /* TODO: REVISIT gap-less audio */
        aout_DecFlush( p_owner->p_aout, false );
        aout_DecDelete( p_owner->p_aout );
        input_resource_PutAout( p_owner->p_resource, p_owner->p_aout );
        if( p_owner->p_input != NULL )
            input_SendEventAout( p_owner->p_input );
    }",5,,1828,2,,void
32490,BLOCK,-1,,<empty>,13,,1834,2,,void
32499,BLOCK,-1,,"{
        /* Reset the cancel state that was set before joining the decoder
         * thread */
        vout_Cancel( p_owner->p_vout, false );

        input_resource_RequestVout( p_owner->p_resource, p_owner->p_vout, NULL,
                                    0, true );
        if( p_owner->p_input != NULL )
            input_SendEventVout( p_owner->p_input );
    }",5,,1837,2,,void
32521,BLOCK,-1,,<empty>,13,,1845,2,,void
32533,BLOCK,-1,,"{
        vout_thread_t *p_vout = input_resource_HoldVout( p_owner->p_resource );
        if( p_vout )
        {
            if( p_owner->p_spu_vout == p_vout )
                vout_FlushSubpictureChannel( p_vout, p_owner->i_spu_channel );
            vlc_object_release( p_vout );
        }
    }",5,,1857,2,,void
32543,BLOCK,-1,,"{
            if( p_owner->p_spu_vout == p_vout )
                vout_FlushSubpictureChannel( p_vout, p_owner->i_spu_channel );
            vlc_object_release( p_vout );
        }",9,,1860,2,,void
32550,BLOCK,-1,,<empty>,17,,1862,2,,void
32562,BLOCK,-1,,<empty>,9,,1868,2,,void
32571,BLOCK,-1,,"{
        UnloadDecoder( p_owner->p_packetizer );
        vlc_object_release( p_owner->p_packetizer );
    }",5,,1871,2,,void
32615,BLOCK,-1,,"{
    if (fmt->i_codec != VLC_CODEC_UNKNOWN && fmt->i_codec) {
        const char *desc = vlc_fourcc_GetDescription(fmt->i_cat, fmt->i_codec);
        if (!desc || !*desc)
            desc = N_(""No description for this codec"");
        msg_Err( p_dec, ""Codec `%4.4s' (%s) is not supported."", (char*)&fmt->i_codec, desc );
        vlc_dialog_display_error( p_dec, _(""Codec not supported""),
            _(""VLC could not decode the format \""%4.4s\"" (%s)""),
            (char*)&fmt->i_codec, desc );
    } else if( b_decoding ){
        msg_Err( p_dec, ""could not identify codec"" );
        vlc_dialog_display_error( p_dec, _(""Unidentified codec""),
            _(""VLC could not identify the audio or video codec"" ) );
    }
}",1,,1889,4,,void
32626,BLOCK,-1,,"{
        const char *desc = vlc_fourcc_GetDescription(fmt->i_cat, fmt->i_codec);
        if (!desc || !*desc)
            desc = N_(""No description for this codec"");
        msg_Err( p_dec, ""Codec `%4.4s' (%s) is not supported."", (char*)&fmt->i_codec, desc );
        vlc_dialog_display_error( p_dec, _(""Codec not supported""),
            _(""VLC could not decode the format \""%4.4s\"" (%s)""),
            (char*)&fmt->i_codec, desc );
    }",60,,1890,2,,void
32644,BLOCK,-1,,<empty>,13,,1893,2,,void
32673,BLOCK,-1,,<empty>,12,,1898,1,,void
32676,BLOCK,-1,,"{
        msg_Err( p_dec, ""could not identify codec"" );
        vlc_dialog_display_error( p_dec, _(""Unidentified codec""),
            _(""VLC could not identify the audio or video codec"" ) );
    }",28,,1898,2,,void
32695,BLOCK,-1,,"{
    decoder_t *p_dec = NULL;
    const char *psz_type = p_sout ? N_(""packetizer"") : N_(""decoder"");
    int i_priority;

    /* Create the decoder configuration structure */
    p_dec = CreateDecoder( p_parent, p_input, fmt, p_resource, p_sout );
    if( p_dec == NULL )
    {
        msg_Err( p_parent, ""could not create %s"", psz_type );
        vlc_dialog_display_error( p_parent, _(""Streaming / Transcoding failed""),
            _(""VLC could not open the %s module.""), vlc_gettext( psz_type ) );
        return NULL;
    }

    if( !p_dec->p_module )
    {
        DecoderUnsupportedCodec( p_dec, fmt, !p_sout );

        DeleteDecoder( p_dec );
        return NULL;
    }

    p_dec->p_owner->p_clock = p_clock;
    assert( p_dec->fmt_out.i_cat != UNKNOWN_ES );

    if( p_dec->fmt_out.i_cat == AUDIO_ES )
        i_priority = VLC_THREAD_PRIORITY_AUDIO;
    else
        i_priority = VLC_THREAD_PRIORITY_VIDEO;

    /* Spawn the decoder thread */
    if( vlc_clone( &p_dec->p_owner->thread, D...",1,,1910,7,,void
32722,BLOCK,-1,,"{
        msg_Err( p_parent, ""could not create %s"", psz_type );
        vlc_dialog_display_error( p_parent, _(""Streaming / Transcoding failed""),
            _(""VLC could not open the %s module.""), vlc_gettext( psz_type ) );
        return NULL;
    }",5,,1918,2,,void
32742,BLOCK,-1,,"{
        DecoderUnsupportedCodec( p_dec, fmt, !p_sout );

        DeleteDecoder( p_dec );
        return NULL;
    }",5,,1926,2,,void
32775,BLOCK,-1,,<empty>,9,,1937,2,,void
32780,BLOCK,-1,,<empty>,9,,1939,1,,void
32795,BLOCK,-1,,"{
        msg_Err( p_dec, ""cannot spawn decoder thread"" );
        DeleteDecoder( p_dec );
        return NULL;
    }",5,,1943,2,,void
32812,BLOCK,-1,,"{
    return decoder_New( VLC_OBJECT(p_input), p_input, fmt, p_clock,
                        input_priv(p_input)->p_resource, p_sout );
}",1,,1963,5,,void
32831,BLOCK,-1,,"{
    return decoder_New( p_parent, NULL, fmt, NULL, p_resource, NULL );
}",1,,1973,4,,void
32844,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_cancel( p_owner->thread );

    vlc_fifo_Lock( p_owner->p_fifo );
    /* Signal DecoderTimedWait */
    p_owner->flushing = true;
    vlc_cond_signal( &p_owner->wait_timed );
    vlc_fifo_Unlock( p_owner->p_fifo );

    /* Make sure we aren't waiting/decoding anymore */
    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );

    /* If the video output is paused or slow, or if the picture pool size was
     * under-estimated (e.g. greedy video filter, buggy decoder...), the
     * the picture pool may be empty, and the decoder thread or any decoder
     * module worker threads may be stuck waiting for free picture buffers.
     *
     * This unblocks the thread, allowing the decoder module to join all its
     * worker threads (if any) and the decoder thread to terminate. */
    if( p_owner->p_vout != NULL )
        vout_Cancel( p_owner->p_vout, true );
    vlc_...",1,,1986,2,,void
32894,BLOCK,-1,,<empty>,9,,2010,2,,void
32918,BLOCK,-1,,"{
        for( int i = 0; i < MAX_CC_DECODERS; i++ )
            input_DecoderSetCcState( p_dec, VLC_CODEC_CEA608, i, false );
    }",5,,2017,2,,void
32920,BLOCK,-1,,<empty>,9,,2018,1,,void
32928,BLOCK,1,,<empty>,,,,1,,void
32945,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !b_do_pace )
    {
        /* FIXME: ideally we would check the time amount of data
         * in the FIFO instead of its size. */
        /* 400 MiB, i.e. ~ 50mb/s for 60s */
        if( vlc_fifo_GetBytes( p_owner->p_fifo ) > 400*1024*1024 )
        {
            msg_Warn( p_dec, ""decoder/packetizer fifo full (data not ""
                      ""consumed quickly enough), resetting fifo!"" );
            block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );
            p_block->i_flags |= BLOCK_FLAG_DISCONTINUITY;
        }
    }
    else
    if( !p_owner->b_waiting )
    {   /* The FIFO is not consumed when waiting, so pacing would deadlock VLC.
         * Locking is not necessary as b_waiting is only read, not written by
         * the decoder thread. */
        while( vlc_fifo_GetCount( p_owner->p_fifo ) >= 10 )
            vlc_fifo_WaitCond( p_owner->p_fifo, &p_owner-...",1,,2034,4,,void
32959,BLOCK,-1,,"{
        /* FIXME: ideally we would check the time amount of data
         * in the FIFO instead of its size. */
        /* 400 MiB, i.e. ~ 50mb/s for 60s */
        if( vlc_fifo_GetBytes( p_owner->p_fifo ) > 400*1024*1024 )
        {
            msg_Warn( p_dec, ""decoder/packetizer fifo full (data not ""
                      ""consumed quickly enough), resetting fifo!"" );
            block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );
            p_block->i_flags |= BLOCK_FLAG_DISCONTINUITY;
        }
    }",5,,2039,2,,void
32971,BLOCK,-1,,"{
            msg_Warn( p_dec, ""decoder/packetizer fifo full (data not ""
                      ""consumed quickly enough), resetting fifo!"" );
            block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );
            p_block->i_flags |= BLOCK_FLAG_DISCONTINUITY;
        }",9,,2044,2,,void
32986,BLOCK,-1,,<empty>,5,,2052,1,,void
32992,BLOCK,-1,,"{   /* The FIFO is not consumed when waiting, so pacing would deadlock VLC.
         * Locking is not necessary as b_waiting is only read, not written by
         * the decoder thread. */
        while( vlc_fifo_GetCount( p_owner->p_fifo ) >= 10 )
            vlc_fifo_WaitCond( p_owner->p_fifo, &p_owner->wait_fifo );
    }",5,,2053,2,,void
33021,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !vlc_fifo_IsEmpty( p_dec->p_owner->p_fifo ) || p_owner->b_draining )
    {
        vlc_fifo_Unlock( p_owner->p_fifo );
        return false;
    }
    vlc_fifo_Unlock( p_owner->p_fifo );

    bool b_empty;

    vlc_mutex_lock( &p_owner->lock );
#ifdef ENABLE_SOUT
    if( p_owner->p_sout_input != NULL )
        b_empty = sout_InputIsEmpty( p_owner->p_sout_input );
    else
#endif
    if( p_owner->fmt.i_cat == VIDEO_ES && p_owner->p_vout != NULL )
        b_empty = vout_IsEmpty( p_owner->p_vout );
    else if( p_owner->fmt.i_cat == AUDIO_ES )
        b_empty = !p_owner->b_draining || p_owner->drained;
    else
        b_empty = true; /* TODO subtitles support */
    vlc_mutex_unlock( &p_owner->lock );

    return b_empty;
}",1,,2065,2,,void
33049,BLOCK,-1,,"{
        vlc_fifo_Unlock( p_owner->p_fifo );
        return false;
    }",5,,2072,2,,void
33080,BLOCK,-1,,<empty>,9,,2087,2,,void
33088,BLOCK,-1,,<empty>,10,,2088,1,,void
33097,BLOCK,-1,,<empty>,9,,2089,2,,void
33109,BLOCK,-1,,<empty>,9,,2091,1,,void
33124,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->b_draining = true;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",1,,2106,2,,void
33152,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );

    /* Empty the fifo */
    block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );

    /* Don't need to wait for the DecoderThread to flush. Indeed, if called a
     * second time, this function will clear the FIFO again before anything was
     * dequeued by DecoderThread and there is no need to flush a second time in
     * a row. */
    p_owner->flushing = true;

    /* Flush video/spu decoder when paused: increment frames_countdown in order
     * to display one frame/subtitle */
    if( p_owner->paused
     && ( p_owner->fmt.i_cat == VIDEO_ES || p_owner->fmt.i_cat == SPU_ES )
     && p_owner->frames_countdown == 0 )
        p_owner->frames_countdown++;

    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_cond_signal( &p_owner->wait_timed );

    vlc_fifo_Unlock( p_owner->p_fifo );
}",1,,2120,2,,void
33199,BLOCK,-1,,<empty>,9,,2139,2,,void
33222,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    *p_desc = p_owner->cc.desc;
    vlc_mutex_unlock( &p_owner->lock );
}",1,,2148,3,,void
33253,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int i_max_channels;
    uint64_t i_bitmap;
    if( codec == VLC_CODEC_CEA608 )
    {
        i_max_channels = 4;
        i_bitmap = p_owner->cc.desc.i_608_channels;
    }
    else if( codec == VLC_CODEC_CEA708 )
    {
        i_max_channels = 64;
        i_bitmap = p_owner->cc.desc.i_708_channels;
    }
    else return false;

    return ( i_channel >= 0 && i_channel < i_max_channels &&
             ( i_bitmap & ((uint64_t)1 << i_channel) ) );
}",1,,2158,4,,void
33266,BLOCK,-1,,"{
        i_max_channels = 4;
        i_bitmap = p_owner->cc.desc.i_608_channels;
    }",5,,2164,2,,void
33280,BLOCK,-1,,<empty>,10,,2168,1,,void
33285,BLOCK,-1,,"{
        i_max_channels = 64;
        i_bitmap = p_owner->cc.desc.i_708_channels;
    }",5,,2169,2,,void
33299,BLOCK,-1,,<empty>,10,,2173,1,,void
33325,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    //msg_Warn( p_dec, ""input_DecoderSetCcState: %d @%x"", b_decode, i_channel );

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    if( b_decode )
    {
        decoder_t *p_cc;
        es_format_t fmt;

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i_channel;
        fmt.subs.cc.i_reorder_depth = p_owner->cc.desc.i_reorder_depth;
        p_cc = input_DecoderNew( p_owner->p_input, &fmt,
                              p_dec->p_owner->p_clock, p_owner->p_sout );
        if( !p_cc )
        {
            msg_Err( p_dec, ""could not create decoder"" );
            vlc_dialog_display_error( p_dec,
                _(""Streaming / Transcoding failed""), ""%s"",
                _(""VLC could not open the decoder module."") );
            return VLC_EGENERIC;
        }
        else if( !p_cc->p_module )
        {
            DecoderUnsupportedCodec( p_dec, &fmt, true...",1,,2181,5,,void
33338,BLOCK,-1,,<empty>,9,,2187,2,,void
33343,BLOCK,-1,,"{
        decoder_t *p_cc;
        es_format_t fmt;

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i_channel;
        fmt.subs.cc.i_reorder_depth = p_owner->cc.desc.i_reorder_depth;
        p_cc = input_DecoderNew( p_owner->p_input, &fmt,
                              p_dec->p_owner->p_clock, p_owner->p_sout );
        if( !p_cc )
        {
            msg_Err( p_dec, ""could not create decoder"" );
            vlc_dialog_display_error( p_dec,
                _(""Streaming / Transcoding failed""), ""%s"",
                _(""VLC could not open the decoder module."") );
            return VLC_EGENERIC;
        }
        else if( !p_cc->p_module )
        {
            DecoderUnsupportedCodec( p_dec, &fmt, true );
            input_DecoderDelete(p_cc);
            return VLC_EGENERIC;
        }
        p_cc->p_owner->p_clock = p_owner->p_clock;

        vlc_mutex_lock( &p_owner->lock );
        p_owner->cc.pp_decoder[i_channel] = p_cc;
        vlc_mutex_unlock...",5,,2190,2,,void
33394,BLOCK,-1,,"{
            msg_Err( p_dec, ""could not create decoder"" );
            vlc_dialog_display_error( p_dec,
                _(""Streaming / Transcoding failed""), ""%s"",
                _(""VLC could not open the decoder module."") );
            return VLC_EGENERIC;
        }",9,,2200,2,,void
33408,BLOCK,-1,,<empty>,14,,2207,1,,void
33414,BLOCK,-1,,"{
            DecoderUnsupportedCodec( p_dec, &fmt, true );
            input_DecoderDelete(p_cc);
            return VLC_EGENERIC;
        }",9,,2208,2,,void
33453,BLOCK,-1,,"{
        decoder_t *p_cc;

        vlc_mutex_lock( &p_owner->lock );
        p_cc = p_owner->cc.pp_decoder[i_channel];
        p_owner->cc.pp_decoder[i_channel] = NULL;
        vlc_mutex_unlock( &p_owner->lock );

        if( p_cc )
            input_DecoderDelete(p_cc);
    }",5,,2220,1,,void
33485,BLOCK,-1,,<empty>,13,,2229,2,,void
33497,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_owner->lock );
    *pb_decode = p_owner->cc.pp_decoder[i_channel] != NULL;
    vlc_mutex_unlock( &p_owner->lock );
    return VLC_SUCCESS;
}",1,,2236,5,,void
33510,BLOCK,-1,,<empty>,9,,2240,2,,void
33543,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    /* Normally, p_owner->b_paused != b_paused here. But if a track is added
     * while the input is paused (e.g. add sub file), then b_paused is
     * (incorrectly) false. FIXME: This is a bug in the decoder owner. */
    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->paused = b_paused;
    p_owner->pause_date = i_date;
    p_owner->frames_countdown = 0;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",1,,2249,4,,void
33582,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    p_owner->i_ts_delay = i_delay;
    vlc_mutex_unlock( &p_owner->lock );
}",1,,2264,3,,void
33608,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_first = true;
    p_owner->b_has_data = false;
    p_owner->b_waiting = true;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",1,,2273,2,,void
33654,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",1,,2287,2,,void
33689,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    while( !p_owner->b_has_data )
    {
        /* Don't need to lock p_owner->paused since it's only modified by the
         * owner */
        if( p_owner->paused )
            break;
        vlc_fifo_Lock( p_owner->p_fifo );
        if( p_owner->b_idle && vlc_fifo_IsEmpty( p_owner->p_fifo ) )
        {
            msg_Err( p_dec, ""buffer deadlock prevented"" );
            vlc_fifo_Unlock( p_owner->p_fifo );
            break;
        }
        vlc_fifo_Unlock( p_owner->p_fifo );
        vlc_cond_wait( &p_owner->wait_acknowledge, &p_owner->lock );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",1,,2299,2,,void
33710,BLOCK,-1,,"{
        /* Don't need to lock p_owner->paused since it's only modified by the
         * owner */
        if( p_owner->paused )
            break;
        vlc_fifo_Lock( p_owner->p_fifo );
        if( p_owner->b_idle && vlc_fifo_IsEmpty( p_owner->p_fifo ) )
        {
            msg_Err( p_dec, ""buffer deadlock prevented"" );
            vlc_fifo_Unlock( p_owner->p_fifo );
            break;
        }
        vlc_fifo_Unlock( p_owner->p_fifo );
        vlc_cond_wait( &p_owner->wait_acknowledge, &p_owner->lock );
    }",5,,2306,2,,void
33715,BLOCK,-1,,<empty>,13,,2310,2,,void
33730,BLOCK,-1,,"{
            msg_Err( p_dec, ""buffer deadlock prevented"" );
            vlc_fifo_Unlock( p_owner->p_fifo );
            break;
        }",9,,2313,2,,void
33762,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->paused );
    *pi_duration = 0;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->frames_countdown++;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->fmt.i_cat == VIDEO_ES )
    {
        if( p_owner->p_vout )
            vout_NextPicture( p_owner->p_vout, pi_duration );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",1,,2325,3,,void
33806,BLOCK,-1,,"{
        if( p_owner->p_vout )
            vout_NextPicture( p_owner->p_vout, pi_duration );
    }",5,,2338,2,,void
33811,BLOCK,-1,,<empty>,13,,2340,2,,void
33828,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool b_changed;

    vlc_mutex_lock( &p_owner->lock );
    b_changed = p_owner->b_fmt_description;
    if( b_changed )
    {
        if( p_fmt != NULL )
            es_format_Copy( p_fmt, &p_owner->fmt );

        if( pp_meta )
        {
            *pp_meta = NULL;
            if( p_owner->p_description )
            {
                *pp_meta = vlc_meta_New();
                if( *pp_meta )
                    vlc_meta_Merge( *pp_meta, p_owner->p_description );
            }
        }
        p_owner->b_fmt_description = false;
    }
    vlc_mutex_unlock( &p_owner->lock );
    return b_changed;
}",1,,2346,4,,void
33848,BLOCK,-1,,"{
        if( p_fmt != NULL )
            es_format_Copy( p_fmt, &p_owner->fmt );

        if( pp_meta )
        {
            *pp_meta = NULL;
            if( p_owner->p_description )
            {
                *pp_meta = vlc_meta_New();
                if( *pp_meta )
                    vlc_meta_Merge( *pp_meta, p_owner->p_description );
            }
        }
        p_owner->b_fmt_description = false;
    }",5,,2353,2,,void
33853,BLOCK,-1,,<empty>,13,,2355,2,,void
33862,BLOCK,-1,,"{
            *pp_meta = NULL;
            if( p_owner->p_description )
            {
                *pp_meta = vlc_meta_New();
                if( *pp_meta )
                    vlc_meta_Merge( *pp_meta, p_owner->p_description );
            }
        }",9,,2358,2,,void
33871,BLOCK,-1,,"{
                *pp_meta = vlc_meta_New();
                if( *pp_meta )
                    vlc_meta_Merge( *pp_meta, p_owner->p_description );
            }",13,,2361,2,,void
33879,BLOCK,-1,,<empty>,21,,2364,2,,void
33902,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    return block_FifoSize( p_owner->p_fifo );
}",1,,2374,2,,void
33920,BLOCK,-1,,"{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( pp_vout )
        *pp_vout = p_owner->p_vout ? vlc_object_hold( p_owner->p_vout ) : NULL;
    if( pp_aout )
        *pp_aout = p_owner->p_aout ? vlc_object_hold( p_owner->p_aout ) : NULL;
    vlc_mutex_unlock( &p_owner->lock );
}",1,,2382,4,,void
33934,BLOCK,-1,,<empty>,9,,2387,2,,void
33949,BLOCK,-1,,<empty>,9,,2389,2,,void
33977,BLOCK,-1,,<empty>,1,,1,1,,ANY
33983,BLOCK,-1,,<empty>,,,,5,,<empty>
33992,BLOCK,-1,,<empty>,,,,4,,<empty>
33998,BLOCK,-1,,<empty>,,,,3,,<empty>
34003,BLOCK,-1,,<empty>,,,,2,,<empty>
34008,BLOCK,-1,,<empty>,,,,2,,<empty>
34013,BLOCK,-1,,<empty>,,,,2,,<empty>
34018,BLOCK,-1,,<empty>,,,,2,,<empty>
34026,BLOCK,-1,,<empty>,,,,5,,<empty>
34034,BLOCK,-1,,<empty>,,,,5,,<empty>
34040,BLOCK,-1,,<empty>,,,,3,,<empty>
34046,BLOCK,-1,,<empty>,,,,3,,<empty>
34053,BLOCK,-1,,<empty>,,,,4,,<empty>
34058,BLOCK,-1,,<empty>,,,,2,,<empty>
34065,BLOCK,-1,,<empty>,,,,4,,<empty>
34092,BLOCK,-1,,<empty>,1,,1,1,,ANY
34097,BLOCK,-1,,<empty>,,,,1,,<empty>
34108,BLOCK,-1,,"{
    demux_mapping* entry = v;
    return vlc_ascii_strcasecmp( k, entry->key );
}",1,,47,3,,void
34125,BLOCK,-1,,"{
    return bsearch( key, data, size, sizeof( *data ), demux_mapping_cmp );
}",1,,54,4,,void
34139,BLOCK,-1,,"{
    static demux_mapping types[] =
    {   /* Must be sorted in ascending ASCII order */
        { ""audio/aac"",           ""m4a""     },
        { ""audio/aacp"",          ""m4a""     },
        { ""audio/mpeg"",          ""mp3""     },
        //{ ""video/MP1S"",          ""es,mpgv"" }, !b_force
        { ""video/dv"",            ""rawdv""   },
        { ""video/MP2P"",          ""ps""      },
        { ""video/MP2T"",          ""ts""      },
        { ""video/nsa"",           ""nsv""     },
        { ""video/nsv"",           ""nsv""     },
    };
    demux_mapping *type = demux_lookup( mime, types, ARRAY_SIZE( types ) );
    return (type != NULL) ? type->name : ""any"";
}",1,,59,2,,void
34190,BLOCK,-1,,"{
    /* NOTE: Add only file without any problems here and with strong detection:
     * - no .mp3, .a52, ...
     *  - wav can't be added 'cause of a52 and dts in them as raw audio
     */
    static demux_mapping strong[] =
    { /* NOTE: must be sorted in asc order */
        { ""aiff"", ""aiff"" },
        { ""asf"",  ""asf"" },
        { ""au"",   ""au"" },
        { ""avi"",  ""avi"" },
        { ""drc"",  ""dirac"" },
        { ""dv"",   ""dv"" },
        { ""flac"", ""flac"" },
        { ""h264"", ""h264"" },
        { ""kar"", ""smf"" },
        { ""m3u"",  ""m3u"" },
        { ""m4a"",  ""mp4"" },
        { ""m4v"",  ""m4v"" },
        { ""mid"",  ""smf"" },
        { ""mka"",  ""mkv"" },
        { ""mks"",  ""mkv"" },
        { ""mkv"",  ""mkv"" },
        { ""moov"", ""mp4"" },
        { ""mov"",  ""mp4"" },
        { ""mp4"",  ""mp4"" },
        { ""nsv"",  ""nsv"" },
        { ""oga"",  ""ogg"" },
        { ""ogg"",  ""ogg"" },
        { ""ogm"",  ""ogg"" },
        { ""ogv"",  ""ogg"" },
        { ""ogx"",  ""ogg"" }, /*RFC5334*/
        { ""opus"", ""ogg"" }, /*draft-t...",1,,78,3,,void
34311,BLOCK,1,,<empty>,9,,133,1,,void
34318,BLOCK,2,,<empty>,9,,134,2,,void
34353,BLOCK,-1,,"{
    return demux_NewAdvanced( p_obj, NULL,
                              (s == NULL) ? psz_name : """",
                              (s != NULL) ? psz_name : """",
                              psz_location, s, out, false );
}",1,,147,6,,void
34362,BLOCK,1,,<empty>,,,,7,,void
34389,BLOCK,-1,,<empty>,,,,2,,<empty>
34395,BLOCK,-1,,"{
    assert(demux->s != NULL);
    vlc_stream_Delete(demux->s);
}",1,,161,2,,void
34410,BLOCK,-1,,"{
    assert(demux->s == NULL);
    (void) demux;
}",1,,167,2,,void
34424,BLOCK,-1,,"{
    assert(demux->p_next != NULL);
    demux_Delete(demux->p_next);
}",1,,173,2,,void
34440,BLOCK,-1,,"{
    int (*probe)(vlc_object_t *) = func;
    demux_t *demux = va_arg(ap, demux_t *);

    /* Restore input stream offset (in case previous probed demux failed to
     * to do so). */
    if (vlc_stream_Tell(demux->s) != 0 && vlc_stream_Seek(demux->s, 0))
    {
        msg_Err(demux, ""seek failure before probing"");
        return VLC_EGENERIC;
    }

    return probe(VLC_OBJECT(demux));
}",1,,179,3,,void
34443,BLOCK,-1,,<empty>,,,,2,,<empty>
34460,BLOCK,-1,,"{
        msg_Err(demux, ""seek failure before probing"");
        return VLC_EGENERIC;
    }",5,,186,2,,void
34481,BLOCK,-1,,"{
    demux_priv_t *priv = vlc_custom_create(p_obj, sizeof (*priv), ""demux"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    if( s != NULL && (!strcasecmp( psz_demux, ""any"" ) || !psz_demux[0]) )
    {   /* Look up demux by mime-type for hard to detect formats */
        char *type = stream_MimeType( s );
        if( type != NULL )
        {
            psz_demux = demux_NameFromMimeType( type );
            free( type );
        }
    }

    p_demux->p_input = p_parent_input;
    p_demux->psz_access = strdup( psz_access );
    p_demux->psz_demux = strdup( psz_demux );
    p_demux->psz_location = strdup( psz_location );
    p_demux->psz_file = get_path( psz_location ); /* parse URL */

    if( unlikely(p_demux->psz_access == NULL
              || p_demux->psz_demux == NULL
              || p_demux->psz_location == NULL) )
        goto error;

    if( !b_preparsing )
        msg_Dbg( p_obj, ""creating demux: access='%s' demux='%s' ""
    ...",1,,203,9,,void
34496,BLOCK,-1,,<empty>,9,,206,2,,void
34520,BLOCK,-1,,"{   /* Look up demux by mime-type for hard to detect formats */
        char *type = stream_MimeType( s );
        if( type != NULL )
        {
            psz_demux = demux_NameFromMimeType( type );
            free( type );
        }
    }",5,,211,2,,void
34530,BLOCK,-1,,"{
            psz_demux = demux_NameFromMimeType( type );
            free( type );
        }",9,,214,2,,void
34585,BLOCK,-1,,<empty>,9,,229,2,,void
34590,BLOCK,-1,,<empty>,9,,232,2,,void
34669,BLOCK,-1,,"{
        const char *psz_module = NULL;

        if( !strcmp( p_demux->psz_demux, ""any"" ) && p_demux->psz_file )
        {
            char const* psz_ext = strrchr( p_demux->psz_file, '.' );

            if( psz_ext )
                psz_module = DemuxNameFromExtension( psz_ext + 1, b_preparsing );
        }

        if( psz_module == NULL )
            psz_module = p_demux->psz_demux;

        p_demux->p_module = vlc_module_load(p_demux, ""demux"", psz_module,
             !strcmp(psz_module, p_demux->psz_demux), demux_Probe, p_demux);
    }",5,,250,2,,void
34685,BLOCK,-1,,"{
            char const* psz_ext = strrchr( p_demux->psz_file, '.' );

            if( psz_ext )
                psz_module = DemuxNameFromExtension( psz_ext + 1, b_preparsing );
        }",9,,254,2,,void
34696,BLOCK,-1,,<empty>,17,,258,2,,void
34708,BLOCK,-1,,<empty>,13,,262,2,,void
34731,BLOCK,-1,,"{
        p_demux->p_module =
            module_need( p_demux, ""access_demux"", p_demux->psz_access, true );
    }",5,,268,1,,void
34749,BLOCK,-1,,<empty>,9,,274,2,,void
34778,BLOCK,-1,,"{
    demux_priv_t *priv = (demux_priv_t *)p_demux;

    module_unneed( p_demux, p_demux->p_module );

    priv->destroy(p_demux);
    free( p_demux->psz_file );
    free( p_demux->psz_location );
    free( p_demux->psz_demux );
    free( p_demux->psz_access );
    vlc_object_release( p_demux );
}",1,,290,2,,void
34818,BLOCK,-1,,"{
    int ret;
    va_list ap;

    va_start( ap, query );
    ret = demux->pf_control( demux, query, ap );
    va_end( ap );
    return ret;
}",1,,307,3,,void
34843,BLOCK,-1,,"{
    if( demux->s != NULL )
        switch( query )
        {
            /* Legacy fallback for missing getters in synchronous demuxers */
            case DEMUX_CAN_PAUSE:
            case DEMUX_CAN_CONTROL_PACE:
            case DEMUX_GET_PTS_DELAY:
            {
                int ret;
                va_list ap;

                va_copy( ap, args );
                ret = demux->pf_control( demux, query, args );
                if( ret != VLC_SUCCESS )
                    ret = vlc_stream_vaControl( demux->s, query, ap );
                va_end( ap );
                return ret;
            }

            /* Some demuxers need to control pause directly (e.g. adaptive),
             * but many legacy demuxers do not understand pause at all.
             * If DEMUX_CAN_PAUSE is not implemented, bypass the demuxer and
             * byte stream. If DEMUX_CAN_PAUSE is implemented and pause is
             * supported, pause the demuxer normally. Else, something went very
         ...",1,,318,4,,void
34850,BLOCK,-1,,<empty>,9,,320,2,,void
34853,BLOCK,-1,,"{
            /* Legacy fallback for missing getters in synchronous demuxers */
            case DEMUX_CAN_PAUSE:
            case DEMUX_CAN_CONTROL_PACE:
            case DEMUX_GET_PTS_DELAY:
            {
                int ret;
                va_list ap;

                va_copy( ap, args );
                ret = demux->pf_control( demux, query, args );
                if( ret != VLC_SUCCESS )
                    ret = vlc_stream_vaControl( demux->s, query, ap );
                va_end( ap );
                return ret;
            }

            /* Some demuxers need to control pause directly (e.g. adaptive),
             * but many legacy demuxers do not understand pause at all.
             * If DEMUX_CAN_PAUSE is not implemented, bypass the demuxer and
             * byte stream. If DEMUX_CAN_PAUSE is implemented and pause is
             * supported, pause the demuxer normally. Else, something went very
             * wrong.
             *
             * Note that this req...",9,,321,2,,void
34860,BLOCK,7,,"{
                int ret;
                va_list ap;

                va_copy( ap, args );
                ret = demux->pf_control( demux, query, args );
                if( ret != VLC_SUCCESS )
                    ret = vlc_stream_vaControl( demux->s, query, ap );
                va_end( ap );
                return ret;
            }",13,,326,7,,void
34879,BLOCK,-1,,<empty>,21,,333,2,,void
34894,BLOCK,10,,"{
                bool can_pause;

                if( demux_ControlInternal( demux, DEMUX_CAN_PAUSE,
                                           &can_pause ) )
                    return vlc_stream_vaControl( demux->s, query, args );

                /* The caller shall not pause if pause is unsupported. */
                assert( can_pause );
                break;
            }",13,,352,10,,void
34902,BLOCK,-1,,<empty>,21,,357,2,,void
34931,BLOCK,-1,,"{
    int64_t i_tell;
    double  f, *pf;
    int64_t i64, *pi64;

    if( i_end < 0 )    i_end   = stream_Size( s );
    if( i_start < 0 )  i_start = 0;
    if( i_align <= 0 ) i_align = 1;
    i_tell = vlc_stream_Tell( s );

    static_control_match(CAN_PAUSE);
    static_control_match(CAN_CONTROL_PACE);
    static_control_match(GET_PTS_DELAY);
    static_control_match(GET_META);
    static_control_match(GET_SIGNAL);
    static_control_match(SET_PAUSE_STATE);

    switch( i_query )
    {
        case DEMUX_CAN_SEEK:
        {
            bool *b = va_arg( args, bool * );

            if( (i_bitrate <= 0 && i_start >= i_end)
             || vlc_stream_Control( s, STREAM_CAN_SEEK, b ) )
                *b = false;
            break;
        }

        case DEMUX_CAN_PAUSE:
        case DEMUX_CAN_CONTROL_PACE:
        case DEMUX_GET_PTS_DELAY:
        case DEMUX_GET_META:
        case DEMUX_GET_SIGNAL:
        case DEMUX_SET_PAUSE_STATE:
            return vlc_stream_vaControl( s, i_q...",1,,375,8,,void
34941,BLOCK,-1,,<empty>,24,,380,2,,void
34950,BLOCK,-1,,<empty>,24,,381,2,,void
34958,BLOCK,-1,,<empty>,24,,382,2,,void
34967,BLOCK,1,,<empty>,,,,1,,void
34976,BLOCK,1,,<empty>,,,,1,,void
34985,BLOCK,1,,<empty>,,,,1,,void
34994,BLOCK,1,,<empty>,,,,1,,void
35003,BLOCK,1,,<empty>,,,,1,,void
35012,BLOCK,1,,<empty>,,,,1,,void
35022,BLOCK,-1,,"{
        case DEMUX_CAN_SEEK:
        {
            bool *b = va_arg( args, bool * );

            if( (i_bitrate <= 0 && i_start >= i_end)
             || vlc_stream_Control( s, STREAM_CAN_SEEK, b ) )
                *b = false;
            break;
        }

        case DEMUX_CAN_PAUSE:
        case DEMUX_CAN_CONTROL_PACE:
        case DEMUX_GET_PTS_DELAY:
        case DEMUX_GET_META:
        case DEMUX_GET_SIGNAL:
        case DEMUX_SET_PAUSE_STATE:
            return vlc_stream_vaControl( s, i_query, args );

        case DEMUX_GET_LENGTH:
            pi64 = (int64_t*)va_arg( args, int64_t * );
            if( i_bitrate > 0 && i_end > i_start )
            {
                *pi64 = INT64_C(8000000) * (i_end - i_start) / i_bitrate;
                return VLC_SUCCESS;
            }
            return VLC_EGENERIC;

        case DEMUX_GET_TIME:
            pi64 = (int64_t*)va_arg( args, int64_t * );
            if( i_bitrate > 0 && i_tell >= i_start )
            {
               ...",5,,393,2,,void
35025,BLOCK,3,,"{
            bool *b = va_arg( args, bool * );

            if( (i_bitrate <= 0 && i_start >= i_end)
             || vlc_stream_Control( s, STREAM_CAN_SEEK, b ) )
                *b = false;
            break;
        }",9,,395,3,,void
35040,BLOCK,-1,,<empty>,17,,400,2,,void
35074,BLOCK,-1,,"{
                *pi64 = INT64_C(8000000) * (i_end - i_start) / i_bitrate;
                return VLC_SUCCESS;
            }",13,,415,2,,void
35101,BLOCK,-1,,"{
                *pi64 = INT64_C(8000000) * (i_tell - i_start) / i_bitrate;
                return VLC_SUCCESS;
            }",13,,424,2,,void
35124,BLOCK,-1,,"{
                *pf = (double)( i_tell - i_start ) /
                      (double)( i_end  - i_start );
                return VLC_SUCCESS;
            }",13,,433,2,,void
35158,BLOCK,-1,,"{
                int64_t i_block = (f * ( i_end - i_start )) / i_align;

                if( vlc_stream_Seek( s, i_start + i_block * i_align ) )
                {
                    return VLC_EGENERIC;
                }
                return VLC_SUCCESS;
            }",13,,444,2,,void
35177,BLOCK,-1,,"{
                    return VLC_EGENERIC;
                }",17,,448,2,,void
35201,BLOCK,-1,,"{
                int64_t i_block = i64 * i_bitrate / INT64_C(8000000) / i_align;
                if( vlc_stream_Seek( s, i_start + i_block * i_align ) )
                {
                    return VLC_EGENERIC;
                }
                return VLC_SUCCESS;
            }",13,,458,2,,void
35221,BLOCK,-1,,"{
                    return VLC_EGENERIC;
                }",17,,461,2,,void
35299,BLOCK,-1,,"{
    decoder_t *p_packetizer;
    p_packetizer = vlc_custom_create( p_demux, sizeof( *p_packetizer ),
                                      ""demux packetizer"" );
    if( !p_packetizer )
    {
        es_format_Clean( p_fmt );
        return NULL;
    }
    p_fmt->b_packetized = false;

    p_packetizer->pf_decode = NULL;
    p_packetizer->pf_packetize = NULL;

    p_packetizer->fmt_in = *p_fmt;
    es_format_Init( &p_packetizer->fmt_out, p_fmt->i_cat, 0 );

    p_packetizer->p_module = module_need( p_packetizer, ""packetizer"", NULL, false );
    if( !p_packetizer->p_module )
    {
        es_format_Clean( p_fmt );
        vlc_object_release( p_packetizer );
        msg_Err( p_demux, ""cannot find packetizer for %s"", psz_msg );
        return NULL;
    }

    return p_packetizer;
}",1,,509,4,,void
35312,BLOCK,-1,,"{
        es_format_Clean( p_fmt );
        return NULL;
    }",5,,514,2,,void
35361,BLOCK,-1,,"{
        es_format_Clean( p_fmt );
        vlc_object_release( p_packetizer );
        msg_Err( p_demux, ""cannot find packetizer for %s"", psz_msg );
        return NULL;
    }",5,,528,2,,void
35378,BLOCK,-1,,"{
    if( p_packetizer->p_module )
        module_unneed( p_packetizer, p_packetizer->p_module );
    es_format_Clean( &p_packetizer->fmt_in );
    es_format_Clean( &p_packetizer->fmt_out );
    if( p_packetizer->p_description )
        vlc_meta_Delete( p_packetizer->p_description );
    vlc_object_release( p_packetizer );
}",1,,539,2,,void
35383,BLOCK,-1,,<empty>,9,,541,2,,void
35403,BLOCK,-1,,<empty>,9,,545,2,,void
35415,BLOCK,-1,,"{
    unsigned update = flags;

    if ( demux_Control( p_demux, DEMUX_TEST_AND_CLEAR_FLAGS, &update ) == VLC_SUCCESS )
        return update;

    update = p_demux->info.i_update & flags;
    p_demux->info.i_update &= ~flags;
    return update;
}",1,,550,3,,void
35428,BLOCK,-1,,<empty>,9,,554,2,,void
35454,BLOCK,-1,,"{
    int i_title;
    if ( demux_Control( p_demux, DEMUX_GET_TITLE, &i_title ) == VLC_SUCCESS )
        return i_title;
    return p_demux->info.i_title;
}",1,,562,2,,void
35464,BLOCK,-1,,<empty>,9,,565,2,,void
35477,BLOCK,-1,,"{
    int i_seekpoint;
    if ( demux_Control( p_demux, DEMUX_GET_SEEKPOINT, &i_seekpoint ) == VLC_SUCCESS  )
        return i_seekpoint;
    return p_demux->info.i_seekpoint;
}",1,,570,2,,void
35487,BLOCK,-1,,<empty>,9,,573,2,,void
35501,BLOCK,-1,,"{
    demux_priv_t *priv = vlc_custom_create(p_next, sizeof (*priv), ""demux_filter"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    p_demux->p_next       = p_next;
    p_demux->p_input      = NULL;
    p_demux->p_sys        = NULL;
    p_demux->psz_access   = NULL;
    p_demux->psz_demux    = NULL;
    p_demux->psz_location = NULL;
    p_demux->psz_file     = NULL;
    p_demux->out          = NULL;
    priv->destroy         = demux_DestroyDemuxFilter;
    p_demux->p_module =
        module_need( p_demux, ""demux_filter"", p_name, p_name != NULL );

    if( p_demux->p_module == NULL )
        goto error;

    return p_demux;
error:
    vlc_object_release( p_demux );
    return NULL;
}",1,,578,3,,void
35516,BLOCK,-1,,<empty>,9,,581,2,,void
35588,BLOCK,-1,,<empty>,9,,598,2,,void
35602,BLOCK,-1,,"{
    if( !psz_chain || !*psz_chain )
        return NULL;

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        demux_t *filter = demux_FilterNew(p_demux, psz_name);
        if (filter != NULL)
            p_demux = filter;

        free(psz_name);
        config_ChainDestroy(p_cfg);
    }

    return p_demux;
}",1,,607,3,,void
35610,BLOCK,-1,,<empty>,9,,609,2,,void
35621,BLOCK,-1,,<empty>,9,,613,2,,void
35626,BLOCK,-1,,"{
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        demux_t *filter = demux_FilterNew(p_demux, psz_name);
        if (filter != NULL)
            p_demux = filter;

        free(psz_name);
        config_ChainDestroy(p_cfg);
    }",5,,617,2,,void
35653,BLOCK,-1,,<empty>,13,,626,2,,void
35669,BLOCK,-1,,"{
    demux_t *p_demux = p_demux_chain;

     if( strcmp( module_get_name( p_demux->p_module, false ), psz_demux) == 0 ||
         strcmp( module_get_name( p_demux->p_module, true ), psz_demux ) == 0 )
     {
        demux_Control( p_demux,
                       b_enable ? DEMUX_FILTER_ENABLE : DEMUX_FILTER_DISABLE );
        return true;
    }
    return false;
}",1,,637,4,,void
35694,BLOCK,-1,,"{
        demux_Control( p_demux,
                       b_enable ? DEMUX_FILTER_ENABLE : DEMUX_FILTER_DISABLE );
        return true;
    }",6,,642,2,,void
35710,BLOCK,-1,,"{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, true );
}",1,,651,3,,void
35721,BLOCK,-1,,"{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, false );
}",1,,656,3,,void
35739,BLOCK,-1,,<empty>,1,,1,1,,ANY
35749,BLOCK,-1,,<empty>,,,,9,,<empty>
35755,BLOCK,-1,,<empty>,,,,3,,<empty>
35760,BLOCK,-1,,<empty>,,,,2,,<empty>
35765,BLOCK,-1,,<empty>,,,,2,,<empty>
35771,BLOCK,-1,,<empty>,,,,3,,<empty>
35779,BLOCK,-1,,<empty>,,,,3,,<empty>
35785,BLOCK,-1,,<empty>,,,,3,,<empty>
35806,BLOCK,-1,,<empty>,1,,1,1,,ANY
35819,BLOCK,-1,,<empty>,,,,1,,<empty>
35825,BLOCK,-1,,"{
    vlc_demux_chained_t *dc = data;
    demux_t *demux = demux_NewAdvanced(dc->fifo, NULL, """", dc->name, """",
                                       dc->fifo, dc->out, false);
    if (demux == NULL)
    {
        vlc_stream_Delete(dc->fifo);
        return NULL;
    }

    /* Stream FIFO cannot apply DVB filters.
     * Get all programs and let the E/S output sort them out. */
    demux_Control(demux, DEMUX_SET_GROUP, -1, NULL);

    /* Main loop */
    mtime_t next_update = 0;

    do
        if (demux_TestAndClearFlags(demux, UINT_MAX) || mdate() >= next_update)
        {
            double newpos;
            int64_t newlen, newtime;

            if (demux_Control(demux, DEMUX_GET_POSITION, &newpos))
                newpos = 0.;
            if (demux_Control(demux, DEMUX_GET_LENGTH, &newlen))
                newlen = 0;
            if (demux_Control(demux, DEMUX_GET_TIME, &newtime))
                newtime = 0;

            vlc_mutex_lock(&dc->lock);
            dc->stats.positi...",1,,54,2,,void
35850,BLOCK,1,,<empty>,,,,13,,void
35873,BLOCK,-1,,"{
        vlc_stream_Delete(dc->fifo);
        return NULL;
    }",5,,59,2,,void
35899,BLOCK,-1,,"{
            double newpos;
            int64_t newlen, newtime;

            if (demux_Control(demux, DEMUX_GET_POSITION, &newpos))
                newpos = 0.;
            if (demux_Control(demux, DEMUX_GET_LENGTH, &newlen))
                newlen = 0;
            if (demux_Control(demux, DEMUX_GET_TIME, &newtime))
                newtime = 0;

            vlc_mutex_lock(&dc->lock);
            dc->stats.position = newpos;
            dc->stats.length = newlen;
            dc->stats.time = newtime;
            vlc_mutex_unlock(&dc->lock);

            next_update = mdate() + (CLOCK_FREQ / 4);
        }",9,,73,2,,void
35909,BLOCK,-1,,<empty>,17,,78,2,,void
35919,BLOCK,-1,,<empty>,17,,80,2,,void
35929,BLOCK,-1,,<empty>,17,,82,2,,void
35985,BLOCK,-1,,"{
    vlc_demux_chained_t *dc = malloc(sizeof (*dc) + strlen(name) + 1);
    if (unlikely(dc == NULL))
        return NULL;

    dc->fifo = vlc_stream_fifo_New(parent);
    if (dc->fifo == NULL)
    {
        free(dc);
        return NULL;
    }

    dc->stats.position = 0.;
    dc->stats.length = 0;
    dc->stats.time = 0;
    dc->out = out;
    strcpy(dc->name, name);

    vlc_mutex_init(&dc->lock);

    if (vlc_clone(&dc->thread, vlc_demux_chained_Thread, dc,
                  VLC_THREAD_PRIORITY_INPUT))
    {
        vlc_stream_Delete(dc->fifo);
        vlc_stream_fifo_Close(dc->fifo);
        vlc_mutex_destroy(&dc->lock);
        free(dc);
        dc = NULL;
    }
    return dc;
}",1,,100,4,,void
36003,BLOCK,-1,,<empty>,9,,103,2,,void
36018,BLOCK,-1,,"{
        free(dc);
        return NULL;
    }",5,,107,2,,void
36068,BLOCK,-1,,"{
        vlc_stream_Delete(dc->fifo);
        vlc_stream_fifo_Close(dc->fifo);
        vlc_mutex_destroy(&dc->lock);
        free(dc);
        dc = NULL;
    }",5,,122,2,,void
36094,BLOCK,-1,,"{
    vlc_stream_fifo_Queue(dc->fifo, block);
}",1,,133,3,,void
36106,BLOCK,-1,,"{
    switch (query)
    {
        case DEMUX_GET_POSITION:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, double *) = dc->stats.position;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_LENGTH:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.length;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_TIME:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.time;
            vlc_mutex_unlock(&dc->lock);
            break;
        default:
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,,138,4,,void
36109,BLOCK,-1,,"{
        case DEMUX_GET_POSITION:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, double *) = dc->stats.position;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_LENGTH:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.length;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_TIME:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.time;
            vlc_mutex_unlock(&dc->lock);
            break;
        default:
            return VLC_EGENERIC;
    }",5,,140,2,,void
36161,BLOCK,-1,,"{
    vlc_stream_fifo_Close(dc->fifo);
    vlc_join(dc->thread, NULL);
    vlc_mutex_destroy(&dc->lock);
    free(dc);
}",1,,163,2,,void
36224,BLOCK,-1,,<empty>,1,,1,1,,ANY
36250,BLOCK,-1,,<empty>,,,,1,,<empty>
36302,BLOCK,-1,,<empty>,,,,3,,<empty>
36309,BLOCK,-1,,<empty>,,,,4,,<empty>
36315,BLOCK,-1,,<empty>,,,,3,,<empty>
36322,BLOCK,-1,,<empty>,,,,4,,<empty>
36327,BLOCK,-1,,<empty>,,,,2,,<empty>
36332,BLOCK,-1,,<empty>,,,,2,,<empty>
36339,BLOCK,-1,,<empty>,,,,4,,<empty>
36347,BLOCK,-1,,<empty>,,,,5,,<empty>
36353,BLOCK,-1,,<empty>,,,,3,,<empty>
36358,BLOCK,-1,,<empty>,,,,2,,<empty>
36364,BLOCK,-1,,<empty>,,,,3,,<empty>
36370,BLOCK,-1,,<empty>,,,,3,,<empty>
36377,BLOCK,-1,,<empty>,,,,4,,<empty>
36383,BLOCK,-1,,<empty>,,,,3,,<empty>
36390,BLOCK,-1,,<empty>,,,,4,,<empty>
36397,BLOCK,-1,,<empty>,,,,4,,<empty>
36402,BLOCK,-1,,<empty>,,,,2,,<empty>
36408,BLOCK,-1,,<empty>,,,,3,,<empty>
36414,BLOCK,-1,,<empty>,,,,3,,<empty>
36421,BLOCK,-1,,<empty>,,,,4,,<empty>
36426,BLOCK,-1,,<empty>,,,,2,,<empty>
36431,BLOCK,-1,,<empty>,,,,2,,<empty>
36436,BLOCK,-1,,<empty>,,,,2,,<empty>
36442,BLOCK,-1,,<empty>,,,,3,,<empty>
36447,BLOCK,-1,,<empty>,,,,2,,<empty>
36452,BLOCK,-1,,<empty>,,,,2,,<empty>
36457,BLOCK,-1,,"{
    int i_channel;
    if( p_fmt->i_codec == VLC_CODEC_CEA608 && p_fmt->subs.cc.i_channel < 4 )
        i_channel = p_fmt->subs.cc.i_channel;
    else if( p_fmt->i_codec == VLC_CODEC_CEA708 && p_fmt->subs.cc.i_channel < 64 )
        i_channel = p_fmt->subs.cc.i_channel;
    else
        i_channel = -1;
    return i_channel;
}",1,,216,2,,void
36475,BLOCK,-1,,<empty>,9,,219,2,,void
36486,BLOCK,-1,,<empty>,10,,220,1,,void
36503,BLOCK,-1,,<empty>,9,,221,2,,void
36514,BLOCK,-1,,<empty>,9,,223,1,,void
36525,BLOCK,-1,,"{
    return p_fmt->i_cat == SPU_ES && p_fmt->i_codec == VLC_CODEC_TELETEXT;
}",1,,227,2,,void
36543,BLOCK,-1,,"{
    switch( i_cat )
    {
    case AUDIO_ES:
        return &p_sys->audio;
    case SPU_ES:
        return &p_sys->sub;
    case VIDEO_ES:
        return &p_sys->video;
    }
    return NULL;
}",1,,235,3,,void
36546,BLOCK,-1,,"{
    case AUDIO_ES:
        return &p_sys->audio;
    case SPU_ES:
        return &p_sys->sub;
    case VIDEO_ES:
        return &p_sys->video;
    }",5,,237,2,,void
36574,BLOCK,-1,,"{
    if( p_props->ppsz_language )
    {
        for( int i = 0; p_props->ppsz_language[i]; i++ )
            free( p_props->ppsz_language[i] );
        free( p_props->ppsz_language );
    }
}",1,,249,2,,void
36579,BLOCK,-1,,"{
        for( int i = 0; p_props->ppsz_language[i]; i++ )
            free( p_props->ppsz_language[i] );
        free( p_props->ppsz_language );
    }",5,,251,2,,void
36581,BLOCK,-1,,<empty>,9,,252,1,,void
36614,BLOCK,-1,,"{
    p_props->e_policy = e_default_policy;
    p_props->i_count = 0;
    p_props->b_autoselect = autoselect;
    p_props->i_id = (psz_trackidvar) ? var_GetInteger( p_input, psz_trackidvar ): -1;
    p_props->i_channel = (psz_trackvar) ? var_GetInteger( p_input, psz_trackvar ): -1;
    p_props->i_demux_id = -1;
    p_props->p_main_es = NULL;

    if( !input_priv(p_input)->b_preparsing && psz_langvar )
    {
        char *psz_string = var_GetString( p_input, psz_langvar );
        p_props->ppsz_language = LanguageSplit( psz_string );
        if( p_props->ppsz_language )
        {
            for( int i = 0; p_props->ppsz_language[i]; i++ )
                msg_Dbg( p_input, ""selected %s language[%d] %s"",
                         psz_debug, i, p_props->ppsz_language[i] );
        }
        free( psz_string );
    }
}",1,,266,9,,void
36671,BLOCK,-1,,"{
        char *psz_string = var_GetString( p_input, psz_langvar );
        p_props->ppsz_language = LanguageSplit( psz_string );
        if( p_props->ppsz_language )
        {
            for( int i = 0; p_props->ppsz_language[i]; i++ )
                msg_Dbg( p_input, ""selected %s language[%d] %s"",
                         psz_debug, i, p_props->ppsz_language[i] );
        }
        free( psz_string );
    }",5,,276,2,,void
36688,BLOCK,-1,,"{
            for( int i = 0; p_props->ppsz_language[i]; i++ )
                msg_Dbg( p_input, ""selected %s language[%d] %s"",
                         psz_debug, i, p_props->ppsz_language[i] );
        }",9,,280,2,,void
36690,BLOCK,-1,,<empty>,13,,281,1,,void
36719,BLOCK,-1,,"{
    es_out_t     *out = malloc( sizeof( *out ) );
    if( !out )
        return NULL;

    es_out_sys_t *p_sys = calloc( 1, sizeof( *p_sys ) );
    if( !p_sys )
    {
        free( out );
        return NULL;
    }

    out->pf_add     = EsOutAdd;
    out->pf_send    = EsOutSend;
    out->pf_del     = EsOutDel;
    out->pf_control = EsOutControl;
    out->pf_destroy = EsOutDelete;
    out->p_sys      = p_sys;

    vlc_mutex_init_recursive( &p_sys->lock );
    p_sys->p_input = p_input;

    p_sys->b_active = false;
    p_sys->i_mode   = ES_OUT_MODE_NONE;

    TAB_INIT( p_sys->i_pgrm, p_sys->pgrm );

    TAB_INIT( p_sys->i_es, p_sys->es );

    /* */
    EsOutPropsInit( &p_sys->video, true, p_input, ES_OUT_ES_POLICY_SIMULTANEOUS,
                    NULL, NULL, NULL, NULL );
    EsOutPropsInit( &p_sys->audio, true, p_input, ES_OUT_ES_POLICY_EXCLUSIVE,
                    ""audio-track-id"", ""audio-track"", ""audio-language"", ""audio"" );
    EsOutPropsInit( &p_sys->sub,  false, p_input, E...",1,,293,3,,void
36730,BLOCK,-1,,<empty>,9,,296,2,,void
36744,BLOCK,-1,,"{
        free( out );
        return NULL;
    }",5,,300,2,,void
36890,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    assert( !p_sys->i_es && !p_sys->i_pgrm && !p_sys->p_pgrm );
    EsOutPropsCleanup( &p_sys->audio );
    EsOutPropsCleanup( &p_sys->sub );

    vlc_mutex_destroy( &p_sys->lock );

    free( p_sys );
    free( out );
}",1,,347,2,,void
36935,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    if( p_sys->p_sout_record )
        EsOutSetRecord( out, false );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_dec )
            input_DecoderDelete( p_sys->es[i]->p_dec );

        free( p_sys->es[i]->psz_language );
        free( p_sys->es[i]->psz_language_code );
        es_format_Clean( &p_sys->es[i]->fmt );

        free( p_sys->es[i] );
    }
    TAB_CLEAN( p_sys->i_es, p_sys->es );

    /* FIXME duplicate work EsOutProgramDel (but we cannot use it) add a EsOutProgramClean ? */
    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        es_out_pgrm_t *p_pgrm = p_sys->pgrm[i];
        input_clock_Delete( p_pgrm->p_clock );
        if( p_pgrm->p_meta )
            vlc_meta_Delete( p_pgrm->p_meta );

        free( p_pgrm );
    }
    TAB_CLEAN( p_sys->i_pgrm, p_sys->pgrm );

    p_sys->p_pgrm = NULL;

    input_item_SetEpgOffline( input_priv(p_sys->p_input)->p_item );
    input_SendEventMetaEpg( p_sys->p_...",1,,361,2,,void
36946,BLOCK,-1,,<empty>,9,,365,2,,void
36951,BLOCK,-1,,<empty>,5,,367,1,,void
36963,BLOCK,4,,"{
        if( p_sys->es[i]->p_dec )
            input_DecoderDelete( p_sys->es[i]->p_dec );

        free( p_sys->es[i]->psz_language );
        free( p_sys->es[i]->psz_language_code );
        es_format_Clean( &p_sys->es[i]->fmt );

        free( p_sys->es[i] );
    }",5,,368,4,,void
36972,BLOCK,-1,,<empty>,13,,370,2,,void
37020,BLOCK,-1,,<empty>,5,,381,1,,void
37032,BLOCK,4,,"{
        es_out_pgrm_t *p_pgrm = p_sys->pgrm[i];
        input_clock_Delete( p_pgrm->p_clock );
        if( p_pgrm->p_meta )
            vlc_meta_Delete( p_pgrm->p_meta );

        free( p_pgrm );
    }",5,,382,4,,void
37049,BLOCK,-1,,<empty>,13,,386,2,,void
37083,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !p_sys->p_pgrm )
        return 0;

    /* We do not have a wake up date if the input cannot have its speed
     * controlled or sout is imposing its own or while buffering
     *
     * FIXME for !input_priv(p_input)->b_can_pace_control a wake-up time is still needed
     * to avoid too heavy buffering */
    if( !input_priv(p_input)->b_can_pace_control ||
        input_priv(p_input)->b_out_pace_control ||
        p_sys->b_buffering )
        return 0;

    return input_clock_GetWakeup( p_sys->p_pgrm->p_clock );
}",1,,399,2,,void
37101,BLOCK,-1,,<empty>,9,,404,2,,void
37119,BLOCK,-1,,<empty>,9,,414,2,,void
37137,BLOCK,-1,,"{
    if( i_id < 0 )
    {
        /* Special HACK, -i_id is the cat of the stream */
        return es_cat - i_id;
    }

    for( int i = 0; i < out->p_sys->i_es; i++ )
    {
        if( out->p_sys->es[i]->i_id == i_id )
            return out->p_sys->es[i];
    }
    return NULL;
}",1,,422,3,,void
37142,BLOCK,-1,,"{
        /* Special HACK, -i_id is the cat of the stream */
        return es_cat - i_id;
    }",5,,424,2,,void
37148,BLOCK,-1,,<empty>,5,,429,1,,void
37162,BLOCK,4,,"{
        if( out->p_sys->es[i]->i_id == i_id )
            return out->p_sys->es[i];
    }",5,,430,4,,void
37175,BLOCK,-1,,<empty>,13,,432,2,,void
37190,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;

    if( p_sys->b_buffering && p_sys->p_pgrm )
    {
        EsOutDecodersStopBuffering( out, true );
        if( p_sys->b_buffering )
            return true;
    }

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec && !input_DecoderIsEmpty( es->p_dec ) )
            return false;
        if( es->p_dec_record && !input_DecoderIsEmpty( es->p_dec_record ) )
            return false;
    }
    return true;
}",1,,438,2,,void
37205,BLOCK,-1,,"{
        EsOutDecodersStopBuffering( out, true );
        if( p_sys->b_buffering )
            return true;
    }",5,,442,2,,void
37213,BLOCK,-1,,<empty>,13,,445,2,,void
37217,BLOCK,-1,,<empty>,5,,448,1,,void
37229,BLOCK,4,,"{
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec && !input_DecoderIsEmpty( es->p_dec ) )
            return false;
        if( es->p_dec_record && !input_DecoderIsEmpty( es->p_dec_record ) )
            return false;
    }",5,,449,4,,void
37248,BLOCK,-1,,<empty>,13,,453,2,,void
37261,BLOCK,-1,,<empty>,13,,455,2,,void
37272,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    if( i_cat == AUDIO_ES )
        p_sys->i_audio_delay = i_delay;
    else if( i_cat == SPU_ES )
        p_sys->i_spu_delay = i_delay;

    for( int i = 0; i < p_sys->i_es; i++ )
        EsOutDecoderChangeDelay( out, p_sys->es[i] );
}",1,,461,4,,void
37283,BLOCK,-1,,<empty>,9,,465,2,,void
37290,BLOCK,-1,,<empty>,10,,466,1,,void
37295,BLOCK,-1,,<empty>,9,,467,2,,void
37302,BLOCK,-1,,<empty>,5,,469,1,,void
37326,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    assert( ( b_record && !p_sys->p_sout_record ) || ( !b_record && p_sys->p_sout_record ) );

    if( b_record )
    {
        char *psz_path = var_CreateGetNonEmptyString( p_input, ""input-record-path"" );
        if( !psz_path )
        {
            if( var_CountChoices( p_input, ""video-es"" ) )
                psz_path = config_GetUserDir( VLC_VIDEOS_DIR );
            else if( var_CountChoices( p_input, ""audio-es"" ) )
                psz_path = config_GetUserDir( VLC_MUSIC_DIR );
            else
                psz_path = config_GetUserDir( VLC_DOWNLOAD_DIR );
        }

        char *psz_sout = NULL;  // TODO conf

        if( !psz_sout && psz_path )
        {
            char *psz_file = input_CreateFilename( p_input, psz_path, INPUT_RECORD_PREFIX, NULL );
            if( psz_file )
            {
                char* psz_file_esc = config_StringEscape( psz_file );
                if ( psz...",1,,474,3,,void
37355,BLOCK,-1,,"{
        char *psz_path = var_CreateGetNonEmptyString( p_input, ""input-record-path"" );
        if( !psz_path )
        {
            if( var_CountChoices( p_input, ""video-es"" ) )
                psz_path = config_GetUserDir( VLC_VIDEOS_DIR );
            else if( var_CountChoices( p_input, ""audio-es"" ) )
                psz_path = config_GetUserDir( VLC_MUSIC_DIR );
            else
                psz_path = config_GetUserDir( VLC_DOWNLOAD_DIR );
        }

        char *psz_sout = NULL;  // TODO conf

        if( !psz_sout && psz_path )
        {
            char *psz_file = input_CreateFilename( p_input, psz_path, INPUT_RECORD_PREFIX, NULL );
            if( psz_file )
            {
                char* psz_file_esc = config_StringEscape( psz_file );
                if ( psz_file_esc )
                {
                    if( asprintf( &psz_sout, ""#record{dst-prefix='%s'}"", psz_file_esc ) < 0 )
                        psz_sout = NULL;
                    free( psz_file_esc );
...",5,,481,2,,void
37365,BLOCK,-1,,"{
            if( var_CountChoices( p_input, ""video-es"" ) )
                psz_path = config_GetUserDir( VLC_VIDEOS_DIR );
            else if( var_CountChoices( p_input, ""audio-es"" ) )
                psz_path = config_GetUserDir( VLC_MUSIC_DIR );
            else
                psz_path = config_GetUserDir( VLC_DOWNLOAD_DIR );
        }",9,,484,2,,void
37370,BLOCK,-1,,<empty>,17,,486,2,,void
37376,BLOCK,-1,,<empty>,18,,487,1,,void
37381,BLOCK,-1,,<empty>,17,,488,2,,void
37387,BLOCK,-1,,<empty>,17,,490,1,,void
37401,BLOCK,-1,,"{
            char *psz_file = input_CreateFilename( p_input, psz_path, INPUT_RECORD_PREFIX, NULL );
            if( psz_file )
            {
                char* psz_file_esc = config_StringEscape( psz_file );
                if ( psz_file_esc )
                {
                    if( asprintf( &psz_sout, ""#record{dst-prefix='%s'}"", psz_file_esc ) < 0 )
                        psz_sout = NULL;
                    free( psz_file_esc );
                }
                free( psz_file );
            }
        }",9,,496,2,,void
37412,BLOCK,-1,,"{
                char* psz_file_esc = config_StringEscape( psz_file );
                if ( psz_file_esc )
                {
                    if( asprintf( &psz_sout, ""#record{dst-prefix='%s'}"", psz_file_esc ) < 0 )
                        psz_sout = NULL;
                    free( psz_file_esc );
                }
                free( psz_file );
            }",13,,499,2,,void
37420,BLOCK,-1,,"{
                    if( asprintf( &psz_sout, ""#record{dst-prefix='%s'}"", psz_file_esc ) < 0 )
                        psz_sout = NULL;
                    free( psz_file_esc );
                }",17,,502,2,,void
37429,BLOCK,-1,,<empty>,25,,504,2,,void
37442,BLOCK,-1,,<empty>,13,,513,2,,void
37452,BLOCK,-1,,<empty>,13,,521,2,,void
37456,BLOCK,-1,,<empty>,9,,523,1,,void
37468,BLOCK,4,,"{
            es_out_id_t *p_es = p_sys->es[i];

            if( !p_es->p_dec || p_es->p_master )
                continue;

            p_es->p_dec_record = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_sys->p_sout_record );
            if( p_es->p_dec_record && p_sys->b_buffering )
                input_DecoderStartWait( p_es->p_dec_record );
        }",9,,524,4,,void
37486,BLOCK,-1,,<empty>,17,,528,2,,void
37514,BLOCK,-1,,<empty>,17,,532,2,,void
37520,BLOCK,-1,,"{
        for( int i = 0; i < p_sys->i_es; i++ )
        {
            es_out_id_t *p_es = p_sys->es[i];

            if( !p_es->p_dec_record )
                continue;

            input_DecoderDelete( p_es->p_dec_record );
            p_es->p_dec_record = NULL;
        }
#ifdef ENABLE_SOUT
        sout_DeleteInstance( p_sys->p_sout_record );
#endif
        p_sys->p_sout_record = NULL;
    }",5,,536,1,,void
37522,BLOCK,-1,,<empty>,9,,537,1,,void
37534,BLOCK,4,,"{
            es_out_id_t *p_es = p_sys->es[i];

            if( !p_es->p_dec_record )
                continue;

            input_DecoderDelete( p_es->p_dec_record );
            p_es->p_dec_record = NULL;
        }",9,,538,4,,void
37548,BLOCK,-1,,<empty>,17,,542,2,,void
37572,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    /* XXX the order is important */
    if( b_paused )
    {
        EsOutDecodersChangePause( out, true, i_date );
        EsOutProgramChangePause( out, true, i_date );
    }
    else
    {
        if( p_sys->i_buffering_extra_initial > 0 )
        {
            mtime_t i_stream_start;
            mtime_t i_system_start;
            mtime_t i_stream_duration;
            mtime_t i_system_duration;
            int i_ret;
            i_ret = input_clock_GetState( p_sys->p_pgrm->p_clock,
                                          &i_stream_start, &i_system_start,
                                          &i_stream_duration, &i_system_duration );
            if( !i_ret )
            {
                /* FIXME pcr != exactly what wanted */
                const mtime_t i_used = /*(i_stream_duration - input_priv(p_sys->p_input)->i_pts_delay)*/ p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
                i_date -= i_used;
   ...",1,,556,4,,void
37581,BLOCK,-1,,"{
        EsOutDecodersChangePause( out, true, i_date );
        EsOutProgramChangePause( out, true, i_date );
    }",5,,561,2,,void
37591,BLOCK,-1,,"{
        if( p_sys->i_buffering_extra_initial > 0 )
        {
            mtime_t i_stream_start;
            mtime_t i_system_start;
            mtime_t i_stream_duration;
            mtime_t i_system_duration;
            int i_ret;
            i_ret = input_clock_GetState( p_sys->p_pgrm->p_clock,
                                          &i_stream_start, &i_system_start,
                                          &i_stream_duration, &i_system_duration );
            if( !i_ret )
            {
                /* FIXME pcr != exactly what wanted */
                const mtime_t i_used = /*(i_stream_duration - input_priv(p_sys->p_input)->i_pts_delay)*/ p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
                i_date -= i_used;
            }
            p_sys->i_buffering_extra_initial = 0;
            p_sys->i_buffering_extra_stream = 0;
            p_sys->i_buffering_extra_system = 0;
        }
        EsOutProgramChangePause( out, false, i_date );
       ...",5,,566,1,,void
37598,BLOCK,-1,,"{
            mtime_t i_stream_start;
            mtime_t i_system_start;
            mtime_t i_stream_duration;
            mtime_t i_system_duration;
            int i_ret;
            i_ret = input_clock_GetState( p_sys->p_pgrm->p_clock,
                                          &i_stream_start, &i_system_start,
                                          &i_stream_duration, &i_system_duration );
            if( !i_ret )
            {
                /* FIXME pcr != exactly what wanted */
                const mtime_t i_used = /*(i_stream_duration - input_priv(p_sys->p_input)->i_pts_delay)*/ p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
                i_date -= i_used;
            }
            p_sys->i_buffering_extra_initial = 0;
            p_sys->i_buffering_extra_stream = 0;
            p_sys->i_buffering_extra_system = 0;
        }",9,,568,2,,void
37623,BLOCK,-1,,"{
                /* FIXME pcr != exactly what wanted */
                const mtime_t i_used = /*(i_stream_duration - input_priv(p_sys->p_input)->i_pts_delay)*/ p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
                i_date -= i_used;
            }",13,,578,2,,void
37677,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;

    p_sys->i_rate = i_rate;
    EsOutProgramsChangeRate( out );
}",1,,597,3,,void
37695,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;

    input_SendEventCache( p_sys->p_input, 0.0 );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec != NULL )
        {
            input_DecoderFlush( p_es->p_dec );
            if( !p_sys->b_buffering )
            {
                input_DecoderStartWait( p_es->p_dec );
                if( p_es->p_dec_record != NULL )
                    input_DecoderStartWait( p_es->p_dec_record );
            }
        }
        p_es->i_pts_level = VLC_TS_INVALID;
    }

    for( int i = 0; i < p_sys->i_pgrm; i++ ) {
        input_clock_Reset( p_sys->pgrm[i]->p_clock );
        p_sys->pgrm[i]->i_last_pcr = VLC_TS_INVALID;
    }

    p_sys->b_buffering = true;
    p_sys->i_buffering_extra_initial = 0;
    p_sys->i_buffering_extra_stream = 0;
    p_sys->i_buffering_extra_system = 0;
    p_sys->i_preroll_end = -1;
    p_sys->i_prev_stream_level = -1;
}",1,,605,2,,void
37708,BLOCK,-1,,<empty>,5,,610,1,,void
37720,BLOCK,4,,"{
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec != NULL )
        {
            input_DecoderFlush( p_es->p_dec );
            if( !p_sys->b_buffering )
            {
                input_DecoderStartWait( p_es->p_dec );
                if( p_es->p_dec_record != NULL )
                    input_DecoderStartWait( p_es->p_dec_record );
            }
        }
        p_es->i_pts_level = VLC_TS_INVALID;
    }",5,,611,4,,void
37735,BLOCK,-1,,"{
            input_DecoderFlush( p_es->p_dec );
            if( !p_sys->b_buffering )
            {
                input_DecoderStartWait( p_es->p_dec );
                if( p_es->p_dec_record != NULL )
                    input_DecoderStartWait( p_es->p_dec_record );
            }
        }",9,,615,2,,void
37745,BLOCK,-1,,"{
                input_DecoderStartWait( p_es->p_dec );
                if( p_es->p_dec_record != NULL )
                    input_DecoderStartWait( p_es->p_dec_record );
            }",13,,618,2,,void
37756,BLOCK,-1,,<empty>,21,,621,2,,void
37767,BLOCK,-1,,<empty>,5,,627,1,,void
37779,BLOCK,4,,"{
        input_clock_Reset( p_sys->pgrm[i]->p_clock );
        p_sys->pgrm[i]->i_last_pcr = VLC_TS_INVALID;
    }",46,,627,4,,void
37834,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_stream_start;
    mtime_t i_system_start;
    mtime_t i_stream_duration;
    mtime_t i_system_duration;
    if (input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ))
        return;

    mtime_t i_preroll_duration = 0;
    if( p_sys->i_preroll_end >= 0 )
        i_preroll_duration = __MAX( p_sys->i_preroll_end - i_stream_start, 0 );

    const mtime_t i_buffering_duration = p_sys->i_pts_delay +
                                         i_preroll_duration +
                                         p_sys->i_buffering_extra_stream - p_sys->i_buffering_extra_initial;

    if( i_stream_duration <= i_buffering_duration && !b_forced )
    {
        double f_level;
        if (i_buffering_duration == 0)
            f_level = 0;
        else
            f_level = __MAX( (double)i_stream_duration / i_buffe...",1,,643,3,,void
37860,BLOCK,-1,,<empty>,9,,653,2,,void
37872,BLOCK,-1,,<empty>,9,,657,2,,void
37905,BLOCK,-1,,"{
        double f_level;
        if (i_buffering_duration == 0)
            f_level = 0;
        else
            f_level = __MAX( (double)i_stream_duration / i_buffering_duration, 0 );
        input_SendEventCache( p_sys->p_input, f_level );

        int i_level = (int)(100 * f_level);
        if( p_sys->i_prev_stream_level != i_level )
        {
            msg_Dbg( p_sys->p_input, ""Buffering %d%%"", i_level );
            p_sys->i_prev_stream_level = i_level;
        }

        return;
    }",5,,664,2,,void
37911,BLOCK,-1,,<empty>,13,,667,2,,void
37916,BLOCK,-1,,<empty>,13,,669,1,,void
37945,BLOCK,-1,,"{
            msg_Dbg( p_sys->p_input, ""Buffering %d%%"", i_level );
            p_sys->i_prev_stream_level = i_level;
        }",9,,674,2,,void
38001,BLOCK,-1,,"{
        /* FIXME wrong ? */
        return;
    }",5,,690,2,,void
38008,BLOCK,-1,,<empty>,5,,696,1,,void
38020,BLOCK,4,,"{
        es_out_id_t *p_es = p_sys->es[i];

        if( !p_es->p_dec || p_es->fmt.i_cat == SPU_ES )
            continue;
        input_DecoderWait( p_es->p_dec );
        if( p_es->p_dec_record )
            input_DecoderWait( p_es->p_dec_record );
    }",5,,697,4,,void
38042,BLOCK,-1,,<empty>,13,,701,2,,void
38052,BLOCK,-1,,<empty>,13,,704,2,,void
38106,BLOCK,-1,,<empty>,5,,720,1,,void
38118,BLOCK,4,,"{
        es_out_id_t *p_es = p_sys->es[i];

        if( !p_es->p_dec )
            continue;

        input_DecoderStopWait( p_es->p_dec );
        if( p_es->p_dec_record )
            input_DecoderStopWait( p_es->p_dec_record );
    }",5,,721,4,,void
38132,BLOCK,-1,,<empty>,13,,725,2,,void
38142,BLOCK,-1,,<empty>,13,,729,2,,void
38153,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    /* Pause decoders first */
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec )
        {
            input_DecoderChangePause( es->p_dec, b_paused, i_date );
            if( es->p_dec_record )
                input_DecoderChangePause( es->p_dec_record, b_paused, i_date );
        }
    }
}",1,,733,4,,void
38161,BLOCK,-1,,<empty>,5,,737,1,,void
38173,BLOCK,4,,"{
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec )
        {
            input_DecoderChangePause( es->p_dec, b_paused, i_date );
            if( es->p_dec_record )
                input_DecoderChangePause( es->p_dec_record, b_paused, i_date );
        }
    }",5,,738,4,,void
38186,BLOCK,-1,,"{
            input_DecoderChangePause( es->p_dec, b_paused, i_date );
            if( es->p_dec_record )
                input_DecoderChangePause( es->p_dec_record, b_paused, i_date );
        }",9,,742,2,,void
38197,BLOCK,-1,,<empty>,17,,745,2,,void
38208,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    size_t i_size = 0;
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec )
            i_size += input_DecoderGetFifoSize( p_es->p_dec );
        if( p_es->p_dec_record )
            i_size += input_DecoderGetFifoSize( p_es->p_dec_record );
    }
    //msg_Info( out, ""----- EsOutIsExtraBufferingAllowed =% 5d KiB -- "", i_size / 1024 );

    /* TODO maybe we want to be able to tune it ? */
#if defined(OPTIMIZE_MEMORY)
    const size_t i_level_high = 512*1024;  /* 0.5 MiB */
#else
    const size_t i_level_high = 10*1024*1024; /* 10 MiB */
#endif
    return i_size < i_level_high;
}",1,,751,2,,void
38220,BLOCK,-1,,<empty>,5,,755,1,,void
38232,BLOCK,4,,"{
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec )
            i_size += input_DecoderGetFifoSize( p_es->p_dec );
        if( p_es->p_dec_record )
            i_size += input_DecoderGetFifoSize( p_es->p_dec_record );
    }",5,,756,4,,void
38245,BLOCK,-1,,<empty>,13,,760,2,,void
38256,BLOCK,-1,,<empty>,13,,762,2,,void
38281,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangePause( p_sys->pgrm[i]->p_clock, b_paused, i_date );
}",1,,776,4,,void
38289,BLOCK,-1,,<empty>,5,,779,1,,void
38316,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_delay = 0;
    if( p_es->fmt.i_cat == AUDIO_ES )
        i_delay = p_sys->i_audio_delay;
    else if( p_es->fmt.i_cat == SPU_ES )
        i_delay = p_sys->i_spu_delay;
    else
        return;

    if( p_es->p_dec )
        input_DecoderChangeDelay( p_es->p_dec, i_delay );
    if( p_es->p_dec_record )
        input_DecoderChangeDelay( p_es->p_dec_record, i_delay );
}",1,,784,3,,void
38335,BLOCK,-1,,<empty>,9,,789,2,,void
38342,BLOCK,-1,,<empty>,10,,790,1,,void
38351,BLOCK,-1,,<empty>,9,,791,2,,void
38358,BLOCK,-1,,<empty>,9,,793,1,,void
38364,BLOCK,-1,,<empty>,9,,796,2,,void
38374,BLOCK,-1,,<empty>,9,,798,2,,void
38384,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangeRate( p_sys->pgrm[i]->p_clock, p_sys->i_rate );
}",1,,801,2,,void
38392,BLOCK,-1,,<empty>,5,,804,1,,void
38419,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;
    es_out_id_t *p_es_video = NULL;

    if( p_sys->b_buffering )
    {
        msg_Warn( p_sys->p_input, ""buffering, ignoring 'frame next'"" );
        return;
    }

    assert( p_sys->b_paused );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->fmt.i_cat == VIDEO_ES && p_es->p_dec )
        {
            p_es_video = p_es;
            break;
        }
    }

    if( !p_es_video )
    {
        msg_Warn( p_sys->p_input, ""No video track selected, ignoring 'frame next'"" );
        return;
    }

    mtime_t i_duration;
    input_DecoderFrameNext( p_es_video->p_dec, &i_duration );

    msg_Dbg( out->p_sys->p_input, ""EsOutFrameNext consummed %d ms"", (int)(i_duration/1000) );

    if( i_duration <= 0 )
        i_duration = 40*1000;

    /* FIXME it is not a clean way ? */
    if( p_sys->i_buffering_extra_initial <= 0 )
    {
        mtime_t i_stream_start;
        mtime_t i_system_start...",1,,809,2,,void
38434,BLOCK,-1,,"{
        msg_Warn( p_sys->p_input, ""buffering, ignoring 'frame next'"" );
        return;
    }",5,,814,2,,void
38446,BLOCK,-1,,<empty>,5,,821,1,,void
38458,BLOCK,4,,"{
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->fmt.i_cat == VIDEO_ES && p_es->p_dec )
        {
            p_es_video = p_es;
            break;
        }
    }",5,,822,4,,void
38479,BLOCK,-1,,"{
            p_es_video = p_es;
            break;
        }",9,,826,2,,void
38487,BLOCK,-1,,"{
        msg_Warn( p_sys->p_input, ""No video track selected, ignoring 'frame next'"" );
        return;
    }",5,,833,2,,void
38517,BLOCK,-1,,<empty>,9,,844,2,,void
38529,BLOCK,-1,,"{
        mtime_t i_stream_start;
        mtime_t i_system_start;
        mtime_t i_stream_duration;
        mtime_t i_system_duration;
        int i_ret;

        i_ret = input_clock_GetState( p_sys->p_pgrm->p_clock,
                                      &i_stream_start, &i_system_start,
                                      &i_stream_duration, &i_system_duration );
        if( i_ret )
            return;

        p_sys->i_buffering_extra_initial = 1 + i_stream_duration - p_sys->i_pts_delay; /* FIXME < 0 ? */
        p_sys->i_buffering_extra_system =
        p_sys->i_buffering_extra_stream = p_sys->i_buffering_extra_initial;
    }",5,,848,2,,void
38553,BLOCK,-1,,<empty>,13,,859,2,,void
38631,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;
    mtime_t i_stream_duration, i_system_start;

    if( !p_sys->p_pgrm )
        return 0;
    else
    {
        mtime_t i_stream_start, i_system_duration;

        if( input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ) )
            return 0;
    }

    mtime_t i_delay;

    if( p_sys->b_buffering && p_sys->i_buffering_extra_initial <= 0 )
    {
        i_delay = i_stream_duration;
    }
    else
    {
        mtime_t i_system_duration;

        if( p_sys->b_paused )
        {
            i_system_duration = p_sys->i_pause_date  - i_system_start;
            if( p_sys->i_buffering_extra_initial > 0 )
                i_system_duration += p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
        }
        else
        {
            i_system_duration = mdate() - i_system_start;
        }

  ...",1,,878,2,,void
38645,BLOCK,-1,,<empty>,9,,883,2,,void
38649,BLOCK,-1,,"{
        mtime_t i_stream_start, i_system_duration;

        if( input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ) )
            return 0;
    }",5,,885,1,,void
38667,BLOCK,-1,,<empty>,13,,891,2,,void
38681,BLOCK,-1,,"{
        i_delay = i_stream_duration;
    }",5,,897,2,,void
38686,BLOCK,-1,,"{
        mtime_t i_system_duration;

        if( p_sys->b_paused )
        {
            i_system_duration = p_sys->i_pause_date  - i_system_start;
            if( p_sys->i_buffering_extra_initial > 0 )
                i_system_duration += p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
        }
        else
        {
            i_system_duration = mdate() - i_system_start;
        }

        const mtime_t i_consumed = i_system_duration * INPUT_RATE_DEFAULT / p_sys->i_rate - i_stream_duration;
        i_delay = p_sys->i_pts_delay - i_consumed;
    }",5,,901,1,,void
38692,BLOCK,-1,,"{
            i_system_duration = p_sys->i_pause_date  - i_system_start;
            if( p_sys->i_buffering_extra_initial > 0 )
                i_system_duration += p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
        }",9,,905,2,,void
38706,BLOCK,-1,,<empty>,17,,908,2,,void
38717,BLOCK,-1,,"{
            i_system_duration = mdate() - i_system_start;
        }",9,,911,1,,void
38746,BLOCK,-1,,<empty>,9,,919,2,,void
38759,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    vlc_value_t       val, text;

    if( b_delete )
    {
        if( EsFmtIsTeletext( fmt ) )
            input_SendEventTeletextDel( p_sys->p_input, i_id );

        input_SendEventEsDel( p_input, fmt->i_cat, i_id );
        return;
    }

    /* Get the number of ES already added */
    const char *psz_var;
    if( fmt->i_cat == AUDIO_ES )
        psz_var = ""audio-es"";
    else if( fmt->i_cat == VIDEO_ES )
        psz_var = ""video-es"";
    else
        psz_var = ""spu-es"";

    var_Change( p_input, psz_var, VLC_VAR_CHOICESCOUNT, &val, NULL );
    if( val.i_int == 0 )
    {
        vlc_value_t val2;

        /* First one, we need to add the ""Disable"" choice */
        val2.i_int = -1; text.psz_string = _(""Disable"");
        var_Change( p_input, psz_var, VLC_VAR_ADDCHOICE, &val2, &text );
        val.i_int++;
    }

    /* Take care of the ES description */
    if( fmt->psz_description && ...",1,,926,6,,void
38776,BLOCK,-1,,"{
        if( EsFmtIsTeletext( fmt ) )
            input_SendEventTeletextDel( p_sys->p_input, i_id );

        input_SendEventEsDel( p_input, fmt->i_cat, i_id );
        return;
    }",5,,932,2,,void
38780,BLOCK,-1,,<empty>,13,,934,2,,void
38800,BLOCK,-1,,<empty>,9,,943,2,,void
38805,BLOCK,-1,,<empty>,10,,944,1,,void
38812,BLOCK,-1,,<empty>,9,,945,2,,void
38817,BLOCK,-1,,<empty>,9,,947,1,,void
38834,BLOCK,-1,,"{
        vlc_value_t val2;

        /* First one, we need to add the ""Disable"" choice */
        val2.i_int = -1; text.psz_string = _(""Disable"");
        var_Change( p_input, psz_var, VLC_VAR_ADDCHOICE, &val2, &text );
        val.i_int++;
    }",5,,951,2,,void
38869,BLOCK,-1,,"{
        if( psz_language && *psz_language )
        {
            if( asprintf( &text.psz_string, ""%s - [%s]"", fmt->psz_description,
                          psz_language ) == -1 )
                text.psz_string = NULL;
        }
        else text.psz_string = strdup( fmt->psz_description );
    }",5,,962,2,,void
38875,BLOCK,-1,,"{
            if( asprintf( &text.psz_string, ""%s - [%s]"", fmt->psz_description,
                          psz_language ) == -1 )
                text.psz_string = NULL;
        }",9,,964,2,,void
38890,BLOCK,-1,,<empty>,17,,967,2,,void
38897,BLOCK,-1,,<empty>,14,,969,1,,void
38907,BLOCK,-1,,"{
        if( psz_language && *psz_language )
        {
            if( asprintf( &text.psz_string, ""%s %""PRId64"" - [%s]"", _( ""Track"" ), val.i_int, psz_language ) == -1 )
                text.psz_string = NULL;
        }
        else
        {
            if( asprintf( &text.psz_string, ""%s %""PRId64, _( ""Track"" ), val.i_int ) == -1 )
                text.psz_string = NULL;
        }
    }",5,,972,1,,void
38913,BLOCK,-1,,"{
            if( asprintf( &text.psz_string, ""%s %""PRId64"" - [%s]"", _( ""Track"" ), val.i_int, psz_language ) == -1 )
                text.psz_string = NULL;
        }",9,,974,2,,void
38916,BLOCK,-1,,<empty>,17,,976,2,,void
38923,BLOCK,-1,,"{
            if( asprintf( &text.psz_string, ""%s %""PRId64, _( ""Track"" ), val.i_int ) == -1 )
                text.psz_string = NULL;
        }",9,,979,1,,void
38926,BLOCK,-1,,<empty>,17,,981,2,,void
38944,BLOCK,-1,,"{
        char psz_page[3+1];
        snprintf( psz_page, sizeof(psz_page), ""%d%2.2x"",
                  fmt->subs.teletext.i_magazine,
                  fmt->subs.teletext.i_page );
        input_SendEventTeletextAdd( p_sys->p_input,
                                    i_id, fmt->subs.teletext.i_magazine >= 0 ? psz_page : NULL );
    }",5,,987,2,,void
38992,BLOCK,-1,,"{
    EsOutESVarUpdateGeneric( out, es->i_id, &es->fmt, es->psz_language, b_delete );
}",1,,1001,4,,void
39011,BLOCK,-1,,"{
    return out->p_sys->i_group_id == 0 || out->p_sys->i_group_id == i_group;
}",1,,1006,3,,void
39033,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    int               i;

    if( p_sys->p_pgrm == p_pgrm )
        return; /* Nothing to do */

    if( p_sys->p_pgrm )
    {
        es_out_pgrm_t *old = p_sys->p_pgrm;
        msg_Dbg( p_input, ""unselecting program id=%d"", old->i_id );

        for( i = 0; i < p_sys->i_es; i++ )
        {
            if( p_sys->es[i]->p_pgrm == old && EsIsSelected( p_sys->es[i] ) &&
                p_sys->i_mode != ES_OUT_MODE_ALL )
                EsUnselect( out, p_sys->es[i], true );
        }

        p_sys->audio.p_main_es = NULL;
        p_sys->video.p_main_es = NULL;
        p_sys->sub.p_main_es = NULL;
    }

    msg_Dbg( p_input, ""selecting program id=%d"", p_pgrm->i_id );

    /* Mark it selected */
    p_pgrm->b_selected = true;

    /* Switch master stream */
    p_sys->p_pgrm = p_pgrm;

    /* Update ""program"" */
    input_SendEventProgramSelect( p_input, p_pgrm->i_id );

    /* Update ""es-*""...",1,,1014,3,,void
39053,BLOCK,-1,,<empty>,9,,1020,2,,void
39059,BLOCK,-1,,"{
        es_out_pgrm_t *old = p_sys->p_pgrm;
        msg_Dbg( p_input, ""unselecting program id=%d"", old->i_id );

        for( i = 0; i < p_sys->i_es; i++ )
        {
            if( p_sys->es[i]->p_pgrm == old && EsIsSelected( p_sys->es[i] ) &&
                p_sys->i_mode != ES_OUT_MODE_ALL )
                EsUnselect( out, p_sys->es[i], true );
        }

        p_sys->audio.p_main_es = NULL;
        p_sys->video.p_main_es = NULL;
        p_sys->sub.p_main_es = NULL;
    }",5,,1023,2,,void
39073,BLOCK,-1,,<empty>,9,,1027,1,,void
39084,BLOCK,4,,"{
            if( p_sys->es[i]->p_pgrm == old && EsIsSelected( p_sys->es[i] ) &&
                p_sys->i_mode != ES_OUT_MODE_ALL )
                EsUnselect( out, p_sys->es[i], true );
        }",9,,1028,4,,void
39108,BLOCK,-1,,<empty>,17,,1031,2,,void
39192,BLOCK,-1,,<empty>,5,,1060,1,,void
39203,BLOCK,4,,"{
        if( p_sys->es[i]->p_pgrm == p_sys->p_pgrm )
        {
            EsOutESVarUpdate( out, p_sys->es[i], false );
            EsOutUpdateInfo( out, p_sys->es[i], &p_sys->es[i]->fmt, NULL );
        }

        EsOutSelect( out, p_sys->es[i], false );
    }",5,,1061,4,,void
39216,BLOCK,-1,,"{
            EsOutESVarUpdate( out, p_sys->es[i], false );
            EsOutUpdateInfo( out, p_sys->es[i], &p_sys->es[i]->fmt, NULL );
        }",9,,1063,2,,void
39261,BLOCK,-1,,"{
        input_item_SetESNowPlaying( input_priv(p_input)->p_item,
                                    vlc_meta_Get( p_pgrm->p_meta, vlc_meta_ESNowPlaying ) );
        input_item_SetPublisher( input_priv(p_input)->p_item,
                                 vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Publisher ) );
        input_item_SetTitle( input_priv(p_input)->p_item,
                             vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) );
        input_SendEventMeta( p_input );
        /* FIXME: we probably want to replace every input meta */
    }",5,,1076,2,,void
39299,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    es_out_pgrm_t *p_pgrm = malloc( sizeof( es_out_pgrm_t ) );
    if( !p_pgrm )
        return NULL;

    /* Init */
    p_pgrm->i_id = i_group;
    p_pgrm->i_es = 0;
    p_pgrm->b_selected = false;
    p_pgrm->b_scrambled = false;
    p_pgrm->i_last_pcr = VLC_TS_INVALID;
    p_pgrm->p_meta = NULL;
    p_pgrm->p_clock = input_clock_New( p_sys->i_rate );
    if( !p_pgrm->p_clock )
    {
        free( p_pgrm );
        return NULL;
    }
    if( p_sys->b_paused )
        input_clock_ChangePause( p_pgrm->p_clock, p_sys->b_paused, p_sys->i_pause_date );
    input_clock_SetJitter( p_pgrm->p_clock, p_sys->i_pts_delay, p_sys->i_cr_average );

    /* Append it */
    TAB_APPEND( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* Update ""program"" variable */
    if( EsOutIsProgramVisible( out, i_group ) )
        input_SendEventProgramAdd( p_input, i_group, NULL );

    if( i_group == p_sys->i_group_id...",1,,1092,3,,void
39321,BLOCK,-1,,<empty>,9,,1098,2,,void
39367,BLOCK,-1,,"{
        free( p_pgrm );
        return NULL;
    }",5,,1109,2,,void
39376,BLOCK,-1,,<empty>,9,,1114,2,,void
39409,BLOCK,-1,,<empty>,9,,1122,2,,void
39431,BLOCK,-1,,<empty>,9,,1125,2,,void
39442,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    es_out_pgrm_t     *p_pgrm = NULL;
    int               i;

    for( i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
        {
            p_pgrm = p_sys->pgrm[i];
            break;
        }
    }

    if( p_pgrm == NULL )
        return VLC_EGENERIC;

    if( p_pgrm->i_es )
    {
        msg_Dbg( p_input, ""can't delete program %d which still has %i ES"",
                 i_group, p_pgrm->i_es );
        return VLC_EGENERIC;
    }

    TAB_REMOVE( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* If program is selected we need to unselect it */
    if( p_sys->p_pgrm == p_pgrm )
        p_sys->p_pgrm = NULL;

    input_clock_Delete( p_pgrm->p_clock );

    if( p_pgrm->p_meta )
        vlc_meta_Delete( p_pgrm->p_meta );
    free( p_pgrm );

    /* Update ""program"" variable */
    input_SendEventProgramDel( p_input, i_group );

    return VLC_SUCCESS;
}",1,,1134,3,,void
39461,BLOCK,-1,,<empty>,5,,1140,1,,void
39472,BLOCK,4,,"{
        if( p_sys->pgrm[i]->i_id == i_group )
        {
            p_pgrm = p_sys->pgrm[i];
            break;
        }
    }",5,,1141,4,,void
39483,BLOCK,-1,,"{
            p_pgrm = p_sys->pgrm[i];
            break;
        }",9,,1143,2,,void
39496,BLOCK,-1,,<empty>,9,,1150,2,,void
39503,BLOCK,-1,,"{
        msg_Dbg( p_input, ""can't delete program %d which still has %i ES"",
                 i_group, p_pgrm->i_es );
        return VLC_EGENERIC;
    }",5,,1153,2,,void
39527,BLOCK,-1,,<empty>,9,,1163,2,,void
39541,BLOCK,-1,,<empty>,9,,1168,2,,void
39558,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
            return p_sys->pgrm[i];
    }
    return EsOutProgramAdd( p_out, i_group );
}",1,,1180,3,,void
39566,BLOCK,-1,,<empty>,5,,1183,1,,void
39578,BLOCK,4,,"{
        if( p_sys->pgrm[i]->i_id == i_group )
            return p_sys->pgrm[i];
    }",5,,1184,4,,void
39589,BLOCK,-1,,<empty>,13,,1186,2,,void
39604,BLOCK,-1,,"{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        if( asprintf( &psz, _(""%s [%s %d]""), vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ),
                      _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1,,1194,2,,void
39619,BLOCK,-1,,"{
        if( asprintf( &psz, _(""%s [%s %d]""), vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ),
                      _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }",5,,1197,2,,void
39639,BLOCK,-1,,<empty>,13,,1200,2,,void
39643,BLOCK,-1,,"{
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }",5,,1203,1,,void
39657,BLOCK,-1,,<empty>,13,,1205,2,,void
39666,BLOCK,-1,,"{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        return strdup( vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) );
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1,,1211,2,,void
39681,BLOCK,-1,,"{
        return strdup( vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) );
    }",5,,1214,2,,void
39690,BLOCK,-1,,"{
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }",5,,1218,1,,void
39704,BLOCK,-1,,<empty>,13,,1220,2,,void
39713,BLOCK,-1,,"{
    char *psz_category;

    if( asprintf( &psz_category, _(""Stream %d""), es->i_meta_id ) == -1 )
        return NULL;

    return psz_category;
}",1,,1226,2,,void
39727,BLOCK,-1,,<empty>,9,,1230,2,,void
39738,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_pgrm_t     *p_pgrm;
    input_thread_t    *p_input = p_sys->p_input;
    const char        *psz_title = NULL;
    const char        *psz_provider = NULL;
    int i;

    msg_Dbg( p_input, ""EsOutProgramMeta: number=%d"", i_group );

    /* Check against empty meta data (empty for what we handle) */
    if( !vlc_meta_Get( p_meta, vlc_meta_Title) &&
        !vlc_meta_Get( p_meta, vlc_meta_ESNowPlaying) &&
        !vlc_meta_Get( p_meta, vlc_meta_Publisher) )
    {
        return;
    }

    if( i_group < 0 )
    {
        EsOutGlobalMeta( out, p_meta );
        return;
    }

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    if( p_pgrm->p_meta )
    {
        const char *psz_current_title = vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title );
        const char *psz_new_title = vlc_meta_Get( p_meta, vlc_meta_Title )...",1,,1236,4,,void
39780,BLOCK,-1,,"{
        return;
    }",5,,1250,2,,void
39786,BLOCK,-1,,"{
        EsOutGlobalMeta( out, p_meta );
        return;
    }",5,,1255,2,,void
39796,BLOCK,-1,,<empty>,9,,1262,2,,void
39806,BLOCK,-1,,<empty>,9,,1265,2,,void
39812,BLOCK,-1,,"{
        const char *psz_current_title = vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title );
        const char *psz_new_title = vlc_meta_Get( p_meta, vlc_meta_Title );
        if( (psz_current_title != NULL && psz_new_title != NULL)
            ? strcmp(psz_new_title, psz_current_title)
            : (psz_current_title != psz_new_title) )
        {
            /* Remove old entries */
            char *psz_oldinfokey = EsOutProgramGetMetaName( p_pgrm );
            input_Control( p_input, INPUT_DEL_INFO, psz_oldinfokey, NULL );
            /* TODO update epg name ?
             * TODO update scrambled info name ? */
            free( psz_oldinfokey );
        }
        vlc_meta_Delete( p_pgrm->p_meta );
    }",5,,1268,2,,void
39842,BLOCK,-1,,"{
            /* Remove old entries */
            char *psz_oldinfokey = EsOutProgramGetMetaName( p_pgrm );
            input_Control( p_input, INPUT_DEL_INFO, psz_oldinfokey, NULL );
            /* TODO update epg name ?
             * TODO update scrambled info name ? */
            free( psz_oldinfokey );
        }",9,,1274,2,,void
39868,BLOCK,-1,,<empty>,9,,1286,2,,void
39880,BLOCK,-1,,"{
        EsOutMeta( out, NULL, p_meta );
    }",5,,1289,2,,void
39900,BLOCK,-1,,"{
        char *psz_text;
        if( psz_provider && *psz_provider )
        {
            if( asprintf( &psz_text, ""%s [%s]"", psz_title, psz_provider ) < 0 )
                psz_text = NULL;
        }
        else
        {
            psz_text = strdup( psz_title );
        }

        /* ugly but it works */
        if( psz_text )
        {
            input_SendEventProgramDel( p_input, i_group );
            input_SendEventProgramAdd( p_input, i_group, psz_text );
            if( p_sys->p_pgrm == p_pgrm )
                input_SendEventProgramSelect( p_input, i_group );
            free( psz_text );
        }
    }",5,,1298,2,,void
39907,BLOCK,-1,,"{
            if( asprintf( &psz_text, ""%s [%s]"", psz_title, psz_provider ) < 0 )
                psz_text = NULL;
        }",9,,1301,2,,void
39917,BLOCK,-1,,<empty>,17,,1303,2,,void
39922,BLOCK,-1,,"{
            psz_text = strdup( psz_title );
        }",9,,1306,1,,void
39929,BLOCK,-1,,"{
            input_SendEventProgramDel( p_input, i_group );
            input_SendEventProgramAdd( p_input, i_group, psz_text );
            if( p_sys->p_pgrm == p_pgrm )
                input_SendEventProgramSelect( p_input, i_group );
            free( psz_text );
        }",9,,1312,2,,void
39943,BLOCK,-1,,<empty>,17,,1316,2,,void
39969,BLOCK,-1,,"{
        char *psz_cat = EsOutProgramGetMetaName( p_pgrm );
        if( psz_cat )
            p_cat = info_category_New( psz_cat );
        free( psz_cat );
    }",5,,1326,2,,void
39977,BLOCK,-1,,<empty>,13,,1329,2,,void
39985,BLOCK,-1,,<empty>,5,,1333,1,,void
39994,BLOCK,4,,"{
        if( p_cat )
            info_category_AddInfo( p_cat, vlc_gettext(ppsz_all_keys[i]), ""%s"",
                                   vlc_meta_GetExtra( p_meta, ppsz_all_keys[i] ) );
        free( ppsz_all_keys[i] );
    }",5,,1334,4,,void
39997,BLOCK,-1,,<empty>,13,,1336,2,,void
40018,BLOCK,-1,,"{
        if( p_sys->p_pgrm == p_pgrm )
        {
            input_item_SetPublisher( input_priv(p_input)->p_item, psz_provider );
            input_SendEventMeta( p_input );
        }
        if( p_cat )
            info_category_AddInfo( p_cat, vlc_meta_TypeToLocalizedString(vlc_meta_Publisher),
                                   ""%s"",psz_provider );
    }",5,,1343,2,,void
40025,BLOCK,-1,,"{
            input_item_SetPublisher( input_priv(p_input)->p_item, psz_provider );
            input_SendEventMeta( p_input );
        }",9,,1345,2,,void
40036,BLOCK,-1,,<empty>,13,,1350,2,,void
40045,BLOCK,-1,,<empty>,9,,1354,2,,void
40056,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    input_item_SetEpgEvent( p_item, p_event );
}",1,,1358,4,,void
40082,BLOCK,-1,,<empty>,9,,1366,2,,void
40092,BLOCK,-1,,<empty>,9,,1369,2,,void
40103,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;
    char *psz_cat;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    /* Update info */
    psz_cat = EsOutProgramGetMetaName( p_pgrm );
    msg_Dbg( p_input, ""EsOutProgramEpg: number=%d name=%s"", i_group, psz_cat );

    /* Merge EPG */
    vlc_epg_t epg;

    epg = *p_epg;
    epg.psz_name = EsOutProgramGetProgramName( p_pgrm );

    input_item_SetEpg( p_item, &epg, p_sys->p_pgrm && (p_epg->i_source_id == p_sys->p_pgrm->i_id) );
    input_SendEventMetaEpg( p_sys->p_input );

    free( epg.psz_name );

    /* Update now playing */
    if( p_epg->b_present && p_pgrm->p_meta &&
       ( p_epg->p_current || p_epg->i_event == 0 ) )
    {
        vlc_meta_SetNowPlaying( p_pgrm->p_me...",1,,1375,4,,void
40130,BLOCK,-1,,<empty>,9,,1384,2,,void
40140,BLOCK,-1,,<empty>,9,,1387,2,,void
40205,BLOCK,-1,,"{
        vlc_meta_SetNowPlaying( p_pgrm->p_meta, NULL );
    }",5,,1407,2,,void
40217,BLOCK,-1,,<empty>,5,,1412,1,,void
40229,BLOCK,4,,"{
        const vlc_epg_t *p_tmp = p_item->pp_epg[i];

        if( p_tmp->b_present && p_tmp->i_source_id == p_pgrm->i_id )
        {
            const char *psz_name = ( p_tmp->p_current ) ? p_tmp->p_current->psz_name : NULL;
            if( !p_pgrm->p_meta )
                p_pgrm->p_meta = vlc_meta_New();
            if( p_pgrm->p_meta )
                vlc_meta_Set( p_pgrm->p_meta, vlc_meta_ESNowPlaying, psz_name );
            break;
        }
    }",5,,1413,4,,void
40250,BLOCK,-1,,"{
            const char *psz_name = ( p_tmp->p_current ) ? p_tmp->p_current->psz_name : NULL;
            if( !p_pgrm->p_meta )
                p_pgrm->p_meta = vlc_meta_New();
            if( p_pgrm->p_meta )
                vlc_meta_Set( p_pgrm->p_meta, vlc_meta_ESNowPlaying, psz_name );
            break;
        }",9,,1417,2,,void
40269,BLOCK,-1,,<empty>,17,,1420,2,,void
40279,BLOCK,-1,,<empty>,17,,1422,2,,void
40298,BLOCK,-1,,"{
        const char *psz_nowplaying = p_pgrm->p_meta ?
                                     vlc_meta_Get( p_pgrm->p_meta, vlc_meta_ESNowPlaying ) : NULL;

        input_item_SetESNowPlaying( input_priv(p_input)->p_item, psz_nowplaying );
        input_SendEventMeta( p_input );

        if( psz_nowplaying )
        {
            input_Control( p_input, INPUT_ADD_INFO, psz_cat,
                vlc_meta_TypeToLocalizedString(vlc_meta_ESNowPlaying), ""%s"", psz_nowplaying );
        }
        else
        {
            input_Control( p_input, INPUT_DEL_INFO, psz_cat,
                vlc_meta_TypeToLocalizedString(vlc_meta_ESNowPlaying) );
        }
    }",5,,1430,2,,void
40322,BLOCK,-1,,"{
            input_Control( p_input, INPUT_ADD_INFO, psz_cat,
                vlc_meta_TypeToLocalizedString(vlc_meta_ESNowPlaying), ""%s"", psz_nowplaying );
        }",9,,1438,2,,void
40332,BLOCK,-1,,"{
            input_Control( p_input, INPUT_DEL_INFO, psz_cat,
                vlc_meta_TypeToLocalizedString(vlc_meta_ESNowPlaying) );
        }",9,,1443,1,,void
40346,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;

    input_item_SetEpgTime( p_item, time );
}",1,,1453,3,,void
40374,BLOCK,-1,,"{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    bool b_scrambled = false;

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_pgrm == p_pgrm && p_sys->es[i]->b_scrambled )
        {
            b_scrambled = true;
            break;
        }
    }
    if( !p_pgrm->b_scrambled == !b_scrambled )
        return;

    p_pgrm->b_scrambled = b_scrambled;
    char *psz_cat = EsOutProgramGetMetaName( p_pgrm );

    if( b_scrambled )
        input_Control( p_input, INPUT_ADD_INFO, psz_cat, _(""Scrambled""), _(""Yes"") );
    else
        input_Control( p_input, INPUT_DEL_INFO, psz_cat, _(""Scrambled"") );
    free( psz_cat );

    input_SendEventProgramScrambled( p_input, p_pgrm->i_id, b_scrambled );
}",1,,1462,3,,void
40392,BLOCK,-1,,<empty>,5,,1467,1,,void
40404,BLOCK,4,,"{
        if( p_sys->es[i]->p_pgrm == p_pgrm && p_sys->es[i]->b_scrambled )
        {
            b_scrambled = true;
            break;
        }
    }",5,,1468,4,,void
40423,BLOCK,-1,,"{
            b_scrambled = true;
            break;
        }",9,,1470,2,,void
40436,BLOCK,-1,,<empty>,9,,1476,2,,void
40450,BLOCK,-1,,<empty>,9,,1482,2,,void
40460,BLOCK,-1,,<empty>,9,,1484,1,,void
40481,BLOCK,-1,,"{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    input_item_t *p_item = input_GetItem( p_input );

    vlc_mutex_lock( &p_item->lock );
    if( p_meta )
        vlc_meta_Merge( p_item->p_meta, p_meta );
    vlc_mutex_unlock( &p_item->lock );

    /* Check program meta to not override GROUP_META values */
    if( p_meta && (!p_program_meta || vlc_meta_Get( p_program_meta, vlc_meta_Title ) == NULL) &&
         vlc_meta_Get( p_meta, vlc_meta_Title ) != NULL )
        input_item_SetName( p_item, vlc_meta_Get( p_meta, vlc_meta_Title ) );

    const char *psz_arturl = NULL;
    char *psz_alloc = NULL;

    if( p_program_meta )
        psz_arturl = vlc_meta_Get( p_program_meta, vlc_meta_ArtworkURL );
    if( psz_arturl == NULL && p_meta )
        psz_arturl = vlc_meta_Get( p_meta, vlc_meta_ArtworkURL );

    if( psz_arturl == NULL ) /* restore/favor previously set item art URL */
        psz_arturl = psz_alloc = input_item_GetArtURL( p_item );...",1,,1491,4,,void
40506,BLOCK,-1,,<empty>,9,,1498,2,,void
40534,BLOCK,-1,,<empty>,9,,1504,2,,void
40550,BLOCK,-1,,<empty>,9,,1510,2,,void
40562,BLOCK,-1,,<empty>,9,,1512,2,,void
40572,BLOCK,-1,,<empty>,9,,1515,2,,void
40583,BLOCK,-1,,<empty>,9,,1518,2,,void
40597,BLOCK,-1,,"{   /* Clear art cover if streaming out.
         * FIXME: Why? Remove this when sout gets meta data support. */
        if( input_priv(p_input)->p_sout != NULL )
            input_item_SetArtURL( p_item, NULL );
        else
            input_ExtractAttachmentAndCacheArt( p_input, psz_arturl + 13 );
    }",5,,1521,2,,void
40605,BLOCK,-1,,<empty>,13,,1524,2,,void
40610,BLOCK,-1,,<empty>,13,,1526,1,,void
40628,BLOCK,-1,,"{
    es_out_sys_t    *p_sys = p_out->p_sys;
    EsOutMeta( p_out, p_meta,
               (p_sys->p_pgrm && p_sys->p_pgrm->p_meta) ? p_sys->p_pgrm->p_meta : NULL );
}",1,,1537,3,,void
40660,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    if( fmt->i_group < 0 )
    {
        msg_Err( p_input, ""invalid group number"" );
        return NULL;
    }

    es_out_id_t   *es = malloc( sizeof( *es ) );
    es_out_pgrm_t *p_pgrm;
    int i;

    if( !es )
        return NULL;

    vlc_mutex_lock( &p_sys->lock );

    /* Search the program */
    p_pgrm = EsOutProgramFind( out, fmt->i_group );
    if( !p_pgrm )
    {
        vlc_mutex_unlock( &p_sys->lock );
        free( es );
        return NULL;
    }

    /* Increase ref count for program */
    p_pgrm->i_es++;

    /* Set up ES */
    es->p_pgrm = p_pgrm;
    es_format_Copy( &es->fmt, fmt );
    if( es->fmt.i_id < 0 )
        es->fmt.i_id = p_sys->i_id;
    if( !es->fmt.i_original_fourcc )
        es->fmt.i_original_fourcc = es->fmt.i_codec;

    es->i_id = es->fmt.i_id;
    es->i_meta_id = p_sys->i_id++; /* always incremented */
    es->b_scrambled = false;

    switch( es->...",1,,1544,4,,void
40679,BLOCK,-1,,"{
        msg_Err( p_input, ""invalid group number"" );
        return NULL;
    }",5,,1549,2,,void
40697,BLOCK,-1,,<empty>,9,,1559,2,,void
40715,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_sys->lock );
        free( es );
        return NULL;
    }",5,,1566,2,,void
40748,BLOCK,-1,,<empty>,9,,1579,2,,void
40765,BLOCK,-1,,<empty>,9,,1581,2,,void
40805,BLOCK,-1,,"{
    case AUDIO_ES:
    {
        es->fmt.i_codec = vlc_fourcc_GetCodecAudio( es->fmt.i_codec,
                                                    es->fmt.audio.i_bitspersample );
        es->i_channel = p_sys->audio.i_count++;

        audio_replay_gain_t rg;
        memset( &rg, 0, sizeof(rg) );
        vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
        vlc_audio_replay_gain_MergeFromMeta( &rg, input_priv(p_input)->p_item->p_meta );
        vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );

        for( i = 0; i < AUDIO_REPLAY_GAIN_MAX; i++ )
        {
            if( !es->fmt.audio_replay_gain.pb_peak[i] )
            {
                es->fmt.audio_replay_gain.pb_peak[i] = rg.pb_peak[i];
                es->fmt.audio_replay_gain.pf_peak[i] = rg.pf_peak[i];
            }
            if( !es->fmt.audio_replay_gain.pb_gain[i] )
            {
                es->fmt.audio_replay_gain.pb_gain[i] = rg.pb_gain[i];
                es->fmt.audio_replay_gain.pf_gain[i] =...",5,,1588,2,,void
40808,BLOCK,3,,"{
        es->fmt.i_codec = vlc_fourcc_GetCodecAudio( es->fmt.i_codec,
                                                    es->fmt.audio.i_bitspersample );
        es->i_channel = p_sys->audio.i_count++;

        audio_replay_gain_t rg;
        memset( &rg, 0, sizeof(rg) );
        vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
        vlc_audio_replay_gain_MergeFromMeta( &rg, input_priv(p_input)->p_item->p_meta );
        vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );

        for( i = 0; i < AUDIO_REPLAY_GAIN_MAX; i++ )
        {
            if( !es->fmt.audio_replay_gain.pb_peak[i] )
            {
                es->fmt.audio_replay_gain.pb_peak[i] = rg.pb_peak[i];
                es->fmt.audio_replay_gain.pf_peak[i] = rg.pf_peak[i];
            }
            if( !es->fmt.audio_replay_gain.pb_gain[i] )
            {
                es->fmt.audio_replay_gain.pb_gain[i] = rg.pb_gain[i];
                es->fmt.audio_replay_gain.pf_gain[i] = rg.pf_gain[i];
         ...",5,,1590,3,,void
40871,BLOCK,-1,,<empty>,9,,1601,1,,void
40880,BLOCK,4,,"{
            if( !es->fmt.audio_replay_gain.pb_peak[i] )
            {
                es->fmt.audio_replay_gain.pb_peak[i] = rg.pb_peak[i];
                es->fmt.audio_replay_gain.pf_peak[i] = rg.pf_peak[i];
            }
            if( !es->fmt.audio_replay_gain.pb_gain[i] )
            {
                es->fmt.audio_replay_gain.pb_gain[i] = rg.pb_gain[i];
                es->fmt.audio_replay_gain.pf_gain[i] = rg.pf_gain[i];
            }
        }",9,,1602,4,,void
40892,BLOCK,-1,,"{
                es->fmt.audio_replay_gain.pb_peak[i] = rg.pb_peak[i];
                es->fmt.audio_replay_gain.pf_peak[i] = rg.pf_peak[i];
            }",13,,1604,2,,void
40934,BLOCK,-1,,"{
                es->fmt.audio_replay_gain.pb_gain[i] = rg.pb_gain[i];
                es->fmt.audio_replay_gain.pf_gain[i] = rg.pf_gain[i];
            }",13,,1609,2,,void
41013,BLOCK,-1,,"{
            es->fmt.video.i_visible_width = es->fmt.video.i_width;
            es->fmt.video.i_visible_height = es->fmt.video.i_height;
        }",9,,1622,2,,void
41060,BLOCK,-1,,<empty>,13,,1628,2,,void
41201,BLOCK,-1,,<empty>,9,,1655,2,,void
41222,BLOCK,-1,,<empty>,9,,1661,2,,void
41240,BLOCK,-1,,"{
    return EsOutAddSlave( out, fmt, NULL );
}",1,,1672,3,,void
41250,BLOCK,-1,,"{
    if( es->p_master )
    {
        bool b_decode = false;
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            input_DecoderGetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, &b_decode );
        }
        return b_decode;
    }
    else
    {
        return es->p_dec != NULL;
    }
}",1,,1677,2,,void
41255,BLOCK,-1,,"{
        bool b_decode = false;
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            input_DecoderGetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, &b_decode );
        }
        return b_decode;
    }",5,,1679,2,,void
41266,BLOCK,-1,,"{
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            input_DecoderGetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, &b_decode );
        }",9,,1682,2,,void
41292,BLOCK,-1,,"{
        return es->p_dec != NULL;
    }",5,,1690,1,,void
41304,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    p_es->p_dec = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, input_priv(p_input)->p_sout );
    if( p_es->p_dec )
    {
        if( p_sys->b_buffering )
            input_DecoderStartWait( p_es->p_dec );

        if( !p_es->p_master && p_sys->p_sout_record )
        {
            p_es->p_dec_record = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_sys->p_sout_record );
            if( p_es->p_dec_record && p_sys->b_buffering )
                input_DecoderStartWait( p_es->p_dec_record );
        }
    }

    EsOutDecoderChangeDelay( out, p_es );
}",1,,1695,3,,void
41340,BLOCK,-1,,"{
        if( p_sys->b_buffering )
            input_DecoderStartWait( p_es->p_dec );

        if( !p_es->p_master && p_sys->p_sout_record )
        {
            p_es->p_dec_record = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_sys->p_sout_record );
            if( p_es->p_dec_record && p_sys->b_buffering )
                input_DecoderStartWait( p_es->p_dec_record );
        }
    }",5,,1701,2,,void
41345,BLOCK,-1,,<empty>,13,,1703,2,,void
41359,BLOCK,-1,,"{
            p_es->p_dec_record = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_sys->p_sout_record );
            if( p_es->p_dec_record && p_sys->b_buffering )
                input_DecoderStartWait( p_es->p_dec_record );
        }",9,,1706,2,,void
41386,BLOCK,-1,,<empty>,17,,1709,2,,void
41399,BLOCK,-1,,"{
    VLC_UNUSED(out);

    if( !p_es->p_dec )
        return;

    input_DecoderDelete( p_es->p_dec );
    p_es->p_dec = NULL;

    if( p_es->p_dec_record )
    {
        input_DecoderDelete( p_es->p_dec_record );
        p_es->p_dec_record = NULL;
    }
}",1,,1716,3,,void
41407,BLOCK,-1,,<empty>,9,,1720,2,,void
41422,BLOCK,-1,,"{
        input_DecoderDelete( p_es->p_dec_record );
        p_es->p_dec_record = NULL;
    }",5,,1726,2,,void
41437,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already selected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        int i_channel;
        if( !es->p_master->p_dec )
            return;

        i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );

        if( i_channel == -1 ||
            input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, true ) )
            return;
    }
    else
    {
        const bool b_sout = input_priv(p_input)->p_sout != NULL;
        if( es->fmt.i_cat == VIDEO_ES || es->fmt.i_cat == SPU_ES )
        {
            if( !var_GetBool( p_input, b_sout ? ""sout-video"" : ""video"" ) )
            {
                msg_Dbg( p_input, ""video is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }
        }
        el...",1,,1733,3,,void
41453,BLOCK,-1,,"{
        msg_Warn( p_input, ""ES 0x%x is already selected"", es->i_id );
        return;
    }",5,,1738,2,,void
41465,BLOCK,-1,,"{
        int i_channel;
        if( !es->p_master->p_dec )
            return;

        i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );

        if( i_channel == -1 ||
            input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, true ) )
            return;
    }",5,,1744,2,,void
41474,BLOCK,-1,,<empty>,13,,1747,2,,void
41502,BLOCK,-1,,<empty>,13,,1754,2,,void
41505,BLOCK,-1,,"{
        const bool b_sout = input_priv(p_input)->p_sout != NULL;
        if( es->fmt.i_cat == VIDEO_ES || es->fmt.i_cat == SPU_ES )
        {
            if( !var_GetBool( p_input, b_sout ? ""sout-video"" : ""video"" ) )
            {
                msg_Dbg( p_input, ""video is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }
        }
        else if( es->fmt.i_cat == AUDIO_ES )
        {
            if( !var_GetBool( p_input, b_sout ? ""sout-audio"" : ""audio"" ) )
            {
                msg_Dbg( p_input, ""audio is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }
        }
        if( es->fmt.i_cat == SPU_ES )
        {
            if( !var_GetBool( p_input, b_sout ? ""sout-spu"" : ""spu"" ) )
            {
                msg_Dbg( p_input, ""spu is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }
        }
...",5,,1757,1,,void
41531,BLOCK,-1,,"{
            if( !var_GetBool( p_input, b_sout ? ""sout-video"" : ""video"" ) )
            {
                msg_Dbg( p_input, ""video is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }
        }",9,,1760,2,,void
41540,BLOCK,-1,,"{
                msg_Dbg( p_input, ""video is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }",13,,1762,2,,void
41549,BLOCK,-1,,<empty>,14,,1768,1,,void
41558,BLOCK,-1,,"{
            if( !var_GetBool( p_input, b_sout ? ""sout-audio"" : ""audio"" ) )
            {
                msg_Dbg( p_input, ""audio is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }
        }",9,,1769,2,,void
41567,BLOCK,-1,,"{
                msg_Dbg( p_input, ""audio is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }",13,,1771,2,,void
41583,BLOCK,-1,,"{
            if( !var_GetBool( p_input, b_sout ? ""sout-spu"" : ""spu"" ) )
            {
                msg_Dbg( p_input, ""spu is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }
        }",9,,1778,2,,void
41592,BLOCK,-1,,"{
                msg_Dbg( p_input, ""spu is disabled, not selecting ES 0x%x"",
                         es->i_id );
                return;
            }",13,,1780,2,,void
41617,BLOCK,-1,,<empty>,13,,1790,2,,void
41647,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( parent->cc.type == 0 )
        return;

    const int i_spu_id = var_GetInteger( p_input, ""spu-es"");

    uint64_t i_bitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1 )
    {
        if( (i_bitmap & 1) == 0 || !parent->cc.pp_es[i] )
            continue;

        if( i_spu_id == parent->cc.pp_es[i]->i_id )
        {
            /* Force unselection of the CC */
            input_SendEventEsSelect( p_input, SPU_ES, -1 );
        }
        EsOutDel( out, parent->cc.pp_es[i] );
    }

    parent->cc.i_bitmap = 0;
    parent->cc.type = 0;
}",1,,1799,3,,void
41668,BLOCK,-1,,<empty>,9,,1804,2,,void
41685,BLOCK,-1,,<empty>,5,,1809,1,,void
41699,BLOCK,4,,"{
        if( (i_bitmap & 1) == 0 || !parent->cc.pp_es[i] )
            continue;

        if( i_spu_id == parent->cc.pp_es[i]->i_id )
        {
            /* Force unselection of the CC */
            input_SendEventEsSelect( p_input, SPU_ES, -1 );
        }
        EsOutDel( out, parent->cc.pp_es[i] );
    }",5,,1810,4,,void
41715,BLOCK,-1,,<empty>,13,,1812,2,,void
41729,BLOCK,-1,,"{
            /* Force unselection of the CC */
            input_SendEventEsSelect( p_input, SPU_ES, -1 );
        }",9,,1815,2,,void
41764,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already unselected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            if( i_channel != -1 )
                input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                         i_channel, false );
        }
    }
    else
    {
        EsDeleteCCChannels( out, es );
        EsDestroyDecoder( out, es );
    }

    if( !b_update )
        return;

    /* Mark it as unselected */
    input_SendEventEsSelect( p_input, es->fmt.i_cat, -1 );
    if( EsFmtIsTeletext( &es->fmt ) )
        input_SendEventTeletextSelect( p_input, -1 );
}",1,,1827,4,,void
41781,BLOCK,-1,,"{
        msg_Warn( p_input, ""ES 0x%x is already unselected"", es->i_id );
        return;
    }",5,,1832,2,,void
41793,BLOCK,-1,,"{
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            if( i_channel != -1 )
                input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                         i_channel, false );
        }
    }",5,,1838,2,,void
41800,BLOCK,-1,,"{
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            if( i_channel != -1 )
                input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                         i_channel, false );
        }",9,,1840,2,,void
41814,BLOCK,-1,,<empty>,17,,1843,2,,void
41829,BLOCK,-1,,"{
        EsDeleteCCChannels( out, es );
        EsDestroyDecoder( out, es );
    }",5,,1848,1,,void
41839,BLOCK,-1,,<empty>,9,,1854,2,,void
41856,BLOCK,-1,,<empty>,9,,1859,2,,void
41867,BLOCK,-1,,"{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    if( !p_sys->b_active ||
        ( !b_force && es->fmt.i_priority < ES_PRIORITY_SELECTABLE_MIN ) )
    {
        return;
    }

    bool b_auto_unselect = p_esprops && p_sys->i_mode == ES_OUT_MODE_AUTO &&
                           p_esprops->e_policy == ES_OUT_ES_POLICY_EXCLUSIVE &&
                           p_esprops->p_main_es && p_esprops->p_main_es != es;

    if( p_sys->i_mode == ES_OUT_MODE_ALL || b_force )
    {
        if( !EsIsSelected( es ) )
        {
            if( b_auto_unselect )
                EsUnselect( out, p_esprops->p_main_es, false );

            EsSelect( out, es );
        }
    }
    else if( p_sys->i_mode == ES_OUT_MODE_PARTIAL )
    {
        char *prgms = var_GetNonEmptyString( p_sys->p_input, ""programs"" );
        if( prgms != NULL )
        {
            char *buf;

            for ( const char *prgm = strtok_r( prgms, "","", &bu...",1,,1872,4,,void
41900,BLOCK,-1,,"{
        return;
    }",5,,1878,2,,void
41936,BLOCK,-1,,"{
        if( !EsIsSelected( es ) )
        {
            if( b_auto_unselect )
                EsUnselect( out, p_esprops->p_main_es, false );

            EsSelect( out, es );
        }
    }",5,,1887,2,,void
41941,BLOCK,-1,,"{
            if( b_auto_unselect )
                EsUnselect( out, p_esprops->p_main_es, false );

            EsSelect( out, es );
        }",9,,1889,2,,void
41944,BLOCK,-1,,<empty>,17,,1891,2,,void
41955,BLOCK,-1,,<empty>,10,,1896,1,,void
41962,BLOCK,-1,,"{
        char *prgms = var_GetNonEmptyString( p_sys->p_input, ""programs"" );
        if( prgms != NULL )
        {
            char *buf;

            for ( const char *prgm = strtok_r( prgms, "","", &buf );
                  prgm != NULL;
                  prgm = strtok_r( NULL, "","", &buf ) )
            {
                if( atoi( prgm ) == es->p_pgrm->i_id || b_force )
                {
                    if( !EsIsSelected( es ) )
                        EsSelect( out, es );
                    break;
                }
            }
            free( prgms );
        }
    }",5,,1897,2,,void
41975,BLOCK,-1,,"{
            char *buf;

            for ( const char *prgm = strtok_r( prgms, "","", &buf );
                  prgm != NULL;
                  prgm = strtok_r( NULL, "","", &buf ) )
            {
                if( atoi( prgm ) == es->p_pgrm->i_id || b_force )
                {
                    if( !EsIsSelected( es ) )
                        EsSelect( out, es );
                    break;
                }
            }
            free( prgms );
        }",9,,1900,2,,void
41978,BLOCK,-1,,<empty>,13,,1903,1,,void
41997,BLOCK,4,,"{
                if( atoi( prgm ) == es->p_pgrm->i_id || b_force )
                {
                    if( !EsIsSelected( es ) )
                        EsSelect( out, es );
                    break;
                }
            }",13,,1906,4,,void
42009,BLOCK,-1,,"{
                    if( !EsIsSelected( es ) )
                        EsSelect( out, es );
                    break;
                }",17,,1908,2,,void
42014,BLOCK,-1,,<empty>,25,,1910,2,,void
42022,BLOCK,-1,,<empty>,10,,1917,1,,void
42029,BLOCK,-1,,"{
        const es_out_id_t *wanted_es = NULL;

        if( es->p_pgrm != p_sys->p_pgrm || !p_esprops )
            return;

        /* user designated by ID ES have higher prio than everything */
        if ( p_esprops->i_id >= 0 )
        {
            if( es->i_id == p_esprops->i_id )
                wanted_es = es;
        }
        /* then per pos */
        else if( p_esprops->i_channel >= 0 )
        {
            if( p_esprops->i_channel == es->i_channel )
                wanted_es = es;
        }
        else if( p_esprops->ppsz_language )
        {
            /* If not deactivated */
            const int i_stop_idx = LanguageArrayIndex( p_esprops->ppsz_language, ""none"" );
            {
                int current_es_idx = ( p_esprops->p_main_es == NULL ) ? -1 :
                        LanguageArrayIndex( p_esprops->ppsz_language,
                                            p_esprops->p_main_es->psz_language_code );
                int es_idx = LanguageArrayIndex( p_espro...",5,,1918,2,,void
42045,BLOCK,-1,,<empty>,13,,1922,2,,void
42053,BLOCK,-1,,"{
            if( es->i_id == p_esprops->i_id )
                wanted_es = es;
        }",9,,1926,2,,void
42062,BLOCK,-1,,<empty>,17,,1928,2,,void
42067,BLOCK,-1,,<empty>,14,,1931,1,,void
42074,BLOCK,-1,,"{
            if( p_esprops->i_channel == es->i_channel )
                wanted_es = es;
        }",9,,1932,2,,void
42083,BLOCK,-1,,<empty>,17,,1934,2,,void
42088,BLOCK,-1,,<empty>,14,,1936,1,,void
42093,BLOCK,-1,,"{
            /* If not deactivated */
            const int i_stop_idx = LanguageArrayIndex( p_esprops->ppsz_language, ""none"" );
            {
                int current_es_idx = ( p_esprops->p_main_es == NULL ) ? -1 :
                        LanguageArrayIndex( p_esprops->ppsz_language,
                                            p_esprops->p_main_es->psz_language_code );
                int es_idx = LanguageArrayIndex( p_esprops->ppsz_language,
                                                 es->psz_language_code );
                if( es_idx >= 0 && (i_stop_idx < 0 || i_stop_idx > es_idx) )
                {
                    /* Only select the language if it's in the list */
                    if( p_esprops->p_main_es == NULL ||
                        current_es_idx < 0 || /* current es was not selected by lang prefs */
                        es_idx < current_es_idx || /* current es has lower lang prio */
                        (  es_idx == current_es_idx && /* lang is ...",9,,1937,2,,void
42102,BLOCK,3,,"{
                int current_es_idx = ( p_esprops->p_main_es == NULL ) ? -1 :
                        LanguageArrayIndex( p_esprops->ppsz_language,
                                            p_esprops->p_main_es->psz_language_code );
                int es_idx = LanguageArrayIndex( p_esprops->ppsz_language,
                                                 es->psz_language_code );
                if( es_idx >= 0 && (i_stop_idx < 0 || i_stop_idx > es_idx) )
                {
                    /* Only select the language if it's in the list */
                    if( p_esprops->p_main_es == NULL ||
                        current_es_idx < 0 || /* current es was not selected by lang prefs */
                        es_idx < current_es_idx || /* current es has lower lang prio */
                        (  es_idx == current_es_idx && /* lang is same, but es has higher prio */
                           p_esprops->p_main_es->fmt.i_priority < es->fmt.i_priority ) )
                    {...",13,,1940,3,,void
42145,BLOCK,-1,,"{
                    /* Only select the language if it's in the list */
                    if( p_esprops->p_main_es == NULL ||
                        current_es_idx < 0 || /* current es was not selected by lang prefs */
                        es_idx < current_es_idx || /* current es has lower lang prio */
                        (  es_idx == current_es_idx && /* lang is same, but es has higher prio */
                           p_esprops->p_main_es->fmt.i_priority < es->fmt.i_priority ) )
                    {
                        wanted_es = es;
                    }
                }",17,,1947,2,,void
42178,BLOCK,-1,,"{
                        wanted_es = es;
                    }",21,,1954,2,,void
42183,BLOCK,-1,,<empty>,22,,1959,1,,void
42188,BLOCK,-1,,"{
                    /* Select if asked by demuxer */
                    if( current_es_idx < 0 ) /* No es is currently selected by lang pref */
                    {
                        /* If demux has specified a track */
                        if( p_esprops->i_demux_id >= 0 && es->i_id == p_esprops->i_demux_id )
                        {
                            wanted_es = es;
                        }
                        /* Otherwise, fallback by priority */
                        else if( p_esprops->p_main_es == NULL ||
                                 es->fmt.i_priority > p_esprops->p_main_es->fmt.i_priority )
                        {
                            if( p_esprops->b_autoselect )
                                wanted_es = es;
                        }
                    }
                }",17,,1960,2,,void
42193,BLOCK,-1,,"{
                        /* If demux has specified a track */
                        if( p_esprops->i_demux_id >= 0 && es->i_id == p_esprops->i_demux_id )
                        {
                            wanted_es = es;
                        }
                        /* Otherwise, fallback by priority */
                        else if( p_esprops->p_main_es == NULL ||
                                 es->fmt.i_priority > p_esprops->p_main_es->fmt.i_priority )
                        {
                            if( p_esprops->b_autoselect )
                                wanted_es = es;
                        }
                    }",21,,1963,2,,void
42208,BLOCK,-1,,"{
                            wanted_es = es;
                        }",25,,1966,2,,void
42213,BLOCK,-1,,<empty>,30,,1970,1,,void
42234,BLOCK,-1,,"{
                            if( p_esprops->b_autoselect )
                                wanted_es = es;
                        }",25,,1972,2,,void
42239,BLOCK,-1,,<empty>,33,,1974,2,,void
42244,BLOCK,-1,,<empty>,14,,1983,1,,void
42259,BLOCK,-1,,"{
            wanted_es = es;
        }",9,,1984,2,,void
42264,BLOCK,-1,,<empty>,14,,1987,1,,void
42285,BLOCK,-1,,"{
            if( p_esprops->b_autoselect )
                wanted_es = es;
        }",9,,1989,2,,void
42290,BLOCK,-1,,<empty>,17,,1991,2,,void
42302,BLOCK,-1,,"{
            if( b_auto_unselect )
                EsUnselect( out, p_esprops->p_main_es, false );

            EsSelect( out, es );
        }",9,,1995,2,,void
42305,BLOCK,-1,,<empty>,17,,1997,2,,void
42326,BLOCK,-1,,<empty>,9,,2005,2,,void
42340,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    /* Only one type of captions is allowed ! */
    if( parent->cc.type && parent->cc.type != codec )
        return;

    uint64_t i_existingbitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1, i_existingbitmap >>= 1 )
    {
        es_format_t fmt;

        if( (i_bitmap & 1) == 0 || (i_existingbitmap & 1) )
            continue;

        msg_Dbg( p_input, ""Adding CC track %d for es[%d]"", 1+i, parent->i_id );

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i;
        fmt.i_group = parent->fmt.i_group;
        if( asprintf( &fmt.psz_description, psz_descfmt, 1 + i ) == -1 )
            fmt.psz_description = NULL;

        es_out_id_t **pp_es = &parent->cc.pp_es[i];
        *pp_es = EsOutAddSlave( out, &fmt, parent );
        es_format_Clean( &fmt );

        /* */
        parent->cc.i_bitmap |= (1ULL << i);
        parent->cc.type...",1,,2010,6,,void
42367,BLOCK,-1,,<empty>,9,,2016,2,,void
42378,BLOCK,-1,,<empty>,5,,2019,1,,void
42395,BLOCK,4,,"{
        es_format_t fmt;

        if( (i_bitmap & 1) == 0 || (i_existingbitmap & 1) )
            continue;

        msg_Dbg( p_input, ""Adding CC track %d for es[%d]"", 1+i, parent->i_id );

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i;
        fmt.i_group = parent->fmt.i_group;
        if( asprintf( &fmt.psz_description, psz_descfmt, 1 + i ) == -1 )
            fmt.psz_description = NULL;

        es_out_id_t **pp_es = &parent->cc.pp_es[i];
        *pp_es = EsOutAddSlave( out, &fmt, parent );
        es_format_Clean( &fmt );

        /* */
        parent->cc.i_bitmap |= (1ULL << i);
        parent->cc.type = codec;

        /* Enable if user specified on command line */
        if (p_sys->sub.i_channel == i)
            EsOutSelect(out, *pp_es, true);
    }",5,,2020,4,,void
42407,BLOCK,-1,,<empty>,13,,2024,2,,void
42454,BLOCK,-1,,<empty>,13,,2032,2,,void
42506,BLOCK,-1,,<empty>,13,,2044,2,,void
42518,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    assert( p_block->p_next == NULL );

    if( libvlc_stats( p_input ) )
    {
        uint64_t i_total;

        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_demux_read,
                      p_block->i_buffer, &i_total );
        stats_Update( input_priv(p_input)->counters.p_demux_bitrate, i_total, NULL );

        /* Update number of corrupted data packats */
        if( p_block->i_flags & BLOCK_FLAG_CORRUPTED )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_corrupted, 1, NULL );
        }
        /* Update number of discontinuities */
        if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_discontinuity, 1, NULL );
        }
        vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
    }

    vlc_mutex...",1,,2056,4,,void
42540,BLOCK,-1,,"{
        uint64_t i_total;

        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_demux_read,
                      p_block->i_buffer, &i_total );
        stats_Update( input_priv(p_input)->counters.p_demux_bitrate, i_total, NULL );

        /* Update number of corrupted data packats */
        if( p_block->i_flags & BLOCK_FLAG_CORRUPTED )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_corrupted, 1, NULL );
        }
        /* Update number of discontinuities */
        if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY )
        {
            stats_Update( input_priv(p_input)->counters.p_demux_discontinuity, 1, NULL );
        }
        vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
    }",5,,2063,2,,void
42577,BLOCK,-1,,"{
            stats_Update( input_priv(p_input)->counters.p_demux_corrupted, 1, NULL );
        }",9,,2073,2,,void
42593,BLOCK,-1,,"{
            stats_Update( input_priv(p_input)->counters.p_demux_discontinuity, 1, NULL );
        }",9,,2078,2,,void
42622,BLOCK,-1,,"{
        int64_t i_date = p_block->i_pts;
        if( p_block->i_pts <= VLC_TS_INVALID )
            i_date = p_block->i_dts;

        /* In some cases, the demuxer sends non dated packets.
           We use interpolation, previous, or pcr value to compare with
           preroll target timestamp */
        if( i_date == VLC_TS_INVALID )
        {
            if( es->i_pts_level != VLC_TS_INVALID )
                i_date = es->i_pts_level;
            else if( es->p_pgrm->i_last_pcr != VLC_TS_INVALID )
                i_date = es->p_pgrm->i_last_pcr;
        }

        if( i_date != VLC_TS_INVALID )
            es->i_pts_level = i_date + p_block->i_length;

        /* If i_date is still invalid (first/all non dated), expect to be in preroll */

        if( i_date == VLC_TS_INVALID ||
            es->i_pts_level < p_sys->i_preroll_end )
            p_block->i_flags |= BLOCK_FLAG_PREROLL;
    }",5,,2088,2,,void
42635,BLOCK,-1,,<empty>,13,,2091,2,,void
42645,BLOCK,-1,,"{
            if( es->i_pts_level != VLC_TS_INVALID )
                i_date = es->i_pts_level;
            else if( es->p_pgrm->i_last_pcr != VLC_TS_INVALID )
                i_date = es->p_pgrm->i_last_pcr;
        }",9,,2097,2,,void
42652,BLOCK,-1,,<empty>,17,,2099,2,,void
42659,BLOCK,-1,,<empty>,18,,2100,1,,void
42668,BLOCK,-1,,<empty>,17,,2101,2,,void
42680,BLOCK,-1,,<empty>,13,,2105,2,,void
42702,BLOCK,-1,,<empty>,13,,2111,2,,void
42713,BLOCK,-1,,"{
        block_Release( p_block );
        vlc_mutex_unlock( &p_sys->lock );
        return VLC_SUCCESS;
    }",5,,2115,2,,void
42728,BLOCK,-1,,"{
        /* FIXME review this, proper lock may be missing */
        if( input_priv(p_input)->p_sout->i_out_pace_nocontrol > 0 &&
            input_priv(p_input)->b_out_pace_control )
        {
            msg_Dbg( p_input, ""switching to sync mode"" );
            input_priv(p_input)->b_out_pace_control = false;
        }
        else if( input_priv(p_input)->p_sout->i_out_pace_nocontrol <= 0 &&
                 !input_priv(p_input)->b_out_pace_control )
        {
            msg_Dbg( p_input, ""switching to async mode"" );
            input_priv(p_input)->b_out_pace_control = true;
        }
    }",5,,2123,2,,void
42743,BLOCK,-1,,"{
            msg_Dbg( p_input, ""switching to sync mode"" );
            input_priv(p_input)->b_out_pace_control = false;
        }",9,,2127,2,,void
42754,BLOCK,-1,,<empty>,14,,2131,1,,void
42770,BLOCK,-1,,"{
            msg_Dbg( p_input, ""switching to async mode"" );
            input_priv(p_input)->b_out_pace_control = true;
        }",9,,2133,2,,void
42784,BLOCK,-1,,"{
        block_t *p_dup = block_Duplicate( p_block );
        if( p_dup )
            input_DecoderDecode( es->p_dec_record, p_dup,
                                 input_priv(p_input)->b_out_pace_control );
    }",5,,2141,2,,void
42792,BLOCK,-1,,<empty>,13,,2144,2,,void
42822,BLOCK,-1,,"{
        EsOutUpdateInfo( out, es, &fmt_dsc, p_meta_dsc );

        es_format_Clean( &fmt_dsc );
        if( p_meta_dsc )
            vlc_meta_Delete( p_meta_dsc );
    }",5,,2153,2,,void
42834,BLOCK,-1,,<empty>,13,,2158,2,,void
42850,BLOCK,-1,,<empty>,9,,2166,2,,void
42881,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;
    bool b_reselect = false;
    int i;

    vlc_mutex_lock( &p_sys->lock );

    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    /* We don't try to reselect */
    if( es->p_dec )
    {   /* FIXME: This might hold the ES output caller (i.e. the demux), and
         * the corresponding thread (typically the input thread), for a little
         * bit too long if the ES is deleted in the middle of a stream. */
        input_DecoderDrain( es->p_dec );
        while( !input_Stopped(p_sys->p_input) && !p_sys->b_buffering )
        {
            if( input_DecoderIsEmpty( es->p_dec ) &&
                ( !es->p_dec_record || input_DecoderIsEmpty( es->p_dec_record ) ))
                break;
            /* FIXME there should be a way to have auto deleted es, but there will be
             * a problem when another codec of the same type is created (mainly video) */
            msleep( 20*1000 );
        }
        EsUnselect( ...",1,,2180,3,,void
42912,BLOCK,-1,,"{   /* FIXME: This might hold the ES output caller (i.e. the demux), and
         * the corresponding thread (typically the input thread), for a little
         * bit too long if the ES is deleted in the middle of a stream. */
        input_DecoderDrain( es->p_dec );
        while( !input_Stopped(p_sys->p_input) && !p_sys->b_buffering )
        {
            if( input_DecoderIsEmpty( es->p_dec ) &&
                ( !es->p_dec_record || input_DecoderIsEmpty( es->p_dec_record ) ))
                break;
            /* FIXME there should be a way to have auto deleted es, but there will be
             * a problem when another codec of the same type is created (mainly video) */
            msleep( 20*1000 );
        }
        EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
    }",5,,2191,2,,void
42928,BLOCK,-1,,"{
            if( input_DecoderIsEmpty( es->p_dec ) &&
                ( !es->p_dec_record || input_DecoderIsEmpty( es->p_dec_record ) ))
                break;
            /* FIXME there should be a way to have auto deleted es, but there will be
             * a problem when another codec of the same type is created (mainly video) */
            msleep( 20*1000 );
        }",9,,2196,2,,void
42944,BLOCK,-1,,<empty>,17,,2199,2,,void
42968,BLOCK,-1,,<empty>,9,,2208,2,,void
42998,BLOCK,-1,,<empty>,9,,2217,2,,void
43008,BLOCK,-1,,<empty>,9,,2220,2,,void
43016,BLOCK,-1,,"{
        if( p_esprops->p_main_es == es )
        {
            b_reselect = true;
            p_esprops->p_main_es = NULL;
        }
        p_esprops->i_count--;
    }",5,,2224,2,,void
43023,BLOCK,-1,,"{
            b_reselect = true;
            p_esprops->p_main_es = NULL;
        }",9,,2226,2,,void
43038,BLOCK,-1,,"{
        for( i = 0; i < p_sys->i_es; i++ )
        {
            if( es->fmt.i_cat == p_sys->es[i]->fmt.i_cat )
            {
                if( EsIsSelected(p_sys->es[i]) )
                {
                    input_SendEventEsSelect( p_sys->p_input, es->fmt.i_cat, p_sys->es[i]->i_id );
                    if( p_esprops->p_main_es == NULL )
                        p_esprops->p_main_es = p_sys->es[i];
                }
                else
                    EsOutSelect( out, p_sys->es[i], false );
            }
        }
    }",5,,2235,2,,void
43040,BLOCK,-1,,<empty>,9,,2236,1,,void
43051,BLOCK,4,,"{
            if( es->fmt.i_cat == p_sys->es[i]->fmt.i_cat )
            {
                if( EsIsSelected(p_sys->es[i]) )
                {
                    input_SendEventEsSelect( p_sys->p_input, es->fmt.i_cat, p_sys->es[i]->i_id );
                    if( p_esprops->p_main_es == NULL )
                        p_esprops->p_main_es = p_sys->es[i];
                }
                else
                    EsOutSelect( out, p_sys->es[i], false );
            }
        }",9,,2237,4,,void
43068,BLOCK,-1,,"{
                if( EsIsSelected(p_sys->es[i]) )
                {
                    input_SendEventEsSelect( p_sys->p_input, es->fmt.i_cat, p_sys->es[i]->i_id );
                    if( p_esprops->p_main_es == NULL )
                        p_esprops->p_main_es = p_sys->es[i];
                }
                else
                    EsOutSelect( out, p_sys->es[i], false );
            }",13,,2239,2,,void
43076,BLOCK,-1,,"{
                    input_SendEventEsSelect( p_sys->p_input, es->fmt.i_cat, p_sys->es[i]->i_id );
                    if( p_esprops->p_main_es == NULL )
                        p_esprops->p_main_es = p_sys->es[i];
                }",17,,2241,2,,void
43099,BLOCK,-1,,<empty>,25,,2244,2,,void
43110,BLOCK,-1,,<empty>,21,,2247,1,,void
43145,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;

    switch( i_query )
    {
    case ES_OUT_SET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool b = va_arg( args, int );
        if( b && !EsIsSelected( es ) )
        {
            EsSelect( out, es );
            return EsIsSelected( es ) ? VLC_SUCCESS : VLC_EGENERIC;
        }
        else if( !b && EsIsSelected( es ) )
        {
            EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
            return VLC_SUCCESS;
        }
        return VLC_SUCCESS;
    }

    case ES_OUT_GET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool *pb = va_arg( args, bool * );

        *pb = EsIsSelected( es );
        return VLC_SUCCESS;
    }

    case ES_OUT_SET_ES_CAT_POLICY:
    {
        enum es_format_category_e i_cat = va_arg( args, enum es_format_category_e );
        enum es_out_policy_e i_pol = va_arg( args, enum es_out_policy_e );
        es_out_es_props_t *p_esprop...",1,,2271,4,,void
43154,BLOCK,-1,,"{
    case ES_OUT_SET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool b = va_arg( args, int );
        if( b && !EsIsSelected( es ) )
        {
            EsSelect( out, es );
            return EsIsSelected( es ) ? VLC_SUCCESS : VLC_EGENERIC;
        }
        else if( !b && EsIsSelected( es ) )
        {
            EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
            return VLC_SUCCESS;
        }
        return VLC_SUCCESS;
    }

    case ES_OUT_GET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool *pb = va_arg( args, bool * );

        *pb = EsIsSelected( es );
        return VLC_SUCCESS;
    }

    case ES_OUT_SET_ES_CAT_POLICY:
    {
        enum es_format_category_e i_cat = va_arg( args, enum es_format_category_e );
        enum es_out_policy_e i_pol = va_arg( args, enum es_out_policy_e );
        es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, i_cat );
        if( p_esprops == NULL )
...",5,,2275,2,,void
43157,BLOCK,3,,"{
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool b = va_arg( args, int );
        if( b && !EsIsSelected( es ) )
        {
            EsSelect( out, es );
            return EsIsSelected( es ) ? VLC_SUCCESS : VLC_EGENERIC;
        }
        else if( !b && EsIsSelected( es ) )
        {
            EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
            return VLC_SUCCESS;
        }
        return VLC_SUCCESS;
    }",5,,2277,3,,void
43168,BLOCK,-1,,"{
            EsSelect( out, es );
            return EsIsSelected( es ) ? VLC_SUCCESS : VLC_EGENERIC;
        }",9,,2281,2,,void
43179,BLOCK,-1,,<empty>,14,,2285,1,,void
43186,BLOCK,-1,,"{
            EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
            return VLC_SUCCESS;
        }",9,,2286,2,,void
43203,BLOCK,6,,"{
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool *pb = va_arg( args, bool * );

        *pb = EsIsSelected( es );
        return VLC_SUCCESS;
    }",5,,2294,6,,void
43215,BLOCK,9,,"{
        enum es_format_category_e i_cat = va_arg( args, enum es_format_category_e );
        enum es_out_policy_e i_pol = va_arg( args, enum es_out_policy_e );
        es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, i_cat );
        if( p_esprops == NULL )
            return VLC_EGENERIC;
        p_esprops->e_policy = i_pol;
        return VLC_SUCCESS;
    }",5,,2303,9,,void
43230,BLOCK,-1,,<empty>,13,,2308,2,,void
43242,BLOCK,12,,"{
        int *pi_group = va_arg( args, int * );
        *pi_group = p_sys->i_group_id;
        return VLC_SUCCESS;
    }",5,,2314,12,,void
43254,BLOCK,15,,"{
        const int i_mode = va_arg( args, int );
        assert( i_mode == ES_OUT_MODE_NONE || i_mode == ES_OUT_MODE_ALL ||
                i_mode == ES_OUT_MODE_AUTO || i_mode == ES_OUT_MODE_PARTIAL ||
                i_mode == ES_OUT_MODE_END );

        if( i_mode != ES_OUT_MODE_NONE && !p_sys->b_active && p_sys->i_es > 0 )
        {
            /* XXX Terminate vout if there are tracks but no video one.
             * This one is not mandatory but is he earliest place where it
             * can be done */
            int i;
            for( i = 0; i < p_sys->i_es; i++ )
            {
                es_out_id_t *p_es = p_sys->es[i];
                if( p_es->fmt.i_cat == VIDEO_ES )
                    break;
            }
            if( i >= p_sys->i_es )
                input_resource_TerminateVout( input_priv(p_sys->p_input)->p_resource );
        }
        p_sys->b_active = i_mode != ES_OUT_MODE_NONE;
        p_sys->i_mode = i_mode;

        /* Reapply policy mode */
     ...",5,,2321,15,,void
43291,BLOCK,-1,,"{
            /* XXX Terminate vout if there are tracks but no video one.
             * This one is not mandatory but is he earliest place where it
             * can be done */
            int i;
            for( i = 0; i < p_sys->i_es; i++ )
            {
                es_out_id_t *p_es = p_sys->es[i];
                if( p_es->fmt.i_cat == VIDEO_ES )
                    break;
            }
            if( i >= p_sys->i_es )
                input_resource_TerminateVout( input_priv(p_sys->p_input)->p_resource );
        }",9,,2328,2,,void
43294,BLOCK,-1,,<empty>,13,,2333,1,,void
43305,BLOCK,4,,"{
                es_out_id_t *p_es = p_sys->es[i];
                if( p_es->fmt.i_cat == VIDEO_ES )
                    break;
            }",13,,2334,4,,void
43322,BLOCK,-1,,<empty>,21,,2337,2,,void
43330,BLOCK,-1,,<empty>,17,,2340,2,,void
43351,BLOCK,-1,,<empty>,9,,2346,1,,void
43363,BLOCK,4,,"{
            if( EsIsSelected( p_sys->es[i] ) )
                EsUnselect( out, p_sys->es[i],
                            p_sys->es[i]->p_pgrm == p_sys->p_pgrm );
        }",9,,2347,4,,void
43371,BLOCK,-1,,<empty>,17,,2349,2,,void
43391,BLOCK,-1,,<empty>,9,,2352,1,,void
43415,BLOCK,-1,,<empty>,13,,2355,2,,void
43424,BLOCK,20,,"{
#define IGNORE_ES DATA_ES
        es_out_id_t *es = va_arg( args, es_out_id_t * );

        enum es_format_category_e i_cat;
        if( es == NULL )
            i_cat = UNKNOWN_ES;
        else if( es == es_cat + AUDIO_ES )
            i_cat = AUDIO_ES;
        else if( es == es_cat + VIDEO_ES )
            i_cat = VIDEO_ES;
        else if( es == es_cat + SPU_ES )
            i_cat = SPU_ES;
        else
            i_cat = IGNORE_ES;

        for( int i = 0; i < p_sys->i_es; i++ )
        {
            if( i_cat == IGNORE_ES )
            {
                if( es == p_sys->es[i] )
                {
                    if( i_query == ES_OUT_RESTART_ES && p_sys->es[i]->p_dec )
                    {
                        EsDestroyDecoder( out, p_sys->es[i] );
                        EsCreateDecoder( out, p_sys->es[i] );
                    }
                    else if( i_query == ES_OUT_SET_ES )
                    {
                        EsOutSelect( out, es, true );
       ...",5,,2361,20,,void
43431,BLOCK,-1,,<empty>,13,,2367,2,,void
43436,BLOCK,-1,,<empty>,14,,2368,1,,void
43443,BLOCK,-1,,<empty>,13,,2369,2,,void
43448,BLOCK,-1,,<empty>,14,,2370,1,,void
43455,BLOCK,-1,,<empty>,13,,2371,2,,void
43460,BLOCK,-1,,<empty>,14,,2372,1,,void
43467,BLOCK,-1,,<empty>,13,,2373,2,,void
43472,BLOCK,-1,,<empty>,13,,2375,1,,void
43476,BLOCK,1,,<empty>,,,,1,,void
43479,BLOCK,-1,,<empty>,9,,2377,1,,void
43491,BLOCK,4,,"{
            if( i_cat == IGNORE_ES )
            {
                if( es == p_sys->es[i] )
                {
                    if( i_query == ES_OUT_RESTART_ES && p_sys->es[i]->p_dec )
                    {
                        EsDestroyDecoder( out, p_sys->es[i] );
                        EsCreateDecoder( out, p_sys->es[i] );
                    }
                    else if( i_query == ES_OUT_SET_ES )
                    {
                        EsOutSelect( out, es, true );
                    }
                    break;
                }
            }
            else
            {
                if( i_cat == UNKNOWN_ES || p_sys->es[i]->fmt.i_cat == i_cat )
                {
                    if( EsIsSelected( p_sys->es[i] ) )
                    {
                        if( i_query == ES_OUT_RESTART_ES )
                        {
                            if( p_sys->es[i]->p_dec )
                            {
                                EsDestroyDecoder( ou...",9,,2378,4,,void
43496,BLOCK,1,,<empty>,,,,1,,void
43498,BLOCK,-1,,"{
                if( es == p_sys->es[i] )
                {
                    if( i_query == ES_OUT_RESTART_ES && p_sys->es[i]->p_dec )
                    {
                        EsDestroyDecoder( out, p_sys->es[i] );
                        EsCreateDecoder( out, p_sys->es[i] );
                    }
                    else if( i_query == ES_OUT_SET_ES )
                    {
                        EsOutSelect( out, es, true );
                    }
                    break;
                }
            }",13,,2380,2,,void
43507,BLOCK,-1,,"{
                    if( i_query == ES_OUT_RESTART_ES && p_sys->es[i]->p_dec )
                    {
                        EsDestroyDecoder( out, p_sys->es[i] );
                        EsCreateDecoder( out, p_sys->es[i] );
                    }
                    else if( i_query == ES_OUT_SET_ES )
                    {
                        EsOutSelect( out, es, true );
                    }
                    break;
                }",17,,2382,2,,void
43520,BLOCK,-1,,"{
                        EsDestroyDecoder( out, p_sys->es[i] );
                        EsCreateDecoder( out, p_sys->es[i] );
                    }",21,,2384,2,,void
43536,BLOCK,-1,,<empty>,26,,2388,1,,void
43541,BLOCK,-1,,"{
                        EsOutSelect( out, es, true );
                    }",21,,2389,2,,void
43548,BLOCK,-1,,"{
                if( i_cat == UNKNOWN_ES || p_sys->es[i]->fmt.i_cat == i_cat )
                {
                    if( EsIsSelected( p_sys->es[i] ) )
                    {
                        if( i_query == ES_OUT_RESTART_ES )
                        {
                            if( p_sys->es[i]->p_dec )
                            {
                                EsDestroyDecoder( out, p_sys->es[i] );
                                EsCreateDecoder( out, p_sys->es[i] );
                            }
                        }
                        else
                        {
                            EsUnselect( out, p_sys->es[i],
                                        p_sys->es[i]->p_pgrm == p_sys->p_pgrm );
                        }
                    }
                }
            }",13,,2396,1,,void
43565,BLOCK,-1,,"{
                    if( EsIsSelected( p_sys->es[i] ) )
                    {
                        if( i_query == ES_OUT_RESTART_ES )
                        {
                            if( p_sys->es[i]->p_dec )
                            {
                                EsDestroyDecoder( out, p_sys->es[i] );
                                EsCreateDecoder( out, p_sys->es[i] );
                            }
                        }
                        else
                        {
                            EsUnselect( out, p_sys->es[i],
                                        p_sys->es[i]->p_pgrm == p_sys->p_pgrm );
                        }
                    }
                }",17,,2398,2,,void
43573,BLOCK,-1,,"{
                        if( i_query == ES_OUT_RESTART_ES )
                        {
                            if( p_sys->es[i]->p_dec )
                            {
                                EsDestroyDecoder( out, p_sys->es[i] );
                                EsCreateDecoder( out, p_sys->es[i] );
                            }
                        }
                        else
                        {
                            EsUnselect( out, p_sys->es[i],
                                        p_sys->es[i]->p_pgrm == p_sys->p_pgrm );
                        }
                    }",21,,2400,2,,void
43578,BLOCK,-1,,"{
                            if( p_sys->es[i]->p_dec )
                            {
                                EsDestroyDecoder( out, p_sys->es[i] );
                                EsCreateDecoder( out, p_sys->es[i] );
                            }
                        }",25,,2402,2,,void
43587,BLOCK,-1,,"{
                                EsDestroyDecoder( out, p_sys->es[i] );
                                EsCreateDecoder( out, p_sys->es[i] );
                            }",29,,2404,2,,void
43603,BLOCK,-1,,"{
                            EsUnselect( out, p_sys->es[i],
                                        p_sys->es[i]->p_pgrm == p_sys->p_pgrm );
                        }",25,,2410,1,,void
43626,BLOCK,23,,"{
        int *selected_es = vlc_alloc(p_sys->i_es + 1, sizeof(int));
        if (!selected_es)
            return VLC_ENOMEM;
        selected_es[0] = p_sys->i_es;
        for( int i = 0; i < p_sys->i_es; i++ )
        {
            if( EsIsSelected( p_sys->es[i] ) )
            {
                EsDestroyDecoder( out, p_sys->es[i] );
                selected_es[i + 1] = p_sys->es[i]->i_id;
            }
            else
                selected_es[i + 1] = -1;
        }
        *va_arg( args, void **) = selected_es;
        return VLC_SUCCESS;
    }",5,,2421,23,,void
43641,BLOCK,-1,,<empty>,13,,2424,2,,void
43652,BLOCK,-1,,<empty>,9,,2426,1,,void
43664,BLOCK,4,,"{
            if( EsIsSelected( p_sys->es[i] ) )
            {
                EsDestroyDecoder( out, p_sys->es[i] );
                selected_es[i + 1] = p_sys->es[i]->i_id;
            }
            else
                selected_es[i + 1] = -1;
        }",9,,2427,4,,void
43672,BLOCK,-1,,"{
                EsDestroyDecoder( out, p_sys->es[i] );
                selected_es[i + 1] = p_sys->es[i]->i_id;
            }",13,,2429,2,,void
43694,BLOCK,-1,,<empty>,17,,2434,1,,void
43708,BLOCK,26,,"{
        int *selected_es = va_arg( args, void * );
        int count = selected_es[0];
        for( int i = 0; i < count; ++i )
        {
            int i_id = selected_es[i + 1];
            if( i_id != -1 )
            {
                es_out_id_t *p_es = EsOutGetFromID( out, i_id );
                EsCreateDecoder( out, p_es );
            }
        }
        free(selected_es);
        return VLC_SUCCESS;
    }",5,,2440,26,,void
43717,BLOCK,-1,,<empty>,9,,2443,1,,void
43727,BLOCK,4,,"{
            int i_id = selected_es[i + 1];
            if( i_id != -1 )
            {
                es_out_id_t *p_es = EsOutGetFromID( out, i_id );
                EsCreateDecoder( out, p_es );
            }
        }",9,,2444,4,,void
43741,BLOCK,-1,,"{
                es_out_id_t *p_es = EsOutGetFromID( out, i_id );
                EsCreateDecoder( out, p_es );
            }",13,,2447,2,,void
43757,BLOCK,29,,"{
        es_out_id_t *es = va_arg( args, es_out_id_t * );

        if( es == NULL )
        {
            /*p_sys->i_default_video_id = -1;*/
            /*p_sys->i_default_audio_id = -1;*/
            p_sys->sub.i_demux_id = -1;
        }
        else if( es == es_cat + AUDIO_ES )
        {
            /*p_sys->i_default_video_id = -1;*/
        }
        else if( es == es_cat + VIDEO_ES )
        {
            /*p_sys->i_default_audio_id = -1;*/
        }
        else if( es == es_cat + SPU_ES )
        {
            p_sys->sub.i_demux_id = -1;
        }
        else
        {
            /*if( es->fmt.i_cat == VIDEO_ES )
                p_sys->i_default_video_id = es->i_id;
            else
            if( es->fmt.i_cat == AUDIO_ES )
                p_sys->i_default_audio_id = es->i_id;
            else*/
            if( es->fmt.i_cat == SPU_ES )
                p_sys->sub.i_demux_id = es->i_id;
        }
        return VLC_SUCCESS;
    }",5,,2457,29,,void
43763,BLOCK,-1,,"{
            /*p_sys->i_default_video_id = -1;*/
            /*p_sys->i_default_audio_id = -1;*/
            p_sys->sub.i_demux_id = -1;
        }",9,,2461,2,,void
43773,BLOCK,-1,,<empty>,14,,2466,1,,void
43780,BLOCK,-1,,"{
            /*p_sys->i_default_video_id = -1;*/
        }",9,,2467,2,,void
43782,BLOCK,-1,,<empty>,14,,2470,1,,void
43789,BLOCK,-1,,"{
            /*p_sys->i_default_audio_id = -1;*/
        }",9,,2471,2,,void
43791,BLOCK,-1,,<empty>,14,,2474,1,,void
43798,BLOCK,-1,,"{
            p_sys->sub.i_demux_id = -1;
        }",9,,2475,2,,void
43808,BLOCK,-1,,"{
            /*if( es->fmt.i_cat == VIDEO_ES )
                p_sys->i_default_video_id = es->i_id;
            else
            if( es->fmt.i_cat == AUDIO_ES )
                p_sys->i_default_audio_id = es->i_id;
            else*/
            if( es->fmt.i_cat == SPU_ES )
                p_sys->sub.i_demux_id = es->i_id;
        }",9,,2479,1,,void
43817,BLOCK,-1,,<empty>,17,,2487,2,,void
43833,BLOCK,34,,"{
        es_out_pgrm_t *p_pgrm = NULL;
        int            i_group = 0;
        int64_t        i_pcr;

        /* Search program */
        if( i_query == ES_OUT_SET_PCR )
        {
            p_pgrm = p_sys->p_pgrm;
            if( !p_pgrm )
                p_pgrm = EsOutProgramAdd( out, i_group );   /* Create it */
        }
        else
        {
            i_group = va_arg( args, int );
            p_pgrm = EsOutProgramFind( out, i_group );
        }
        if( !p_pgrm )
            return VLC_EGENERIC;

        i_pcr = va_arg( args, int64_t );
        if( i_pcr <= VLC_TS_INVALID )
        {
            msg_Err( p_sys->p_input, ""Invalid PCR value in ES_OUT_SET_(GROUP_)PCR !"" );
            return VLC_EGENERIC;
        }

        p_pgrm->i_last_pcr = i_pcr;

        /* TODO do not use mdate() but proper stream acquisition date */
        bool b_late;
        input_clock_Update( p_pgrm->p_clock, VLC_OBJECT(p_sys->p_input),
                            &b_late,
              ...",5,,2494,34,,void
43847,BLOCK,-1,,"{
            p_pgrm = p_sys->p_pgrm;
            if( !p_pgrm )
                p_pgrm = EsOutProgramAdd( out, i_group );   /* Create it */
        }",9,,2501,2,,void
43856,BLOCK,-1,,<empty>,17,,2504,2,,void
43863,BLOCK,-1,,"{
            i_group = va_arg( args, int );
            p_pgrm = EsOutProgramFind( out, i_group );
        }",9,,2507,1,,void
43873,BLOCK,-1,,<empty>,13,,2512,2,,void
43885,BLOCK,-1,,"{
            msg_Err( p_sys->p_input, ""Invalid PCR value in ES_OUT_SET_(GROUP_)PCR !"" );
            return VLC_EGENERIC;
        }",9,,2516,2,,void
43928,BLOCK,-1,,<empty>,13,,2532,2,,void
43935,BLOCK,-1,,"{
            /* Check buffering state on master clock update */
            EsOutDecodersStopBuffering( out, false );
        }",9,,2535,2,,void
43940,BLOCK,-1,,<empty>,14,,2539,1,,void
43947,BLOCK,-1,,"{
            if( b_late && ( !input_priv(p_sys->p_input)->p_sout ||
                            !input_priv(p_sys->p_input)->b_out_pace_control ) )
            {
                const mtime_t i_pts_delay_base = p_sys->i_pts_delay - p_sys->i_pts_jitter;
                mtime_t i_pts_delay = input_clock_GetJitter( p_pgrm->p_clock );

                /* Avoid dangerously high value */
                const mtime_t i_jitter_max = INT64_C(1000) * var_InheritInteger( p_sys->p_input, ""clock-jitter"" );
                if( i_pts_delay > __MIN( i_pts_delay_base + i_jitter_max, INPUT_PTS_DELAY_MAX ) )
                {
                    msg_Err( p_sys->p_input,
                             ""ES_OUT_SET_(GROUP_)PCR  is called too late (jitter of %d ms ignored)"",
                             (int)(i_pts_delay - i_pts_delay_base) / 1000 );
                    i_pts_delay = p_sys->i_pts_delay;

                    /* reset clock */
                    for( int i = 0; i < p_sys->i_pgrm; i++ )
   ...",9,,2540,2,,void
43966,BLOCK,-1,,"{
                const mtime_t i_pts_delay_base = p_sys->i_pts_delay - p_sys->i_pts_jitter;
                mtime_t i_pts_delay = input_clock_GetJitter( p_pgrm->p_clock );

                /* Avoid dangerously high value */
                const mtime_t i_jitter_max = INT64_C(1000) * var_InheritInteger( p_sys->p_input, ""clock-jitter"" );
                if( i_pts_delay > __MIN( i_pts_delay_base + i_jitter_max, INPUT_PTS_DELAY_MAX ) )
                {
                    msg_Err( p_sys->p_input,
                             ""ES_OUT_SET_(GROUP_)PCR  is called too late (jitter of %d ms ignored)"",
                             (int)(i_pts_delay - i_pts_delay_base) / 1000 );
                    i_pts_delay = p_sys->i_pts_delay;

                    /* reset clock */
                    for( int i = 0; i < p_sys->i_pgrm; i++ )
                      input_clock_Reset( p_sys->pgrm[i]->p_clock );
                }
                else
                {
                    msg_Err( p_sys->p_i...",13,,2543,2,,void
44003,BLOCK,1,,<empty>,,,,1,,void
44006,BLOCK,-1,,"{
                    msg_Err( p_sys->p_input,
                             ""ES_OUT_SET_(GROUP_)PCR  is called too late (jitter of %d ms ignored)"",
                             (int)(i_pts_delay - i_pts_delay_base) / 1000 );
                    i_pts_delay = p_sys->i_pts_delay;

                    /* reset clock */
                    for( int i = 0; i < p_sys->i_pgrm; i++ )
                      input_clock_Reset( p_sys->pgrm[i]->p_clock );
                }",17,,2550,2,,void
44025,BLOCK,-1,,<empty>,21,,2557,1,,void
44046,BLOCK,-1,,"{
                    msg_Err( p_sys->p_input,
                             ""ES_OUT_SET_(GROUP_)PCR  is called too late (pts_delay increased to %d ms)"",
                             (int)(i_pts_delay/1000) );

                    /* Force a rebufferization when we are too late */

                    /* It is not really good, as we throw away already buffered data
                     * TODO have a mean to correctly reenter bufferization */
                    es_out_Control( out, ES_OUT_RESET_PCR );
                }",17,,2561,1,,void
44084,BLOCK,42,,"{
        int i = va_arg( args, int );
        for( int j = 0; j < p_sys->i_pgrm; j++ )
        {
            es_out_pgrm_t *p_pgrm = p_sys->pgrm[j];
            if( p_pgrm->i_id == i )
            {
                EsOutProgramSelect( out, p_pgrm );
                return VLC_SUCCESS;
            }
        }
        return VLC_EGENERIC;
    }",5,,2585,42,,void
44087,BLOCK,-1,,<empty>,9,,2587,1,,void
44099,BLOCK,4,,"{
            es_out_pgrm_t *p_pgrm = p_sys->pgrm[j];
            if( p_pgrm->i_id == i )
            {
                EsOutProgramSelect( out, p_pgrm );
                return VLC_SUCCESS;
            }
        }",9,,2588,4,,void
44114,BLOCK,-1,,"{
                EsOutProgramSelect( out, p_pgrm );
                return VLC_SUCCESS;
            }",13,,2591,2,,void
44124,BLOCK,45,,"{
        /* This ain't pretty but is need by some demuxers (eg. Ogg )
         * to update the p_extra data */
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        es_format_t *p_fmt = va_arg( args, es_format_t * );
        if( es == NULL )
            return VLC_EGENERIC;

        es_format_Clean( &es->fmt );
        es_format_Copy( &es->fmt, p_fmt );

        if( es->p_dec )
        {
            EsDestroyDecoder( out, es );
            EsCreateDecoder( out, es );
        }

        return VLC_SUCCESS;
    }",5,,2600,45,,void
44131,BLOCK,-1,,<empty>,13,,2606,2,,void
44149,BLOCK,-1,,"{
            EsDestroyDecoder( out, es );
            EsCreateDecoder( out, es );
        }",9,,2612,2,,void
44160,BLOCK,48,,"{
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool b_scrambled = (bool)va_arg( args, int );

        if( !es->b_scrambled != !b_scrambled )
        {
            es->b_scrambled = b_scrambled;
            EsOutProgramUpdateScrambled( out, es->p_pgrm );
        }
        return VLC_SUCCESS;
    }",5,,2621,48,,void
44176,BLOCK,-1,,"{
            es->b_scrambled = b_scrambled;
            EsOutProgramUpdateScrambled( out, es->p_pgrm );
        }",9,,2626,2,,void
44191,BLOCK,51,,"{
        const int64_t i_date = va_arg( args, int64_t );

        if( i_date < 0 )
            return VLC_EGENERIC;

        p_sys->i_preroll_end = i_date;

        return VLC_SUCCESS;
    }",5,,2634,51,,void
44202,BLOCK,-1,,<empty>,13,,2638,2,,void
44214,BLOCK,54,,"{
        int i_group = va_arg( args, int );
        const vlc_meta_t *p_meta = va_arg( args, const vlc_meta_t * );

        EsOutProgramMeta( out, i_group, p_meta );
        return VLC_SUCCESS;
    }",5,,2645,54,,void
44227,BLOCK,57,,"{
        int i_group = va_arg( args, int );
        const vlc_epg_t *p_epg = va_arg( args, const vlc_epg_t * );

        EsOutProgramEpg( out, i_group, p_epg );
        return VLC_SUCCESS;
    }",5,,2653,57,,void
44240,BLOCK,60,,"{
        int i_group = va_arg( args, int );
        const vlc_epg_event_t *p_evt = va_arg( args, const vlc_epg_event_t * );

        EsOutProgramEpgEvent( out, i_group, p_evt );
        return VLC_SUCCESS;
    }",5,,2661,60,,void
44253,BLOCK,63,,"{
        int64_t i64 = va_arg( args, int64_t );

        EsOutEpgTime( out, i64 );
        return VLC_SUCCESS;
    }",5,,2669,63,,void
44267,BLOCK,66,,"{
        int i_group = va_arg( args, int );

        return EsOutProgramDel( out, i_group );
    }",5,,2677,66,,void
44275,BLOCK,69,,"{
        const vlc_meta_t *p_meta = va_arg( args, const vlc_meta_t * );

        EsOutGlobalMeta( out, p_meta );
        return VLC_SUCCESS;
    }",5,,2684,69,,void
44286,BLOCK,72,,"{
        mtime_t *pi_wakeup = va_arg( args, mtime_t* );
        *pi_wakeup = EsOutGetWakeup( out );
        return VLC_SUCCESS;
    }",5,,2692,72,,void
44301,BLOCK,79,,"{
        const int i_id = va_arg( args, int );
        es_out_id_t *p_es = EsOutGetFromID( out, i_id );
        int i_new_query = 0;

        switch( i_query )
        {
        case ES_OUT_SET_ES_BY_ID:         i_new_query = ES_OUT_SET_ES; break;
        case ES_OUT_RESTART_ES_BY_ID:     i_new_query = ES_OUT_RESTART_ES; break;
        case ES_OUT_SET_ES_DEFAULT_BY_ID: i_new_query = ES_OUT_SET_ES_DEFAULT; break;
        default:
          vlc_assert_unreachable();
        }
        /* TODO if the lock is made non recursive it should be changed */
        int i_ret = es_out_Control( out, i_new_query, p_es );

        /* Clean up vout after user action (in active mode only).
         * FIXME it does not work well with multiple video windows */
        if( p_sys->b_active )
            input_resource_TerminateVout( input_priv(p_sys->p_input)->p_resource );
        return i_ret;
    }",5,,2701,79,,void
44315,BLOCK,-1,,"{
        case ES_OUT_SET_ES_BY_ID:         i_new_query = ES_OUT_SET_ES; break;
        case ES_OUT_RESTART_ES_BY_ID:     i_new_query = ES_OUT_RESTART_ES; break;
        case ES_OUT_SET_ES_DEFAULT_BY_ID: i_new_query = ES_OUT_SET_ES_DEFAULT; break;
        default:
          vlc_assert_unreachable();
        }",9,,2707,2,,void
44347,BLOCK,-1,,<empty>,13,,2720,2,,void
44359,BLOCK,82,,"{
        const int i_id = va_arg( args, int );
        es_out_id_t *p_es = EsOutGetFromID( out, i_id );
        if( !p_es )
            return VLC_EGENERIC;

        vlc_object_t    **pp_decoder = va_arg( args, vlc_object_t ** );
        vout_thread_t   **pp_vout    = va_arg( args, vout_thread_t ** );
        audio_output_t **pp_aout    = va_arg( args, audio_output_t ** );
        if( p_es->p_dec )
        {
            if( pp_decoder )
                *pp_decoder = vlc_object_hold( p_es->p_dec );
            input_DecoderGetObjects( p_es->p_dec, pp_vout, pp_aout );
        }
        else
        {
            if( pp_decoder )
                *pp_decoder = NULL;
            if( pp_vout )
                *pp_vout = NULL;
            if( pp_aout )
                *pp_aout = NULL;
        }
        return VLC_SUCCESS;
    }",5,,2725,82,,void
44370,BLOCK,-1,,<empty>,13,,2729,2,,void
44380,BLOCK,-1,,"{
            if( pp_decoder )
                *pp_decoder = vlc_object_hold( p_es->p_dec );
            input_DecoderGetObjects( p_es->p_dec, pp_vout, pp_aout );
        }",9,,2735,2,,void
44383,BLOCK,-1,,<empty>,17,,2737,2,,void
44398,BLOCK,-1,,"{
            if( pp_decoder )
                *pp_decoder = NULL;
            if( pp_vout )
                *pp_vout = NULL;
            if( pp_aout )
                *pp_aout = NULL;
        }",9,,2741,1,,void
44401,BLOCK,-1,,<empty>,17,,2743,2,,void
44408,BLOCK,-1,,<empty>,17,,2745,2,,void
44415,BLOCK,-1,,<empty>,17,,2747,2,,void
44424,BLOCK,85,,"{
        bool *pb = va_arg( args, bool* );
        *pb = p_sys->b_buffering;
        return VLC_SUCCESS;
    }",5,,2753,85,,void
44436,BLOCK,88,,"{
        bool *pb = va_arg( args, bool* );
        *pb = EsOutDecodersIsEmpty( out );
        return VLC_SUCCESS;
    }",5,,2760,88,,void
44447,BLOCK,91,,"{
        const int i_cat = va_arg( args, int );
        const mtime_t i_delay = va_arg( args, mtime_t );
        EsOutSetDelay( out, i_cat, i_delay );
        return VLC_SUCCESS;
    }",5,,2767,91,,void
44463,BLOCK,94,,"{
        bool b = va_arg( args, int );
        return EsOutSetRecord( out, b );
    }",5,,2775,94,,void
44473,BLOCK,97,,"{
        const bool b_source_paused = (bool)va_arg( args, int );
        const bool b_paused = (bool)va_arg( args, int );
        const mtime_t i_date = va_arg( args, mtime_t );

        assert( !b_source_paused == !b_paused );
        EsOutChangePause( out, b_paused, i_date );

        return VLC_SUCCESS;
    }",5,,2781,97,,void
44506,BLOCK,100,,"{
        const int i_src_rate = va_arg( args, int );
        const int i_rate = va_arg( args, int );

        assert( i_src_rate == i_rate );
        EsOutChangeRate( out, i_rate );

        return VLC_SUCCESS;
    }",5,,2793,100,,void
44520,BLOCK,103,,"{
        const mtime_t i_date = va_arg( args, mtime_t );

        assert( i_date == -1 );
        EsOutChangePosition( out );

        return VLC_SUCCESS;
    }",5,,2804,103,,void
44544,BLOCK,110,,"{
        double f_position = va_arg( args, double );
        mtime_t i_time = va_arg( args, mtime_t );
        mtime_t i_length = va_arg( args, mtime_t );

        input_SendEventLength( p_sys->p_input, i_length );

        if( !p_sys->b_buffering )
        {
            mtime_t i_delay;

            /* Fix for buffering delay */
            if( !input_priv(p_sys->p_input)->p_sout ||
                !input_priv(p_sys->p_input)->b_out_pace_control )
                i_delay = EsOutGetBuffering( out );
            else
                i_delay = 0;

            i_time -= i_delay;
            if( i_time < 0 )
                i_time = 0;

            if( i_length > 0 )
                f_position -= (double)i_delay / i_length;
            if( f_position < 0 )
                f_position = 0;

            input_SendEventPosition( p_sys->p_input, f_position, i_time );
        }
        return VLC_SUCCESS;
    }",5,,2818,110,,void
44568,BLOCK,-1,,"{
            mtime_t i_delay;

            /* Fix for buffering delay */
            if( !input_priv(p_sys->p_input)->p_sout ||
                !input_priv(p_sys->p_input)->b_out_pace_control )
                i_delay = EsOutGetBuffering( out );
            else
                i_delay = 0;

            i_time -= i_delay;
            if( i_time < 0 )
                i_time = 0;

            if( i_length > 0 )
                f_position -= (double)i_delay / i_length;
            if( f_position < 0 )
                f_position = 0;

            input_SendEventPosition( p_sys->p_input, f_position, i_time );
        }",9,,2826,2,,void
44586,BLOCK,-1,,<empty>,17,,2832,2,,void
44592,BLOCK,-1,,<empty>,17,,2834,1,,void
44603,BLOCK,-1,,<empty>,17,,2838,2,,void
44611,BLOCK,-1,,<empty>,17,,2841,2,,void
44623,BLOCK,-1,,<empty>,17,,2843,2,,void
44637,BLOCK,113,,"{
        mtime_t i_pts_delay  = va_arg( args, mtime_t );
        mtime_t i_pts_jitter = va_arg( args, mtime_t );
        int     i_cr_average = va_arg( args, int );

        bool b_change_clock =
            i_pts_delay + i_pts_jitter != p_sys->i_pts_delay ||
            i_cr_average != p_sys->i_cr_average;

        assert( i_pts_jitter >= 0 );
        p_sys->i_pts_delay  = i_pts_delay + i_pts_jitter;
        p_sys->i_pts_jitter = i_pts_jitter;
        p_sys->i_cr_average = i_cr_average;

        for( int i = 0; i < p_sys->i_pgrm && b_change_clock; i++ )
            input_clock_SetJitter( p_sys->pgrm[i]->p_clock,
                                   i_pts_delay + i_pts_jitter, i_cr_average );
        return VLC_SUCCESS;
    }",5,,2850,113,,void
44689,BLOCK,-1,,<empty>,9,,2864,1,,void
44719,BLOCK,116,,"{
        if( p_sys->b_buffering )
            return VLC_EGENERIC;

        es_out_pgrm_t *p_pgrm = p_sys->p_pgrm;
        if( !p_pgrm )
            return VLC_EGENERIC;

        mtime_t *pi_system = va_arg( args, mtime_t *);
        mtime_t *pi_delay  = va_arg( args, mtime_t *);
        input_clock_GetSystemOrigin( p_pgrm->p_clock, pi_system, pi_delay );
        return VLC_SUCCESS;
    }",5,,2871,116,,void
44724,BLOCK,-1,,<empty>,13,,2873,2,,void
44736,BLOCK,-1,,<empty>,13,,2877,2,,void
44751,BLOCK,119,,"{
        if( p_sys->b_buffering )
            return VLC_EGENERIC;

        es_out_pgrm_t *p_pgrm = p_sys->p_pgrm;
        if( !p_pgrm )
            return VLC_EGENERIC;

        const bool    b_absolute = va_arg( args, int );
        const mtime_t i_system   = va_arg( args, mtime_t );
        input_clock_ChangeSystemOrigin( p_pgrm->p_clock, b_absolute, i_system );
        return VLC_SUCCESS;
    }",5,,2886,119,,void
44756,BLOCK,-1,,<empty>,13,,2888,2,,void
44768,BLOCK,-1,,<empty>,13,,2892,2,,void
44790,BLOCK,122,,"{
        for (int i = 0; i < p_sys->i_es; i++) {
            es_out_id_t *id = p_sys->es[i];
            if (id->p_dec != NULL)
                input_DecoderDrain(id->p_dec);
        }
        return VLC_SUCCESS;
    }",5,,2900,122,,void
44792,BLOCK,-1,,<empty>,9,,2901,1,,void
44804,BLOCK,4,,"{
            es_out_id_t *id = p_sys->es[i];
            if (id->p_dec != NULL)
                input_DecoderDrain(id->p_dec);
        }",47,,2901,4,,void
44819,BLOCK,-1,,<empty>,17,,2904,2,,void
44828,BLOCK,125,,"{
        input_item_node_t *node = va_arg(args, input_item_node_t *);
        input_item_node_PostAndDelete(node);
        return VLC_SUCCESS;
    }",5,,2910,125,,void
44850,BLOCK,-1,,"{
    es_out_sys_t *p_sys = out->p_sys;
    int i_ret;

    vlc_mutex_lock( &p_sys->lock );
    i_ret = EsOutControlLocked( out, i_query, args );
    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",1,,2923,4,,void
44880,BLOCK,-1,,"{
    const iso639_lang_t *pl;

    if( psz_code == NULL || !strcmp( psz_code, ""und"" ) )
    {
        return strdup( """" );
    }

    if( strlen( psz_code ) == 2 )
    {
        pl = GetLang_1( psz_code );
    }
    else if( strlen( psz_code ) == 3 )
    {
        pl = GetLang_2B( psz_code );
        if( !strcmp( pl->psz_iso639_1, ""??"" ) )
        {
            pl = GetLang_2T( psz_code );
        }
    }
    else
    {
        char *lang = LanguageGetCode( psz_code );
        pl = GetLang_1( lang );
        free( lang );
    }

    if( !strcmp( pl->psz_iso639_1, ""??"" ) )
    {
       return strdup( psz_code );
    }
    else
    {
        return strdup( vlc_gettext(pl->psz_eng_name) );
    }
}",1,,2938,2,,void
44891,BLOCK,-1,,"{
        return strdup( """" );
    }",5,,2942,2,,void
44900,BLOCK,-1,,"{
        pl = GetLang_1( psz_code );
    }",5,,2947,2,,void
44906,BLOCK,-1,,<empty>,10,,2950,1,,void
44912,BLOCK,-1,,"{
        pl = GetLang_2B( psz_code );
        if( !strcmp( pl->psz_iso639_1, ""??"" ) )
        {
            pl = GetLang_2T( psz_code );
        }
    }",5,,2951,2,,void
44924,BLOCK,-1,,"{
            pl = GetLang_2T( psz_code );
        }",9,,2954,2,,void
44930,BLOCK,-1,,"{
        char *lang = LanguageGetCode( psz_code );
        pl = GetLang_1( lang );
        free( lang );
    }",5,,2959,1,,void
44949,BLOCK,-1,,"{
       return strdup( psz_code );
    }",5,,2966,2,,void
44954,BLOCK,-1,,"{
        return strdup( vlc_gettext(pl->psz_eng_name) );
    }",5,,2970,1,,void
44965,BLOCK,-1,,"{
    const iso639_lang_t *pl;

    if( psz_lang == NULL || *psz_lang == '\0' )
        return strdup(""??"");

    for( pl = p_languages; pl->psz_eng_name != NULL; pl++ )
    {
        if( !strcasecmp( pl->psz_eng_name, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_1, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2T, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2B, psz_lang ) )
            return strdup( pl->psz_iso639_1 );
    }

    return strdup(""??"");
}",1,,2977,2,,void
44976,BLOCK,-1,,<empty>,9,,2981,2,,void
44981,BLOCK,-1,,<empty>,5,,2983,1,,void
44992,BLOCK,4,,"{
        if( !strcasecmp( pl->psz_eng_name, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_1, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2T, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2B, psz_lang ) )
            return strdup( pl->psz_iso639_1 );
    }",5,,2984,4,,void
45021,BLOCK,-1,,<empty>,13,,2989,2,,void
45034,BLOCK,-1,,"{
    char *psz_dup;
    char *psz_parser;
    char **ppsz = NULL;
    int i_psz = 0;

    if( psz_langs == NULL ) return NULL;

    psz_parser = psz_dup = strdup(psz_langs);

    while( psz_parser && *psz_parser )
    {
        char *psz;
        char *psz_code;

        psz = strchr(psz_parser, ',' );
        if( psz ) *psz++ = '\0';

        if( !strcmp( psz_parser, ""any"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""any"") );
        }
        else if( !strcmp( psz_parser, ""none"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""none"") );
        }
        else
        {
            psz_code = LanguageGetCode( psz_parser );
            if( strcmp( psz_code, ""??"" ) )
            {
                TAB_APPEND( i_psz, ppsz, psz_code );
            }
            else
            {
                free( psz_code );
            }
        }

        psz_parser = psz;
    }

    if( i_psz )
    {
        TAB_APPEND( i_psz, ppsz, NULL );
    }

    free( psz_dup );
  ...",1,,2996,2,,void
45049,BLOCK,-1,,<empty>,29,,3002,2,,void
45063,BLOCK,-1,,"{
        char *psz;
        char *psz_code;

        psz = strchr(psz_parser, ',' );
        if( psz ) *psz++ = '\0';

        if( !strcmp( psz_parser, ""any"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""any"") );
        }
        else if( !strcmp( psz_parser, ""none"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""none"") );
        }
        else
        {
            psz_code = LanguageGetCode( psz_parser );
            if( strcmp( psz_code, ""??"" ) )
            {
                TAB_APPEND( i_psz, ppsz, psz_code );
            }
            else
            {
                free( psz_code );
            }
        }

        psz_parser = psz;
    }",5,,3007,2,,void
45073,BLOCK,-1,,<empty>,19,,3012,2,,void
45084,BLOCK,-1,,"{
            TAB_APPEND( i_psz, ppsz, strdup(""any"") );
        }",9,,3015,2,,void
45091,BLOCK,-1,,<empty>,14,,3018,1,,void
45097,BLOCK,-1,,"{
            TAB_APPEND( i_psz, ppsz, strdup(""none"") );
        }",9,,3019,2,,void
45104,BLOCK,-1,,"{
            psz_code = LanguageGetCode( psz_parser );
            if( strcmp( psz_code, ""??"" ) )
            {
                TAB_APPEND( i_psz, ppsz, psz_code );
            }
            else
            {
                free( psz_code );
            }
        }",9,,3023,1,,void
45113,BLOCK,-1,,"{
                TAB_APPEND( i_psz, ppsz, psz_code );
            }",13,,3026,2,,void
45119,BLOCK,-1,,"{
                free( psz_code );
            }",13,,3030,1,,void
45127,BLOCK,-1,,"{
        TAB_APPEND( i_psz, ppsz, NULL );
    }",5,,3039,2,,void
45141,BLOCK,-1,,"{
    if( !ppsz_langs || !psz_lang )
        return -1;

    for( int i = 0; ppsz_langs[i]; i++ )
    {
        if( !strcasecmp( ppsz_langs[i], psz_lang ) ||
            ( !strcasecmp( ppsz_langs[i], ""any"" ) && strcasecmp( psz_lang, ""none"") ) )
            return i;
        if( !strcasecmp( ppsz_langs[i], ""none"" ) )
            break;
    }

    return -1;
}",1,,3048,3,,void
45148,BLOCK,-1,,<empty>,9,,3050,2,,void
45153,BLOCK,-1,,<empty>,5,,3052,1,,void
45163,BLOCK,4,,"{
        if( !strcasecmp( ppsz_langs[i], psz_lang ) ||
            ( !strcasecmp( ppsz_langs[i], ""any"" ) && strcasecmp( psz_lang, ""none"") ) )
            return i;
        if( !strcasecmp( ppsz_langs[i], ""none"" ) )
            break;
    }",5,,3053,4,,void
45182,BLOCK,-1,,<empty>,13,,3056,2,,void
45192,BLOCK,-1,,<empty>,13,,3058,2,,void
45204,BLOCK,-1,,"{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;
    const es_format_t *p_fmt_es = &es->fmt;
    lldiv_t         div;

    if( es->fmt.i_cat == fmt->i_cat )
    {
        es_format_t update = *fmt;
        update.i_id = es->i_meta_id;
        update.i_codec = es->fmt.i_codec;
        update.i_original_fourcc = es->fmt.i_original_fourcc;

        /* Update infos that could have been lost by the decoder (no need to
         * dup them since input_item_UpdateTracksInfo() will do it). */
        if (update.psz_language == NULL)
            update.psz_language = es->fmt.psz_language;
        if (update.psz_description == NULL)
            update.psz_description = es->fmt.psz_description;
        if (update.i_cat == SPU_ES)
        {
            if (update.subs.psz_encoding == NULL)
                update.subs.psz_encoding = es->fmt.subs.psz_encoding;
            if (update.subs.p_style == NULL)
                update.subs.p_style = es->fmt.subs.p_st...",1,,3069,5,,void
45235,BLOCK,-1,,"{
        es_format_t update = *fmt;
        update.i_id = es->i_meta_id;
        update.i_codec = es->fmt.i_codec;
        update.i_original_fourcc = es->fmt.i_original_fourcc;

        /* Update infos that could have been lost by the decoder (no need to
         * dup them since input_item_UpdateTracksInfo() will do it). */
        if (update.psz_language == NULL)
            update.psz_language = es->fmt.psz_language;
        if (update.psz_description == NULL)
            update.psz_description = es->fmt.psz_description;
        if (update.i_cat == SPU_ES)
        {
            if (update.subs.psz_encoding == NULL)
                update.subs.psz_encoding = es->fmt.subs.psz_encoding;
            if (update.subs.p_style == NULL)
                update.subs.p_style = es->fmt.subs.p_style;
        }
        if (update.i_extra_languages == 0)
        {
            assert(update.p_extra_languages == NULL);
            update.i_extra_languages = es->fmt.i_extra_languages;
            ...",5,,3076,2,,void
45272,BLOCK,-1,,<empty>,13,,3085,2,,void
45288,BLOCK,-1,,<empty>,13,,3087,2,,void
45304,BLOCK,-1,,"{
            if (update.subs.psz_encoding == NULL)
                update.subs.psz_encoding = es->fmt.subs.psz_encoding;
            if (update.subs.p_style == NULL)
                update.subs.p_style = es->fmt.subs.p_style;
        }",9,,3089,2,,void
45313,BLOCK,-1,,<empty>,17,,3091,2,,void
45335,BLOCK,-1,,<empty>,17,,3093,2,,void
45355,BLOCK,-1,,"{
            assert(update.p_extra_languages == NULL);
            update.i_extra_languages = es->fmt.i_extra_languages;
            update.p_extra_languages = es->fmt.p_extra_languages;
        }",9,,3096,2,,void
45404,BLOCK,-1,,<empty>,9,,3113,2,,void
45417,BLOCK,-1,,<empty>,9,,3120,2,,void
45427,BLOCK,-1,,<empty>,9,,3124,2,,void
45462,BLOCK,-1,,<empty>,9,,3132,2,,void
45474,BLOCK,-1,,<empty>,10,,3134,1,,void
45483,BLOCK,-1,,<empty>,9,,3135,2,,void
45502,BLOCK,-1,,<empty>,9,,3139,2,,void
45520,BLOCK,-1,,<empty>,9,,3142,2,,void
45533,BLOCK,-1,,"{
    case AUDIO_ES:
        info_category_AddInfo( p_cat, _(""Type""), _(""Audio"") );

        if( fmt->audio.i_physical_channels )
            info_category_AddInfo( p_cat, _(""Channels""), ""%s"",
                                   _( aout_FormatPrintChannels( &fmt->audio ) ) );

        if( fmt->audio.i_rate != 0 )
        {
            info_category_AddInfo( p_cat, _(""Sample rate""), _(""%u Hz""),
                                   fmt->audio.i_rate );
            /* FIXME that should be removed or improved ! (used by text/strings.c) */
            var_SetInteger( p_input, ""sample-rate"", fmt->audio.i_rate );
        }

        unsigned int i_bitspersample = fmt->audio.i_bitspersample;
        if( i_bitspersample == 0 )
            i_bitspersample = aout_BitsPerSample( p_fmt_es->i_codec );
        if( i_bitspersample != 0 )
            info_category_AddInfo( p_cat, _(""Bits per sample""), ""%u"",
                                   i_bitspersample );

        if( fmt->i_bitrate != 0 )
        ...",5,,3146,2,,void
45548,BLOCK,-1,,<empty>,13,,3151,2,,void
45568,BLOCK,-1,,"{
            info_category_AddInfo( p_cat, _(""Sample rate""), _(""%u Hz""),
                                   fmt->audio.i_rate );
            /* FIXME that should be removed or improved ! (used by text/strings.c) */
            var_SetInteger( p_input, ""sample-rate"", fmt->audio.i_rate );
        }",9,,3155,2,,void
45600,BLOCK,-1,,<empty>,13,,3164,2,,void
45611,BLOCK,-1,,<empty>,13,,3166,2,,void
45624,BLOCK,-1,,"{
            info_category_AddInfo( p_cat, _(""Bitrate""), _(""%u kb/s""),
                                   fmt->i_bitrate / 1000 );
            /* FIXME that should be removed or improved ! (used by text/strings.c) */
            var_SetInteger( p_input, ""bit-rate"", fmt->i_bitrate );
        }",9,,3170,2,,void
45643,BLOCK,-1,,<empty>,9,,3176,1,,void
45653,BLOCK,4,,"{
            const audio_replay_gain_t *p_rg = &fmt->audio_replay_gain;
            if( !p_rg->pb_gain[i] )
                continue;
            const char *psz_name;
            if( i == AUDIO_REPLAY_GAIN_TRACK )
                psz_name = _(""Track replay gain"");
            else
                psz_name = _(""Album replay gain"");
            info_category_AddInfo( p_cat, psz_name, _(""%.2f dB""),
                                   p_rg->pf_gain[i] );
        }",9,,3177,4,,void
45668,BLOCK,-1,,<empty>,17,,3180,2,,void
45675,BLOCK,-1,,<empty>,17,,3183,2,,void
45681,BLOCK,-1,,<empty>,17,,3185,1,,void
45721,BLOCK,-1,,<empty>,13,,3196,2,,void
45753,BLOCK,-1,,<empty>,13,,3201,2,,void
45785,BLOCK,-1,,"{
           div = lldiv( (float)fmt->video.i_frame_rate /
                               fmt->video.i_frame_rate_base * 1000000,
                               1000000 );
           if( div.rem > 0 )
               info_category_AddInfo( p_cat, _(""Frame rate""), ""%""PRId64"".%06u"",
                                      div.quot, (unsigned int )div.rem );
           else
               info_category_AddInfo( p_cat, _(""Frame rate""), ""%""PRId64,
                                      div.quot );
       }",8,,3206,2,,void
45815,BLOCK,-1,,"{
           const char *psz_chroma_description =
                vlc_fourcc_GetDescription( VIDEO_ES, fmt->i_codec );
           if( psz_chroma_description )
               info_category_AddInfo( p_cat, _(""Decoded format""), ""%s"",
                                      psz_chroma_description );
       }",8,,3218,2,,void
45826,BLOCK,-1,,<empty>,16,,3222,2,,void
45833,BLOCK,20,,"{
           static const char orient_names[][13] = {
               N_(""Top left""), N_(""Left top""),
               N_(""Right bottom""), N_(""Top right""),
               N_(""Bottom left""), N_(""Bottom right""),
               N_(""Left bottom""), N_(""Right top""),
           };
           info_category_AddInfo( p_cat, _(""Orientation""), ""%s"",
                                  _(orient_names[fmt->video.orientation]) );
       }",8,,3225,20,,void
45875,BLOCK,-1,,"{
           static const char primaries_names[][32] = {
               [COLOR_PRIMARIES_UNDEF] = N_(""Undefined""),
               [COLOR_PRIMARIES_BT601_525] =
                   N_(""ITU-R BT.601 (525 lines, 60 Hz)""),
               [COLOR_PRIMARIES_BT601_625] =
                   N_(""ITU-R BT.601 (625 lines, 50 Hz)""),
               [COLOR_PRIMARIES_BT709] = ""ITU-R BT.709"",
               [COLOR_PRIMARIES_BT2020] = ""ITU-R BT.2020"",
               [COLOR_PRIMARIES_DCI_P3] = ""DCI/P3 D65"",
               [COLOR_PRIMARIES_BT470_M] = ""ITU-R BT.470 M"",
           };
           static_assert(ARRAY_SIZE(primaries_names) == COLOR_PRIMARIES_MAX+1,
                         ""Color primiaries table mismatch"");
           info_category_AddInfo( p_cat, _(""Color primaries""), ""%s"",
                                  _(primaries_names[fmt->video.primaries]) );
       }",8,,3236,2,,void
45880,BLOCK,1,,<empty>,16,,3238,1,,void
45885,BLOCK,2,,<empty>,16,,3239,2,,void
45890,BLOCK,3,,<empty>,16,,3241,3,,void
45895,BLOCK,4,,<empty>,16,,3243,4,,void
45899,BLOCK,5,,<empty>,16,,3244,5,,void
45903,BLOCK,6,,<empty>,16,,3245,6,,void
45907,BLOCK,7,,<empty>,16,,3246,7,,void
45940,BLOCK,-1,,"{
           static const char func_names[][20] = {
               [TRANSFER_FUNC_UNDEF] = N_(""Undefined""),
               [TRANSFER_FUNC_LINEAR] = N_(""Linear""),
               [TRANSFER_FUNC_SRGB] = ""sRGB"",
               [TRANSFER_FUNC_BT470_BG] = ""ITU-R BT.470 BG"",
               [TRANSFER_FUNC_BT470_M] = ""ITU-R BT.470 M"",
               [TRANSFER_FUNC_BT709] = ""ITU-R BT.709"",
               [TRANSFER_FUNC_SMPTE_ST2084] = ""SMPTE ST2084 (PQ)"",
               [TRANSFER_FUNC_SMPTE_240] = ""SMPTE 240M"",
               [TRANSFER_FUNC_HLG] = N_(""Hybrid Log-Gamma""),
           };
           static_assert(ARRAY_SIZE(func_names) == TRANSFER_FUNC_MAX+1,
                         ""Transfer functions table mismatch"");
           info_category_AddInfo( p_cat, _(""Color transfer function""), ""%s"",
                                  _(func_names[fmt->video.transfer]) );
       }",8,,3254,2,,void
45945,BLOCK,1,,<empty>,16,,3256,1,,void
45950,BLOCK,2,,<empty>,16,,3257,2,,void
45955,BLOCK,3,,<empty>,16,,3258,3,,void
45959,BLOCK,4,,<empty>,16,,3259,4,,void
45963,BLOCK,5,,<empty>,16,,3260,5,,void
45967,BLOCK,6,,<empty>,16,,3261,6,,void
45971,BLOCK,7,,<empty>,16,,3262,7,,void
45975,BLOCK,8,,<empty>,16,,3263,8,,void
45979,BLOCK,9,,<empty>,16,,3264,9,,void
46013,BLOCK,-1,,"{
           static const char space_names[][16] = {
               [COLOR_SPACE_UNDEF] = N_(""Undefined""),
               [COLOR_SPACE_BT601] = ""ITU-R BT.601"",
               [COLOR_SPACE_BT709] = ""ITU-R BT.709"",
               [COLOR_SPACE_BT2020] = ""ITU-R BT.2020"",
           };
           static_assert(ARRAY_SIZE(space_names) == COLOR_SPACE_MAX+1,
                         ""Color space table mismatch"");
           info_category_AddInfo( p_cat, _(""Color space""), _(""%s Range""),
                                  _(space_names[fmt->video.space]),
                       _(fmt->video.b_color_range_full ? ""Full"" : ""Limited"") );
       }",8,,3272,2,,void
46018,BLOCK,1,,<empty>,16,,3274,1,,void
46023,BLOCK,2,,<empty>,16,,3275,2,,void
46027,BLOCK,3,,<empty>,16,,3276,3,,void
46031,BLOCK,4,,<empty>,16,,3277,4,,void
46074,BLOCK,-1,,"{
           static const char c_loc_names[][16] = {
               [CHROMA_LOCATION_UNDEF] = N_(""Undefined""),
               [CHROMA_LOCATION_LEFT] = N_(""Left""),
               [CHROMA_LOCATION_CENTER] = N_(""Center""),
               [CHROMA_LOCATION_TOP_LEFT] = N_(""Top Left""),
               [CHROMA_LOCATION_TOP_CENTER] = N_(""Top Center""),
               [CHROMA_LOCATION_BOTTOM_LEFT] =N_(""Bottom Left""),
               [CHROMA_LOCATION_BOTTOM_CENTER] = N_(""Bottom Center""),
           };
           static_assert(ARRAY_SIZE(c_loc_names) == CHROMA_LOCATION_MAX+1,
                         ""Chroma location table mismatch"");
           info_category_AddInfo( p_cat, _(""Chroma location""), ""%s"",
                   _(c_loc_names[fmt->video.chroma_location]) );
       }",8,,3286,2,,void
46079,BLOCK,1,,<empty>,16,,3288,1,,void
46084,BLOCK,2,,<empty>,16,,3289,2,,void
46089,BLOCK,3,,<empty>,16,,3290,3,,void
46094,BLOCK,4,,<empty>,16,,3291,4,,void
46099,BLOCK,5,,<empty>,16,,3292,5,,void
46104,BLOCK,6,,<empty>,16,,3293,6,,void
46109,BLOCK,7,,<empty>,16,,3294,7,,void
46143,BLOCK,-1,,"{
           const char *psz_loc_name = NULL;
           switch (fmt->video.projection_mode)
           {
           case PROJECTION_MODE_RECTANGULAR:
               psz_loc_name = N_(""Rectangular"");
               break;
           case PROJECTION_MODE_EQUIRECTANGULAR:
               psz_loc_name = N_(""Equirectangular"");
               break;
           case PROJECTION_MODE_CUBEMAP_LAYOUT_STANDARD:
               psz_loc_name = N_(""Cubemap"");
               break;
           default:
               vlc_assert_unreachable();
               break;
           }
           info_category_AddInfo( p_cat, _(""Projection""), ""%s"", _(psz_loc_name) );

           info_category_AddInfo( p_cat, vlc_pgettext(""ViewPoint"", ""Yaw""),
                                  ""%.2f"", fmt->video.pose.yaw );
           info_category_AddInfo( p_cat, vlc_pgettext(""ViewPoint"", ""Pitch""),
                                  ""%.2f"", fmt->video.pose.pitch );
           info_category_AddInfo( p_cat, vlc_pgettext(""ViewPoin...",8,,3302,2,,void
46154,BLOCK,-1,,"{
           case PROJECTION_MODE_RECTANGULAR:
               psz_loc_name = N_(""Rectangular"");
               break;
           case PROJECTION_MODE_EQUIRECTANGULAR:
               psz_loc_name = N_(""Equirectangular"");
               break;
           case PROJECTION_MODE_CUBEMAP_LAYOUT_STANDARD:
               psz_loc_name = N_(""Cubemap"");
               break;
           default:
               vlc_assert_unreachable();
               break;
           }",12,,3305,2,,void
46246,BLOCK,-1,,"{
           info_category_AddInfo( p_cat, _(""Max. luminance""), ""%.4f cd/m²"",
               fmt->video.mastering.max_luminance / 10000.f );
       }",8,,3332,2,,void
46269,BLOCK,-1,,"{
           info_category_AddInfo( p_cat, _(""Min. luminance""), ""%.4f cd/m²"",
               fmt->video.mastering.min_luminance / 10000.f );
       }",8,,3337,2,,void
46304,BLOCK,-1,,"{
           float x = (float)fmt->video.mastering.primaries[4] / 50000.f;
           float y = (float)fmt->video.mastering.primaries[5] / 50000.f;
           info_category_AddInfo( p_cat, _(""Primary R""), ""x=%.4f y=%.4f"", x, y );
       }",8,,3343,2,,void
46364,BLOCK,-1,,"{
           float x = (float)fmt->video.mastering.primaries[0] / 50000.f;
           float y = (float)fmt->video.mastering.primaries[1] / 50000.f;
           info_category_AddInfo( p_cat, _(""Primary G""), ""x=%.4f y=%.4f"", x, y );
       }",8,,3350,2,,void
46424,BLOCK,-1,,"{
           float x = (float)fmt->video.mastering.primaries[2] / 50000.f;
           float y = (float)fmt->video.mastering.primaries[3] / 50000.f;
           info_category_AddInfo( p_cat, _(""Primary B""), ""x=%.4f y=%.4f"", x, y );
       }",8,,3357,2,,void
46484,BLOCK,-1,,"{
           float x = (float)fmt->video.mastering.white_point[0] / 50000.f;
           float y = (float)fmt->video.mastering.white_point[1] / 50000.f;
           info_category_AddInfo( p_cat, _(""White point""), ""x=%.4f y=%.4f"", x, y );
       }",8,,3364,2,,void
46532,BLOCK,-1,,"{
           info_category_AddInfo( p_cat, ""MaxCLL"", ""%d cd/m²"",
                                  fmt->video.lighting.MaxCLL );
       }",8,,3370,2,,void
46552,BLOCK,-1,,"{
           info_category_AddInfo( p_cat, ""MaxFALL"", ""%d cd/m²"",
                                  fmt->video.lighting.MaxFALL );
       }",8,,3375,2,,void
46578,BLOCK,-1,,"{
        char **ppsz_all_keys = vlc_meta_CopyExtraNames( p_meta );
        for( int i = 0; ppsz_all_keys && ppsz_all_keys[i]; i++ )
        {
            char *psz_key = ppsz_all_keys[i];
            const char *psz_value = vlc_meta_GetExtra( p_meta, psz_key );

            if( psz_value )
                info_category_AddInfo( p_cat, vlc_gettext(psz_key), ""%s"",
                                       vlc_gettext(psz_value) );
            free( psz_key );
        }
        free( ppsz_all_keys );
    }",5,,3391,2,,void
46585,BLOCK,-1,,<empty>,9,,3393,1,,void
46597,BLOCK,4,,"{
            char *psz_key = ppsz_all_keys[i];
            const char *psz_value = vlc_meta_GetExtra( p_meta, psz_key );

            if( psz_value )
                info_category_AddInfo( p_cat, vlc_gettext(psz_key), ""%s"",
                                       vlc_gettext(psz_value) );
            free( psz_key );
        }",9,,3394,4,,void
46612,BLOCK,-1,,<empty>,17,,3399,2,,void
46633,BLOCK,-1,,"{
    char* psz_info_category;

    if( likely( psz_info_category = EsInfoCategoryName( es ) ) )
    {
        input_Control( out->p_sys->p_input, INPUT_DEL_INFO,
          psz_info_category, NULL );

        free( psz_info_category );
    }
}",1,,3410,3,,void
46641,BLOCK,-1,,"{
        input_Control( out->p_sys->p_input, INPUT_DEL_INFO,
          psz_info_category, NULL );

        free( psz_info_category );
    }",5,,3414,2,,void
46661,BLOCK,-1,,<empty>,1,,1,1,,ANY
46689,BLOCK,-1,,<empty>,,,,1,,<empty>
46698,BLOCK,-1,,"{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_MODE, i_mode );
    assert( !i_ret );
}",1,,94,3,,void
46713,BLOCK,-1,,"{
    mtime_t i_wu;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_WAKE_UP, &i_wu );

    assert( !i_ret );
    return i_wu;
}",1,,99,2,,void
46732,BLOCK,-1,,"{
    bool b;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_BUFFERING, &b );

    assert( !i_ret );
    return b;
}",1,,107,2,,void
46751,BLOCK,-1,,"{
    bool b;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_EMPTY, &b );

    assert( !i_ret );
    return b;
}",1,,115,2,,void
46772,BLOCK,-1,,"{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_DELAY, i_cat, i_delay );
    assert( !i_ret );
}",1,,123,4,,void
46789,BLOCK,-1,,"{
    return es_out_Control( p_out, ES_OUT_SET_RECORD_STATE, b_record );
}",1,,128,3,,void
46802,BLOCK,-1,,"{
    return es_out_Control( p_out, ES_OUT_SET_PAUSE_STATE, b_source_paused, b_paused, i_date );
}",1,,132,5,,void
46816,BLOCK,-1,,"{
    return es_out_Control( p_out, ES_OUT_SET_RATE, i_source_rate, i_rate );
}",1,,136,4,,void
46828,BLOCK,-1,,"{
    return es_out_Control( p_out, ES_OUT_SET_TIME, i_date );
}",1,,140,3,,void
46838,BLOCK,-1,,"{
    return es_out_Control( p_out, ES_OUT_SET_FRAME_NEXT );
}",1,,144,2,,void
46850,BLOCK,-1,,"{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_TIMES, f_position, i_time, i_length );
    assert( !i_ret );
}",1,,148,5,,void
46870,BLOCK,-1,,"{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_JITTER,
                                i_pts_delay, i_pts_jitter, i_cr_average );
    assert( !i_ret );
}",1,,154,5,,void
46891,BLOCK,-1,,"{
    return es_out_Control( p_out, ES_OUT_GET_ES_OBJECTS_BY_ID, i_id, pp_decoder, pp_vout, pp_aout );
}",1,,161,6,,void
46904,BLOCK,-1,,"{
    int i_group;
    int i_ret = es_out_Control( p_out, ES_OUT_GET_GROUP_FORCED, &i_group );
    assert( !i_ret );
    return i_group;
}",1,,165,2,,void
46923,BLOCK,-1,,"{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_EOS );
    assert( !i_ret );
}",1,,172,2,,void
46938,BLOCK,-1,,<empty>,,,,3,,<empty>
46979,BLOCK,-1,,<empty>,1,,1,1,,ANY
47105,BLOCK,-1,,<empty>,,,,3,,<empty>
47112,BLOCK,-1,,<empty>,,,,4,,<empty>
47118,BLOCK,-1,,<empty>,,,,3,,<empty>
47125,BLOCK,-1,,<empty>,,,,4,,<empty>
47130,BLOCK,-1,,<empty>,,,,2,,<empty>
47135,BLOCK,-1,,<empty>,,,,2,,<empty>
47140,BLOCK,-1,,<empty>,,,,2,,<empty>
47145,BLOCK,-1,,<empty>,,,,2,,<empty>
47151,BLOCK,-1,,<empty>,,,,3,,<empty>
47158,BLOCK,-1,,<empty>,,,,4,,<empty>
47163,BLOCK,-1,,<empty>,,,,2,,<empty>
47168,BLOCK,-1,,<empty>,,,,2,,<empty>
47176,BLOCK,-1,,<empty>,,,,5,,<empty>
47183,BLOCK,-1,,<empty>,,,,4,,<empty>
47188,BLOCK,-1,,<empty>,,,,2,,<empty>
47194,BLOCK,-1,,<empty>,,,,3,,<empty>
47199,BLOCK,-1,,<empty>,,,,2,,<empty>
47204,BLOCK,-1,,<empty>,,,,2,,<empty>
47210,BLOCK,-1,,<empty>,,,,3,,<empty>
47215,BLOCK,-1,,<empty>,,,,2,,<empty>
47222,BLOCK,-1,,<empty>,,,,4,,<empty>
47229,BLOCK,-1,,<empty>,,,,4,,<empty>
47234,BLOCK,-1,,<empty>,,,,2,,<empty>
47239,BLOCK,-1,,{ CmdClean( p ); },44,,278,2,,void
47249,BLOCK,-1,,<empty>,,,,5,,<empty>
47256,BLOCK,-1,,<empty>,,,,4,,<empty>
47262,BLOCK,-1,,<empty>,,,,3,,<empty>
47270,BLOCK,-1,,<empty>,,,,5,,<empty>
47275,BLOCK,-1,,<empty>,,,,2,,<empty>
47280,BLOCK,-1,,<empty>,,,,2,,<empty>
47285,BLOCK,-1,,<empty>,,,,2,,<empty>
47291,BLOCK,-1,,<empty>,,,,3,,<empty>
47297,BLOCK,-1,,<empty>,,,,3,,<empty>
47303,BLOCK,-1,,<empty>,,,,3,,<empty>
47309,BLOCK,-1,,<empty>,,,,3,,<empty>
47315,BLOCK,-1,,<empty>,,,,3,,<empty>
47322,BLOCK,-1,,"{
    es_out_t *p_out = malloc( sizeof(*p_out) );
    if( !p_out )
        return NULL;

    es_out_sys_t *p_sys = malloc( sizeof(*p_sys) );
    if( !p_sys )
    {
        free( p_out );
        return NULL;
    }

    /* */
    p_out->pf_add     = Add;
    p_out->pf_send    = Send;
    p_out->pf_del     = Del;
    p_out->pf_control = Control;
    p_out->pf_destroy = Destroy;
    p_out->p_sys      = p_sys;

    /* */
    p_sys->b_input_paused = false;
    p_sys->b_input_paused_source = false;
    p_sys->p_input = p_input;
    p_sys->i_input_rate = i_rate;
    p_sys->i_input_rate_source = i_rate;

    p_sys->p_out = p_next_out;
    vlc_mutex_init_recursive( &p_sys->lock );

    p_sys->b_delayed = false;
    p_sys->p_ts = NULL;

    TAB_INIT( p_sys->i_es, p_sys->pp_es );

    /* */
    const int i_tmp_size_max = var_CreateGetInteger( p_input, ""input-timeshift-granularity"" );
    if( i_tmp_size_max < 0 )
        p_sys->i_tmp_size_max = 50*1024*1024;
    else
        p_sys->i_tmp_size_m...",1,,303,4,,void
47333,BLOCK,-1,,<empty>,9,,306,2,,void
47346,BLOCK,-1,,"{
        free( p_out );
        return NULL;
    }",5,,310,2,,void
47443,BLOCK,-1,,<empty>,9,,341,2,,void
47454,BLOCK,-1,,<empty>,9,,343,1,,void
47491,BLOCK,-1,,<empty>,9,,387,2,,void
47499,BLOCK,-1,,<empty>,9,,389,1,,void
47509,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
    {
        TsStop( p_sys->p_ts );
        p_sys->b_delayed = false;
    }

    while( p_sys->i_es > 0 )
        Del( p_out, p_sys->pp_es[0] );
    TAB_CLEAN( p_sys->i_es, p_sys->pp_es  );

    free( p_sys->psz_tmp_path );
    vlc_mutex_destroy( &p_sys->lock );
    free( p_sys );
    free( p_out );
}",1,,408,2,,void
47520,BLOCK,-1,,"{
        TsStop( p_sys->p_ts );
        p_sys->b_delayed = false;
    }",5,,412,2,,void
47568,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;

    es_out_id_t *p_es = malloc( sizeof( *p_es ) );
    if( !p_es )
        return NULL;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    if( CmdInitAdd( &cmd, p_es, p_fmt, p_sys->b_delayed ) )
    {
        vlc_mutex_unlock( &p_sys->lock );
        free( p_es );
        return NULL;
    }

    TAB_APPEND( p_sys->i_es, p_sys->pp_es, p_es );

    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        CmdExecuteAdd( p_sys->p_out, &cmd );

    vlc_mutex_unlock( &p_sys->lock );

    return p_es;
}",1,,428,3,,void
47586,BLOCK,-1,,<empty>,9,,434,2,,void
47605,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_sys->lock );
        free( p_es );
        return NULL;
    }",5,,441,2,,void
47627,BLOCK,-1,,<empty>,9,,450,2,,void
47635,BLOCK,-1,,<empty>,9,,452,1,,void
47655,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;
    int i_ret = VLC_SUCCESS;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    CmdInitSend( &cmd, p_es, p_block );
    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        i_ret = CmdExecuteSend( p_sys->p_out, &cmd) ;

    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",1,,459,4,,void
47683,BLOCK,-1,,<empty>,9,,470,2,,void
47691,BLOCK,-1,,<empty>,9,,472,1,,void
47712,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_cmd_t cmd;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    CmdInitDel( &cmd, p_es );
    if( p_sys->b_delayed )
        TsPushCmd( p_sys->p_ts, &cmd );
    else
        CmdExecuteDel( p_sys->p_out, &cmd );

    TAB_REMOVE( p_sys->i_es, p_sys->pp_es, p_es );

    vlc_mutex_unlock( &p_sys->lock );
}",1,,479,3,,void
47735,BLOCK,-1,,<empty>,9,,489,2,,void
47743,BLOCK,-1,,<empty>,9,,491,1,,void
47768,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed && TsHasCmd( p_sys->p_ts ) )
        *pb_empty = false;
    else
        *pb_empty = es_out_GetEmpty( p_sys->p_out );

    return VLC_SUCCESS;
}",1,,499,3,,void
47784,BLOCK,-1,,<empty>,9,,503,2,,void
47790,BLOCK,-1,,<empty>,9,,505,1,,void
47805,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
    {
        assert( !input_priv(p_sys->p_input)->b_can_pace_control );
        *pi_wakeup = 0;
    }
    else
    {
        *pi_wakeup = es_out_GetWakeup( p_sys->p_out );
    }

    return VLC_SUCCESS;
}",1,,510,3,,void
47816,BLOCK,-1,,"{
        assert( !input_priv(p_sys->p_input)->b_can_pace_control );
        *pi_wakeup = 0;
    }",5,,514,2,,void
47830,BLOCK,-1,,"{
        *pi_wakeup = es_out_GetWakeup( p_sys->p_out );
    }",5,,519,1,,void
47845,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
        *pb_buffering = true;
    else
        *pb_buffering = es_out_GetBuffering( p_sys->p_out );

    return VLC_SUCCESS;
}",1,,526,3,,void
47856,BLOCK,-1,,<empty>,9,,530,2,,void
47862,BLOCK,-1,,<empty>,9,,532,1,,void
47879,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && !b_source_paused == !b_paused )
    {
        i_ret = es_out_SetPauseState( p_sys->p_out, b_source_paused, b_paused, i_date );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangePause( p_sys->p_ts, b_source_paused, b_paused, i_date );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }
    }

    if( !i_ret )
    {
        p_sys->b_input_paused_source = b_source_paused;
        p_sys->b_input_...",1,,537,5,,void
47898,BLOCK,-1,,"{
        i_ret = es_out_SetPauseState( p_sys->p_out, b_source_paused, b_paused, i_date );
    }",5,,542,2,,void
47909,BLOCK,-1,,"{
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangePause( p_sys->p_ts, b_source_paused, b_paused, i_date );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }
    }",5,,546,1,,void
47921,BLOCK,-1,,"{
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangePause( p_sys->p_ts, b_source_paused, b_paused, i_date );
        }",9,,549,2,,void
47927,BLOCK,-1,,<empty>,17,,551,2,,void
47934,BLOCK,-1,,<empty>,17,,553,2,,void
47945,BLOCK,-1,,"{
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }",9,,556,1,,void
47954,BLOCK,-1,,"{
        p_sys->b_input_paused_source = b_source_paused;
        p_sys->b_input_paused = b_paused;
    }",5,,565,2,,void
47973,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && i_src_rate == i_rate )
    {
        i_ret = es_out_SetRate( p_sys->p_out, i_src_rate, i_rate );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangeRate( p_sys->p_ts, i_src_rate, i_rate );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }

    }

    if( !i_ret )
    {
        p_sys->i_input_rate_source = i_src_rate;
        p_sys->i_input_rate = i_rate;
    }
    return i_ret;
}",1,,572,4,,void
47990,BLOCK,-1,,"{
        i_ret = es_out_SetRate( p_sys->p_out, i_src_rate, i_rate );
    }",5,,577,2,,void
48000,BLOCK,-1,,"{
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangeRate( p_sys->p_ts, i_src_rate, i_rate );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }

    }",5,,581,1,,void
48012,BLOCK,-1,,"{
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangeRate( p_sys->p_ts, i_src_rate, i_rate );
        }",9,,584,2,,void
48018,BLOCK,-1,,<empty>,17,,586,2,,void
48025,BLOCK,-1,,<empty>,17,,588,2,,void
48035,BLOCK,-1,,"{
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }",9,,591,1,,void
48044,BLOCK,-1,,"{
        p_sys->i_input_rate_source = i_src_rate;
        p_sys->i_input_rate = i_rate;
    }",5,,601,2,,void
48062,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( !p_sys->b_delayed )
        return es_out_SetTime( p_sys->p_out, i_date );

    /* TODO */
    msg_Err( p_sys->p_input, ""EsOutTimeshift does not yet support time change"" );
    return VLC_EGENERIC;
}",1,,608,3,,void
48074,BLOCK,-1,,<empty>,9,,612,2,,void
48092,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    return es_out_SetFrameNext( p_sys->p_out );
}",1,,619,2,,void
48110,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:
    case ES_OUT_SET_GROUP:
    case ES_OUT_SET_PCR:
    case ES_OUT_SET_GROUP_PCR:
    case ES_OUT_RESET_PCR:
    case ES_OUT_SET_NEXT_DISPLAY_TIME:
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_GROUP_EPG:
    case ES_OUT_SET_GROUP_EPG_EVENT:
    case ES_OUT_SET_EPG_TIME:
    case ES_OUT_SET_ES_SCRAMBLED_STATE:
    case ES_OUT_DEL_GROUP:
    case ES_OUT_SET_META:
    case ES_OUT_SET_ES:
    case ES_OUT_RESTART_ES:
    case ES_OUT_RESTART_ALL_ES:
    case ES_OUT_SET_ES_DEFAULT:
    case ES_OUT_SET_ES_STATE:
    case ES_OUT_SET_ES_CAT_POLICY:
    case ES_OUT_SET_ES_FMT:
    case ES_OUT_SET_TIMES:
    case ES_OUT_SET_JITTER:
    case ES_OUT_SET_EOS:
    {
        ts_cmd_t cmd;
        if( CmdInitControl( &cmd, i_query, args, p_sys->b_delayed ) )
            return VLC_EGENERIC;
        if( p_sys->b_delayed )
        {
            TsPushCmd( p_sys->p_ts, ...",1,,626,4,,void
48119,BLOCK,-1,,"{
    /* Pass-through control */
    case ES_OUT_SET_MODE:
    case ES_OUT_SET_GROUP:
    case ES_OUT_SET_PCR:
    case ES_OUT_SET_GROUP_PCR:
    case ES_OUT_RESET_PCR:
    case ES_OUT_SET_NEXT_DISPLAY_TIME:
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_GROUP_EPG:
    case ES_OUT_SET_GROUP_EPG_EVENT:
    case ES_OUT_SET_EPG_TIME:
    case ES_OUT_SET_ES_SCRAMBLED_STATE:
    case ES_OUT_DEL_GROUP:
    case ES_OUT_SET_META:
    case ES_OUT_SET_ES:
    case ES_OUT_RESTART_ES:
    case ES_OUT_RESTART_ALL_ES:
    case ES_OUT_SET_ES_DEFAULT:
    case ES_OUT_SET_ES_STATE:
    case ES_OUT_SET_ES_CAT_POLICY:
    case ES_OUT_SET_ES_FMT:
    case ES_OUT_SET_TIMES:
    case ES_OUT_SET_JITTER:
    case ES_OUT_SET_EOS:
    {
        ts_cmd_t cmd;
        if( CmdInitControl( &cmd, i_query, args, p_sys->b_delayed ) )
            return VLC_EGENERIC;
        if( p_sys->b_delayed )
        {
            TsPushCmd( p_sys->p_ts, &cmd );
            return VLC_SUCCESS;
        }
        return CmdE...",5,,630,2,,void
48166,BLOCK,47,,"{
        ts_cmd_t cmd;
        if( CmdInitControl( &cmd, i_query, args, p_sys->b_delayed ) )
            return VLC_EGENERIC;
        if( p_sys->b_delayed )
        {
            TsPushCmd( p_sys->p_ts, &cmd );
            return VLC_SUCCESS;
        }
        return CmdExecuteControl( p_sys->p_out, &cmd );
    }",5,,655,47,,void
48177,BLOCK,-1,,<empty>,13,,658,2,,void
48184,BLOCK,-1,,"{
            TsPushCmd( p_sys->p_ts, &cmd );
            return VLC_SUCCESS;
        }",9,,660,2,,void
48202,BLOCK,50,,"{
        es_out_id_t *p_es = (es_out_id_t*)va_arg( args, es_out_id_t * );
        bool *pb_enabled = (bool*)va_arg( args, bool* );

        if( p_sys->b_delayed )
        {
            *pb_enabled = true;
            return VLC_SUCCESS;
        }
        return es_out_Control( p_sys->p_out, ES_OUT_GET_ES_STATE, p_es->p_es, pb_enabled );
    }",5,,669,50,,void
48209,BLOCK,-1,,"{
            *pb_enabled = true;
            return VLC_SUCCESS;
        }",9,,674,2,,void
48228,BLOCK,53,,"{
        bool *pb_empty = (bool*)va_arg( args, bool* );
        return ControlLockedGetEmpty( p_out, pb_empty );
    }",5,,682,53,,void
48236,BLOCK,56,,"{
        mtime_t *pi_wakeup = (mtime_t*)va_arg( args, mtime_t* );
        return ControlLockedGetWakeup( p_out, pi_wakeup );
    }",5,,687,56,,void
48244,BLOCK,59,,"{
        bool *pb_buffering = (bool *)va_arg( args, bool* );
        return ControlLockedGetBuffering( p_out, pb_buffering );
    }",5,,692,59,,void
48252,BLOCK,62,,"{
        const bool b_source_paused = (bool)va_arg( args, int );
        const bool b_paused = (bool)va_arg( args, int );
        const mtime_t i_date = (mtime_t) va_arg( args, mtime_t );

        return ControlLockedSetPauseState( p_out, b_source_paused, b_paused, i_date );
    }",5,,697,62,,void
48281,BLOCK,65,,"{
        const int i_src_rate = (int)va_arg( args, int );
        const int i_rate = (int)va_arg( args, int );

        return ControlLockedSetRate( p_out, i_src_rate, i_rate );
    }",5,,705,65,,void
48291,BLOCK,68,,"{
        const mtime_t i_date = (mtime_t)va_arg( args, mtime_t );

        return ControlLockedSetTime( p_out, i_date );
    }",5,,712,68,,void
48306,BLOCK,71,,"{
        return ControlLockedSetFrameNext( p_out );
    }",5,,718,71,,void
48316,BLOCK,-1,,<empty>,13,,724,2,,void
48332,BLOCK,82,,"{
        const bool    b_absolute = va_arg( args, int );
        const mtime_t i_system   = va_arg( args, mtime_t );

        if( b_absolute && p_sys->b_delayed )
            return VLC_EGENERIC;

        return es_out_ControlModifyPcrSystem( p_sys->p_out, b_absolute, i_system );
    }",5,,731,82,,void
48348,BLOCK,-1,,<empty>,13,,736,2,,void
48384,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    vlc_mutex_lock( &p_sys->lock );

    TsAutoStop( p_out );

    i_ret = ControlLocked( p_out, i_query, args );

    vlc_mutex_unlock( &p_sys->lock );

    return i_ret;
}",1,,756,4,,void
48416,BLOCK,-1,,"{
    vlc_cond_destroy( &p_ts->wait );
    vlc_mutex_destroy( &p_ts->lock );
    free( p_ts );
}",1,,775,2,,void
48433,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;
    ts_thread_t *p_ts;

    assert( !p_sys->b_delayed );

    p_sys->p_ts = p_ts = calloc(1, sizeof(*p_ts));
    if( !p_ts )
        return VLC_EGENERIC;

    p_ts->i_tmp_size_max = p_sys->i_tmp_size_max;
    p_ts->psz_tmp_path = p_sys->psz_tmp_path;
    p_ts->p_input = p_sys->p_input;
    p_ts->p_out = p_sys->p_out;
    vlc_mutex_init( &p_ts->lock );
    vlc_cond_init( &p_ts->wait );
    p_ts->b_paused = p_sys->b_input_paused && !p_sys->b_input_paused_source;
    p_ts->i_pause_date = p_ts->b_paused ? mdate() : -1;
    p_ts->i_rate_source = p_sys->i_input_rate_source;
    p_ts->i_rate        = p_sys->i_input_rate;
    p_ts->i_rate_date = -1;
    p_ts->i_rate_delay = 0;
    p_ts->i_buffering_delay = 0;
    p_ts->i_cmd_delay = 0;
    p_ts->p_storage_r = NULL;
    p_ts->p_storage_w = NULL;

    p_sys->b_delayed = true;
    if( vlc_clone( &p_ts->thread, TsRun, p_ts, VLC_THREAD_PRIORITY_INPUT ) )
    {
        msg_Err( p_sys->p_input, ""cannot cre...",1,,781,2,,void
48460,BLOCK,-1,,<empty>,9,,789,2,,void
48583,BLOCK,-1,,"{
        msg_Err( p_sys->p_input, ""cannot create timeshift thread"" );

        TsDestroy( p_ts );

        p_sys->b_delayed = false;
        return VLC_EGENERIC;
    }",5,,810,2,,void
48604,BLOCK,-1,,"{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( !p_sys->b_delayed || !TsIsUnused( p_sys->p_ts ) )
        return;

    msg_Warn( p_sys->p_input, ""es out timeshift: auto stop"" );
    TsStop( p_sys->p_ts );

    p_sys->b_delayed = false;
}",1,,822,2,,void
48622,BLOCK,-1,,<empty>,9,,826,2,,void
48642,BLOCK,-1,,"{
    vlc_cancel( p_ts->thread );
    vlc_join( p_ts->thread, NULL );

    vlc_mutex_lock( &p_ts->lock );
    for( ;; )
    {
        ts_cmd_t cmd;

        if( TsPopCmdLocked( p_ts, &cmd, true ) )
            break;

        CmdClean( &cmd );
    }
    assert( !p_ts->p_storage_r || !p_ts->p_storage_r->p_next );
    if( p_ts->p_storage_r )
        TsStorageDelete( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    TsDestroy( p_ts );
}",1,,834,2,,void
48658,BLOCK,-1,,<empty>,5,,839,1,,void
48659,BLOCK,4,,"{
        ts_cmd_t cmd;

        if( TsPopCmdLocked( p_ts, &cmd, true ) )
            break;

        CmdClean( &cmd );
    }",5,,840,4,,void
48667,BLOCK,-1,,<empty>,13,,844,2,,void
48688,BLOCK,-1,,<empty>,9,,850,2,,void
48705,BLOCK,-1,,"{
    vlc_mutex_lock( &p_ts->lock );

    if( !p_ts->p_storage_w || TsStorageIsFull( p_ts->p_storage_w, p_cmd ) )
    {
        ts_storage_t *p_storage = TsStorageNew( p_ts->psz_tmp_path, p_ts->i_tmp_size_max );

        if( !p_storage )
        {
            CmdClean( p_cmd );
            vlc_mutex_unlock( &p_ts->lock );
            /* TODO warn the user (but only once) */
            return;
        }

        if( !p_ts->p_storage_w )
        {
            p_ts->p_storage_r = p_ts->p_storage_w = p_storage;
        }
        else
        {
            TsStoragePack( p_ts->p_storage_w );
            p_ts->p_storage_w->p_next = p_storage;
            p_ts->p_storage_w = p_storage;
        }
    }

    /* TODO return error and warn the user (but only once) */
    TsStoragePushCmd( p_ts->p_storage_w, p_cmd, p_ts->p_storage_r == p_ts->p_storage_w );

    vlc_cond_signal( &p_ts->wait );

    vlc_mutex_unlock( &p_ts->lock );
}",1,,856,3,,void
48722,BLOCK,-1,,"{
        ts_storage_t *p_storage = TsStorageNew( p_ts->psz_tmp_path, p_ts->i_tmp_size_max );

        if( !p_storage )
        {
            CmdClean( p_cmd );
            vlc_mutex_unlock( &p_ts->lock );
            /* TODO warn the user (but only once) */
            return;
        }

        if( !p_ts->p_storage_w )
        {
            p_ts->p_storage_r = p_ts->p_storage_w = p_storage;
        }
        else
        {
            TsStoragePack( p_ts->p_storage_w );
            p_ts->p_storage_w->p_next = p_storage;
            p_ts->p_storage_w = p_storage;
        }
    }",5,,860,2,,void
48736,BLOCK,-1,,"{
            CmdClean( p_cmd );
            vlc_mutex_unlock( &p_ts->lock );
            /* TODO warn the user (but only once) */
            return;
        }",9,,864,2,,void
48750,BLOCK,-1,,"{
            p_ts->p_storage_r = p_ts->p_storage_w = p_storage;
        }",9,,872,2,,void
48761,BLOCK,-1,,"{
            TsStoragePack( p_ts->p_storage_w );
            p_ts->p_storage_w->p_next = p_storage;
            p_ts->p_storage_w = p_storage;
        }",9,,876,1,,void
48806,BLOCK,-1,,"{
    vlc_assert_locked( &p_ts->lock );

    if( TsStorageIsEmpty( p_ts->p_storage_r ) )
        return VLC_EGENERIC;

    TsStoragePopCmd( p_ts->p_storage_r, p_cmd, b_flush );

    while( TsStorageIsEmpty( p_ts->p_storage_r ) )
    {
        ts_storage_t *p_next = p_ts->p_storage_r->p_next;
        if( !p_next )
            break;

        TsStorageDelete( p_ts->p_storage_r );
        p_ts->p_storage_r = p_next;
    }

    return VLC_SUCCESS;
}",1,,891,4,,void
48817,BLOCK,-1,,<empty>,9,,895,2,,void
48831,BLOCK,-1,,"{
        ts_storage_t *p_next = p_ts->p_storage_r->p_next;
        if( !p_next )
            break;

        TsStorageDelete( p_ts->p_storage_r );
        p_ts->p_storage_r = p_next;
    }",5,,900,2,,void
48843,BLOCK,-1,,<empty>,13,,903,2,,void
48860,BLOCK,-1,,"{
    bool b_cmd;

    vlc_mutex_lock( &p_ts->lock );
    b_cmd = !TsStorageIsEmpty( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    return b_cmd;
}",1,,912,2,,void
48885,BLOCK,-1,,"{
    bool b_unused;

    vlc_mutex_lock( &p_ts->lock );
    b_unused = !p_ts->b_paused &&
               p_ts->i_rate == p_ts->i_rate_source &&
               TsStorageIsEmpty( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    return b_unused;
}",1,,922,2,,void
48925,BLOCK,-1,,"{
    vlc_mutex_lock( &p_ts->lock );

    int i_ret;
    if( b_paused )
    {
        assert( !b_source_paused );
        i_ret = es_out_SetPauseState( p_ts->p_out, true, true, i_date );
    }
    else
    {
        i_ret = es_out_SetPauseState( p_ts->p_out, false, false, i_date );
    }

    if( !i_ret )
    {
        if( !b_paused )
        {
            assert( p_ts->i_pause_date > 0 );

            p_ts->i_cmd_delay += i_date - p_ts->i_pause_date;
        }

        p_ts->b_paused = b_paused;
        p_ts->i_pause_date = i_date;

        vlc_cond_signal( &p_ts->wait );
    }
    vlc_mutex_unlock( &p_ts->lock );
    return i_ret;
}",1,,934,5,,void
48934,BLOCK,-1,,"{
        assert( !b_source_paused );
        i_ret = es_out_SetPauseState( p_ts->p_out, true, true, i_date );
    }",5,,939,2,,void
48948,BLOCK,-1,,"{
        i_ret = es_out_SetPauseState( p_ts->p_out, false, false, i_date );
    }",5,,944,1,,void
48961,BLOCK,-1,,"{
        if( !b_paused )
        {
            assert( p_ts->i_pause_date > 0 );

            p_ts->i_cmd_delay += i_date - p_ts->i_pause_date;
        }

        p_ts->b_paused = b_paused;
        p_ts->i_pause_date = i_date;

        vlc_cond_signal( &p_ts->wait );
    }",5,,949,2,,void
48965,BLOCK,-1,,"{
            assert( p_ts->i_pause_date > 0 );

            p_ts->i_cmd_delay += i_date - p_ts->i_pause_date;
        }",9,,951,2,,void
49009,BLOCK,-1,,"{
    int i_ret;

    vlc_mutex_lock( &p_ts->lock );
    p_ts->i_cmd_delay += p_ts->i_rate_delay;

    p_ts->i_rate_date = -1;
    p_ts->i_rate_delay = 0;
    p_ts->i_rate = i_rate;
    p_ts->i_rate_source = i_src_rate;

    i_ret = es_out_SetRate( p_ts->p_out, i_rate, i_rate );
    vlc_mutex_unlock( &p_ts->lock );

    return i_ret;
}",1,,966,4,,void
49063,BLOCK,-1,,"{
    ts_thread_t *p_ts = p_data;
    mtime_t i_buffering_date = -1;

    for( ;; )
    {
        ts_cmd_t cmd;
        mtime_t  i_deadline;
        bool b_buffering;

        /* Pop a command to execute */
        vlc_mutex_lock( &p_ts->lock );
        mutex_cleanup_push( &p_ts->lock );

        for( ;; )
        {
            const int canc = vlc_savecancel();
            b_buffering = es_out_GetBuffering( p_ts->p_out );

            if( ( !p_ts->b_paused || b_buffering ) && !TsPopCmdLocked( p_ts, &cmd, false ) )
            {
                vlc_restorecancel( canc );
                break;
            }
            vlc_restorecancel( canc );

            vlc_cond_wait( &p_ts->wait, &p_ts->lock );
        }

        if( b_buffering && i_buffering_date < 0 )
        {
            i_buffering_date = cmd.i_date;
        }
        else if( i_buffering_date > 0 )
        {
            p_ts->i_buffering_delay += i_buffering_date - cmd.i_date; /* It is < 0 */
            if( b_buffering...",1,,984,2,,void
49074,BLOCK,-1,,<empty>,5,,988,1,,void
49075,BLOCK,4,,"{
        ts_cmd_t cmd;
        mtime_t  i_deadline;
        bool b_buffering;

        /* Pop a command to execute */
        vlc_mutex_lock( &p_ts->lock );
        mutex_cleanup_push( &p_ts->lock );

        for( ;; )
        {
            const int canc = vlc_savecancel();
            b_buffering = es_out_GetBuffering( p_ts->p_out );

            if( ( !p_ts->b_paused || b_buffering ) && !TsPopCmdLocked( p_ts, &cmd, false ) )
            {
                vlc_restorecancel( canc );
                break;
            }
            vlc_restorecancel( canc );

            vlc_cond_wait( &p_ts->wait, &p_ts->lock );
        }

        if( b_buffering && i_buffering_date < 0 )
        {
            i_buffering_date = cmd.i_date;
        }
        else if( i_buffering_date > 0 )
        {
            p_ts->i_buffering_delay += i_buffering_date - cmd.i_date; /* It is < 0 */
            if( b_buffering )
                i_buffering_date = cmd.i_date;
            else
                i_buf...",5,,989,4,,void
49090,BLOCK,-1,,<empty>,9,,998,1,,void
49091,BLOCK,4,,"{
            const int canc = vlc_savecancel();
            b_buffering = es_out_GetBuffering( p_ts->p_out );

            if( ( !p_ts->b_paused || b_buffering ) && !TsPopCmdLocked( p_ts, &cmd, false ) )
            {
                vlc_restorecancel( canc );
                break;
            }
            vlc_restorecancel( canc );

            vlc_cond_wait( &p_ts->wait, &p_ts->lock );
        }",9,,999,4,,void
49116,BLOCK,-1,,"{
                vlc_restorecancel( canc );
                break;
            }",13,,1004,2,,void
49137,BLOCK,-1,,"{
            i_buffering_date = cmd.i_date;
        }",9,,1014,2,,void
49144,BLOCK,-1,,<empty>,14,,1017,1,,void
49149,BLOCK,-1,,"{
            p_ts->i_buffering_delay += i_buffering_date - cmd.i_date; /* It is < 0 */
            if( b_buffering )
                i_buffering_date = cmd.i_date;
            else
                i_buffering_date = -1;
        }",9,,1018,2,,void
49161,BLOCK,-1,,<empty>,17,,1021,2,,void
49168,BLOCK,-1,,<empty>,17,,1023,1,,void
49179,BLOCK,-1,,<empty>,13,,1027,2,,void
49200,BLOCK,-1,,"{
            const mtime_t i_duration = cmd.i_date - p_ts->i_rate_date;
            p_ts->i_rate_delay = i_duration * p_ts->i_rate / p_ts->i_rate_source - i_duration;
        }",9,,1031,2,,void
49248,BLOCK,-1,,"{
            const int canc = vlc_savecancel();

            /* Auto reset to rate 1.0 */
            msg_Warn( p_ts->p_input, ""es out timeshift: auto reset rate to %d"", p_ts->i_rate_source );

            p_ts->i_cmd_delay = 0;
            p_ts->i_buffering_delay = 0;

            p_ts->i_rate_delay = 0;
            p_ts->i_rate_date = -1;
            p_ts->i_rate = p_ts->i_rate_source;

            if( !es_out_SetRate( p_ts->p_out, p_ts->i_rate_source, p_ts->i_rate ) )
            {
                vlc_value_t val = { .i_int = p_ts->i_rate };
                /* Warn back input
                 * FIXME it is perfectly safe BUT it is ugly as it may hide a
                 * rate change requested by user */
                input_ControlPush( p_ts->p_input, INPUT_CONTROL_SET_RATE, &val );
            }

            vlc_restorecancel( canc );
        }",9,,1036,2,,void
49301,BLOCK,-1,,"{
                vlc_value_t val = { .i_int = p_ts->i_rate };
                /* Warn back input
                 * FIXME it is perfectly safe BUT it is ugly as it may hide a
                 * rate change requested by user */
                input_ControlPush( p_ts->p_input, INPUT_CONTROL_SET_RATE, &val );
            }",13,,1050,2,,void
49306,BLOCK,1,,<empty>,37,,1051,1,,void
49359,BLOCK,-1,,"{
        case C_ADD:
            CmdExecuteAdd( p_ts->p_out, &cmd );
            CmdCleanAdd( &cmd );
            break;
        case C_SEND:
            CmdExecuteSend( p_ts->p_out, &cmd );
            CmdCleanSend( &cmd );
            break;
        case C_CONTROL:
            CmdExecuteControl( p_ts->p_out, &cmd );
            CmdCleanControl( &cmd );
            break;
        case C_DEL:
            CmdExecuteDel( p_ts->p_out, &cmd );
            break;
        default:
            vlc_assert_unreachable();
            break;
        }",9,,1076,2,,void
49417,BLOCK,-1,,"{
    ts_storage_t *p_storage = malloc( sizeof (*p_storage) );
    if( unlikely(p_storage == NULL) )
        return NULL;

    char *psz_file;
    int fd = GetTmpFile( &psz_file, psz_tmp_path );
    if( fd == -1 )
    {
        free( p_storage );
        return NULL;
    }

    p_storage->p_filew = fdopen( fd, ""w+b"" );
    if( p_storage->p_filew == NULL )
    {
        vlc_close( fd );
        vlc_unlink( psz_file );
        goto error;
    }

    p_storage->p_filer = vlc_fopen( psz_file, ""rb"" );
    if( p_storage->p_filer == NULL )
    {
        fclose( p_storage->p_filew );
        vlc_unlink( psz_file );
        goto error;
    }

#ifndef _WIN32
    vlc_unlink( psz_file );
    free( psz_file );
#else
    p_storage->psz_file = psz_file;
#endif
    p_storage->p_next = NULL;

    /* */
    p_storage->i_file_max = i_tmp_size_max;
    p_storage->i_file_size = 0;

    /* */
    p_storage->i_cmd_w = 0;
    p_storage->i_cmd_r = 0;
    p_storage->i_cmd_max = 30000;
    p_storage->p_cmd = ...",1,,1106,3,,void
49430,BLOCK,-1,,<empty>,9,,1109,2,,void
49446,BLOCK,-1,,"{
        free( p_storage );
        return NULL;
    }",5,,1114,2,,void
49464,BLOCK,-1,,"{
        vlc_close( fd );
        vlc_unlink( psz_file );
        goto error;
    }",5,,1121,2,,void
49483,BLOCK,-1,,"{
        fclose( p_storage->p_filew );
        vlc_unlink( psz_file );
        goto error;
    }",5,,1129,2,,void
49543,BLOCK,-1,,"{
        TsStorageDelete( p_storage );
        return NULL;
    }",5,,1155,2,,void
49561,BLOCK,-1,,"{
    while( p_storage->i_cmd_r < p_storage->i_cmd_w )
    {
        ts_cmd_t cmd;

        TsStoragePopCmd( p_storage, &cmd, true );

        CmdClean( &cmd );
    }
    free( p_storage->p_cmd );

    fclose( p_storage->p_filer );
    fclose( p_storage->p_filew );
#ifdef _WIN32
    vlc_unlink( p_storage->psz_file );
    free( p_storage->psz_file );
#endif
    free( p_storage );
}",1,,1167,2,,void
49570,BLOCK,-1,,"{
        ts_cmd_t cmd;

        TsStoragePopCmd( p_storage, &cmd, true );

        CmdClean( &cmd );
    }",5,,1169,2,,void
49598,BLOCK,-1,,"{
    /* Try to release a bit of memory */
    if( p_storage->i_cmd_w >= p_storage->i_cmd_max )
        return;

    p_storage->i_cmd_max = __MAX( p_storage->i_cmd_w, 1 );

    ts_cmd_t *p_new = realloc( p_storage->p_cmd, p_storage->i_cmd_max * sizeof(*p_storage->p_cmd) );
    if( p_new )
        p_storage->p_cmd = p_new;
}",1,,1188,2,,void
49607,BLOCK,-1,,<empty>,9,,1191,2,,void
49636,BLOCK,-1,,<empty>,9,,1197,2,,void
49647,BLOCK,-1,,"{
    if( p_cmd && p_cmd->i_type == C_SEND && p_storage->i_cmd_w > 0 )
    {
        size_t i_size = sizeof(*p_cmd->u.send.p_block) + p_cmd->u.send.p_block->i_buffer;

        if( p_storage->i_file_size + i_size >= p_storage->i_file_max )
            return true;
    }
    return p_storage->i_cmd_w >= p_storage->i_cmd_max;
}",1,,1200,3,,void
49662,BLOCK,-1,,"{
        size_t i_size = sizeof(*p_cmd->u.send.p_block) + p_cmd->u.send.p_block->i_buffer;

        if( p_storage->i_file_size + i_size >= p_storage->i_file_max )
            return true;
    }",5,,1202,2,,void
49695,BLOCK,-1,,<empty>,13,,1206,2,,void
49710,BLOCK,-1,,"{
    return !p_storage || p_storage->i_cmd_r >= p_storage->i_cmd_w;
}",1,,1211,2,,void
49728,BLOCK,-1,,"{
    ts_cmd_t cmd = *p_cmd;

    assert( !TsStorageIsFull( p_storage, p_cmd ) );

    if( cmd.i_type == C_SEND )
    {
        block_t *p_block = cmd.u.send.p_block;

        cmd.u.send.p_block = NULL;
        cmd.u.send.i_offset = ftell( p_storage->p_filew );

        if( fwrite( p_block, sizeof(*p_block), 1, p_storage->p_filew ) != 1 )
        {
            block_Release( p_block );
            return;
        }
        p_storage->i_file_size += sizeof(*p_block);
        if( p_block->i_buffer > 0 )
        {
            if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, p_storage->p_filew ) != 1 )
            {
                block_Release( p_block );
                return;
            }
        }
        p_storage->i_file_size += p_block->i_buffer;
        block_Release( p_block );

        if( b_flush )
            fflush( p_storage->p_filew );
    }
    p_storage->p_cmd[p_storage->i_cmd_w++] = cmd;
}",1,,1215,4,,void
49745,BLOCK,-1,,"{
        block_t *p_block = cmd.u.send.p_block;

        cmd.u.send.p_block = NULL;
        cmd.u.send.i_offset = ftell( p_storage->p_filew );

        if( fwrite( p_block, sizeof(*p_block), 1, p_storage->p_filew ) != 1 )
        {
            block_Release( p_block );
            return;
        }
        p_storage->i_file_size += sizeof(*p_block);
        if( p_block->i_buffer > 0 )
        {
            if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, p_storage->p_filew ) != 1 )
            {
                block_Release( p_block );
                return;
            }
        }
        p_storage->i_file_size += p_block->i_buffer;
        block_Release( p_block );

        if( b_flush )
            fflush( p_storage->p_filew );
    }",5,,1221,2,,void
49789,BLOCK,-1,,"{
            block_Release( p_block );
            return;
        }",9,,1228,2,,void
49806,BLOCK,-1,,"{
            if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, p_storage->p_filew ) != 1 )
            {
                block_Release( p_block );
                return;
            }
        }",9,,1234,2,,void
49821,BLOCK,-1,,"{
                block_Release( p_block );
                return;
            }",13,,1236,2,,void
49836,BLOCK,-1,,<empty>,13,,1245,2,,void
49857,BLOCK,-1,,"{
    assert( !TsStorageIsEmpty( p_storage ) );

    *p_cmd = p_storage->p_cmd[p_storage->i_cmd_r++];
    if( p_cmd->i_type == C_SEND )
    {
        block_t block;

        if( !b_flush &&
            !fseek( p_storage->p_filer, p_cmd->u.send.i_offset, SEEK_SET ) &&
            fread( &block, sizeof(block), 1, p_storage->p_filer ) == 1 )
        {
            block_t *p_block = block_Alloc( block.i_buffer );
            if( p_block )
            {
                p_block->i_dts      = block.i_dts;
                p_block->i_pts      = block.i_pts;
                p_block->i_flags    = block.i_flags;
                p_block->i_length   = block.i_length;
                p_block->i_nb_samples = block.i_nb_samples;
                p_block->i_buffer = fread( p_block->p_buffer, 1, block.i_buffer, p_storage->p_filer );
            }
            p_cmd->u.send.p_block = p_block;
        }
        else
        {
            //perror( ""TsStoragePopCmd"" );
            p_cmd->u.send.p_block = b...",1,,1250,4,,void
49879,BLOCK,-1,,"{
        block_t block;

        if( !b_flush &&
            !fseek( p_storage->p_filer, p_cmd->u.send.i_offset, SEEK_SET ) &&
            fread( &block, sizeof(block), 1, p_storage->p_filer ) == 1 )
        {
            block_t *p_block = block_Alloc( block.i_buffer );
            if( p_block )
            {
                p_block->i_dts      = block.i_dts;
                p_block->i_pts      = block.i_pts;
                p_block->i_flags    = block.i_flags;
                p_block->i_length   = block.i_length;
                p_block->i_nb_samples = block.i_nb_samples;
                p_block->i_buffer = fread( p_block->p_buffer, 1, block.i_buffer, p_storage->p_filer );
            }
            p_cmd->u.send.p_block = p_block;
        }
        else
        {
            //perror( ""TsStoragePopCmd"" );
            p_cmd->u.send.p_block = block_Alloc( 1 );
        }
    }",5,,1255,2,,void
49910,BLOCK,-1,,"{
            block_t *p_block = block_Alloc( block.i_buffer );
            if( p_block )
            {
                p_block->i_dts      = block.i_dts;
                p_block->i_pts      = block.i_pts;
                p_block->i_flags    = block.i_flags;
                p_block->i_length   = block.i_length;
                p_block->i_nb_samples = block.i_nb_samples;
                p_block->i_buffer = fread( p_block->p_buffer, 1, block.i_buffer, p_storage->p_filer );
            }
            p_cmd->u.send.p_block = p_block;
        }",9,,1261,2,,void
49920,BLOCK,-1,,"{
                p_block->i_dts      = block.i_dts;
                p_block->i_pts      = block.i_pts;
                p_block->i_flags    = block.i_flags;
                p_block->i_length   = block.i_length;
                p_block->i_nb_samples = block.i_nb_samples;
                p_block->i_buffer = fread( p_block->p_buffer, 1, block.i_buffer, p_storage->p_filer );
            }",13,,1264,2,,void
49981,BLOCK,-1,,"{
            //perror( ""TsStoragePopCmd"" );
            p_cmd->u.send.p_block = block_Alloc( 1 );
        }",9,,1275,1,,void
49996,BLOCK,-1,,"{
    switch( p_cmd->i_type )
    {
    case C_ADD:
        CmdCleanAdd( p_cmd );
        break;
    case C_SEND:
        CmdCleanSend( p_cmd );
        break;
    case C_CONTROL:
        CmdCleanControl( p_cmd );
        break;
    case C_DEL:
        break;
    default:
        vlc_assert_unreachable();
        break;
    }
}",1,,1286,2,,void
50001,BLOCK,-1,,"{
    case C_ADD:
        CmdCleanAdd( p_cmd );
        break;
    case C_SEND:
        CmdCleanSend( p_cmd );
        break;
    case C_CONTROL:
        CmdCleanControl( p_cmd );
        break;
    case C_DEL:
        break;
    default:
        vlc_assert_unreachable();
        break;
    }",5,,1288,2,,void
50030,BLOCK,-1,,"{
    p_cmd->i_type = C_ADD;
    p_cmd->i_date = mdate();
    p_cmd->u.add.p_es = p_es;
    if( b_copy )
    {
        p_cmd->u.add.p_fmt = malloc( sizeof(*p_fmt) );
        if( !p_cmd->u.add.p_fmt )
            return VLC_EGENERIC;
        es_format_Copy( p_cmd->u.add.p_fmt, p_fmt );
    }
    else
    {
        p_cmd->u.add.p_fmt = (es_format_t*)p_fmt;
    }
    return VLC_SUCCESS;
}",1,,1307,5,,void
50052,BLOCK,-1,,"{
        p_cmd->u.add.p_fmt = malloc( sizeof(*p_fmt) );
        if( !p_cmd->u.add.p_fmt )
            return VLC_EGENERIC;
        es_format_Copy( p_cmd->u.add.p_fmt, p_fmt );
    }",5,,1312,2,,void
50074,BLOCK,-1,,<empty>,13,,1315,2,,void
50087,BLOCK,-1,,"{
        p_cmd->u.add.p_fmt = (es_format_t*)p_fmt;
    }",5,,1319,1,,void
50106,BLOCK,-1,,"{
    p_cmd->u.add.p_es->p_es = es_out_Add( p_out, p_cmd->u.add.p_fmt );
}",1,,1325,3,,void
50130,BLOCK,-1,,"{
    es_format_Clean( p_cmd->u.add.p_fmt );
    free( p_cmd->u.add.p_fmt );
}",1,,1329,2,,void
50153,BLOCK,-1,,"{
    p_cmd->i_type = C_SEND;
    p_cmd->i_date = mdate();
    p_cmd->u.send.p_es = p_es;
    p_cmd->u.send.p_block = p_block;
}",1,,1335,4,,void
50187,BLOCK,-1,,"{
    block_t *p_block = p_cmd->u.send.p_block;

    p_cmd->u.send.p_block = NULL;

    if( p_block )
    {
        if( p_cmd->u.send.p_es->p_es )
            return es_out_Send( p_out, p_cmd->u.send.p_es->p_es, p_block );
        block_Release( p_block );
    }
    return VLC_EGENERIC;
}",1,,1342,3,,void
50209,BLOCK,-1,,"{
        if( p_cmd->u.send.p_es->p_es )
            return es_out_Send( p_out, p_cmd->u.send.p_es->p_es, p_block );
        block_Release( p_block );
    }",5,,1348,2,,void
50220,BLOCK,-1,,<empty>,13,,1350,2,,void
50242,BLOCK,-1,,"{
    if( p_cmd->u.send.p_block )
        block_Release( p_cmd->u.send.p_block );
}",1,,1356,2,,void
50251,BLOCK,-1,,<empty>,9,,1358,2,,void
50265,BLOCK,-1,,"{
    p_cmd->i_type = C_DEL;
    p_cmd->i_date = mdate();
    p_cmd->u.del.p_es = p_es;
    return VLC_SUCCESS;
}",1,,1362,3,,void
50292,BLOCK,-1,,"{
    if( p_cmd->u.del.p_es->p_es )
        es_out_Del( p_out, p_cmd->u.del.p_es->p_es );
    free( p_cmd->u.del.p_es );
}",1,,1369,3,,void
50303,BLOCK,-1,,<empty>,9,,1371,2,,void
50330,BLOCK,-1,,"{
    p_cmd->i_type = C_CONTROL;
    p_cmd->i_date = mdate();
    p_cmd->u.control.i_query = i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        p_cmd->u.control.u.i_int = (int)va_arg( args, int );
        break;

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        p_cmd->u.control.u.i_i64 = (int64_t)va_arg( args, int64_t );
        break;

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        p_cmd->u.control.u.int_i64.i_int = (int)va_arg( args, int );
        p_cmd->u.control.u.int_i64.i_i64 = (int64_t)va_arg( args, int64_t );
        break;

    case ES_OUT_SET_ES_SCRAMBLED_STATE...",1,,1376,5,,void
50352,BLOCK,-1,,"{
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        p_cmd->u.control.u.i_int = (int)va_arg( args, int );
        break;

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        p_cmd->u.control.u.i_i64 = (int64_t)va_arg( args, int64_t );
        break;

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        p_cmd->u.control.u.int_i64.i_int = (int)va_arg( args, int );
        p_cmd->u.control.u.int_i64.i_i64 = (int64_t)va_arg( args, int64_t );
        break;

    case ES_OUT_SET_ES_SCRAMBLED_STATE:
        p_cmd->u.control.u.es_bool.p_es = (es_out_id_t*)va_arg( args, es_out_id_t * );
        p_cmd->u.control.u.es_bool.b_boo...",5,,1382,2,,void
50432,BLOCK,38,,"{
        if( i_query == ES_OUT_SET_GROUP_META )
            p_cmd->u.control.u.int_meta.i_int = (int)va_arg( args, int );
        const vlc_meta_t *p_meta = va_arg( args, const vlc_meta_t * );

        if( b_copy )
        {
            p_cmd->u.control.u.int_meta.p_meta = vlc_meta_New();
            if( !p_cmd->u.control.u.int_meta.p_meta )
                return VLC_EGENERIC;
            vlc_meta_Merge( p_cmd->u.control.u.int_meta.p_meta, p_meta );
        }
        else
        {
            /* The cast is only needed to avoid warning */
            p_cmd->u.control.u.int_meta.p_meta = (vlc_meta_t*)p_meta;
        }
        break;
    }",5,,1412,38,,void
50439,BLOCK,-1,,"{
            p_cmd->u.control.u.int_meta.p_meta = vlc_meta_New();
            if( !p_cmd->u.control.u.int_meta.p_meta )
                return VLC_EGENERIC;
            vlc_meta_Merge( p_cmd->u.control.u.int_meta.p_meta, p_meta );
        }",9,,1418,2,,void
50466,BLOCK,-1,,<empty>,17,,1421,2,,void
50483,BLOCK,-1,,"{
            /* The cast is only needed to avoid warning */
            p_cmd->u.control.u.int_meta.p_meta = (vlc_meta_t*)p_meta;
        }",9,,1425,1,,void
50502,BLOCK,41,,"{
        p_cmd->u.control.u.int_epg.i_int = (int)va_arg( args, int );
        const vlc_epg_t *p_epg = va_arg( args, const vlc_epg_t * );

        if( b_copy )
        {
            p_cmd->u.control.u.int_epg.p_epg = vlc_epg_Duplicate( p_epg );
            if( !p_cmd->u.control.u.int_epg.p_epg )
                return VLC_EGENERIC;
        }
        else
        {
            /* The cast is only needed to avoid warning */
            p_cmd->u.control.u.int_epg.p_epg = (vlc_epg_t*)p_epg;
        }
        break;
    }",5,,1433,41,,void
50509,BLOCK,-1,,"{
            p_cmd->u.control.u.int_epg.p_epg = vlc_epg_Duplicate( p_epg );
            if( !p_cmd->u.control.u.int_epg.p_epg )
                return VLC_EGENERIC;
        }",9,,1438,2,,void
50537,BLOCK,-1,,<empty>,17,,1441,2,,void
50541,BLOCK,-1,,"{
            /* The cast is only needed to avoid warning */
            p_cmd->u.control.u.int_epg.p_epg = (vlc_epg_t*)p_epg;
        }",9,,1444,1,,void
50560,BLOCK,44,,"{
        p_cmd->u.control.u.int_epg_evt.i_int = (int)va_arg( args, int );
        const vlc_epg_event_t *p_evt = va_arg( args, const vlc_epg_event_t * );

        if( b_copy )
        {
            p_cmd->u.control.u.int_epg_evt.p_evt = vlc_epg_event_Duplicate( p_evt );
            if( !p_cmd->u.control.u.int_epg_evt.p_evt )
                return VLC_EGENERIC;
        }
        else
        {
            /* The cast is only needed to avoid warning */
            p_cmd->u.control.u.int_epg_evt.p_evt = (vlc_epg_event_t*)p_evt;
        }
        break;
    }",5,,1451,44,,void
50567,BLOCK,-1,,"{
            p_cmd->u.control.u.int_epg_evt.p_evt = vlc_epg_event_Duplicate( p_evt );
            if( !p_cmd->u.control.u.int_epg_evt.p_evt )
                return VLC_EGENERIC;
        }",9,,1456,2,,void
50595,BLOCK,-1,,<empty>,17,,1459,2,,void
50599,BLOCK,-1,,"{
            /* The cast is only needed to avoid warning */
            p_cmd->u.control.u.int_epg_evt.p_evt = (vlc_epg_event_t*)p_evt;
        }",9,,1462,1,,void
50668,BLOCK,71,,"{
        p_cmd->u.control.u.es_fmt.p_es = (es_out_id_t*)va_arg( args, es_out_id_t * );
        es_format_t *p_fmt = (es_format_t*)va_arg( args, es_format_t * );

        if( b_copy )
        {
            p_cmd->u.control.u.es_fmt.p_fmt = malloc( sizeof(*p_fmt) );
            if( !p_cmd->u.control.u.es_fmt.p_fmt )
                return VLC_EGENERIC;
            es_format_Copy( p_cmd->u.control.u.es_fmt.p_fmt, p_fmt );
        }
        else
        {
            p_cmd->u.control.u.es_fmt.p_fmt = p_fmt;
        }
        break;
    }",5,,1490,71,,void
50673,BLOCK,-1,,"{
            p_cmd->u.control.u.es_fmt.p_fmt = malloc( sizeof(*p_fmt) );
            if( !p_cmd->u.control.u.es_fmt.p_fmt )
                return VLC_EGENERIC;
            es_format_Copy( p_cmd->u.control.u.es_fmt.p_fmt, p_fmt );
        }",9,,1495,2,,void
50703,BLOCK,-1,,<empty>,17,,1498,2,,void
50720,BLOCK,-1,,"{
            p_cmd->u.control.u.es_fmt.p_fmt = p_fmt;
        }",9,,1502,1,,void
50737,BLOCK,74,,"{
        double f_position = (double)va_arg( args, double );
        mtime_t i_time = (mtime_t)va_arg( args, mtime_t );
        mtime_t i_length = (mtime_t)va_arg( args, mtime_t );

        p_cmd->u.control.u.times.f_position = f_position;
        p_cmd->u.control.u.times.i_time = i_time;
        p_cmd->u.control.u.times.i_length = i_length;
        break;
    }",5,,1508,74,,void
50797,BLOCK,77,,"{
        mtime_t i_pts_delay = (mtime_t)va_arg( args, mtime_t );
        mtime_t i_pts_jitter = (mtime_t)va_arg( args, mtime_t );
        int     i_cr_average = (int)va_arg( args, int );

        p_cmd->u.control.u.jitter.i_pts_delay = i_pts_delay;
        p_cmd->u.control.u.jitter.i_pts_jitter = i_pts_jitter;
        p_cmd->u.control.u.jitter.i_cr_average = i_cr_average;
        break;
    }",5,,1519,77,,void
50866,BLOCK,-1,,"{
    const int i_query = p_cmd->u.control.i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_int );

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_i64 );

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.int_i64.i_int,
                                               p_cmd->u.control.u.int_i64.i_i64 );

    case ES_OUT_RESET_PCR:           /* no arg */
    case ES_OUT_SET_EOS:
    case ES_OUT_REST...",1,,1538,3,,void
50879,BLOCK,-1,,"{
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_int );

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_i64 );

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.int_i64.i_int,
                                               p_cmd->u.control.u.int_i64.i_i64 );

    case ES_OUT_RESET_PCR:           /* no arg */
    case ES_OUT_SET_EOS:
    case ES_OUT_RESTART_ALL_ES:
        return es_out_Control( p_out, i_query );

    case ES_OUT_S...",5,,1542,2,,void
51307,BLOCK,-1,,"{
    switch( p_cmd->u.control.i_query )
    {
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_META:
        if( p_cmd->u.control.u.int_meta.p_meta )
            vlc_meta_Delete( p_cmd->u.control.u.int_meta.p_meta );
        break;
    case ES_OUT_SET_GROUP_EPG:
        if( p_cmd->u.control.u.int_epg.p_epg )
            vlc_epg_Delete( p_cmd->u.control.u.int_epg.p_epg );
        break;
    case ES_OUT_SET_GROUP_EPG_EVENT:
        if( p_cmd->u.control.u.int_epg_evt.p_evt )
            vlc_epg_event_Delete( p_cmd->u.control.u.int_epg_evt.p_evt );
        break;
    case ES_OUT_SET_ES_FMT:
        if( p_cmd->u.control.u.es_fmt.p_fmt )
        {
            es_format_Clean( p_cmd->u.control.u.es_fmt.p_fmt );
            free( p_cmd->u.control.u.es_fmt.p_fmt );
        }
        break;
    }
}",1,,1618,2,,void
51316,BLOCK,-1,,"{
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_META:
        if( p_cmd->u.control.u.int_meta.p_meta )
            vlc_meta_Delete( p_cmd->u.control.u.int_meta.p_meta );
        break;
    case ES_OUT_SET_GROUP_EPG:
        if( p_cmd->u.control.u.int_epg.p_epg )
            vlc_epg_Delete( p_cmd->u.control.u.int_epg.p_epg );
        break;
    case ES_OUT_SET_GROUP_EPG_EVENT:
        if( p_cmd->u.control.u.int_epg_evt.p_evt )
            vlc_epg_event_Delete( p_cmd->u.control.u.int_epg_evt.p_evt );
        break;
    case ES_OUT_SET_ES_FMT:
        if( p_cmd->u.control.u.es_fmt.p_fmt )
        {
            es_format_Clean( p_cmd->u.control.u.es_fmt.p_fmt );
            free( p_cmd->u.control.u.es_fmt.p_fmt );
        }
        break;
    }",5,,1620,2,,void
51333,BLOCK,-1,,<empty>,13,,1624,2,,void
51361,BLOCK,-1,,<empty>,13,,1628,2,,void
51389,BLOCK,-1,,<empty>,13,,1632,2,,void
51417,BLOCK,-1,,"{
            es_format_Clean( p_cmd->u.control.u.es_fmt.p_fmt );
            free( p_cmd->u.control.u.es_fmt.p_fmt );
        }",9,,1636,2,,void
51448,BLOCK,-1,,"{
    if( dirname != NULL
     && asprintf( filename, ""%s""DIR_SEP PACKAGE_NAME""-timeshift.XXXXXX"",
                  dirname ) >= 0 )
    {
        vlc_mkdir( dirname, 0700 );

        int fd = vlc_mkstemp( *filename );
        if( fd != -1 )
            return fd;

        free( *filename );
    }

    *filename = strdup( DIR_SEP""tmp""DIR_SEP PACKAGE_NAME""-timeshift.XXXXXX"" );
    if( unlikely(*filename == NULL) )
        return -1;

    int fd = vlc_mkstemp( *filename );
    if( fd != -1 )
        return fd;

    free( *filename );
    return -1;
}",1,,1645,3,,void
51451,BLOCK,-1,,"{
        vlc_mkdir( dirname, 0700 );

        int fd = vlc_mkstemp( *filename );
        if( fd != -1 )
            return fd;

        free( *filename );
    }",5,,1649,2,,void
51466,BLOCK,-1,,<empty>,13,,1654,2,,void
51479,BLOCK,-1,,<empty>,9,,1661,2,,void
51494,BLOCK,-1,,<empty>,9,,1665,2,,void
51511,BLOCK,-1,,<empty>,1,,1,1,,ANY
51516,BLOCK,-1,,<empty>,,,,4,,<empty>
51535,BLOCK,-1,,<empty>,1,,1,1,,ANY
51539,BLOCK,-1,,<empty>,,,,3,,<empty>
51548,BLOCK,-1,,<empty>,,,,6,,<empty>
51556,BLOCK,-1,,<empty>,,,,5,,<empty>
51564,BLOCK,-1,,<empty>,,,,5,,<empty>
51569,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_DEAD );
}",1,,53,2,,void
51579,BLOCK,-1,,"{
    vlc_value_t val;

    /* */
    val.f_float = f_position;
    var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );

    /* */
    val.i_int = i_time;
    var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_POSITION );
}",1,,58,4,,void
51613,BLOCK,-1,,"{
    vlc_value_t val;

    /* FIXME ugly + what about meta change event ? */
    if( var_GetInteger( p_input, ""length"" ) == i_length )
        return;

    input_item_SetDuration( input_priv(p_input)->p_item, i_length );

    val.i_int = i_length;
    var_Change( p_input, ""length"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_LENGTH );
}",1,,72,3,,void
51621,BLOCK,-1,,<empty>,9,,77,2,,void
51648,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_STATISTICS );
}",1,,87,2,,void
51657,BLOCK,-1,,"{
    vlc_value_t val;

    val.f_float = (float)INPUT_RATE_DEFAULT / (float)i_rate;
    var_Change( p_input, ""rate"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RATE );
}",1,,91,3,,void
51685,BLOCK,-1,,"{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""audio-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_AUDIO_DELAY );
}",1,,100,3,,void
51707,BLOCK,-1,,"{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""spu-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SUBTITLE_DELAY );
}",1,,110,3,,void
51729,BLOCK,-1,,"{
    vlc_value_t val;

    val.b_bool = b_recording;
    var_Change( p_input, ""record"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RECORD );
}",1,,121,3,,void
51751,BLOCK,-1,,"{
    vlc_value_t val;

    val.i_int = i_title;
    var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );

    input_ControlVarTitle( p_input, i_title );

    Trigger( p_input, INPUT_EVENT_TITLE );
}",1,,131,3,,void
51777,BLOCK,-1,,"{
    vlc_value_t val;

    /* ""chapter"" */
    val.i_int = i_seekpoint;
    var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );

    /* ""title %2u"" */
    char psz_title[sizeof (""title "") + 3 * sizeof (int)];
    sprintf( psz_title, ""title %2u"", i_title );
    var_Change( p_input, psz_title, VLC_VAR_SETVALUE, &val, NULL );

    /* */
    Trigger( p_input, INPUT_EVENT_CHAPTER );
}",1,,143,4,,void
51812,BLOCK,-1,,"{
    vlc_value_t val;

    val.f_float = f_quality;
    var_Change( p_input, ""signal-quality"", VLC_VAR_SETVALUE, &val, NULL );

    val.f_float = f_strength;
    var_Change( p_input, ""signal-strength"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SIGNAL );
}",1,,160,4,,void
51846,BLOCK,-1,,"{
    vlc_value_t val;

    val.i_int = i_state;
    var_Change( p_input, ""state"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_STATE );
}",1,,173,3,,void
51868,BLOCK,-1,,"{
    vlc_value_t val;

    val.f_float = f_level;
    var_Change( p_input, ""cache"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_CACHE );
}",1,,183,3,,void
51889,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_ITEM_META );
}",1,,193,2,,void
51897,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_ITEM_INFO );
}",1,,198,2,,void
51905,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_ITEM_EPG );
}",1,,203,2,,void
51915,BLOCK,-1,,"{
    VarListAdd( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program, psz_text );
}",1,,211,4,,void
51927,BLOCK,-1,,"{
    VarListDel( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",1,,215,3,,void
51938,BLOCK,-1,,"{
    VarListSelect( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",1,,219,3,,void
51950,BLOCK,-1,,"{
    if( var_GetInteger( p_input, ""program"" ) != i_group )
        return;

    var_SetBool( p_input, ""program-scrambled"", b_scrambled );
    Trigger( p_input, INPUT_EVENT_PROGRAM );
}",1,,223,4,,void
51957,BLOCK,-1,,<empty>,9,,225,2,,void
51970,BLOCK,-1,,"{
    switch( i_cat )
    {
    case VIDEO_ES:
        return ""video-es"";
    case AUDIO_ES:
        return ""audio-es"";
    case SPU_ES:
        return ""spu-es"";
    default:
        return NULL;
    }
}",1,,232,2,,void
51973,BLOCK,-1,,"{
    case VIDEO_ES:
        return ""video-es"";
    case AUDIO_ES:
        return ""audio-es"";
    case SPU_ES:
        return ""spu-es"";
    default:
        return NULL;
    }",5,,234,2,,void
51996,BLOCK,-1,,"{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListAdd( p_input, psz_varname, INPUT_EVENT_ES, i_id, psz_text );
}",1,,246,5,,void
52004,BLOCK,-1,,<empty>,9,,249,2,,void
52017,BLOCK,-1,,"{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListDel( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",1,,252,4,,void
52025,BLOCK,-1,,<empty>,9,,255,2,,void
52037,BLOCK,-1,,"{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListSelect( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",1,,259,4,,void
52045,BLOCK,-1,,<empty>,9,,262,2,,void
52057,BLOCK,-1,,"{
    VarListAdd( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext, psz_text );
}",1,,267,4,,void
52069,BLOCK,-1,,"{
    VarListDel( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",1,,271,3,,void
52080,BLOCK,-1,,"{
    VarListSelect( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",1,,275,3,,void
52090,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_VOUT );
}",1,,280,2,,void
52098,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_AOUT );
}",1,,285,2,,void
52106,BLOCK,-1,,"{
    Trigger( p_input, INPUT_EVENT_BOOKMARK );
}",1,,293,2,,void
52115,BLOCK,-1,,"{
    var_SetInteger( p_input, ""intf-event"", i_type );
}",1,,301,3,,void
52128,BLOCK,-1,,"{
    vlc_value_t val;
    vlc_value_t text;

    val.i_int = i_value;
    text.psz_string = (char*)psz_text;

    var_Change( p_input, psz_variable, VLC_VAR_ADDCHOICE,
                &val, psz_text ? &text : NULL );

    Trigger( p_input, i_event );
}",1,,307,6,,void
52164,BLOCK,-1,,"{
    vlc_value_t val;

    if( i_value >= 0 )
    {
        val.i_int = i_value;
        var_Change( p_input, psz_variable, VLC_VAR_DELCHOICE, &val, NULL );
    }
    else
    {
        var_Change( p_input, psz_variable, VLC_VAR_CLEARCHOICES, &val, NULL );
    }

    Trigger( p_input, i_event );
}",1,,322,5,,void
52170,BLOCK,-1,,"{
        val.i_int = i_value;
        var_Change( p_input, psz_variable, VLC_VAR_DELCHOICE, &val, NULL );
    }",5,,326,2,,void
52184,BLOCK,-1,,"{
        var_Change( p_input, psz_variable, VLC_VAR_CLEARCHOICES, &val, NULL );
    }",5,,331,1,,void
52202,BLOCK,-1,,"{
    vlc_value_t val;

    val.i_int = i_value;
    var_Change( p_input, psz_variable, VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, i_event );
}",1,,340,5,,void
52227,BLOCK,-1,,<empty>,1,,1,1,,ANY
52230,BLOCK,-1,,<empty>,,,,2,,<empty>
52237,BLOCK,-1,,<empty>,,,,4,,<empty>
52243,BLOCK,-1,,<empty>,,,,3,,<empty>
52248,BLOCK,-1,,<empty>,,,,2,,<empty>
52254,BLOCK,-1,,<empty>,,,,3,,<empty>
52260,BLOCK,-1,,<empty>,,,,3,,<empty>
52266,BLOCK,-1,,<empty>,,,,3,,<empty>
52272,BLOCK,-1,,<empty>,,,,3,,<empty>
52278,BLOCK,-1,,<empty>,,,,3,,<empty>
52285,BLOCK,-1,,<empty>,,,,4,,<empty>
52292,BLOCK,-1,,<empty>,,,,4,,<empty>
52298,BLOCK,-1,,<empty>,,,,3,,<empty>
52304,BLOCK,-1,,<empty>,,,,3,,<empty>
52309,BLOCK,-1,,<empty>,,,,2,,<empty>
52314,BLOCK,-1,,<empty>,,,,2,,<empty>
52319,BLOCK,-1,,<empty>,,,,2,,<empty>
52326,BLOCK,-1,,<empty>,,,,4,,<empty>
52332,BLOCK,-1,,<empty>,,,,3,,<empty>
52338,BLOCK,-1,,<empty>,,,,3,,<empty>
52345,BLOCK,-1,,<empty>,,,,4,,<empty>
52352,BLOCK,-1,,<empty>,,,,4,,<empty>
52360,BLOCK,-1,,<empty>,,,,5,,<empty>
52367,BLOCK,-1,,<empty>,,,,4,,<empty>
52374,BLOCK,-1,,<empty>,,,,4,,<empty>
52380,BLOCK,-1,,<empty>,,,,3,,<empty>
52386,BLOCK,-1,,<empty>,,,,3,,<empty>
52391,BLOCK,-1,,<empty>,,,,2,,<empty>
52396,BLOCK,-1,,<empty>,,,,2,,<empty>
52401,BLOCK,-1,,<empty>,,,,2,,<empty>
52410,BLOCK,-1,,<empty>,1,,1,1,,ANY
52414,BLOCK,-1,,"{
    info_t *info = malloc(sizeof(*info));
    if (!info)
        return NULL;

    info->psz_name = strdup(name);
    info->psz_value = value ? strdup(value) : NULL;
    return info;
}",1,,30,3,,void
52425,BLOCK,-1,,<empty>,9,,33,2,,void
52449,BLOCK,-1,,"{
    free(i->psz_name);
    free(i->psz_value);
    free(i);
}",1,,41,2,,void
52464,BLOCK,-1,,"{
    info_category_t *cat = malloc(sizeof(*cat));
    if (!cat)
        return NULL;
    cat->psz_name = strdup(name);
    cat->i_infos  = 0;
    cat->pp_infos = NULL;

    return cat;
}",1,,48,2,,void
52475,BLOCK,-1,,<empty>,9,,51,2,,void
52502,BLOCK,-1,,"{
    for (int i = 0; i < cat->i_infos; i++) {
        if (!strcmp(cat->pp_infos[i]->psz_name, name)) {
            if (index)
                *index = i;
            return cat->pp_infos[i];
        }
    }
    return NULL;
}",1,,61,4,,void
52504,BLOCK,-1,,<empty>,5,,62,1,,void
52516,BLOCK,4,,"{
        if (!strcmp(cat->pp_infos[i]->psz_name, name)) {
            if (index)
                *index = i;
            return cat->pp_infos[i];
        }
    }",44,,62,4,,void
52528,BLOCK,-1,,"{
            if (index)
                *index = i;
            return cat->pp_infos[i];
        }",56,,63,2,,void
52531,BLOCK,-1,,<empty>,17,,65,2,,void
52549,BLOCK,-1,,"{
    int index;
    info_t *old = info_category_FindInfo(cat, &index, info->psz_name);
    if (old) {
        info_Delete(cat->pp_infos[index]);
        cat->pp_infos[index] = info;
    } else
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
}",1,,74,3,,void
52563,BLOCK,-1,,"{
        info_Delete(cat->pp_infos[index]);
        cat->pp_infos[index] = info;
    }",14,,77,2,,void
52578,BLOCK,-1,,<empty>,9,,81,1,,void
52594,BLOCK,-1,,"{
    info_t *info = info_category_FindInfo(cat, NULL, name);
    if (!info) {
        info = info_New(name, NULL);
        if (!info)
            return NULL;
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
    } else
        free(info->psz_value);
    if (vasprintf(&info->psz_value, format, args) == -1)
        info->psz_value = NULL;
    return info;
}",1,,87,5,,void
52605,BLOCK,-1,,"{
        info = info_New(name, NULL);
        if (!info)
            return NULL;
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
    }",16,,89,2,,void
52614,BLOCK,-1,,<empty>,13,,92,2,,void
52626,BLOCK,-1,,<empty>,9,,95,1,,void
52642,BLOCK,-1,,<empty>,9,,97,2,,void
52656,BLOCK,-1,,"{
    va_list args;

    va_start(args, format);
    info_t *info = info_category_VaAddInfo(cat, name, format, args);
    va_end(args);

    return info;
}",1,,104,4,,void
52678,BLOCK,-1,,"{
    int index;
    if (info_category_FindInfo(cat, &index, name)) {
        info_Delete(cat->pp_infos[index]);
        TAB_ERASE(cat->i_infos, cat->pp_infos, index);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",1,,115,3,,void
52686,BLOCK,-1,,"{
        info_Delete(cat->pp_infos[index]);
        TAB_ERASE(cat->i_infos, cat->pp_infos, index);
        return VLC_SUCCESS;
    }",52,,117,2,,void
52709,BLOCK,-1,,"{
    for (int i = 0; i < cat->i_infos; i++)
        info_Delete(cat->pp_infos[i]);
    free(cat->pp_infos);
    free(cat->psz_name);
    free(cat);
}",1,,126,2,,void
52711,BLOCK,-1,,<empty>,5,,127,1,,void
52793,BLOCK,-1,,<empty>,1,,1,1,,ANY
52796,BLOCK,-1,,<empty>,,,,2,,<empty>
52801,BLOCK,-1,,<empty>,,,,2,,<empty>
52811,BLOCK,-1,,<empty>,,,,7,,<empty>
52816,BLOCK,-1,,<empty>,,,,2,,<empty>
52821,BLOCK,-1,,<empty>,,,,2,,<empty>
52827,BLOCK,-1,,<empty>,,,,3,,<empty>
52836,BLOCK,-1,,<empty>,,,,6,,<empty>
52842,BLOCK,-1,,<empty>,,,,3,,<empty>
52847,BLOCK,-1,,<empty>,,,,2,,<empty>
52854,BLOCK,-1,,<empty>,,,,4,,<empty>
52860,BLOCK,-1,,<empty>,,,,3,,<empty>
52865,BLOCK,-1,,<empty>,,,,2,,<empty>
52870,BLOCK,-1,,<empty>,,,,2,,<empty>
52875,BLOCK,-1,,<empty>,,,,2,,<empty>
52884,BLOCK,-1,,<empty>,,,,6,,<empty>
52892,BLOCK,-1,,<empty>,,,,5,,<empty>
52897,BLOCK,-1,,<empty>,,,,2,,<empty>
52904,BLOCK,-1,,<empty>,,,,4,,<empty>
52909,BLOCK,-1,,<empty>,,,,2,,<empty>
52914,BLOCK,-1,,<empty>,,,,2,,<empty>
52920,BLOCK,-1,,<empty>,,,,3,,<empty>
52926,BLOCK,-1,,<empty>,,,,3,,<empty>
52935,BLOCK,-1,,<empty>,,,,6,,<empty>
52945,BLOCK,-1,,<empty>,,,,7,,<empty>
52953,BLOCK,-1,,<empty>,,,,5,,<empty>
52959,BLOCK,-1,,<empty>,,,,3,,<empty>
52965,BLOCK,-1,,<empty>,,,,3,,<empty>
52974,BLOCK,-1,,"{
    return Create( p_parent, p_item, psz_log, false, p_resource, p_renderer );
}",1,,132,6,,void
52988,BLOCK,-1,,"{
    input_thread_t *p_input = Create( p_parent, p_item, NULL, false, NULL, NULL );
    if( !p_input )
        return VLC_EGENERIC;

    if( !Init( p_input ) )
    {
        MainLoop( p_input, false );
        End( p_input );
    }

    vlc_object_release( p_input );
    return VLC_SUCCESS;
}",1,,145,3,,void
53002,BLOCK,-1,,<empty>,9,,148,2,,void
53009,BLOCK,-1,,"{
        MainLoop( p_input, false );
        End( p_input );
    }",5,,151,2,,void
53024,BLOCK,-1,,"{
    return Create( parent, item, NULL, true, NULL, NULL );
}",1,,162,3,,void
53037,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    void *(*func)(void *) = Run;

    if( priv->b_preparsing )
        func = Preparse;

    assert( !priv->is_running );
    /* Create thread and wait for its readiness. */
    priv->is_running = !vlc_clone( &priv->thread, func, priv,
                                   VLC_THREAD_PRIORITY_INPUT );
    if( !priv->is_running )
    {
        input_ChangeState( p_input, ERROR_S );
        msg_Err( p_input, ""cannot create input thread"" );
        return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,,174,2,,void
53045,BLOCK,-1,,<empty>,,,,2,,<empty>
53052,BLOCK,-1,,<empty>,9,,179,2,,void
53079,BLOCK,-1,,"{
        input_ChangeState( p_input, ERROR_S );
        msg_Err( p_input, ""cannot create input thread"" );
        return VLC_EGENERIC;
    }",5,,186,2,,void
53094,BLOCK,-1,,"{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    /* Discard all pending controls */
    for( int i = 0; i < sys->i_control; i++ )
    {
        input_control_t *ctrl = &sys->control[i];
        ControlRelease( ctrl->i_type, ctrl->val );
    }
    sys->i_control = 0;
    sys->is_stopped = true;
    vlc_cond_signal( &sys->wait_control );
    vlc_mutex_unlock( &sys->lock_control );
    vlc_interrupt_kill( &sys->interrupt );
}",1,,200,2,,void
53106,BLOCK,-1,,<empty>,5,,205,1,,void
53118,BLOCK,4,,"{
        input_control_t *ctrl = &sys->control[i];
        ControlRelease( ctrl->i_type, ctrl->val );
    }",5,,206,4,,void
53164,BLOCK,-1,,"{
    if( input_priv(p_input)->is_running )
        vlc_join( input_priv(p_input)->thread, NULL );
    vlc_interrupt_deinit( &input_priv(p_input)->interrupt );
    vlc_object_release( p_input );
}",1,,223,2,,void
53170,BLOCK,-1,,<empty>,9,,225,2,,void
53189,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t *)obj;
    input_thread_private_t *priv = input_priv(p_input);
#ifndef NDEBUG
    char * psz_name = input_item_GetName( priv->p_item );
    msg_Dbg( p_input, ""Destroying the input for '%s'"", psz_name);
    free( psz_name );
#endif

    if( priv->p_renderer )
        vlc_renderer_item_release( priv->p_renderer );
    if( priv->p_es_out_display )
        es_out_Delete( priv->p_es_out_display );

    if( priv->p_resource )
        input_resource_Release( priv->p_resource );
    if( priv->p_resource_private )
        input_resource_Release( priv->p_resource_private );

    input_item_Release( priv->p_item );

    vlc_mutex_destroy( &priv->counters.counters_lock );

    for( int i = 0; i < priv->i_control; i++ )
    {
        input_control_t *p_ctrl = &priv->control[i];
        ControlRelease( p_ctrl->i_type, p_ctrl->val );
    }

    vlc_cond_destroy( &priv->wait_control );
    vlc_mutex_destroy( &priv->lock_control );
}",1,,234,2,,void
53218,BLOCK,-1,,<empty>,9,,244,2,,void
53227,BLOCK,-1,,<empty>,9,,246,2,,void
53236,BLOCK,-1,,<empty>,9,,249,2,,void
53245,BLOCK,-1,,<empty>,9,,251,2,,void
53262,BLOCK,-1,,<empty>,5,,257,1,,void
53274,BLOCK,4,,"{
        input_control_t *p_ctrl = &priv->control[i];
        ControlRelease( p_ctrl->i_type, p_ctrl->val );
    }",5,,258,4,,void
53305,BLOCK,-1,,"{
    assert( p_input != NULL );
    return input_priv(p_input)->p_item;
}",1,,274,2,,void
53324,BLOCK,-1,,"{
    /* Allocate descriptor */
    input_thread_private_t *priv;

    priv = vlc_custom_create( p_parent, sizeof( *priv ), ""input"" );
    if( unlikely(priv == NULL) )
        return NULL;

    input_thread_t *p_input = &priv->input;

    char * psz_name = input_item_GetName( p_item );
    msg_Dbg( p_input, ""Creating an input for %s'%s'"",
             b_preparsing ? ""preparsing "" : """", psz_name);
    free( psz_name );

    /* Parse input options */
    input_item_ApplyOptions( VLC_OBJECT(p_input), p_item );

    p_input->obj.header = psz_header ? strdup( psz_header ) : NULL;

    /* Init Common fields */
    priv->b_preparsing = b_preparsing;
    priv->b_can_pace_control = true;
    priv->i_start = 0;
    priv->i_time  = 0;
    priv->i_stop  = 0;
    priv->i_title = 0;
    priv->title = NULL;
    priv->i_title_offset = input_priv(p_input)->i_seekpoint_offset = 0;
    priv->i_state = INIT_S;
    priv->is_running = false;
    priv->is_stopped = false;
    priv->b_recording = false;
  ...",1,,289,7,,void
53339,BLOCK,-1,,<empty>,9,,295,2,,void
53516,BLOCK,-1,,<empty>,9,,336,2,,void
53524,BLOCK,-1,,<empty>,9,,338,1,,void
53552,BLOCK,-1,,<empty>,9,,348,2,,void
53564,BLOCK,-1,,"{
        char *psz_rec = var_InheritString( p_parent, ""recursive"" );

        if( psz_rec != NULL )
        {
            if ( !strcasecmp( psz_rec, ""none"" ) )
                p_item->i_preparse_depth = 0;
            else if ( !strcasecmp( psz_rec, ""collapse"" ) )
                p_item->i_preparse_depth = 1;
            else
                p_item->i_preparse_depth = -1; /* default is expand */
            free (psz_rec);
        } else
            p_item->i_preparse_depth = -1;
    }",5,,353,2,,void
53575,BLOCK,-1,,"{
            if ( !strcasecmp( psz_rec, ""none"" ) )
                p_item->i_preparse_depth = 0;
            else if ( !strcasecmp( psz_rec, ""collapse"" ) )
                p_item->i_preparse_depth = 1;
            else
                p_item->i_preparse_depth = -1; /* default is expand */
            free (psz_rec);
        }",9,,357,2,,void
53581,BLOCK,-1,,<empty>,17,,359,2,,void
53588,BLOCK,-1,,<empty>,18,,360,1,,void
53594,BLOCK,-1,,<empty>,17,,361,2,,void
53601,BLOCK,-1,,<empty>,17,,363,1,,void
53611,BLOCK,-1,,<empty>,13,,366,1,,void
53619,BLOCK,-1,,<empty>,9,,369,1,,void
53634,BLOCK,-1,,<empty>,9,,373,2,,void
53643,BLOCK,-1,,<empty>,10,,374,1,,void
53648,BLOCK,-1,,"{
        /* If true, this item was asked explicitly to interact with the user
         * (via libvlc_MetadataRequest). Sub items created from this input won't
         * have this flag and won't interact with the user */
        p_input->obj.flags &= ~OBJECT_FLAGS_NOINTERACT;
    }",5,,375,2,,void
53674,BLOCK,-1,,"{
        priv->p_resource_private = NULL;
        priv->p_resource = input_resource_Hold( p_resource );
    }",5,,390,2,,void
53687,BLOCK,-1,,"{
        priv->p_resource_private = input_resource_New( VLC_OBJECT( p_input ) );
        priv->p_resource = input_resource_Hold( priv->p_resource_private );
    }",5,,395,1,,void
53737,BLOCK,-1,,"{
        char *psz_bookmarks = var_GetNonEmptyString( p_input, ""bookmarks"" );
        if( psz_bookmarks )
        {
            /* FIXME: have a common cfg parsing routine used by sout and others */
            char *psz_parser, *psz_start, *psz_end;
            psz_parser = psz_bookmarks;
            while( (psz_start = strchr( psz_parser, '{' ) ) )
            {
                 seekpoint_t *p_seekpoint;
                 char backup;
                 psz_start++;
                 psz_end = strchr( psz_start, '}' );
                 if( !psz_end ) break;
                 psz_parser = psz_end + 1;
                 backup = *psz_parser;
                 *psz_parser = 0;
                 *psz_end = ',';

                 p_seekpoint = vlc_seekpoint_New();

                 if( unlikely( p_seekpoint == NULL ) )
                     break;

                 while( (psz_end = strchr( psz_start, ',' ) ) )
                 {
                     *psz_end = 0;
                     if( !str...",5,,415,2,,void
53746,BLOCK,-1,,"{
            /* FIXME: have a common cfg parsing routine used by sout and others */
            char *psz_parser, *psz_start, *psz_end;
            psz_parser = psz_bookmarks;
            while( (psz_start = strchr( psz_parser, '{' ) ) )
            {
                 seekpoint_t *p_seekpoint;
                 char backup;
                 psz_start++;
                 psz_end = strchr( psz_start, '}' );
                 if( !psz_end ) break;
                 psz_parser = psz_end + 1;
                 backup = *psz_parser;
                 *psz_parser = 0;
                 *psz_end = ',';

                 p_seekpoint = vlc_seekpoint_New();

                 if( unlikely( p_seekpoint == NULL ) )
                     break;

                 while( (psz_end = strchr( psz_start, ',' ) ) )
                 {
                     *psz_end = 0;
                     if( !strncmp( psz_start, ""name="", 5 ) )
                     {
                         free( p_seekpoint->psz_name );

   ...",9,,418,2,,void
53759,BLOCK,-1,,"{
                 seekpoint_t *p_seekpoint;
                 char backup;
                 psz_start++;
                 psz_end = strchr( psz_start, '}' );
                 if( !psz_end ) break;
                 psz_parser = psz_end + 1;
                 backup = *psz_parser;
                 *psz_parser = 0;
                 *psz_end = ',';

                 p_seekpoint = vlc_seekpoint_New();

                 if( unlikely( p_seekpoint == NULL ) )
                     break;

                 while( (psz_end = strchr( psz_start, ',' ) ) )
                 {
                     *psz_end = 0;
                     if( !strncmp( psz_start, ""name="", 5 ) )
                     {
                         free( p_seekpoint->psz_name );

                         p_seekpoint->psz_name = strdup(psz_start + 5);
                     }
                     else if( !strncmp( psz_start, ""time="", 5 ) )
                     {
                         p_seekpoint->i_time_offset = atof(psz_start +...",13,,423,2,,void
53772,BLOCK,-1,,<empty>,33,,428,2,,void
53799,BLOCK,-1,,<empty>,22,,437,2,,void
53807,BLOCK,-1,,"{
                     *psz_end = 0;
                     if( !strncmp( psz_start, ""name="", 5 ) )
                     {
                         free( p_seekpoint->psz_name );

                         p_seekpoint->psz_name = strdup(psz_start + 5);
                     }
                     else if( !strncmp( psz_start, ""time="", 5 ) )
                     {
                         p_seekpoint->i_time_offset = atof(psz_start + 5) *
                                                        CLOCK_FREQ;
                     }
                     psz_start = psz_end + 1;
                }",18,,440,2,,void
53818,BLOCK,-1,,"{
                         free( p_seekpoint->psz_name );

                         p_seekpoint->psz_name = strdup(psz_start + 5);
                     }",22,,443,2,,void
53832,BLOCK,-1,,<empty>,27,,448,1,,void
53839,BLOCK,-1,,"{
                         p_seekpoint->i_time_offset = atof(psz_start + 5) *
                                                        CLOCK_FREQ;
                     }",22,,449,2,,void
53916,BLOCK,-1,,"{
    input_thread_private_t *priv = data;
    input_thread_t *p_input = &priv->input;

    vlc_interrupt_set(&priv->interrupt);

    if( !Init( p_input ) )
    {
        if( priv->b_can_pace_control && priv->b_out_pace_control )
        {
            /* We don't want a high input priority here or we'll
             * end-up sucking up all the CPU time */
            vlc_set_priority( priv->thread, VLC_THREAD_PRIORITY_LOW );
        }

        MainLoop( p_input, true ); /* FIXME it can be wrong (like with VLM) */

        /* Clean up */
        End( p_input );
    }

    input_SendEventDead( p_input );
    return NULL;
}",1,,490,2,,void
53937,BLOCK,-1,,"{
        if( priv->b_can_pace_control && priv->b_out_pace_control )
        {
            /* We don't want a high input priority here or we'll
             * end-up sucking up all the CPU time */
            vlc_set_priority( priv->thread, VLC_THREAD_PRIORITY_LOW );
        }

        MainLoop( p_input, true ); /* FIXME it can be wrong (like with VLM) */

        /* Clean up */
        End( p_input );
    }",5,,497,2,,void
53946,BLOCK,-1,,"{
            /* We don't want a high input priority here or we'll
             * end-up sucking up all the CPU time */
            vlc_set_priority( priv->thread, VLC_THREAD_PRIORITY_LOW );
        }",9,,499,2,,void
53965,BLOCK,-1,,"{
    input_thread_private_t *priv = data;
    input_thread_t *p_input = &priv->input;

    vlc_interrupt_set(&priv->interrupt);

    if( !Init( p_input ) )
    {   /* if the demux is a playlist, call Mainloop that will call
         * demux_Demux in order to fetch sub items */
        bool b_is_playlist = false;

        if ( input_item_ShouldPreparseSubItems( priv->p_item )
          && demux_Control( priv->master->p_demux, DEMUX_IS_PLAYLIST,
                            &b_is_playlist ) )
            b_is_playlist = false;
        if( b_is_playlist )
            MainLoop( p_input, false );
        End( p_input );
    }

    input_SendEventDead( p_input );
    return NULL;
}",1,,516,2,,void
53986,BLOCK,-1,,"{   /* if the demux is a playlist, call Mainloop that will call
         * demux_Demux in order to fetch sub items */
        bool b_is_playlist = false;

        if ( input_item_ShouldPreparseSubItems( priv->p_item )
          && demux_Control( priv->master->p_demux, DEMUX_IS_PLAYLIST,
                            &b_is_playlist ) )
            b_is_playlist = false;
        if( b_is_playlist )
            MainLoop( p_input, false );
        End( p_input );
    }",5,,523,2,,void
54006,BLOCK,-1,,<empty>,13,,530,2,,void
54012,BLOCK,-1,,<empty>,13,,532,2,,void
54026,BLOCK,-1,,"{
    input_thread_private_t *sys = input_priv(input);
    bool ret;

    vlc_mutex_lock( &sys->lock_control );
    ret = sys->is_stopped;
    vlc_mutex_unlock( &sys->lock_control );
    return ret;
}",1,,541,2,,void
54055,BLOCK,-1,,"{
    input_thread_private_t* p_priv = input_priv(p_input);
    demux_t *p_demux = p_priv->master->p_demux;
    int i_ret = VLC_DEMUXER_SUCCESS;

    *pb_changed = false;

    if( p_priv->i_stop > 0 )
    {
        if( demux_Control( p_demux, DEMUX_GET_TIME, &p_priv->i_time ) )
            p_priv->i_time = 0;

        if( p_priv->i_stop <= p_priv->i_time )
            i_ret = VLC_DEMUXER_EOF;
    }

    if( i_ret == VLC_DEMUXER_SUCCESS )
        i_ret = demux_Demux( p_demux );

    i_ret = i_ret > 0 ? VLC_DEMUXER_SUCCESS : ( i_ret < 0 ? VLC_DEMUXER_EGENERIC : VLC_DEMUXER_EOF);

    if( i_ret == VLC_DEMUXER_SUCCESS )
    {
        if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE_LIST ) )
            UpdateTitleListfromDemux( p_input );

        if( p_priv->master->b_title_demux )
        {
            i_ret = UpdateTitleSeekpointFromDemux( p_input );
            *pb_changed = true;
        }

        UpdateGenericFromDemux( p_input );
    }

    if( i_ret == VLC_DEMUXER_EOF )...",1,,560,3,,void
54083,BLOCK,-1,,"{
        if( demux_Control( p_demux, DEMUX_GET_TIME, &p_priv->i_time ) )
            p_priv->i_time = 0;

        if( p_priv->i_stop <= p_priv->i_time )
            i_ret = VLC_DEMUXER_EOF;
    }",5,,568,2,,void
54092,BLOCK,-1,,<empty>,13,,570,2,,void
54106,BLOCK,-1,,<empty>,13,,573,2,,void
54114,BLOCK,-1,,<empty>,9,,577,2,,void
54136,BLOCK,-1,,"{
        if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE_LIST ) )
            UpdateTitleListfromDemux( p_input );

        if( p_priv->master->b_title_demux )
        {
            i_ret = UpdateTitleSeekpointFromDemux( p_input );
            *pb_changed = true;
        }

        UpdateGenericFromDemux( p_input );
    }",5,,582,2,,void
54141,BLOCK,-1,,<empty>,13,,584,2,,void
54150,BLOCK,-1,,"{
            i_ret = UpdateTitleSeekpointFromDemux( p_input );
            *pb_changed = true;
        }",9,,587,2,,void
54165,BLOCK,-1,,"{
        msg_Dbg( p_input, ""EOF reached"" );
        p_priv->master->b_eof = true;
        es_out_Eos(p_priv->p_es_out);
    }",5,,596,2,,void
54181,BLOCK,-1,,<empty>,10,,601,1,,void
54186,BLOCK,-1,,"{
        input_ChangeState( p_input, ERROR_S );
    }",5,,602,2,,void
54191,BLOCK,-1,,<empty>,10,,605,1,,void
54198,BLOCK,-1,,<empty>,9,,606,2,,void
54205,BLOCK,-1,,"{
    int i_repeat = var_GetInteger( p_input, ""input-repeat"" );
    if( i_repeat <= 0 )
        return VLC_EGENERIC;

    vlc_value_t val;

    msg_Dbg( p_input, ""repeating the same input (%d)"", i_repeat );
    if( i_repeat > 0 )
    {
        i_repeat--;
        var_SetInteger( p_input, ""input-repeat"", i_repeat );
    }

    /* Seek to start title/seekpoint */
    val.i_int = input_priv(p_input)->master->i_title_start -
        input_priv(p_input)->master->i_title_offset;
    if( val.i_int < 0 || val.i_int >= input_priv(p_input)->master->i_title )
        val.i_int = 0;
    input_ControlPush( p_input,
                       INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = input_priv(p_input)->master->i_seekpoint_start -
        input_priv(p_input)->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input,
                           INPUT_CONTROL_SET_SEEKPOINT, &val );

    /* Seek to start position */
    if( input_pri...",1,,610,2,,void
54216,BLOCK,-1,,<empty>,9,,613,2,,void
54228,BLOCK,-1,,"{
        i_repeat--;
        var_SetInteger( p_input, ""input-repeat"", i_repeat );
    }",5,,619,2,,void
54269,BLOCK,-1,,<empty>,9,,628,2,,void
54303,BLOCK,-1,,<empty>,9,,635,2,,void
54316,BLOCK,-1,,"{
        val.i_int = input_priv(p_input)->i_start;
        input_ControlPush( p_input, INPUT_CONTROL_SET_TIME, &val );
    }",5,,640,2,,void
54331,BLOCK,-1,,"{
        val.f_float = 0.f;
        input_ControlPush( p_input, INPUT_CONTROL_SET_POSITION, &val );
    }",5,,645,1,,void
54348,BLOCK,-1,,"{
    double f_position = 0.0;
    mtime_t i_time = 0;
    mtime_t i_length = 0;

    /* update input status variables */
    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_POSITION, &f_position ) )
        f_position = 0.0;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_TIME, &i_time ) )
        i_time = 0;
    input_priv(p_input)->i_time = i_time;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_LENGTH, &i_length ) )
        i_length = 0;

    es_out_SetTimes( input_priv(p_input)->p_es_out, f_position, i_time, i_length );

    /* update current bookmark */
    vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
    input_priv(p_input)->bookmark.i_time_offset = i_time;
    vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );

    stats_ComputeInputStats( p_input, input_priv(p_input)->p_item->p_stats );
    input_SendEventStatistics( p_input );
}",1,,657,2,,void
54372,BLOCK,-1,,<empty>,9,,665,2,,void
54387,BLOCK,-1,,<empty>,9,,669,2,,void
54408,BLOCK,-1,,<empty>,9,,674,2,,void
54459,BLOCK,-1,,"{
    mtime_t i_intf_update = 0;
    mtime_t i_last_seek_mdate = 0;

    if( b_interactive && var_InheritBool( p_input, ""start-paused"" ) )
        ControlPause( p_input, mdate() );

    bool b_pause_after_eof = b_interactive &&
                           var_InheritBool( p_input, ""play-and-pause"" );
    bool b_paused_at_eof = false;

    demux_t *p_demux = input_priv(p_input)->master->p_demux;
    const bool b_can_demux = p_demux->pf_demux != NULL;

    while( !input_Stopped( p_input ) && input_priv(p_input)->i_state != ERROR_S )
    {
        mtime_t i_wakeup = -1;
        bool b_paused = input_priv(p_input)->i_state == PAUSE_S;
        /* FIXME if input_priv(p_input)->i_state == PAUSE_S the access/access_demux
         * is paused -> this may cause problem with some of them
         * The same problem can be seen when seeking while paused */
        if( b_paused )
            b_paused = !es_out_GetBuffering( input_priv(p_input)->p_es_out )
                    || input_priv(p_input...",1,,692,3,,void
54474,BLOCK,-1,,<empty>,9,,697,2,,void
54518,BLOCK,-1,,"{
        mtime_t i_wakeup = -1;
        bool b_paused = input_priv(p_input)->i_state == PAUSE_S;
        /* FIXME if input_priv(p_input)->i_state == PAUSE_S the access/access_demux
         * is paused -> this may cause problem with some of them
         * The same problem can be seen when seeking while paused */
        if( b_paused )
            b_paused = !es_out_GetBuffering( input_priv(p_input)->p_es_out )
                    || input_priv(p_input)->master->b_eof;

        if( !b_paused )
        {
            if( !input_priv(p_input)->master->b_eof )
            {
                bool b_force_update = false;

                MainLoopDemux( p_input, &b_force_update );

                if( b_can_demux )
                    i_wakeup = es_out_GetWakeup( input_priv(p_input)->p_es_out );
                if( b_force_update )
                    i_intf_update = 0;

                b_paused_at_eof = false;
            }
            else if( !es_out_GetEmpty( input_priv(p_input)->p_es_...",5,,707,2,,void
54535,BLOCK,-1,,<empty>,13,,714,2,,void
54554,BLOCK,-1,,"{
            if( !input_priv(p_input)->master->b_eof )
            {
                bool b_force_update = false;

                MainLoopDemux( p_input, &b_force_update );

                if( b_can_demux )
                    i_wakeup = es_out_GetWakeup( input_priv(p_input)->p_es_out );
                if( b_force_update )
                    i_intf_update = 0;

                b_paused_at_eof = false;
            }
            else if( !es_out_GetEmpty( input_priv(p_input)->p_es_out ) )
            {
                msg_Dbg( p_input, ""waiting decoder fifos to empty"" );
                i_wakeup = mdate() + INPUT_IDLE_SLEEP;
            }
            /* Pause after eof only if the input is pausable.
             * This way we won't trigger timeshifting for nothing */
            else if( b_pause_after_eof && input_priv(p_input)->b_can_pause )
            {
                if( b_paused_at_eof )
                    break;

                vlc_value_t val = { .i_int = PAUSE_S };

  ...",9,,718,2,,void
54563,BLOCK,-1,,"{
                bool b_force_update = false;

                MainLoopDemux( p_input, &b_force_update );

                if( b_can_demux )
                    i_wakeup = es_out_GetWakeup( input_priv(p_input)->p_es_out );
                if( b_force_update )
                    i_intf_update = 0;

                b_paused_at_eof = false;
            }",13,,720,2,,void
54574,BLOCK,-1,,<empty>,21,,726,2,,void
54584,BLOCK,-1,,<empty>,21,,728,2,,void
54592,BLOCK,-1,,<empty>,18,,732,1,,void
54600,BLOCK,-1,,"{
                msg_Dbg( p_input, ""waiting decoder fifos to empty"" );
                i_wakeup = mdate() + INPUT_IDLE_SLEEP;
            }",13,,733,2,,void
54610,BLOCK,-1,,<empty>,18,,739,1,,void
54618,BLOCK,-1,,"{
                if( b_paused_at_eof )
                    break;

                vlc_value_t val = { .i_int = PAUSE_S };

                msg_Dbg( p_input, ""pausing at EOF (pause after each)"");
                Control( p_input, INPUT_CONTROL_SET_STATE, val );

                b_paused = true;
                b_paused_at_eof = true;
            }",13,,740,2,,void
54621,BLOCK,-1,,<empty>,21,,742,2,,void
54627,BLOCK,1,,<empty>,37,,744,1,,void
54645,BLOCK,-1,,"{
                if( MainLoopTryRepeat( p_input ) )
                    break;
            }",13,,753,1,,void
54649,BLOCK,-1,,<empty>,21,,755,2,,void
54659,BLOCK,-1,,"{
                MainLoopStatistics( p_input );
                i_intf_update = now + INT64_C(250000);
            }",13,,761,2,,void
54669,BLOCK,-1,,<empty>,9,,768,1,,void
54670,BLOCK,4,,"{
            mtime_t i_deadline = i_wakeup;

            /* Postpone seeking until ES buffering is complete or at most
             * 125 ms. */
            bool b_postpone = es_out_GetBuffering( input_priv(p_input)->p_es_out )
                            && !input_priv(p_input)->master->b_eof;
            if( b_postpone )
            {
                mtime_t now = mdate();

                /* Recheck ES buffer level every 20 ms when seeking */
                if( now < i_last_seek_mdate + INT64_C(125000)
                 && (i_deadline < 0 || i_deadline > now + INT64_C(20000)) )
                    i_deadline = now + INT64_C(20000);
                else
                    b_postpone = false;
            }

            int i_type;
            vlc_value_t val;

            if( ControlPop( p_input, &i_type, &val, i_deadline, b_postpone ) )
            {
                if( b_postpone )
                    continue;
                break; /* Wake-up time reached */
            }

#i...",9,,769,4,,void
54693,BLOCK,-1,,"{
                mtime_t now = mdate();

                /* Recheck ES buffer level every 20 ms when seeking */
                if( now < i_last_seek_mdate + INT64_C(125000)
                 && (i_deadline < 0 || i_deadline > now + INT64_C(20000)) )
                    i_deadline = now + INT64_C(20000);
                else
                    b_postpone = false;
            }",13,,777,2,,void
54716,BLOCK,-1,,<empty>,21,,783,2,,void
54724,BLOCK,-1,,<empty>,21,,785,1,,void
54739,BLOCK,-1,,"{
                if( b_postpone )
                    continue;
                break; /* Wake-up time reached */
            }",13,,792,2,,void
54742,BLOCK,-1,,<empty>,21,,794,2,,void
54754,BLOCK,-1,,"{
                if( ControlIsSeekRequest( i_type ) )
                    i_last_seek_mdate = mdate();
                i_intf_update = 0;
            }",13,,802,2,,void
54758,BLOCK,-1,,<empty>,21,,804,2,,void
54769,BLOCK,-1,,<empty>,17,,810,2,,void
54781,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);

    if( priv->b_preparsing ) return;

    /* Prepare statistics */
#define INIT_COUNTER( c, compute ) free( priv->counters.p_##c ); \
    priv->counters.p_##c = \
 stats_CounterCreate( STATS_##compute);
    if( libvlc_stats( p_input ) )
    {
        INIT_COUNTER( read_bytes, COUNTER );
        INIT_COUNTER( read_packets, COUNTER );
        INIT_COUNTER( demux_read, COUNTER );
        INIT_COUNTER( input_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_corrupted, COUNTER );
        INIT_COUNTER( demux_discontinuity, COUNTER );
        INIT_COUNTER( played_abuffers, COUNTER );
        INIT_COUNTER( lost_abuffers, COUNTER );
        INIT_COUNTER( displayed_pictures, COUNTER );
        INIT_COUNTER( lost_pictures, COUNTER );
        INIT_COUNTER( decoded_audio, COUNTER );
        INIT_COUNTER( decoded_video, COUNTER );
        INIT_COUNTER( decoded_sub, COUNTER );
        pri...",1,,816,2,,void
54791,BLOCK,-1,,<empty>,30,,819,2,,void
54796,BLOCK,-1,,"{
        INIT_COUNTER( read_bytes, COUNTER );
        INIT_COUNTER( read_packets, COUNTER );
        INIT_COUNTER( demux_read, COUNTER );
        INIT_COUNTER( input_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_corrupted, COUNTER );
        INIT_COUNTER( demux_discontinuity, COUNTER );
        INIT_COUNTER( played_abuffers, COUNTER );
        INIT_COUNTER( lost_abuffers, COUNTER );
        INIT_COUNTER( displayed_pictures, COUNTER );
        INIT_COUNTER( lost_pictures, COUNTER );
        INIT_COUNTER( decoded_audio, COUNTER );
        INIT_COUNTER( decoded_video, COUNTER );
        INIT_COUNTER( decoded_sub, COUNTER );
        priv->counters.p_sout_send_bitrate = NULL;
        priv->counters.p_sout_sent_packets = NULL;
        priv->counters.p_sout_sent_bytes = NULL;
    }",5,,826,2,,void
54798,BLOCK,1,,<empty>,,,,2,,void
54814,BLOCK,1,,<empty>,,,,2,,void
54830,BLOCK,1,,<empty>,,,,2,,void
54846,BLOCK,1,,<empty>,,,,2,,void
54862,BLOCK,1,,<empty>,,,,2,,void
54878,BLOCK,1,,<empty>,,,,2,,void
54894,BLOCK,1,,<empty>,,,,2,,void
54910,BLOCK,1,,<empty>,,,,2,,void
54926,BLOCK,1,,<empty>,,,,2,,void
54942,BLOCK,1,,<empty>,,,,2,,void
54958,BLOCK,1,,<empty>,,,,2,,void
54974,BLOCK,1,,<empty>,,,,2,,void
54990,BLOCK,1,,<empty>,,,,2,,void
55006,BLOCK,1,,<empty>,,,,2,,void
55046,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *p_master = priv->master;

    if( priv->b_preparsing )
        return;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Create global title (from master) */
    priv->i_title = p_master->i_title;
    priv->title   = p_master->title;
    priv->i_title_offset = p_master->i_title_offset;
    priv->i_seekpoint_offset = p_master->i_seekpoint_offset;
    if( priv->i_title > 0 )
    {
        /* Setup variables */
        input_ControlVarNavigation( p_input );
        input_SendEventTitle( p_input, 0 );
    }

    /* Global flag */
    priv->b_can_pace_control = p_master->b_can_pace_control;
    priv->b_can_pause        = p_master->b_can_pause;
    priv->b_can_rate_control = p_master->b_can_rate_control;
    vlc_mutex_unlock( &priv->p_item->lock );
}",1,,899,2,,void
55062,BLOCK,-1,,<empty>,9,,904,2,,void
55105,BLOCK,-1,,"{
        /* Setup variables */
        input_ControlVarNavigation( p_input );
        input_SendEventTitle( p_input, 0 );
    }",5,,913,2,,void
55143,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    vlc_value_t val;

    /* Start title/chapter */
    val.i_int = priv->master->i_title_start - priv->master->i_title_offset;
    if( val.i_int > 0 && val.i_int < priv->master->i_title )
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = priv->master->i_seekpoint_start -
                priv->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &val );

    /* Start/stop/run time */
    priv->i_start = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""start-time"" ));
    priv->i_stop  = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""stop-time"" ));
    if( priv->i_stop <= 0 )
    {
        priv->i_stop = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""run-time"" ));
        if( priv->i_stop < 0 )
...",1,,927,2,,void
55181,BLOCK,-1,,<empty>,9,,934,2,,void
55208,BLOCK,-1,,<empty>,9,,939,2,,void
55240,BLOCK,-1,,"{
        priv->i_stop = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""run-time"" ));
        if( priv->i_stop < 0 )
        {
            msg_Warn( p_input, ""invalid run-time ignored"" );
            priv->i_stop = 0;
        }
        else
            priv->i_stop += priv->i_start;
    }",5,,947,2,,void
55257,BLOCK,-1,,"{
            msg_Warn( p_input, ""invalid run-time ignored"" );
            priv->i_stop = 0;
        }",9,,951,2,,void
55267,BLOCK,-1,,<empty>,13,,956,1,,void
55281,BLOCK,-1,,"{
        vlc_value_t s;

        msg_Dbg( p_input, ""starting at time: %""PRId64""s"",
                 priv->i_start / CLOCK_FREQ );

        s.i_int = priv->i_start;
        input_ControlPush( p_input, INPUT_CONTROL_SET_TIME, &s );
    }",5,,960,2,,void
55310,BLOCK,-1,,"{
        msg_Warn( p_input, ""invalid stop-time ignored"" );
        priv->i_stop = 0;
    }",5,,970,2,,void
55331,BLOCK,-1,,"{
    const input_item_slave_t *p_slave0 = *((const input_item_slave_t **) a);
    const input_item_slave_t *p_slave1 = *((const input_item_slave_t **) b);

    if( p_slave0 == NULL || p_slave1 == NULL )
    {
        /* Put NULL (or rejected) subs at the end */
        return p_slave0 == NULL ? 1 : p_slave1 == NULL ? -1 : 0;
    }

    if( p_slave0->i_priority > p_slave1->i_priority )
        return -1;

    if( p_slave0->i_priority < p_slave1->i_priority )
        return 1;

    return 0;
}",1,,978,3,,void
55354,BLOCK,-1,,"{
        /* Put NULL (or rejected) subs at the end */
        return p_slave0 == NULL ? 1 : p_slave1 == NULL ? -1 : 0;
    }",5,,983,2,,void
55376,BLOCK,-1,,<empty>,9,,989,2,,void
55388,BLOCK,-1,,<empty>,9,,992,2,,void
55399,BLOCK,-1,,"{
    for( int i = 0; i < i_slaves; i++ )
    {
        if( pp_slaves[i] != NULL
         && !strcmp( pp_slaves[i]->psz_uri, psz_uri ) )
            return true;
    }
    return false;
}",1,,999,4,,void
55401,BLOCK,-1,,<empty>,5,,1000,1,,void
55411,BLOCK,4,,"{
        if( pp_slaves[i] != NULL
         && !strcmp( pp_slaves[i]->psz_uri, psz_uri ) )
            return true;
    }",5,,1001,4,,void
55427,BLOCK,-1,,<empty>,13,,1004,2,,void
55436,BLOCK,-1,,"{
    /* Get fps and set it if not already set */
    const float f_fps = input_priv(p_input)->master->f_fps;
    if( f_fps > 1.f )
    {
        var_Create( p_input, ""sub-original-fps"", VLC_VAR_FLOAT );
        var_SetFloat( p_input, ""sub-original-fps"", f_fps );

        float f_requested_fps = var_CreateGetFloat( p_input, ""sub-fps"" );
        if( f_requested_fps != f_fps )
        {
            var_Create( p_input, ""sub-fps"", VLC_VAR_FLOAT|
                                            VLC_VAR_DOINHERIT );
            var_SetFloat( p_input, ""sub-fps"", f_requested_fps );
        }
    }

    const int i_delay = var_CreateGetInteger( p_input, ""sub-delay"" );
    if( i_delay != 0 )
        var_SetInteger( p_input, ""spu-delay"", (mtime_t)i_delay * 100000 );
}",1,,1010,2,,void
55450,BLOCK,-1,,"{
        var_Create( p_input, ""sub-original-fps"", VLC_VAR_FLOAT );
        var_SetFloat( p_input, ""sub-original-fps"", f_fps );

        float f_requested_fps = var_CreateGetFloat( p_input, ""sub-fps"" );
        if( f_requested_fps != f_fps )
        {
            var_Create( p_input, ""sub-fps"", VLC_VAR_FLOAT|
                                            VLC_VAR_DOINHERIT );
            var_SetFloat( p_input, ""sub-fps"", f_requested_fps );
        }
    }",5,,1014,2,,void
55469,BLOCK,-1,,"{
            var_Create( p_input, ""sub-fps"", VLC_VAR_FLOAT|
                                            VLC_VAR_DOINHERIT );
            var_SetFloat( p_input, ""sub-fps"", f_requested_fps );
        }",9,,1020,2,,void
55490,BLOCK,-1,,<empty>,9,,1029,2,,void
55504,BLOCK,-1,,"{
    vlc_url_t parsed_uri;
    if( vlc_UrlParse( &parsed_uri, psz_uri ) != VLC_SUCCESS ||
        parsed_uri.psz_path == NULL )
    {
        goto fail;
    }

    enum slave_type i_type;
    if( !input_item_slave_GetType( parsed_uri.psz_path, &i_type ) )
        goto fail;

    vlc_UrlClean( &parsed_uri );
    return i_type;

fail:
    msg_Dbg( p_input, ""Can't deduce slave type of \""%s\"" with file extension."",
             psz_uri );
    vlc_UrlClean( &parsed_uri );
    return SLAVE_TYPE_AUDIO;
}",1,,1034,3,,void
55519,BLOCK,-1,,"{
        goto fail;
    }",5,,1038,2,,void
55530,BLOCK,-1,,<empty>,9,,1044,2,,void
55553,BLOCK,-1,,"{
    char *psz = var_GetNonEmptyString( p_input, ""input-slave"" );
    if( !psz )
        return;

    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;

    char *psz_org = psz;
    while( psz && *psz )
    {
        while( *psz == ' ' || *psz == '#' )
            psz++;

        char *psz_delim = strchr( psz, '#' );
        if( psz_delim )
            *psz_delim++ = '\0';

        if( *psz == 0 )
            break;

        char *uri = strstr(psz, ""://"")
                                   ? strdup( psz ) : vlc_path2uri( psz, NULL );
        psz = psz_delim;
        if( uri == NULL )
            continue;

        const enum slave_type i_type = DeduceSlaveType( p_input, uri );
        input_item_slave_t *p_slave =
            input_item_slave_New( uri, i_type, SLAVE_PRIORITY_USER );
        free( uri );

        if( unlikely( p_slave == NULL ) )
            break;
        TAB_APPEND(i_slaves, pp_slaves, p_slave);
    }
    free( psz_org );

    *ppp_slaves...",1,,1058,4,,void
55563,BLOCK,-1,,<empty>,9,,1061,2,,void
55584,BLOCK,-1,,"{
        while( *psz == ' ' || *psz == '#' )
            psz++;

        char *psz_delim = strchr( psz, '#' );
        if( psz_delim )
            *psz_delim++ = '\0';

        if( *psz == 0 )
            break;

        char *uri = strstr(psz, ""://"")
                                   ? strdup( psz ) : vlc_path2uri( psz, NULL );
        psz = psz_delim;
        if( uri == NULL )
            continue;

        const enum slave_type i_type = DeduceSlaveType( p_input, uri );
        input_item_slave_t *p_slave =
            input_item_slave_New( uri, i_type, SLAVE_PRIORITY_USER );
        free( uri );

        if( unlikely( p_slave == NULL ) )
            break;
        TAB_APPEND(i_slaves, pp_slaves, p_slave);
    }",5,,1068,2,,void
55605,BLOCK,-1,,<empty>,13,,1074,2,,void
55616,BLOCK,-1,,<empty>,13,,1077,2,,void
55637,BLOCK,-1,,<empty>,13,,1083,2,,void
55659,BLOCK,-1,,<empty>,13,,1091,2,,void
55679,BLOCK,-1,,"{
    input_item_slave_t **pp_slaves;
    int i_slaves;
    TAB_INIT( i_slaves, pp_slaves );

    /* Look for and add slaves */

    char *psz_subtitle = var_GetNonEmptyString( p_input, ""sub-file"" );
    if( psz_subtitle != NULL )
    {
        msg_Dbg( p_input, ""forced subtitle: %s"", psz_subtitle );
        char *psz_uri = input_SubtitleFile2Uri( p_input, psz_subtitle );
        free( psz_subtitle );
        psz_subtitle = NULL;
        if( psz_uri != NULL )
        {
            input_item_slave_t *p_slave =
                input_item_slave_New( psz_uri, SLAVE_TYPE_SPU,
                                      SLAVE_PRIORITY_USER );
            free( psz_uri );
            if( p_slave )
            {
                TAB_APPEND(i_slaves, pp_slaves, p_slave);
                psz_subtitle = p_slave->psz_uri;
            }
        }
    }

    if( var_GetBool( p_input, ""sub-autodetect-file"" ) )
    {
        /* Add local subtitles */
        char *psz_autopath = var_GetNonEmptyString( p_...",1,,1101,2,,void
55695,BLOCK,-1,,"{
        msg_Dbg( p_input, ""forced subtitle: %s"", psz_subtitle );
        char *psz_uri = input_SubtitleFile2Uri( p_input, psz_subtitle );
        free( psz_subtitle );
        psz_subtitle = NULL;
        if( psz_uri != NULL )
        {
            input_item_slave_t *p_slave =
                input_item_slave_New( psz_uri, SLAVE_TYPE_SPU,
                                      SLAVE_PRIORITY_USER );
            free( psz_uri );
            if( p_slave )
            {
                TAB_APPEND(i_slaves, pp_slaves, p_slave);
                psz_subtitle = p_slave->psz_uri;
            }
        }
    }",5,,1110,2,,void
55715,BLOCK,-1,,"{
            input_item_slave_t *p_slave =
                input_item_slave_New( psz_uri, SLAVE_TYPE_SPU,
                                      SLAVE_PRIORITY_USER );
            free( psz_uri );
            if( p_slave )
            {
                TAB_APPEND(i_slaves, pp_slaves, p_slave);
                psz_subtitle = p_slave->psz_uri;
            }
        }",9,,1116,2,,void
55727,BLOCK,-1,,"{
                TAB_APPEND(i_slaves, pp_slaves, p_slave);
                psz_subtitle = p_slave->psz_uri;
            }",13,,1122,2,,void
55741,BLOCK,-1,,"{
        /* Add local subtitles */
        char *psz_autopath = var_GetNonEmptyString( p_input, ""sub-autodetect-path"" );

        if( subtitles_Detect( p_input, psz_autopath, input_priv(p_input)->p_item->psz_uri,
                              &pp_slaves, &i_slaves ) == VLC_SUCCESS )
        {
            /* check that we did not add the subtitle through sub-file */
            if( psz_subtitle != NULL )
            {
                for( int i = 1; i < i_slaves; i++ )
                {
                    input_item_slave_t *p_curr = pp_slaves[i];
                    if( p_curr != NULL
                     && !strcmp( psz_subtitle, p_curr->psz_uri ) )
                    {
                        /* reject current sub */
                        input_item_slave_Delete( p_curr );
                        pp_slaves[i] = NULL;
                    }
                }
            }
        }
        free( psz_autopath );
    }",5,,1130,2,,void
55764,BLOCK,-1,,"{
            /* check that we did not add the subtitle through sub-file */
            if( psz_subtitle != NULL )
            {
                for( int i = 1; i < i_slaves; i++ )
                {
                    input_item_slave_t *p_curr = pp_slaves[i];
                    if( p_curr != NULL
                     && !strcmp( psz_subtitle, p_curr->psz_uri ) )
                    {
                        /* reject current sub */
                        input_item_slave_Delete( p_curr );
                        pp_slaves[i] = NULL;
                    }
                }
            }
        }",9,,1136,2,,void
55769,BLOCK,-1,,"{
                for( int i = 1; i < i_slaves; i++ )
                {
                    input_item_slave_t *p_curr = pp_slaves[i];
                    if( p_curr != NULL
                     && !strcmp( psz_subtitle, p_curr->psz_uri ) )
                    {
                        /* reject current sub */
                        input_item_slave_Delete( p_curr );
                        pp_slaves[i] = NULL;
                    }
                }
            }",13,,1139,2,,void
55771,BLOCK,-1,,<empty>,17,,1140,1,,void
55781,BLOCK,4,,"{
                    input_item_slave_t *p_curr = pp_slaves[i];
                    if( p_curr != NULL
                     && !strcmp( psz_subtitle, p_curr->psz_uri ) )
                    {
                        /* reject current sub */
                        input_item_slave_Delete( p_curr );
                        pp_slaves[i] = NULL;
                    }
                }",17,,1141,4,,void
55799,BLOCK,-1,,"{
                        /* reject current sub */
                        input_item_slave_Delete( p_curr );
                        pp_slaves[i] = NULL;
                    }",21,,1145,2,,void
55828,BLOCK,-1,,<empty>,5,,1164,1,,void
55840,BLOCK,4,,"{
        input_item_slave_t *p_slave = p_item->pp_slaves[i];
        if( !SlaveExists( pp_slaves, i_slaves, p_slave->psz_uri ) )
            TAB_APPEND(i_slaves, pp_slaves, p_slave);
        else
            input_item_slave_Delete( p_slave );
    }",5,,1165,4,,void
55857,BLOCK,-1,,<empty>,13,,1168,2,,void
55863,BLOCK,-1,,<empty>,13,,1170,1,,void
55882,BLOCK,-1,,<empty>,9,,1177,2,,void
55905,BLOCK,-1,,<empty>,5,,1184,1,,void
55921,BLOCK,4,,"{
        input_item_slave_t *p_slave = pp_slaves[i];
        /* Slaves added via options should not fail */
        unsigned i_flags = p_slave->i_priority != SLAVE_PRIORITY_USER
                           ? SLAVE_ADD_CANFAIL : SLAVE_ADD_NOFLAG;
        bool b_forced = false;

        /* Force the first subtitle with the highest priority or with the
         * forced flag */
        if( !p_forced[p_slave->i_type]
         && ( p_slave->b_forced || p_slave->i_priority == SLAVE_PRIORITY_USER ) )
        {
            i_flags |= SLAVE_ADD_FORCED;
            b_forced = true;
        }

        if( input_SlaveSourceAdd( p_input, p_slave->i_type, p_slave->psz_uri,
                                  i_flags ) == VLC_SUCCESS )
        {
            input_item_AddSlave( input_priv(p_input)->p_item, p_slave );
            if( b_forced )
                p_forced[p_slave->i_type] = true;
        }
        else
            input_item_slave_Delete( p_slave );
    }",5,,1185,4,,void
55938,BLOCK,1,,<empty>,,,,1,,void
55943,BLOCK,1,,<empty>,,,,1,,void
55966,BLOCK,-1,,"{
            i_flags |= SLAVE_ADD_FORCED;
            b_forced = true;
        }",9,,1196,2,,void
55970,BLOCK,1,,<empty>,,,,1,,void
55989,BLOCK,-1,,"{
            input_item_AddSlave( input_priv(p_input)->p_item, p_slave );
            if( b_forced )
                p_forced[p_slave->i_type] = true;
        }",9,,1203,2,,void
55998,BLOCK,-1,,<empty>,17,,1206,2,,void
56007,BLOCK,-1,,<empty>,13,,1209,1,,void
56030,BLOCK,-1,,<empty>,5,,1218,1,,void
56043,BLOCK,4,,"{
        const input_attachment_t *a = input_priv(p_input)->attachment[i];
        if( !strcmp( a->psz_mime, ""application/x-srt"" ) )
            TAB_APPEND( i_attachment, pp_attachment,
                        vlc_input_attachment_New( a->psz_name, NULL,
                                                  a->psz_description, NULL, 0 ) );
    }",5,,1219,4,,void
56060,BLOCK,-1,,<empty>,13,,1222,2,,void
56086,BLOCK,-1,,<empty>,9,,1229,2,,void
56092,BLOCK,-1,,<empty>,5,,1230,1,,void
56102,BLOCK,4,,"{
        input_attachment_t *a = pp_attachment[i];
        if( !a )
            continue;
        char *psz_mrl;
        if( a->psz_name[0] &&
            asprintf( &psz_mrl, ""attachment://%s"", a->psz_name ) >= 0 )
        {
            var_SetString( p_input, ""sub-description"", a->psz_description ? a->psz_description : """");

            /* Force the first subtitle from attachment if there is no
             * subtitles already forced */
            if( input_SlaveSourceAdd( p_input, SLAVE_TYPE_SPU, psz_mrl,
                                      p_forced[ SLAVE_TYPE_SPU ] ?
                                      SLAVE_ADD_NOFLAG : SLAVE_ADD_FORCED ) == VLC_SUCCESS )
                p_forced[ SLAVE_TYPE_SPU ] = true;

            free( psz_mrl );
            /* Don't update item slaves for attachements */
        }
        vlc_input_attachment_Delete( a );
    }",5,,1231,4,,void
56112,BLOCK,-1,,<empty>,13,,1234,2,,void
56131,BLOCK,-1,,"{
            var_SetString( p_input, ""sub-description"", a->psz_description ? a->psz_description : """");

            /* Force the first subtitle from attachment if there is no
             * subtitles already forced */
            if( input_SlaveSourceAdd( p_input, SLAVE_TYPE_SPU, psz_mrl,
                                      p_forced[ SLAVE_TYPE_SPU ] ?
                                      SLAVE_ADD_NOFLAG : SLAVE_ADD_FORCED ) == VLC_SUCCESS )
                p_forced[ SLAVE_TYPE_SPU ] = true;

            free( psz_mrl );
            /* Don't update item slaves for attachements */
        }",9,,1238,2,,void
56154,BLOCK,1,,<empty>,,,,1,,void
56157,BLOCK,1,,<empty>,,,,1,,void
56162,BLOCK,-1,,<empty>,17,,1246,2,,void
56178,BLOCK,-1,,<empty>,9,,1255,2,,void
56186,BLOCK,-1,,"{
    input_thread_private_t *p_sys = input_priv(p_input);

    /* Get max pts delay from input source */
    mtime_t i_pts_delay = p_sys->master->i_pts_delay;
    for( int i = 0; i < p_sys->i_slave; i++ )
        i_pts_delay = __MAX( i_pts_delay, p_sys->slave[i]->i_pts_delay );

    if( i_pts_delay < 0 )
        i_pts_delay = 0;

    /* Take care of audio/spu delay */
    const mtime_t i_audio_delay = var_GetInteger( p_input, ""audio-delay"" );
    const mtime_t i_spu_delay   = var_GetInteger( p_input, ""spu-delay"" );
    const mtime_t i_extra_delay = __MIN( i_audio_delay, i_spu_delay );
    if( i_extra_delay < 0 )
        i_pts_delay -= i_extra_delay;

    /* Update cr_average depending on the caching */
    const int i_cr_average = var_GetInteger( p_input, ""cr-average"" ) * i_pts_delay / DEFAULT_PTS_DELAY;

    /* */
    es_out_SetDelay( input_priv(p_input)->p_es_out_display, AUDIO_ES, i_audio_delay );
    es_out_SetDelay( input_priv(p_input)->p_es_out_display, SPU_ES, i_spu_delay );...",1,,1259,2,,void
56201,BLOCK,-1,,<empty>,5,,1264,1,,void
56228,BLOCK,-1,,<empty>,9,,1268,2,,void
56254,BLOCK,-1,,<empty>,9,,1275,2,,void
56294,BLOCK,-1,,"{
    int i_es_out_mode;
    vlc_list_t list;

    /* Compute correct pts_delay */
    UpdatePtsDelay( p_input );

    /* Set up es_out */
    i_es_out_mode = ES_OUT_MODE_AUTO;
    if( input_priv(p_input)->p_sout && !input_priv(p_input)->p_renderer )
    {
        char *prgms;

        if( (prgms = var_GetNonEmptyString( p_input, ""programs"" )) != NULL )
        {
            char *buf;

            TAB_INIT( list.i_count, list.p_values );
            for( const char *prgm = strtok_r( prgms, "","", &buf );
                 prgm != NULL;
                 prgm = strtok_r( NULL, "","", &buf ) )
            {
                vlc_value_t val = { .i_int = atoi( prgm ) };
                TAB_APPEND(list.i_count, list.p_values, val);
            }

            if( list.i_count > 0 )
                i_es_out_mode = ES_OUT_MODE_PARTIAL;
                /* Note : we should remove the ""program"" callback. */

            free( prgms );
        }
        else if( var_GetBool( p_input, ""sout-all"" ) )
 ...",1,,1287,2,,void
56313,BLOCK,-1,,"{
        char *prgms;

        if( (prgms = var_GetNonEmptyString( p_input, ""programs"" )) != NULL )
        {
            char *buf;

            TAB_INIT( list.i_count, list.p_values );
            for( const char *prgm = strtok_r( prgms, "","", &buf );
                 prgm != NULL;
                 prgm = strtok_r( NULL, "","", &buf ) )
            {
                vlc_value_t val = { .i_int = atoi( prgm ) };
                TAB_APPEND(list.i_count, list.p_values, val);
            }

            if( list.i_count > 0 )
                i_es_out_mode = ES_OUT_MODE_PARTIAL;
                /* Note : we should remove the ""program"" callback. */

            free( prgms );
        }
        else if( var_GetBool( p_input, ""sout-all"" ) )
        {
            i_es_out_mode = ES_OUT_MODE_ALL;
        }
    }",5,,1297,2,,void
56323,BLOCK,-1,,"{
            char *buf;

            TAB_INIT( list.i_count, list.p_values );
            for( const char *prgm = strtok_r( prgms, "","", &buf );
                 prgm != NULL;
                 prgm = strtok_r( NULL, "","", &buf ) )
            {
                vlc_value_t val = { .i_int = atoi( prgm ) };
                TAB_APPEND(list.i_count, list.p_values, val);
            }

            if( list.i_count > 0 )
                i_es_out_mode = ES_OUT_MODE_PARTIAL;
                /* Note : we should remove the ""program"" callback. */

            free( prgms );
        }",9,,1301,2,,void
56333,BLOCK,-1,,<empty>,13,,1305,1,,void
56352,BLOCK,4,,"{
                vlc_value_t val = { .i_int = atoi( prgm ) };
                TAB_APPEND(list.i_count, list.p_values, val);
            }",13,,1308,4,,void
56357,BLOCK,1,,<empty>,37,,1309,1,,void
56376,BLOCK,-1,,<empty>,17,,1314,2,,void
56383,BLOCK,-1,,<empty>,14,,1319,1,,void
56388,BLOCK,-1,,"{
            i_es_out_mode = ES_OUT_MODE_ALL;
        }",9,,1320,2,,void
56402,BLOCK,-1,,"{
        demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_GROUP, -1, NULL );
    }",5,,1328,2,,void
56415,BLOCK,-1,,<empty>,10,,1331,1,,void
56420,BLOCK,-1,,"{
        demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_GROUP, -1,
                       &list );
        TAB_CLEAN( list.i_count, list.p_values );
    }",5,,1332,2,,void
56441,BLOCK,-1,,"{
        demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_GROUP,
                       es_out_GetGroupForced( input_priv(p_input)->p_es_out ), NULL );
    }",5,,1338,1,,void
56460,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *master;

    if( var_Type( p_input->obj.parent, ""meta-file"" ) )
    {
        msg_Dbg( p_input, ""Input is a meta file: disabling unneeded options"" );
        var_SetString( p_input, ""sout"", """" );
        var_SetBool( p_input, ""sout-all"", false );
        var_SetString( p_input, ""input-slave"", """" );
        var_SetInteger( p_input, ""input-repeat"", 0 );
        var_SetString( p_input, ""sub-file"", """" );
        var_SetBool( p_input, ""sub-autodetect-file"", false );
    }

    InitStatistics( p_input );
#ifdef ENABLE_SOUT
    if( InitSout( p_input ) )
        goto error;
#endif

    /* Create es out */
    priv->p_es_out = input_EsOutTimeshiftNew( p_input, priv->p_es_out_display,
                                              priv->i_rate );
    if( priv->p_es_out == NULL )
        goto error;

    /* */
    input_ChangeState( p_input, OPENING_S );
    input_SendEventCache( p_input, 0.0 );

    /* */
    master ...",1,,1345,2,,void
56475,BLOCK,-1,,"{
        msg_Dbg( p_input, ""Input is a meta file: disabling unneeded options"" );
        var_SetString( p_input, ""sout"", """" );
        var_SetBool( p_input, ""sout-all"", false );
        var_SetString( p_input, ""input-slave"", """" );
        var_SetInteger( p_input, ""input-repeat"", 0 );
        var_SetString( p_input, ""sub-file"", """" );
        var_SetBool( p_input, ""sub-autodetect-file"", false );
    }",5,,1350,2,,void
56523,BLOCK,-1,,<empty>,9,,1370,2,,void
56546,BLOCK,-1,,<empty>,9,,1379,2,,void
56564,BLOCK,-1,,<empty>,9,,1388,2,,void
56572,BLOCK,-1,,<empty>,9,,1390,2,,void
56591,BLOCK,-1,,"{
        StartTitle( p_input );
        SetSubtitlesOptions( p_input );
        LoadSlaves( p_input );
        InitPrograms( p_input );

        double f_rate = var_InheritFloat( p_input, ""rate"" );
        if( f_rate != 0.0 && f_rate != 1.0 )
        {
            vlc_value_t val = { .i_int = INPUT_RATE_DEFAULT / f_rate };
            input_ControlPush( p_input, INPUT_CONTROL_SET_RATE, &val );
        }
    }",5,,1396,2,,void
56614,BLOCK,-1,,"{
            vlc_value_t val = { .i_int = INPUT_RATE_DEFAULT / f_rate };
            input_ControlPush( p_input, INPUT_CONTROL_SET_RATE, &val );
        }",9,,1404,2,,void
56619,BLOCK,1,,<empty>,33,,1405,1,,void
56639,BLOCK,-1,,"{
        priv->b_out_pace_control = priv->p_sout->i_out_pace_nocontrol > 0;

        msg_Dbg( p_input, ""starting in %ssync mode"",
                 priv->b_out_pace_control ? ""a"" : """" );
    }",5,,1411,2,,void
56668,BLOCK,-1,,"{
        /* Get meta data from users */
        InputMetaUser( p_input, p_meta );

        /* Get meta data from master input */
        InputSourceMeta( p_input, master, p_meta );

        /* And from slave */
        for( int i = 0; i < priv->i_slave; i++ )
            InputSourceMeta( p_input, priv->slave[i], p_meta );

        es_out_ControlSetMeta( priv->p_es_out, p_meta );
        vlc_meta_Delete( p_meta );
    }",5,,1420,2,,void
56677,BLOCK,-1,,<empty>,9,,1428,1,,void
56727,BLOCK,-1,,<empty>,9,,1447,2,,void
56744,BLOCK,-1,,"{
        if( input_priv(p_input)->p_sout )
            input_resource_RequestSout( input_priv(p_input)->p_resource,
                                         input_priv(p_input)->p_sout, NULL );
        input_resource_SetInput( input_priv(p_input)->p_resource, NULL );
        if( input_priv(p_input)->p_resource_private )
            input_resource_Terminate( input_priv(p_input)->p_resource_private );
    }",5,,1450,2,,void
56750,BLOCK,-1,,<empty>,13,,1452,2,,void
56772,BLOCK,-1,,<empty>,13,,1456,2,,void
56786,BLOCK,-1,,"{
#define EXIT_COUNTER( c ) do { if( input_priv(p_input)->counters.p_##c ) \
                                   stats_CounterClean( input_priv(p_input)->counters.p_##c );\
                               input_priv(p_input)->counters.p_##c = NULL; } while(0)
        EXIT_COUNTER( read_bytes );
        EXIT_COUNTER( read_packets );
        EXIT_COUNTER( demux_read );
        EXIT_COUNTER( input_bitrate );
        EXIT_COUNTER( demux_bitrate );
        EXIT_COUNTER( demux_corrupted );
        EXIT_COUNTER( demux_discontinuity );
        EXIT_COUNTER( played_abuffers );
        EXIT_COUNTER( lost_abuffers );
        EXIT_COUNTER( displayed_pictures );
        EXIT_COUNTER( lost_pictures );
        EXIT_COUNTER( decoded_audio );
        EXIT_COUNTER( decoded_video );
        EXIT_COUNTER( decoded_sub );

        if( input_priv(p_input)->p_sout )
        {
            EXIT_COUNTER( sout_sent_packets );
            EXIT_COUNTER( sout_sent_bytes );
            EXIT_COUNTER( sout_send_bitrat...",5,,1460,2,,void
56788,BLOCK,1,,<empty>,,,,1,,void
56790,BLOCK,-1,,EXIT_COUNTER( read_bytes ),9,,1464,1,,void
56798,BLOCK,-1,,<empty>,9,,1464,2,,void
56816,BLOCK,1,,<empty>,,,,1,,void
56818,BLOCK,-1,,EXIT_COUNTER( read_packets ),9,,1465,1,,void
56826,BLOCK,-1,,<empty>,9,,1465,2,,void
56844,BLOCK,1,,<empty>,,,,1,,void
56846,BLOCK,-1,,EXIT_COUNTER( demux_read ),9,,1466,1,,void
56854,BLOCK,-1,,<empty>,9,,1466,2,,void
56872,BLOCK,1,,<empty>,,,,1,,void
56874,BLOCK,-1,,EXIT_COUNTER( input_bitrate ),9,,1467,1,,void
56882,BLOCK,-1,,<empty>,9,,1467,2,,void
56900,BLOCK,1,,<empty>,,,,1,,void
56902,BLOCK,-1,,EXIT_COUNTER( demux_bitrate ),9,,1468,1,,void
56910,BLOCK,-1,,<empty>,9,,1468,2,,void
56928,BLOCK,1,,<empty>,,,,1,,void
56930,BLOCK,-1,,EXIT_COUNTER( demux_corrupted ),9,,1469,1,,void
56938,BLOCK,-1,,<empty>,9,,1469,2,,void
56956,BLOCK,1,,<empty>,,,,1,,void
56958,BLOCK,-1,,EXIT_COUNTER( demux_discontinuity ),9,,1470,1,,void
56966,BLOCK,-1,,<empty>,9,,1470,2,,void
56984,BLOCK,1,,<empty>,,,,1,,void
56986,BLOCK,-1,,EXIT_COUNTER( played_abuffers ),9,,1471,1,,void
56994,BLOCK,-1,,<empty>,9,,1471,2,,void
57012,BLOCK,1,,<empty>,,,,1,,void
57014,BLOCK,-1,,EXIT_COUNTER( lost_abuffers ),9,,1472,1,,void
57022,BLOCK,-1,,<empty>,9,,1472,2,,void
57040,BLOCK,1,,<empty>,,,,1,,void
57042,BLOCK,-1,,EXIT_COUNTER( displayed_pictures ),9,,1473,1,,void
57050,BLOCK,-1,,<empty>,9,,1473,2,,void
57068,BLOCK,1,,<empty>,,,,1,,void
57070,BLOCK,-1,,EXIT_COUNTER( lost_pictures ),9,,1474,1,,void
57078,BLOCK,-1,,<empty>,9,,1474,2,,void
57096,BLOCK,1,,<empty>,,,,1,,void
57098,BLOCK,-1,,EXIT_COUNTER( decoded_audio ),9,,1475,1,,void
57106,BLOCK,-1,,<empty>,9,,1475,2,,void
57124,BLOCK,1,,<empty>,,,,1,,void
57126,BLOCK,-1,,EXIT_COUNTER( decoded_video ),9,,1476,1,,void
57134,BLOCK,-1,,<empty>,9,,1476,2,,void
57152,BLOCK,1,,<empty>,,,,1,,void
57154,BLOCK,-1,,EXIT_COUNTER( decoded_sub ),9,,1477,1,,void
57162,BLOCK,-1,,<empty>,9,,1477,2,,void
57184,BLOCK,-1,,"{
            EXIT_COUNTER( sout_sent_packets );
            EXIT_COUNTER( sout_sent_bytes );
            EXIT_COUNTER( sout_send_bitrate );
        }",9,,1480,2,,void
57186,BLOCK,1,,<empty>,,,,1,,void
57188,BLOCK,-1,,EXIT_COUNTER( sout_sent_packets ),13,,1481,1,,void
57196,BLOCK,-1,,<empty>,13,,1481,2,,void
57214,BLOCK,1,,<empty>,,,,1,,void
57216,BLOCK,-1,,EXIT_COUNTER( sout_sent_bytes ),13,,1482,1,,void
57224,BLOCK,-1,,<empty>,13,,1482,2,,void
57242,BLOCK,1,,<empty>,,,,1,,void
57244,BLOCK,-1,,EXIT_COUNTER( sout_send_bitrate ),13,,1483,1,,void
57252,BLOCK,-1,,<empty>,13,,1483,2,,void
57287,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);

    /* We are at the end */
    input_ChangeState( p_input, END_S );

    /* Clean control variables */
    input_ControlVarStop( p_input );

    /* Stop es out activity */
    es_out_SetMode( priv->p_es_out, ES_OUT_MODE_NONE );

    /* Delete slave */
    for( int i = 0; i < priv->i_slave; i++ )
        InputSourceDestroy( priv->slave[i] );
    free( priv->slave );

    /* Clean up master */
    InputSourceDestroy( priv->master );
    priv->i_title = 0;
    priv->title = NULL;
    priv->i_title_offset = 0;
    priv->i_seekpoint_offset = 0;

    /* Unload all modules */
    if( priv->p_es_out )
        es_out_Delete( priv->p_es_out );
    es_out_SetMode( priv->p_es_out_display, ES_OUT_MODE_END );

    if( !priv->b_preparsing )
    {
#define CL_CO( c ) \
do { \
    stats_CounterClean( priv->counters.p_##c ); \
    priv->counters.p_##c = NULL; \
} while (0)

        if( libvlc_stats( p_input ) )
        {
            /* make s...",1,,1499,2,,void
57304,BLOCK,-1,,<empty>,5,,1512,1,,void
57354,BLOCK,-1,,<empty>,9,,1525,2,,void
57369,BLOCK,-1,,"{
#define CL_CO( c ) \
do { \
    stats_CounterClean( priv->counters.p_##c ); \
    priv->counters.p_##c = NULL; \
} while (0)

        if( libvlc_stats( p_input ) )
        {
            /* make sure we are up to date */
            stats_ComputeInputStats( p_input, priv->p_item->p_stats );
            CL_CO( read_bytes );
            CL_CO( read_packets );
            CL_CO( demux_read );
            CL_CO( input_bitrate );
            CL_CO( demux_bitrate );
            CL_CO( demux_corrupted );
            CL_CO( demux_discontinuity );
            CL_CO( played_abuffers );
            CL_CO( lost_abuffers );
            CL_CO( displayed_pictures );
            CL_CO( lost_pictures );
            CL_CO( decoded_audio) ;
            CL_CO( decoded_video );
            CL_CO( decoded_sub) ;
        }

        /* Close optional stream output instance */
        if( priv->p_sout )
        {
            CL_CO( sout_sent_packets );
            CL_CO( sout_sent_bytes );
            CL_C...",5,,1529,2,,void
57373,BLOCK,-1,,"{
            /* make sure we are up to date */
            stats_ComputeInputStats( p_input, priv->p_item->p_stats );
            CL_CO( read_bytes );
            CL_CO( read_packets );
            CL_CO( demux_read );
            CL_CO( input_bitrate );
            CL_CO( demux_bitrate );
            CL_CO( demux_corrupted );
            CL_CO( demux_discontinuity );
            CL_CO( played_abuffers );
            CL_CO( lost_abuffers );
            CL_CO( displayed_pictures );
            CL_CO( lost_pictures );
            CL_CO( decoded_audio) ;
            CL_CO( decoded_video );
            CL_CO( decoded_sub) ;
        }",9,,1537,2,,void
57382,BLOCK,1,,<empty>,,,,3,,void
57384,BLOCK,-1,,CL_CO( read_bytes ),13,,1540,1,,void
57400,BLOCK,1,,<empty>,,,,3,,void
57402,BLOCK,-1,,CL_CO( read_packets ),13,,1541,1,,void
57418,BLOCK,1,,<empty>,,,,3,,void
57420,BLOCK,-1,,CL_CO( demux_read ),13,,1542,1,,void
57436,BLOCK,1,,<empty>,,,,3,,void
57438,BLOCK,-1,,CL_CO( input_bitrate ),13,,1543,1,,void
57454,BLOCK,1,,<empty>,,,,3,,void
57456,BLOCK,-1,,CL_CO( demux_bitrate ),13,,1544,1,,void
57472,BLOCK,1,,<empty>,,,,3,,void
57474,BLOCK,-1,,CL_CO( demux_corrupted ),13,,1545,1,,void
57490,BLOCK,1,,<empty>,,,,3,,void
57492,BLOCK,-1,,CL_CO( demux_discontinuity ),13,,1546,1,,void
57508,BLOCK,1,,<empty>,,,,3,,void
57510,BLOCK,-1,,CL_CO( played_abuffers ),13,,1547,1,,void
57526,BLOCK,1,,<empty>,,,,3,,void
57528,BLOCK,-1,,CL_CO( lost_abuffers ),13,,1548,1,,void
57544,BLOCK,1,,<empty>,,,,3,,void
57546,BLOCK,-1,,CL_CO( displayed_pictures ),13,,1549,1,,void
57562,BLOCK,1,,<empty>,,,,3,,void
57564,BLOCK,-1,,CL_CO( lost_pictures ),13,,1550,1,,void
57580,BLOCK,1,,<empty>,,,,3,,void
57582,BLOCK,-1,,CL_CO( decoded_audio),13,,1551,1,,void
57598,BLOCK,1,,<empty>,,,,3,,void
57600,BLOCK,-1,,CL_CO( decoded_video ),13,,1552,1,,void
57616,BLOCK,1,,<empty>,,,,3,,void
57618,BLOCK,-1,,CL_CO( decoded_sub),13,,1553,1,,void
57637,BLOCK,-1,,"{
            CL_CO( sout_sent_packets );
            CL_CO( sout_sent_bytes );
            CL_CO( sout_send_bitrate );
        }",9,,1558,2,,void
57639,BLOCK,1,,<empty>,,,,3,,void
57641,BLOCK,-1,,CL_CO( sout_sent_packets ),13,,1559,1,,void
57657,BLOCK,1,,<empty>,,,,3,,void
57659,BLOCK,-1,,CL_CO( sout_sent_bytes ),13,,1560,1,,void
57675,BLOCK,1,,<empty>,,,,3,,void
57677,BLOCK,-1,,CL_CO( sout_send_bitrate ),13,,1561,1,,void
57705,BLOCK,-1,,"{
        for( int i = 0; i < priv->i_attachment; i++ )
            vlc_input_attachment_Delete( priv->attachment[i] );
        TAB_CLEAN( priv->i_attachment, priv->attachment );
        free( priv->attachment_demux);
        priv->attachment_demux = NULL;
    }",5,,1568,2,,void
57707,BLOCK,-1,,<empty>,9,,1569,1,,void
57742,BLOCK,-1,,<empty>,5,,1577,1,,void
57796,BLOCK,-1,,<empty>,9,,1588,2,,void
57808,BLOCK,-1,,"{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    if( sys->is_stopped || sys->i_control >= INPUT_CONTROL_FIFO_SIZE )
    {
        if( sys->is_stopped )
            msg_Dbg( p_input, ""input control stopped, trashing type=%d"",
                     i_type );
        else
            msg_Err( p_input, ""input control fifo overflow, trashing type=%d"",
                     i_type );
        if( p_val )
            ControlRelease( i_type, *p_val );
    }
    else
    {
        input_control_t c;
        c.i_type = i_type;
        if( p_val )
            c.val = *p_val;
        else
            memset( &c.val, 0, sizeof(c.val) );

        sys->control[sys->i_control++] = c;

        vlc_cond_signal( &sys->wait_control );
    }
    vlc_mutex_unlock( &sys->lock_control );
}",1,,1596,4,,void
57829,BLOCK,1,,<empty>,,,,1,,void
57831,BLOCK,-1,,"{
        if( sys->is_stopped )
            msg_Dbg( p_input, ""input control stopped, trashing type=%d"",
                     i_type );
        else
            msg_Err( p_input, ""input control fifo overflow, trashing type=%d"",
                     i_type );
        if( p_val )
            ControlRelease( i_type, *p_val );
    }",5,,1601,2,,void
57836,BLOCK,-1,,<empty>,13,,1603,2,,void
57842,BLOCK,-1,,<empty>,13,,1606,1,,void
57849,BLOCK,-1,,<empty>,13,,1609,2,,void
57855,BLOCK,-1,,"{
        input_control_t c;
        c.i_type = i_type;
        if( p_val )
            c.val = *p_val;
        else
            memset( &c.val, 0, sizeof(c.val) );

        sys->control[sys->i_control++] = c;

        vlc_cond_signal( &sys->wait_control );
    }",5,,1612,1,,void
57864,BLOCK,-1,,<empty>,13,,1616,2,,void
57872,BLOCK,-1,,<empty>,13,,1618,1,,void
57907,BLOCK,-1,,"{
    const int i_lt = input_priv(p_input)->control[0].i_type;
    int i;
    for( i = 1; i < input_priv(p_input)->i_control; i++ )
    {
        const int i_ct = input_priv(p_input)->control[i].i_type;

        if( i_lt == i_ct &&
            ( i_ct == INPUT_CONTROL_SET_STATE ||
              i_ct == INPUT_CONTROL_SET_RATE ||
              i_ct == INPUT_CONTROL_SET_POSITION ||
              i_ct == INPUT_CONTROL_SET_TIME ||
              i_ct == INPUT_CONTROL_SET_PROGRAM ||
              i_ct == INPUT_CONTROL_SET_TITLE ||
              i_ct == INPUT_CONTROL_SET_SEEKPOINT ||
              i_ct == INPUT_CONTROL_SET_BOOKMARK ) )
        {
            continue;
        }
        else
        {
            /* TODO but that's not that important
                - merge SET_X with SET_X_CMD
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before a SET_TITLE
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before another among them
                - ?
               ...",1,,1628,2,,void
57921,BLOCK,-1,,<empty>,5,,1631,1,,void
57933,BLOCK,4,,"{
        const int i_ct = input_priv(p_input)->control[i].i_type;

        if( i_lt == i_ct &&
            ( i_ct == INPUT_CONTROL_SET_STATE ||
              i_ct == INPUT_CONTROL_SET_RATE ||
              i_ct == INPUT_CONTROL_SET_POSITION ||
              i_ct == INPUT_CONTROL_SET_TIME ||
              i_ct == INPUT_CONTROL_SET_PROGRAM ||
              i_ct == INPUT_CONTROL_SET_TITLE ||
              i_ct == INPUT_CONTROL_SET_SEEKPOINT ||
              i_ct == INPUT_CONTROL_SET_BOOKMARK ) )
        {
            continue;
        }
        else
        {
            /* TODO but that's not that important
                - merge SET_X with SET_X_CMD
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before a SET_TITLE
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before another among them
                - ?
                */
            break;
        }
    }",5,,1632,4,,void
57981,BLOCK,-1,,"{
            continue;
        }",9,,1644,2,,void
57984,BLOCK,-1,,"{
            /* TODO but that's not that important
                - merge SET_X with SET_X_CMD
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before a SET_TITLE
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before another among them
                - ?
                */
            break;
        }",9,,1648,1,,void
57998,BLOCK,-1,,"{
    input_thread_private_t *p_sys = input_priv(p_input);

    vlc_mutex_lock( &p_sys->lock_control );
    while( p_sys->i_control <= 0 ||
           ( b_postpone_seek && ControlIsSeekRequest( p_sys->control[0].i_type ) ) )
    {
        if( p_sys->is_stopped )
        {
            vlc_mutex_unlock( &p_sys->lock_control );
            return VLC_EGENERIC;
        }

        if( i_deadline >= 0 )
        {
            if( vlc_cond_timedwait( &p_sys->wait_control, &p_sys->lock_control,
                                    i_deadline ) )
            {
                vlc_mutex_unlock( &p_sys->lock_control );
                return VLC_EGENERIC;
            }
        }
        else
            vlc_cond_wait( &p_sys->wait_control, &p_sys->lock_control );
    }

    /* */
    const int i_index = ControlGetReducedIndexLocked( p_input );

    for( int i = 0; i < i_index; ++i )
    {
        /* Release Reduced controls */
        ControlRelease( p_sys->control[i].i_type, p_sys->control[i].v...",1,,1665,6,,void
58026,BLOCK,-1,,"{
        if( p_sys->is_stopped )
        {
            vlc_mutex_unlock( &p_sys->lock_control );
            return VLC_EGENERIC;
        }

        if( i_deadline >= 0 )
        {
            if( vlc_cond_timedwait( &p_sys->wait_control, &p_sys->lock_control,
                                    i_deadline ) )
            {
                vlc_mutex_unlock( &p_sys->lock_control );
                return VLC_EGENERIC;
            }
        }
        else
            vlc_cond_wait( &p_sys->wait_control, &p_sys->lock_control );
    }",5,,1671,2,,void
58031,BLOCK,-1,,"{
            vlc_mutex_unlock( &p_sys->lock_control );
            return VLC_EGENERIC;
        }",9,,1673,2,,void
58043,BLOCK,-1,,"{
            if( vlc_cond_timedwait( &p_sys->wait_control, &p_sys->lock_control,
                                    i_deadline ) )
            {
                vlc_mutex_unlock( &p_sys->lock_control );
                return VLC_EGENERIC;
            }
        }",9,,1679,2,,void
58055,BLOCK,-1,,"{
                vlc_mutex_unlock( &p_sys->lock_control );
                return VLC_EGENERIC;
            }",13,,1682,2,,void
58064,BLOCK,-1,,<empty>,13,,1688,1,,void
58080,BLOCK,-1,,<empty>,5,,1694,1,,void
58090,BLOCK,4,,"{
        /* Release Reduced controls */
        ControlRelease( p_sys->control[i].i_type, p_sys->control[i].val );
    }",5,,1695,4,,void
58139,BLOCK,-1,,<empty>,9,,1706,2,,void
58175,BLOCK,-1,,"{
    switch( i_type )
    {
    case INPUT_CONTROL_SET_POSITION:
    case INPUT_CONTROL_SET_TIME:
    case INPUT_CONTROL_SET_TITLE:
    case INPUT_CONTROL_SET_TITLE_NEXT:
    case INPUT_CONTROL_SET_TITLE_PREV:
    case INPUT_CONTROL_SET_SEEKPOINT:
    case INPUT_CONTROL_SET_SEEKPOINT_NEXT:
    case INPUT_CONTROL_SET_SEEKPOINT_PREV:
    case INPUT_CONTROL_SET_BOOKMARK:
    case INPUT_CONTROL_NAV_ACTIVATE:
    case INPUT_CONTROL_NAV_UP:
    case INPUT_CONTROL_NAV_DOWN:
    case INPUT_CONTROL_NAV_LEFT:
    case INPUT_CONTROL_NAV_RIGHT:
    case INPUT_CONTROL_NAV_POPUP:
    case INPUT_CONTROL_NAV_MENU:
        return true;
    default:
        return false;
    }
}",1,,1713,2,,void
58178,BLOCK,-1,,"{
    case INPUT_CONTROL_SET_POSITION:
    case INPUT_CONTROL_SET_TIME:
    case INPUT_CONTROL_SET_TITLE:
    case INPUT_CONTROL_SET_TITLE_NEXT:
    case INPUT_CONTROL_SET_TITLE_PREV:
    case INPUT_CONTROL_SET_SEEKPOINT:
    case INPUT_CONTROL_SET_SEEKPOINT_NEXT:
    case INPUT_CONTROL_SET_SEEKPOINT_PREV:
    case INPUT_CONTROL_SET_BOOKMARK:
    case INPUT_CONTROL_NAV_ACTIVATE:
    case INPUT_CONTROL_NAV_UP:
    case INPUT_CONTROL_NAV_DOWN:
    case INPUT_CONTROL_NAV_LEFT:
    case INPUT_CONTROL_NAV_RIGHT:
    case INPUT_CONTROL_NAV_POPUP:
    case INPUT_CONTROL_NAV_MENU:
        return true;
    default:
        return false;
    }",5,,1715,2,,void
58221,BLOCK,-1,,"{
    switch( i_type )
    {
    case INPUT_CONTROL_ADD_SLAVE:
        if( val.p_address )
            input_item_slave_Delete( val.p_address );
        break;
    case INPUT_CONTROL_SET_VIEWPOINT:
    case INPUT_CONTROL_SET_INITIAL_VIEWPOINT:
    case INPUT_CONTROL_UPDATE_VIEWPOINT:
        free( val.p_address );
        break;
    case INPUT_CONTROL_SET_RENDERER:
        if( val.p_address )
            vlc_renderer_item_release( val.p_address );
        break;

    default:
        break;
    }
}",1,,1739,3,,void
58224,BLOCK,-1,,"{
    case INPUT_CONTROL_ADD_SLAVE:
        if( val.p_address )
            input_item_slave_Delete( val.p_address );
        break;
    case INPUT_CONTROL_SET_VIEWPOINT:
    case INPUT_CONTROL_SET_INITIAL_VIEWPOINT:
    case INPUT_CONTROL_UPDATE_VIEWPOINT:
        free( val.p_address );
        break;
    case INPUT_CONTROL_SET_RENDERER:
        if( val.p_address )
            vlc_renderer_item_release( val.p_address );
        break;

    default:
        break;
    }",5,,1741,2,,void
58231,BLOCK,-1,,<empty>,13,,1744,2,,void
58254,BLOCK,-1,,<empty>,13,,1753,2,,void
58267,BLOCK,-1,,"{
    int i_state = PAUSE_S;

    if( input_priv(p_input)->b_can_pause )
    {
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, true ) )
        {
            msg_Warn( p_input, ""cannot set pause state"" );
            return;
        }
    }

    /* */
    if( es_out_SetPauseState( input_priv(p_input)->p_es_out, input_priv(p_input)->b_can_pause,
                              true, i_control_date ) )
    {
        msg_Warn( p_input, ""cannot set pause state at es_out level"" );
        return;
    }

    /* Switch to new state */
    input_ChangeState( p_input, i_state );
}",1,,1763,3,,void
58277,BLOCK,-1,,"{
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, true ) )
        {
            msg_Warn( p_input, ""cannot set pause state"" );
            return;
        }
    }",5,,1767,2,,void
58292,BLOCK,-1,,"{
            msg_Warn( p_input, ""cannot set pause state"" );
            return;
        }",9,,1771,2,,void
58309,BLOCK,-1,,"{
        msg_Warn( p_input, ""cannot set pause state at es_out level"" );
        return;
    }",5,,1780,2,,void
58322,BLOCK,-1,,"{
    if( input_priv(p_input)->b_can_pause )
    {
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, false ) )
        {
            msg_Err( p_input, ""cannot resume"" );
            input_ChangeState( p_input, ERROR_S );
            return;
        }
    }

    /* Switch to play */
    input_ChangeState( p_input, PLAYING_S );
    es_out_SetPauseState( input_priv(p_input)->p_es_out, false, false, i_control_date );
}",1,,1790,3,,void
58328,BLOCK,-1,,"{
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, false ) )
        {
            msg_Err( p_input, ""cannot resume"" );
            input_ChangeState( p_input, ERROR_S );
            return;
        }
    }",5,,1792,2,,void
58343,BLOCK,-1,,"{
            msg_Err( p_input, ""cannot resume"" );
            input_ChangeState( p_input, ERROR_S );
            return;
        }",9,,1796,2,,void
58366,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);

    vlc_viewpoint_clip( &priv->viewpoint );

    vout_thread_t **pp_vout;
    size_t i_vout;
    input_resource_HoldVouts( priv->p_resource, &pp_vout, &i_vout );

    for( size_t i = 0; i < i_vout; ++i )
    {
        var_SetAddress( pp_vout[i], ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( pp_vout[i], ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL );
        vlc_object_release( pp_vout[i] );
    }
    free( pp_vout );

    audio_output_t *p_aout = input_resource_HoldAout( priv->p_resource );
    if( p_aout )
    {

        var_SetAddress( p_aout, ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( p_aout, ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL );
        vlc_object_release( p_aout );
    }
}",1,,1809,2,,void
58388,BLOCK,-1,,<empty>,5,,1818,1,,void
58398,BLOCK,4,,"{
        var_SetAddress( pp_vout[i], ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( pp_vout[i], ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL );
        vlc_object_release( pp_vout[i] );
    }",5,,1819,4,,void
58418,BLOCK,1,,<empty>,38,,1823,1,,void
58438,BLOCK,-1,,"{

        var_SetAddress( p_aout, ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( p_aout, ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL );
        vlc_object_release( p_aout );
    }",5,,1830,2,,void
58454,BLOCK,1,,<empty>,38,,1835,1,,void
58466,BLOCK,-1,,"{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, _( ""Volume %ld%%"" ),
                     lroundf( vol * 100.f ) );
}",1,,1844,3,,void
58484,BLOCK,-1,,"{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );

    int64_t t = var_GetInteger( p_input, ""time"" ) / CLOCK_FREQ;
    int64_t l = var_GetInteger( p_input, ""length"" ) / CLOCK_FREQ;

    char psz_time[MSTRTIME_MAX_SIZE];
    secstotimestr( psz_time, t );

    if( l > 0 )
    {
        char psz_duration[MSTRTIME_MAX_SIZE];

        secstotimestr( psz_duration, l );
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD,
                         ""%s / %s"", psz_time, psz_duration );
    }
    else if( t > 0 )
    {
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_time );
    }
}",1,,1852,3,,void
58512,BLOCK,-1,,"{
        char psz_duration[MSTRTIME_MAX_SIZE];

        secstotimestr( psz_duration, l );
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD,
                         ""%s / %s"", psz_time, psz_duration );
    }",5,,1862,2,,void
58524,BLOCK,-1,,<empty>,10,,1869,1,,void
58529,BLOCK,-1,,"{
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_time );
    }",5,,1870,2,,void
58540,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);

    if( !demux_Control( priv->master->p_demux, i_type
                        - INPUT_CONTROL_NAV_ACTIVATE + DEMUX_NAV_ACTIVATE ) )
        return; /* The demux handled the navigation control */

    /* Handle Up/Down/Left/Right if the demux can't navigate */
    vlc_viewpoint_t vp = {};
    int vol_direction = 0;
    int seek_direction = 0;
    switch( i_type )
    {
        case INPUT_CONTROL_NAV_UP:
            vol_direction = 1;
            vp.pitch = -1.f;
            break;
        case INPUT_CONTROL_NAV_DOWN:
            vol_direction = -1;
            vp.pitch = 1.f;
            break;
        case INPUT_CONTROL_NAV_LEFT:
            seek_direction = -1;
            vp.yaw = -1.f;
            break;
        case INPUT_CONTROL_NAV_RIGHT:
            seek_direction = 1;
            vp.yaw = 1.f;
            break;
        case INPUT_CONTROL_NAV_ACTIVATE:
        case INPUT_CONTROL_NAV_POPUP:
        case INPUT_CONTROL_...",1,,1876,3,,void
58559,BLOCK,-1,,<empty>,9,,1881,2,,void
58575,BLOCK,-1,,"{
        case INPUT_CONTROL_NAV_UP:
            vol_direction = 1;
            vp.pitch = -1.f;
            break;
        case INPUT_CONTROL_NAV_DOWN:
            vol_direction = -1;
            vp.pitch = 1.f;
            break;
        case INPUT_CONTROL_NAV_LEFT:
            seek_direction = -1;
            vp.yaw = -1.f;
            break;
        case INPUT_CONTROL_NAV_RIGHT:
            seek_direction = 1;
            vp.yaw = 1.f;
            break;
        case INPUT_CONTROL_NAV_ACTIVATE:
        case INPUT_CONTROL_NAV_POPUP:
        case INPUT_CONTROL_NAV_MENU:
            return;
        default:
            vlc_assert_unreachable();
    }",5,,1888,2,,void
58648,BLOCK,-1,,<empty>,5,,1918,1,,void
58658,BLOCK,4,,"{
        if( !b_viewpoint_ch
         && var_GetBool( pp_vout[i], ""viewpoint-changeable"" ) )
            b_viewpoint_ch = true;
    }",5,,1919,4,,void
58668,BLOCK,-1,,<empty>,13,,1922,2,,void
58674,BLOCK,-1,,"{
        priv->viewpoint_changed = true;
        priv->viewpoint.yaw   += vp.yaw;
        priv->viewpoint.pitch += vp.pitch;
        priv->viewpoint.roll  += vp.roll;
        priv->viewpoint.fov   += vp.fov;
        ViewpointApply( p_input );
        goto clean;
    }",5,,1926,2,,void
58723,BLOCK,-1,,"{
        mtime_t it = var_InheritInteger( p_input, ""short-jump-size"" );
        var_SetInteger( p_input, ""time-offset"", it * seek_direction * CLOCK_FREQ );
        if( i_vout > 0 )
            ControlNavDisplayPosition( pp_vout[0], p_input );
    }",5,,1938,2,,void
58742,BLOCK,-1,,<empty>,13,,1942,2,,void
58749,BLOCK,-1,,"{
        assert( vol_direction != 0 );
        audio_output_t *p_aout = input_resource_HoldAout( priv->p_resource );
        if( p_aout )
        {
            float new_vol;
            aout_VolumeUpdate( p_aout, vol_direction, &new_vol );
            vlc_object_release( p_aout );
            if( i_vout > 0 )
                ControlNavDisplayVolume( pp_vout[0], new_vol );
        }
    }",5,,1945,1,,void
58763,BLOCK,-1,,"{
            float new_vol;
            aout_VolumeUpdate( p_aout, vol_direction, &new_vol );
            vlc_object_release( p_aout );
            if( i_vout > 0 )
                ControlNavDisplayVolume( pp_vout[0], new_vol );
        }",9,,1949,2,,void
58776,BLOCK,-1,,<empty>,17,,1954,2,,void
58784,BLOCK,-1,,<empty>,5,,1959,1,,void
58805,BLOCK,-1,,"{
    input_source_t *p_inputSource = input_priv(p_input)->master;
    demux_t *p_filtered_demux = demux_FilterChainNew( p_inputSource->p_demux, psz_demux_chain );
    if ( p_filtered_demux != NULL )
        p_inputSource->p_demux = p_filtered_demux;
    else if ( psz_demux_chain != NULL )
        msg_Dbg(p_input, ""Failed to create demux filter %s"", psz_demux_chain);
}",1,,1985,3,,void
58825,BLOCK,-1,,<empty>,9,,1989,2,,void
58832,BLOCK,-1,,<empty>,10,,1990,1,,void
58837,BLOCK,-1,,<empty>,9,,1991,2,,void
58848,BLOCK,-1,,"{
    const mtime_t i_control_date = mdate();
    /* FIXME b_force_update is abused, it should be carefully checked */
    bool b_force_update = false;

    if( !p_input )
        return b_force_update;

    switch( i_type )
    {
        case INPUT_CONTROL_SET_POSITION:
        {
            if( input_priv(p_input)->b_recording )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ignored while recording"" );
                break;
            }

            float f_pos = val.f_float;
            if( f_pos < 0.f )
                f_pos = 0.f;
            else if( f_pos > 1.f )
                f_pos = 1.f;
            /* Reset the decoders states and clock sync (before calling the demuxer */
            es_out_SetTime( input_priv(p_input)->p_es_out, -1 );
            if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_POSITION,
                               (double) f_pos, !input_priv(p_input)->b_fast_seek ) )
            {
                msg_...",1,,1996,4,,void
58860,BLOCK,-1,,<empty>,9,,2002,2,,void
58865,BLOCK,-1,,"{
        case INPUT_CONTROL_SET_POSITION:
        {
            if( input_priv(p_input)->b_recording )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ignored while recording"" );
                break;
            }

            float f_pos = val.f_float;
            if( f_pos < 0.f )
                f_pos = 0.f;
            else if( f_pos > 1.f )
                f_pos = 1.f;
            /* Reset the decoders states and clock sync (before calling the demuxer */
            es_out_SetTime( input_priv(p_input)->p_es_out, -1 );
            if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_POSITION,
                               (double) f_pos, !input_priv(p_input)->b_fast_seek ) )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ""
                         ""%2.1f%% failed"", (double)(f_pos * 100.f) );
            }
            else
            {
                if( input_priv(p_input)->i_slave > 0 )
               ...",5,,2005,2,,void
58868,BLOCK,3,,"{
            if( input_priv(p_input)->b_recording )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ignored while recording"" );
                break;
            }

            float f_pos = val.f_float;
            if( f_pos < 0.f )
                f_pos = 0.f;
            else if( f_pos > 1.f )
                f_pos = 1.f;
            /* Reset the decoders states and clock sync (before calling the demuxer */
            es_out_SetTime( input_priv(p_input)->p_es_out, -1 );
            if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_POSITION,
                               (double) f_pos, !input_priv(p_input)->b_fast_seek ) )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ""
                         ""%2.1f%% failed"", (double)(f_pos * 100.f) );
            }
            else
            {
                if( input_priv(p_input)->i_slave > 0 )
                    SlaveSeek( p_input );
                input_pr...",9,,2007,3,,void
58874,BLOCK,-1,,"{
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ignored while recording"" );
                break;
            }",13,,2009,2,,void
58889,BLOCK,-1,,<empty>,17,,2016,2,,void
58894,BLOCK,-1,,<empty>,18,,2017,1,,void
58899,BLOCK,-1,,<empty>,17,,2018,2,,void
58927,BLOCK,-1,,"{
                msg_Err( p_input, ""INPUT_CONTROL_SET_POSITION ""
                         ""%2.1f%% failed"", (double)(f_pos * 100.f) );
            }",13,,2023,2,,void
58937,BLOCK,-1,,"{
                if( input_priv(p_input)->i_slave > 0 )
                    SlaveSeek( p_input );
                input_priv(p_input)->master->b_eof = false;

                b_force_update = true;
            }",13,,2028,1,,void
58945,BLOCK,-1,,<empty>,21,,2030,2,,void
58962,BLOCK,6,,"{
            int64_t i_time;
            int i_ret;

            if( input_priv(p_input)->b_recording )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_TIME ignored while recording"" );
                break;
            }

            i_time = val.i_int;
            if( i_time < 0 )
                i_time = 0;

            /* Reset the decoders states and clock sync (before calling the demuxer */
            es_out_SetTime( input_priv(p_input)->p_es_out, -1 );

            i_ret = demux_Control( input_priv(p_input)->master->p_demux,
                                   DEMUX_SET_TIME, i_time,
                                   !input_priv(p_input)->b_fast_seek );
            if( i_ret )
            {
                int64_t i_length;

                /* Emulate it with a SET_POS */
                if( !demux_Control( input_priv(p_input)->master->p_demux,
                                    DEMUX_GET_LENGTH, &i_length ) && i_length > 0 )
                {
          ...",9,,2039,6,,void
58970,BLOCK,-1,,"{
                msg_Err( p_input, ""INPUT_CONTROL_SET_TIME ignored while recording"" );
                break;
            }",13,,2044,2,,void
58984,BLOCK,-1,,<empty>,17,,2051,2,,void
59013,BLOCK,-1,,"{
                int64_t i_length;

                /* Emulate it with a SET_POS */
                if( !demux_Control( input_priv(p_input)->master->p_demux,
                                    DEMUX_GET_LENGTH, &i_length ) && i_length > 0 )
                {
                    double f_pos = (double)i_time / (double)i_length;
                    f_pos = VLC_CLIP(f_pos, 0.0, 1.0);
                    i_ret = demux_Control( input_priv(p_input)->master->p_demux,
                                            DEMUX_SET_POSITION, f_pos,
                                            !input_priv(p_input)->b_fast_seek );
                }
            }",13,,2060,2,,void
59031,BLOCK,-1,,"{
                    double f_pos = (double)i_time / (double)i_length;
                    f_pos = VLC_CLIP(f_pos, 0.0, 1.0);
                    i_ret = demux_Control( input_priv(p_input)->master->p_demux,
                                            DEMUX_SET_POSITION, f_pos,
                                            !input_priv(p_input)->b_fast_seek );
                }",17,,2066,2,,void
59066,BLOCK,-1,,"{
                msg_Warn( p_input, ""INPUT_CONTROL_SET_TIME %""PRId64
                         "" failed or not possible"", i_time );
            }",13,,2075,2,,void
59069,BLOCK,-1,,"{
                if( input_priv(p_input)->i_slave > 0 )
                    SlaveSeek( p_input );
                input_priv(p_input)->master->b_eof = false;

                b_force_update = true;
            }",13,,2080,1,,void
59077,BLOCK,-1,,<empty>,21,,2082,2,,void
59098,BLOCK,-1,,"{
                case PLAYING_S:
                    if( input_priv(p_input)->i_state == PAUSE_S )
                    {
                        ControlUnpause( p_input, i_control_date );
                        b_force_update = true;
                    }
                    break;
                case PAUSE_S:
                    if( input_priv(p_input)->i_state == PLAYING_S )
                    {
                        ControlPause( p_input, i_control_date );
                        b_force_update = true;
                    }
                    break;
                default:
                    msg_Err( p_input, ""invalid INPUT_CONTROL_SET_STATE"" );
            }",13,,2092,2,,void
59108,BLOCK,-1,,"{
                        ControlUnpause( p_input, i_control_date );
                        b_force_update = true;
                    }",21,,2095,2,,void
59125,BLOCK,-1,,"{
                        ControlPause( p_input, i_control_date );
                        b_force_update = true;
                    }",21,,2102,2,,void
59140,BLOCK,13,,"{
            /* Get rate and direction */
            long long i_rate = llabs( val.i_int );
            int i_rate_sign = val.i_int < 0 ? -1 : 1;

            /* Check rate bound */
            if( i_rate < INPUT_RATE_MIN )
            {
                msg_Dbg( p_input, ""cannot set rate faster"" );
                i_rate = INPUT_RATE_MIN;
            }
            else if( i_rate > INPUT_RATE_MAX )
            {
                msg_Dbg( p_input, ""cannot set rate slower"" );
                i_rate = INPUT_RATE_MAX;
            }

            /* Apply direction */
            if( i_rate_sign < 0 )
            {
                if( input_priv(p_input)->master->b_rescale_ts )
                {
                    msg_Dbg( p_input, ""cannot set negative rate"" );
                    i_rate = input_priv(p_input)->i_rate;
                    assert( i_rate > 0 );
                }
                else
                {
                    i_rate *= i_rate_sign;
                }
           ...",9,,2113,13,,void
59164,BLOCK,-1,,"{
                msg_Dbg( p_input, ""cannot set rate faster"" );
                i_rate = INPUT_RATE_MIN;
            }",13,,2120,2,,void
59172,BLOCK,-1,,<empty>,18,,2124,1,,void
59177,BLOCK,-1,,"{
                msg_Dbg( p_input, ""cannot set rate slower"" );
                i_rate = INPUT_RATE_MAX;
            }",13,,2125,2,,void
59188,BLOCK,-1,,"{
                if( input_priv(p_input)->master->b_rescale_ts )
                {
                    msg_Dbg( p_input, ""cannot set negative rate"" );
                    i_rate = input_priv(p_input)->i_rate;
                    assert( i_rate > 0 );
                }
                else
                {
                    i_rate *= i_rate_sign;
                }
            }",13,,2132,2,,void
59196,BLOCK,-1,,"{
                    msg_Dbg( p_input, ""cannot set negative rate"" );
                    i_rate = input_priv(p_input)->i_rate;
                    assert( i_rate > 0 );
                }",17,,2134,2,,void
59211,BLOCK,-1,,"{
                    i_rate *= i_rate_sign;
                }",17,,2140,1,,void
59244,BLOCK,-1,,"{
                msg_Dbg( p_input, ""cannot change rate"" );
                i_rate = INPUT_RATE_DEFAULT;
            }",13,,2148,2,,void
59269,BLOCK,-1,,"{
                if( !input_priv(p_input)->master->b_rescale_ts )
                    es_out_Control( input_priv(p_input)->p_es_out, ES_OUT_RESET_PCR );

                if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_SET_RATE,
                                   &i_rate ) )
                {
                    msg_Warn( p_input, ""ACCESS/DEMUX_SET_RATE failed"" );
                    i_rate = input_priv(p_input)->i_rate;
                }
            }",13,,2154,2,,void
59278,BLOCK,-1,,<empty>,21,,2156,2,,void
59296,BLOCK,-1,,"{
                    msg_Warn( p_input, ""ACCESS/DEMUX_SET_RATE failed"" );
                    i_rate = input_priv(p_input)->i_rate;
                }",17,,2160,2,,void
59313,BLOCK,-1,,"{
                input_priv(p_input)->i_rate = i_rate;
                input_SendEventRate( p_input, i_rate );

                if( input_priv(p_input)->master->b_rescale_ts )
                {
                    const int i_rate_source = (input_priv(p_input)->b_can_pace_control || input_priv(p_input)->b_can_rate_control ) ? i_rate : INPUT_RATE_DEFAULT;
                    es_out_SetRate( input_priv(p_input)->p_es_out, i_rate_source, i_rate );
                }

                b_force_update = true;
            }",13,,2168,2,,void
59330,BLOCK,-1,,"{
                    const int i_rate_source = (input_priv(p_input)->b_can_pace_control || input_priv(p_input)->b_can_rate_control ) ? i_rate : INPUT_RATE_DEFAULT;
                    es_out_SetRate( input_priv(p_input)->p_es_out, i_rate_source, i_rate );
                }",17,,2173,2,,void
59428,BLOCK,34,,"{
            input_thread_private_t *priv = input_priv(p_input);
            const vlc_viewpoint_t *p_vp = val.p_address;

            if ( i_type == INPUT_CONTROL_SET_INITIAL_VIEWPOINT )
            {

                /* Set the initial viewpoint if it had not been changed by the
                 * user. */
                if( !priv->viewpoint_changed )
                    priv->viewpoint = *p_vp;
                /* Update viewpoints of aout and every vouts in all cases. */
            }
            else if ( i_type == INPUT_CONTROL_SET_VIEWPOINT)
            {
                priv->viewpoint_changed = true;
                priv->viewpoint = *p_vp;
            }
            else
            {
                priv->viewpoint_changed = true;
                priv->viewpoint.yaw   += p_vp->yaw;
                priv->viewpoint.pitch += p_vp->pitch;
                priv->viewpoint.roll  += p_vp->roll;
                priv->viewpoint.fov   += p_vp->fov;
            }

            Viewpoi...",9,,2208,34,,void
59444,BLOCK,-1,,"{

                /* Set the initial viewpoint if it had not been changed by the
                 * user. */
                if( !priv->viewpoint_changed )
                    priv->viewpoint = *p_vp;
                /* Update viewpoints of aout and every vouts in all cases. */
            }",13,,2213,2,,void
59450,BLOCK,-1,,<empty>,21,,2218,2,,void
59458,BLOCK,-1,,<empty>,18,,2221,1,,void
59463,BLOCK,-1,,"{
                priv->viewpoint_changed = true;
                priv->viewpoint = *p_vp;
            }",13,,2222,2,,void
59476,BLOCK,-1,,"{
                priv->viewpoint_changed = true;
                priv->viewpoint.yaw   += p_vp->yaw;
                priv->viewpoint.pitch += p_vp->pitch;
                priv->viewpoint.roll  += p_vp->roll;
                priv->viewpoint.fov   += p_vp->fov;
            }",13,,2227,1,,void
59547,BLOCK,51,,"{
            if( input_priv(p_input)->b_recording )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_TITLE(*) ignored while recording"" );
                break;
            }
            if( input_priv(p_input)->master->i_title <= 0 )
                break;

            int i_title = demux_GetTitle( input_priv(p_input)->master->p_demux );
            if( i_type == INPUT_CONTROL_SET_TITLE_PREV )
                i_title--;
            else if( i_type == INPUT_CONTROL_SET_TITLE_NEXT )
                i_title++;
            else
                i_title = val.i_int;
            if( i_title < 0 || i_title >= input_priv(p_input)->master->i_title )
                break;

            es_out_SetTime( input_priv(p_input)->p_es_out, -1 );
            demux_Control( input_priv(p_input)->master->p_demux,
                           DEMUX_SET_TITLE, i_title );
            input_SendEventTitle( p_input, i_title );
            break;
        }",9,,2252,51,,void
59553,BLOCK,-1,,"{
                msg_Err( p_input, ""INPUT_CONTROL_SET_TITLE(*) ignored while recording"" );
                break;
            }",13,,2254,2,,void
59567,BLOCK,-1,,<empty>,17,,2259,2,,void
59583,BLOCK,-1,,<empty>,17,,2263,2,,void
59587,BLOCK,-1,,<empty>,18,,2264,1,,void
59592,BLOCK,-1,,<empty>,17,,2265,2,,void
59596,BLOCK,-1,,<empty>,17,,2267,1,,void
59615,BLOCK,-1,,<empty>,17,,2269,2,,void
59643,BLOCK,58,,"{
            if( input_priv(p_input)->b_recording )
            {
                msg_Err( p_input, ""INPUT_CONTROL_SET_SEEKPOINT(*) ignored while recording"" );
                break;
            }
            if( input_priv(p_input)->master->i_title <= 0 )
                break;

            demux_t *p_demux = input_priv(p_input)->master->p_demux;

            int i_title = demux_GetTitle( p_demux );
            int i_seekpoint = demux_GetSeekpoint( p_demux );

            if( i_type == INPUT_CONTROL_SET_SEEKPOINT_PREV )
            {
                int64_t i_seekpoint_time = input_priv(p_input)->master->title[i_title]->seekpoint[i_seekpoint]->i_time_offset;
                int64_t i_input_time = var_GetInteger( p_input, ""time"" );
                if( i_seekpoint_time >= 0 && i_input_time >= 0 )
                {
                    if( i_input_time < i_seekpoint_time + 3000000 )
                        i_seekpoint--;
                }
                else
                    i_see...",9,,2280,58,,void
59649,BLOCK,-1,,"{
                msg_Err( p_input, ""INPUT_CONTROL_SET_SEEKPOINT(*) ignored while recording"" );
                break;
            }",13,,2282,2,,void
59663,BLOCK,-1,,<empty>,17,,2287,2,,void
59688,BLOCK,-1,,"{
                int64_t i_seekpoint_time = input_priv(p_input)->master->title[i_title]->seekpoint[i_seekpoint]->i_time_offset;
                int64_t i_input_time = var_GetInteger( p_input, ""time"" );
                if( i_seekpoint_time >= 0 && i_input_time >= 0 )
                {
                    if( i_input_time < i_seekpoint_time + 3000000 )
                        i_seekpoint--;
                }
                else
                    i_seekpoint--;
            }",13,,2295,2,,void
59720,BLOCK,-1,,"{
                    if( i_input_time < i_seekpoint_time + 3000000 )
                        i_seekpoint--;
                }",17,,2299,2,,void
59727,BLOCK,-1,,<empty>,25,,2301,2,,void
59731,BLOCK,-1,,<empty>,21,,2304,1,,void
59735,BLOCK,-1,,<empty>,18,,2306,1,,void
59740,BLOCK,-1,,<empty>,17,,2307,2,,void
59744,BLOCK,-1,,<empty>,17,,2309,1,,void
59767,BLOCK,-1,,<empty>,17,,2312,2,,void
59796,BLOCK,-1,,<empty>,17,,2319,2,,void
59806,BLOCK,-1,,"{
                input_item_slave_t *p_item_slave  = val.p_address;
                unsigned i_flags = SLAVE_ADD_CANFAIL | SLAVE_ADD_SET_TIME;
                if( p_item_slave->b_forced )
                    i_flags |= SLAVE_ADD_FORCED;

                if( input_SlaveSourceAdd( p_input, p_item_slave->i_type,
                                          p_item_slave->psz_uri, i_flags )
                                          == VLC_SUCCESS )
                {
                    /* Update item slaves */
                    input_item_AddSlave( input_priv(p_input)->p_item, p_item_slave );
                    /* The slave is now owned by the item */
                    val.p_address = NULL;
                }
            }",13,,2325,2,,void
59818,BLOCK,1,,<empty>,,,,1,,void
59823,BLOCK,1,,<empty>,,,,1,,void
59831,BLOCK,-1,,<empty>,21,,2329,2,,void
59835,BLOCK,1,,<empty>,,,,1,,void
59851,BLOCK,-1,,"{
                    /* Update item slaves */
                    input_item_AddSlave( input_priv(p_input)->p_item, p_item_slave );
                    /* The slave is now owned by the item */
                    val.p_address = NULL;
                }",17,,2334,2,,void
59879,BLOCK,-1,,"{
                if( input_priv(p_input)->master->b_can_stream_record )
                {
                    if( demux_Control( input_priv(p_input)->master->p_demux,
                                       DEMUX_SET_RECORD_STATE, val.b_bool ) )
                        val.b_bool = false;
                }
                else
                {
                    if( es_out_SetRecordState( input_priv(p_input)->p_es_out_display, val.b_bool ) )
                        val.b_bool = false;
                }
                input_priv(p_input)->b_recording = val.b_bool;

                input_SendEventRecord( p_input, val.b_bool );

                b_force_update = true;
            }",13,,2345,2,,void
59887,BLOCK,-1,,"{
                    if( demux_Control( input_priv(p_input)->master->p_demux,
                                       DEMUX_SET_RECORD_STATE, val.b_bool ) )
                        val.b_bool = false;
                }",17,,2347,2,,void
59900,BLOCK,-1,,<empty>,25,,2350,2,,void
59907,BLOCK,-1,,"{
                    if( es_out_SetRecordState( input_priv(p_input)->p_es_out_display, val.b_bool ) )
                        val.b_bool = false;
                }",17,,2353,1,,void
59917,BLOCK,-1,,<empty>,25,,2355,2,,void
59949,BLOCK,-1,,"{
                es_out_SetFrameNext( input_priv(p_input)->p_es_out );
            }",13,,2367,2,,void
59956,BLOCK,-1,,<empty>,18,,2370,1,,void
59964,BLOCK,-1,,"{
                ControlPause( p_input, i_control_date );
            }",13,,2371,2,,void
59969,BLOCK,-1,,"{
                msg_Err( p_input, ""invalid state for frame next"" );
            }",13,,2375,1,,void
59979,BLOCK,74,,"{
            mtime_t time_offset = -1;

            vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
            if( val.i_int >= 0 && val.i_int < input_priv(p_input)->i_bookmark )
            {
                const seekpoint_t *p_bookmark = input_priv(p_input)->pp_bookmark[val.i_int];
                time_offset = p_bookmark->i_time_offset;
            }
            vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );

            if( time_offset < 0 )
            {
                msg_Err( p_input, ""invalid bookmark %""PRId64, val.i_int );
                break;
            }

            val.i_int = time_offset;
            b_force_update = Control( p_input, INPUT_CONTROL_SET_TIME, val );
            break;
        }",9,,2382,74,,void
60008,BLOCK,-1,,"{
                const seekpoint_t *p_bookmark = input_priv(p_input)->pp_bookmark[val.i_int];
                time_offset = p_bookmark->i_time_offset;
            }",13,,2387,2,,void
60037,BLOCK,-1,,"{
                msg_Err( p_input, ""invalid bookmark %""PRId64, val.i_int );
                break;
            }",13,,2394,2,,void
60054,BLOCK,77,,"{
#ifdef ENABLE_SOUT
            vlc_renderer_item_t *p_item = val.p_address;
            input_thread_private_t *p_priv = input_priv( p_input );
            // We do not support switching from a renderer to another for now
            if ( p_item == NULL && p_priv->p_renderer == NULL )
                break;

            void *context;
            if( es_out_Control( input_priv(p_input)->p_es_out_display,
                                ES_OUT_STOP_ALL_ES, &context ) != VLC_SUCCESS )
                break;

            if ( p_priv->p_renderer )
            {
                ControlUpdateRenderer( p_input, false );
                demux_FilterDisable( p_priv->master->p_demux,
                        vlc_renderer_item_demux_filter( p_priv->p_renderer ) );
                vlc_renderer_item_release( p_priv->p_renderer );
                p_priv->p_renderer = NULL;
            }
            if( p_item != NULL )
            {
                p_priv->p_renderer = vlc_renderer_item_hold( p_...",9,,2404,77,,void
60090,BLOCK,-1,,"{
    int i_title_end = input_priv(p_input)->master->i_title_end -
                        input_priv(p_input)->master->i_title_offset;
    int i_seekpoint_end = input_priv(p_input)->master->i_seekpoint_end -
                            input_priv(p_input)->master->i_seekpoint_offset;

    if( i_title_end >= 0 && i_seekpoint_end >= 0 )
    {
        if( i_title > i_title_end ||
            ( i_title == i_title_end && i_seekpoint > i_seekpoint_end ) )
            return VLC_DEMUXER_EOF;
    }
    else if( i_seekpoint_end >= 0 )
    {
        if( i_seekpoint > i_seekpoint_end )
            return VLC_DEMUXER_EOF;
    }
    else if( i_title_end >= 0 )
    {
        if( i_title > i_title_end )
            return VLC_DEMUXER_EOF;
    }
    return VLC_DEMUXER_SUCCESS;
}",1,,2467,4,,void
60131,BLOCK,-1,,"{
        if( i_title > i_title_end ||
            ( i_title == i_title_end && i_seekpoint > i_seekpoint_end ) )
            return VLC_DEMUXER_EOF;
    }",5,,2474,2,,void
60144,BLOCK,-1,,<empty>,13,,2477,2,,void
60148,BLOCK,-1,,<empty>,10,,2479,1,,void
60153,BLOCK,-1,,"{
        if( i_seekpoint > i_seekpoint_end )
            return VLC_DEMUXER_EOF;
    }",5,,2480,2,,void
60158,BLOCK,-1,,<empty>,13,,2482,2,,void
60162,BLOCK,-1,,<empty>,10,,2484,1,,void
60167,BLOCK,-1,,"{
        if( i_title > i_title_end )
            return VLC_DEMUXER_EOF;
    }",5,,2485,2,,void
60172,BLOCK,-1,,<empty>,13,,2487,2,,void
60181,BLOCK,-1,,"{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    /* TODO event-like */
    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE ) )
        input_SendEventTitle( p_input, demux_GetTitle( p_demux ) );

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_SEEKPOINT ) )
        input_SendEventSeekpoint( p_input, demux_GetTitle( p_demux ),
                                  demux_GetSeekpoint( p_demux ) );

    return UpdateTitleSeekpoint( p_input,
                                 demux_GetTitle( p_demux ),
                                 demux_GetSeekpoint( p_demux ) );
}",1,,2495,2,,void
60195,BLOCK,-1,,<empty>,9,,2500,2,,void
60204,BLOCK,-1,,<empty>,9,,2503,2,,void
60222,BLOCK,-1,,"{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_META ) )
        InputUpdateMeta( p_input, p_demux );

    {
        double quality;
        double strength;

        if( !demux_Control( p_demux, DEMUX_GET_SIGNAL, &quality, &strength ) )
            input_SendEventSignal( p_input, quality, strength );
    }
}",1,,2512,2,,void
60236,BLOCK,-1,,<empty>,9,,2516,2,,void
60240,BLOCK,4,,"{
        double quality;
        double strength;

        if( !demux_Control( p_demux, DEMUX_GET_SIGNAL, &quality, &strength ) )
            input_SendEventSignal( p_input, quality, strength );
    }",5,,2518,4,,void
60252,BLOCK,-1,,<empty>,13,,2523,2,,void
60261,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *in = priv->master;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Delete the preexisting titles */
    if( in->i_title > 0 )
    {
        for( int i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
        priv->i_title = 0;
        priv->title = NULL;
        in->b_title_demux = false;
    }

    /* Get the new title list */
    if( demux_Control( in->p_demux, DEMUX_GET_TITLE_INFO,
                       &in->title, &in->i_title,
                       &in->i_title_offset, &in->i_seekpoint_offset ) )
        TAB_INIT( in->i_title, in->title );
    else
        in->b_title_demux = true;

    vlc_mutex_unlock( &priv->p_item->lock );

    InitTitle( p_input );
}",1,,2528,2,,void
60286,BLOCK,-1,,"{
        for( int i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
        priv->i_title = 0;
        priv->title = NULL;
        in->b_title_demux = false;
    }",5,,2535,2,,void
60288,BLOCK,-1,,<empty>,9,,2536,1,,void
60350,BLOCK,-1,,<empty>,9,,2548,2,,void
60359,BLOCK,-1,,<empty>,9,,2550,1,,void
60380,BLOCK,-1,,"{
    char const* extra;
    if( stream_extractor_AttachParsed( stream, anchor, &extra ) )
    {
        msg_Err( source, ""unable to attach stream-extractors for %s"",
            (*stream)->psz_url );

        return VLC_EGENERIC;
    }

    if( vlc_stream_directory_Attach( stream, NULL ) )
        msg_Dbg( source, ""attachment of directory-extractor failed for %s"",
            (*stream)->psz_url );

    MRLSections( extra ? extra : """",
        &source->i_title_start, &source->i_title_end,
        &source->i_seekpoint_start, &source->i_seekpoint_end );

    return VLC_SUCCESS;
}",1,,2560,4,,void
60388,BLOCK,-1,,"{
        msg_Err( source, ""unable to attach stream-extractors for %s"",
            (*stream)->psz_url );

        return VLC_EGENERIC;
    }",5,,2563,2,,void
60402,BLOCK,-1,,<empty>,9,,2571,2,,void
60442,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input );
    demux_t *p_demux = NULL;

    /* first, try to create an access demux */
    p_demux = demux_NewAdvanced( VLC_OBJECT( p_source ), p_input,
                                 psz_access, psz_demux, psz_path,
                                 NULL, priv->p_es_out, priv->b_preparsing );
    if( p_demux )
    {
        MRLSections( psz_anchor,
            &p_source->i_title_start, &p_source->i_title_end,
            &p_source->i_seekpoint_start, &p_source->i_seekpoint_end );

        return p_demux;
    }

    /* not an access-demux: create the underlying access stream */
    char *psz_base_mrl;

    if( asprintf( &psz_base_mrl, ""%s://%s"", psz_access, psz_path ) < 0 )
        return NULL;

    char *psz_filters = var_InheritString( p_source, ""stream-filter"" );
    stream_t* p_stream = stream_AccessNew( VLC_OBJECT( p_source ), p_input,
                                           priv->b_preparsing,
                               ...",1,,2584,7,,void
60468,BLOCK,1,,<empty>,,,,11,,void
60486,BLOCK,-1,,"{
        MRLSections( psz_anchor,
            &p_source->i_title_start, &p_source->i_title_end,
            &p_source->i_seekpoint_start, &p_source->i_seekpoint_end );

        return p_demux;
    }",5,,2593,2,,void
60517,BLOCK,-1,,<empty>,9,,2605,2,,void
60543,BLOCK,-1,,<empty>,9,,2614,2,,void
60547,BLOCK,-1,,<empty>,9,,2618,2,,void
60561,BLOCK,-1,,<empty>,9,,2624,2,,void
60567,BLOCK,-1,,<empty>,9,,2628,2,,void
60589,BLOCK,1,,<empty>,,,,12,,void
60607,BLOCK,-1,,<empty>,9,,2636,2,,void
60617,BLOCK,-1,,<empty>,9,,2643,2,,void
60629,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *in = vlc_custom_create( p_input, sizeof( *in ),
                                            ""input source"" );
    if( unlikely(in == NULL) )
        return NULL;

    const char *psz_access, *psz_demux, *psz_path, *psz_anchor = NULL;

    assert( psz_mrl );
    char *psz_dup = strdup( psz_mrl );
    char *psz_demux_var = NULL;

    if( psz_dup == NULL )
    {
        vlc_object_release( in );
        return NULL;
    }

    /* Split uri */
    input_SplitMRL( &psz_access, &psz_demux, &psz_path, &psz_anchor, psz_dup );

    if( psz_demux == NULL || psz_demux[0] == '\0' )
        psz_demux = psz_demux_var = var_InheritString( in, ""demux"" );

    if( psz_forced_demux != NULL )
        psz_demux = psz_forced_demux;

    if( psz_demux == NULL )
        psz_demux = ""any"";

    msg_Dbg( p_input, ""`%s' gives access `%s' demux `%s' path `%s'"",
             psz_mrl, psz_access, psz_demux, psz_path );

    if( input_...",1,,2655,5,,void
60649,BLOCK,-1,,<empty>,9,,2660,2,,void
60674,BLOCK,-1,,"{
        vlc_object_release( in );
        return NULL;
    }",5,,2669,2,,void
60699,BLOCK,-1,,<empty>,9,,2678,2,,void
60711,BLOCK,-1,,<empty>,9,,2681,2,,void
60719,BLOCK,-1,,<empty>,9,,2684,2,,void
60737,BLOCK,-1,,"{   /* On master stream only, use input-list */
        char *str = var_InheritString( p_input, ""input-list"" );
        if( str != NULL )
        {
            char *list;

            var_Create( p_input, ""concat-list"", VLC_VAR_STRING );
            if( likely(asprintf( &list, ""%s://%s,%s"", psz_access, psz_path,
                                 str ) >= 0) )
            {
                 var_SetString( p_input, ""concat-list"", list );
                 free( list );
            }
            free( str );
            psz_access = ""concat"";
        }
    }",5,,2690,2,,void
60748,BLOCK,-1,,"{
            char *list;

            var_Create( p_input, ""concat-list"", VLC_VAR_STRING );
            if( likely(asprintf( &list, ""%s://%s,%s"", psz_access, psz_path,
                                 str ) >= 0) )
            {
                 var_SetString( p_input, ""concat-list"", list );
                 free( list );
            }
            free( str );
            psz_access = ""concat"";
        }",9,,2693,2,,void
60765,BLOCK,-1,,"{
                 var_SetString( p_input, ""concat-list"", list );
                 free( list );
            }",13,,2699,2,,void
60781,BLOCK,-1,,"{   /* Autodetect extra files if none specified */
        int count;
        char **tab;

        TAB_INIT( count, tab );
        InputGetExtraFiles( p_input, &count, &tab, &psz_access, psz_path );
        if( count > 0 )
        {
            char *list = NULL;

            for( int i = 0; i < count; i++ )
            {
                char *str;
                if( asprintf( &str, ""%s,%s"", list ? list : psz_mrl,
                              tab[i] ) < 0 )
                    break;

                free( tab[i] );
                free( list );
                list = str;
            }

            var_Create( p_input, ""concat-list"", VLC_VAR_STRING );
            if( likely(list != NULL) )
            {
                var_SetString( p_input, ""concat-list"", list );
                free( list );
            }
        }
        TAB_CLEAN( count, tab );
    }",5,,2709,2,,void
60800,BLOCK,-1,,"{
            char *list = NULL;

            for( int i = 0; i < count; i++ )
            {
                char *str;
                if( asprintf( &str, ""%s,%s"", list ? list : psz_mrl,
                              tab[i] ) < 0 )
                    break;

                free( tab[i] );
                free( list );
                list = str;
            }

            var_Create( p_input, ""concat-list"", VLC_VAR_STRING );
            if( likely(list != NULL) )
            {
                var_SetString( p_input, ""concat-list"", list );
                free( list );
            }
        }",9,,2716,2,,void
60806,BLOCK,-1,,<empty>,13,,2719,1,,void
60816,BLOCK,4,,"{
                char *str;
                if( asprintf( &str, ""%s,%s"", list ? list : psz_mrl,
                              tab[i] ) < 0 )
                    break;

                free( tab[i] );
                free( list );
                list = str;
            }",13,,2720,4,,void
60832,BLOCK,-1,,<empty>,21,,2724,2,,void
60852,BLOCK,-1,,"{
                var_SetString( p_input, ""concat-list"", list );
                free( list );
            }",13,,2733,2,,void
60883,BLOCK,-1,,"{
        if( !b_in_can_fail && !input_Stopped( p_input ) )
            vlc_dialog_display_error( p_input, _(""Your input can't be opened""),
                                      _(""VLC is unable to open the MRL '%s'.""
                                      "" Check the log for details.""), psz_mrl );
        vlc_object_release( in );
        return NULL;
    }",5,,2748,2,,void
60891,BLOCK,-1,,<empty>,13,,2750,2,,void
60911,BLOCK,-1,,"{
        const char* psz_renderer_demux = vlc_renderer_item_demux_filter(
                    priv->p_renderer );
        if( psz_renderer_demux )
            psz_demux_chain = strdup( psz_renderer_demux );
    }",5,,2759,2,,void
60921,BLOCK,-1,,<empty>,13,,2763,2,,void
60929,BLOCK,-1,,<empty>,9,,2766,2,,void
60939,BLOCK,-1,,"{
        in->p_demux = demux_FilterChainNew( in->p_demux, psz_demux_chain );
        free( psz_demux_chain );

        if( in->p_demux == NULL )
        {
            msg_Err(p_input, ""Failed to create demux filter"");
            vlc_object_release( in );
            return NULL;
        }
    }",5,,2768,2,,void
60957,BLOCK,-1,,"{
            msg_Err(p_input, ""Failed to create demux filter"");
            vlc_object_release( in );
            return NULL;
        }",9,,2773,2,,void
60974,BLOCK,-1,,<empty>,9,,2783,2,,void
60992,BLOCK,-1,,<empty>,9,,2788,2,,void
61016,BLOCK,-1,,"{
        if( demux_Control( in->p_demux, DEMUX_CAN_CONTROL_RATE,
                           &in->b_can_rate_control ) )
        {
            in->b_can_rate_control = false;
            in->b_rescale_ts = true;
        }
        else
            in->b_rescale_ts = !in->b_can_rate_control;
    }",5,,2793,2,,void
61027,BLOCK,-1,,"{
            in->b_can_rate_control = false;
            in->b_rescale_ts = true;
        }",9,,2796,2,,void
61039,BLOCK,-1,,<empty>,13,,2801,1,,void
61049,BLOCK,-1,,"{
        in->b_can_rate_control = true;
        in->b_rescale_ts = true;
    }",5,,2804,1,,void
61117,BLOCK,-1,,<empty>,9,,2817,2,,void
61135,BLOCK,-1,,"{
        if( demux_Control( in->p_demux, DEMUX_GET_TITLE_INFO,
                           &in->title, &in->i_title,
                           &in->i_title_offset, &in->i_seekpoint_offset ))
        {
            TAB_INIT( in->i_title, in->title );
        }
        else
        {
            in->b_title_demux = true;
        }

        int i_attachment;
        input_attachment_t **attachment;
        if( !demux_Control( in->p_demux, DEMUX_GET_ATTACHMENTS,
                             &attachment, &i_attachment ) )
        {
            vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
            AppendAttachment( &input_priv(p_input)->i_attachment, &input_priv(p_input)->attachment, &input_priv(p_input)->attachment_demux,
                              i_attachment, attachment, in->p_demux );
            vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );
        }

        demux_Control( in->p_demux, DEMUX_GET_PTS_DELAY, &in->i_pts_delay );
        if( in->i_pts_delay > I...",5,,2829,2,,void
61158,BLOCK,-1,,"{
            TAB_INIT( in->i_title, in->title );
        }",9,,2833,2,,void
61167,BLOCK,-1,,"{
            in->b_title_demux = true;
        }",9,,2837,1,,void
61186,BLOCK,-1,,"{
            vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
            AppendAttachment( &input_priv(p_input)->i_attachment, &input_priv(p_input)->attachment, &input_priv(p_input)->attachment_demux,
                              i_attachment, attachment, in->p_demux );
            vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );
        }",9,,2845,2,,void
61239,BLOCK,1,,<empty>,,,,1,,void
61242,BLOCK,-1,,<empty>,13,,2854,2,,void
61248,BLOCK,1,,<empty>,,,,1,,void
61252,BLOCK,-1,,<empty>,14,,2855,1,,void
61259,BLOCK,-1,,<empty>,13,,2856,2,,void
61275,BLOCK,-1,,<empty>,9,,2860,2,,void
61288,BLOCK,-1,,<empty>,9,,2863,2,,void
61303,BLOCK,-1,,"{
    int i;

    if( in->p_demux )
        demux_Delete( in->p_demux );

    if( in->i_title > 0 )
    {
        for( i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
    }

    vlc_object_release( in );
}",1,,2872,2,,void
61309,BLOCK,-1,,<empty>,9,,2876,2,,void
61320,BLOCK,-1,,"{
        for( i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
    }",5,,2879,2,,void
61322,BLOCK,-1,,<empty>,9,,2880,1,,void
61354,BLOCK,-1,,"{
    demux_t *p_demux = p_source->p_demux;

    /* XXX Remember that checking against p_item->p_meta->i_status & ITEM_PREPARSED
     * is a bad idea */

    bool has_meta = false;

    /* Read demux meta */
    if( !demux_Control( p_demux, DEMUX_GET_META, p_meta ) )
        has_meta = true;

    bool has_unsupported;
    if( demux_Control( p_demux, DEMUX_HAS_UNSUPPORTED_META, &has_unsupported ) )
        has_unsupported = true;

    /* If the demux report unsupported meta data, or if we don't have meta data
     * try an external ""meta reader"" */
    if( has_meta && !has_unsupported )
        return;

    demux_meta_t *p_demux_meta =
        vlc_custom_create( p_source, sizeof( *p_demux_meta ), ""demux meta"" );
    if( unlikely(p_demux_meta == NULL) )
        return;
    p_demux_meta->p_item = input_priv(p_input)->p_item;

    module_t *p_id3 = module_need( p_demux_meta, ""meta reader"", NULL, false );
    if( p_id3 )
    {
        if( p_demux_meta->p_meta )
        {
            vlc_...",1,,2893,4,,void
61371,BLOCK,-1,,<empty>,9,,2903,2,,void
61382,BLOCK,-1,,<empty>,9,,2907,2,,void
61391,BLOCK,-1,,<empty>,9,,2912,2,,void
61407,BLOCK,-1,,<empty>,9,,2917,2,,void
61427,BLOCK,-1,,"{
        if( p_demux_meta->p_meta )
        {
            vlc_meta_Merge( p_meta, p_demux_meta->p_meta );
            vlc_meta_Delete( p_demux_meta->p_meta );
        }

        if( p_demux_meta->i_attachments > 0 )
        {
            vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
            AppendAttachment( &input_priv(p_input)->i_attachment, &input_priv(p_input)->attachment, &input_priv(p_input)->attachment_demux,
                              p_demux_meta->i_attachments, p_demux_meta->attachments, p_demux);
            vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );
        }
        module_unneed( p_demux, p_id3 );
    }",5,,2922,2,,void
61432,BLOCK,-1,,"{
            vlc_meta_Merge( p_meta, p_demux_meta->p_meta );
            vlc_meta_Delete( p_demux_meta->p_meta );
        }",9,,2924,2,,void
61448,BLOCK,-1,,"{
            vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
            AppendAttachment( &input_priv(p_input)->i_attachment, &input_priv(p_input)->attachment, &input_priv(p_input)->attachment_demux,
                              p_demux_meta->i_attachments, p_demux_meta->attachments, p_demux);
            vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );
        }",9,,2930,2,,void
61497,BLOCK,-1,,"{
    int64_t i_time;
    int i;

    if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_GET_TIME, &i_time ) )
    {
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }

    for( i = 0; i < input_priv(p_input)->i_slave; i++ )
    {
        input_source_t *in = input_priv(p_input)->slave[i];
        int i_ret;

        if( in->b_eof )
            continue;

        /* Call demux_Demux until we have read enough data */
        if( demux_Control( in->p_demux, DEMUX_SET_NEXT_DEMUX_TIME, i_time ) )
        {
            for( ;; )
            {
                int64_t i_stime;
                if( demux_Control( in->p_demux, DEMUX_GET_TIME, &i_stime ) )
                {
                    msg_Err( p_input, ""slave[%d] doesn't like ""
                             ""DEMUX_GET_TIME -> EOF"", i );
                    i_ret = 0;
                    break;
                }

                if( i_stime >= i_time )
                {
                   ...",1,,2943,2,,void
61511,BLOCK,-1,,"{
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }",5,,2948,2,,void
61517,BLOCK,-1,,<empty>,5,,2953,1,,void
61529,BLOCK,4,,"{
        input_source_t *in = input_priv(p_input)->slave[i];
        int i_ret;

        if( in->b_eof )
            continue;

        /* Call demux_Demux until we have read enough data */
        if( demux_Control( in->p_demux, DEMUX_SET_NEXT_DEMUX_TIME, i_time ) )
        {
            for( ;; )
            {
                int64_t i_stime;
                if( demux_Control( in->p_demux, DEMUX_GET_TIME, &i_stime ) )
                {
                    msg_Err( p_input, ""slave[%d] doesn't like ""
                             ""DEMUX_GET_TIME -> EOF"", i );
                    i_ret = 0;
                    break;
                }

                if( i_stime >= i_time )
                {
                    i_ret = 1;
                    break;
                }

                if( ( i_ret = demux_Demux( in->p_demux ) ) <= 0 )
                    break;
            }
        }
        else
        {
            i_ret = demux_Demux( in->p_demux );
        }

        if( i_ret <=...",5,,2954,4,,void
61544,BLOCK,-1,,<empty>,13,,2959,2,,void
61553,BLOCK,-1,,"{
            for( ;; )
            {
                int64_t i_stime;
                if( demux_Control( in->p_demux, DEMUX_GET_TIME, &i_stime ) )
                {
                    msg_Err( p_input, ""slave[%d] doesn't like ""
                             ""DEMUX_GET_TIME -> EOF"", i );
                    i_ret = 0;
                    break;
                }

                if( i_stime >= i_time )
                {
                    i_ret = 1;
                    break;
                }

                if( ( i_ret = demux_Demux( in->p_demux ) ) <= 0 )
                    break;
            }
        }",9,,2963,2,,void
61555,BLOCK,-1,,<empty>,13,,2964,1,,void
61556,BLOCK,4,,"{
                int64_t i_stime;
                if( demux_Control( in->p_demux, DEMUX_GET_TIME, &i_stime ) )
                {
                    msg_Err( p_input, ""slave[%d] doesn't like ""
                             ""DEMUX_GET_TIME -> EOF"", i );
                    i_ret = 0;
                    break;
                }

                if( i_stime >= i_time )
                {
                    i_ret = 1;
                    break;
                }

                if( ( i_ret = demux_Demux( in->p_demux ) ) <= 0 )
                    break;
            }",13,,2965,4,,void
61566,BLOCK,-1,,"{
                    msg_Err( p_input, ""slave[%d] doesn't like ""
                             ""DEMUX_GET_TIME -> EOF"", i );
                    i_ret = 0;
                    break;
                }",17,,2968,2,,void
61579,BLOCK,-1,,"{
                    i_ret = 1;
                    break;
                }",17,,2976,2,,void
61593,BLOCK,-1,,<empty>,21,,2982,2,,void
61596,BLOCK,-1,,"{
            i_ret = demux_Demux( in->p_demux );
        }",9,,2986,1,,void
61607,BLOCK,-1,,"{
            msg_Dbg( p_input, ""slave %d EOF"", i );
            in->b_eof = true;
        }",9,,2991,2,,void
61621,BLOCK,-1,,"{
    int64_t i_time;
    int i;

    if( demux_Control( input_priv(p_input)->master->p_demux, DEMUX_GET_TIME, &i_time ) )
    {
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }

    for( i = 0; i < input_priv(p_input)->i_slave; i++ )
    {
        input_source_t *in = input_priv(p_input)->slave[i];

        if( demux_Control( in->p_demux, DEMUX_SET_TIME, i_time, true ) )
        {
            if( !in->b_eof )
                msg_Err( p_input, ""seek failed for slave %d -> EOF"", i );
            in->b_eof = true;
        }
        else
        {
            in->b_eof = false;
        }
    }
}",1,,2999,2,,void
61635,BLOCK,-1,,"{
        msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
        return;
    }",5,,3004,2,,void
61641,BLOCK,-1,,<empty>,5,,3009,1,,void
61653,BLOCK,4,,"{
        input_source_t *in = input_priv(p_input)->slave[i];

        if( demux_Control( in->p_demux, DEMUX_SET_TIME, i_time, true ) )
        {
            if( !in->b_eof )
                msg_Err( p_input, ""seek failed for slave %d -> EOF"", i );
            in->b_eof = true;
        }
        else
        {
            in->b_eof = false;
        }
    }",5,,3010,4,,void
61671,BLOCK,-1,,"{
            if( !in->b_eof )
                msg_Err( p_input, ""seek failed for slave %d -> EOF"", i );
            in->b_eof = true;
        }",9,,3014,2,,void
61677,BLOCK,-1,,<empty>,17,,3016,2,,void
61688,BLOCK,-1,,"{
            in->b_eof = false;
        }",9,,3020,1,,void
61699,BLOCK,-1,,"{
    static const struct { int i_meta; const char *psz_name; } p_list[] = {
        { vlc_meta_Title,       ""meta-title"" },
        { vlc_meta_Artist,      ""meta-artist"" },
        { vlc_meta_Genre,       ""meta-genre"" },
        { vlc_meta_Copyright,   ""meta-copyright"" },
        { vlc_meta_Description, ""meta-description"" },
        { vlc_meta_Date,        ""meta-date"" },
        { vlc_meta_URL,         ""meta-url"" },
        { 0, NULL }
    };

    /* Get meta information from user */
    for( int i = 0; p_list[i].psz_name; i++ )
    {
        char *psz_string = var_GetNonEmptyString( p_input, p_list[i].psz_name );
        if( !psz_string )
            continue;

        EnsureUTF8( psz_string );
        vlc_meta_Set( p_meta, p_list[i].i_meta, psz_string );
        free( psz_string );
    }
}",1,,3030,3,,void
61729,BLOCK,-1,,<empty>,5,,3043,1,,void
61741,BLOCK,4,,"{
        char *psz_string = var_GetNonEmptyString( p_input, p_list[i].psz_name );
        if( !psz_string )
            continue;

        EnsureUTF8( psz_string );
        vlc_meta_Set( p_meta, p_list[i].i_meta, psz_string );
        free( psz_string );
    }",5,,3044,4,,void
61755,BLOCK,-1,,<empty>,13,,3047,2,,void
61778,BLOCK,-1,,"{
    int i_attachment = *pi_attachment;
    int i;

    input_attachment_t **pp_att = realloc( *ppp_attachment,
                    sizeof(*pp_att) * ( i_attachment + i_new ) );
    if( likely(pp_att) )
    {
        *ppp_attachment = pp_att;
        const demux_t **pp_attdmx = realloc( *ppp_attachment_demux,
                        sizeof(*pp_attdmx) * ( i_attachment + i_new ) );
        if( likely(pp_attdmx) )
        {
            *ppp_attachment_demux = pp_attdmx;

            for( i = 0; i < i_new; i++ )
            {
                pp_att[i_attachment] = pp_new[i];
                pp_attdmx[i_attachment++] = p_demux;
            }
            /* */
            *pi_attachment = i_attachment;
            free( pp_new );
            return;
        }
    }

    /* on alloc errors */
    for( i = 0; i < i_new; i++ )
        vlc_input_attachment_Delete( pp_new[i] );
    free( pp_new );
}",1,,3058,7,,void
61801,BLOCK,-1,,"{
        *ppp_attachment = pp_att;
        const demux_t **pp_attdmx = realloc( *ppp_attachment_demux,
                        sizeof(*pp_attdmx) * ( i_attachment + i_new ) );
        if( likely(pp_attdmx) )
        {
            *ppp_attachment_demux = pp_attdmx;

            for( i = 0; i < i_new; i++ )
            {
                pp_att[i_attachment] = pp_new[i];
                pp_attdmx[i_attachment++] = p_demux;
            }
            /* */
            *pi_attachment = i_attachment;
            free( pp_new );
            return;
        }
    }",5,,3065,2,,void
61822,BLOCK,-1,,"{
            *ppp_attachment_demux = pp_attdmx;

            for( i = 0; i < i_new; i++ )
            {
                pp_att[i_attachment] = pp_new[i];
                pp_attdmx[i_attachment++] = p_demux;
            }
            /* */
            *pi_attachment = i_attachment;
            free( pp_new );
            return;
        }",9,,3070,2,,void
61828,BLOCK,-1,,<empty>,13,,3073,1,,void
61837,BLOCK,4,,"{
                pp_att[i_attachment] = pp_new[i];
                pp_attdmx[i_attachment++] = p_demux;
            }",13,,3074,4,,void
61859,BLOCK,-1,,<empty>,5,,3086,1,,void
61879,BLOCK,-1,,"{
    vlc_meta_t *p_meta = vlc_meta_New();
    if( unlikely(p_meta == NULL) )
        return;

    demux_Control( p_demux, DEMUX_GET_META, p_meta );

    /* If metadata changed, then the attachments might have changed.
       We need to update them in case they contain album art. */
    input_attachment_t **attachment;
    int i_attachment;

    if( !demux_Control( p_demux, DEMUX_GET_ATTACHMENTS,
                        &attachment, &i_attachment ) )
    {
        vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
        if( input_priv(p_input)->i_attachment > 0 )
        {
            int j = 0;
            for( int i = 0; i < input_priv(p_input)->i_attachment; i++ )
            {
                if( input_priv(p_input)->attachment_demux[i] == p_demux )
                    vlc_input_attachment_Delete( input_priv(p_input)->attachment[i] );
                else
                {
                    input_priv(p_input)->attachment[j] = input_priv(p_input)->attachment[i];
         ...",1,,3096,3,,void
61889,BLOCK,-1,,<empty>,9,,3099,2,,void
61906,BLOCK,-1,,"{
        vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
        if( input_priv(p_input)->i_attachment > 0 )
        {
            int j = 0;
            for( int i = 0; i < input_priv(p_input)->i_attachment; i++ )
            {
                if( input_priv(p_input)->attachment_demux[i] == p_demux )
                    vlc_input_attachment_Delete( input_priv(p_input)->attachment[i] );
                else
                {
                    input_priv(p_input)->attachment[j] = input_priv(p_input)->attachment[i];
                    input_priv(p_input)->attachment_demux[j] = input_priv(p_input)->attachment_demux[i];
                    j++;
                }
            }
            input_priv(p_input)->i_attachment = j;
        }
        AppendAttachment( &input_priv(p_input)->i_attachment, &input_priv(p_input)->attachment, &input_priv(p_input)->attachment_demux,
                          i_attachment, attachment, p_demux );
        vlc_mutex_unlock( &input_priv(p_input)...",5,,3110,2,,void
61922,BLOCK,-1,,"{
            int j = 0;
            for( int i = 0; i < input_priv(p_input)->i_attachment; i++ )
            {
                if( input_priv(p_input)->attachment_demux[i] == p_demux )
                    vlc_input_attachment_Delete( input_priv(p_input)->attachment[i] );
                else
                {
                    input_priv(p_input)->attachment[j] = input_priv(p_input)->attachment[i];
                    input_priv(p_input)->attachment_demux[j] = input_priv(p_input)->attachment_demux[i];
                    j++;
                }
            }
            input_priv(p_input)->i_attachment = j;
        }",9,,3113,2,,void
61928,BLOCK,-1,,<empty>,13,,3115,1,,void
61941,BLOCK,4,,"{
                if( input_priv(p_input)->attachment_demux[i] == p_demux )
                    vlc_input_attachment_Delete( input_priv(p_input)->attachment[i] );
                else
                {
                    input_priv(p_input)->attachment[j] = input_priv(p_input)->attachment[i];
                    input_priv(p_input)->attachment_demux[j] = input_priv(p_input)->attachment_demux[i];
                    j++;
                }
            }",13,,3116,4,,void
61951,BLOCK,-1,,<empty>,21,,3118,2,,void
61960,BLOCK,-1,,"{
                    input_priv(p_input)->attachment[j] = input_priv(p_input)->attachment[i];
                    input_priv(p_input)->attachment_demux[j] = input_priv(p_input)->attachment_demux[i];
                    j++;
                }",17,,3120,1,,void
62041,BLOCK,-1,,"{
    int i_list;
    char **ppsz_list;
    TAB_INIT( i_list, ppsz_list );

    char *psz_base = strdup( psz_path );
    if( !psz_base )
        goto exit;

    /* Remove the extension */
    char *psz_end = &psz_base[strlen(psz_base)-strlen(psz_match)];
    assert( psz_end >= psz_base);
    *psz_end = '\0';

    /* Try to list files */
    for( int i = i_start; i <= i_stop; i++ )
    {
        char *psz_probe;
        if( asprintf( &psz_probe, psz_format, psz_base, i ) < 0 )
            break;

        char *filepath = get_path( psz_probe );

        struct stat st;
        if( filepath == NULL ||
            vlc_stat( filepath, &st ) || !S_ISREG( st.st_mode ) || !st.st_size )
        {
            free( filepath );
            free( psz_probe );
            break;
        }

        msg_Dbg( p_input, ""Detected extra file `%s'"", filepath );

        char* psz_uri = vlc_path2uri( filepath, NULL );
        if( psz_uri )
            TAB_APPEND( i_list, ppsz_list, psz_uri );

        f...",1,,3147,9,,void
62055,BLOCK,-1,,<empty>,9,,3154,2,,void
62077,BLOCK,-1,,<empty>,5,,3162,1,,void
62087,BLOCK,4,,"{
        char *psz_probe;
        if( asprintf( &psz_probe, psz_format, psz_base, i ) < 0 )
            break;

        char *filepath = get_path( psz_probe );

        struct stat st;
        if( filepath == NULL ||
            vlc_stat( filepath, &st ) || !S_ISREG( st.st_mode ) || !st.st_size )
        {
            free( filepath );
            free( psz_probe );
            break;
        }

        msg_Dbg( p_input, ""Detected extra file `%s'"", filepath );

        char* psz_uri = vlc_path2uri( filepath, NULL );
        if( psz_uri )
            TAB_APPEND( i_list, ppsz_list, psz_uri );

        free( filepath );
        free( psz_probe );
    }",5,,3163,4,,void
62098,BLOCK,-1,,<empty>,13,,3166,2,,void
62126,BLOCK,-1,,"{
            free( filepath );
            free( psz_probe );
            break;
        }",9,,3173,2,,void
62144,BLOCK,-1,,<empty>,13,,3183,2,,void
62172,BLOCK,-1,,"{
    static const struct pattern
    {
        const char *psz_access_force;
        const char *psz_match;
        const char *psz_format;
        int i_start;
        int i_stop;
    } patterns[] = {
        /* XXX the order is important */
        { ""concat"", "".001"", ""%s.%.3d"", 2, 999 },
        { NULL, "".part1.rar"",""%s.part%.1d.rar"", 2, 9 },
        { NULL, "".part01.rar"",""%s.part%.2d.rar"", 2, 99, },
        { NULL, "".part001.rar"", ""%s.part%.3d.rar"", 2, 999 },
        { NULL, "".rar"", ""%s.r%.2d"", 0, 99 },
        { ""concat"", "".mts"", ""%s.mts%d"", 1, 999 },
    };

    TAB_INIT( *pi_list, *pppsz_list );

    if( ( **ppsz_access && strcmp( *ppsz_access, ""file"" ) ) || !psz_path )
        return;

    const size_t i_path = strlen(psz_path);

    for( size_t i = 0; i < ARRAY_SIZE( patterns ); ++i )
    {
        const struct pattern* pat = &patterns[i];
        const size_t i_ext = strlen( pat->psz_match );

        if( i_path < i_ext )
            continue;

        if( !strcmp( &psz_p...",1,,3197,6,,void
62230,BLOCK,-1,,<empty>,9,,3218,2,,void
62238,BLOCK,-1,,<empty>,5,,3222,1,,void
62249,BLOCK,4,,"{
        const struct pattern* pat = &patterns[i];
        const size_t i_ext = strlen( pat->psz_match );

        if( i_path < i_ext )
            continue;

        if( !strcmp( &psz_path[i_path-i_ext], pat->psz_match ) )
        {
            InputGetExtraFilesPattern( p_input, pi_list, pppsz_list, psz_path,
                pat->psz_match, pat->psz_format, pat->i_start, pat->i_stop );

            if( *pi_list > 0 && pat->psz_access_force )
                *ppsz_access = pat->psz_access_force;
            return;
        }
    }",5,,3223,4,,void
62268,BLOCK,-1,,<empty>,13,,3228,2,,void
62282,BLOCK,-1,,"{
            InputGetExtraFilesPattern( p_input, pi_list, pppsz_list, psz_path,
                pat->psz_match, pat->psz_format, pat->i_start, pat->i_stop );

            if( *pi_list > 0 && pat->psz_access_force )
                *ppsz_access = pat->psz_access_force;
            return;
        }",9,,3231,2,,void
62309,BLOCK,-1,,<empty>,17,,3236,2,,void
62322,BLOCK,-1,,"{
    if( input_priv(p_input)->i_state == i_state )
        return;

    input_priv(p_input)->i_state = i_state;
    if( i_state == ERROR_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, true );
    else if ( i_state == PLAYING_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, false );
    input_SendEventState( p_input, i_state );
}",1,,3244,3,,void
62330,BLOCK,-1,,<empty>,9,,3246,2,,void
62342,BLOCK,-1,,<empty>,9,,3250,2,,void
62350,BLOCK,-1,,<empty>,10,,3251,1,,void
62355,BLOCK,-1,,<empty>,9,,3252,2,,void
62373,BLOCK,-1,,"{
    char *p;

    /* Separate <path> from <access>[/<demux>]:// */
    p = strstr( buf, ""://"" );
    if( p != NULL )
    {
        *p = '\0';
        p += 3; /* skips ""://"" */
        *path = p;

        /* Remove HTML anchor if present (not supported).
         * The hash symbol itself should be URI-encoded. */
        p = strchr( p, '#' );
        if( p != NULL )
        {
            *(p++) = '\0';
            *anchor = p;
        }
        else
            *anchor = """";
    }
    else
    {
#ifndef NDEBUG
        fprintf( stderr, ""%s(\""%s\"") probably not a valid URI!\n"", __func__,
                 buf );
#endif
        /* Note: this is a valid non const pointer to """": */
        *path = buf + strlen( buf );
    }

    /* Separate access from demux */
    p = strchr( buf, '/' );
    if( p != NULL )
    {
        *(p++) = '\0';
        if( p[0] == '$' )
            p++;
        *demux = p;
    }
    else
        *demux = """";

    /* We really don't want module name substitution ...",1,,3263,6,,void
62384,BLOCK,-1,,"{
        *p = '\0';
        p += 3; /* skips ""://"" */
        *path = p;

        /* Remove HTML anchor if present (not supported).
         * The hash symbol itself should be URI-encoded. */
        p = strchr( p, '#' );
        if( p != NULL )
        {
            *(p++) = '\0';
            *anchor = p;
        }
        else
            *anchor = """";
    }",5,,3269,2,,void
62405,BLOCK,-1,,"{
            *(p++) = '\0';
            *anchor = p;
        }",9,,3278,2,,void
62416,BLOCK,-1,,<empty>,13,,3283,1,,void
62422,BLOCK,-1,,"{
#ifndef NDEBUG
        fprintf( stderr, ""%s(\""%s\"") probably not a valid URI!\n"", __func__,
                 buf );
#endif
        /* Note: this is a valid non const pointer to """": */
        *path = buf + strlen( buf );
    }",5,,3286,1,,void
62444,BLOCK,-1,,"{
        *(p++) = '\0';
        if( p[0] == '$' )
            p++;
        *demux = p;
    }",5,,3298,2,,void
62456,BLOCK,-1,,<empty>,13,,3301,2,,void
62464,BLOCK,-1,,<empty>,9,,3305,1,,void
62478,BLOCK,-1,,<empty>,9,,3310,2,,void
62491,BLOCK,-1,,"{
    char *end;
    unsigned long u;

    /* Look for the title */
    u = strtoul( str, &end, 0 );
    *title = (str == end || u > (unsigned long)INT_MAX) ? -1 : (int)u;
    str = end;

    /* Look for the chapter */
    if( *str == ':' )
    {
        str++;
        u = strtoul( str, &end, 0 );
        *chapter = (str == end || u > (unsigned long)INT_MAX) ? -1 : (int)u;
        str = end;
    }
    else
        *chapter = -1;

    return str;
}",1,,3315,4,,void
62527,BLOCK,-1,,"{
        str++;
        u = strtoul( str, &end, 0 );
        *chapter = (str == end || u > (unsigned long)INT_MAX) ? -1 : (int)u;
        str = end;
    }",5,,3326,2,,void
62559,BLOCK,-1,,<empty>,9,,3333,1,,void
62575,BLOCK,-1,,"{
    *pi_title_start = *pi_title_end = *pi_chapter_start = *pi_chapter_end = -1;

    int title_start, chapter_start, title_end, chapter_end;

    if( !p )
        return;

    if( *p != '-' )
        p = MRLSeekPoint( p, &title_start, &chapter_start );
    else
        title_start = chapter_start = -1;

    if( *p == '-' )
        p = MRLSeekPoint( p + 1, &title_end, &chapter_end );
    else
        title_end = chapter_end = -1;

    if( *p ) /* syntax error */
        return;

    *pi_title_start = title_start;
    *pi_title_end = title_end;
    *pi_chapter_start = chapter_start;
    *pi_chapter_end = chapter_end;
}",1,,3348,6,,void
62597,BLOCK,-1,,<empty>,9,,3354,2,,void
62604,BLOCK,-1,,<empty>,9,,3357,2,,void
62614,BLOCK,-1,,<empty>,9,,3359,1,,void
62626,BLOCK,-1,,<empty>,9,,3362,2,,void
62638,BLOCK,-1,,<empty>,9,,3364,1,,void
62648,BLOCK,-1,,<empty>,9,,3367,2,,void
62673,BLOCK,-1,,"{
    vlc_value_t count;
    const char *psz_es;
    const char *psz_forced_demux;
    const bool b_can_fail = i_flags & SLAVE_ADD_CANFAIL;
    const bool b_forced = i_flags & SLAVE_ADD_FORCED;
    const bool b_set_time = i_flags & SLAVE_ADD_SET_TIME;

    switch( i_type )
    {
    case SLAVE_TYPE_SPU:
        psz_es = ""spu-es"";
        psz_forced_demux = ""subtitle"";
        break;
    case SLAVE_TYPE_AUDIO:
        psz_es = ""audio-es"";
        psz_forced_demux = NULL;
        break;
    default:
        vlc_assert_unreachable();
    }

    if( b_forced )
        var_Change( p_input, psz_es, VLC_VAR_CHOICESCOUNT, &count, NULL );

    msg_Dbg( p_input, ""loading %s slave: %s (forced: %d)"", psz_es, psz_uri,
             b_forced );

    input_source_t *p_source = InputSourceNew( p_input, psz_uri,
                                               psz_forced_demux,
                                               b_can_fail || psz_forced_demux );

    if( psz_forced_demux && p_source == NULL...",1,,3378,5,,void
62683,BLOCK,1,,<empty>,,,,1,,void
62693,BLOCK,1,,<empty>,,,,1,,void
62703,BLOCK,1,,<empty>,,,,1,,void
62709,BLOCK,-1,,"{
    case SLAVE_TYPE_SPU:
        psz_es = ""spu-es"";
        psz_forced_demux = ""subtitle"";
        break;
    case SLAVE_TYPE_AUDIO:
        psz_es = ""audio-es"";
        psz_forced_demux = NULL;
        break;
    default:
        vlc_assert_unreachable();
    }",5,,3387,2,,void
62732,BLOCK,-1,,<empty>,9,,3401,2,,void
62762,BLOCK,-1,,<empty>,9,,3411,2,,void
62774,BLOCK,-1,,"{
        msg_Warn( p_input, ""failed to add %s as slave"", psz_uri );
        return VLC_EGENERIC;
    }",5,,3414,2,,void
62785,BLOCK,-1,,"{
        if( b_set_time )
        {
            int64_t i_time;

            /* Set position */
            if( demux_Control( input_priv(p_input)->master->p_demux,
                               DEMUX_GET_TIME, &i_time ) )
            {
                msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
                InputSourceDestroy( p_source );
                return VLC_EGENERIC;
            }

            if( demux_Control( p_source->p_demux,
                               DEMUX_SET_TIME, i_time, true ) )
            {
                msg_Err( p_input, ""seek failed for new slave"" );
                InputSourceDestroy( p_source );
                return VLC_EGENERIC;
            }
        }

        /* Get meta (access and demux) */
        InputUpdateMeta( p_input, p_source->p_demux );
    }",5,,3420,2,,void
62788,BLOCK,-1,,"{
            int64_t i_time;

            /* Set position */
            if( demux_Control( input_priv(p_input)->master->p_demux,
                               DEMUX_GET_TIME, &i_time ) )
            {
                msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
                InputSourceDestroy( p_source );
                return VLC_EGENERIC;
            }

            if( demux_Control( p_source->p_demux,
                               DEMUX_SET_TIME, i_time, true ) )
            {
                msg_Err( p_input, ""seek failed for new slave"" );
                InputSourceDestroy( p_source );
                return VLC_EGENERIC;
            }
        }",9,,3422,2,,void
62801,BLOCK,-1,,"{
                msg_Err( p_input, ""demux doesn't like DEMUX_GET_TIME"" );
                InputSourceDestroy( p_source );
                return VLC_EGENERIC;
            }",13,,3428,2,,void
62817,BLOCK,-1,,"{
                msg_Err( p_input, ""seek failed for new slave"" );
                InputSourceDestroy( p_source );
                return VLC_EGENERIC;
            }",13,,3436,2,,void
62843,BLOCK,-1,,<empty>,9,,3450,2,,void
62855,BLOCK,-1,,<empty>,9,,3456,2,,void
62864,BLOCK,-1,,<empty>,9,,3459,2,,void
62879,BLOCK,-1,,"{
        const int i_id = list.p_list->p_values[count.i_int].i_int;

        es_out_Control( input_priv(p_input)->p_es_out_display, ES_OUT_SET_ES_DEFAULT_BY_ID, i_id );
        es_out_Control( input_priv(p_input)->p_es_out_display, ES_OUT_SET_ES_BY_ID, i_id );
    }",5,,3463,2,,void
62919,BLOCK,-1,,"{
    /* if we are provided a subtitle.sub file,
     * see if we don't have a subtitle.idx and use it instead */
    char *psz_idxpath = NULL;
    char *psz_extension = strrchr( psz_subtitle, '.');
    if( psz_extension && strcmp( psz_extension, "".sub"" ) == 0 )
    {
        psz_idxpath = strdup( psz_subtitle );
        if( psz_idxpath )
        {
            struct stat st;

            psz_extension = psz_extension - psz_subtitle + psz_idxpath;
            strcpy( psz_extension, "".idx"" );

            if( !vlc_stat( psz_idxpath, &st ) && S_ISREG( st.st_mode ) )
            {
                msg_Dbg( p_input, ""using %s as subtitle file instead of %s"",
                         psz_idxpath, psz_subtitle );
                psz_subtitle = psz_idxpath;
            }
        }
    }

    char *psz_uri = vlc_path2uri( psz_subtitle, NULL );
    free( psz_idxpath );
    return psz_uri;
}",1,,3476,3,,void
62938,BLOCK,-1,,"{
        psz_idxpath = strdup( psz_subtitle );
        if( psz_idxpath )
        {
            struct stat st;

            psz_extension = psz_extension - psz_subtitle + psz_idxpath;
            strcpy( psz_extension, "".idx"" );

            if( !vlc_stat( psz_idxpath, &st ) && S_ISREG( st.st_mode ) )
            {
                msg_Dbg( p_input, ""using %s as subtitle file instead of %s"",
                         psz_idxpath, psz_subtitle );
                psz_subtitle = psz_idxpath;
            }
        }
    }",5,,3482,2,,void
62945,BLOCK,-1,,"{
            struct stat st;

            psz_extension = psz_extension - psz_subtitle + psz_idxpath;
            strcpy( psz_extension, "".idx"" );

            if( !vlc_stat( psz_idxpath, &st ) && S_ISREG( st.st_mode ) )
            {
                msg_Dbg( p_input, ""using %s as subtitle file instead of %s"",
                         psz_idxpath, psz_subtitle );
                psz_subtitle = psz_idxpath;
            }
        }",9,,3485,2,,void
62968,BLOCK,-1,,"{
                msg_Dbg( p_input, ""using %s as subtitle file instead of %s"",
                         psz_idxpath, psz_subtitle );
                psz_subtitle = psz_idxpath;
            }",13,,3492,2,,void
62993,BLOCK,-1,,"{
    assert( input_priv(p_input)->i_state != INIT_S );

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    switch( i_type )
    {
#define I(c) stats_Update( input_priv(p_input)->counters.c, i_delta, NULL )
    case INPUT_STATISTIC_DECODED_VIDEO:
        I(p_decoded_video);
        break;
    case INPUT_STATISTIC_DECODED_AUDIO:
        I(p_decoded_audio);
        break;
    case INPUT_STATISTIC_DECODED_SUBTITLE:
        I(p_decoded_sub);
        break;
    case INPUT_STATISTIC_SENT_PACKET:
        I(p_sout_sent_packets);
        break;
#undef I
    case INPUT_STATISTIC_SENT_BYTE:
    {
        uint64_t bytes;

        stats_Update( input_priv(p_input)->counters.p_sout_sent_bytes, i_delta, &bytes );
        stats_Update( input_priv(p_input)->counters.p_sout_send_bitrate, bytes, NULL );
        break;
    }
    default:
        msg_Err( p_input, ""Invalid statistic type %d (internal error)"", i_type );
        break;
    }
    vlc_mutex_unlock( &input_priv(p_input)->...",1,,3510,4,,void
63011,BLOCK,-1,,"{
#define I(c) stats_Update( input_priv(p_input)->counters.c, i_delta, NULL )
    case INPUT_STATISTIC_DECODED_VIDEO:
        I(p_decoded_video);
        break;
    case INPUT_STATISTIC_DECODED_AUDIO:
        I(p_decoded_audio);
        break;
    case INPUT_STATISTIC_DECODED_SUBTITLE:
        I(p_decoded_sub);
        break;
    case INPUT_STATISTIC_SENT_PACKET:
        I(p_sout_sent_packets);
        break;
#undef I
    case INPUT_STATISTIC_SENT_BYTE:
    {
        uint64_t bytes;

        stats_Update( input_priv(p_input)->counters.p_sout_sent_bytes, i_delta, &bytes );
        stats_Update( input_priv(p_input)->counters.p_sout_send_bitrate, bytes, NULL );
        break;
    }
    default:
        msg_Err( p_input, ""Invalid statistic type %d (internal error)"", i_type );
        break;
    }",5,,3515,2,,void
63015,BLOCK,1,,<empty>,,,,1,,void
63029,BLOCK,1,,<empty>,,,,1,,void
63043,BLOCK,1,,<empty>,,,,1,,void
63057,BLOCK,1,,<empty>,,,,1,,void
63070,BLOCK,19,,"{
        uint64_t bytes;

        stats_Update( input_priv(p_input)->counters.p_sout_sent_bytes, i_delta, &bytes );
        stats_Update( input_priv(p_input)->counters.p_sout_send_bitrate, bytes, NULL );
        break;
    }",5,,3531,19,,void
63113,BLOCK,-1,,"{
    char *path;
    char *filename = str_format(input, filenamefmt);
    if (unlikely(filename == NULL))
        return NULL;

    filename_sanitize(filename);

    if (((ext != NULL)
            ? asprintf(&path, ""%s""DIR_SEP""%s.%s"", dir, filename, ext)
            : asprintf(&path, ""%s""DIR_SEP""%s"", dir, filename)) < 0)
        path = NULL;

    free(filename);
    return path;
}",1,,3549,5,,void
63126,BLOCK,-1,,<empty>,9,,3553,2,,void
63133,BLOCK,-1,,<empty>,9,,3560,2,,void
63151,BLOCK,-1,,<empty>,1,,1,1,,ANY
63155,BLOCK,-1,,<empty>,,,,3,,<empty>
63161,BLOCK,-1,,<empty>,,,,3,,<empty>
63167,BLOCK,-1,,<empty>,,,,3,,<empty>
63173,BLOCK,-1,,<empty>,,,,3,,<empty>
63180,BLOCK,-1,,<empty>,,,,4,,<empty>
63186,BLOCK,-1,,<empty>,,,,3,,<empty>
63192,BLOCK,-1,,<empty>,,,,3,,<empty>
63198,BLOCK,-1,,<empty>,,,,3,,<empty>
63203,BLOCK,-1,,<empty>,,,,2,,<empty>
63209,BLOCK,-1,,<empty>,,,,3,,<empty>
63216,BLOCK,-1,,<empty>,,,,2,,<empty>
63221,BLOCK,-1,,<empty>,,,,2,,<empty>
63226,BLOCK,-1,,<empty>,,,,2,,<empty>
63240,BLOCK,-1,,<empty>,,,,4,,<empty>
63263,BLOCK,-1,,<empty>,1,,1,1,,ANY
63356,BLOCK,-1,,<empty>,,,,1,,<empty>
63359,BLOCK,1,,<empty>,,,,1,,void
63366,BLOCK,-1,,"{
    return container_of(input, input_thread_private_t, input);
}",1,,182,2,,void
63409,BLOCK,-1,,<empty>,,,,4,,<empty>
63414,BLOCK,-1,,<empty>,,,,2,,<empty>
63420,BLOCK,-1,,<empty>,,,,3,,<empty>
63425,BLOCK,-1,,<empty>,,,,2,,<empty>
63430,BLOCK,-1,,<empty>,,,,2,,<empty>
63435,BLOCK,-1,,<empty>,,,,2,,<empty>
63441,BLOCK,-1,,<empty>,,,,3,,<empty>
63446,BLOCK,-1,,<empty>,,,,2,,<empty>
63455,BLOCK,-1,,<empty>,,,,6,,<empty>
63460,BLOCK,-1,,<empty>,,,,2,,<empty>
63469,BLOCK,-1,,<empty>,,,,6,,<empty>
63475,BLOCK,-1,,<empty>,,,,3,,<empty>
63480,BLOCK,-1,,<empty>,,,,2,,<empty>
63513,BLOCK,-1,,<empty>,1,,1,1,,ANY
63520,BLOCK,-1,,<empty>,,,,1,,<empty>
63528,BLOCK,-1,,<empty>,,,,3,,<empty>
63534,BLOCK,-1,,"{
    bool b_changed;

    vlc_mutex_lock( &p_i->lock );

    b_changed = p_i->b_error_when_reading != b_error;
    p_i->b_error_when_reading = b_error;

    vlc_mutex_unlock( &p_i->lock );

    if( b_changed )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemErrorWhenReadingChanged,
            .u.input_item_error_when_reading_changed.new_value = b_error } );
    }
}",1,,52,3,,void
63560,BLOCK,-1,,"{
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemErrorWhenReadingChanged,
            .u.input_item_error_when_reading_changed.new_value = b_error } );
    }",5,,63,2,,void
63570,BLOCK,1,,<empty>,13,,65,1,,void
63574,BLOCK,2,,<empty>,13,,66,2,,void
63589,BLOCK,-1,,"{
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemPreparseEnded,
        .u.input_item_preparse_ended.new_status = status } );
}",1,,70,3,,void
63599,BLOCK,1,,<empty>,9,,72,1,,void
63603,BLOCK,2,,<empty>,9,,73,2,,void
63618,BLOCK,-1,,"{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);
    int new_status;
    if( b_preparsed )
        new_status = status | ITEM_PREPARSED;
    else
        new_status = status & ~ITEM_PREPARSED;
    if( status != new_status )
    {
        vlc_meta_SetStatus(p_i->p_meta, new_status);
        b_send_event = true;
    }

    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemPreparsedChanged,
            .u.input_item_preparsed_changed.new_status = new_status } );
    }
}",1,,77,3,,void
63633,BLOCK,-1,,<empty>,9,,83,2,,void
63649,BLOCK,-1,,<empty>,9,,88,2,,void
63656,BLOCK,-1,,<empty>,9,,90,1,,void
63667,BLOCK,-1,,"{
        vlc_meta_SetStatus(p_i->p_meta, new_status);
        b_send_event = true;
    }",5,,92,2,,void
63683,BLOCK,-1,,"{
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemPreparsedChanged,
            .u.input_item_preparsed_changed.new_status = new_status } );
    }",5,,100,2,,void
63693,BLOCK,1,,<empty>,13,,102,1,,void
63697,BLOCK,2,,<empty>,13,,103,2,,void
63712,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_not_found )
        status |= ITEM_ART_NOTFOUND;
    else
        status &= ~ITEM_ART_NOTFOUND;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",1,,108,3,,void
63723,BLOCK,-1,,<empty>,9,,112,2,,void
63738,BLOCK,-1,,<empty>,9,,117,2,,void
63743,BLOCK,-1,,<empty>,9,,119,1,,void
63763,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_art_fetched )
        status |= ITEM_ART_FETCHED;
    else
        status &= ~ITEM_ART_FETCHED;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",1,,127,3,,void
63774,BLOCK,-1,,<empty>,9,,131,2,,void
63789,BLOCK,-1,,<empty>,9,,136,2,,void
63794,BLOCK,-1,,<empty>,9,,138,1,,void
63815,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );
    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();
    vlc_meta_Set( p_i->p_meta, meta_type, psz_val );
    vlc_mutex_unlock( &p_i->lock );

    /* Notify interested third parties */
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemMetaChanged,
        .u.input_item_meta_changed.meta_type = meta_type } );
}",1,,146,4,,void
63826,BLOCK,-1,,<empty>,9,,149,2,,void
63852,BLOCK,1,,<empty>,9,,155,1,,void
63856,BLOCK,2,,<empty>,9,,156,2,,void
63871,BLOCK,-1,,"{
    char **optv = NULL;
    uint8_t *flagv = NULL;
    int optc = 0;
    char **optv_realloc = NULL;
    uint8_t *flagv_realloc = NULL;

    vlc_mutex_lock( &p_parent->lock );

    if( p_parent->i_options > 0 )
    {
        optv = vlc_alloc( p_parent->i_options, sizeof (*optv) );
        if( likely(optv) )
            flagv = vlc_alloc( p_parent->i_options, sizeof (*flagv) );

        if( likely(flagv) )
        {
            for( int i = 0; i < p_parent->i_options; i++ )
            {
                char *psz_dup = strdup( p_parent->ppsz_options[i] );
                if( likely(psz_dup) )
                {
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }
            }
        }
    }

    vlc_mutex_unlock( &p_parent->lock );

    if( likely(optv && flagv && optc ) )
    {
        vlc_mutex_lock( &p_child->lock );

        if( INT_MAX - p_child->i_options >= optc &&
            SIZE_MAX / sizeof (*flagv) >= (s...",1,,161,3,,void
63903,BLOCK,-1,,"{
        optv = vlc_alloc( p_parent->i_options, sizeof (*optv) );
        if( likely(optv) )
            flagv = vlc_alloc( p_parent->i_options, sizeof (*flagv) );

        if( likely(flagv) )
        {
            for( int i = 0; i < p_parent->i_options; i++ )
            {
                char *psz_dup = strdup( p_parent->ppsz_options[i] );
                if( likely(psz_dup) )
                {
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }
            }
        }
    }",5,,171,2,,void
63916,BLOCK,-1,,<empty>,13,,174,2,,void
63929,BLOCK,-1,,"{
            for( int i = 0; i < p_parent->i_options; i++ )
            {
                char *psz_dup = strdup( p_parent->ppsz_options[i] );
                if( likely(psz_dup) )
                {
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }
            }
        }",9,,177,2,,void
63931,BLOCK,-1,,<empty>,13,,178,1,,void
63943,BLOCK,4,,"{
                char *psz_dup = strdup( p_parent->ppsz_options[i] );
                if( likely(psz_dup) )
                {
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }
            }",13,,179,4,,void
63956,BLOCK,-1,,"{
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }",17,,182,2,,void
63984,BLOCK,-1,,"{
        vlc_mutex_lock( &p_child->lock );

        if( INT_MAX - p_child->i_options >= optc &&
            SIZE_MAX / sizeof (*flagv) >= (size_t) (p_child->i_options + optc) )
            flagv_realloc = realloc( p_child->optflagv,
                                    (p_child->i_options + optc) * sizeof (*flagv) );
        if( likely(flagv_realloc) )
        {
            p_child->optflagv = flagv_realloc;
            if( SIZE_MAX / sizeof (*optv) >= (size_t) (p_child->i_options + optc) )
                optv_realloc = realloc( p_child->ppsz_options,
                                       (p_child->i_options + optc) * sizeof (*optv) );
            if( likely(optv_realloc) )
            {
                p_child->ppsz_options = optv_realloc;
                memcpy( p_child->ppsz_options + p_child->i_options, optv,
                        optc * sizeof (*optv) );
                memcpy( p_child->optflagv + p_child->i_options, flagv,
                        optc * sizeof (*flagv) );
...",5,,193,2,,void
64011,BLOCK,-1,,<empty>,13,,198,2,,void
64030,BLOCK,-1,,"{
            p_child->optflagv = flagv_realloc;
            if( SIZE_MAX / sizeof (*optv) >= (size_t) (p_child->i_options + optc) )
                optv_realloc = realloc( p_child->ppsz_options,
                                       (p_child->i_options + optc) * sizeof (*optv) );
            if( likely(optv_realloc) )
            {
                p_child->ppsz_options = optv_realloc;
                memcpy( p_child->ppsz_options + p_child->i_options, optv,
                        optc * sizeof (*optv) );
                memcpy( p_child->optflagv + p_child->i_options, flagv,
                        optc * sizeof (*flagv) );
                p_child->i_options += optc;
                p_child->optflagc += optc;
            }
        }",9,,201,2,,void
64049,BLOCK,-1,,<empty>,17,,204,2,,void
64068,BLOCK,-1,,"{
                p_child->ppsz_options = optv_realloc;
                memcpy( p_child->ppsz_options + p_child->i_options, optv,
                        optc * sizeof (*optv) );
                memcpy( p_child->optflagv + p_child->i_options, flagv,
                        optc * sizeof (*flagv) );
                p_child->i_options += optc;
                p_child->optflagc += optc;
            }",13,,207,2,,void
64124,BLOCK,-1,,"{
        /* Didn't copy pointers, so need to free the strdup() */
        for( int i=0; i<optc; i++ )
            free( optv[i] );
    }",5,,222,2,,void
64126,BLOCK,-1,,<empty>,9,,224,1,,void
64148,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );

    bool b_error = p_item->b_error_when_reading;

    vlc_mutex_unlock( &p_item->lock );

    return b_error;
}",1,,233,2,,void
64173,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return false;
    }
    const char *psz_meta = vlc_meta_Get( p_i->p_meta, meta_type );
    bool b_ret = psz_meta && strcasestr( psz_meta, psz );

    vlc_mutex_unlock( &p_i->lock );

    return b_ret;
}",1,,245,4,,void
64184,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_i->lock );
        return false;
    }",5,,249,2,,void
64220,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return NULL;
    }

    char *psz = NULL;
    if( vlc_meta_Get( p_i->p_meta, meta_type ) )
        psz = strdup( vlc_meta_Get( p_i->p_meta, meta_type ) );

    vlc_mutex_unlock( &p_i->lock );
    return psz;
}",1,,262,3,,void
64231,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_i->lock );
        return NULL;
    }",5,,266,2,,void
64249,BLOCK,-1,,<empty>,9,,273,2,,void
64269,BLOCK,-1,,"{
    char *psz_ret;
    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
    {
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;
        vlc_mutex_unlock( &p_item->lock );
        return psz_ret;
    }

    const char *psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !EMPTY_STR( psz_title ) )
        psz_ret = strdup( psz_title );
    else
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_ret;
}",1,,281,2,,void
64281,BLOCK,-1,,"{
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;
        vlc_mutex_unlock( &p_item->lock );
        return psz_ret;
    }",5,,286,2,,void
64312,BLOCK,-1,,<empty>,9,,294,2,,void
64318,BLOCK,-1,,<empty>,9,,296,1,,void
64341,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );

    char *psz_name = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_name;
}",1,,303,2,,void
64371,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );

    free( p_item->psz_name );
    p_item->psz_name = strdup( psz_name );

    vlc_mutex_unlock( &p_item->lock );
}",1,,312,3,,void
64396,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );

    char *psz_s = p_i->psz_uri ? strdup( p_i->psz_uri ) : NULL;

    vlc_mutex_unlock( &p_i->lock );
    return psz_s;
}",1,,322,2,,void
64426,BLOCK,-1,,"{
    assert( psz_uri );
#ifndef NDEBUG
    if( !strstr( psz_uri, ""://"" )
     || strchr( psz_uri, ' ' ) || strchr( psz_uri, '""' ) )
        fprintf( stderr, ""Warning: %s(\""%s\""): file path instead of URL.\n"",
                 __func__, psz_uri );
#endif
    vlc_mutex_lock( &p_i->lock );
    free( p_i->psz_uri );
    p_i->psz_uri = strdup( psz_uri );

    p_i->i_type = GuessType( p_i, &p_i->b_net );

    if( p_i->psz_name )
        ;
    else
    if( p_i->i_type == ITEM_TYPE_FILE || p_i->i_type == ITEM_TYPE_DIRECTORY )
    {
        const char *psz_filename = strrchr( p_i->psz_uri, '/' );

        if( psz_filename && *psz_filename == '/' )
            psz_filename++;
        if( psz_filename && *psz_filename )
            p_i->psz_name = strdup( psz_filename );

        /* Make the name more readable */
        if( p_i->psz_name )
        {
            vlc_uri_decode( p_i->psz_name );
            EnsureUTF8( p_i->psz_name );
        }
    }
    else
    {   /* Strip login and passwo...",1,,332,3,,void
64442,BLOCK,-1,,<empty>,9,,337,2,,void
64477,BLOCK,-1,,<empty>,9,,347,2,,void
64479,BLOCK,-1,,<empty>,5,,349,1,,void
64492,BLOCK,-1,,"{
        const char *psz_filename = strrchr( p_i->psz_uri, '/' );

        if( psz_filename && *psz_filename == '/' )
            psz_filename++;
        if( psz_filename && *psz_filename )
            p_i->psz_name = strdup( psz_filename );

        /* Make the name more readable */
        if( p_i->psz_name )
        {
            vlc_uri_decode( p_i->psz_name );
            EnsureUTF8( p_i->psz_name );
        }
    }",5,,350,2,,void
64508,BLOCK,-1,,<empty>,13,,354,2,,void
64516,BLOCK,-1,,<empty>,13,,356,2,,void
64527,BLOCK,-1,,"{
            vlc_uri_decode( p_i->psz_name );
            EnsureUTF8( p_i->psz_name );
        }",9,,360,2,,void
64537,BLOCK,-1,,"{   /* Strip login and password from title */
        int r;
        vlc_url_t url;

        vlc_UrlParse( &url, psz_uri );
        if( url.psz_protocol )
        {
            if( url.i_port > 0 )
                r=asprintf( &p_i->psz_name, ""%s://%s:%d%s"", url.psz_protocol,
                          url.psz_host, url.i_port,
                          url.psz_path ? url.psz_path : """" );
            else
                r=asprintf( &p_i->psz_name, ""%s://%s%s"", url.psz_protocol,
                          url.psz_host ? url.psz_host : """",
                          url.psz_path ? url.psz_path : """" );
        }
        else
        {
            if( url.i_port > 0 )
                r=asprintf( &p_i->psz_name, ""%s:%d%s"", url.psz_host, url.i_port,
                          url.psz_path ? url.psz_path : """" );
            else
                r=asprintf( &p_i->psz_name, ""%s%s"", url.psz_host,
                          url.psz_path ? url.psz_path : """" );
        }
        vlc_UrlClean( &url );...",5,,366,1,,void
64548,BLOCK,-1,,"{
            if( url.i_port > 0 )
                r=asprintf( &p_i->psz_name, ""%s://%s:%d%s"", url.psz_protocol,
                          url.psz_host, url.i_port,
                          url.psz_path ? url.psz_path : """" );
            else
                r=asprintf( &p_i->psz_name, ""%s://%s%s"", url.psz_protocol,
                          url.psz_host ? url.psz_host : """",
                          url.psz_path ? url.psz_path : """" );
        }",9,,372,2,,void
64555,BLOCK,-1,,<empty>,17,,374,2,,void
64582,BLOCK,-1,,<empty>,17,,378,1,,void
64611,BLOCK,-1,,"{
            if( url.i_port > 0 )
                r=asprintf( &p_i->psz_name, ""%s:%d%s"", url.psz_host, url.i_port,
                          url.psz_path ? url.psz_path : """" );
            else
                r=asprintf( &p_i->psz_name, ""%s%s"", url.psz_host,
                          url.psz_path ? url.psz_path : """" );
        }",9,,383,1,,void
64618,BLOCK,-1,,<empty>,17,,385,2,,void
64642,BLOCK,-1,,<empty>,17,,388,1,,void
64670,BLOCK,-1,,<empty>,13,,393,2,,void
64685,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );

    mtime_t i_duration = p_i->i_duration;

    vlc_mutex_unlock( &p_i->lock );
    return i_duration;
}",1,,400,2,,void
64709,BLOCK,-1,,"{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );
    if( p_i->i_duration != i_duration )
    {
        p_i->i_duration = i_duration;
        b_send_event = true;
    }
    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemDurationChanged,
            .u.input_item_duration_changed.new_duration = i_duration } );
    }
}",1,,410,3,,void
64725,BLOCK,-1,,"{
        p_i->i_duration = i_duration;
        b_send_event = true;
    }",5,,415,2,,void
64741,BLOCK,-1,,"{
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemDurationChanged,
            .u.input_item_duration_changed.new_duration = i_duration } );
    }",5,,422,2,,void
64751,BLOCK,1,,<empty>,13,,424,1,,void
64755,BLOCK,2,,<empty>,13,,425,2,,void
64769,BLOCK,-1,,"{
    char *psz_meta = input_item_GetMeta( p_item, vlc_meta_NowPlaying );
    if( !psz_meta || strlen( psz_meta ) == 0 )
    {
        free( psz_meta );
        return input_item_GetMeta( p_item, vlc_meta_ESNowPlaying );
    }

    return psz_meta;
}",1,,430,2,,void
64784,BLOCK,-1,,"{
        free( psz_meta );
        return input_item_GetMeta( p_item, vlc_meta_ESNowPlaying );
    }",5,,433,2,,void
64797,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );
    bool b_preparsed = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_PREPARSED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_preparsed;
}",1,,442,2,,void
64830,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );
    bool b_fetched = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_ART_FETCHED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_fetched;
}",1,,451,2,,void
64863,BLOCK,-1,,"{
    bool b_ret;

    vlc_mutex_lock( &p_item->lock );
    b_ret = p_item->i_preparse_depth == -1 ? true : p_item->i_preparse_depth > 0;
    vlc_mutex_unlock( &p_item->lock );

    return b_ret;
}",1,,460,2,,void
64896,BLOCK,-1,,"{
    input_item_owner_t *owner = item_owner(p_item);

    atomic_fetch_add( &owner->refs, 1 );
    return p_item;
}",1,,471,2,,void
64902,BLOCK,1,,<empty>,,,,2,,void
64918,BLOCK,-1,,"{
    input_item_owner_t *owner = item_owner(p_item);

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    vlc_event_manager_fini( &p_item->event_manager );

    free( p_item->psz_name );
    free( p_item->psz_uri );
    if( p_item->p_stats != NULL )
    {
        vlc_mutex_destroy( &p_item->p_stats->lock );
        free( p_item->p_stats );
    }

    if( p_item->p_meta != NULL )
        vlc_meta_Delete( p_item->p_meta );

    for( input_item_opaque_t *o = p_item->opaques, *next; o != NULL; o = next )
    {
        next = o->next;
        free( o );
    }

    for( int i = 0; i < p_item->i_options; i++ )
        free( p_item->ppsz_options[i] );
    TAB_CLEAN( p_item->i_options, p_item->ppsz_options );
    free( p_item->optflagv );

    for( int i = 0; i < p_item->i_es; i++ )
    {
        es_format_Clean( p_item->es[i] );
        free( p_item->es[i] );
    }
    TAB_CLEAN( p_item->i_es, p_item->es );

    for( int i = 0; i < p_item->i_epg; i++ )
        vlc_epg_Del...",1,,479,2,,void
64924,BLOCK,1,,<empty>,,,,2,,void
64937,BLOCK,-1,,<empty>,9,,483,2,,void
64958,BLOCK,-1,,"{
        vlc_mutex_destroy( &p_item->p_stats->lock );
        free( p_item->p_stats );
    }",5,,490,2,,void
64976,BLOCK,-1,,<empty>,9,,496,2,,void
64982,BLOCK,-1,,<empty>,5,,498,1,,void
64996,BLOCK,4,,"{
        next = o->next;
        free( o );
    }",5,,499,4,,void
65005,BLOCK,-1,,<empty>,5,,504,1,,void
65035,BLOCK,-1,,<empty>,5,,509,1,,void
65047,BLOCK,4,,"{
        es_format_Clean( p_item->es[i] );
        free( p_item->es[i] );
    }",5,,510,4,,void
65068,BLOCK,-1,,<empty>,5,,516,1,,void
65094,BLOCK,-1,,<empty>,5,,520,1,,void
65120,BLOCK,-1,,<empty>,5,,524,1,,void
65158,BLOCK,-1,,"{
    int err = VLC_SUCCESS;

    if( psz_option == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_input->lock );
    if (flags & VLC_INPUT_OPTION_UNIQUE)
    {
        for (int i = 0 ; i < p_input->i_options; i++)
            if( !strcmp( p_input->ppsz_options[i], psz_option ) )
                goto out;
    }

    uint8_t *flagv = realloc (p_input->optflagv, p_input->optflagc + 1);
    if (flagv == NULL)
    {
        err = VLC_ENOMEM;
        goto out;
    }

    p_input->optflagv = flagv;

    char* psz_option_dup = strdup( psz_option );
    if( unlikely( !psz_option_dup ) )
    {
        err = VLC_ENOMEM;
        goto out;
    }

    TAB_APPEND(p_input->i_options, p_input->ppsz_options, psz_option_dup);

    flagv[p_input->optflagc++] = flags;

out:
    vlc_mutex_unlock( &p_input->lock );
    return err;
}",1,,534,4,,void
65167,BLOCK,-1,,<empty>,9,,538,2,,void
65179,BLOCK,-1,,"{
        for (int i = 0 ; i < p_input->i_options; i++)
            if( !strcmp( p_input->ppsz_options[i], psz_option ) )
                goto out;
    }",5,,542,2,,void
65181,BLOCK,-1,,<empty>,9,,543,1,,void
65202,BLOCK,-1,,<empty>,17,,545,2,,void
65220,BLOCK,-1,,"{
        err = VLC_ENOMEM;
        goto out;
    }",5,,550,2,,void
65239,BLOCK,-1,,"{
        err = VLC_ENOMEM;
        goto out;
    }",5,,559,2,,void
65275,BLOCK,-1,,"{
    int i_ret = VLC_SUCCESS;
    for( int i = 0; i < i_options && i_ret == VLC_SUCCESS; i++ )
        i_ret = input_item_AddOption( p_item, ppsz_options[i], i_flags );
    return i_ret;
}",1,,576,5,,void
65281,BLOCK,-1,,<empty>,5,,578,1,,void
65311,BLOCK,-1,,"{
    assert(name != NULL);

    size_t namelen = strlen(name);
    input_item_opaque_t *entry = malloc(sizeof (*entry) + namelen);
    if (unlikely(entry == NULL))
        return VLC_ENOMEM;

    memcpy(entry->name, name, namelen + 1);
    entry->value = value;

    vlc_mutex_lock(&item->lock);
    entry->next = item->opaques;
    item->opaques = entry;
    vlc_mutex_unlock(&item->lock);
    return VLC_SUCCESS;
}",1,,584,4,,void
65335,BLOCK,-1,,<empty>,9,,590,2,,void
65380,BLOCK,-1,,"{
    vlc_mutex_lock(&item->lock);
    assert(item->optflagc == (unsigned)item->i_options);

    for (unsigned i = 0; i < (unsigned)item->i_options; i++)
        var_OptionParse(obj, item->ppsz_options[i],
                        !!(item->optflagv[i] & VLC_INPUT_OPTION_TRUSTED));

    for (const input_item_opaque_t *o = item->opaques; o != NULL; o = o->next)
    {
        var_Create(obj, o->name, VLC_VAR_ADDRESS);
        var_SetAddress(obj, o->name, o->value);
    }

    vlc_mutex_unlock(&item->lock);
}",1,,603,3,,void
65397,BLOCK,-1,,<empty>,5,,607,1,,void
65428,BLOCK,-1,,<empty>,5,,611,1,,void
65443,BLOCK,4,,"{
        var_Create(obj, o->name, VLC_VAR_ADDRESS);
        var_SetAddress(obj, o->name, o->value);
    }",5,,612,4,,void
65468,BLOCK,-1,,"{
    const char *const *entry = b;
    return strcasecmp(a, *entry);
}",1,,621,3,,void
65482,BLOCK,-1,,"{
    static const char *const ppsz_master_exts[] = { MASTER_EXTENSIONS };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    return bsearch(psz_ext, ppsz_master_exts, ARRAY_SIZE(ppsz_master_exts),
                   sizeof(const char *), bsearch_strcmp_cb) != NULL;
}",1,,627,2,,void
65504,BLOCK,-1,,<empty>,9,,632,2,,void
65523,BLOCK,-1,,"{
    static const char *const ppsz_sub_exts[] = { SLAVE_SPU_EXTENSIONS };
    static const char *const ppsz_audio_exts[] = { SLAVE_AUDIO_EXTENSIONS };

    static struct {
        enum slave_type i_type;
        const char *const *ppsz_exts;
        size_t nmemb;
    } p_slave_list[] = {
        { SLAVE_TYPE_SPU, ppsz_sub_exts, ARRAY_SIZE(ppsz_sub_exts) },
        { SLAVE_TYPE_AUDIO, ppsz_audio_exts, ARRAY_SIZE(ppsz_audio_exts) },
    };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    for (unsigned int i = 0; i < sizeof(p_slave_list) / sizeof(*p_slave_list); ++i)
    {
        if (bsearch(psz_ext, p_slave_list[i].ppsz_exts, p_slave_list[i].nmemb,
                    sizeof(const char *), bsearch_strcmp_cb))
        {
            *p_slave_type = p_slave_list[i].i_type;
            return true;
        }
    }
    return false;
}",1,,640,3,,void
65564,BLOCK,-1,,<empty>,9,,655,2,,void
65568,BLOCK,-1,,<empty>,5,,657,1,,void
65583,BLOCK,4,,"{
        if (bsearch(psz_ext, p_slave_list[i].ppsz_exts, p_slave_list[i].nmemb,
                    sizeof(const char *), bsearch_strcmp_cb))
        {
            *p_slave_type = p_slave_list[i].i_type;
            return true;
        }
    }",5,,658,4,,void
65600,BLOCK,-1,,"{
            *p_slave_type = p_slave_list[i].i_type;
            return true;
        }",9,,661,2,,void
65619,BLOCK,-1,,"{
    if( !psz_uri )
        return NULL;

    input_item_slave_t *p_slave = malloc( sizeof( *p_slave ) + strlen( psz_uri ) + 1 );
    if( !p_slave )
        return NULL;

    p_slave->i_type = i_type;
    p_slave->i_priority = i_priority;
    p_slave->b_forced = false;
    strcpy( p_slave->psz_uri, psz_uri );

    return p_slave;
}",1,,671,4,,void
65623,BLOCK,-1,,<empty>,9,,673,2,,void
65641,BLOCK,-1,,<empty>,9,,677,2,,void
65671,BLOCK,-1,,"{
    if( p_item == NULL || p_slave == NULL
     || p_slave->i_priority < SLAVE_PRIORITY_MATCH_NONE )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_item->lock );

    TAB_APPEND(p_item->i_slaves, p_item->pp_slaves, p_slave);

    vlc_mutex_unlock( &p_item->lock );
    return VLC_SUCCESS;
}",1,,688,3,,void
65686,BLOCK,-1,,<empty>,9,,691,2,,void
65715,BLOCK,-1,,"{
    vlc_assert_locked( &p_item->lock );
    for( int i = 0; i < p_item->i_categories && psz_cat; i++ )
    {
        info_category_t *p_cat = p_item->pp_categories[i];

        if( !strcmp( p_cat->psz_name, psz_cat ) )
        {
            if( pi_index )
                *pi_index = i;
            return p_cat;
        }
    }
    return NULL;
}",1,,703,4,,void
65722,BLOCK,-1,,<empty>,5,,705,1,,void
65736,BLOCK,4,,"{
        info_category_t *p_cat = p_item->pp_categories[i];

        if( !strcmp( p_cat->psz_name, psz_cat ) )
        {
            if( pi_index )
                *pi_index = i;
            return p_cat;
        }
    }",5,,706,4,,void
65752,BLOCK,-1,,"{
            if( pi_index )
                *pi_index = i;
            return p_cat;
        }",9,,710,2,,void
65755,BLOCK,-1,,<empty>,17,,712,2,,void
65770,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );

    const info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( p_cat )
    {
        info_t *p_info = info_category_FindInfo( p_cat, NULL, psz_name );
        if( p_info && p_info->psz_value )
        {
            char *psz_ret = strdup( p_info->psz_value );
            vlc_mutex_unlock( &p_i->lock );
            return psz_ret;
        }
    }
    vlc_mutex_unlock( &p_i->lock );
    return strdup( """" );
}",1,,732,4,,void
65785,BLOCK,-1,,"{
        info_t *p_info = info_category_FindInfo( p_cat, NULL, psz_name );
        if( p_info && p_info->psz_value )
        {
            char *psz_ret = strdup( p_info->psz_value );
            vlc_mutex_unlock( &p_i->lock );
            return psz_ret;
        }
    }",5,,737,2,,void
65799,BLOCK,-1,,"{
            char *psz_ret = strdup( p_info->psz_value );
            vlc_mutex_unlock( &p_i->lock );
            return psz_ret;
        }",9,,740,2,,void
65830,BLOCK,-1,,"{
    vlc_assert_locked( &p_i->lock );

    info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( !p_cat )
    {
        p_cat = info_category_New( psz_cat );
        if( !p_cat )
            return VLC_ENOMEM;
        TAB_APPEND(p_i->i_categories, p_i->pp_categories, p_cat);
    }
    info_t *p_info = info_category_VaAddInfo( p_cat, psz_name, psz_format, args );
    if( !p_info || !p_info->psz_value )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,,754,6,,void
65846,BLOCK,-1,,"{
        p_cat = info_category_New( psz_cat );
        if( !p_cat )
            return VLC_ENOMEM;
        TAB_APPEND(p_i->i_categories, p_i->pp_categories, p_cat);
    }",5,,759,2,,void
65854,BLOCK,-1,,<empty>,13,,762,2,,void
65881,BLOCK,-1,,<empty>,9,,767,2,,void
65893,BLOCK,-1,,"{
    va_list args;

    vlc_mutex_lock( &p_i->lock );

    va_start( args, psz_format );
    const int i_ret = InputItemVaAddInfo( p_i, psz_cat, psz_name, psz_format, args );
    va_end( args );

    vlc_mutex_unlock( &p_i->lock );


    if( !i_ret )
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemInfoChanged } );

    return i_ret;
}",1,,775,5,,void
65922,BLOCK,-1,,<empty>,9,,788,2,,void
65932,BLOCK,1,,<empty>,13,,789,1,,void
65944,BLOCK,-1,,"{
    vlc_mutex_lock( &p_i->lock );
    int i_cat;
    info_category_t *p_cat = InputItemFindCat( p_i, &i_cat, psz_cat );
    if( !p_cat )
    {
        vlc_mutex_unlock( &p_i->lock );
        return VLC_EGENERIC;
    }

    if( psz_name )
    {
        /* Remove a specific info */
        int i_ret = info_category_DeleteInfo( p_cat, psz_name );
        if( i_ret )
        {
            vlc_mutex_unlock( &p_i->lock );
            return VLC_EGENERIC;
        }
    }
    else
    {
        /* Remove the complete categorie */
        info_category_Delete( p_cat );
        TAB_ERASE(p_i->i_categories, p_i->pp_categories, i_cat);
    }
    vlc_mutex_unlock( &p_i->lock );

    vlc_event_send( &p_i->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );

    return VLC_SUCCESS;
}",1,,797,4,,void
65962,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_i->lock );
        return VLC_EGENERIC;
    }",5,,802,2,,void
65972,BLOCK,-1,,"{
        /* Remove a specific info */
        int i_ret = info_category_DeleteInfo( p_cat, psz_name );
        if( i_ret )
        {
            vlc_mutex_unlock( &p_i->lock );
            return VLC_EGENERIC;
        }
    }",5,,808,2,,void
65981,BLOCK,-1,,"{
            vlc_mutex_unlock( &p_i->lock );
            return VLC_EGENERIC;
        }",9,,812,2,,void
65990,BLOCK,-1,,"{
        /* Remove the complete categorie */
        info_category_Delete( p_cat );
        TAB_ERASE(p_i->i_categories, p_i->pp_categories, i_cat);
    }",5,,818,1,,void
66015,BLOCK,1,,<empty>,38,,826,1,,void
66026,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );
    int i_cat;
    info_category_t *p_old = InputItemFindCat( p_item, &i_cat, p_cat->psz_name );
    if( p_old )
    {
        info_category_Delete( p_old );
        p_item->pp_categories[i_cat] = p_cat;
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",1,,831,3,,void
66045,BLOCK,-1,,"{
        info_category_Delete( p_old );
        p_item->pp_categories[i_cat] = p_cat;
    }",5,,836,2,,void
66056,BLOCK,-1,,<empty>,9,,841,1,,void
66079,BLOCK,1,,<empty>,38,,845,1,,void
66088,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );
    info_category_t *p_old = InputItemFindCat( p_item, NULL, p_cat->psz_name );
    if( p_old )
    {
        for( int i = 0; i < p_cat->i_infos; i++ )
            info_category_ReplaceInfo( p_old, p_cat->pp_infos[i] );
        TAB_CLEAN( p_cat->i_infos, p_cat->pp_infos );
        info_category_Delete( p_cat );
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",1,,849,3,,void
66105,BLOCK,-1,,"{
        for( int i = 0; i < p_cat->i_infos; i++ )
            info_category_ReplaceInfo( p_old, p_cat->pp_infos[i] );
        TAB_CLEAN( p_cat->i_infos, p_cat->pp_infos );
        info_category_Delete( p_cat );
    }",5,,853,2,,void
66107,BLOCK,-1,,<empty>,9,,854,1,,void
66136,BLOCK,-1,,<empty>,9,,860,1,,void
66159,BLOCK,1,,<empty>,38,,864,1,,void
66168,BLOCK,-1,,"{
    bool b_changed = false;
    vlc_mutex_lock( &p_item->lock );

    for( int i = 0; i < p_item->i_epg; i++ )
    {
        vlc_epg_t *p_epg = p_item->pp_epg[i];
        for( size_t j = 0; j < p_epg->i_event; j++ )
        {
            /* Same event can exist in more than one table */
            if( p_epg->pp_event[j]->i_id == p_epg_evt->i_id )
            {
                vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_epg_evt );
                if( p_dup )
                {
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );

    if ( b_changed )
    {
        vlc_event_send( &p_item->event_manager,
                        &(vlc_event_t) { .type = vlc_In...",1,,868,3,,void
66179,BLOCK,-1,,<empty>,5,,872,1,,void
66191,BLOCK,4,,"{
        vlc_epg_t *p_epg = p_item->pp_epg[i];
        for( size_t j = 0; j < p_epg->i_event; j++ )
        {
            /* Same event can exist in more than one table */
            if( p_epg->pp_event[j]->i_id == p_epg_evt->i_id )
            {
                vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_epg_evt );
                if( p_dup )
                {
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }
                break;
            }
        }
    }",5,,873,4,,void
66201,BLOCK,-1,,<empty>,9,,875,1,,void
66213,BLOCK,4,,"{
            /* Same event can exist in more than one table */
            if( p_epg->pp_event[j]->i_id == p_epg_evt->i_id )
            {
                vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_epg_evt );
                if( p_dup )
                {
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }
                break;
            }
        }",9,,876,4,,void
66226,BLOCK,-1,,"{
                vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_epg_evt );
                if( p_dup )
                {
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }
                break;
            }",13,,879,2,,void
66234,BLOCK,-1,,"{
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }",17,,882,2,,void
66245,BLOCK,-1,,<empty>,25,,884,2,,void
66275,BLOCK,-1,,"{
        vlc_event_send( &p_item->event_manager,
                        &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
    }",5,,896,2,,void
66285,BLOCK,1,,<empty>,42,,898,1,,void
66295,BLOCK,-1,,"{
    vlc_epg_t *p_epg = vlc_epg_Duplicate( p_update );
    if( !p_epg )
        return;

    vlc_mutex_lock( &p_item->lock );

    /* */
    vlc_epg_t **pp_epg = NULL;
    for( int i = 0; i < p_item->i_epg; i++ )
    {
        if( p_item->pp_epg[i]->i_source_id == p_update->i_source_id &&
            p_item->pp_epg[i]->i_id == p_update->i_id )
        {
            pp_epg = &p_item->pp_epg[i];
            break;
        }
    }

    /* replace with new version */
    if( pp_epg )
    {
        vlc_epg_Delete( *pp_epg );
        if( *pp_epg == p_item->p_epg_table ) /* current table can have changed */
            p_item->p_epg_table = NULL;
        *pp_epg = p_epg;
    }
    else
    {
        TAB_APPEND( p_item->i_epg, p_item->pp_epg, p_epg );
    }

    if( b_current_source && p_epg->b_present )
        p_item->p_epg_table = p_epg;

    vlc_mutex_unlock( &p_item->lock );

#ifdef EPG_DEBUG
    char *psz_epg;
    if( asprintf( &psz_epg, ""EPG %s"", p_epg->psz_name ? p_epg->psz_name : ...",1,,920,4,,void
66304,BLOCK,-1,,<empty>,9,,923,2,,void
66316,BLOCK,-1,,<empty>,5,,929,1,,void
66328,BLOCK,4,,"{
        if( p_item->pp_epg[i]->i_source_id == p_update->i_source_id &&
            p_item->pp_epg[i]->i_id == p_update->i_id )
        {
            pp_epg = &p_item->pp_epg[i];
            break;
        }
    }",5,,930,4,,void
66353,BLOCK,-1,,"{
            pp_epg = &p_item->pp_epg[i];
            break;
        }",9,,933,2,,void
66365,BLOCK,-1,,"{
        vlc_epg_Delete( *pp_epg );
        if( *pp_epg == p_item->p_epg_table ) /* current table can have changed */
            p_item->p_epg_table = NULL;
        *pp_epg = p_epg;
    }",5,,941,2,,void
66376,BLOCK,-1,,<empty>,13,,944,2,,void
66387,BLOCK,-1,,"{
        TAB_APPEND( p_item->i_epg, p_item->pp_epg, p_epg );
    }",5,,948,1,,void
66402,BLOCK,-1,,<empty>,9,,953,2,,void
66422,BLOCK,1,,<empty>,37,,993,1,,void
66431,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );
    p_item->p_epg_table = NULL;
    if( i_source_id > 0 )
    {
        /* Update pointer to current/next table in the full schedule */
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            if( p_item->pp_epg[i]->i_source_id == i_source_id &&
                p_item->pp_epg[i]->b_present )
            {
                p_item->p_epg_table = p_item->pp_epg[i];
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );
}",1,,997,3,,void
66446,BLOCK,-1,,"{
        /* Update pointer to current/next table in the full schedule */
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            if( p_item->pp_epg[i]->i_source_id == i_source_id &&
                p_item->pp_epg[i]->b_present )
            {
                p_item->p_epg_table = p_item->pp_epg[i];
                break;
            }
        }
    }",5,,1001,2,,void
66448,BLOCK,-1,,<empty>,9,,1003,1,,void
66460,BLOCK,4,,"{
            if( p_item->pp_epg[i]->i_source_id == i_source_id &&
                p_item->pp_epg[i]->b_present )
            {
                p_item->p_epg_table = p_item->pp_epg[i];
                break;
            }
        }",9,,1004,4,,void
66479,BLOCK,-1,,"{
                p_item->p_epg_table = p_item->pp_epg[i];
                break;
            }",13,,1007,2,,void
66500,BLOCK,-1,,"{
    vlc_mutex_lock( &p_item->lock );
    p_item->i_epg_time = i_time;
    vlc_mutex_unlock( &p_item->lock );
}",1,,1017,3,,void
66520,BLOCK,-1,,"{
    input_item_ChangeEPGSource( p_item, -1 );

#ifdef EPG_DEBUG
    vlc_mutex_lock( &p_item->lock );
    const int i_epg_info = p_item->i_epg;
    if( i_epg_info > 0 )
    {
        char *ppsz_epg_info[i_epg_info];
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            const vlc_epg_t *p_epg = p_item->pp_epg[i];
            if( asprintf( &ppsz_epg_info[i], ""EPG %s"", p_epg->psz_name ? p_epg->psz_name : ""unknown"" ) < 0 )
                ppsz_epg_info[i] = NULL;
        }
        vlc_mutex_unlock( &p_item->lock );

        for( int i = 0; i < i_epg_info; i++ )
        {
            if( !ppsz_epg_info[i] )
                continue;
            input_item_DelInfo( p_item, ppsz_epg_info[i], NULL );
            free( ppsz_epg_info[i] );
        }
    }
    else
        vlc_mutex_unlock( &p_item->lock );
#endif

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",1,,1024,2,,void
66534,BLOCK,1,,<empty>,38,,1054,1,,void
66546,BLOCK,-1,,"{
    input_item_owner_t *owner = calloc( 1, sizeof( *owner ) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    input_item_t *p_input = &owner->item;
    vlc_event_manager_t * p_em = &p_input->event_manager;

    vlc_mutex_init( &p_input->lock );

    p_input->psz_name = NULL;
    if( psz_name )
        input_item_SetName( p_input, psz_name );

    p_input->psz_uri = NULL;
    if( psz_uri )
        input_item_SetURI( p_input, psz_uri );
    else
    {
        p_input->i_type = ITEM_TYPE_UNKNOWN;
        p_input->b_net = false;
    }

    TAB_INIT( p_input->i_options, p_input->ppsz_options );
    p_input->optflagc = 0;
    p_input->optflagv = NULL;
    p_input->opaques = NULL;

    p_input->i_duration = duration;
    TAB_INIT( p_input->i_categories, p_input->pp_categories );
    TAB_INIT( p_input->i_es, p_input->es );
    p_input->p_stats = NULL;
    p_input->p_meta = NULL;
    TAB_INIT( p_input->i_epg, p_input->pp_epg );
    TAB_INIT...",1,,1060,6,,void
66560,BLOCK,-1,,<empty>,9,,1063,2,,void
66595,BLOCK,-1,,<empty>,9,,1074,2,,void
66606,BLOCK,-1,,<empty>,9,,1078,2,,void
66611,BLOCK,-1,,"{
        p_input->i_type = ITEM_TYPE_UNKNOWN;
        p_input->b_net = false;
    }",5,,1080,1,,void
66694,BLOCK,-1,,<empty>,9,,1101,2,,void
66709,BLOCK,-1,,<empty>,9,,1105,2,,void
66723,BLOCK,-1,,"{
    vlc_meta_t *meta = NULL;
    input_item_t *item;
    bool b_net;

    vlc_mutex_lock( &p_input->lock );

    item = input_item_NewExt( p_input->psz_uri, p_input->psz_name,
                              p_input->i_duration, p_input->i_type,
                              ITEM_NET_UNKNOWN );
    if( likely(item != NULL) && p_input->p_meta != NULL )
    {
        meta = vlc_meta_New();
        vlc_meta_Merge( meta, p_input->p_meta );
    }
    b_net = p_input->b_net;
    vlc_mutex_unlock( &p_input->lock );

    if( likely(item != NULL) )
    {   /* No need to lock; no other thread has seen this new item yet. */
        input_item_CopyOptions( item, p_input );
        item->p_meta = meta;
        item->b_net = b_net;
    }

    return item;
}",1,,1110,2,,void
66762,BLOCK,-1,,"{
        meta = vlc_meta_New();
        vlc_meta_Merge( meta, p_input->p_meta );
    }",5,,1121,2,,void
66786,BLOCK,-1,,"{   /* No need to lock; no other thread has seen this new item yet. */
        input_item_CopyOptions( item, p_input );
        item->p_meta = meta;
        item->b_net = b_net;
    }",5,,1129,2,,void
66811,BLOCK,-1,,"{
    const struct item_type_entry *type = entry;
    const char *uri = key, *scheme = type->psz_scheme;

    return strncmp( uri, scheme, strlen( scheme ) );
}",1,,1146,3,,void
66837,BLOCK,-1,,"{
    static const struct item_type_entry tab[] =
    {   /* /!\ Alphabetical order /!\ */
        /* Short match work, not just exact match */
        { ""alsa"",   ITEM_TYPE_CARD, false },
        { ""atsc"",   ITEM_TYPE_CARD, false },
        { ""bd"",     ITEM_TYPE_DISC, false },
        { ""bluray"", ITEM_TYPE_DISC, false },
        { ""cable"",  ITEM_TYPE_CARD, false },
        { ""cdda"",   ITEM_TYPE_DISC, false },
        { ""cqam"",   ITEM_TYPE_CARD, false },
        { ""dc1394"", ITEM_TYPE_CARD, false },
        { ""dccp"",   ITEM_TYPE_STREAM, true },
        { ""deckli"", ITEM_TYPE_CARD, false }, /* decklink */
        { ""dir"",    ITEM_TYPE_DIRECTORY, false },
        { ""dshow"",  ITEM_TYPE_CARD, false },
        { ""dtv"",    ITEM_TYPE_CARD, false },
        { ""dvb"",    ITEM_TYPE_CARD, false },
        { ""dvd"",    ITEM_TYPE_DISC, false },
        { ""eyetv"",  ITEM_TYPE_CARD, false },
        { ""fd"",     ITEM_TYPE_UNKNOWN, false },
        { ""file"",   ITEM_TYPE_FILE, false },
        { ""ftp"",   ...",1,,1155,3,,void
67083,BLOCK,-1,,<empty>,5,,1222,1,,void
67120,BLOCK,-1,,<empty>,9,,1229,2,,void
67142,BLOCK,-1,,<empty>,9,,1235,2,,void
67159,BLOCK,-1,,"{
    input_item_node_t* p_node = malloc( sizeof( input_item_node_t ) );
    if( !p_node )
        return NULL;

    assert( p_input );

    p_node->p_item = p_input;
    input_item_Hold( p_input );

    p_node->i_children = 0;
    p_node->pp_children = NULL;

    return p_node;
}",1,,1242,2,,void
67169,BLOCK,-1,,<empty>,9,,1245,2,,void
67197,BLOCK,-1,,"{
    for( int i = 0; i < p_node->i_children; i++ )
        input_item_node_Delete( p_node->pp_children[i] );

    input_item_Release( p_node->p_item );
    free( p_node->pp_children );
    free( p_node );
}",1,,1259,2,,void
67199,BLOCK,-1,,<empty>,5,,1260,1,,void
67232,BLOCK,-1,,"{
    int i_preparse_depth;
    input_item_node_t *p_new_child = input_item_node_Create( p_item );
    if( !p_new_child ) return NULL;

    vlc_mutex_lock( &p_node->p_item->lock );
    i_preparse_depth = p_node->p_item->i_preparse_depth;
    vlc_mutex_unlock( &p_node->p_item->lock );

    vlc_mutex_lock( &p_item->lock );
    p_item->i_preparse_depth = i_preparse_depth > 0 ?
                               i_preparse_depth -1 :
                               i_preparse_depth;
    vlc_mutex_unlock( &p_item->lock );

    input_item_node_AppendNode( p_node, p_new_child );
    return p_new_child;
}",1,,1269,3,,void
67242,BLOCK,-1,,<empty>,24,,1272,2,,void
67298,BLOCK,-1,,"{
    assert(p_parent != NULL);
    assert(p_child != NULL);
    TAB_APPEND(p_parent->i_children, p_parent->pp_children, p_child);
}",1,,1290,3,,void
67320,BLOCK,-1,,"{
    TAB_REMOVE(parent->i_children, parent->pp_children, child);
}",1,,1298,3,,void
67333,BLOCK,-1,,"{
    vlc_event_send( &p_root->p_item->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemSubItemTreeAdded,
        .u.input_item_subitem_tree_added.p_root = p_root } );

    input_item_node_Delete( p_root );
}",1,,1303,2,,void
67345,BLOCK,1,,<empty>,9,,1305,1,,void
67349,BLOCK,2,,<empty>,9,,1306,2,,void
67366,BLOCK,-1,,"{
    int i;
    es_format_t *fmt_copy = malloc(sizeof *fmt_copy);
    if (!fmt_copy)
        return;

    es_format_Copy(fmt_copy, fmt);

    vlc_mutex_lock( &item->lock );

    for( i = 0; i < item->i_es; i++ )
    {
        if (item->es[i]->i_id != fmt->i_id)
            continue;

        /* We've found the right ES, replace it */
        es_format_Clean(item->es[i]);
        free(item->es[i]);
        item->es[i] = fmt_copy;
        vlc_mutex_unlock( &item->lock );
        return;
    }

    /* ES not found, insert it */
    TAB_APPEND(item->i_es, item->es, fmt_copy);
    vlc_mutex_unlock( &item->lock );
}",1,,1313,3,,void
67378,BLOCK,-1,,<empty>,9,,1317,2,,void
67389,BLOCK,-1,,<empty>,5,,1323,1,,void
67400,BLOCK,4,,"{
        if (item->es[i]->i_id != fmt->i_id)
            continue;

        /* We've found the right ES, replace it */
        es_format_Clean(item->es[i]);
        free(item->es[i]);
        item->es[i] = fmt_copy;
        vlc_mutex_unlock( &item->lock );
        return;
    }",5,,1324,4,,void
67413,BLOCK,-1,,<empty>,13,,1326,2,,void
67458,BLOCK,-1,,"{
    if (p1->i_type != p2->i_type)
    {
        if (p1->i_type == ITEM_TYPE_DIRECTORY)
            return -1;
        if (p2->i_type == ITEM_TYPE_DIRECTORY)
            return 1;
    }
    return 0;
}",1,,1342,3,,void
67467,BLOCK,-1,,"{
        if (p1->i_type == ITEM_TYPE_DIRECTORY)
            return -1;
        if (p2->i_type == ITEM_TYPE_DIRECTORY)
            return 1;
    }",5,,1344,2,,void
67474,BLOCK,-1,,<empty>,13,,1346,2,,void
67484,BLOCK,-1,,<empty>,13,,1348,2,,void
67494,BLOCK,-1,,"{
    input_item_node_t *const *na = a, *const *nb = b;
    input_item_t *ia = (*na)->p_item, *ib = (*nb)->p_item;

    int i_ret = rdh_compar_type(ia, ib);
    if (i_ret != 0)
        return i_ret;

    return vlc_filenamecmp(ia->psz_name, ib->psz_name);
}",1,,1354,3,,void
67527,BLOCK,-1,,<empty>,9,,1360,2,,void
67542,BLOCK,-1,,"{
    if (p_node->i_children <= 0)
        return;

    /* Sort current node */
    qsort(p_node->pp_children, p_node->i_children,
          sizeof(input_item_node_t *), rdh_compar_filename);

    /* Sort all children */
    for (int i = 0; i < p_node->i_children; i++)
        rdh_sort(p_node->pp_children[i]);
}",1,,1366,2,,void
67549,BLOCK,-1,,<empty>,9,,1368,2,,void
67562,BLOCK,-1,,<empty>,5,,1375,1,,void
67585,BLOCK,-1,,"{
    if (psz_ignored_exts == NULL)
        return false;

    const char *ext = strrchr(psz_filename, '.');
    if (ext == NULL)
        return false;

    size_t extlen = strlen(++ext);

    for (const char *type = psz_ignored_exts, *end; type[0]; type = end + 1)
    {
        end = strchr(type, ',');
        if (end == NULL)
            end = type + strlen(type);

        if (type + extlen == end && !strncasecmp(ext, type, extlen))
            return true;

        if (*end == '\0')
            break;
    }

    return false;
}",1,,1384,3,,void
67590,BLOCK,-1,,<empty>,9,,1386,2,,void
67603,BLOCK,-1,,<empty>,9,,1390,2,,void
67613,BLOCK,-1,,<empty>,5,,1394,1,,void
67627,BLOCK,4,,"{
        end = strchr(type, ',');
        if (end == NULL)
            end = type + strlen(type);

        if (type + extlen == end && !strncasecmp(ext, type, extlen))
            return true;

        if (*end == '\0')
            break;
    }",5,,1395,4,,void
67637,BLOCK,-1,,<empty>,13,,1398,2,,void
67656,BLOCK,-1,,<empty>,13,,1401,2,,void
67664,BLOCK,-1,,<empty>,13,,1404,2,,void
67673,BLOCK,-1,,"{
    return (psz_filename[0] == '\0'
         || strcmp(psz_filename, ""."") == 0
         || strcmp(psz_filename, "".."") == 0
         || (!p_rdh->b_show_hiddenfiles && psz_filename[0] == '.')
         || rdh_file_has_ext(psz_filename, p_rdh->psz_ignored_exts));
}",1,,1412,3,,void
67719,BLOCK,-1,,<empty>,,,,1,,<empty>
67725,BLOCK,-1,,"{
    /* remove leading white spaces */
    while (*psz_filename != '\0' && *psz_filename == ' ')
        psz_filename++;

    char *psz_name = strdup(psz_filename);
    if (!psz_name)
        return NULL;

    /* remove extension */
    char *psz_ptr = strrchr(psz_name, '.');
    if (psz_ptr && psz_ptr != psz_name)
        *psz_ptr = '\0';

    /* remove trailing white spaces */
    int i = strlen(psz_name) - 1;
    while (psz_name[i] == ' ' && i >= 0)
        psz_name[i--] = '\0';

    /* convert to lower case */
    psz_ptr = psz_name;
    while (*psz_ptr != '\0')
    {
        *psz_ptr = tolower(*psz_ptr);
        psz_ptr++;
    }

    return psz_name;
}",1,,1434,2,,void
67746,BLOCK,-1,,<empty>,9,,1441,2,,void
67761,BLOCK,-1,,<empty>,9,,1446,2,,void
67797,BLOCK,-1,,"{
        *psz_ptr = tolower(*psz_ptr);
        psz_ptr++;
    }",5,,1456,2,,void
67814,BLOCK,-1,,"{
    uint8_t i_priority = SLAVE_PRIORITY_MATCH_NONE;
    char *psz_item_name = rdh_name_from_filename(p_item->psz_name);
    char *psz_slave_name = rdh_name_from_filename(psz_slave_filename);

    if (!psz_item_name || !psz_slave_name)
        goto done;

    size_t i_item_len = strlen(psz_item_name);
    size_t i_slave_len = strlen(psz_slave_name);

    /* The slave name len should not be twice longer than the item name len. */
    if (i_item_len > i_slave_len || i_slave_len > 2 * i_item_len)
        goto done;

    /* check if the names match exactly */
    if (!strcmp(psz_item_name, psz_slave_name))
    {
        i_priority = SLAVE_PRIORITY_MATCH_ALL;
        goto done;
    }

    /* ""cdg"" slaves have to be a full match */
    if (p_slave->i_type == SLAVE_TYPE_SPU)
    {
        char *psz_ext = strrchr(psz_slave_name, '.');
        if (psz_ext != NULL && strcasecmp(++psz_ext, ""cdg"") == 0)
            goto done;
    }

    /* check if the item name is a substring of the slave nam...",1,,1467,4,,void
67837,BLOCK,-1,,<empty>,9,,1473,2,,void
67859,BLOCK,-1,,<empty>,9,,1480,2,,void
67866,BLOCK,-1,,"{
        i_priority = SLAVE_PRIORITY_MATCH_ALL;
        goto done;
    }",5,,1484,2,,void
67877,BLOCK,-1,,"{
        char *psz_ext = strrchr(psz_slave_name, '.');
        if (psz_ext != NULL && strcasecmp(++psz_ext, ""cdg"") == 0)
            goto done;
    }",5,,1491,2,,void
67895,BLOCK,-1,,<empty>,13,,1494,2,,void
67905,BLOCK,-1,,"{
        /* check if the item name was found at the end of the slave name */
        if (strlen(psz_sub + strlen(psz_item_name)) == 0)
        {
            i_priority = SLAVE_PRIORITY_MATCH_RIGHT;
            goto done;
        }
        else
        {
            i_priority = SLAVE_PRIORITY_MATCH_LEFT;
            goto done;
        }
    }",5,,1501,2,,void
67914,BLOCK,-1,,"{
            i_priority = SLAVE_PRIORITY_MATCH_RIGHT;
            goto done;
        }",9,,1504,2,,void
67920,BLOCK,-1,,"{
            i_priority = SLAVE_PRIORITY_MATCH_LEFT;
            goto done;
        }",9,,1509,1,,void
67937,BLOCK,-1,,"{
    char *psz_ext = strrchr(p_rdh_sub->psz_filename, '.');
    if (!psz_ext)
        return false;
    psz_ext++;

    if (strcasecmp(psz_ext, ""sub"") != 0)
        return false;

    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];

        if (p_rdh_slave == NULL || p_rdh_slave == p_rdh_sub)
            continue;

        /* check that priorities match */
        if (p_rdh_slave->p_slave->i_priority !=
            p_rdh_sub->p_slave->i_priority)
            continue;

        /* check that the filenames without extension match */
        if (strncasecmp(p_rdh_sub->psz_filename, p_rdh_slave->psz_filename,
                        strlen(p_rdh_sub->psz_filename) - 3 ) != 0)
            continue;

        /* check that we have an idx file */
        char *psz_ext_idx = strrchr(p_rdh_slave->psz_filename, '.');
        if (psz_ext_idx == NULL)
            continue;
        psz_ext_idx++;
        if (strcasecmp(psz_ext_idx, ...",1,,1523,3,,void
67949,BLOCK,-1,,<empty>,9,,1526,2,,void
67960,BLOCK,-1,,<empty>,9,,1530,2,,void
67964,BLOCK,-1,,<empty>,5,,1532,1,,void
67976,BLOCK,4,,"{
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];

        if (p_rdh_slave == NULL || p_rdh_slave == p_rdh_sub)
            continue;

        /* check that priorities match */
        if (p_rdh_slave->p_slave->i_priority !=
            p_rdh_sub->p_slave->i_priority)
            continue;

        /* check that the filenames without extension match */
        if (strncasecmp(p_rdh_sub->psz_filename, p_rdh_slave->psz_filename,
                        strlen(p_rdh_sub->psz_filename) - 3 ) != 0)
            continue;

        /* check that we have an idx file */
        char *psz_ext_idx = strrchr(p_rdh_slave->psz_filename, '.');
        if (psz_ext_idx == NULL)
            continue;
        psz_ext_idx++;
        if (strcasecmp(psz_ext_idx, ""idx"" ) == 0)
            return true;
    }",5,,1533,4,,void
67993,BLOCK,-1,,<empty>,13,,1537,2,,void
68007,BLOCK,-1,,<empty>,13,,1542,2,,void
68025,BLOCK,-1,,<empty>,13,,1547,2,,void
68039,BLOCK,-1,,<empty>,13,,1552,2,,void
68049,BLOCK,-1,,<empty>,13,,1555,2,,void
68059,BLOCK,-1,,"{
    if (p_rdh->i_sub_autodetect_fuzzy == 0)
        return;

    /* Try to match slaves for each items of the node */
    for (int i = 0; i < p_parent_node->i_children; i++)
    {
        input_item_node_t *p_node = p_parent_node->pp_children[i];
        input_item_t *p_item = p_node->p_item;

        enum slave_type unused;
        if (!input_item_IsMaster(p_item->psz_name)
         || input_item_slave_GetType(p_item->psz_name, &unused))
            continue; /* don't match 2 possible slaves between each others */

        for (size_t j = 0; j < p_rdh->i_slaves; j++)
        {
            struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[j];

            /* Don't try to match slaves with themselves or slaves already
             * attached with the higher priority */
            if (p_rdh_slave->p_node == p_node
             || p_rdh_slave->p_slave->i_priority == SLAVE_PRIORITY_MATCH_ALL)
                continue;

            uint8_t i_priority =
                rdh_get_slave_pri...",1,,1562,3,,void
68066,BLOCK,-1,,<empty>,9,,1564,2,,void
68069,BLOCK,-1,,<empty>,5,,1567,1,,void
68081,BLOCK,4,,"{
        input_item_node_t *p_node = p_parent_node->pp_children[i];
        input_item_t *p_item = p_node->p_item;

        enum slave_type unused;
        if (!input_item_IsMaster(p_item->psz_name)
         || input_item_slave_GetType(p_item->psz_name, &unused))
            continue; /* don't match 2 possible slaves between each others */

        for (size_t j = 0; j < p_rdh->i_slaves; j++)
        {
            struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[j];

            /* Don't try to match slaves with themselves or slaves already
             * attached with the higher priority */
            if (p_rdh_slave->p_node == p_node
             || p_rdh_slave->p_slave->i_priority == SLAVE_PRIORITY_MATCH_ALL)
                continue;

            uint8_t i_priority =
                rdh_get_slave_priority(p_item, p_rdh_slave->p_slave,
                                         p_rdh_slave->psz_filename);

            if (i_priority < p_rdh->i_sub_autodetect_fuzzy)
              ...",5,,1568,4,,void
68110,BLOCK,-1,,<empty>,13,,1575,2,,void
68113,BLOCK,-1,,<empty>,9,,1577,1,,void
68125,BLOCK,4,,"{
            struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[j];

            /* Don't try to match slaves with themselves or slaves already
             * attached with the higher priority */
            if (p_rdh_slave->p_node == p_node
             || p_rdh_slave->p_slave->i_priority == SLAVE_PRIORITY_MATCH_ALL)
                continue;

            uint8_t i_priority =
                rdh_get_slave_priority(p_item, p_rdh_slave->p_slave,
                                         p_rdh_slave->psz_filename);

            if (i_priority < p_rdh->i_sub_autodetect_fuzzy)
                continue;

            /* Drop the "".sub"" slave if a "".idx"" slave matches */
            if (p_rdh_slave->p_slave->i_type == SLAVE_TYPE_SPU
             && rdh_should_match_idx(p_rdh, p_rdh_slave))
                continue;

            input_item_slave_t *p_slave =
                input_item_slave_New(p_rdh_slave->p_slave->psz_uri,
                                     p_rdh_slave->p_slave->i_type,
 ...",9,,1578,4,,void
68148,BLOCK,-1,,<empty>,17,,1585,2,,void
68167,BLOCK,-1,,<empty>,17,,1592,2,,void
68181,BLOCK,-1,,<empty>,17,,1597,2,,void
68202,BLOCK,-1,,<empty>,17,,1604,2,,void
68210,BLOCK,-1,,"{
                input_item_slave_Delete(p_slave);
                break;
            }",13,,1607,2,,void
68220,BLOCK,-1,,"{
                input_item_node_RemoveNode(p_parent_node, p_rdh_slave->p_node);
                input_item_node_Delete(p_rdh_slave->p_node);
                p_rdh_slave->p_node = NULL;
            }",13,,1615,2,,void
68243,BLOCK,-1,,<empty>,5,,1626,1,,void
68269,BLOCK,-1,,"{
    /* Create an input input for each sub folders that is contained in the full
     * path. Update pp_node to point to the direct parent of the future item to
     * add. */

    assert(psz_path != NULL);
    const char *psz_subpaths = psz_path;

    while ((psz_subpaths = strchr(psz_subpaths, '/')))
    {
        input_item_node_t *p_subnode = NULL;

        /* Check if this sub folder item was already added */
        for (size_t i = 0; i < p_rdh->i_dirs && p_subnode == NULL; i++)
        {
            struct rdh_dir *rdh_dir = p_rdh->pp_dirs[i];
            if (!strncmp(rdh_dir->psz_path, psz_path, psz_subpaths - psz_path))
                p_subnode = rdh_dir->p_node;
        }

        /* The sub folder item doesn't exist, so create it */
        if (p_subnode == NULL)
        {
            size_t i_sub_path_len = psz_subpaths - psz_path;
            struct rdh_dir *p_rdh_dir =
                malloc(sizeof(struct rdh_dir) + 1 + i_sub_path_len);
            if (p_rdh_dir == N...",1,,1633,5,,void
68284,BLOCK,-1,,"{
        input_item_node_t *p_subnode = NULL;

        /* Check if this sub folder item was already added */
        for (size_t i = 0; i < p_rdh->i_dirs && p_subnode == NULL; i++)
        {
            struct rdh_dir *rdh_dir = p_rdh->pp_dirs[i];
            if (!strncmp(rdh_dir->psz_path, psz_path, psz_subpaths - psz_path))
                p_subnode = rdh_dir->p_node;
        }

        /* The sub folder item doesn't exist, so create it */
        if (p_subnode == NULL)
        {
            size_t i_sub_path_len = psz_subpaths - psz_path;
            struct rdh_dir *p_rdh_dir =
                malloc(sizeof(struct rdh_dir) + 1 + i_sub_path_len);
            if (p_rdh_dir == NULL)
                return VLC_ENOMEM;
            strncpy(p_rdh_dir->psz_path, psz_path, i_sub_path_len);
            p_rdh_dir->psz_path[i_sub_path_len] = 0;

            const char *psz_subpathname = strrchr(p_rdh_dir->psz_path, '/');
            if (psz_subpathname != NULL)
                ++psz_subpath...",5,,1642,2,,void
68290,BLOCK,-1,,<empty>,9,,1646,1,,void
68306,BLOCK,4,,"{
            struct rdh_dir *rdh_dir = p_rdh->pp_dirs[i];
            if (!strncmp(rdh_dir->psz_path, psz_path, psz_subpaths - psz_path))
                p_subnode = rdh_dir->p_node;
        }",9,,1647,4,,void
68325,BLOCK,-1,,<empty>,17,,1650,2,,void
68335,BLOCK,-1,,"{
            size_t i_sub_path_len = psz_subpaths - psz_path;
            struct rdh_dir *p_rdh_dir =
                malloc(sizeof(struct rdh_dir) + 1 + i_sub_path_len);
            if (p_rdh_dir == NULL)
                return VLC_ENOMEM;
            strncpy(p_rdh_dir->psz_path, psz_path, i_sub_path_len);
            p_rdh_dir->psz_path[i_sub_path_len] = 0;

            const char *psz_subpathname = strrchr(p_rdh_dir->psz_path, '/');
            if (psz_subpathname != NULL)
                ++psz_subpathname;
            else
                psz_subpathname = p_rdh_dir->psz_path;

            input_item_t *p_item =
                input_item_NewExt(""vlc://nop"", psz_subpathname, -1,
                                  ITEM_TYPE_DIRECTORY, i_net);
            if (p_item == NULL)
            {
                free(p_rdh_dir);
                return VLC_ENOMEM;
            }
            input_item_CopyOptions(p_item, (*pp_node)->p_item);
            *pp_node = input_item_node_AppendItem...",9,,1655,2,,void
68356,BLOCK,-1,,<empty>,17,,1660,2,,void
68384,BLOCK,-1,,<empty>,17,,1666,2,,void
68388,BLOCK,-1,,<empty>,17,,1668,1,,void
68408,BLOCK,-1,,"{
                free(p_rdh_dir);
                return VLC_ENOMEM;
            }",13,,1674,2,,void
68433,BLOCK,-1,,"{
                free(p_rdh_dir);
                return VLC_ENOMEM;
            }",13,,1682,2,,void
68453,BLOCK,-1,,<empty>,13,,1690,1,,void
68468,BLOCK,-1,,"{
    /* Read options from the parent item. This allows vlc_stream_ReadDir()
     * users to specify options whitout touhing any vlc_object_t. Apply options
     * on a temporary object in order to not apply options (that can be
     * insecure) to the current object. */
    vlc_object_t *p_var_obj = vlc_object_create(p_obj, sizeof(vlc_object_t));
    if (p_var_obj != NULL)
    {
        input_item_ApplyOptions(p_var_obj, p_node->p_item);
        p_obj = p_var_obj;
    }

    p_rdh->p_node = p_node;
    p_rdh->b_show_hiddenfiles = var_InheritBool(p_obj, ""show-hiddenfiles"");
    p_rdh->psz_ignored_exts = var_InheritString(p_obj, ""ignore-filetypes"");
    bool b_autodetect = var_InheritBool(p_obj, ""sub-autodetect-file"");
    p_rdh->i_sub_autodetect_fuzzy = !b_autodetect ? 0 :
        var_InheritInteger(p_obj, ""sub-autodetect-fuzzy"");
    p_rdh->b_flatten = var_InheritBool(p_obj, ""extractor-flatten"");
    TAB_INIT(p_rdh->i_slaves, p_rdh->pp_slaves);
    TAB_INIT(p_rdh->i_dirs, p_rdh->pp...",1,,1699,4,,void
68480,BLOCK,-1,,"{
        input_item_ApplyOptions(p_var_obj, p_node->p_item);
        p_obj = p_var_obj;
    }",5,,1706,2,,void
68550,BLOCK,-1,,<empty>,9,,1722,2,,void
68558,BLOCK,-1,,"{
    if (b_success)
    {
        rdh_sort(p_rdh->p_node);
        rdh_attach_slaves(p_rdh, p_rdh->p_node);
    }
    free(p_rdh->psz_ignored_exts);

    /* Remove unmatched slaves */
    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];
        if (p_rdh_slave != NULL)
        {
            input_item_slave_Delete(p_rdh_slave->p_slave);
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
        }
    }
    TAB_CLEAN(p_rdh->i_slaves, p_rdh->pp_slaves);

    for (size_t i = 0; i < p_rdh->i_dirs; i++)
        free(p_rdh->pp_dirs[i]);
    TAB_CLEAN(p_rdh->i_dirs, p_rdh->pp_dirs);
}",1,,1726,3,,void
68561,BLOCK,-1,,"{
        rdh_sort(p_rdh->p_node);
        rdh_attach_slaves(p_rdh, p_rdh->p_node);
    }",5,,1728,2,,void
68576,BLOCK,-1,,<empty>,5,,1735,1,,void
68588,BLOCK,4,,"{
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];
        if (p_rdh_slave != NULL)
        {
            input_item_slave_Delete(p_rdh_slave->p_slave);
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
        }
    }",5,,1736,4,,void
68601,BLOCK,-1,,"{
            input_item_slave_Delete(p_rdh_slave->p_slave);
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
        }",9,,1739,2,,void
68620,BLOCK,-1,,<empty>,5,,1747,1,,void
68654,BLOCK,-1,,"{
    enum slave_type i_slave_type;
    struct rdh_slave *p_rdh_slave = NULL;
    assert(psz_flatpath || psz_filename);

    if (!p_rdh->b_flatten)
    {
        if (psz_filename == NULL)
        {
            psz_filename = strrchr(psz_flatpath, '/');
            if (psz_filename != NULL)
                ++psz_filename;
            else
                psz_filename = psz_flatpath;
        }
    }
    else
    {
        if (psz_filename == NULL)
            psz_filename = psz_flatpath;
        psz_flatpath = NULL;
    }

    if (p_rdh->i_sub_autodetect_fuzzy != 0
     && input_item_slave_GetType(psz_filename, &i_slave_type))
    {
        p_rdh_slave = malloc(sizeof(*p_rdh_slave));
        if (!p_rdh_slave)
            return VLC_ENOMEM;

        p_rdh_slave->p_node = NULL;
        p_rdh_slave->psz_filename = strdup(psz_filename);
        p_rdh_slave->p_slave = input_item_slave_New(psz_uri, i_slave_type,
                                                      SLAVE_PRIORITY_MATCH_NONE...",1,,1755,7,,void
68669,BLOCK,-1,,"{
        if (psz_filename == NULL)
        {
            psz_filename = strrchr(psz_flatpath, '/');
            if (psz_filename != NULL)
                ++psz_filename;
            else
                psz_filename = psz_flatpath;
        }
    }",5,,1761,2,,void
68674,BLOCK,-1,,"{
            psz_filename = strrchr(psz_flatpath, '/');
            if (psz_filename != NULL)
                ++psz_filename;
            else
                psz_filename = psz_flatpath;
        }",9,,1763,2,,void
68684,BLOCK,-1,,<empty>,17,,1766,2,,void
68688,BLOCK,-1,,<empty>,17,,1768,1,,void
68693,BLOCK,-1,,"{
        if (psz_filename == NULL)
            psz_filename = psz_flatpath;
        psz_flatpath = NULL;
    }",5,,1772,1,,void
68698,BLOCK,-1,,<empty>,13,,1774,2,,void
68716,BLOCK,-1,,"{
        p_rdh_slave = malloc(sizeof(*p_rdh_slave));
        if (!p_rdh_slave)
            return VLC_ENOMEM;

        p_rdh_slave->p_node = NULL;
        p_rdh_slave->psz_filename = strdup(psz_filename);
        p_rdh_slave->p_slave = input_item_slave_New(psz_uri, i_slave_type,
                                                      SLAVE_PRIORITY_MATCH_NONE);
        if (!p_rdh_slave->p_slave || !p_rdh_slave->psz_filename)
        {
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
            return VLC_ENOMEM;
        }

        TAB_APPEND(p_rdh->i_slaves, p_rdh->pp_slaves, p_rdh_slave);
    }",5,,1780,2,,void
68726,BLOCK,-1,,<empty>,13,,1783,2,,void
68758,BLOCK,-1,,"{
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
            return VLC_ENOMEM;
        }",9,,1790,2,,void
68779,BLOCK,-1,,<empty>,9,,1800,2,,void
68792,BLOCK,-1,,"{
        int i_ret = rdh_unflatten(p_rdh, &p_node, psz_flatpath, i_net);
        if (i_ret != VLC_SUCCESS)
            return i_ret;
    }",5,,1805,2,,void
68806,BLOCK,-1,,<empty>,13,,1808,2,,void
68823,BLOCK,-1,,<empty>,9,,1814,2,,void
68842,BLOCK,-1,,<empty>,9,,1820,2,,void
68849,BLOCK,-1,,<empty>,9,,1826,2,,void
68867,BLOCK,-1,,<empty>,1,,1,1,,ANY
68871,BLOCK,-1,,<empty>,,,,3,,<empty>
68877,BLOCK,-1,,<empty>,,,,3,,<empty>
68882,BLOCK,-1,,<empty>,,,,2,,<empty>
68913,BLOCK,-1,,<empty>,1,,1,1,,ANY
68919,BLOCK,-1,,<empty>,,,,1,,<empty>
68926,BLOCK,-1,,"{
    static const char posix_names[][18] =
    {
        [vlc_meta_Title]       = N_(""Title""),
        [vlc_meta_Artist]      = N_(""Artist""),
        [vlc_meta_Genre]       = N_(""Genre""),
        [vlc_meta_Copyright]   = N_(""Copyright""),
        [vlc_meta_Album]       = N_(""Album""),
        [vlc_meta_TrackNumber] = N_(""Track number""),
        [vlc_meta_Description] = N_(""Description""),
        [vlc_meta_Rating]      = N_(""Rating""),
        [vlc_meta_Date]        = N_(""Date""),
        [vlc_meta_Setting]     = N_(""Setting""),
        [vlc_meta_URL]         = N_(""URL""),
        [vlc_meta_Language]    = N_(""Language""),
        [vlc_meta_ESNowPlaying]= N_(""Now Playing""),
        [vlc_meta_NowPlaying]  = N_(""Now Playing""),
        [vlc_meta_Publisher]   = N_(""Publisher""),
        [vlc_meta_EncodedBy]   = N_(""Encoded by""),
        [vlc_meta_ArtworkURL]  = N_(""Artwork URL""),
        [vlc_meta_TrackID]     = N_(""Track ID""),
        [vlc_meta_TrackTotal]  = N_(""Number of Tracks""),
        [vl...",1,,52,2,,void
68931,BLOCK,1,,<empty>,9,,55,1,,void
68936,BLOCK,2,,<empty>,9,,56,2,,void
68941,BLOCK,3,,<empty>,9,,57,3,,void
68946,BLOCK,4,,<empty>,9,,58,4,,void
68951,BLOCK,5,,<empty>,9,,59,5,,void
68956,BLOCK,6,,<empty>,9,,60,6,,void
68961,BLOCK,7,,<empty>,9,,61,7,,void
68966,BLOCK,8,,<empty>,9,,62,8,,void
68971,BLOCK,9,,<empty>,9,,63,9,,void
68976,BLOCK,10,,<empty>,9,,64,10,,void
68981,BLOCK,11,,<empty>,9,,65,11,,void
68986,BLOCK,12,,<empty>,9,,66,12,,void
68991,BLOCK,13,,<empty>,9,,67,13,,void
68996,BLOCK,14,,<empty>,9,,68,14,,void
69001,BLOCK,15,,<empty>,9,,69,15,,void
69006,BLOCK,16,,<empty>,9,,70,16,,void
69011,BLOCK,17,,<empty>,9,,71,17,,void
69016,BLOCK,18,,<empty>,9,,72,18,,void
69021,BLOCK,19,,<empty>,9,,73,19,,void
69026,BLOCK,20,,<empty>,9,,74,20,,void
69031,BLOCK,21,,<empty>,9,,75,21,,void
69036,BLOCK,22,,<empty>,9,,76,22,,void
69041,BLOCK,23,,<empty>,9,,77,23,,void
69046,BLOCK,24,,<empty>,9,,78,24,,void
69051,BLOCK,25,,<empty>,9,,79,25,,void
69056,BLOCK,26,,<empty>,9,,80,26,,void
69080,BLOCK,-1,,"{
    vlc_meta_t *m = (vlc_meta_t*)malloc( sizeof(*m) );
    if( !m )
        return NULL;
    memset( m->ppsz_meta, 0, sizeof(m->ppsz_meta) );
    m->i_status = 0;
    vlc_dictionary_init( &m->extra_tags, 0 );
    return m;
}",1,,93,2,,void
69093,BLOCK,-1,,<empty>,9,,96,2,,void
69123,BLOCK,-1,,"{
    VLC_UNUSED( p_obj );
    free( p_data );
}",1,,105,3,,void
69132,BLOCK,-1,,"{
    for( int i = 0; i < VLC_META_TYPE_COUNT ; i++ )
        free( m->ppsz_meta[i] );
    vlc_dictionary_clear( &m->extra_tags, vlc_meta_FreeExtraKey, NULL );
    free( m );
}",1,,111,2,,void
69134,BLOCK,-1,,<empty>,5,,112,1,,void
69165,BLOCK,-1,,"{
    free( p_meta->ppsz_meta[meta_type] );
    assert( psz_val == NULL || IsUTF8( psz_val ) );
    p_meta->ppsz_meta[meta_type] = psz_val ? strdup( psz_val ) : NULL;
}",1,,125,4,,void
69195,BLOCK,-1,,"{
    return p_meta->ppsz_meta[meta_type];
}",1,,132,3,,void
69208,BLOCK,-1,,"{
    char *psz_oldvalue = (char *)vlc_dictionary_value_for_key( &m->extra_tags, psz_name );
    if( psz_oldvalue != kVLCDictionaryNotFound )
        vlc_dictionary_remove_value_for_key( &m->extra_tags, psz_name,
                                            vlc_meta_FreeExtraKey, NULL );
    vlc_dictionary_insert( &m->extra_tags, psz_name, strdup(psz_value) );
}",1,,137,4,,void
69224,BLOCK,-1,,<empty>,9,,140,2,,void
69246,BLOCK,-1,,"{
    return (char *)vlc_dictionary_value_for_key(&m->extra_tags, psz_name);
}",1,,146,3,,void
69260,BLOCK,-1,,"{
    return vlc_dictionary_keys_count(&m->extra_tags);
}",1,,151,2,,void
69271,BLOCK,-1,,"{
    return vlc_dictionary_all_keys(&m->extra_tags);
}",1,,156,2,,void
69282,BLOCK,-1,,"{
    return m->i_status;
}",1,,164,2,,void
69292,BLOCK,-1,,"{
    m->i_status = status;
}",1,,169,3,,void
69303,BLOCK,-1,,"{
    if( !dst || !src )
        return;

    for( int i = 0; i < VLC_META_TYPE_COUNT; i++ )
    {
        if( src->ppsz_meta[i] )
        {
            free( dst->ppsz_meta[i] );
            dst->ppsz_meta[i] = strdup( src->ppsz_meta[i] );
        }
    }

    /* XXX: If speed up are needed, it is possible */
    char **ppsz_all_keys = vlc_dictionary_all_keys( &src->extra_tags );
    for( int i = 0; ppsz_all_keys && ppsz_all_keys[i]; i++ )
    {
        /* Always try to remove the previous value */
        vlc_dictionary_remove_value_for_key( &dst->extra_tags, ppsz_all_keys[i], vlc_meta_FreeExtraKey, NULL );

        void *p_value = vlc_dictionary_value_for_key( &src->extra_tags, ppsz_all_keys[i] );
        vlc_dictionary_insert( &dst->extra_tags, ppsz_all_keys[i], strdup( (const char*)p_value ) );
        free( ppsz_all_keys[i] );
    }
    free( ppsz_all_keys );
}",1,,178,3,,void
69310,BLOCK,-1,,<empty>,9,,180,2,,void
69313,BLOCK,-1,,<empty>,5,,182,1,,void
69323,BLOCK,4,,"{
        if( src->ppsz_meta[i] )
        {
            free( dst->ppsz_meta[i] );
            dst->ppsz_meta[i] = strdup( src->ppsz_meta[i] );
        }
    }",5,,183,4,,void
69330,BLOCK,-1,,"{
            free( dst->ppsz_meta[i] );
            dst->ppsz_meta[i] = strdup( src->ppsz_meta[i] );
        }",9,,185,2,,void
69358,BLOCK,-1,,<empty>,5,,193,1,,void
69370,BLOCK,4,,"{
        /* Always try to remove the previous value */
        vlc_dictionary_remove_value_for_key( &dst->extra_tags, ppsz_all_keys[i], vlc_meta_FreeExtraKey, NULL );

        void *p_value = vlc_dictionary_value_for_key( &src->extra_tags, ppsz_all_keys[i] );
        vlc_dictionary_insert( &dst->extra_tags, ppsz_all_keys[i], strdup( (const char*)p_value ) );
        free( ppsz_all_keys[i] );
    }",5,,194,4,,void
69415,BLOCK,-1,,"{
    input_item_t *p_item = input_priv(p_input)->p_item;

    if( input_item_IsArtFetched( p_item ) )
    {   /* XXX Weird, we should not end up with attachment:// art URL
         * unless there is a race condition */
        msg_Warn( p_input, ""art already fetched"" );
        if( likely(playlist_FindArtInCache( p_item ) == VLC_SUCCESS) )
            return;
    }

    /* */
    input_attachment_t *p_attachment = NULL;

    vlc_mutex_lock( &p_item->lock );
    for( int i_idx = 0; i_idx < input_priv(p_input)->i_attachment; i_idx++ )
    {
        input_attachment_t *a = input_priv(p_input)->attachment[i_idx];

        if( !strcmp( a->psz_name, name ) )
        {
            p_attachment = vlc_input_attachment_Duplicate( a );
            break;
        }
    }
    vlc_mutex_unlock( &p_item->lock );

    if( p_attachment == NULL )
    {
        msg_Warn( p_input, ""art attachment %s not found"", name );
        return;
    }

    /* */
    const char *psz_type = NULL;

    if( !strcmp(...",1,,208,3,,void
69426,BLOCK,-1,,"{   /* XXX Weird, we should not end up with attachment:// art URL
         * unless there is a race condition */
        msg_Warn( p_input, ""art already fetched"" );
        if( likely(playlist_FindArtInCache( p_item ) == VLC_SUCCESS) )
            return;
    }",5,,212,2,,void
69436,BLOCK,-1,,<empty>,13,,216,2,,void
69448,BLOCK,-1,,<empty>,5,,223,1,,void
69461,BLOCK,4,,"{
        input_attachment_t *a = input_priv(p_input)->attachment[i_idx];

        if( !strcmp( a->psz_name, name ) )
        {
            p_attachment = vlc_input_attachment_Duplicate( a );
            break;
        }
    }",5,,224,4,,void
69478,BLOCK,-1,,"{
            p_attachment = vlc_input_attachment_Duplicate( a );
            break;
        }",9,,228,2,,void
69493,BLOCK,-1,,"{
        msg_Warn( p_input, ""art attachment %s not found"", name );
        return;
    }",5,,236,2,,void
69510,BLOCK,-1,,<empty>,9,,245,2,,void
69515,BLOCK,-1,,<empty>,10,,246,1,,void
69523,BLOCK,-1,,<empty>,9,,247,2,,void
69528,BLOCK,-1,,<empty>,10,,248,1,,void
69536,BLOCK,-1,,<empty>,9,,249,2,,void
69558,BLOCK,-1,,"{
    meta_export_t *p_export =
        vlc_custom_create( obj, sizeof( *p_export ), ""meta writer"" );
    if( p_export == NULL )
        return VLC_ENOMEM;
    p_export->p_item = p_item;

    int type;
    vlc_mutex_lock( &p_item->lock );
    type = p_item->i_type;
    vlc_mutex_unlock( &p_item->lock );
    if( type != ITEM_TYPE_FILE )
        goto error;

    char *psz_uri = input_item_GetURI( p_item );
    p_export->psz_file = vlc_uri2path( psz_uri );
    if( p_export->psz_file == NULL )
        msg_Err( p_export, ""cannot write meta to remote media %s"", psz_uri );
    free( psz_uri );
    if( p_export->psz_file == NULL )
        goto error;

    module_t *p_mod = module_need( p_export, ""meta writer"", NULL, false );
    if( p_mod )
        module_unneed( p_export, p_mod );
    vlc_object_release( p_export );
    return VLC_SUCCESS;

error:
    vlc_object_release( p_export );
    return VLC_EGENERIC;
}",1,,257,3,,void
69572,BLOCK,-1,,<empty>,9,,261,2,,void
69600,BLOCK,-1,,<empty>,9,,269,2,,void
69619,BLOCK,-1,,<empty>,9,,274,2,,void
69632,BLOCK,-1,,<empty>,9,,277,2,,void
69644,BLOCK,-1,,<empty>,9,,281,2,,void
69662,BLOCK,-1,,"{
    const char * psz_value;

    if( !p_meta )
        return;

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_GAIN"")) ||
        (psz_value = vlc_meta_GetExtra(p_meta, ""RG_RADIO"")) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_gain[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_PEAK"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_PEAK"" )) )
    {
        p_dst->pb_peak[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_peak[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_ALBUM_GAIN"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_AUDIOPHILE"" )) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_ALBUM] = true;
        p_dst->pf_gain[AUDIO_REPLAY_GAIN_ALBUM] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_ALBUM_PEAK"" )) )
...",1,,292,3,,void
69667,BLOCK,-1,,<empty>,9,,296,2,,void
69681,BLOCK,-1,,"{
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_gain[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }",5,,300,2,,void
69709,BLOCK,-1,,"{
        p_dst->pb_peak[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_peak[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }",5,,307,2,,void
69737,BLOCK,-1,,"{
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_ALBUM] = true;
        p_dst->pf_gain[AUDIO_REPLAY_GAIN_ALBUM] = us_atof( psz_value );
    }",5,,314,2,,void
69759,BLOCK,-1,,"{
        p_dst->pb_peak[AUDIO_REPLAY_GAIN_ALBUM] = true;
        p_dst->pf_peak[AUDIO_REPLAY_GAIN_ALBUM] = us_atof( psz_value );
    }",5,,320,2,,void
69793,BLOCK,-1,,<empty>,1,,1,1,,ANY
69797,BLOCK,-1,,"{
    struct vlc_memstream mstream;

#define RFC3986_SUBDELIMS  ""!"" ""$"" ""&"" ""'"" ""("" "")"" \
                           ""*"" ""+"" "","" "";"" ""=""
#define RFC3986_ALPHA      ""abcdefghijklmnopqrstuvwxyz"" \
                           ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
#define RFC3986_DIGIT      ""0123456789""
#define RFC3986_UNRESERVED RFC3986_ALPHA RFC3986_DIGIT ""-"" ""."" ""_"" ""~""
#define RFC3986_PCHAR      RFC3986_UNRESERVED RFC3986_SUBDELIMS "":"" ""@""
#define RFC3986_FRAGMENT   RFC3986_PCHAR ""/"" ""?""

    if( vlc_memstream_open( &mstream ) )
        return VLC_EGENERIC;

    for( char const* p = payload; *p; ++p )
    {
        vlc_memstream_printf( &mstream,
            ( strchr( ""!?"", *p ) == NULL &&
              strchr( RFC3986_FRAGMENT, *p ) ? ""%c"" : ""%%%02hhx""), *p );
    }

#undef RFC3986_FRAGMENT
#undef RFC3986_PCHAR
#undef RFC3986_UNRESERVEd
#undef RFC3986_DIGIT
#undef RFC3986_ALPHA
#undef RFC3986_SUBDELIMS

    if( vlc_memstream_close( &mstream ) )
        return VLC_EGENERIC;

    *out = mstrea...",1,,59,3,,void
69803,BLOCK,-1,,<empty>,9,,72,2,,void
69807,BLOCK,-1,,<empty>,5,,74,1,,void
69816,BLOCK,4,,"{
        vlc_memstream_printf( &mstream,
            ( strchr( ""!?"", *p ) == NULL &&
              strchr( RFC3986_FRAGMENT, *p ) ? ""%c"" : ""%%%02hhx""), *p );
    }",5,,75,4,,void
69830,BLOCK,1,,<empty>,,,,1,,void
69842,BLOCK,-1,,<empty>,9,,89,2,,void
69859,BLOCK,-1,,"{
    char const* extra = NULL;

    vlc_array_init( out_items );

    while( strncmp( payload, ""!/"", 2 ) == 0 )
    {
        payload += 2;

        int len = strcspn( payload, ""!?"" );
        char* decoded = strndup( payload, len );

        if( unlikely( !decoded ) || !vlc_uri_decode( decoded ) )
            goto error;

        if( vlc_array_append( out_items, decoded ) )
        {
            free( decoded );
            goto error;
        }
        payload += len;
    }

    if( *payload )
    {
        if( *payload == '!' )
            goto error;

        if( *payload == '?' && vlc_array_count( out_items ) )
            ++payload;

        extra = payload;
    }

    *out_extra = extra;
    return VLC_SUCCESS;

error:
    for( size_t i = 0; i < vlc_array_count( out_items ); ++i )
        free( vlc_array_item_at_index( out_items, i ) );
    vlc_array_clear( out_items );
    return VLC_EGENERIC;;
}",1,,118,4,,void
69873,BLOCK,-1,,"{
        payload += 2;

        int len = strcspn( payload, ""!?"" );
        char* decoded = strndup( payload, len );

        if( unlikely( !decoded ) || !vlc_uri_decode( decoded ) )
            goto error;

        if( vlc_array_append( out_items, decoded ) )
        {
            free( decoded );
            goto error;
        }
        payload += len;
    }",5,,124,2,,void
69897,BLOCK,-1,,<empty>,13,,131,2,,void
69903,BLOCK,-1,,"{
            free( decoded );
            goto error;
        }",9,,134,2,,void
69913,BLOCK,-1,,"{
        if( *payload == '!' )
            goto error;

        if( *payload == '?' && vlc_array_count( out_items ) )
            ++payload;

        extra = payload;
    }",5,,142,2,,void
69919,BLOCK,-1,,<empty>,13,,144,2,,void
69929,BLOCK,-1,,<empty>,13,,147,2,,void
69943,BLOCK,-1,,<empty>,5,,156,1,,void
69996,BLOCK,-1,,<empty>,1,,1,1,,ANY
70011,BLOCK,-1,,"{
#ifdef ENABLE_SOUT
    if( p_resource->p_sout )
        sout_DeleteInstance( p_resource->p_sout );
#endif
    p_resource->p_sout = NULL;
}",1,,80,2,,void
70023,BLOCK,-1,,"{
#ifdef ENABLE_SOUT
    if( !p_sout && !psz_sout )
    {
        if( p_resource->p_sout )
        {
            msg_Dbg( p_resource->p_sout, ""destroying useless sout"" );
            DestroySout( p_resource );
        }
        return NULL;
    }

    assert( !p_sout || ( !p_resource->p_sout && !psz_sout ) );

    /* Check the validity of the sout */
    if( p_resource->p_sout &&
        strcmp( p_resource->p_sout->psz_sout, psz_sout ) )
    {
        msg_Dbg( p_resource->p_parent, ""destroying unusable sout"" );
        DestroySout( p_resource );
    }

    if( psz_sout )
    {
        if( p_resource->p_sout )
        {
            /* Reuse it */
            msg_Dbg( p_resource->p_parent, ""reusing sout"" );
            msg_Dbg( p_resource->p_parent, ""you probably want to use gather stream_out"" );
        }
        else
        {
            /* Create a new one */
            p_resource->p_sout = sout_NewInstance( p_resource->p_parent, psz_sout );
        }

        p_sout = p_resource...",1,,90,4,,void
70036,BLOCK,-1,,"{
    assert( p_resource->i_vout == 0 );

    if( p_resource->p_vout_free )
        vout_CloseAndRelease( p_resource->p_vout_free );

    p_resource->p_vout_free = NULL;
}",1,,144,2,,void
70047,BLOCK,-1,,<empty>,9,,148,2,,void
70062,BLOCK,-1,,"{
    if( p_resource->p_input == NULL )
        return;

    /* TODO display the title only one time for the same input ? */

    input_item_t *p_item = input_GetItem( p_resource->p_input );

    char *psz_nowplaying = input_item_GetNowPlayingFb( p_item );
    if( psz_nowplaying && *psz_nowplaying )
    {
        vout_DisplayTitle( p_vout, psz_nowplaying );
    }
    else
    {
        char *psz_artist = input_item_GetArtist( p_item );
        char *psz_name = input_item_GetTitle( p_item );

        if( !psz_name || *psz_name == '\0' )
        {
            free( psz_name );
            psz_name = input_item_GetName( p_item );
        }
        if( psz_artist && *psz_artist )
        {
            char *psz_string;
            if( asprintf( &psz_string, ""%s - %s"", psz_name, psz_artist ) != -1 )
            {
                vout_DisplayTitle( p_vout, psz_string );
                free( psz_string );
            }
        }
        else if( psz_name )
        {
            vout_Displ...",1,,155,3,,void
70069,BLOCK,-1,,<empty>,9,,157,2,,void
70088,BLOCK,-1,,"{
        vout_DisplayTitle( p_vout, psz_nowplaying );
    }",5,,165,2,,void
70093,BLOCK,-1,,"{
        char *psz_artist = input_item_GetArtist( p_item );
        char *psz_name = input_item_GetTitle( p_item );

        if( !psz_name || *psz_name == '\0' )
        {
            free( psz_name );
            psz_name = input_item_GetName( p_item );
        }
        if( psz_artist && *psz_artist )
        {
            char *psz_string;
            if( asprintf( &psz_string, ""%s - %s"", psz_name, psz_artist ) != -1 )
            {
                vout_DisplayTitle( p_vout, psz_string );
                free( psz_string );
            }
        }
        else if( psz_name )
        {
            vout_DisplayTitle( p_vout, psz_name );
        }
        free( psz_name );
        free( psz_artist );
    }",5,,169,1,,void
70112,BLOCK,-1,,"{
            free( psz_name );
            psz_name = input_item_GetName( p_item );
        }",9,,174,2,,void
70124,BLOCK,-1,,"{
            char *psz_string;
            if( asprintf( &psz_string, ""%s - %s"", psz_name, psz_artist ) != -1 )
            {
                vout_DisplayTitle( p_vout, psz_string );
                free( psz_string );
            }
        }",9,,179,2,,void
70136,BLOCK,-1,,"{
                vout_DisplayTitle( p_vout, psz_string );
                free( psz_string );
            }",13,,182,2,,void
70143,BLOCK,-1,,<empty>,14,,187,1,,void
70146,BLOCK,-1,,"{
            vout_DisplayTitle( p_vout, psz_name );
        }",9,,188,2,,void
70164,BLOCK,-1,,"{
    vlc_assert_locked( &p_resource->lock );

    if( !p_vout && !p_fmt )
    {
        if( p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_vout_free, ""destroying useless vout"" );
            vout_CloseAndRelease( p_resource->p_vout_free );
            p_resource->p_vout_free = NULL;
        }
        return NULL;
    }

    if( p_fmt )
    {
        /* */
        if( !p_vout && p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_parent, ""trying to reuse free vout"" );
            p_vout = p_resource->p_vout_free;

            p_resource->p_vout_free = NULL;
        }
        else if( p_vout )
        {
            assert( p_vout != p_resource->p_vout_free );

            vlc_mutex_lock( &p_resource->lock_hold );
            TAB_REMOVE( p_resource->i_vout, p_resource->pp_vout, p_vout );
            vlc_mutex_unlock( &p_resource->lock_hold );
        }

        /* */
        vout_configuration_t cfg = {
            .vout       = p_vout,
     ...",1,,200,6,,void
70170,BLOCK,1,,<empty>,,,,2,,void
70183,BLOCK,-1,,"{
        if( p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_vout_free, ""destroying useless vout"" );
            vout_CloseAndRelease( p_resource->p_vout_free );
            p_resource->p_vout_free = NULL;
        }
        return NULL;
    }",5,,204,2,,void
70188,BLOCK,-1,,"{
            msg_Dbg( p_resource->p_vout_free, ""destroying useless vout"" );
            vout_CloseAndRelease( p_resource->p_vout_free );
            p_resource->p_vout_free = NULL;
        }",9,,206,2,,void
70207,BLOCK,-1,,"{
        /* */
        if( !p_vout && p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_parent, ""trying to reuse free vout"" );
            p_vout = p_resource->p_vout_free;

            p_resource->p_vout_free = NULL;
        }
        else if( p_vout )
        {
            assert( p_vout != p_resource->p_vout_free );

            vlc_mutex_lock( &p_resource->lock_hold );
            TAB_REMOVE( p_resource->i_vout, p_resource->pp_vout, p_vout );
            vlc_mutex_unlock( &p_resource->lock_hold );
        }

        /* */
        vout_configuration_t cfg = {
            .vout       = p_vout,
            .input      = VLC_OBJECT(p_resource->p_input),
            .change_fmt = true,
            .fmt        = p_fmt,
            .dpb_size   = dpb_size,
        };
        p_vout = vout_Request( p_resource->p_parent, &cfg );
        if( !p_vout )
            return NULL;

        DisplayVoutTitle( p_resource, p_vout );

        /* Send original viewpoint to the i...",5,,215,2,,void
70215,BLOCK,-1,,"{
            msg_Dbg( p_resource->p_parent, ""trying to reuse free vout"" );
            p_vout = p_resource->p_vout_free;

            p_resource->p_vout_free = NULL;
        }",9,,218,2,,void
70232,BLOCK,-1,,<empty>,14,,224,1,,void
70235,BLOCK,-1,,"{
            assert( p_vout != p_resource->p_vout_free );

            vlc_mutex_lock( &p_resource->lock_hold );
            TAB_REMOVE( p_resource->i_vout, p_resource->pp_vout, p_vout );
            vlc_mutex_unlock( &p_resource->lock_hold );
        }",9,,225,2,,void
70264,BLOCK,1,,<empty>,13,,235,1,,void
70268,BLOCK,2,,<empty>,13,,236,2,,void
70275,BLOCK,3,,<empty>,13,,237,3,,void
70279,BLOCK,4,,<empty>,13,,238,4,,void
70283,BLOCK,5,,<empty>,13,,239,5,,void
70298,BLOCK,-1,,<empty>,13,,243,2,,void
70310,BLOCK,-1,,<empty>,13,,249,2,,void
70341,BLOCK,-1,,"{
        assert( p_vout );

        vlc_mutex_lock( &p_resource->lock_hold );
        TAB_REMOVE( p_resource->i_vout, p_resource->pp_vout, p_vout );
        const int i_vout_active = p_resource->i_vout;
        vlc_mutex_unlock( &p_resource->lock_hold );

        if( p_resource->p_vout_free || i_vout_active > 0 || !b_recycle )
        {
            if( b_recycle )
                msg_Dbg( p_resource->p_parent, ""destroying vout (already one saved or active)"" );
            vout_CloseAndRelease( p_vout );
        }
        else
        {
            msg_Dbg( p_resource->p_parent, ""saving a free vout"" );
            vout_Flush( p_vout, 1 );
            vout_FlushSubpictureChannel( p_vout, -1 );

            vout_configuration_t cfg = {
                .vout       = p_vout,
                .input      = NULL,
                .change_fmt = false,
                .fmt        = NULL,
                .dpb_size   = 0,
            };
            p_resource->p_vout_free = vout_Request( p_reso...",5,,259,1,,void
70379,BLOCK,-1,,"{
            if( b_recycle )
                msg_Dbg( p_resource->p_parent, ""destroying vout (already one saved or active)"" );
            vout_CloseAndRelease( p_vout );
        }",9,,268,2,,void
70382,BLOCK,-1,,<empty>,17,,270,2,,void
70391,BLOCK,-1,,"{
            msg_Dbg( p_resource->p_parent, ""saving a free vout"" );
            vout_Flush( p_vout, 1 );
            vout_FlushSubpictureChannel( p_vout, -1 );

            vout_configuration_t cfg = {
                .vout       = p_vout,
                .input      = NULL,
                .change_fmt = false,
                .fmt        = NULL,
                .dpb_size   = 0,
            };
            p_resource->p_vout_free = vout_Request( p_resource->p_parent, &cfg );
        }",9,,274,1,,void
70408,BLOCK,1,,<empty>,17,,280,1,,void
70412,BLOCK,2,,<empty>,17,,281,2,,void
70416,BLOCK,3,,<empty>,17,,282,3,,void
70420,BLOCK,4,,<empty>,17,,283,4,,void
70424,BLOCK,5,,<empty>,17,,284,5,,void
70444,BLOCK,-1,,"{
    /* TODO FIXME: p_resource->pp_vout order is NOT stable */
    vlc_mutex_lock( &p_resource->lock_hold );

    vout_thread_t *p_vout = p_resource->i_vout > 0 ? p_resource->pp_vout[0] : NULL;
    if( p_vout )
        vlc_object_hold( p_vout );

    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_vout;
}",1,,292,2,,void
70467,BLOCK,-1,,<empty>,9,,298,2,,void
70483,BLOCK,-1,,"{
    vout_thread_t **pp_vout;

    *pi_vout = 0;
    *ppp_vout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );

    if( p_resource->i_vout <= 0 )
        goto exit;

    pp_vout = vlc_alloc( p_resource->i_vout, sizeof(*pp_vout) );
    if( !pp_vout )
        goto exit;

    *ppp_vout = pp_vout;
    *pi_vout = p_resource->i_vout;

    for( int i = 0; i < p_resource->i_vout; i++ )
    {
        pp_vout[i] = p_resource->pp_vout[i];
        vlc_object_hold( pp_vout[i] );
    }

exit:
    vlc_mutex_unlock( &p_resource->lock_hold );
}",1,,307,4,,void
70504,BLOCK,-1,,<empty>,9,,316,2,,void
70518,BLOCK,-1,,<empty>,9,,320,2,,void
70531,BLOCK,-1,,<empty>,5,,325,1,,void
70543,BLOCK,4,,"{
        pp_vout[i] = p_resource->pp_vout[i];
        vlc_object_hold( pp_vout[i] );
    }",5,,326,4,,void
70567,BLOCK,-1,,"{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;

    if( p_aout == NULL || p_resource->b_aout_busy )
    {
        msg_Dbg( p_resource->p_parent, ""creating audio output"" );
        vlc_mutex_unlock( &p_resource->lock_hold );

        p_aout = aout_New( p_resource->p_parent );
        if( p_aout == NULL )
            return NULL; /* failed */

        vlc_mutex_lock( &p_resource->lock_hold );
        if( p_resource->p_aout == NULL )
            p_resource->p_aout = p_aout;
    }
    else
        msg_Dbg( p_resource->p_parent, ""reusing audio output"" );

    if( p_resource->p_aout == p_aout )
    {
        assert( !p_resource->b_aout_busy );
        p_resource->b_aout_busy = true;
    }
    vlc_mutex_unlock( &p_resource->lock_hold );
    return p_aout;
}",1,,337,2,,void
70587,BLOCK,-1,,"{
        msg_Dbg( p_resource->p_parent, ""creating audio output"" );
        vlc_mutex_unlock( &p_resource->lock_hold );

        p_aout = aout_New( p_resource->p_parent );
        if( p_aout == NULL )
            return NULL; /* failed */

        vlc_mutex_lock( &p_resource->lock_hold );
        if( p_resource->p_aout == NULL )
            p_resource->p_aout = p_aout;
    }",5,,344,2,,void
70604,BLOCK,1,,<empty>,,,,2,,void
70614,BLOCK,-1,,<empty>,13,,350,2,,void
70628,BLOCK,-1,,<empty>,13,,354,2,,void
70635,BLOCK,-1,,<empty>,9,,357,1,,void
70647,BLOCK,-1,,"{
        assert( !p_resource->b_aout_busy );
        p_resource->b_aout_busy = true;
    }",5,,360,2,,void
70670,BLOCK,-1,,"{
    assert( p_aout != NULL );

    vlc_mutex_lock( &p_resource->lock_hold );
    if( p_aout == p_resource->p_aout )
    {
        assert( p_resource->b_aout_busy );
        p_resource->b_aout_busy = false;
        msg_Dbg( p_resource->p_parent, ""keeping audio output"" );
        p_aout = NULL;
    }
    else
        msg_Dbg( p_resource->p_parent, ""destroying extra audio output"" );
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",1,,370,3,,void
70686,BLOCK,-1,,"{
        assert( p_resource->b_aout_busy );
        p_resource->b_aout_busy = false;
        msg_Dbg( p_resource->p_parent, ""keeping audio output"" );
        p_aout = NULL;
    }",5,,375,2,,void
70705,BLOCK,-1,,<empty>,9,,382,1,,void
70720,BLOCK,-1,,<empty>,9,,386,2,,void
70727,BLOCK,-1,,"{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;
    if( p_aout != NULL )
        vlc_object_hold( p_aout );
    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_aout;
}",1,,390,2,,void
70743,BLOCK,-1,,<empty>,9,,396,2,,void
70757,BLOCK,-1,,"{
    audio_output_t *p_aout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );
    if( !p_resource->b_aout_busy )
        p_aout = p_resource->p_aout;

    p_resource->p_aout = NULL;
    p_resource->b_aout_busy = false;
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",1,,403,2,,void
70772,BLOCK,-1,,<empty>,9,,408,2,,void
70797,BLOCK,-1,,<empty>,9,,415,2,,void
70804,BLOCK,-1,,"{
    input_resource_t *p_resource = calloc( 1, sizeof(*p_resource) );
    if( !p_resource )
        return NULL;

    atomic_init( &p_resource->refs, 1 );
    p_resource->p_parent = p_parent;
    vlc_mutex_init( &p_resource->lock );
    vlc_mutex_init( &p_resource->lock_hold );
    return p_resource;
}",1,,420,2,,void
70816,BLOCK,-1,,<empty>,9,,423,2,,void
70846,BLOCK,-1,,"{
    if( atomic_fetch_sub( &p_resource->refs, 1 ) != 1 )
        return;

    DestroySout( p_resource );
    DestroyVout( p_resource );
    if( p_resource->p_aout != NULL )
        aout_Destroy( p_resource->p_aout );

    vlc_mutex_destroy( &p_resource->lock_hold );
    vlc_mutex_destroy( &p_resource->lock );
    free( p_resource );
}",1,,433,2,,void
70856,BLOCK,-1,,<empty>,9,,435,2,,void
70868,BLOCK,-1,,<empty>,9,,440,2,,void
70889,BLOCK,-1,,"{
    atomic_fetch_add( &p_resource->refs, 1 );
    return p_resource;
}",1,,448,2,,void
70903,BLOCK,-1,,"{
    vlc_mutex_lock( &p_resource->lock );

    if( p_resource->p_input && !p_input )
        assert( p_resource->i_vout == 0 );

    /* */
    p_resource->p_input = p_input;

    vlc_mutex_unlock( &p_resource->lock );
}",1,,454,3,,void
70916,BLOCK,-1,,<empty>,9,,458,2,,void
70941,BLOCK,-1,,"{
    vlc_mutex_lock( &p_resource->lock );
    vout_thread_t *p_ret = RequestVout( p_resource, p_vout, p_fmt, dpb_size, b_recycle );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",1,,470,6,,void
70967,BLOCK,-1,,"{
    return HoldVout( p_resource );
}",1,,478,2,,void
70977,BLOCK,-1,,"{
    HoldVouts( p_resource, ppp_vout, pi_vout );
}",1,,484,4,,void
70986,BLOCK,-1,,"{
    input_resource_RequestVout( p_resource, NULL, NULL, 0, false );
}",1,,489,2,,void
70997,BLOCK,-1,,"{
    vlc_mutex_lock( &p_resource->lock );
    assert( !p_resource->p_input );
    const bool b_vout = p_resource->p_vout_free != NULL;
    vlc_mutex_unlock( &p_resource->lock );

    return b_vout;
}",1,,493,2,,void
71029,BLOCK,-1,,"{
    vlc_mutex_lock( &p_resource->lock );
    sout_instance_t *p_ret = RequestSout( p_resource, p_sout, psz_sout );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",1,,504,4,,void
71053,BLOCK,-1,,"{
    input_resource_RequestSout( p_resource, NULL, NULL );
}",1,,512,2,,void
71062,BLOCK,-1,,"{
    input_resource_TerminateSout( p_resource );
    input_resource_ResetAout( p_resource );
    input_resource_TerminateVout( p_resource );
}",1,,517,2,,void
71077,BLOCK,-1,,<empty>,1,,1,1,,ANY
71081,BLOCK,-1,,<empty>,,,,3,,<empty>
71088,BLOCK,-1,,<empty>,,,,4,,<empty>
71097,BLOCK,-1,,<empty>,,,,6,,<empty>
71102,BLOCK,-1,,<empty>,,,,2,,<empty>
71109,BLOCK,-1,,<empty>,,,,4,,<empty>
71114,BLOCK,-1,,<empty>,,,,2,,<empty>
71119,BLOCK,-1,,<empty>,,,,2,,<empty>
71140,BLOCK,-1,,<empty>,1,,1,1,,ANY
71151,BLOCK,-1,,"{
    vlc_sd_probe_t names = { strdup(name), strdup(longname), category };

    if (unlikely (names.name == NULL || names.longname == NULL
               || vlc_probe_add (probe, &names, sizeof (names))))
    {
        free (names.name);
        free (names.longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",1,,43,5,,void
71181,BLOCK,-1,,"{
        free (names.name);
        free (names.longname);
        return VLC_ENOMEM;
    }",5,,48,2,,void
71200,BLOCK,-1,,"{
    size_t count;
    vlc_sd_probe_t *tab = vlc_probe (obj, ""services probe"", &count);

    if (count == 0)
    {
        free (tab);
        return NULL;
    }

    char **names = vlc_alloc (count + 1, sizeof(char *));
    char **longnames = vlc_alloc (count + 1, sizeof(char *));
    int *categories = vlc_alloc (count + 1, sizeof(int));

    if (unlikely (names == NULL || longnames == NULL || categories == NULL))
    {
        free(names);
        free(longnames);
        free(categories);
        free(tab);
        return NULL;
    }
    for( size_t i = 0; i < count; i++ )
    {
        names[i] = tab[i].name;
        longnames[i] = tab[i].longname;
        categories[i] = tab[i].category;
    }
    free (tab);
    names[count] = longnames[count] = NULL;
    categories[count] = 0;
    *pppsz_longnames = longnames;
    if( pp_categories ) *pp_categories = categories;
    else free( categories );
    return names;
}",1,,62,4,,void
71214,BLOCK,-1,,"{
        free (tab);
        return NULL;
    }",5,,67,2,,void
71259,BLOCK,-1,,"{
        free(names);
        free(longnames);
        free(categories);
        free(tab);
        return NULL;
    }",5,,77,2,,void
71271,BLOCK,-1,,<empty>,5,,84,1,,void
71281,BLOCK,4,,"{
        names[i] = tab[i].name;
        longnames[i] = tab[i].longname;
        categories[i] = tab[i].category;
    }",5,,85,4,,void
71331,BLOCK,-1,,<empty>,25,,94,2,,void
71337,BLOCK,-1,,<empty>,10,,95,1,,void
71348,BLOCK,-1,,"{
    services_discovery_t *sd = vlc_custom_create(parent, sizeof (*sd),
                                                 ""services discovery"");
    if (unlikely(sd == NULL))
        return NULL;

    free(config_ChainCreate(&sd->psz_name, &sd->p_cfg, cfg));
    sd->description = NULL;
    sd->owner = *owner;

    sd->p_module = module_need(sd, ""services_discovery"",
                               sd->psz_name, true);
    if (sd->p_module == NULL)
    {
        msg_Err(sd, ""no suitable services discovery module"");
        vlc_sd_Destroy(sd);
        sd = NULL;
    }

    return sd;
}",1,,108,4,,void
71354,BLOCK,1,,<empty>,,,,3,,void
71367,BLOCK,-1,,<empty>,9,,112,2,,void
71409,BLOCK,-1,,"{
        msg_Err(sd, ""no suitable services discovery module"");
        vlc_sd_Destroy(sd);
        sd = NULL;
    }",5,,121,2,,void
71424,BLOCK,-1,,"{
    if (sd->p_module != NULL)
        module_unneed(sd, sd->p_module);
    config_ChainDestroy(sd->p_cfg);
    free(sd->psz_name);
    vlc_object_release(sd);
}",1,,131,2,,void
71431,BLOCK,-1,,<empty>,9,,133,2,,void
71459,BLOCK,-1,,<empty>,1,,1,1,,ANY
71462,BLOCK,-1,,"{
    counter_t *p_counter = (counter_t*) malloc( sizeof( counter_t ) ) ;

    if( !p_counter ) return NULL;
    p_counter->i_compute_type = i_compute_type;
    p_counter->i_samples = 0;
    p_counter->pp_samples = NULL;

    p_counter->last_update = 0;

    return p_counter;
}",1,,39,2,,void
71474,BLOCK,-1,,<empty>,22,,42,2,,void
71503,BLOCK,-1,,"{
    if (counter == NULL || counter->i_samples == 0)
        return 0;
    return counter->pp_samples[0]->value;
}",1,,53,2,,void
71514,BLOCK,-1,,<empty>,9,,55,2,,void
71529,BLOCK,-1,,"{
    if (counter == NULL || counter->i_samples < 2)
        return 0.;

    return (counter->pp_samples[0]->value - counter->pp_samples[1]->value)
        / (float)(counter->pp_samples[0]->date - counter->pp_samples[1]->date);
}",1,,60,2,,void
71540,BLOCK,-1,,<empty>,9,,62,2,,void
71581,BLOCK,-1,,"{
    (void)p_input;
    input_stats_t *p_stats = calloc( 1, sizeof(input_stats_t) );
    if( !p_stats )
        return NULL;

    vlc_mutex_init( &p_stats->lock );
    stats_ReinitInputStats( p_stats );

    return p_stats;
}",1,,69,2,,void
71595,BLOCK,-1,,<empty>,9,,73,2,,void
71612,BLOCK,-1,,"{
    input_thread_private_t *priv = input_priv(input);

    if (!libvlc_stats(input))
        return;

    vlc_mutex_lock(&priv->counters.counters_lock);
    vlc_mutex_lock(&st->lock);

    /* Input */
    st->i_read_packets = stats_GetTotal(priv->counters.p_read_packets);
    st->i_read_bytes = stats_GetTotal(priv->counters.p_read_bytes);
    st->f_input_bitrate = stats_GetRate(priv->counters.p_input_bitrate);
    st->i_demux_read_bytes = stats_GetTotal(priv->counters.p_demux_read);
    st->f_demux_bitrate = stats_GetRate(priv->counters.p_demux_bitrate);
    st->i_demux_corrupted = stats_GetTotal(priv->counters.p_demux_corrupted);
    st->i_demux_discontinuity = stats_GetTotal(priv->counters.p_demux_discontinuity);

    /* Decoders */
    st->i_decoded_video = stats_GetTotal(priv->counters.p_decoded_video);
    st->i_decoded_audio = stats_GetTotal(priv->counters.p_decoded_audio);

    /* Sout */
    if (priv->counters.p_sout_send_bitrate)
    {
        st->i_sent_packets = stats_G...",1,,82,3,,void
71622,BLOCK,-1,,<empty>,9,,86,2,,void
71732,BLOCK,-1,,"{
        st->i_sent_packets = stats_GetTotal(priv->counters.p_sout_sent_packets);
        st->i_sent_bytes = stats_GetTotal(priv->counters.p_sout_sent_bytes);
        st->f_send_bitrate = stats_GetRate(priv->counters.p_sout_send_bitrate);
    }",5,,106,2,,void
71819,BLOCK,-1,,"{
    vlc_mutex_lock( &p_stats->lock );
    p_stats->i_read_packets = p_stats->i_read_bytes =
    p_stats->f_input_bitrate = p_stats->f_average_input_bitrate =
    p_stats->i_demux_read_packets = p_stats->i_demux_read_bytes =
    p_stats->f_demux_bitrate = p_stats->f_average_demux_bitrate =
    p_stats->i_demux_corrupted = p_stats->i_demux_discontinuity =
    p_stats->i_displayed_pictures = p_stats->i_lost_pictures =
    p_stats->i_played_abuffers = p_stats->i_lost_abuffers =
    p_stats->i_decoded_video = p_stats->i_decoded_audio =
    p_stats->i_sent_bytes = p_stats->i_sent_packets = p_stats->f_send_bitrate
     = 0;
    vlc_mutex_unlock( &p_stats->lock );
}",1,,125,2,,void
71911,BLOCK,-1,,"{
    if( p_c )
    {
        for( int i = 0; i < p_c->i_samples; i++ )
            free( p_c->pp_samples[i] );
        TAB_CLEAN(p_c->i_samples, p_c->pp_samples);
        free( p_c );
    }
}",1,,141,2,,void
71914,BLOCK,-1,,"{
        for( int i = 0; i < p_c->i_samples; i++ )
            free( p_c->pp_samples[i] );
        TAB_CLEAN(p_c->i_samples, p_c->pp_samples);
        free( p_c );
    }",5,,143,2,,void
71916,BLOCK,-1,,<empty>,9,,144,1,,void
71949,BLOCK,-1,,"{
    if( !p_counter )
        return;

    switch( p_counter->i_compute_type )
    {
    case STATS_DERIVATIVE:
    {
        counter_sample_t *p_new, *p_old;
        mtime_t now = mdate();
        if( now - p_counter->last_update < CLOCK_FREQ )
            return;
        p_counter->last_update = now;
        /* Insert the new one at the beginning */
        p_new = (counter_sample_t*)malloc( sizeof( counter_sample_t ) );
        if (unlikely(p_new == NULL))
            return; /* NOTE: Losing sample here */

        p_new->value = val;
        p_new->date = p_counter->last_update;
        TAB_INSERT(p_counter->i_samples, p_counter->pp_samples, p_new, 0);

        if( p_counter->i_samples == 3 )
        {
            p_old = p_counter->pp_samples[2];
            TAB_ERASE(p_counter->i_samples, p_counter->pp_samples, 2);
            free( p_old );
        }
        break;
    }
    case STATS_COUNTER:
        if( p_counter->i_samples == 0 )
        {
            counter_sample_t *p...",1,,159,4,,void
71953,BLOCK,-1,,<empty>,9,,161,2,,void
71959,BLOCK,-1,,"{
    case STATS_DERIVATIVE:
    {
        counter_sample_t *p_new, *p_old;
        mtime_t now = mdate();
        if( now - p_counter->last_update < CLOCK_FREQ )
            return;
        p_counter->last_update = now;
        /* Insert the new one at the beginning */
        p_new = (counter_sample_t*)malloc( sizeof( counter_sample_t ) );
        if (unlikely(p_new == NULL))
            return; /* NOTE: Losing sample here */

        p_new->value = val;
        p_new->date = p_counter->last_update;
        TAB_INSERT(p_counter->i_samples, p_counter->pp_samples, p_new, 0);

        if( p_counter->i_samples == 3 )
        {
            p_old = p_counter->pp_samples[2];
            TAB_ERASE(p_counter->i_samples, p_counter->pp_samples, 2);
            free( p_old );
        }
        break;
    }
    case STATS_COUNTER:
        if( p_counter->i_samples == 0 )
        {
            counter_sample_t *p_new = (counter_sample_t*)malloc(
                                               siz...",5,,164,2,,void
71962,BLOCK,3,,"{
        counter_sample_t *p_new, *p_old;
        mtime_t now = mdate();
        if( now - p_counter->last_update < CLOCK_FREQ )
            return;
        p_counter->last_update = now;
        /* Insert the new one at the beginning */
        p_new = (counter_sample_t*)malloc( sizeof( counter_sample_t ) );
        if (unlikely(p_new == NULL))
            return; /* NOTE: Losing sample here */

        p_new->value = val;
        p_new->date = p_counter->last_update;
        TAB_INSERT(p_counter->i_samples, p_counter->pp_samples, p_new, 0);

        if( p_counter->i_samples == 3 )
        {
            p_old = p_counter->pp_samples[2];
            TAB_ERASE(p_counter->i_samples, p_counter->pp_samples, 2);
            free( p_old );
        }
        break;
    }",5,,166,3,,void
71977,BLOCK,-1,,<empty>,13,,170,2,,void
71996,BLOCK,-1,,<empty>,13,,175,2,,void
72025,BLOCK,-1,,"{
            p_old = p_counter->pp_samples[2];
            TAB_ERASE(p_counter->i_samples, p_counter->pp_samples, 2);
            free( p_old );
        }",9,,182,2,,void
72052,BLOCK,-1,,"{
            counter_sample_t *p_new = (counter_sample_t*)malloc(
                                               sizeof( counter_sample_t ) );
            if (unlikely(p_new == NULL))
                return; /* NOTE: Losing sample here */

            p_new->value = 0;

            TAB_APPEND(p_counter->i_samples, p_counter->pp_samples, p_new);
        }",9,,191,2,,void
72066,BLOCK,-1,,<empty>,17,,195,2,,void
72087,BLOCK,-1,,"{
            p_counter->pp_samples[0]->value += val;
            if( new_val )
                *new_val = p_counter->pp_samples[0]->value;
        }",9,,202,2,,void
72099,BLOCK,-1,,<empty>,17,,205,2,,void
72149,BLOCK,-1,,<empty>,1,,1,1,,ANY
72154,BLOCK,-1,,<empty>,,,,2,,<empty>
72170,BLOCK,-1,,"{
    stream_priv_t *priv = vlc_custom_create(parent, sizeof (*priv), ""stream"");
    if (unlikely(priv == NULL))
        return NULL;

    stream_t *s = &priv->stream;

    s->p_module = NULL;
    s->psz_url = NULL;
    s->p_source = NULL;
    s->pf_read = NULL;
    s->pf_block = NULL;
    s->pf_readdir = NULL;
    s->pf_seek = NULL;
    s->pf_control = NULL;
    s->p_sys = NULL;
    s->p_input = NULL;
    assert(destroy != NULL);
    priv->destroy = destroy;
    priv->block = NULL;
    priv->peek = NULL;
    priv->offset = 0;
    priv->eof = false;

    /* UTF16 and UTF32 text file conversion */
    priv->text.conv = (vlc_iconv_t)(-1);
    priv->text.char_width = 1;
    priv->text.little_endian = false;

    return s;
}",1,,69,3,,void
72185,BLOCK,-1,,<empty>,9,,72,2,,void
72303,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;

    if (priv->text.conv != (vlc_iconv_t)(-1))
        vlc_iconv_close(priv->text.conv);

    if (priv->peek != NULL)
        block_Release(priv->peek);
    if (priv->block != NULL)
        block_Release(priv->block);

    free(s->psz_url);
    vlc_object_release(s);
}",1,,102,2,,void
72320,BLOCK,-1,,<empty>,9,,106,2,,void
72333,BLOCK,-1,,<empty>,9,,109,2,,void
72344,BLOCK,-1,,<empty>,9,,111,2,,void
72359,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->destroy(s);
    stream_CommonDelete(s);
}",1,,121,2,,void
72378,BLOCK,-1,,"{
    if( !psz_url )
        return NULL;

    stream_t *s = stream_AccessNew( p_parent, NULL, false, psz_url );
    if( s == NULL )
        msg_Err( p_parent, ""no suitable access module for `%s'"", psz_url );
    return s;
}",1,,129,3,,void
72382,BLOCK,-1,,<empty>,9,,131,2,,void
72397,BLOCK,-1,,<empty>,9,,135,2,,void
72409,BLOCK,-1,,"{
    stream_t* stream = vlc_stream_NewURL( parent, mrl );

    if( stream == NULL )
        return NULL;

    char const* anchor = strchr( mrl, '#' );

    if( anchor == NULL )
        return stream;

    char const* extra;
    if( stream_extractor_AttachParsed( &stream, anchor + 1, &extra ) )
    {
        msg_Err( parent, ""unable to open %s"", mrl );
        vlc_stream_Delete( stream );
        return NULL;
    }

    if( extra && *extra )
        msg_Warn( parent, ""ignoring extra fragment data: %s"", extra );

    return stream;
}",1,,140,3,,void
72420,BLOCK,-1,,<empty>,9,,144,2,,void
72433,BLOCK,-1,,<empty>,9,,149,2,,void
72446,BLOCK,-1,,"{
        msg_Err( parent, ""unable to open %s"", mrl );
        vlc_stream_Delete( stream );
        return NULL;
    }",5,,153,2,,void
72460,BLOCK,-1,,<empty>,9,,160,2,,void
72471,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;
    char *p_line = NULL;
    int i_line = 0, i_read = 0;

    /* Let's fail quickly if this is a readdir access */
    if( s->pf_read == NULL && s->pf_block == NULL )
        return NULL;

    for( ;; )
    {
        char *psz_eol;
        const uint8_t *p_data;
        int i_data;
        int64_t i_pos;

        /* Probe new data */
        i_data = vlc_stream_Peek( s, &p_data, STREAM_PROBE_LINE );
        if( i_data <= 0 ) break; /* No more data */

        /* BOM detection */
        i_pos = vlc_stream_Tell( s );
        if( i_pos == 0 && i_data >= 2 )
        {
            const char *psz_encoding = NULL;
            bool little_endian = false;

            if( unlikely(priv->text.conv != (vlc_iconv_t)-1) )
            {   /* seek back to beginning? reset */
                vlc_iconv_close( priv->text.conv );
                priv->text.conv = (vlc_iconv_t)-1;
            }
            priv->text.char_width = 1;
            priv->te...",1,,173,2,,void
72502,BLOCK,-1,,<empty>,9,,180,2,,void
72506,BLOCK,-1,,<empty>,5,,182,1,,void
72507,BLOCK,4,,"{
        char *psz_eol;
        const uint8_t *p_data;
        int i_data;
        int64_t i_pos;

        /* Probe new data */
        i_data = vlc_stream_Peek( s, &p_data, STREAM_PROBE_LINE );
        if( i_data <= 0 ) break; /* No more data */

        /* BOM detection */
        i_pos = vlc_stream_Tell( s );
        if( i_pos == 0 && i_data >= 2 )
        {
            const char *psz_encoding = NULL;
            bool little_endian = false;

            if( unlikely(priv->text.conv != (vlc_iconv_t)-1) )
            {   /* seek back to beginning? reset */
                vlc_iconv_close( priv->text.conv );
                priv->text.conv = (vlc_iconv_t)-1;
            }
            priv->text.char_width = 1;
            priv->text.little_endian = false;

            if( !memcmp( p_data, ""\xFF\xFE"", 2 ) )
            {
                psz_encoding = ""UTF-16LE"";
                little_endian = true;
            }
            else if( !memcmp( p_data, ""\xFE\xFF"", 2 ) )
            ...",5,,183,4,,void
72519,BLOCK,1,,<empty>,,,,1,,void
72525,BLOCK,-1,,<empty>,27,,191,2,,void
72539,BLOCK,-1,,"{
            const char *psz_encoding = NULL;
            bool little_endian = false;

            if( unlikely(priv->text.conv != (vlc_iconv_t)-1) )
            {   /* seek back to beginning? reset */
                vlc_iconv_close( priv->text.conv );
                priv->text.conv = (vlc_iconv_t)-1;
            }
            priv->text.char_width = 1;
            priv->text.little_endian = false;

            if( !memcmp( p_data, ""\xFF\xFE"", 2 ) )
            {
                psz_encoding = ""UTF-16LE"";
                little_endian = true;
            }
            else if( !memcmp( p_data, ""\xFE\xFF"", 2 ) )
            {
                psz_encoding = ""UTF-16BE"";
            }

            /* Open the converter if we need it */
            if( psz_encoding != NULL )
            {
                msg_Dbg( s, ""UTF-16 BOM detected"" );
                priv->text.conv = vlc_iconv_open( ""UTF-8"", psz_encoding );
                if( unlikely(priv->text.conv == (vlc_iconv_t)-1) )
    ...",9,,196,2,,void
72559,BLOCK,-1,,"{   /* seek back to beginning? reset */
                vlc_iconv_close( priv->text.conv );
                priv->text.conv = (vlc_iconv_t)-1;
            }",13,,201,2,,void
72595,BLOCK,-1,,"{
                psz_encoding = ""UTF-16LE"";
                little_endian = true;
            }",13,,209,2,,void
72603,BLOCK,-1,,<empty>,18,,213,1,,void
72610,BLOCK,-1,,"{
                psz_encoding = ""UTF-16BE"";
            }",13,,214,2,,void
72618,BLOCK,-1,,"{
                msg_Dbg( s, ""UTF-16 BOM detected"" );
                priv->text.conv = vlc_iconv_open( ""UTF-8"", psz_encoding );
                if( unlikely(priv->text.conv == (vlc_iconv_t)-1) )
                {
                    msg_Err( s, ""iconv_open failed"" );
                    goto error;
                }
                priv->text.char_width = 2;
                priv->text.little_endian = little_endian;
            }",13,,220,2,,void
72642,BLOCK,-1,,"{
                    msg_Err( s, ""iconv_open failed"" );
                    goto error;
                }",17,,224,2,,void
72669,BLOCK,-1,,"{
            /* keep i_char_width boundary */
            i_data = i_data - ( i_data % priv->text.char_width );
            msg_Warn( s, ""the read is not i_char_width compatible"");
        }",9,,234,2,,void
72688,BLOCK,-1,,<empty>,13,,241,2,,void
72698,BLOCK,-1,,"{
            /* UTF-8: 0A <LF> */
            psz_eol = memchr( p_data, '\n', i_data );
            if( psz_eol == NULL )
                /* UTF-8: 0D <CR> */
                psz_eol = memchr( p_data, '\r', i_data );
        }",9,,245,2,,void
72709,BLOCK,-1,,<empty>,17,,250,2,,void
72717,BLOCK,-1,,"{
            const uint8_t *p_last = p_data + i_data - priv->text.char_width;
            uint16_t eol = priv->text.little_endian ? 0x0A00 : 0x000A;

            assert( priv->text.char_width == 2 );
            psz_eol = NULL;
            /* UTF-16: 000A <LF> */
            for( const uint8_t *p = p_data; p <= p_last; p += 2 )
            {
                if( U16_AT( p ) == eol )
                {
                     psz_eol = (char *)p + 1;
                     break;
                }
            }

            if( psz_eol == NULL )
            {   /* UTF-16: 000D <CR> */
                eol = priv->text.little_endian ? 0x0D00 : 0x000D;
                for( const uint8_t *p = p_data; p <= p_last; p += 2 )
                {
                    if( U16_AT( p ) == eol )
                    {
                        psz_eol = (char *)p + 1;
                        break;
                    }
                }
            }
        }",9,,253,1,,void
72753,BLOCK,-1,,<empty>,13,,260,1,,void
72764,BLOCK,4,,"{
                if( U16_AT( p ) == eol )
                {
                     psz_eol = (char *)p + 1;
                     break;
                }
            }",13,,261,4,,void
72770,BLOCK,-1,,"{
                     psz_eol = (char *)p + 1;
                     break;
                }",17,,263,2,,void
72783,BLOCK,-1,,"{   /* UTF-16: 000D <CR> */
                eol = priv->text.little_endian ? 0x0D00 : 0x000D;
                for( const uint8_t *p = p_data; p <= p_last; p += 2 )
                {
                    if( U16_AT( p ) == eol )
                    {
                        psz_eol = (char *)p + 1;
                        break;
                    }
                }
            }",13,,270,2,,void
72795,BLOCK,-1,,<empty>,17,,272,1,,void
72806,BLOCK,4,,"{
                    if( U16_AT( p ) == eol )
                    {
                        psz_eol = (char *)p + 1;
                        break;
                    }
                }",17,,273,4,,void
72812,BLOCK,-1,,"{
                        psz_eol = (char *)p + 1;
                        break;
                    }",21,,275,2,,void
72823,BLOCK,-1,,"{
            i_data = (psz_eol - (char *)p_data) + 1;
            p_line = realloc_or_free( p_line,
                        i_line + i_data + priv->text.char_width ); /* add \0 */
            if( !p_line )
                goto error;
            i_data = vlc_stream_Read( s, &p_line[i_line], i_data );
            if( i_data <= 0 ) break; /* Hmmm */
            i_line += i_data - priv->text.char_width; /* skip \n */;
            i_read += i_data;

            /* We have our line */
            break;
        }",9,,284,2,,void
72849,BLOCK,-1,,<empty>,17,,289,2,,void
72864,BLOCK,-1,,<empty>,31,,291,2,,void
72887,BLOCK,1,,<empty>,,,,1,,void
72897,BLOCK,-1,,<empty>,13,,303,2,,void
72908,BLOCK,1,,<empty>,,,,1,,void
72914,BLOCK,-1,,<empty>,27,,305,2,,void
72926,BLOCK,1,,<empty>,,,,1,,void
72930,BLOCK,-1,,<empty>,13,,310,2,,void
72936,BLOCK,-1,,"{
        if( priv->text.char_width > 1 )
        {
            int i_new_line = 0;
            size_t i_in = 0, i_out = 0;
            const char * p_in = NULL;
            char * p_out = NULL;
            char * psz_new_line = NULL;

            /* iconv */
            /* UTF-8 needs at most 150% of the buffer as many as UTF-16 */
            i_new_line = i_line * 3 / 2 + 1;
            psz_new_line = malloc( i_new_line );
            if( psz_new_line == NULL )
                goto error;
            i_in = (size_t)i_line;
            i_out = (size_t)i_new_line;
            p_in = p_line;
            p_out = psz_new_line;

            if( vlc_iconv( priv->text.conv, &p_in, &i_in, &p_out, &i_out ) == (size_t)-1 )
            {
                msg_Err( s, ""conversion error: %s"", vlc_strerror_c( errno ) );
                msg_Dbg( s, ""original: %d, in %zu, out %zu"", i_line, i_in, i_out );
            }
            free( p_line );
            p_line = psz_new_line;
            i_line ...",5,,314,2,,void
72945,BLOCK,-1,,"{
            int i_new_line = 0;
            size_t i_in = 0, i_out = 0;
            const char * p_in = NULL;
            char * p_out = NULL;
            char * psz_new_line = NULL;

            /* iconv */
            /* UTF-8 needs at most 150% of the buffer as many as UTF-16 */
            i_new_line = i_line * 3 / 2 + 1;
            psz_new_line = malloc( i_new_line );
            if( psz_new_line == NULL )
                goto error;
            i_in = (size_t)i_line;
            i_out = (size_t)i_new_line;
            p_in = p_line;
            p_out = psz_new_line;

            if( vlc_iconv( priv->text.conv, &p_in, &i_in, &p_out, &i_out ) == (size_t)-1 )
            {
                msg_Err( s, ""conversion error: %s"", vlc_strerror_c( errno ) );
                msg_Dbg( s, ""original: %d, in %zu, out %zu"", i_line, i_in, i_out );
            }
            free( p_line );
            p_line = psz_new_line;
            i_line = (size_t)i_new_line - i_out; /* does not include ...",9,,316,2,,void
72987,BLOCK,-1,,<empty>,17,,328,2,,void
73024,BLOCK,-1,,"{
                msg_Err( s, ""conversion error: %s"", vlc_strerror_c( errno ) );
                msg_Dbg( s, ""original: %d, in %zu, out %zu"", i_line, i_in, i_out );
            }",13,,335,2,,void
73088,BLOCK,-1,,"{
    block_t *block = *pp;

    if (block == NULL)
        return -1;

    if (len > block->i_buffer)
        len = block->i_buffer;

    if (buf != NULL)
        memcpy(buf, block->p_buffer, len);

    block->p_buffer += len;
    block->i_buffer -= len;

    if (block->i_buffer == 0)
    {
        block_Release(block);
        *pp = NULL;
    }

    return likely(len > 0) ? (ssize_t)len : -1;
}",1,,363,4,,void
73098,BLOCK,-1,,<empty>,9,,367,2,,void
73108,BLOCK,-1,,<empty>,9,,370,2,,void
73118,BLOCK,-1,,<empty>,9,,373,2,,void
73141,BLOCK,-1,,"{
        block_Release(block);
        *pp = NULL;
    }",5,,379,2,,void
73165,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    assert(len <= SSIZE_MAX);

    if (vlc_killed())
        return 0;

    if (s->pf_read != NULL)
    {
        assert(priv->block == NULL);
        if (buf == NULL)
        {
            if (unlikely(len == 0))
                return 0;

            char dummy[(len <= 256 ? len : 256)];
            ret = s->pf_read(s, dummy, sizeof (dummy));
        }
        else
            ret = s->pf_read(s, buf, len);
        return ret;
    }

    ret = vlc_stream_CopyBlock(&priv->block, buf, len);
    if (ret >= 0)
        return ret;

    if (s->pf_block != NULL)
    {
        bool eof = false;

        priv->block = s->pf_block(s, &eof);
        ret = vlc_stream_CopyBlock(&priv->block, buf, len);
        if (ret >= 0)
            return ret;
        return eof ? 0 : -1;
    }

    return 0;
}",1,,388,4,,void
73179,BLOCK,-1,,<empty>,9,,395,2,,void
73188,BLOCK,-1,,"{
        assert(priv->block == NULL);
        if (buf == NULL)
        {
            if (unlikely(len == 0))
                return 0;

            char dummy[(len <= 256 ? len : 256)];
            ret = s->pf_read(s, dummy, sizeof (dummy));
        }
        else
            ret = s->pf_read(s, buf, len);
        return ret;
    }",5,,398,2,,void
73199,BLOCK,-1,,"{
            if (unlikely(len == 0))
                return 0;

            char dummy[(len <= 256 ? len : 256)];
            ret = s->pf_read(s, dummy, sizeof (dummy));
        }",9,,401,2,,void
73205,BLOCK,-1,,<empty>,17,,403,2,,void
73220,BLOCK,-1,,<empty>,13,,409,1,,void
73245,BLOCK,-1,,<empty>,9,,415,2,,void
73254,BLOCK,-1,,"{
        bool eof = false;

        priv->block = s->pf_block(s, &eof);
        ret = vlc_stream_CopyBlock(&priv->block, buf, len);
        if (ret >= 0)
            return ret;
        return eof ? 0 : -1;
    }",5,,418,2,,void
73283,BLOCK,-1,,<empty>,13,,424,2,,void
73300,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    ret = vlc_stream_CopyBlock(&priv->peek, buf, len);
    if (ret >= 0)
    {
        priv->offset += ret;
        assert(ret <= (ssize_t)len);
        return ret;
    }

    ret = vlc_stream_ReadRaw(s, buf, len);
    if (ret > 0)
        priv->offset += ret;
    if (ret == 0)
        priv->eof = len != 0;
    assert(ret <= (ssize_t)len);
    return ret;
}",1,,432,4,,void
73321,BLOCK,-1,,"{
        priv->offset += ret;
        assert(ret <= (ssize_t)len);
        return ret;
    }",5,,438,2,,void
73345,BLOCK,-1,,<empty>,9,,446,2,,void
73355,BLOCK,-1,,<empty>,9,,448,2,,void
73377,BLOCK,-1,,"{
    size_t copied = 0;

    while (len > 0)
    {
        ssize_t ret = vlc_stream_ReadPartial(s, buf, len);
        if (ret < 0)
            continue;
        if (ret == 0)
            break;

        if (buf != NULL)
            buf = (char *)buf + ret;
        assert(len >= (size_t)ret);
        len -= ret;
        copied += ret;
    }

    return copied;
}",1,,454,4,,void
73386,BLOCK,-1,,"{
        ssize_t ret = vlc_stream_ReadPartial(s, buf, len);
        if (ret < 0)
            continue;
        if (ret == 0)
            break;

        if (buf != NULL)
            buf = (char *)buf + ret;
        assert(len >= (size_t)ret);
        len -= ret;
        copied += ret;
    }",5,,458,2,,void
73398,BLOCK,-1,,<empty>,13,,461,2,,void
73404,BLOCK,-1,,<empty>,13,,463,2,,void
73410,BLOCK,-1,,<empty>,13,,466,2,,void
73438,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *peek;

    peek = priv->peek;
    if (peek == NULL)
    {
        peek = priv->block;
        priv->peek = peek;
        priv->block = NULL;
    }

    if (peek == NULL)
    {
        peek = block_Alloc(len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = 0;
    }
    else
    if (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;

        peek = block_TryRealloc(peek, 0, len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = avail;
    }

    priv->peek = peek;
    *bufp = peek->p_buffer;

    while (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;
        ssize_t ret;

        ret = vlc_stream_ReadRaw(s, peek->p_buffer + avail, len - avail);
        if (ret < 0)
            continue;

        peek->i_buffer += ret;

        if (ret == 0)
            return peek->i_buffer;
    }

    return len;
}",1,,476,4,,void
73455,BLOCK,-1,,"{
        peek = priv->block;
        priv->peek = peek;
        priv->block = NULL;
    }",5,,482,2,,void
73475,BLOCK,-1,,"{
        peek = block_Alloc(len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = 0;
    }",5,,489,2,,void
73485,BLOCK,-1,,<empty>,13,,492,2,,void
73494,BLOCK,-1,,<empty>,5,,497,1,,void
73501,BLOCK,-1,,"{
        size_t avail = peek->i_buffer;

        peek = block_TryRealloc(peek, 0, len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = avail;
    }",5,,498,2,,void
73519,BLOCK,-1,,<empty>,13,,503,2,,void
73544,BLOCK,-1,,"{
        size_t avail = peek->i_buffer;
        ssize_t ret;

        ret = vlc_stream_ReadRaw(s, peek->p_buffer + avail, len - avail);
        if (ret < 0)
            continue;

        peek->i_buffer += ret;

        if (ret == 0)
            return peek->i_buffer;
    }",5,,512,2,,void
73568,BLOCK,-1,,<empty>,13,,518,2,,void
73579,BLOCK,-1,,<empty>,13,,523,2,,void
73590,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *block;

    if (vlc_killed())
    {
        priv->eof = true;
        return NULL;
    }

    if (priv->peek != NULL)
    {
        block = priv->peek;
        priv->peek = NULL;
    }
    else if (priv->block != NULL)
    {
        block = priv->block;
        priv->block = NULL;
    }
    else if (s->pf_block != NULL)
    {
        priv->eof = false;
        block = s->pf_block(s, &priv->eof);
    }
    else
    {
        block = block_Alloc(4096);
        if (unlikely(block == NULL))
            return NULL;

        ssize_t ret = s->pf_read(s, block->p_buffer, block->i_buffer);
        if (ret > 0)
            block->i_buffer = ret;
        else
        {
            block_Release(block);
            block = NULL;
        }

        priv->eof = !ret;
    }

    if (block != NULL)
        priv->offset += block->i_buffer;

    return block;
}",1,,530,2,,void
73600,BLOCK,-1,,"{
        priv->eof = true;
        return NULL;
    }",5,,535,2,,void
73614,BLOCK,-1,,"{
        block = priv->peek;
        priv->peek = NULL;
    }",5,,541,2,,void
73626,BLOCK,-1,,<empty>,10,,545,1,,void
73633,BLOCK,-1,,"{
        block = priv->block;
        priv->block = NULL;
    }",5,,546,2,,void
73645,BLOCK,-1,,<empty>,10,,550,1,,void
73652,BLOCK,-1,,"{
        priv->eof = false;
        block = s->pf_block(s, &priv->eof);
    }",5,,551,2,,void
73670,BLOCK,-1,,"{
        block = block_Alloc(4096);
        if (unlikely(block == NULL))
            return NULL;

        ssize_t ret = s->pf_read(s, block->p_buffer, block->i_buffer);
        if (ret > 0)
            block->i_buffer = ret;
        else
        {
            block_Release(block);
            block = NULL;
        }

        priv->eof = !ret;
    }",5,,556,1,,void
73680,BLOCK,-1,,<empty>,13,,559,2,,void
73701,BLOCK,-1,,<empty>,13,,563,2,,void
73708,BLOCK,-1,,"{
            block_Release(block);
            block = NULL;
        }",9,,565,1,,void
73724,BLOCK,-1,,<empty>,9,,574,2,,void
73738,BLOCK,-1,,"{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->offset;
}",1,,580,2,,void
73753,BLOCK,-1,,"{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->eof;
}",1,,587,2,,void
73769,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->eof = false;

    block_t *peek = priv->peek;
    if (peek != NULL)
    {
        if (offset >= priv->offset
         && offset <= (priv->offset + peek->i_buffer))
        {   /* Seeking within the peek buffer */
            size_t fwd = offset - priv->offset;

            peek->p_buffer += fwd;
            peek->i_buffer -= fwd;
            priv->offset = offset;

            if (peek->i_buffer == 0)
            {
                priv->peek = NULL;
                block_Release(peek);
            }

            return VLC_SUCCESS;
        }
    }
    else
    {
        if (priv->offset == offset)
            return VLC_SUCCESS; /* Nothing to do! */
    }

    if (s->pf_seek == NULL)
        return VLC_EGENERIC;

    int ret = s->pf_seek(s, offset);
    if (ret != VLC_SUCCESS)
        return ret;

    priv->offset = offset;

    if (peek != NULL)
    {
        priv->peek = NULL;
        block_Release(peek);
    }

    if (pr...",1,,594,3,,void
73791,BLOCK,-1,,"{
        if (offset >= priv->offset
         && offset <= (priv->offset + peek->i_buffer))
        {   /* Seeking within the peek buffer */
            size_t fwd = offset - priv->offset;

            peek->p_buffer += fwd;
            peek->i_buffer -= fwd;
            priv->offset = offset;

            if (peek->i_buffer == 0)
            {
                priv->peek = NULL;
                block_Release(peek);
            }

            return VLC_SUCCESS;
        }
    }",5,,601,2,,void
73808,BLOCK,-1,,"{   /* Seeking within the peek buffer */
            size_t fwd = offset - priv->offset;

            peek->p_buffer += fwd;
            peek->i_buffer -= fwd;
            priv->offset = offset;

            if (peek->i_buffer == 0)
            {
                priv->peek = NULL;
                block_Release(peek);
            }

            return VLC_SUCCESS;
        }",9,,604,2,,void
73838,BLOCK,-1,,"{
                priv->peek = NULL;
                block_Release(peek);
            }",13,,612,2,,void
73849,BLOCK,-1,,"{
        if (priv->offset == offset)
            return VLC_SUCCESS; /* Nothing to do! */
    }",5,,621,1,,void
73856,BLOCK,-1,,<empty>,13,,623,2,,void
73865,BLOCK,-1,,<empty>,9,,627,2,,void
73881,BLOCK,-1,,<empty>,9,,631,2,,void
73893,BLOCK,-1,,"{
        priv->peek = NULL;
        block_Release(peek);
    }",5,,636,2,,void
73907,BLOCK,-1,,"{
        block_Release(priv->block);
        priv->block = NULL;
    }",5,,642,2,,void
73925,BLOCK,-1,,"{
    stream_priv_t *priv = (stream_priv_t *)s;

    switch (cmd)
    {
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
        {
            int ret = s->pf_control(s, cmd, args);
            if (ret != VLC_SUCCESS)
                return ret;

            priv->offset = 0;

            if (priv->peek != NULL)
            {
                block_Release(priv->peek);
                priv->peek = NULL;
            }

            if (priv->block != NULL)
            {
                block_Release(priv->block);
                priv->block = NULL;
            }

            return VLC_SUCCESS;
        }
    }
    return s->pf_control(s, cmd, args);
}",1,,656,4,,void
73934,BLOCK,-1,,"{
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
        {
            int ret = s->pf_control(s, cmd, args);
            if (ret != VLC_SUCCESS)
                return ret;

            priv->offset = 0;

            if (priv->peek != NULL)
            {
                block_Release(priv->peek);
                priv->peek = NULL;
            }

            if (priv->block != NULL)
            {
                block_Release(priv->block);
                priv->block = NULL;
            }

            return VLC_SUCCESS;
        }
    }",5,,660,2,,void
73939,BLOCK,5,,"{
            int ret = s->pf_control(s, cmd, args);
            if (ret != VLC_SUCCESS)
                return ret;

            priv->offset = 0;

            if (priv->peek != NULL)
            {
                block_Release(priv->peek);
                priv->peek = NULL;
            }

            if (priv->block != NULL)
            {
                block_Release(priv->block);
                priv->block = NULL;
            }

            return VLC_SUCCESS;
        }",9,,663,5,,void
73954,BLOCK,-1,,<empty>,17,,666,2,,void
73968,BLOCK,-1,,"{
                block_Release(priv->peek);
                priv->peek = NULL;
            }",13,,671,2,,void
73984,BLOCK,-1,,"{
                block_Release(priv->block);
                priv->block = NULL;
            }",13,,677,2,,void
74009,BLOCK,-1,,"{
    if( unlikely(size > SSIZE_MAX) )
        return NULL;

    block_t *block = block_Alloc( size );
    if( unlikely(block == NULL) )
        return NULL;

    ssize_t val = vlc_stream_Read( s, block->p_buffer, size );
    if( val <= 0 )
    {
        block_Release( block );
        return NULL;
    }

    block->i_buffer = val;
    return block;
}",1,,698,3,,void
74015,BLOCK,-1,,<empty>,9,,700,2,,void
74028,BLOCK,-1,,<empty>,9,,704,2,,void
74044,BLOCK,-1,,"{
        block_Release( block );
        return NULL;
    }",5,,708,2,,void
74061,BLOCK,-1,,"{
    return s->pf_readdir( s, p_node );
}",1,,722,3,,void
74079,BLOCK,-1,,<empty>,1,,1,1,,ANY
74082,BLOCK,-1,,<empty>,,,,2,,<empty>
74090,BLOCK,-1,,<empty>,,,,5,,<empty>
74095,BLOCK,-1,,<empty>,,,,2,,<empty>
74103,BLOCK,-1,,<empty>,,,,3,,<empty>
74112,BLOCK,-1,,<empty>,,,,4,,<empty>
74117,BLOCK,-1,,<empty>,,,,2,,<empty>
74146,BLOCK,-1,,<empty>,1,,1,1,,ANY
74154,BLOCK,-1,,<empty>,,,,3,,<empty>
74159,BLOCK,-1,,<empty>,,,,2,,<empty>
74169,BLOCK,-1,,"{
    struct vlc_memstream buffer;
    char* escaped;

    if( mrl_EscapeFragmentIdentifier( &escaped, subentry ) )
        return NULL;

    if( vlc_memstream_open( &buffer ) )
    {
        free( escaped );
        return NULL;
    }

    vlc_memstream_puts( &buffer, base );

    if( !strstr( base, ""#"" ) )
        vlc_memstream_putc( &buffer, '#' );

    vlc_memstream_printf( &buffer, ""!/%s"", escaped );

    free( escaped );
    return vlc_memstream_close( &buffer ) ? NULL : buffer.ptr;
}",1,,90,3,,void
74177,BLOCK,-1,,<empty>,9,,95,2,,void
74184,BLOCK,-1,,"{
        free( escaped );
        return NULL;
    }",5,,98,2,,void
74198,BLOCK,-1,,<empty>,9,,106,2,,void
74223,BLOCK,-1,,"{
    if( priv->pf_clean )
        priv->pf_clean( priv );

    if( priv->module )
    {
        module_unneed( priv->object, priv->module );

        if( priv->source )
            vlc_stream_Delete( priv->source );
    }

    vlc_object_release( priv->object );
}",1,,119,2,,void
74228,BLOCK,-1,,<empty>,9,,121,2,,void
74238,BLOCK,-1,,"{
        module_unneed( priv->object, priv->module );

        if( priv->source )
            vlc_stream_Delete( priv->source );
    }",5,,124,2,,void
74250,BLOCK,-1,,<empty>,13,,128,2,,void
74263,BLOCK,-1,,"{
    se_Release( stream->p_sys );
}",1,,142,2,,void
74274,BLOCK,-1,,"{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_read( &priv->extractor, buf, len );
}",1,,148,4,,void
74299,BLOCK,-1,,"{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_block( &priv->extractor, eof );
}",1,,155,3,,void
74323,BLOCK,-1,,"{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_seek( &priv->extractor, offset );
}",1,,162,3,,void
74347,BLOCK,-1,,"{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->directory.pf_readdir( &priv->directory, node );
}",1,,169,3,,void
74372,BLOCK,-1,,"{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_control( &priv->extractor, req, args );
}",1,,176,4,,void
74398,BLOCK,-1,,"{
    (void)stream;
    (void)args;

    if( req == STREAM_IS_DIRECTORY )
        return VLC_SUCCESS;

    return VLC_EGENERIC;
}",1,,183,4,,void
74409,BLOCK,-1,,<empty>,9,,188,2,,void
74419,BLOCK,-1,,"{
    if( priv->extractor.pf_read ) s->pf_read = se_StreamRead;
    else                          s->pf_block = se_StreamBlock;

    s->pf_seek = se_StreamSeek;
    s->pf_control = se_StreamControl;
    s->psz_url = StreamExtractorCreateMRL( priv->extractor.source->psz_url,
                                           priv->extractor.identifier );
    if( unlikely( !s->psz_url ) )
        return VLC_ENOMEM;

    return VLC_SUCCESS;
}",1,,205,3,,void
74426,BLOCK,-1,,<empty>,35,,206,2,,void
74433,BLOCK,-1,,<empty>,35,,207,1,,void
74472,BLOCK,-1,,<empty>,9,,214,2,,void
74481,BLOCK,-1,,"{
    free( (char*)priv->extractor.identifier );
}",1,,221,2,,void
74495,BLOCK,-1,,"{
    stream_directory_t* directory = &priv->directory;

    s->pf_readdir = se_ReadDir;
    s->pf_control = se_DirControl;
    s->psz_url = strdup( directory->source->psz_url );

    if( unlikely( !s->psz_url ) )
        return VLC_EGENERIC;

    return VLC_SUCCESS;
}",1,,227,3,,void
74529,BLOCK,-1,,<empty>,9,,235,2,,void
74539,BLOCK,-1,,"{
    stream_t* s = vlc_stream_CommonNew( source->obj.parent, se_StreamDelete );

    if( unlikely( !s ) )
        return VLC_ENOMEM;

    if( priv->pf_init( priv, s ) )
    {
        stream_CommonDelete( s );
        return VLC_EGENERIC;
    }

    priv->wrapper = s;
    priv->wrapper->p_input = source->p_input;
    priv->wrapper->p_sys = priv;

    priv->source = source;

    if( priv->wrapper->pf_read )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_read"" );
    else if( priv->wrapper->pf_block )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_block"" );

    return VLC_SUCCESS;
}",1,,257,3,,void
74554,BLOCK,-1,,<empty>,9,,261,2,,void
74564,BLOCK,-1,,"{
        stream_CommonDelete( s );
        return VLC_EGENERIC;
    }",5,,264,2,,void
74601,BLOCK,-1,,<empty>,9,,276,2,,void
74612,BLOCK,-1,,<empty>,10,,277,1,,void
74619,BLOCK,-1,,<empty>,9,,278,2,,void
74637,BLOCK,-1,,"{
    const bool extractor = identifier != NULL;
    char const* capability = extractor ? ""stream_extractor""
                                       : ""stream_directory"";

    struct stream_extractor_private* priv = vlc_custom_create(
        (*source)->obj.parent, sizeof( *priv ), capability );

    if( unlikely( !priv ) )
        return VLC_ENOMEM;

    if( extractor )
    {
        priv->object = VLC_OBJECT( &priv->extractor );

        priv->pf_init = se_InitStream;
        priv->pf_clean = se_CleanStream;

        priv->extractor.source = *source;
        priv->extractor.identifier = strdup( identifier );

        if( unlikely( !priv->extractor.identifier ) )
            goto error;
    }
    else
    {
        priv->object = VLC_OBJECT( &priv->directory );

        priv->pf_init = se_InitDirectory;
        priv->pf_clean = NULL;

        priv->directory.source = *source;
    }

    priv->module = module_need( priv->object, capability, module_name, true );

    if( !priv->module...",1,,286,4,,void
74669,BLOCK,-1,,<empty>,9,,295,2,,void
74674,BLOCK,-1,,"{
        priv->object = VLC_OBJECT( &priv->extractor );

        priv->pf_init = se_InitStream;
        priv->pf_clean = se_CleanStream;

        priv->extractor.source = *source;
        priv->extractor.identifier = strdup( identifier );

        if( unlikely( !priv->extractor.identifier ) )
            goto error;
    }",5,,298,2,,void
74718,BLOCK,-1,,<empty>,13,,308,2,,void
74721,BLOCK,-1,,"{
        priv->object = VLC_OBJECT( &priv->directory );

        priv->pf_init = se_InitDirectory;
        priv->pf_clean = NULL;

        priv->directory.source = *source;
    }",5,,311,1,,void
74770,BLOCK,-1,,<empty>,9,,323,2,,void
74790,BLOCK,-1,,"{
    return StreamExtractorAttach( source, NULL, module_name );
}",1,,335,3,,void
74802,BLOCK,-1,,"{
    return StreamExtractorAttach( source, identifier, module_name );
}",1,,342,4,,void
74814,BLOCK,-1,,"{
    vlc_array_t identifiers;

    if( mrl_FragmentSplit( &identifiers, out_extra, data ) )
        return VLC_EGENERIC;

    size_t count = vlc_array_count( &identifiers );
    size_t idx = 0;

    while( idx < count )
    {
        char* id = vlc_array_item_at_index( &identifiers, idx );

        if( vlc_stream_extractor_Attach( source, id, NULL ) )
            break;

        ++idx;
    }

    for( size_t i = 0; i < count; ++i )
        free( vlc_array_item_at_index( &identifiers, i ) );
    vlc_array_clear( &identifiers );

    return idx == count ? VLC_SUCCESS : VLC_EGENERIC;
}",1,,349,4,,void
74822,BLOCK,-1,,<empty>,9,,353,2,,void
74839,BLOCK,-1,,"{
        char* id = vlc_array_item_at_index( &identifiers, idx );

        if( vlc_stream_extractor_Attach( source, id, NULL ) )
            break;

        ++idx;
    }",5,,359,2,,void
74852,BLOCK,-1,,<empty>,13,,363,2,,void
74857,BLOCK,-1,,<empty>,5,,368,1,,void
74887,BLOCK,-1,,"{
    return StreamExtractorCreateMRL( directory->source->psz_url, subentry );
}",1,,378,3,,void
74920,BLOCK,-1,,<empty>,1,,1,1,,ANY
74926,BLOCK,-1,,"{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;
    bool closed;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Unlock(fifo);

    block_ChainRelease(block);

    if (closed)
    {   /* Destroy shared state if write end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }
}",1,,43,2,,void
74963,BLOCK,-1,,"{   /* Destroy shared state if write end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }",5,,58,2,,void
74973,BLOCK,-1,,"{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        if (sys->eof)
        {
            *eof = true;
            break;
        }
        vlc_fifo_Wait(fifo);
    }

    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    return block;
}",1,,65,3,,void
74992,BLOCK,-1,,"{
        if (sys->eof)
        {
            *eof = true;
            break;
        }
        vlc_fifo_Wait(fifo);
    }",5,,72,2,,void
74997,BLOCK,-1,,"{
            *eof = true;
            break;
        }",9,,74,2,,void
75019,BLOCK,-1,,"{
    (void) s;

    switch (query)
    {
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg(ap, bool *) = false;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg(ap, int64_t *) = DEFAULT_PTS_DELAY;
            break;

        default:
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,,87,4,,void
75025,BLOCK,-1,,"{
        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg(ap, bool *) = false;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg(ap, int64_t *) = DEFAULT_PTS_DELAY;
            break;

        default:
            return VLC_EGENERIC;
    }",5,,91,2,,void
75049,BLOCK,-1,,"{
    stream_sys_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->fifo = block_FifoNew();
    if (unlikely(sys->fifo == NULL))
    {
        free(sys);
        return NULL;
    }

    sys->eof = false;

    stream_t *s = vlc_stream_CommonNew(parent, vlc_stream_fifo_Destroy);
    if (unlikely(s == NULL))
    {
        block_FifoRelease(sys->fifo);
        free(sys);
        return NULL;
    }

    s->pf_block = vlc_stream_fifo_Block;
    s->pf_seek = NULL;
    s->pf_control = vlc_stream_fifo_Control;
    s->p_sys = sys;
    return vlc_object_hold(s);
}",1,,110,2,,void
75062,BLOCK,-1,,<empty>,9,,113,2,,void
75077,BLOCK,-1,,"{
        free(sys);
        return NULL;
    }",5,,117,2,,void
75098,BLOCK,-1,,"{
        block_FifoRelease(sys->fifo);
        free(sys);
        return NULL;
    }",5,,126,2,,void
75135,BLOCK,-1,,"{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;

    vlc_fifo_Lock(fifo);
    if (likely(!sys->eof))
    {
        vlc_fifo_QueueUnlocked(fifo, block);
        block = NULL;
    }
    vlc_fifo_Unlock(fifo);

    if (unlikely(block != NULL))
    {
        block_Release(block);
        errno = EPIPE;
        return -1;
    }
    return 0;
}",1,,140,3,,void
75156,BLOCK,-1,,"{
        vlc_fifo_QueueUnlocked(fifo, block);
        block = NULL;
    }",5,,146,2,,void
75170,BLOCK,-1,,"{
        block_Release(block);
        errno = EPIPE;
        return -1;
    }",5,,153,2,,void
75187,BLOCK,-1,,"{
    block_t *block = block_Alloc(len);
    if (unlikely(block == NULL))
        return -1;

    memcpy(block->p_buffer, buf, len);
    return vlc_stream_fifo_Queue(s, block) ? -1 : (ssize_t)len;
}",1,,162,4,,void
75198,BLOCK,-1,,<empty>,9,,165,2,,void
75222,BLOCK,-1,,"{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    bool closed;

    vlc_fifo_Lock(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Signal(fifo);
    vlc_fifo_Unlock(fifo);

    if (closed)
    {   /* Destroy shared state if read end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }

    vlc_object_release(s);
}",1,,172,2,,void
75254,BLOCK,-1,,"{   /* Destroy shared state if read end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }",5,,184,2,,void
75281,BLOCK,-1,,<empty>,1,,1,1,,ANY
75284,BLOCK,-1,,<empty>,,,,2,,<empty>
75290,BLOCK,-1,,"{
    stream_t *s;
    assert( p_source != NULL );

    s = vlc_stream_CommonNew( p_source->obj.parent, StreamDelete );
    if( s == NULL )
        return NULL;

    s->p_input = p_source->p_input;

    if( p_source->psz_url != NULL )
    {
        s->psz_url = strdup( p_source->psz_url );
        if( unlikely(s->psz_url == NULL) )
            goto error;
    }
    s->p_source = p_source;

    /* */
    s->p_module = module_need( s, ""stream_filter"", psz_stream_filter, true );
    if( s->p_module == NULL )
        goto error;

    return s;
error:
    stream_CommonDelete( s );
    return NULL;
}",1,,41,3,,void
75309,BLOCK,-1,,<empty>,9,,47,2,,void
75325,BLOCK,-1,,"{
        s->psz_url = strdup( p_source->psz_url );
        if( unlikely(s->psz_url == NULL) )
            goto error;
    }",5,,52,2,,void
75341,BLOCK,-1,,<empty>,13,,55,2,,void
75363,BLOCK,-1,,<empty>,9,,62,2,,void
75376,BLOCK,-1,,"{
    /* Limit number of entries to avoid infinite recursion. */
    for( unsigned i = 0; i < 16; i++ )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, NULL );
        if( p_filter == NULL )
            break;

        msg_Dbg( p_filter, ""stream filter added to %p"", (void *)p_source );
        p_source = p_filter;
    }
    return p_source;
}",1,,72,2,,void
75378,BLOCK,-1,,<empty>,5,,74,1,,void
75388,BLOCK,4,,"{
        stream_t *p_filter = vlc_stream_FilterNew( p_source, NULL );
        if( p_filter == NULL )
            break;

        msg_Dbg( p_filter, ""stream filter added to %p"", (void *)p_source );
        p_source = p_filter;
    }",5,,75,4,,void
75399,BLOCK,-1,,<empty>,13,,78,2,,void
75417,BLOCK,-1,,"{
    /* Add user stream filter */
    char *chain = strdup( psz_chain );
    if( unlikely(chain == NULL) )
        return p_source;

    char *buf;
    for( const char *name = strtok_r( chain, "":"", &buf );
         name != NULL;
         name = strtok_r( NULL, "":"", &buf ) )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, name );
        if( p_filter != NULL )
            p_source = p_filter;
        else
            msg_Warn( p_source, ""cannot insert stream filter %s"", name );
    }
    free( chain );

    return p_source;
}",1,,88,3,,void
75428,BLOCK,-1,,<empty>,9,,92,2,,void
75433,BLOCK,-1,,<empty>,5,,95,1,,void
75452,BLOCK,4,,"{
        stream_t *p_filter = vlc_stream_FilterNew( p_source, name );
        if( p_filter != NULL )
            p_source = p_filter;
        else
            msg_Warn( p_source, ""cannot insert stream filter %s"", name );
    }",5,,98,4,,void
75463,BLOCK,-1,,<empty>,13,,101,2,,void
75468,BLOCK,-1,,<empty>,13,,103,1,,void
75481,BLOCK,-1,,"{
    module_unneed( s, s->p_module );

    if( s->p_source )
        vlc_stream_Delete( s->p_source );
}",1,,111,2,,void
75491,BLOCK,-1,,<empty>,9,,115,2,,void
75501,BLOCK,-1,,"{
    assert( s->p_source != NULL );
    return vlc_stream_ReadDir( s->p_source, p_node );
}",1,,119,3,,void
75524,BLOCK,-1,,<empty>,1,,1,1,,ANY
75533,BLOCK,-1,,<empty>,,,,4,,<empty>
75539,BLOCK,-1,,<empty>,,,,3,,<empty>
75546,BLOCK,-1,,<empty>,,,,4,,<empty>
75551,BLOCK,-1,,"{
    free(s->p_sys);
}",1,,42,2,,void
75560,BLOCK,-1,,"{
    stream_sys_t *sys = s->p_sys;

    free(sys->p_buffer);
    stream_MemoryPreserveDelete(s);
}",1,,47,2,,void
75580,BLOCK,-1,,"{
    stream_t *s = vlc_stream_CommonNew( p_this,
                                        preserve ? stream_MemoryPreserveDelete
                                                 : stream_MemoryDelete );
    stream_sys_t *p_sys;

    if( !s )
        return NULL;

    s->p_sys = p_sys = malloc( sizeof( stream_sys_t ) );
    if( !s->p_sys )
    {
        stream_CommonDelete( s );
        return NULL;
    }
    p_sys->i_pos = 0;
    p_sys->i_size = i_size;
    p_sys->p_buffer = p_buffer;

    s->pf_read    = Read;
    s->pf_seek    = Seek;
    s->pf_control = Control;

    return s;
}",1,,56,5,,void
75594,BLOCK,-1,,<empty>,9,,63,2,,void
75611,BLOCK,-1,,"{
        stream_CommonDelete( s );
        return NULL;
    }",5,,67,2,,void
75654,BLOCK,-1,,"{
    stream_sys_t *p_sys = s->p_sys;

    uint64_t   *pi_64;

    switch( i_query )
    {
        case STREAM_GET_SIZE:
            pi_64 = va_arg( args, uint64_t * );
            *pi_64 = p_sys->i_size;
            break;

        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool * ) = true;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;

        case STREAM_GET_TITLE_INFO:
        case STREAM_GET_TITLE:
        case STREAM_GET_SEEKPOINT:
        case STREAM_GET_META:
        case STREAM_GET_CONTENT_TYPE:
        case STREAM_GET_SIGNAL:
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
            return VLC_EGENERIC;

        case STREAM_SET_PAUSE_STATE:
            break; /* nothing to do */

        case STREAM_SET_PRIVATE_ID_STATE:
        case STREAM_SET_PRIVATE_ID_CA:
        case STR...",1,,86,4,,void
75664,BLOCK,-1,,"{
        case STREAM_GET_SIZE:
            pi_64 = va_arg( args, uint64_t * );
            *pi_64 = p_sys->i_size;
            break;

        case STREAM_CAN_SEEK:
        case STREAM_CAN_FASTSEEK:
        case STREAM_CAN_PAUSE:
        case STREAM_CAN_CONTROL_PACE:
            *va_arg( args, bool * ) = true;
            break;

        case STREAM_GET_PTS_DELAY:
            *va_arg( args, int64_t * ) = 0;
            break;

        case STREAM_GET_TITLE_INFO:
        case STREAM_GET_TITLE:
        case STREAM_GET_SEEKPOINT:
        case STREAM_GET_META:
        case STREAM_GET_CONTENT_TYPE:
        case STREAM_GET_SIGNAL:
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
            return VLC_EGENERIC;

        case STREAM_SET_PAUSE_STATE:
            break; /* nothing to do */

        case STREAM_SET_PRIVATE_ID_STATE:
        case STREAM_SET_PRIVATE_ID_CA:
        case STREAM_GET_PRIVATE_ID_STATE:
            msg_Err( s, ""Hey, what are you thinking? ""
        ...",5,,92,2,,void
75736,BLOCK,-1,,"{
    stream_sys_t *p_sys = s->p_sys;

    if( i_read > p_sys->i_size - p_sys->i_pos )
        i_read = p_sys->i_size - p_sys->i_pos;
    if ( p_read )
        memcpy( p_read, p_sys->p_buffer + p_sys->i_pos, i_read );
    p_sys->i_pos += i_read;
    return i_read;
}",1,,137,4,,void
75753,BLOCK,-1,,<empty>,9,,141,2,,void
75765,BLOCK,-1,,<empty>,9,,143,2,,void
75788,BLOCK,-1,,"{
    stream_sys_t *p_sys = s->p_sys;

    if( offset > p_sys->i_size )
        offset = p_sys->i_size;

    p_sys->i_pos = offset;
    return VLC_SUCCESS;
}",1,,149,3,,void
75801,BLOCK,-1,,<empty>,9,,153,2,,void
75836,BLOCK,-1,,<empty>,1,,1,1,,ANY
75846,BLOCK,-1,,"{
    unsigned char c;

    /* skip leading whitespace */
    while( ((c = *s) != '\0') && !isalnum(c) )
    {
        s++;
    }
    for(;;)
    {
        /* copy word */
        while( ((c = *s) != '\0') && isalnum(c) )
        {
            *d = tolower(c);
            s++; d++;
        }
        if( *s == 0 ) break;
        /* trim excess whitespace */
        while( ((c = *s) != '\0') && !isalnum(c) )
        {
            s++;
        }
        if( *s == 0 ) break;
        *d++ = ' ';
    }
    *d = 0;
}",1,,50,3,,void
75859,BLOCK,-1,,"{
        s++;
    }",5,,55,2,,void
75863,BLOCK,-1,,<empty>,5,,58,1,,void
75864,BLOCK,4,,"{
        /* copy word */
        while( ((c = *s) != '\0') && isalnum(c) )
        {
            *d = tolower(c);
            s++; d++;
        }
        if( *s == 0 ) break;
        /* trim excess whitespace */
        while( ((c = *s) != '\0') && !isalnum(c) )
        {
            s++;
        }
        if( *s == 0 ) break;
        *d++ = ' ';
    }",5,,59,4,,void
75875,BLOCK,-1,,"{
            *d = tolower(c);
            s++; d++;
        }",9,,62,2,,void
75890,BLOCK,-1,,<empty>,23,,66,2,,void
75903,BLOCK,-1,,"{
            s++;
        }",9,,69,2,,void
75911,BLOCK,-1,,<empty>,23,,72,2,,void
75927,BLOCK,-1,,"{
    unsigned char c;

    const char *tmp = strrchr(s, '.');
    if( !tmp )
    {
        strcpy(d, s);
        return;
    }
    else
        strlcpy(d, s, tmp - s + 1 );
    while( (c = *d) != '\0' )
    {
        *d = tolower(c);
        d++;
    }
}",1,,79,3,,void
75938,BLOCK,-1,,"{
        strcpy(d, s);
        return;
    }",5,,84,2,,void
75944,BLOCK,-1,,<empty>,9,,89,1,,void
75960,BLOCK,-1,,"{
        *d = tolower(c);
        d++;
    }",5,,91,2,,void
75973,BLOCK,-1,,"{
    const char *tmp = strrchr(s, '.');
    if( !tmp )
        strcpy(d, """");
    else
        strcpy( d, tmp + 1 );
}",1,,98,3,,void
75983,BLOCK,-1,,<empty>,9,,101,2,,void
75988,BLOCK,-1,,<empty>,9,,103,1,,void
75998,BLOCK,-1,,"{
    unsigned char c;

    while( (c = *s) != '\0' )
    {
        if( isalnum( c ) )
            return 0;
        s++;
    }
    return 1;
}",1,,107,2,,void
76007,BLOCK,-1,,"{
        if( isalnum( c ) )
            return 0;
        s++;
    }",5,,111,2,,void
76011,BLOCK,-1,,<empty>,13,,113,2,,void
76023,BLOCK,-1,,"{
    const input_item_slave_t *p_slave0 = *((const input_item_slave_t **) a);
    const input_item_slave_t *p_slave1 = *((const input_item_slave_t **) b);

    if( p_slave0 == NULL || p_slave1 == NULL )
        return 0;

    /* We can compare these uris since they come from the file system */
#ifdef HAVE_STRCOLL
    return strcoll( p_slave0->psz_uri, p_slave1->psz_uri );
#else
    return strcmp( p_slave0->psz_uri, p_slave1->psz_uri );
#endif
}",1,,120,3,,void
76046,BLOCK,-1,,<empty>,9,,125,2,,void
76061,BLOCK,-1,,"{
    const char *tmp = strrchr( psz_dir_content, '.');

    if( !tmp )
        return 0;
    tmp++;

    for( int i = 0; sub_exts[i][0]; i++ )
        if( strcasecmp( sub_exts[i], tmp ) == 0 )
            return 1;
    return 0;
}",1,,139,2,,void
76071,BLOCK,-1,,<empty>,9,,143,2,,void
76077,BLOCK,-1,,<empty>,5,,146,1,,void
76097,BLOCK,-1,,<empty>,13,,148,2,,void
76107,BLOCK,-1,,"{
    unsigned int i, k, i_nb_subdirs;
    char **subdirs; /* list of subdirectories to look in */
    char *psz_parser = psz_path;

    if( !psz_dir || !psz_path )
        return NULL;

    for( k = 0, i_nb_subdirs = 1; psz_path[k] != '\0'; k++ )
    {
        if( psz_path[k] == ',' )
            i_nb_subdirs++;
    }

    subdirs = calloc( i_nb_subdirs + 1, sizeof(char*) );
    if( !subdirs )
        return NULL;

    for( i = 0; psz_parser && *psz_parser != '\0' ; )
    {
        char *psz_subdir = psz_parser;
        psz_parser = strchr( psz_subdir, ',' );
        if( psz_parser )
        {
            *psz_parser++ = '\0';
            while( *psz_parser == ' ' )
                psz_parser++;
        }
        if( *psz_subdir == '\0' )
            continue;

        if( asprintf( &subdirs[i++], ""%s%s"",
                  psz_subdir[0] == '.' ? psz_dir : """",
                  psz_subdir ) == -1 )
            break;
    }
    subdirs[i] = NULL;

    return subdirs;
}",1,,157,3,,void
76122,BLOCK,-1,,<empty>,9,,163,2,,void
76126,BLOCK,-1,,<empty>,5,,165,1,,void
76141,BLOCK,4,,"{
        if( psz_path[k] == ',' )
            i_nb_subdirs++;
    }",5,,166,4,,void
76148,BLOCK,-1,,<empty>,13,,168,2,,void
76162,BLOCK,-1,,<empty>,9,,173,2,,void
76166,BLOCK,-1,,<empty>,5,,175,1,,void
76176,BLOCK,4,,"{
        char *psz_subdir = psz_parser;
        psz_parser = strchr( psz_subdir, ',' );
        if( psz_parser )
        {
            *psz_parser++ = '\0';
            while( *psz_parser == ' ' )
                psz_parser++;
        }
        if( *psz_subdir == '\0' )
            continue;

        if( asprintf( &subdirs[i++], ""%s%s"",
                  psz_subdir[0] == '.' ? psz_dir : """",
                  psz_subdir ) == -1 )
            break;
    }",5,,176,4,,void
76188,BLOCK,-1,,"{
            *psz_parser++ = '\0';
            while( *psz_parser == ' ' )
                psz_parser++;
        }",9,,180,2,,void
76206,BLOCK,-1,,<empty>,13,,186,2,,void
76228,BLOCK,-1,,<empty>,13,,191,2,,void
76245,BLOCK,-1,,"{
    int i_fuzzy = var_GetInteger( p_this, ""sub-autodetect-fuzzy"" );
    if ( i_fuzzy == 0 )
        return VLC_EGENERIC;
    int i_fname_len;
    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;
    char *f_fname_noext = NULL, *f_fname_trim = NULL;
    char **subdirs; /* list of subdirectories to look in */

    if( !psz_name_org )
        return VLC_EGENERIC;

    char *psz_fname = vlc_uri2path( psz_name_org );
    if( !psz_fname )
        return VLC_EGENERIC;

    /* extract filename & dirname from psz_fname */
    char *f_dir = strdup( psz_fname );
    if( f_dir == 0 )
    {
        free( psz_fname );
        return VLC_ENOMEM;
    }

    const char *f_fname = strrchr( psz_fname, DIR_SEP_CHAR );
    if( !f_fname )
    {
        free( f_dir );
        free( psz_fname );
        return VLC_EGENERIC;
    }
    f_fname++; /* Skip the '/' */
    f_dir[f_fname - psz_fname] = 0; /* keep dir separator in f_dir */

    i_fname_len = strlen( f_fname );

    f_f...",1,,216,6,,void
76256,BLOCK,-1,,<empty>,9,,219,2,,void
76282,BLOCK,-1,,<empty>,9,,227,2,,void
76293,BLOCK,-1,,<empty>,9,,231,2,,void
76305,BLOCK,-1,,"{
        free( psz_fname );
        return VLC_ENOMEM;
    }",5,,236,2,,void
76319,BLOCK,-1,,"{
        free( f_dir );
        free( psz_fname );
        return VLC_EGENERIC;
    }",5,,243,2,,void
76357,BLOCK,-1,,"{
        free( f_dir );
        free( f_fname_noext );
        free( f_fname_trim );
        free( psz_fname );
        return VLC_ENOMEM;
    }",5,,256,2,,void
76380,BLOCK,-1,,<empty>,5,,268,1,,void
76406,BLOCK,4,,"{
        const char *psz_dir = (j < 0) ? f_dir : subdirs[j];
        if( psz_dir == NULL || ( j >= 0 && !strcmp( psz_dir, f_dir ) ) )
            continue;

        /* parse psz_src dir */
        DIR *dir = vlc_opendir( psz_dir );
        if( dir == NULL )
            continue;

        msg_Dbg( p_this, ""looking for a subtitle file in %s"", psz_dir );

        const char *psz_name;
        while( (psz_name = vlc_readdir( dir )) )
        {
            if( psz_name[0] == '.' || !subtitles_Filter( psz_name ) )
                continue;

            char tmp_fname_noext[strlen( psz_name ) + 1];
            char tmp_fname_trim[strlen( psz_name ) + 1];
            char tmp_fname_ext[strlen( psz_name ) + 1];
            const char *tmp;
            int i_prio = 0;

            /* retrieve various parts of the filename */
            strcpy_strip_ext( tmp_fname_noext, psz_name );
            strcpy_get_ext( tmp_fname_ext, psz_name );
            strcpy_trim( tmp_fname_trim, tmp_fname_noex...",5,,269,4,,void
76431,BLOCK,-1,,<empty>,13,,272,2,,void
76442,BLOCK,-1,,<empty>,13,,277,2,,void
76454,BLOCK,-1,,"{
            if( psz_name[0] == '.' || !subtitles_Filter( psz_name ) )
                continue;

            char tmp_fname_noext[strlen( psz_name ) + 1];
            char tmp_fname_trim[strlen( psz_name ) + 1];
            char tmp_fname_ext[strlen( psz_name ) + 1];
            const char *tmp;
            int i_prio = 0;

            /* retrieve various parts of the filename */
            strcpy_strip_ext( tmp_fname_noext, psz_name );
            strcpy_get_ext( tmp_fname_ext, psz_name );
            strcpy_trim( tmp_fname_trim, tmp_fname_noext );

            if( !strcmp( tmp_fname_trim, f_fname_trim ) )
            {
                /* matches the movie name exactly */
                i_prio = SLAVE_PRIORITY_MATCH_ALL;
            }
            else if( (tmp = strstr( tmp_fname_trim, f_fname_trim )) )
            {
                /* contains the movie name */
                tmp += strlen( f_fname_trim );
                if( whiteonly( tmp ) )
                {
             ...",9,,283,2,,void
76465,BLOCK,-1,,<empty>,17,,285,2,,void
76489,BLOCK,-1,,"{
                /* matches the movie name exactly */
                i_prio = SLAVE_PRIORITY_MATCH_ALL;
            }",13,,299,2,,void
76494,BLOCK,-1,,<empty>,18,,303,1,,void
76501,BLOCK,-1,,"{
                /* contains the movie name */
                tmp += strlen( f_fname_trim );
                if( whiteonly( tmp ) )
                {
                    /* chars in front of the movie name */
                    i_prio = SLAVE_PRIORITY_MATCH_RIGHT;
                }
                else
                {
                    /* chars after (and possibly in front of)
                     * the movie name */
                    i_prio = SLAVE_PRIORITY_MATCH_LEFT;
                }
            }",13,,304,2,,void
76509,BLOCK,-1,,"{
                    /* chars in front of the movie name */
                    i_prio = SLAVE_PRIORITY_MATCH_RIGHT;
                }",17,,308,2,,void
76514,BLOCK,-1,,"{
                    /* chars after (and possibly in front of)
                     * the movie name */
                    i_prio = SLAVE_PRIORITY_MATCH_LEFT;
                }",17,,313,1,,void
76519,BLOCK,-1,,<empty>,18,,319,1,,void
76525,BLOCK,-1,,"{
                /* doesn't contain the movie name, prefer files in f_dir over subdirs */
                i_prio = SLAVE_PRIORITY_MATCH_NONE;
            }",13,,320,2,,void
76533,BLOCK,-1,,"{
                struct stat st;
                char *path;

                size_t i_len = strlen( psz_dir );
                const char *psz_format;
                if ( i_len == 0 )
                    continue;
                if( psz_dir[i_len - 1] == DIR_SEP_CHAR )
                    psz_format = ""%s%s"";
                else
                    psz_format = ""%s""DIR_SEP""%s"";

                if( asprintf( &path, psz_format, psz_dir, psz_name ) < 0 )
                    continue;

                if( strcmp( path, psz_fname )
                 && vlc_stat( path, &st ) == 0
                 && S_ISREG( st.st_mode ) )
                {
                    msg_Dbg( p_this,
                            ""autodetected subtitle: %s with priority %d"",
                            path, i_prio );
                    char *psz_uri = vlc_path2uri( path, NULL );
                    input_item_slave_t *p_sub = psz_uri != NULL ?
                        input_item_slave_New( psz_uri, SLAVE_TYP...",13,,325,2,,void
76546,BLOCK,-1,,<empty>,21,,332,2,,void
76564,BLOCK,-1,,<empty>,21,,339,2,,void
76582,BLOCK,-1,,"{
                    msg_Dbg( p_this,
                            ""autodetected subtitle: %s with priority %d"",
                            path, i_prio );
                    char *psz_uri = vlc_path2uri( path, NULL );
                    input_item_slave_t *p_sub = psz_uri != NULL ?
                        input_item_slave_New( psz_uri, SLAVE_TYPE_SPU, i_prio )
                        : NULL;
                    if( p_sub )
                    {
                        p_sub->b_forced = true;
                        TAB_APPEND(i_slaves, pp_slaves, p_sub);
                    }
                    free( psz_uri );
                }",17,,344,2,,void
76608,BLOCK,-1,,"{
                        p_sub->b_forced = true;
                        TAB_APPEND(i_slaves, pp_slaves, p_sub);
                    }",21,,353,2,,void
76626,BLOCK,-1,,"{
        for( size_t j = 0; subdirs[j] != NULL; j++ )
            free( subdirs[j] );
        free( subdirs );
    }",5,,365,2,,void
76628,BLOCK,-1,,<empty>,9,,366,1,,void
76655,BLOCK,-1,,<empty>,5,,375,1,,void
76665,BLOCK,4,,"{
        input_item_slave_t *p_sub = pp_slaves[i];

        bool b_reject = false;
        char *psz_ext = strrchr( p_sub->psz_uri, '.' );
        if( !psz_ext )
            continue;
        psz_ext++;

        if( !strcasecmp( psz_ext, ""sub"" ) )
        {
            for( int j = 0; j < i_slaves; j++ )
            {
                input_item_slave_t *p_sub_inner = pp_slaves[j];

                /* A slave can be null if it's already rejected */
                if( p_sub_inner == NULL )
                    continue;

                /* check that the filenames without extension match */
                if( strncasecmp( p_sub->psz_uri, p_sub_inner->psz_uri,
                    strlen( p_sub->psz_uri ) - 3 ) )
                    continue;

                char *psz_ext_inner = strrchr( p_sub_inner->psz_uri, '.' );
                if( !psz_ext_inner )
                    continue;
                psz_ext_inner++;

                /* check that we have an idx file */
               ...",5,,376,4,,void
76687,BLOCK,-1,,<empty>,13,,382,2,,void
76696,BLOCK,-1,,"{
            for( int j = 0; j < i_slaves; j++ )
            {
                input_item_slave_t *p_sub_inner = pp_slaves[j];

                /* A slave can be null if it's already rejected */
                if( p_sub_inner == NULL )
                    continue;

                /* check that the filenames without extension match */
                if( strncasecmp( p_sub->psz_uri, p_sub_inner->psz_uri,
                    strlen( p_sub->psz_uri ) - 3 ) )
                    continue;

                char *psz_ext_inner = strrchr( p_sub_inner->psz_uri, '.' );
                if( !psz_ext_inner )
                    continue;
                psz_ext_inner++;

                /* check that we have an idx file */
                if( !strcasecmp( psz_ext_inner, ""idx"" ) )
                {
                    b_reject = true;
                    break;
                }
            }
        }",9,,386,2,,void
76698,BLOCK,-1,,<empty>,13,,387,1,,void
76708,BLOCK,4,,"{
                input_item_slave_t *p_sub_inner = pp_slaves[j];

                /* A slave can be null if it's already rejected */
                if( p_sub_inner == NULL )
                    continue;

                /* check that the filenames without extension match */
                if( strncasecmp( p_sub->psz_uri, p_sub_inner->psz_uri,
                    strlen( p_sub->psz_uri ) - 3 ) )
                    continue;

                char *psz_ext_inner = strrchr( p_sub_inner->psz_uri, '.' );
                if( !psz_ext_inner )
                    continue;
                psz_ext_inner++;

                /* check that we have an idx file */
                if( !strcasecmp( psz_ext_inner, ""idx"" ) )
                {
                    b_reject = true;
                    break;
                }
            }",13,,388,4,,void
76719,BLOCK,-1,,<empty>,21,,393,2,,void
76735,BLOCK,-1,,<empty>,21,,398,2,,void
76748,BLOCK,-1,,<empty>,21,,402,2,,void
76757,BLOCK,-1,,"{
                    b_reject = true;
                    break;
                }",17,,407,2,,void
76763,BLOCK,-1,,<empty>,14,,413,1,,void
76769,BLOCK,-1,,"{
            if( p_sub->i_priority < SLAVE_PRIORITY_MATCH_ALL )
                b_reject = true;
        }",9,,414,2,,void
76776,BLOCK,-1,,<empty>,17,,416,2,,void
76782,BLOCK,-1,,"{
            pp_slaves[i] = NULL;
            input_item_slave_Delete( p_sub );
        }",9,,419,2,,void
76794,BLOCK,-1,,<empty>,9,,427,2,,void
76831,BLOCK,-1,,<empty>,1,,1,1,,ANY
76838,BLOCK,-1,,<empty>,,,,6,,<empty>
76847,BLOCK,-1,,<empty>,,,,6,,<empty>
76856,BLOCK,-1,,<empty>,,,,6,,<empty>
76865,BLOCK,-1,,<empty>,,,,6,,<empty>
76874,BLOCK,-1,,<empty>,,,,6,,<empty>
76883,BLOCK,-1,,<empty>,,,,6,,<empty>
76892,BLOCK,-1,,<empty>,,,,6,,<empty>
76901,BLOCK,-1,,<empty>,,,,6,,<empty>
76910,BLOCK,-1,,<empty>,,,,6,,<empty>
76919,BLOCK,-1,,<empty>,,,,6,,<empty>
76928,BLOCK,-1,,<empty>,,,,6,,<empty>
76937,BLOCK,-1,,<empty>,,,,6,,<empty>
76946,BLOCK,-1,,<empty>,,,,6,,<empty>
76955,BLOCK,-1,,<empty>,,,,6,,<empty>
76964,BLOCK,-1,,<empty>,,,,6,,<empty>
76973,BLOCK,-1,,<empty>,,,,6,,<empty>
76983,BLOCK,-1,,<empty>,,,,3,,<empty>
76989,BLOCK,-1,,<empty>,,,,3,,<empty>
77068,BLOCK,-1,,"{
    vlc_value_t val, text;

    /* State */
    var_Create( p_input, ""state"", VLC_VAR_INTEGER );
    val.i_int = input_priv(p_input)->i_state;
    var_Change( p_input, ""state"", VLC_VAR_SETVALUE, &val, NULL );

    /* Rate */
    var_Create( p_input, ""rate"", VLC_VAR_FLOAT | VLC_VAR_DOINHERIT );

    var_Create( p_input, ""frame-next"", VLC_VAR_VOID );

    /* Position */
    var_Create( p_input, ""position"",  VLC_VAR_FLOAT );

    /* Time */
    var_Create( p_input, ""time"", VLC_VAR_INTEGER );
    var_Create( p_input, ""time-offset"", VLC_VAR_INTEGER );    /* relative */

    /* Bookmark */
    var_Create( p_input, ""bookmark"", VLC_VAR_INTEGER | VLC_VAR_ISCOMMAND );
    val.psz_string = _(""Bookmark"");
    var_Change( p_input, ""bookmark"", VLC_VAR_SETTEXT, &val, NULL );

    /* Program */
    var_Create( p_input, ""program"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Get( p_input, ""program"", &val );
    if( val.i_int <= 0 )
        var_Change( p_input, ""program"", VLC_VAR_DELCHOICE, &val,...",1,,130,2,,void
77148,BLOCK,-1,,<empty>,9,,159,2,,void
77353,BLOCK,-1,,<empty>,9,,221,2,,void
77361,BLOCK,-1,,"{
    if( !input_priv(p_input)->b_preparsing )
        InputDelCallbacks( p_input, p_input_callbacks );

    if( input_priv(p_input)->i_title > 1 )
        InputDelCallbacks( p_input, p_input_title_navigation_callbacks );

    for( int i = 0; i < input_priv(p_input)->i_title; i++ )
    {
        char name[sizeof(""title "") + 3 * sizeof (int)];

        sprintf( name, ""title %2u"", i );
        var_DelCallback( p_input, name, NavigationCallback, (void *)(intptr_t)i );
    }

    if( var_Type( p_input, ""next-chapter"" ) != 0 )
    {
        assert( var_Type( p_input, ""prev-chapter"" ) != 0 );
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }
}",1,,228,2,,void
77368,BLOCK,-1,,<empty>,9,,230,2,,void
77379,BLOCK,-1,,<empty>,9,,233,2,,void
77384,BLOCK,-1,,<empty>,5,,235,1,,void
77397,BLOCK,4,,"{
        char name[sizeof(""title "") + 3 * sizeof (int)];

        sprintf( name, ""title %2u"", i );
        var_DelCallback( p_input, name, NavigationCallback, (void *)(intptr_t)i );
    }",5,,236,4,,void
77418,BLOCK,-1,,"{
        assert( var_Type( p_input, ""prev-chapter"" ) != 0 );
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }",5,,244,2,,void
77435,BLOCK,-1,,"{
    vlc_value_t text;

    /* Create more command variables */
    if( input_priv(p_input)->i_title > 1 )
    {
        if( var_Type( p_input, ""next-title"" ) == 0 ) {
            var_Create( p_input, ""next-title"", VLC_VAR_VOID );
            text.psz_string = _(""Next title"");
            var_Change( p_input, ""next-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""next-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""prev-title"" ) == 0 ) {
            var_Create( p_input, ""prev-title"", VLC_VAR_VOID );
            text.psz_string = _(""Previous title"");
            var_Change( p_input, ""prev-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""prev-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""menu-title"" ) == 0 ) {
            var_Create( p_input, ""menu-title"", VLC_VAR_VOID );
            text.psz_string = _(""Menu title"");
            var_Change( p_input, ""menu-title"", VLC_VAR...",1,,256,2,,void
77444,BLOCK,-1,,"{
        if( var_Type( p_input, ""next-title"" ) == 0 ) {
            var_Create( p_input, ""next-title"", VLC_VAR_VOID );
            text.psz_string = _(""Next title"");
            var_Change( p_input, ""next-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""next-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""prev-title"" ) == 0 ) {
            var_Create( p_input, ""prev-title"", VLC_VAR_VOID );
            text.psz_string = _(""Previous title"");
            var_Change( p_input, ""prev-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""prev-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""menu-title"" ) == 0 ) {
            var_Create( p_input, ""menu-title"", VLC_VAR_VOID );
            text.psz_string = _(""Menu title"");
            var_Change( p_input, ""menu-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""menu-title"", TitleCallback, NULL );
        }

 ...",5,,261,2,,void
77451,BLOCK,-1,,"{
            var_Create( p_input, ""next-title"", VLC_VAR_VOID );
            text.psz_string = _(""Next title"");
            var_Change( p_input, ""next-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""next-title"", TitleCallback, NULL );
        }",54,,262,2,,void
77480,BLOCK,-1,,"{
            var_Create( p_input, ""prev-title"", VLC_VAR_VOID );
            text.psz_string = _(""Previous title"");
            var_Change( p_input, ""prev-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""prev-title"", TitleCallback, NULL );
        }",54,,269,2,,void
77509,BLOCK,-1,,"{
            var_Create( p_input, ""menu-title"", VLC_VAR_VOID );
            text.psz_string = _(""Menu title"");
            var_Change( p_input, ""menu-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""menu-title"", TitleCallback, NULL );
        }",54,,276,2,,void
77538,BLOCK,-1,,"{
            var_Create( p_input, ""menu-popup"", VLC_VAR_VOID );
            text.psz_string = _(""Menu popup"");
            var_Change( p_input, ""menu-popup"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""menu-popup"", TitleCallback, NULL );
        }",54,,283,2,,void
77568,BLOCK,-1,,<empty>,5,,294,1,,void
77581,BLOCK,4,,"{
        vlc_value_t val2, text2;
        char title[sizeof(""title "") + 3 * sizeof (int)];

        /* Add Navigation entries */
        sprintf( title, ""title %2u"", i );
        var_Destroy( p_input, title );
        var_Create( p_input, title, VLC_VAR_INTEGER | VLC_VAR_ISCOMMAND );
        var_AddCallback( p_input, title,
                         NavigationCallback, (void *)(intptr_t)i );

        char psz_length[MSTRTIME_MAX_SIZE + sizeof("" []"")];
        if( input_priv(p_input)->title[i]->i_length > 0 )
        {
            strcpy( psz_length, "" ["" );
            secstotimestr( &psz_length[2], input_priv(p_input)->title[i]->i_length / CLOCK_FREQ );
            strcat( psz_length, ""]"" );
        }
        else
            psz_length[0] = '\0';

        if( input_priv(p_input)->title[i]->psz_name == NULL ||
            *input_priv(p_input)->title[i]->psz_name == '\0' )
        {
            if( asprintf( &text.psz_string, _(""Title %i%s""),
                          i + input_priv...",5,,295,4,,void
77619,BLOCK,-1,,"{
            strcpy( psz_length, "" ["" );
            secstotimestr( &psz_length[2], input_priv(p_input)->title[i]->i_length / CLOCK_FREQ );
            strcat( psz_length, ""]"" );
        }",9,,308,2,,void
77642,BLOCK,-1,,<empty>,13,,314,1,,void
77671,BLOCK,-1,,"{
            if( asprintf( &text.psz_string, _(""Title %i%s""),
                          i + input_priv(p_input)->i_title_offset, psz_length ) == -1 )
                continue;
        }",9,,318,2,,void
77690,BLOCK,-1,,<empty>,17,,321,2,,void
77693,BLOCK,-1,,"{
            if( asprintf( &text.psz_string, ""%s%s"",
                          input_priv(p_input)->title[i]->psz_name, psz_length ) == -1 )
                continue;
        }",9,,324,1,,void
77713,BLOCK,-1,,<empty>,17,,327,2,,void
77733,BLOCK,-1,,<empty>,9,,336,1,,void
77750,BLOCK,4,,"{
            val2.i_int = j;

            if( input_priv(p_input)->title[i]->seekpoint[j]->psz_name == NULL ||
                *input_priv(p_input)->title[i]->seekpoint[j]->psz_name == '\0' )
            {
                /* Default value */
                if( asprintf( &text2.psz_string, _(""Chapter %i""),
                          j + input_priv(p_input)->i_seekpoint_offset ) == -1 )
                    continue;
            }
            else
            {
                text2.psz_string =
                    strdup( input_priv(p_input)->title[i]->seekpoint[j]->psz_name );
            }

            var_Change( p_input, title, VLC_VAR_ADDCHOICE, &val2, &text2 );
            free( text2.psz_string );
        }",9,,337,4,,void
77787,BLOCK,-1,,"{
                /* Default value */
                if( asprintf( &text2.psz_string, _(""Chapter %i""),
                          j + input_priv(p_input)->i_seekpoint_offset ) == -1 )
                    continue;
            }",13,,342,2,,void
77805,BLOCK,-1,,<empty>,21,,346,2,,void
77808,BLOCK,-1,,"{
                text2.psz_string =
                    strdup( input_priv(p_input)->title[i]->seekpoint[j]->psz_name );
            }",13,,349,1,,void
77843,BLOCK,-1,,"{
    const input_title_t *t = input_priv(p_input)->title[i_title];
    vlc_value_t text;
    int  i;

    /* Create/Destroy command variables */
    if( t->i_seekpoint <= 1 )
    {
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }
    else if( var_Type( p_input, ""next-chapter"" ) == 0 )
    {
        var_Create( p_input, ""next-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Next chapter"");
        var_Change( p_input, ""next-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""next-chapter"", SeekpointCallback, NULL );

        var_Create( p_input, ""prev-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Previous chapter"");
        var_Change( p_input, ""prev-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""prev-chapter"", SeekpointCallback, NULL );
    }

    /* Build chapter list */
    var_Change( p_input, ""chapter"", VLC_VAR_CLEARCHOICES, NULL, NULL );
    for( i = 0; i ...",1,,366,3,,void
77861,BLOCK,-1,,"{
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }",5,,373,2,,void
77869,BLOCK,-1,,<empty>,10,,377,1,,void
77876,BLOCK,-1,,"{
        var_Create( p_input, ""next-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Next chapter"");
        var_Change( p_input, ""next-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""next-chapter"", SeekpointCallback, NULL );

        var_Create( p_input, ""prev-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Previous chapter"");
        var_Change( p_input, ""prev-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""prev-chapter"", SeekpointCallback, NULL );
    }",5,,378,2,,void
77928,BLOCK,-1,,<empty>,5,,392,1,,void
77939,BLOCK,4,,"{
        vlc_value_t val;
        val.i_int = i;

        if( t->seekpoint[i]->psz_name == NULL ||
            *t->seekpoint[i]->psz_name == '\0' )
        {
            /* Default value */
            if( asprintf( &text.psz_string, _(""Chapter %i""),
                      i + input_priv(p_input)->i_seekpoint_offset ) == -1 )
                continue;
        }
        else
        {
            text.psz_string = strdup( t->seekpoint[i]->psz_name );
        }

        var_Change( p_input, ""chapter"", VLC_VAR_ADDCHOICE, &val, &text );
        free( text.psz_string );
    }",5,,393,4,,void
77967,BLOCK,-1,,"{
            /* Default value */
            if( asprintf( &text.psz_string, _(""Chapter %i""),
                      i + input_priv(p_input)->i_seekpoint_offset ) == -1 )
                continue;
        }",9,,399,2,,void
77985,BLOCK,-1,,<empty>,17,,403,2,,void
77988,BLOCK,-1,,"{
            text.psz_string = strdup( t->seekpoint[i]->psz_name );
        }",9,,406,1,,void
78017,BLOCK,-1,,"{
    /* Create Object Variables for private use only */

    if( !input_priv(p_input)->b_preparsing )
    {
        var_Create( p_input, ""video"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""audio"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""spu"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""menu-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track-id"",
                    VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track-id"",
                    VLC_VAR_INTEGER|VLC_VAR_DOINHE...",1,,420,2,,void
78024,BLOCK,-1,,"{
        var_Create( p_input, ""video"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""audio"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
        var_Create( p_input, ""spu"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track"", VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""menu-language"",
                    VLC_VAR_STRING|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""audio-track-id"",
                    VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );
        var_Create( p_input, ""sub-track-id"",
                    VLC_VAR_INTEGER|VLC_VAR_DOINHERIT );

        var_Create( p_input, ""sub-file"", VLC_VAR_STRING | VLC_VAR_DOINHERIT );
        var_Create( ...",5,,424,2,,void
78373,BLOCK,-1,,"{
    int i;
    for( i = 0; p_callbacks[i].psz_name != NULL; i++ )
        var_AddCallback( p_input,
                         p_callbacks[i].psz_name,
                         p_callbacks[i].callback, NULL );
}",1,,535,3,,void
78376,BLOCK,-1,,<empty>,5,,537,1,,void
78407,BLOCK,-1,,"{
    int i;
    for( i = 0; p_callbacks[i].psz_name != NULL; i++ )
        var_DelCallback( p_input,
                         p_callbacks[i].psz_name,
                         p_callbacks[i].callback, NULL );
}",1,,545,3,,void
78410,BLOCK,-1,,<empty>,5,,547,1,,void
78444,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( newval.i_int == PLAYING_S || newval.i_int == PAUSE_S )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_STATE, &newval );
        return VLC_SUCCESS;
    }

    return VLC_EGENERIC;
}",1,,559,6,,void
78469,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_STATE, &newval );
        return VLC_SUCCESS;
    }",5,,564,2,,void
78487,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(psz_cmd);

    newval.i_int = INPUT_RATE_DEFAULT / newval.f_float;
    input_ControlPush( p_input, INPUT_CONTROL_SET_RATE, &newval );

    return VLC_SUCCESS;
}",1,,574,6,,void
78524,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;

    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    /* Update ""length"" for better intf behaviour */
    const int64_t i_length = var_GetInteger( p_input, ""length"" );
    if( i_length > 0 && newval.f_float >= 0.f && newval.f_float <= 1.f )
    {
        vlc_value_t val;

        val.i_int = i_length * newval.f_float;
        var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );
    }

    input_ControlPush( p_input, INPUT_CONTROL_SET_POSITION, &newval );
    return VLC_SUCCESS;
}",1,,587,6,,void
78559,BLOCK,-1,,"{
        vlc_value_t val;

        val.i_int = i_length * newval.f_float;
        var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );
    }",5,,595,2,,void
78592,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    /* Update ""position"" for better intf behaviour */
    const int64_t i_length = var_GetInteger( p_input, ""length"" );
    if( i_length > 0 && newval.i_int >= 0 && newval.i_int <= i_length )
    {
        vlc_value_t val;

        val.f_float = (double)newval.i_int/(double)i_length;
        var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );
        /*
         * Notify the intf that a new event has been occurred.
         * XXX this is a bit hackish but it's the only way to do it now.
         */
        var_SetInteger( p_input, ""intf-event"", INPUT_EVENT_POSITION );
    }

    input_ControlPush( p_input, INPUT_CONTROL_SET_TIME, &newval );
    return VLC_SUCCESS;
}",1,,608,6,,void
78627,BLOCK,-1,,"{
        vlc_value_t val;

        val.f_float = (double)newval.i_int/(double)i_length;
        var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );
        /*
         * Notify the intf that a new event has been occurred.
         * XXX this is a bit hackish but it's the only way to do it now.
         */
        var_SetInteger( p_input, ""intf-event"", INPUT_EVENT_POSITION );
    }",5,,615,2,,void
78668,BLOCK,-1,,"{
    VLC_UNUSED(varname); VLC_UNUSED(prev); VLC_UNUSED(data);

    int64_t i_time = var_GetInteger( obj, ""time"" ) + cur.i_int;
    if( i_time < 0 )
        i_time = 0;
    var_SetInteger( obj, ""time"", i_time );
    return VLC_SUCCESS;
}",1,,633,6,,void
78689,BLOCK,-1,,<empty>,9,,638,2,,void
78707,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_PROGRAM, &newval );

    return VLC_SUCCESS;
}",1,,646,6,,void
78735,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t val, count;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""next-title"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) + 1;
        var_Change( p_input, ""title"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !strcmp( psz_cmd, ""prev-title"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !strcmp( psz_cmd, ""menu-title"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_NAV_MENU, NULL );
    }
    else if( !strcmp( psz_cmd, ""menu-popup"" ) )
    {
        i...",1,,658,6,,void
78753,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) + 1;
        var_Change( p_input, ""title"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }",5,,664,2,,void
78782,BLOCK,-1,,<empty>,13,,670,2,,void
78791,BLOCK,-1,,<empty>,10,,672,1,,void
78797,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""title"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );
    }",5,,673,2,,void
78817,BLOCK,-1,,<empty>,13,,678,2,,void
78826,BLOCK,-1,,<empty>,10,,680,1,,void
78832,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_NAV_MENU, NULL );
    }",5,,681,2,,void
78838,BLOCK,-1,,<empty>,10,,684,1,,void
78844,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_NAV_POPUP, NULL );
    }",5,,685,2,,void
78850,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &newval );
    }",5,,689,1,,void
78866,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t val, count;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""next-chapter"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) + 1;
        var_Change( p_input, ""chapter"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else if( !strcmp( psz_cmd, ""prev-chapter"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );
    }
    else
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &newval );
    }

    return VLC_SUCCESS;
}",1,,699,6,,void
78884,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_NEXT, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) + 1;
        var_Change( p_input, ""chapter"", VLC_VAR_CHOICESCOUNT, &count, NULL );
        if( val.i_int < count.i_int )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );
    }",5,,705,2,,void
78913,BLOCK,-1,,<empty>,13,,711,2,,void
78922,BLOCK,-1,,<empty>,10,,713,1,,void
78928,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT_PREV, NULL );

        val.i_int = var_GetInteger( p_input, ""chapter"" ) - 1;
        if( val.i_int >= 0 )
            var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );
    }",5,,714,2,,void
78948,BLOCK,-1,,<empty>,13,,719,2,,void
78957,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &newval );
    }",5,,722,1,,void
78973,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    vlc_value_t     val;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);

    /* Issue a title change */
    val.i_int = (intptr_t)p_data;
    input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &val );

    var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );

    /* And a chapter change */
    input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &newval );

    var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &newval, NULL );

    return VLC_SUCCESS;
}",1,,732,6,,void
79026,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -VIDEO_ES; /* disable video es */
    else
        var_SetBool( p_input, ""video"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",1,,753,6,,void
79045,BLOCK,-1,,<empty>,9,,758,2,,void
79053,BLOCK,-1,,<empty>,9,,760,1,,void
79073,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -AUDIO_ES; /* disable audio es */
    else
        var_SetBool( p_input, ""audio"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",1,,769,6,,void
79092,BLOCK,-1,,<empty>,9,,774,2,,void
79100,BLOCK,-1,,<empty>,9,,776,1,,void
79120,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED( psz_cmd); VLC_UNUSED( oldval ); VLC_UNUSED( p_data );

    if( newval.i_int < 0 )
        newval.i_int = -SPU_ES; /* disable spu es */
    else
        var_SetBool( p_input, ""spu"", true );

    input_ControlPush( p_input, INPUT_CONTROL_SET_ES, &newval );

    return VLC_SUCCESS;
}",1,,785,6,,void
79139,BLOCK,-1,,<empty>,9,,790,2,,void
79147,BLOCK,-1,,<empty>,9,,792,1,,void
79167,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( !strcmp( psz_cmd, ""audio-delay"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_AUDIO_DELAY, &newval );
    }
    else if( !strcmp( psz_cmd, ""spu-delay"" ) )
    {
        input_ControlPush( p_input, INPUT_CONTROL_SET_SPU_DELAY, &newval );
    }
    return VLC_SUCCESS;
}",1,,801,6,,void
79183,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_AUDIO_DELAY, &newval );
    }",5,,806,2,,void
79190,BLOCK,-1,,<empty>,10,,809,1,,void
79196,BLOCK,-1,,"{
        input_ControlPush( p_input, INPUT_CONTROL_SET_SPU_DELAY, &newval );
    }",5,,810,2,,void
79212,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_BOOKMARK, &newval );

    return VLC_SUCCESS;
}",1,,819,6,,void
79240,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    input_ControlPush( p_input, INPUT_CONTROL_SET_RECORD_STATE, &newval );

    return VLC_SUCCESS;
}",1,,831,6,,void
79268,BLOCK,-1,,"{
    input_thread_t *p_input = (input_thread_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);
    VLC_UNUSED(newval);

    input_ControlPush( p_input, INPUT_CONTROL_SET_FRAME_NEXT, NULL );

    return VLC_SUCCESS;
}",1,,843,6,,void
79331,BLOCK,-1,,<empty>,1,,1,1,,ANY
79334,BLOCK,-1,,<empty>,,,,2,,<empty>
79343,BLOCK,-1,,<empty>,,,,6,,<empty>
79356,BLOCK,-1,,"{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    preparse_data_t *p_pre = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD ||
        ( p_pre->b_mux && newval.i_int == INPUT_EVENT_ITEM_META ) )
        vlc_sem_post( p_pre->p_sem );

    return VLC_SUCCESS;
}",1,,69,6,,void
79383,BLOCK,-1,,<empty>,9,,75,2,,void
79398,BLOCK,-1,,"{
    VLC_UNUSED(psz_cmd);
    VLC_UNUSED(oldval);
    input_thread_t *p_input = (input_thread_t *)p_this;
    vlm_t *p_vlm = libvlc_priv( p_input->obj.libvlc )->p_vlm;
    assert( p_vlm );
    vlm_media_sys_t *p_media = p_data;
    const char *psz_instance_name = NULL;

    if( newval.i_int == INPUT_EVENT_STATE )
    {
        for( int i = 0; i < p_media->i_instance; i++ )
        {
            if( p_media->instance[i]->p_input == p_input )
            {
                psz_instance_name = p_media->instance[i]->psz_name;
                break;
            }
        }
        int state = var_GetInteger(p_input, ""state"");
        vlm_SendEventMediaInstanceState( p_vlm, p_media->cfg.id, p_media->cfg.psz_name, psz_instance_name, state );

        vlc_mutex_lock( &p_vlm->lock_manage );

        if (state == PLAYING_S)
            p_vlm->i_consecutive_errors = 0;
        else if (state == ERROR_S && p_vlm->i_consecutive_errors < 6)
            p_vlm->i_consecutive_errors++;

        p_vl...",1,,83,6,,void
79436,BLOCK,-1,,"{
        for( int i = 0; i < p_media->i_instance; i++ )
        {
            if( p_media->instance[i]->p_input == p_input )
            {
                psz_instance_name = p_media->instance[i]->psz_name;
                break;
            }
        }
        int state = var_GetInteger(p_input, ""state"");
        vlm_SendEventMediaInstanceState( p_vlm, p_media->cfg.id, p_media->cfg.psz_name, psz_instance_name, state );

        vlc_mutex_lock( &p_vlm->lock_manage );

        if (state == PLAYING_S)
            p_vlm->i_consecutive_errors = 0;
        else if (state == ERROR_S && p_vlm->i_consecutive_errors < 6)
            p_vlm->i_consecutive_errors++;

        p_vlm->input_state_changed = true;
        vlc_cond_signal( &p_vlm->wait_manage );
        vlc_mutex_unlock( &p_vlm->lock_manage );
    }",5,,93,2,,void
79438,BLOCK,-1,,<empty>,9,,94,1,,void
79450,BLOCK,4,,"{
            if( p_media->instance[i]->p_input == p_input )
            {
                psz_instance_name = p_media->instance[i]->psz_name;
                break;
            }
        }",9,,95,4,,void
79461,BLOCK,-1,,"{
                psz_instance_name = p_media->instance[i]->psz_name;
                break;
            }",13,,97,2,,void
79501,BLOCK,-1,,<empty>,13,,108,2,,void
79508,BLOCK,-1,,<empty>,14,,109,1,,void
79519,BLOCK,-1,,<empty>,13,,110,2,,void
79549,BLOCK,-1,,"{
    vlm_t *p_vlm = NULL, **pp_vlm = &(libvlc_priv (p_this->obj.libvlc)->p_vlm);
    char *psz_vlmconf;

    /* Avoid multiple creation */
    vlc_mutex_lock( &vlm_mutex );

    p_vlm = *pp_vlm;
    if( p_vlm )
    {   /* VLM already exists */
        if( likely( p_vlm->users < UINT_MAX ) )
            p_vlm->users++;
        else
            p_vlm = NULL;
        vlc_mutex_unlock( &vlm_mutex );
        return p_vlm;
    }

    msg_Dbg( p_this, ""creating VLM"" );

    p_vlm = vlc_custom_create( p_this->obj.libvlc, sizeof( *p_vlm ),
                               ""vlm daemon"" );
    if( !p_vlm )
    {
        vlc_mutex_unlock( &vlm_mutex );
        return NULL;
    }

    vlc_mutex_init( &p_vlm->lock );

    vlc_mutex_init( &p_vlm->lock_delete );
    vlc_cond_init( &p_vlm->wait_delete );

    vlc_mutex_init( &p_vlm->lock_manage );
    vlc_cond_init_daytime( &p_vlm->wait_manage );
    p_vlm->users = 1;
    p_vlm->input_state_changed = false;
    p_vlm->i_id = 1;
    TAB_INIT( p_vlm->i...",1,,126,2,,void
79576,BLOCK,-1,,"{   /* VLM already exists */
        if( likely( p_vlm->users < UINT_MAX ) )
            p_vlm->users++;
        else
            p_vlm = NULL;
        vlc_mutex_unlock( &vlm_mutex );
        return p_vlm;
    }",5,,135,2,,void
79584,BLOCK,-1,,<empty>,13,,137,2,,void
79590,BLOCK,-1,,<empty>,13,,139,1,,void
79610,BLOCK,1,,<empty>,,,,3,,void
79625,BLOCK,-1,,"{
        vlc_mutex_unlock( &vlm_mutex );
        return NULL;
    }",5,,149,2,,void
79708,BLOCK,-1,,"{
        vlc_cond_destroy( &p_vlm->wait_delete );
        vlc_cond_destroy( &p_vlm->wait_manage );
        vlc_mutex_destroy( &p_vlm->lock );
        vlc_mutex_destroy( &p_vlm->lock_manage );
        vlc_mutex_destroy( &p_vlm->lock_delete );
        vlc_object_release( p_vlm );
        vlc_mutex_unlock( &vlm_mutex );
        return NULL;
    }",5,,171,2,,void
79755,BLOCK,-1,,"{
        vlm_message_t *p_message = NULL;
        char *psz_buffer = NULL;

        msg_Dbg( p_this, ""loading VLM configuration"" );
        if( asprintf(&psz_buffer, ""load %s"", psz_vlmconf ) != -1 )
        {
            msg_Dbg( p_this, ""%s"", psz_buffer );
            if( vlm_ExecuteCommand( p_vlm, psz_buffer, &p_message ) )
                msg_Warn( p_this, ""error while loading the configuration file"" );

            vlm_MessageDelete( p_message );
            free( psz_buffer );
        }
    }",5,,187,2,,void
79776,BLOCK,-1,,"{
            msg_Dbg( p_this, ""%s"", psz_buffer );
            if( vlm_ExecuteCommand( p_vlm, psz_buffer, &p_message ) )
                msg_Warn( p_this, ""error while loading the configuration file"" );

            vlm_MessageDelete( p_message );
            free( psz_buffer );
        }",9,,193,2,,void
79787,BLOCK,-1,,<empty>,17,,196,2,,void
79806,BLOCK,-1,,"{
    /* vlm_Delete() is serialized against itself, and against vlm_New().
     * This mutex protects libvlc_priv->p_vlm and p_vlm->users. */
    vlc_mutex_lock( &vlm_mutex );
    assert( p_vlm->users > 0 );
    if( --p_vlm->users == 0 )
        assert( libvlc_priv(p_vlm->obj.libvlc)->p_vlm == p_vlm );
    else
        p_vlm = NULL;

    if( p_vlm == NULL )
    {
        vlc_mutex_unlock( &vlm_mutex );
        return;
    }

    vlc_cond_signal(&p_vlm->wait_delete);

    /* Destroy and release VLM */
    vlc_mutex_lock( &p_vlm->lock );
    vlm_ControlInternal( p_vlm, VLM_CLEAR_MEDIAS );
    TAB_CLEAN( p_vlm->i_media, p_vlm->media );

    vlm_ControlInternal( p_vlm, VLM_CLEAR_SCHEDULES );
    TAB_CLEAN( p_vlm->i_schedule, p_vlm->schedule );
    vlc_mutex_unlock( &p_vlm->lock );

    vlc_cancel( p_vlm->thread );

    if( p_vlm->p_vod )
    {
        module_unneed( p_vlm->p_vod, p_vlm->p_vod->p_module );
        vlc_object_release( p_vlm->p_vod );
    }

    libvlc_priv(p_vlm->obj.libv...",1,,213,2,,void
79823,BLOCK,-1,,<empty>,9,,219,2,,void
79836,BLOCK,-1,,<empty>,9,,221,1,,void
79844,BLOCK,-1,,"{
        vlc_mutex_unlock( &vlm_mutex );
        return;
    }",5,,224,2,,void
79892,BLOCK,-1,,"{
        module_unneed( p_vlm->p_vod, p_vlm->p_vod->p_module );
        vlc_object_release( p_vlm->p_vod );
    }",5,,243,2,,void
79957,BLOCK,-1,,"{
    int i_result;

    vlc_mutex_lock( &p_vlm->lock );
    i_result = ExecuteCommand( p_vlm, psz_command, pp_message );
    vlc_mutex_unlock( &p_vlm->lock );

    return i_result;
}",1,,266,4,,void
79985,BLOCK,-1,,"{
    vlm_t *vlm = (vlm_t *)p_private;
    int i, i_ret;
    const char *psz;
    int64_t id;

    if( !p_private || !p_vod_media )
        return VLC_EGENERIC;

    vlc_mutex_lock( &vlm->lock );

    /* Find media id */
    for( i = 0, id = -1; i < vlm->i_media; i++ )
    {
        if( p_vod_media == vlm->media[i]->vod.p_media )
        {
            id = vlm->media[i]->cfg.id;
            break;
        }
    }
    if( id == -1 )
    {
        vlc_mutex_unlock( &vlm->lock );
        return VLC_EGENERIC;
    }

    switch( i_query )
    {
    case VOD_MEDIA_PLAY:
    {
        psz = (const char *)va_arg( args, const char * );
        int64_t *i_time = (int64_t *)va_arg( args, int64_t *);
        bool b_retry = false;
        if (*i_time < 0)
        {
            /* No start time requested: return the current NPT */
            i_ret = vlm_ControlInternal( vlm, VLM_GET_MEDIA_INSTANCE_TIME, id, psz_id, i_time );
            /* The instance is not running yet, it will start at 0 */
 ...",1,,281,6,,void
80002,BLOCK,-1,,<empty>,9,,288,2,,void
80011,BLOCK,-1,,<empty>,5,,293,1,,void
80027,BLOCK,4,,"{
        if( p_vod_media == vlm->media[i]->vod.p_media )
        {
            id = vlm->media[i]->cfg.id;
            break;
        }
    }",5,,294,4,,void
80040,BLOCK,-1,,"{
            id = vlm->media[i]->cfg.id;
            break;
        }",9,,296,2,,void
80058,BLOCK,-1,,"{
        vlc_mutex_unlock( &vlm->lock );
        return VLC_EGENERIC;
    }",5,,302,2,,void
80068,BLOCK,-1,,"{
    case VOD_MEDIA_PLAY:
    {
        psz = (const char *)va_arg( args, const char * );
        int64_t *i_time = (int64_t *)va_arg( args, int64_t *);
        bool b_retry = false;
        if (*i_time < 0)
        {
            /* No start time requested: return the current NPT */
            i_ret = vlm_ControlInternal( vlm, VLM_GET_MEDIA_INSTANCE_TIME, id, psz_id, i_time );
            /* The instance is not running yet, it will start at 0 */
            if (i_ret)
                *i_time = 0;
        }
        else
        {
            /* We want to seek before unpausing, but it won't
             * work if the instance is not running yet. */
            b_retry = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_TIME, id, psz_id, *i_time );
        }

        i_ret = vlm_ControlInternal( vlm, VLM_START_MEDIA_VOD_INSTANCE, id, psz_id, 0, psz );

        if (!i_ret && b_retry)
            i_ret = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_TIME, id, psz_id, *i_time );
    ...",5,,308,2,,void
80071,BLOCK,3,,"{
        psz = (const char *)va_arg( args, const char * );
        int64_t *i_time = (int64_t *)va_arg( args, int64_t *);
        bool b_retry = false;
        if (*i_time < 0)
        {
            /* No start time requested: return the current NPT */
            i_ret = vlm_ControlInternal( vlm, VLM_GET_MEDIA_INSTANCE_TIME, id, psz_id, i_time );
            /* The instance is not running yet, it will start at 0 */
            if (i_ret)
                *i_time = 0;
        }
        else
        {
            /* We want to seek before unpausing, but it won't
             * work if the instance is not running yet. */
            b_retry = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_TIME, id, psz_id, *i_time );
        }

        i_ret = vlm_ControlInternal( vlm, VLM_START_MEDIA_VOD_INSTANCE, id, psz_id, 0, psz );

        if (!i_ret && b_retry)
            i_ret = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_TIME, id, psz_id, *i_time );
        break;
    }",5,,310,3,,void
80083,BLOCK,-1,,"{
            /* No start time requested: return the current NPT */
            i_ret = vlm_ControlInternal( vlm, VLM_GET_MEDIA_INSTANCE_TIME, id, psz_id, i_time );
            /* The instance is not running yet, it will start at 0 */
            if (i_ret)
                *i_time = 0;
        }",9,,315,2,,void
80094,BLOCK,-1,,<empty>,17,,320,2,,void
80100,BLOCK,-1,,"{
            /* We want to seek before unpausing, but it won't
             * work if the instance is not running yet. */
            b_retry = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_TIME, id, psz_id, *i_time );
        }",9,,323,1,,void
80124,BLOCK,-1,,<empty>,13,,332,2,,void
80137,BLOCK,6,,"{
        int64_t *i_time = (int64_t *)va_arg( args, int64_t *);
        i_ret = vlm_ControlInternal( vlm, VLM_PAUSE_MEDIA_INSTANCE, id, psz_id );
        if (!i_ret)
            i_ret = vlm_ControlInternal( vlm, VLM_GET_MEDIA_INSTANCE_TIME, id, psz_id, i_time );
        break;
    }",5,,337,6,,void
80149,BLOCK,-1,,<empty>,13,,341,2,,void
80171,BLOCK,13,,"{
        int64_t i_time = (int64_t)va_arg( args, int64_t );
        i_ret = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_TIME, id, psz_id, i_time );
        break;
    }",5,,350,13,,void
80191,BLOCK,16,,"{
        double d_scale = (double)va_arg( args, double );
        double d_position;

        vlm_ControlInternal( vlm, VLM_GET_MEDIA_INSTANCE_POSITION, id, psz_id, &d_position );
        d_position -= (d_scale / 1000.0);
        if( d_position < 0.0 )
            d_position = 0.0;
        i_ret = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_POSITION, id, psz_id, d_position );
        break;
    }",5,,357,16,,void
80210,BLOCK,-1,,<empty>,13,,364,2,,void
80225,BLOCK,19,,"{
        double d_scale = (double)va_arg( args, double );
        double d_position;

        vlm_ControlInternal( vlm, VLM_GET_MEDIA_INSTANCE_POSITION, id, psz_id, &d_position );
        d_position += (d_scale / 1000.0);
        if( d_position > 1.0 )
            d_position = 1.0;
        i_ret = vlm_ControlInternal( vlm, VLM_SET_MEDIA_INSTANCE_POSITION, id, psz_id, d_position );
        break;
    }",5,,370,19,,void
80244,BLOCK,-1,,<empty>,13,,377,2,,void
80273,BLOCK,-1,,"{
    vlm_t *vlm = (vlm_t*)p_object;
    time_t lastcheck, now, nextschedule = 0;

    time(&lastcheck);

    for( ;; )
    {
        char **ppsz_scheduled_commands = NULL;
        int    i_scheduled_commands = 0;
        bool scheduled_command = false;

        vlc_mutex_lock( &vlm->lock_manage );
        mutex_cleanup_push( &vlm->lock_manage );
        while( !vlm->input_state_changed && !scheduled_command )
        {
            if( nextschedule != 0 )
                scheduled_command = vlc_cond_timedwait_daytime( &vlm->wait_manage, &vlm->lock_manage, nextschedule ) != 0;
            else
                vlc_cond_wait( &vlm->wait_manage, &vlm->lock_manage );
        }
        vlm->input_state_changed = false;
        vlc_cleanup_pop( );
        vlc_mutex_unlock( &vlm->lock_manage );

        int canc = vlc_savecancel ();
        /* destroy the inputs that wants to die, and launch the next input */
        vlc_mutex_lock( &vlm->lock );
        for( int i = 0; i < vlm->i_media; i+...",1,,397,2,,void
80290,BLOCK,-1,,<empty>,5,,403,1,,void
80291,BLOCK,4,,"{
        char **ppsz_scheduled_commands = NULL;
        int    i_scheduled_commands = 0;
        bool scheduled_command = false;

        vlc_mutex_lock( &vlm->lock_manage );
        mutex_cleanup_push( &vlm->lock_manage );
        while( !vlm->input_state_changed && !scheduled_command )
        {
            if( nextschedule != 0 )
                scheduled_command = vlc_cond_timedwait_daytime( &vlm->wait_manage, &vlm->lock_manage, nextschedule ) != 0;
            else
                vlc_cond_wait( &vlm->wait_manage, &vlm->lock_manage );
        }
        vlm->input_state_changed = false;
        vlc_cleanup_pop( );
        vlc_mutex_unlock( &vlm->lock_manage );

        int canc = vlc_savecancel ();
        /* destroy the inputs that wants to die, and launch the next input */
        vlc_mutex_lock( &vlm->lock );
        for( int i = 0; i < vlm->i_media; i++ )
        {
            vlm_media_sys_t *p_media = vlm->media[i];

            for( int j = 0; j < p_media->i_instance; )
...",5,,404,4,,void
80322,BLOCK,-1,,"{
            if( nextschedule != 0 )
                scheduled_command = vlc_cond_timedwait_daytime( &vlm->wait_manage, &vlm->lock_manage, nextschedule ) != 0;
            else
                vlc_cond_wait( &vlm->wait_manage, &vlm->lock_manage );
        }",9,,412,2,,void
80327,BLOCK,-1,,<empty>,17,,414,2,,void
80343,BLOCK,-1,,<empty>,17,,416,1,,void
80374,BLOCK,-1,,<empty>,9,,425,1,,void
80386,BLOCK,4,,"{
            vlm_media_sys_t *p_media = vlm->media[i];

            for( int j = 0; j < p_media->i_instance; )
            {
                vlm_media_instance_sys_t *p_instance = p_media->instance[j];
                int state = INIT_S;

                if( p_instance->p_input != NULL )
                    state = var_GetInteger( p_instance->p_input, ""state"" );
                if( state == END_S || state == ERROR_S )
                {
                    int i_new_input_index;

                    /* */
                    i_new_input_index = p_instance->i_index + 1;
                    if( !p_media->cfg.b_vod && p_media->cfg.broadcast.b_loop && i_new_input_index >= p_media->cfg.i_input )
                        i_new_input_index = 0;

                    /* FIXME implement multiple input with VOD */
                    if( p_media->cfg.b_vod || i_new_input_index >= p_media->cfg.i_input )
                        vlm_ControlInternal( vlm, VLM_STOP_MEDIA_INSTANCE, p_media->cfg.id, p...",9,,426,4,,void
80396,BLOCK,-1,,<empty>,13,,429,1,,void
80406,BLOCK,4,,"{
                vlm_media_instance_sys_t *p_instance = p_media->instance[j];
                int state = INIT_S;

                if( p_instance->p_input != NULL )
                    state = var_GetInteger( p_instance->p_input, ""state"" );
                if( state == END_S || state == ERROR_S )
                {
                    int i_new_input_index;

                    /* */
                    i_new_input_index = p_instance->i_index + 1;
                    if( !p_media->cfg.b_vod && p_media->cfg.broadcast.b_loop && i_new_input_index >= p_media->cfg.i_input )
                        i_new_input_index = 0;

                    /* FIXME implement multiple input with VOD */
                    if( p_media->cfg.b_vod || i_new_input_index >= p_media->cfg.i_input )
                        vlm_ControlInternal( vlm, VLM_STOP_MEDIA_INSTANCE, p_media->cfg.id, p_instance->psz_name );
                    else
                        vlm_ControlInternal( vlm, VLM_START_MEDIA_BROADCAST_...",13,,430,4,,void
80425,BLOCK,-1,,<empty>,21,,435,2,,void
80441,BLOCK,-1,,"{
                    int i_new_input_index;

                    /* */
                    i_new_input_index = p_instance->i_index + 1;
                    if( !p_media->cfg.b_vod && p_media->cfg.broadcast.b_loop && i_new_input_index >= p_media->cfg.i_input )
                        i_new_input_index = 0;

                    /* FIXME implement multiple input with VOD */
                    if( p_media->cfg.b_vod || i_new_input_index >= p_media->cfg.i_input )
                        vlm_ControlInternal( vlm, VLM_STOP_MEDIA_INSTANCE, p_media->cfg.id, p_instance->psz_name );
                    else
                        vlm_ControlInternal( vlm, VLM_START_MEDIA_BROADCAST_INSTANCE, p_media->cfg.id, p_instance->psz_name, i_new_input_index );

                    j = 0;
                }",17,,437,2,,void
80473,BLOCK,-1,,<empty>,25,,443,2,,void
80491,BLOCK,-1,,<empty>,25,,447,2,,void
80504,BLOCK,-1,,<empty>,25,,449,1,,void
80521,BLOCK,-1,,"{
                    j++;
                }",17,,454,1,,void
80531,BLOCK,-1,,<empty>,9,,464,1,,void
80543,BLOCK,4,,"{
            time_t real_date = vlm->schedule[i]->date;

            if( vlm->schedule[i]->b_enabled )
            {
                bool b_now = false;
                if( vlm->schedule[i]->date == 0 ) // now !
                {
                    vlm->schedule[i]->date = now;
                    real_date = now;
                    b_now = true;
                }
                else if( vlm->schedule[i]->period != 0 )
                {
                    int j = 0;
                    while( ((vlm->schedule[i]->date + j *
                             vlm->schedule[i]->period) <= lastcheck) &&
                           ( vlm->schedule[i]->i_repeat > j ||
                             vlm->schedule[i]->i_repeat < 0 ) )
                    {
                        j++;
                    }

                    real_date = vlm->schedule[i]->date + j *
                        vlm->schedule[i]->period;
                }

                if( real_date <= now )
                {
   ...",9,,465,4,,void
80562,BLOCK,-1,,"{
                bool b_now = false;
                if( vlm->schedule[i]->date == 0 ) // now !
                {
                    vlm->schedule[i]->date = now;
                    real_date = now;
                    b_now = true;
                }
                else if( vlm->schedule[i]->period != 0 )
                {
                    int j = 0;
                    while( ((vlm->schedule[i]->date + j *
                             vlm->schedule[i]->period) <= lastcheck) &&
                           ( vlm->schedule[i]->i_repeat > j ||
                             vlm->schedule[i]->i_repeat < 0 ) )
                    {
                        j++;
                    }

                    real_date = vlm->schedule[i]->date + j *
                        vlm->schedule[i]->period;
                }

                if( real_date <= now )
                {
                    if( real_date > lastcheck || b_now )
                    {
                        for( int j = 0; ...",13,,469,2,,void
80577,BLOCK,-1,,"{
                    vlm->schedule[i]->date = now;
                    real_date = now;
                    b_now = true;
                }",17,,472,2,,void
80594,BLOCK,-1,,<empty>,22,,477,1,,void
80605,BLOCK,-1,,"{
                    int j = 0;
                    while( ((vlm->schedule[i]->date + j *
                             vlm->schedule[i]->period) <= lastcheck) &&
                           ( vlm->schedule[i]->i_repeat > j ||
                             vlm->schedule[i]->i_repeat < 0 ) )
                    {
                        j++;
                    }

                    real_date = vlm->schedule[i]->date + j *
                        vlm->schedule[i]->period;
                }",17,,478,2,,void
80650,BLOCK,-1,,"{
                        j++;
                    }",21,,484,2,,void
80676,BLOCK,-1,,"{
                    if( real_date > lastcheck || b_now )
                    {
                        for( int j = 0; j < vlm->schedule[i]->i_command; j++ )
                        {
                            TAB_APPEND( i_scheduled_commands,
                                        ppsz_scheduled_commands,
                                        strdup(vlm->schedule[i]->command[j] ) );
                        }
                    }
                }",17,,493,2,,void
80683,BLOCK,-1,,"{
                        for( int j = 0; j < vlm->schedule[i]->i_command; j++ )
                        {
                            TAB_APPEND( i_scheduled_commands,
                                        ppsz_scheduled_commands,
                                        strdup(vlm->schedule[i]->command[j] ) );
                        }
                    }",21,,495,2,,void
80685,BLOCK,-1,,<empty>,25,,496,1,,void
80701,BLOCK,4,,"{
                            TAB_APPEND( i_scheduled_commands,
                                        ppsz_scheduled_commands,
                                        strdup(vlm->schedule[i]->command[j] ) );
                        }",25,,497,4,,void
80716,BLOCK,-1,,<empty>,22,,504,1,,void
80725,BLOCK,-1,,"{
                    nextschedule = real_date;
                }",17,,505,2,,void
80731,BLOCK,-1,,"{
            vlm_message_t *message = NULL;
            char *psz_command = ppsz_scheduled_commands[0];
            ExecuteCommand( vlm, psz_command,&message );

            /* for now, drop the message */
            vlm_MessageDelete( message );
            TAB_REMOVE( i_scheduled_commands,
                        ppsz_scheduled_commands,
                        psz_command );
            free( psz_command );
        }",9,,512,2,,void
80772,BLOCK,-1,,"{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == id )
            return p_vlm->media[i];
    }
    return NULL;
}",1,,555,3,,void
80774,BLOCK,-1,,<empty>,5,,556,1,,void
80786,BLOCK,4,,"{
        if( p_vlm->media[i]->cfg.id == id )
            return p_vlm->media[i];
    }",5,,557,4,,void
80799,BLOCK,-1,,<empty>,13,,559,2,,void
80813,BLOCK,-1,,"{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, psz_name ) )
            return p_vlm->media[i];
    }
    return NULL;
}",1,,564,3,,void
80815,BLOCK,-1,,<empty>,5,,565,1,,void
80827,BLOCK,4,,"{
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, psz_name ) )
            return p_vlm->media[i];
    }",5,,566,4,,void
80841,BLOCK,-1,,<empty>,13,,568,2,,void
80855,BLOCK,-1,,"{
    if( !p_cfg || !p_cfg->psz_name ||
        !strcmp( p_cfg->psz_name, ""all"" ) || !strcmp( p_cfg->psz_name, ""media"" ) || !strcmp( p_cfg->psz_name, ""schedule"" ) )
        return VLC_EGENERIC;

    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == p_cfg->id )
            continue;
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, p_cfg->psz_name ) )
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",1,,573,3,,void
80885,BLOCK,-1,,<empty>,9,,576,2,,void
80889,BLOCK,-1,,<empty>,5,,578,1,,void
80901,BLOCK,4,,"{
        if( p_vlm->media[i]->cfg.id == p_cfg->id )
            continue;
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, p_cfg->psz_name ) )
            return VLC_EGENERIC;
    }",5,,579,4,,void
80916,BLOCK,-1,,<empty>,13,,581,2,,void
80933,BLOCK,-1,,<empty>,13,,583,2,,void
80943,BLOCK,-1,,"{
    vlm_media_t *p_cfg = &p_media->cfg;
    /* Check if we need to create/delete a vod media */
    if( p_cfg->b_vod && p_vlm->p_vod )
    {
        if( !p_cfg->b_enabled && p_media->vod.p_media )
        {
            p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );
            p_media->vod.p_media = NULL;
        }
        else if( p_cfg->b_enabled && !p_media->vod.p_media && p_cfg->i_input )
        {
            /* Pre-parse the input */
            input_thread_t *p_input;
            char *psz_output;
            char *psz_header;
            char *psz_dup;

            input_item_Release( p_media->vod.p_item );

            if( strstr( p_cfg->ppsz_input[0], ""://"" ) == NULL )
            {
                char *psz_uri = vlc_path2uri( p_cfg->ppsz_input[0], NULL );
                p_media->vod.p_item = input_item_New( psz_uri,
                                                      p_cfg->psz_name );
                free( psz_uri );
            }
            el...",1,,591,3,,void
80959,BLOCK,-1,,"{
        if( !p_cfg->b_enabled && p_media->vod.p_media )
        {
            p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );
            p_media->vod.p_media = NULL;
        }
        else if( p_cfg->b_enabled && !p_media->vod.p_media && p_cfg->i_input )
        {
            /* Pre-parse the input */
            input_thread_t *p_input;
            char *psz_output;
            char *psz_header;
            char *psz_dup;

            input_item_Release( p_media->vod.p_item );

            if( strstr( p_cfg->ppsz_input[0], ""://"" ) == NULL )
            {
                char *psz_uri = vlc_path2uri( p_cfg->ppsz_input[0], NULL );
                p_media->vod.p_item = input_item_New( psz_uri,
                                                      p_cfg->psz_name );
                free( psz_uri );
            }
            else
                p_media->vod.p_item = input_item_New( p_cfg->ppsz_input[0],
                                                      p_cfg->p...",5,,595,2,,void
80971,BLOCK,-1,,"{
            p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );
            p_media->vod.p_media = NULL;
        }",9,,597,2,,void
80994,BLOCK,-1,,<empty>,14,,601,1,,void
81010,BLOCK,-1,,"{
            /* Pre-parse the input */
            input_thread_t *p_input;
            char *psz_output;
            char *psz_header;
            char *psz_dup;

            input_item_Release( p_media->vod.p_item );

            if( strstr( p_cfg->ppsz_input[0], ""://"" ) == NULL )
            {
                char *psz_uri = vlc_path2uri( p_cfg->ppsz_input[0], NULL );
                p_media->vod.p_item = input_item_New( psz_uri,
                                                      p_cfg->psz_name );
                free( psz_uri );
            }
            else
                p_media->vod.p_item = input_item_New( p_cfg->ppsz_input[0],
                                                      p_cfg->psz_name );

            if( p_cfg->psz_output )
            {
                if( asprintf( &psz_output, ""%s:description"", p_cfg->psz_output )  == -1 )
                    psz_output = NULL;
            }
            else
                psz_output = strdup( ""#description"" );

      ...",9,,602,2,,void
81031,BLOCK,-1,,"{
                char *psz_uri = vlc_path2uri( p_cfg->ppsz_input[0], NULL );
                p_media->vod.p_item = input_item_New( psz_uri,
                                                      p_cfg->psz_name );
                free( psz_uri );
            }",13,,612,2,,void
81056,BLOCK,-1,,<empty>,17,,619,1,,void
81076,BLOCK,-1,,"{
                if( asprintf( &psz_output, ""%s:description"", p_cfg->psz_output )  == -1 )
                    psz_output = NULL;
            }",13,,623,2,,void
81088,BLOCK,-1,,<empty>,21,,625,2,,void
81093,BLOCK,-1,,<empty>,17,,628,1,,void
81109,BLOCK,-1,,"{
                input_item_AddOption( p_media->vod.p_item, psz_dup, VLC_INPUT_OPTION_TRUSTED );
                free( psz_dup );
            }",13,,631,2,,void
81123,BLOCK,-1,,<empty>,13,,637,1,,void
81159,BLOCK,-1,,<empty>,17,,642,2,,void
81187,BLOCK,-1,,"{
                vlc_sem_t sem_preparse;
                vlc_sem_init( &sem_preparse, 0 );

                preparse_data_t preparse = { .p_sem = &sem_preparse,
                                    .b_mux = (p_cfg->vod.psz_mux != NULL) };
                var_AddCallback( p_input, ""intf-event"", InputEventPreparse,
                                 &preparse );

                data.sem = &sem_preparse;
                var_Create( p_input, ""sout-description-data"", VLC_VAR_ADDRESS );
                var_SetAddress( p_input, ""sout-description-data"", &data );

                if( !input_Start( p_input ) )
                    vlc_sem_wait( &sem_preparse );

                var_DelCallback( p_input, ""intf-event"", InputEventPreparse,
                                 &preparse );

                input_Stop( p_input );
                input_Close( p_input );
                vlc_sem_destroy( &sem_preparse );
            }",13,,649,2,,void
81197,BLOCK,1,,<empty>,46,,653,1,,void
81202,BLOCK,2,,<empty>,37,,654,2,,void
81237,BLOCK,-1,,<empty>,21,,663,2,,void
81277,BLOCK,-1,,"{
                const char *psz_mux;
                if (!strcmp(p_cfg->vod.psz_mux, ""ps""))
                    psz_mux = ""mp2p"";
                else if (!strcmp(p_cfg->vod.psz_mux, ""ts""))
                    psz_mux = ""mp2t"";
                else
                    psz_mux = p_cfg->vod.psz_mux;

                union {
                    char text[5];
                    unsigned char utext[5];
                    uint32_t value;
                } fourcc;

                sprintf( fourcc.text, ""%4.4s"", psz_mux );
                for( int i = 0; i < 4; i++ )
                    fourcc.utext[i] = tolower(fourcc.utext[i]);

                item.i_es = 1;
                item.es = &p_es;
                es_format_Init( &es, VIDEO_ES, fourcc.value );
            }",13,,678,2,,void
81288,BLOCK,-1,,<empty>,21,,681,2,,void
81293,BLOCK,-1,,<empty>,22,,682,1,,void
81303,BLOCK,-1,,<empty>,21,,683,2,,void
81308,BLOCK,-1,,<empty>,21,,685,1,,void
81324,BLOCK,-1,,<empty>,17,,694,1,,void
81365,BLOCK,-1,,"{
                item.i_es = data.i_es;
                item.es = data.es;
            }",13,,702,1,,void
81408,BLOCK,-1,,<empty>,10,,712,1,,void
81413,BLOCK,-1,,<empty>,9,,713,2,,void
81418,BLOCK,-1,,"{
        /* TODO start media if needed */
    }",5,,715,1,,void
81434,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, p_cfg->id );

    /* */
    if( !p_media || vlm_MediaDescriptionCheck( p_vlm, p_cfg ) )
        return VLC_EGENERIC;
    if( ( p_media->cfg.b_vod && !p_cfg->b_vod ) || ( !p_media->cfg.b_vod && p_cfg->b_vod ) )
        return VLC_EGENERIC;

    if( 0 )
    {
        /* TODO check what are the changes being done (stop instance if needed) */
    }

    vlm_media_Clean( &p_media->cfg );
    vlm_media_Copy( &p_media->cfg, p_cfg );

    return vlm_OnMediaUpdate( p_vlm, p_media );
}",1,,725,3,,void
81450,BLOCK,-1,,<empty>,9,,730,2,,void
81475,BLOCK,-1,,<empty>,9,,732,2,,void
81480,BLOCK,-1,,"{
        /* TODO check what are the changes being done (stop instance if needed) */
    }",5,,735,2,,void
81502,BLOCK,-1,,"{
    vlm_media_sys_t *p_media;

    if( vlm_MediaDescriptionCheck( p_vlm, p_cfg ) || vlm_ControlMediaGetByName( p_vlm, p_cfg->psz_name ) )
    {
        msg_Err( p_vlm, ""invalid media description"" );
        return VLC_EGENERIC;
    }
    /* Check if we need to load the VOD server */
    if( p_cfg->b_vod && !p_vlm->p_vod )
    {
        msg_Info( p_vlm, ""VoD support will be removed from the VLM in the next major version of VLC."" );

        p_vlm->p_vod = vlc_custom_create( VLC_OBJECT(p_vlm), sizeof( vod_t ),
                                          ""vod server"" );
        p_vlm->p_vod->p_module = module_need( p_vlm->p_vod, ""vod server"", ""$vod-server"", false );
        if( !p_vlm->p_vod->p_module )
        {
            msg_Err( p_vlm, ""cannot find vod server"" );
            vlc_object_release( p_vlm->p_vod );
            p_vlm->p_vod = NULL;
            return VLC_EGENERIC;
        }

        p_vlm->p_vod->p_data = p_vlm;
        p_vlm->p_vod->pf_media_control = vlm_MediaVodContr...",1,,746,4,,void
81514,BLOCK,-1,,"{
        msg_Err( p_vlm, ""invalid media description"" );
        return VLC_EGENERIC;
    }",5,,750,2,,void
81529,BLOCK,-1,,"{
        msg_Info( p_vlm, ""VoD support will be removed from the VLM in the next major version of VLC."" );

        p_vlm->p_vod = vlc_custom_create( VLC_OBJECT(p_vlm), sizeof( vod_t ),
                                          ""vod server"" );
        p_vlm->p_vod->p_module = module_need( p_vlm->p_vod, ""vod server"", ""$vod-server"", false );
        if( !p_vlm->p_vod->p_module )
        {
            msg_Err( p_vlm, ""cannot find vod server"" );
            vlc_object_release( p_vlm->p_vod );
            p_vlm->p_vod = NULL;
            return VLC_EGENERIC;
        }

        p_vlm->p_vod->p_data = p_vlm;
        p_vlm->p_vod->pf_media_control = vlm_MediaVodControl;
    }",5,,756,2,,void
81540,BLOCK,1,,<empty>,,,,2,,void
81568,BLOCK,-1,,"{
            msg_Err( p_vlm, ""cannot find vod server"" );
            vlc_object_release( p_vlm->p_vod );
            p_vlm->p_vod = NULL;
            return VLC_EGENERIC;
        }",9,,763,2,,void
81606,BLOCK,-1,,<empty>,9,,776,2,,void
81658,BLOCK,-1,,<empty>,9,,791,2,,void
81688,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlInternal( p_vlm, VLM_STOP_MEDIA_INSTANCE, id, p_media->instance[0]->psz_name );

    if( p_media->cfg.b_vod )
    {
        p_media->cfg.b_enabled = false;
        vlm_OnMediaUpdate( p_vlm, p_media );
    }

    /* */
    vlm_SendEventMediaRemoved( p_vlm, id, p_media->cfg.psz_name );

    vlm_media_Clean( &p_media->cfg );

    input_item_Release( p_media->vod.p_item );

    if( p_media->vod.p_media )
        p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );

    TAB_REMOVE( p_vlm->i_media, p_vlm->media, p_media );
    free( p_media );

    return VLC_SUCCESS;
}",1,,799,3,,void
81698,BLOCK,-1,,<empty>,9,,803,2,,void
81724,BLOCK,-1,,"{
        p_media->cfg.b_enabled = false;
        vlm_OnMediaUpdate( p_vlm, p_media );
    }",5,,809,2,,void
81760,BLOCK,-1,,<empty>,9,,822,2,,void
81793,BLOCK,-1,,"{
    vlm_media_t **pp_dsc;
    int                     i_dsc;

    TAB_INIT( i_dsc, pp_dsc );
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        vlm_media_t *p_dsc = vlm_media_Duplicate( &p_vlm->media[i]->cfg );
        TAB_APPEND( i_dsc, pp_dsc, p_dsc );
    }

    *ppp_dsc = pp_dsc;
    *pi_dsc = i_dsc;

    return VLC_SUCCESS;
}",1,,831,4,,void
81800,BLOCK,-1,,<empty>,5,,836,1,,void
81812,BLOCK,4,,"{
        vlm_media_t *p_dsc = vlm_media_Duplicate( &p_vlm->media[i]->cfg );
        TAB_APPEND( i_dsc, pp_dsc, p_dsc );
    }",5,,837,4,,void
81843,BLOCK,-1,,"{
    while( p_vlm->i_media > 0 )
        vlm_ControlMediaDel( p_vlm, p_vlm->media[0]->cfg.id );

    return VLC_SUCCESS;
}",1,,848,2,,void
81869,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    if( !p_media )
        return VLC_EGENERIC;

    *pp_dsc = vlm_media_Duplicate( &p_media->cfg );
    return VLC_SUCCESS;
}",1,,855,4,,void
81879,BLOCK,-1,,<empty>,9,,858,2,,void
81898,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetByName( p_vlm, psz_name );
    if( !p_media )
        return VLC_EGENERIC;

    *p_id = p_media->cfg.id;
    return VLC_SUCCESS;
}",1,,864,4,,void
81908,BLOCK,-1,,<empty>,9,,867,2,,void
81926,BLOCK,-1,,"{
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        const char *psz = p_media->instance[i]->psz_name;
        if( ( psz == NULL && psz_id == NULL ) ||
            ( psz && psz_id && !strcmp( psz, psz_id ) ) )
            return p_media->instance[i];
    }
    return NULL;
}",1,,874,3,,void
81928,BLOCK,-1,,<empty>,5,,875,1,,void
81940,BLOCK,4,,"{
        const char *psz = p_media->instance[i]->psz_name;
        if( ( psz == NULL && psz_id == NULL ) ||
            ( psz && psz_id && !strcmp( psz, psz_id ) ) )
            return p_media->instance[i];
    }",5,,876,4,,void
81968,BLOCK,-1,,<empty>,13,,880,2,,void
81982,BLOCK,-1,,"{
    vlm_media_instance_sys_t *p_instance = calloc( 1, sizeof(vlm_media_instance_sys_t) );
    if( !p_instance )
        return NULL;

    p_instance->psz_name = NULL;
    if( psz_name )
        p_instance->psz_name = strdup( psz_name );

    p_instance->p_item = input_item_New( NULL, NULL );

    p_instance->i_index = 0;
    p_instance->b_sout_keep = false;
    p_instance->p_parent = vlc_object_create( p_vlm, sizeof (vlc_object_t) );
    p_instance->p_input = NULL;
    p_instance->p_input_resource = input_resource_New( p_instance->p_parent );

    return p_instance;
}",1,,885,3,,void
81993,BLOCK,-1,,<empty>,9,,888,2,,void
82003,BLOCK,-1,,<empty>,9,,892,2,,void
82057,BLOCK,-1,,"{
    input_thread_t *p_input = p_instance->p_input;
    if( p_input )
    {
        input_Stop( p_input );
        input_Close( p_input );

        vlm_SendEventMediaInstanceStopped( p_vlm, id, p_media->cfg.psz_name );
    }
    input_resource_Terminate( p_instance->p_input_resource );
    input_resource_Release( p_instance->p_input_resource );
    vlc_object_release( p_instance->p_parent );

    TAB_REMOVE( p_media->i_instance, p_media->instance, p_instance );
    input_item_Release( p_instance->p_item );
    free( p_instance->psz_name );
    free( p_instance );
}",1,,905,5,,void
82066,BLOCK,-1,,"{
        input_Stop( p_input );
        input_Close( p_input );

        vlm_SendEventMediaInstanceStopped( p_vlm, id, p_media->cfg.psz_name );
    }",5,,908,2,,void
82117,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    char *psz_log;

    if( !p_media || !p_media->cfg.b_enabled || p_media->cfg.i_input <= 0 )
        return VLC_EGENERIC;

    /* TODO support multiple input for VOD with sout-keep ? */

    if( ( p_media->cfg.b_vod && !psz_vod_output ) || ( !p_media->cfg.b_vod && psz_vod_output ) )
        return VLC_EGENERIC;

    if( i_input_index < 0 || i_input_index >= p_media->cfg.i_input )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
    {
        vlm_media_t *p_cfg = &p_media->cfg;

        p_instance = vlm_MediaInstanceNew( p_vlm, psz_id );
        if( !p_instance )
            return VLC_ENOMEM;

        if ( p_cfg->b_vod )
        {
            var_Create( p_instance->p_parent, ""vod-media"", VLC_VAR_ADDRESS );
            var_SetAddress( p_instance->p_parent, ""vod-media"",
                            ...",1,,926,6,,void
82144,BLOCK,-1,,<empty>,9,,932,2,,void
82165,BLOCK,-1,,<empty>,9,,937,2,,void
82180,BLOCK,-1,,<empty>,9,,940,2,,void
82191,BLOCK,-1,,"{
        vlm_media_t *p_cfg = &p_media->cfg;

        p_instance = vlm_MediaInstanceNew( p_vlm, psz_id );
        if( !p_instance )
            return VLC_ENOMEM;

        if ( p_cfg->b_vod )
        {
            var_Create( p_instance->p_parent, ""vod-media"", VLC_VAR_ADDRESS );
            var_SetAddress( p_instance->p_parent, ""vod-media"",
                            p_media->vod.p_media );
            var_Create( p_instance->p_parent, ""vod-session"", VLC_VAR_STRING );
            var_SetString( p_instance->p_parent, ""vod-session"", psz_id );
        }

        if( p_cfg->psz_output != NULL || psz_vod_output != NULL )
        {
            char *psz_buffer;
            if( asprintf( &psz_buffer, ""sout=%s%s%s"",
                      p_cfg->psz_output ? p_cfg->psz_output : """",
                      (p_cfg->psz_output && psz_vod_output) ? "":"" : psz_vod_output ? ""#"" : """",
                      psz_vod_output ? psz_vod_output : """" ) != -1 )
            {
                input_item_AddOpt...",5,,944,2,,void
82207,BLOCK,-1,,<empty>,13,,949,2,,void
82214,BLOCK,-1,,"{
            var_Create( p_instance->p_parent, ""vod-media"", VLC_VAR_ADDRESS );
            var_SetAddress( p_instance->p_parent, ""vod-media"",
                            p_media->vod.p_media );
            var_Create( p_instance->p_parent, ""vod-session"", VLC_VAR_STRING );
            var_SetString( p_instance->p_parent, ""vod-session"", psz_id );
        }",9,,952,2,,void
82253,BLOCK,-1,,"{
            char *psz_buffer;
            if( asprintf( &psz_buffer, ""sout=%s%s%s"",
                      p_cfg->psz_output ? p_cfg->psz_output : """",
                      (p_cfg->psz_output && psz_vod_output) ? "":"" : psz_vod_output ? ""#"" : """",
                      psz_vod_output ? psz_vod_output : """" ) != -1 )
            {
                input_item_AddOption( p_instance->p_item, psz_buffer, VLC_INPUT_OPTION_TRUSTED );
                free( psz_buffer );
            }
        }",9,,961,2,,void
82286,BLOCK,-1,,"{
                input_item_AddOption( p_instance->p_item, psz_buffer, VLC_INPUT_OPTION_TRUSTED );
                free( psz_buffer );
            }",13,,967,2,,void
82296,BLOCK,-1,,<empty>,9,,973,1,,void
82308,BLOCK,4,,"{
            if( !strcmp( p_cfg->ppsz_option[i], ""sout-keep"" ) )
                p_instance->b_sout_keep = true;
            else if( !strcmp( p_cfg->ppsz_option[i], ""nosout-keep"" ) || !strcmp( p_cfg->ppsz_option[i], ""no-sout-keep"" ) )
                p_instance->b_sout_keep = false;
            else
                input_item_AddOption( p_instance->p_item, p_cfg->ppsz_option[i], VLC_INPUT_OPTION_TRUSTED );
        }",9,,974,4,,void
82318,BLOCK,-1,,<empty>,17,,976,2,,void
82325,BLOCK,-1,,<empty>,18,,977,1,,void
82344,BLOCK,-1,,<empty>,17,,978,2,,void
82351,BLOCK,-1,,<empty>,17,,980,1,,void
82378,BLOCK,-1,,"{
        int state = var_GetInteger( p_input, ""state"" );
        if( p_instance->i_index == i_input_index &&
                state != END_S && state != ERROR_S)
        {
            if( state == PAUSE_S )
                var_SetInteger( p_input, ""state"",  PLAYING_S );
            return VLC_SUCCESS;
        }

        input_Stop( p_input );
        input_Close( p_input );

        if( !p_instance->b_sout_keep )
            input_resource_TerminateSout( p_instance->p_input_resource );
        input_resource_TerminateVout( p_instance->p_input_resource );

        vlm_SendEventMediaInstanceStopped( p_vlm, id, p_media->cfg.psz_name );
    }",5,,988,2,,void
82399,BLOCK,-1,,"{
            if( state == PAUSE_S )
                var_SetInteger( p_input, ""state"",  PLAYING_S );
            return VLC_SUCCESS;
        }",9,,992,2,,void
82404,BLOCK,-1,,<empty>,17,,994,2,,void
82420,BLOCK,-1,,<empty>,13,,1002,2,,void
82456,BLOCK,-1,,"{
        char *psz_uri = vlc_path2uri(
                          p_media->cfg.ppsz_input[p_instance->i_index], NULL );
        input_item_SetURI( p_instance->p_item, psz_uri ) ;
        free( psz_uri );
    }",5,,1011,2,,void
82479,BLOCK,-1,,<empty>,9,,1018,1,,void
82507,BLOCK,-1,,"{
        p_instance->p_input = input_Create( p_instance->p_parent,
                                            p_instance->p_item, psz_log,
                                            p_instance->p_input_resource,
                                            NULL );
        if( p_instance->p_input )
        {
            var_AddCallback( p_instance->p_input, ""intf-event"", InputEvent, p_media );

            if (p_vlm->i_consecutive_errors)
            {
                int slowdown = 1 << (p_vlm->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */

                /* like a sleep, but interrupted on deletion */
                vlc_mutex_lock(&p_vlm->lock_delete);
                vlc_cond_timedwait(&p_vlm->wait_delete, &p_vlm->lock_delete, deadline);
                vlc_mutex_unlock(&p_vlm->lock_delete);
            }

            if( input_Start( p_instance->p_input ) != ...",5,,1021,2,,void
82528,BLOCK,-1,,"{
            var_AddCallback( p_instance->p_input, ""intf-event"", InputEvent, p_media );

            if (p_vlm->i_consecutive_errors)
            {
                int slowdown = 1 << (p_vlm->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */

                /* like a sleep, but interrupted on deletion */
                vlc_mutex_lock(&p_vlm->lock_delete);
                vlc_cond_timedwait(&p_vlm->wait_delete, &p_vlm->lock_delete, deadline);
                vlc_mutex_unlock(&p_vlm->lock_delete);
            }

            if( input_Start( p_instance->p_input ) != VLC_SUCCESS )
            {
                var_DelCallback( p_instance->p_input, ""intf-event"", InputEvent, p_media );
                input_Close( p_instance->p_input );
                p_instance->p_input = NULL;
            }
        }",9,,1027,2,,void
82540,BLOCK,-1,,"{
                int slowdown = 1 << (p_vlm->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */

                /* like a sleep, but interrupted on deletion */
                vlc_mutex_lock(&p_vlm->lock_delete);
                vlc_cond_timedwait(&p_vlm->wait_delete, &p_vlm->lock_delete, deadline);
                vlc_mutex_unlock(&p_vlm->lock_delete);
            }",13,,1031,2,,void
82586,BLOCK,-1,,"{
                var_DelCallback( p_instance->p_input, ""intf-event"", InputEvent, p_media );
                input_Close( p_instance->p_input );
                p_instance->p_input = NULL;
            }",13,,1043,2,,void
82608,BLOCK,-1,,"{
            vlm_MediaInstanceDelete( p_vlm, id, p_instance, p_media );
        }",9,,1051,2,,void
82615,BLOCK,-1,,"{
            vlm_SendEventMediaInstanceStarted( p_vlm, id, p_media->cfg.psz_name );
        }",9,,1055,1,,void
82634,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
        return VLC_EGENERIC;

    vlm_MediaInstanceDelete( p_vlm, id, p_instance, p_media );

    return VLC_SUCCESS;
}",1,,1065,4,,void
82645,BLOCK,-1,,<empty>,9,,1070,2,,void
82656,BLOCK,-1,,<empty>,9,,1074,2,,void
82672,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    int i_state;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    /* Toggle pause state */
    i_state = var_GetInteger( p_instance->p_input, ""state"" );
    if( i_state == PAUSE_S && !p_media->cfg.b_vod )
        var_SetInteger( p_instance->p_input, ""state"", PLAYING_S );
    else if( i_state == PLAYING_S )
        var_SetInteger( p_instance->p_input, ""state"", PAUSE_S );
    return VLC_SUCCESS;
}",1,,1081,4,,void
82684,BLOCK,-1,,<empty>,9,,1087,2,,void
82700,BLOCK,-1,,<empty>,9,,1091,2,,void
82721,BLOCK,-1,,<empty>,9,,1096,2,,void
82729,BLOCK,-1,,<empty>,10,,1097,1,,void
82734,BLOCK,-1,,<empty>,9,,1098,2,,void
82751,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( pi_time )
        *pi_time = var_GetInteger( p_instance->p_input, ""time"" );
    if( pd_position )
        *pd_position = var_GetFloat( p_instance->p_input, ""position"" );
    return VLC_SUCCESS;
}",1,,1102,6,,void
82762,BLOCK,-1,,<empty>,9,,1107,2,,void
82778,BLOCK,-1,,<empty>,9,,1111,2,,void
82783,BLOCK,-1,,<empty>,9,,1114,2,,void
82794,BLOCK,-1,,<empty>,9,,1116,2,,void
82813,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( i_time >= 0 )
        return var_SetInteger( p_instance->p_input, ""time"", i_time );
    else if( d_position >= 0 && d_position <= 100 )
        return var_SetFloat( p_instance->p_input, ""position"", d_position );
    return VLC_EGENERIC;
}",1,,1120,6,,void
82824,BLOCK,-1,,<empty>,9,,1125,2,,void
82840,BLOCK,-1,,<empty>,9,,1129,2,,void
82847,BLOCK,-1,,<empty>,9,,1132,2,,void
82856,BLOCK,-1,,<empty>,10,,1133,1,,void
82865,BLOCK,-1,,<empty>,9,,1134,2,,void
82882,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_t **pp_idsc;
    int                              i_idsc;

    if( !p_media )
        return VLC_EGENERIC;

    TAB_INIT( i_idsc, pp_idsc );
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        vlm_media_instance_sys_t *p_instance = p_media->instance[i];
        vlm_media_instance_t *p_idsc = vlm_media_instance_New();

        if( p_instance->psz_name )
            p_idsc->psz_name = strdup( p_instance->psz_name );
        if( p_instance->p_input )
        {
            p_idsc->i_time = var_GetInteger( p_instance->p_input, ""time"" );
            p_idsc->i_length = var_GetInteger( p_instance->p_input, ""length"" );
            p_idsc->d_position = var_GetFloat( p_instance->p_input, ""position"" );
            if( var_GetInteger( p_instance->p_input, ""state"" ) == PAUSE_S )
                p_idsc->b_paused = true;
            p_idsc->i_rate = INPUT_RATE_DEFAULT
                         ...",1,,1139,5,,void
82894,BLOCK,-1,,<empty>,9,,1145,2,,void
82901,BLOCK,-1,,<empty>,5,,1148,1,,void
82913,BLOCK,4,,"{
        vlm_media_instance_sys_t *p_instance = p_media->instance[i];
        vlm_media_instance_t *p_idsc = vlm_media_instance_New();

        if( p_instance->psz_name )
            p_idsc->psz_name = strdup( p_instance->psz_name );
        if( p_instance->p_input )
        {
            p_idsc->i_time = var_GetInteger( p_instance->p_input, ""time"" );
            p_idsc->i_length = var_GetInteger( p_instance->p_input, ""length"" );
            p_idsc->d_position = var_GetFloat( p_instance->p_input, ""position"" );
            if( var_GetInteger( p_instance->p_input, ""state"" ) == PAUSE_S )
                p_idsc->b_paused = true;
            p_idsc->i_rate = INPUT_RATE_DEFAULT
                             / var_GetFloat( p_instance->p_input, ""rate"" );
        }

        TAB_APPEND( i_idsc, pp_idsc, p_idsc );
    }",5,,1149,4,,void
82930,BLOCK,-1,,<empty>,13,,1154,2,,void
82943,BLOCK,-1,,"{
            p_idsc->i_time = var_GetInteger( p_instance->p_input, ""time"" );
            p_idsc->i_length = var_GetInteger( p_instance->p_input, ""length"" );
            p_idsc->d_position = var_GetFloat( p_instance->p_input, ""position"" );
            if( var_GetInteger( p_instance->p_input, ""state"" ) == PAUSE_S )
                p_idsc->b_paused = true;
            p_idsc->i_rate = INPUT_RATE_DEFAULT
                             / var_GetFloat( p_instance->p_input, ""rate"" );
        }",9,,1156,2,,void
82979,BLOCK,-1,,<empty>,17,,1161,2,,void
83015,BLOCK,-1,,"{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlMediaInstanceStop( p_vlm, id, p_media->instance[0]->psz_name );

    return VLC_SUCCESS;
}",1,,1174,3,,void
83025,BLOCK,-1,,<empty>,9,,1178,2,,void
83050,BLOCK,-1,,"{
    while( p_vlm->i_schedule > 0 )
        vlm_ScheduleDelete( p_vlm, p_vlm->schedule[0] );

    return VLC_SUCCESS;
}",1,,1187,2,,void
83072,BLOCK,-1,,"{
    vlm_media_t *p_dsc;
    vlm_media_t **pp_dsc;
    vlm_media_t ***ppp_dsc;
    vlm_media_instance_t ***ppp_idsc;
    const char *psz_id;
    const char *psz_vod;
    int64_t *p_id;
    int64_t id;
    int i_int;
    int *pi_int;

    int64_t *pi_i64;
    int64_t i_i64;
    double *pd_double;
    double d_double;

    switch( i_query )
    {
    /* Media control */
    case VLM_GET_MEDIAS:
        ppp_dsc = (vlm_media_t ***)va_arg( args, vlm_media_t *** );
        pi_int = (int *)va_arg( args, int * );
        return vlm_ControlMediaGets( p_vlm, ppp_dsc, pi_int );

    case VLM_CLEAR_MEDIAS:
        return vlm_ControlMediaClear( p_vlm );

    case VLM_CHANGE_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        return vlm_ControlMediaChange( p_vlm, p_dsc );

    case VLM_ADD_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        p_id = (int64_t*)va_arg( args, int64_t * );
        return vlm_ControlMediaAdd( p_vlm, p_dsc, p_id );

    ca...",1,,1195,4,,void
83089,BLOCK,-1,,"{
    /* Media control */
    case VLM_GET_MEDIAS:
        ppp_dsc = (vlm_media_t ***)va_arg( args, vlm_media_t *** );
        pi_int = (int *)va_arg( args, int * );
        return vlm_ControlMediaGets( p_vlm, ppp_dsc, pi_int );

    case VLM_CLEAR_MEDIAS:
        return vlm_ControlMediaClear( p_vlm );

    case VLM_CHANGE_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        return vlm_ControlMediaChange( p_vlm, p_dsc );

    case VLM_ADD_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        p_id = (int64_t*)va_arg( args, int64_t * );
        return vlm_ControlMediaAdd( p_vlm, p_dsc, p_id );

    case VLM_DEL_MEDIA:
        id = (int64_t)va_arg( args, int64_t );
        return vlm_ControlMediaDel( p_vlm, id );

    case VLM_GET_MEDIA:
        id = (int64_t)va_arg( args, int64_t );
        pp_dsc = (vlm_media_t **)va_arg( args, vlm_media_t ** );
        return vlm_ControlMediaGet( p_vlm, id, pp_dsc );

    case VLM_GET_MEDIA_ID:
        ps...",5,,1213,2,,void
83220,BLOCK,-1,,<empty>,13,,1271,2,,void
83356,BLOCK,-1,,"{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = vlm_vaControlInternal( p_vlm, i_query, args );
    va_end( args );

    return i_result;
}",1,,1316,3,,void
83377,BLOCK,-1,,"{
    va_list args;
    int     i_result;

    va_start( args, i_query );

    vlc_mutex_lock( &p_vlm->lock );
    i_result = vlm_vaControlInternal( p_vlm, i_query, args );
    vlc_mutex_unlock( &p_vlm->lock );

    va_end( args );

    return i_result;
}",1,,1328,3,,void
83421,BLOCK,-1,,<empty>,1,,1,1,,ANY
83427,BLOCK,-1,,<empty>,,,,5,,<empty>
83437,BLOCK,-1,,<empty>,,,,7,,<empty>
83444,BLOCK,-1,,"{
    Trigger( p_vlm, VLM_EVENT_MEDIA_ADDED, id, psz_name );
}",1,,45,4,,void
83456,BLOCK,-1,,"{
    Trigger( p_vlm, VLM_EVENT_MEDIA_REMOVED, id, psz_name );
}",1,,49,4,,void
83468,BLOCK,-1,,"{
    Trigger( p_vlm, VLM_EVENT_MEDIA_CHANGED, id, psz_name );
}",1,,53,4,,void
83480,BLOCK,-1,,"{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STARTED, id, psz_name );
}",1,,58,4,,void
83492,BLOCK,-1,,"{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STOPPED, id, psz_name );
}",1,,62,4,,void
83506,BLOCK,-1,,"{
    TriggerInstanceState( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STATE, id, psz_name, psz_instance_name, state );
}",1,,67,6,,void
83521,BLOCK,-1,,"{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = 0;
    event.psz_instance_name = NULL;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",1,,75,5,,void
83562,BLOCK,-1,,"{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = input_state;
    event.psz_instance_name = psz_instance_name;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",1,,87,7,,void
83602,BLOCK,-1,,<empty>,1,,1,1,,ANY
83607,BLOCK,-1,,<empty>,,,,4,,<empty>
83614,BLOCK,-1,,<empty>,,,,4,,<empty>
83621,BLOCK,-1,,<empty>,,,,4,,<empty>
83628,BLOCK,-1,,<empty>,,,,4,,<empty>
83635,BLOCK,-1,,<empty>,,,,4,,<empty>
83644,BLOCK,-1,,<empty>,,,,6,,<empty>
83655,BLOCK,-1,,<empty>,1,,1,1,,ANY
83704,BLOCK,-1,,<empty>,,,,3,,<empty>
83711,BLOCK,-1,,<empty>,,,,4,,<empty>
83717,BLOCK,-1,,<empty>,,,,3,,<empty>
83764,BLOCK,-1,,<empty>,1,,1,1,,ANY
83785,BLOCK,-1,,<empty>,1,,1,1,,ANY
83852,BLOCK,-1,,"{
    if (b_check_interact && p_obj->obj.flags & OBJECT_FLAGS_NOINTERACT)
        return NULL;

    vlc_dialog_provider *p_provider =
        libvlc_priv(p_obj->obj.libvlc)->p_dialog_provider;
    assert(p_provider != NULL);
    return p_provider;
}",1,,124,3,,void
83863,BLOCK,-1,,<empty>,9,,126,2,,void
83887,BLOCK,-1,,"{
    if (p_id->answer.i_type == VLC_DIALOG_LOGIN)
    {
        free(p_id->answer.u.login.psz_username);
        free(p_id->answer.u.login.psz_password);
    }
    free(p_id->psz_progress_text);
    vlc_mutex_destroy(&p_id->lock);
    vlc_cond_destroy(&p_id->wait);
    free(p_id);
}",1,,136,2,,void
83896,BLOCK,-1,,"{
        free(p_id->answer.u.login.psz_username);
        free(p_id->answer.u.login.psz_password);
    }",5,,138,2,,void
83937,BLOCK,-1,,"{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = malloc(sizeof(*p_provider));
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_mutex_init(&p_provider->lock);
    vlc_array_init(&p_provider->dialog_array);

    memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
    p_provider->p_cbs_data = NULL;

    p_provider->pf_ext_update = NULL;
    p_provider->p_ext_data = NULL;
    libvlc_priv(p_libvlc)->p_dialog_provider = p_provider;

    return VLC_SUCCESS;
}",1,,150,2,,void
83953,BLOCK,-1,,<empty>,9,,154,2,,void
84004,BLOCK,-1,,"{
    vlc_mutex_lock(&p_id->lock);
    if (p_id->b_cancelled || p_id->b_answered)
    {
        vlc_mutex_unlock(&p_id->lock);
        return;
    }
    p_id->b_cancelled = true;
    vlc_mutex_unlock(&p_id->lock);

    p_provider->cbs.pf_cancel(p_provider->p_cbs_data, p_id);
}",1,,171,3,,void
84018,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_id->lock);
        return;
    }",5,,174,2,,void
84050,BLOCK,-1,,"{
    vlc_dialog_id *p_id = calloc(1, sizeof(*p_id));

    if (p_id == NULL)
        return NULL;

    if(vlc_array_append(&p_provider->dialog_array, p_id))
    {
        free(p_id);
        return NULL;
    }

    vlc_mutex_init(&p_id->lock);
    vlc_cond_init(&p_id->wait);

    p_id->i_type = i_type;
    p_id->i_refcount = 2; /* provider and callbacks */

    return p_id;
}",1,,186,3,,void
84063,BLOCK,-1,,<empty>,9,,190,2,,void
84073,BLOCK,-1,,"{
        free(p_id);
        return NULL;
    }",5,,193,2,,void
84105,BLOCK,-1,,"{
    ssize_t i_idx = vlc_array_index_of_item(&p_provider->dialog_array, p_id);
    assert(i_idx >= 0);
    vlc_array_remove(&p_provider->dialog_array, i_idx);

    vlc_mutex_lock(&p_id->lock);
    p_id->i_refcount--;
    if (p_id->i_refcount == 0)
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    else
        vlc_mutex_unlock(&p_id->lock);
}",1,,209,3,,void
84140,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }",5,,217,2,,void
84149,BLOCK,-1,,<empty>,9,,222,1,,void
84159,BLOCK,-1,,"{
    for (size_t i = 0; i < vlc_array_count(&p_provider->dialog_array); ++i)
    {
        vlc_dialog_id *p_id =
            vlc_array_item_at_index(&p_provider->dialog_array, i);
        dialog_cancel_locked(p_provider, p_id);
    }
}",1,,227,2,,void
84161,BLOCK,-1,,<empty>,5,,228,1,,void
84175,BLOCK,4,,"{
        vlc_dialog_id *p_id =
            vlc_array_item_at_index(&p_provider->dialog_array, i);
        dialog_cancel_locked(p_provider, p_id);
    }",5,,229,4,,void
84192,BLOCK,-1,,"{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = libvlc_priv(p_libvlc)->p_dialog_provider;

    if (p_provider == NULL)
        return;
    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_destroy(&p_provider->lock);
    free(p_provider);
    libvlc_priv(p_libvlc)->p_dialog_provider = NULL;
}",1,,238,2,,void
84208,BLOCK,-1,,<empty>,9,,243,2,,void
84241,BLOCK,-1,,"{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);

    if (p_cbs == NULL)
    {
        memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
        p_provider->p_cbs_data = NULL;
    }
    else
    {
        p_provider->cbs = *p_cbs;
        p_provider->p_cbs_data = p_data;
    }
    vlc_mutex_unlock(&p_provider->lock);
}",1,,257,4,,void
84263,BLOCK,-1,,"{
        memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
        p_provider->p_cbs_data = NULL;
    }",5,,265,2,,void
84280,BLOCK,-1,,"{
        p_provider->cbs = *p_cbs;
        p_provider->p_cbs_data = p_data;
    }",5,,270,1,,void
84301,BLOCK,-1,,"{
    struct dialog_i11e_context *p_context = p_data;
    vlc_dialog_provider *p_provider = p_context->p_provider;
    vlc_dialog_id *p_id = p_context->p_id;

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_lock(&p_id->lock);
    vlc_cond_signal(&p_id->wait);
    vlc_mutex_unlock(&p_id->lock);
}",1,,279,2,,void
84353,BLOCK,-1,,"{
    struct dialog_i11e_context context = {
        .p_provider = p_provider,
        .p_id = p_id,
    };
    vlc_interrupt_register(dialog_wait_interrupted, &context);

    vlc_mutex_lock(&p_id->lock);
    /* Wait for the dialog to be dismissed, interrupted or answered */
    while (!p_id->b_cancelled && !p_id->b_answered)
        vlc_cond_wait(&p_id->wait, &p_id->lock);

    int i_ret;
    if (p_id->b_cancelled)
        i_ret = 0;
    else if (p_id->answer.i_type != i_type)
        i_ret = VLC_EGENERIC;
    else
    {
        i_ret = 1;
        memcpy(p_answer, &p_id->answer, sizeof(p_id->answer));
        memset(&p_id->answer, 0, sizeof(p_id->answer));
    }

    vlc_mutex_unlock(&p_id->lock);
    vlc_interrupt_unregister();

    vlc_mutex_lock(&p_provider->lock);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);
    return i_ret;
}",1,,296,5,,void
84358,BLOCK,1,,<empty>,9,,298,1,,void
84362,BLOCK,2,,<empty>,9,,299,2,,void
84399,BLOCK,-1,,<empty>,9,,310,2,,void
84404,BLOCK,-1,,<empty>,10,,311,1,,void
84413,BLOCK,-1,,<empty>,9,,312,2,,void
84418,BLOCK,-1,,"{
        i_ret = 1;
        memcpy(p_answer, &p_id->answer, sizeof(p_id->answer));
        memset(&p_id->answer, 0, sizeof(p_id->answer));
    }",5,,314,1,,void
84470,BLOCK,-1,,"{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_error == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    p_provider->cbs.pf_display_error(p_provider->p_cbs_data, psz_title, psz_text);
    free(psz_text);
    vlc_mutex_unlock(&p_provider->lock);

    return VLC_SUCCESS;
}",1,,332,5,,void
84484,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }",5,,335,2,,void
84502,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }",5,,342,2,,void
84537,BLOCK,-1,,"{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);
    int i_ret;
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);

    if (p_provider != NULL)
        i_ret = dialog_display_error_va(p_provider, psz_title, psz_fmt, ap);
    else
        i_ret = VLC_EGENERIC;

    if (i_ret != VLC_SUCCESS)
    {
        msg_Err(p_obj, ""%s"", psz_title);
        msg_GenericVa(p_obj, VLC_MSG_ERR, psz_fmt, ap);
    }
    return i_ret;
}",1,,357,5,,void
84561,BLOCK,-1,,<empty>,9,,363,2,,void
84570,BLOCK,-1,,<empty>,9,,365,1,,void
84578,BLOCK,-1,,"{
        msg_Err(p_obj, ""%s"", psz_title);
        msg_GenericVa(p_obj, VLC_MSG_ERR, psz_fmt, ap);
    }",5,,368,2,,void
84596,BLOCK,-1,,"{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_display_error_va(p_obj, psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,,380,4,,void
84627,BLOCK,-1,,"{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_login == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_LOGIN);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_login(p_provider->p_cbs_data, p_id, psz_title,
                                     psz_text, psz_default_username, b_ask_store);
    free(psz_text);
    vlc_mutex_unlock(&p_provider->lock);
    *pp_id = p_id;

    return VLC_SUCCESS;
}",1,,393,8,,void
84649,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }",5,,397,2,,void
84667,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }",5,,404,2,,void
84685,BLOCK,-1,,"{
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }",5,,411,2,,void
84733,BLOCK,-1,,"{
    assert(p_obj != NULL && ppsz_username != NULL && ppsz_password != NULL
        && psz_fmt != NULL && psz_title != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_login_va(p_provider, &p_id, psz_default_username,
                                        p_store != NULL, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_LOGIN, &answer);
    if (i_ret <= 0)
        return i_ret;

    *ppsz_username = answer.u.login.psz_username;
    *ppsz_password = answer.u.login.psz_password;
    if (p_store != NULL)
        *p_store = answer.u.login.b_store;

    return 1;
}",1,,430,9,,void
84764,BLOCK,-1,,<empty>,9,,436,2,,void
84790,BLOCK,-1,,<empty>,9,,442,2,,void
84806,BLOCK,-1,,<empty>,9,,447,2,,void
84833,BLOCK,-1,,<empty>,9,,452,2,,void
84856,BLOCK,-1,,"{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_login_va(p_obj, ppsz_username, ppsz_password,
                                         p_store,psz_default_username,
                                         psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,,463,8,,void
84893,BLOCK,-1,,"{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_question == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_QUESTION);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_question(p_provider->p_cbs_data, p_id, psz_title,
                                        psz_text, i_type, psz_cancel, psz_action1,
                                        psz_action2);
    free(psz_text);
    vlc_mutex_unlock(&p_provider->lock);
    *pp_id = p_id;

    return VLC_SUCCESS;
}",1,,480,10,,void
84915,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }",5,,484,2,,void
84933,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }",5,,491,2,,void
84951,BLOCK,-1,,"{
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }",5,,498,2,,void
85001,BLOCK,-1,,"{
    assert(p_obj != NULL && psz_fmt != NULL && psz_title != NULL
        && psz_cancel != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_question_va(p_provider, &p_id, i_type,
                                           psz_cancel, psz_action1,
                                           psz_action2, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_QUESTION, &answer);
    if (i_ret <= 0)
        return i_ret;

    if (answer.u.question.i_action != 1 && answer.u.question.i_action != 2)
        return VLC_EGENERIC;

    return answer.u.question.i_action;
}",1,,519,9,,void
85028,BLOCK,-1,,<empty>,9,,525,2,,void
85054,BLOCK,-1,,<empty>,9,,532,2,,void
85070,BLOCK,-1,,<empty>,9,,537,2,,void
85093,BLOCK,-1,,<empty>,9,,540,2,,void
85114,BLOCK,-1,,"{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_question_va(p_obj, i_type, psz_cancel,
                                            psz_action1, psz_action2, psz_title,
                                            psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,,552,8,,void
85150,BLOCK,-1,,"{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_progress == NULL
     || p_provider->cbs.pf_update_progress == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_PROGRESS);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_id->b_progress_indeterminate = b_indeterminate;
    p_id->psz_progress_text = psz_text;
    p_provider->cbs.pf_display_progress(p_provider->p_cbs_data, p_id, psz_title,
                                        psz_text, b_indeterminate, f_position,
                                        psz_cancel);
    vlc_mutex_unlock(&p_provider->lock);
    *pp_id = ...",1,,568,9,,void
85180,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }",5,,573,2,,void
85198,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }",5,,580,2,,void
85216,BLOCK,-1,,"{
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }",5,,587,2,,void
85272,BLOCK,-1,,"{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return NULL;
    vlc_dialog_id *p_id;
    int i_ret = display_progress_va(p_provider, &p_id, b_indeterminate,
                                    f_position, psz_cancel, psz_title, psz_fmt,
                                    ap);
    return i_ret == VLC_SUCCESS ? p_id : NULL;
}",1,,608,8,,void
85295,BLOCK,-1,,<empty>,9,,613,2,,void
85328,BLOCK,-1,,"{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    vlc_dialog_id *p_id =
        vlc_dialog_display_progress_va(p_obj, b_indeterminate, f_position,
                                       psz_cancel, psz_title, psz_fmt, ap);
    va_end(ap);
    return p_id;
}",1,,626,7,,void
85359,BLOCK,-1,,"{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_update_progress == NULL ||
        vlc_dialog_is_cancelled(p_obj, p_id))
    {
        vlc_mutex_unlock(&p_provider->lock);
        free(psz_text);
        return VLC_EGENERIC;
    }

    if (p_id->b_progress_indeterminate)
        f_value = 0.0f;

    if (psz_text != NULL)
    {
        free(p_id->psz_progress_text);
        p_id->psz_progress_text = psz_text;
    }
    p_provider->cbs.pf_update_progress(p_provider->p_cbs_data, p_id, f_value,
                                       p_id->psz_progress_text);

    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",1,,640,5,,void
85391,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        free(psz_text);
        return VLC_EGENERIC;
    }",5,,647,2,,void
85405,BLOCK,-1,,<empty>,9,,654,2,,void
85413,BLOCK,-1,,"{
        free(p_id->psz_progress_text);
        p_id->psz_progress_text = psz_text;
    }",5,,657,2,,void
85450,BLOCK,-1,,"{
    return dialog_update_progress(p_obj, p_id, f_value, NULL);
}",1,,672,4,,void
85465,BLOCK,-1,,"{
    assert(psz_fmt != NULL);

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
        return VLC_ENOMEM;
    return dialog_update_progress(p_obj, p_id, f_value, psz_text);
}",1,,680,6,,void
85480,BLOCK,-1,,<empty>,9,,685,2,,void
85496,BLOCK,-1,,"{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_update_progress_text_va(p_obj, p_id, f_value,
                                                   psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",1,,693,5,,void
85523,BLOCK,-1,,"{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);
}",1,,706,3,,void
85559,BLOCK,-1,,"{
    (void) p_obj;
    assert(p_id != NULL);

    vlc_mutex_lock(&p_id->lock);
    bool b_cancelled = p_id->b_cancelled;
    vlc_mutex_unlock(&p_id->lock);
    return b_cancelled;
}",1,,719,3,,void
85590,BLOCK,-1,,"{
    vlc_mutex_lock(&p_id->lock);
    p_id->p_context = p_context;
    vlc_mutex_unlock(&p_id->lock);
}",1,,731,3,,void
85610,BLOCK,-1,,"{
    assert(p_id != NULL);
    vlc_mutex_lock(&p_id->lock);
    void *p_context = p_id->p_context;
    vlc_mutex_unlock(&p_id->lock);
    return p_context;
}",1,,739,2,,void
85638,BLOCK,-1,,"{
    vlc_mutex_lock(&p_id->lock);
    if (p_answer == NULL)
    {
        p_id->b_cancelled = true;
    }
    else
    {
        p_id->answer = *p_answer;
        p_id->b_answered = true;
    }
    p_id->i_refcount--;
    if (p_id->i_refcount > 0)
    {
        vlc_cond_signal(&p_id->wait);
        vlc_mutex_unlock(&p_id->lock);
    }
    else
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    return VLC_SUCCESS;
}",1,,749,3,,void
85648,BLOCK,-1,,"{
        p_id->b_cancelled = true;
    }",5,,752,2,,void
85655,BLOCK,-1,,"{
        p_id->answer = *p_answer;
        p_id->b_answered = true;
    }",5,,756,1,,void
85677,BLOCK,-1,,"{
        vlc_cond_signal(&p_id->wait);
        vlc_mutex_unlock(&p_id->lock);
    }",5,,762,2,,void
85689,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }",5,,767,1,,void
85706,BLOCK,-1,,"{
    assert(p_id != NULL && psz_username != NULL && psz_password != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_LOGIN,
        .u.login = {
            .b_store = b_store,
            .psz_username = strdup(psz_username),
            .psz_password = strdup(psz_password),
        },
    };
    if (answer.u.login.psz_username == NULL
     || answer.u.login.psz_password == NULL)
    {
        free(answer.u.login.psz_username);
        free(answer.u.login.psz_password);
        dialog_id_post(p_id, NULL);
        return VLC_ENOMEM;
    }

    return dialog_id_post(p_id, &answer);
}",1,,777,5,,void
85723,BLOCK,1,,<empty>,9,,781,1,,void
85727,BLOCK,2,,<empty>,9,,782,2,,void
85731,BLOCK,1,,<empty>,13,,783,1,,void
85735,BLOCK,2,,<empty>,13,,784,2,,void
85740,BLOCK,3,,<empty>,13,,785,3,,void
85748,BLOCK,1,,<empty>,13,,783,1,,void
85752,BLOCK,2,,<empty>,13,,784,2,,void
85757,BLOCK,3,,<empty>,13,,785,3,,void
85782,BLOCK,-1,,"{
        free(answer.u.login.psz_username);
        free(answer.u.login.psz_password);
        dialog_id_post(p_id, NULL);
        return VLC_ENOMEM;
    }",5,,790,2,,void
85814,BLOCK,-1,,"{
    assert(p_id != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_QUESTION,
        .u.question = { .i_action = i_action },
    };

    return dialog_id_post(p_id, &answer);
}",1,,802,3,,void
85823,BLOCK,1,,<empty>,9,,806,1,,void
85827,BLOCK,2,,<empty>,9,,807,2,,void
85831,BLOCK,1,,<empty>,25,,807,1,,void
85838,BLOCK,1,,<empty>,25,,807,1,,void
85851,BLOCK,-1,,"{
    return dialog_id_post(p_id, NULL);
}",1,,815,2,,void
85862,BLOCK,-1,,"{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);

    p_provider->pf_ext_update = pf_update;
    p_provider->p_ext_data = p_data;

    vlc_mutex_unlock(&p_provider->lock);
}",1,,824,4,,void
85898,BLOCK,-1,,"{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->pf_ext_update == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }
    p_provider->pf_ext_update(p_ext_dialog, p_provider->p_ext_data);
    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",1,,839,3,,void
85920,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }",5,,845,2,,void
85967,BLOCK,-1,,<empty>,1,,1,1,,ANY
85974,BLOCK,-1,,<empty>,,,,6,,<empty>
85984,BLOCK,-1,,"{
    /* Allocate structure */
    intf_thread_t *p_intf = vlc_custom_create( playlist, sizeof( *p_intf ),
                                               ""interface"" );
    if( unlikely(p_intf == NULL) )
        return VLC_ENOMEM;

    /* Variable used for interface spawning */
    vlc_value_t val, text;
    var_Create( p_intf, ""intf-add"", VLC_VAR_STRING | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Add Interface"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_SETTEXT, &text, NULL );
#if !defined(_WIN32) && defined(HAVE_ISATTY)
    if( isatty( 0 ) )
#endif
    {
        val.psz_string = (char *)""rc,none"";
        text.psz_string = (char *)_(""Console"");
        var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    }
    val.psz_string = (char *)""telnet,none"";
    text.psz_string = (char *)_(""Telnet"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    val.psz_string = (char *)""http,none"";
    text.psz_string = (char *)_(""Web"");
    var_Change( ...",1,,72,3,,void
85991,BLOCK,1,,<empty>,,,,4,,void
86004,BLOCK,-1,,<empty>,9,,77,2,,void
86028,BLOCK,9,,"{
        val.psz_string = (char *)""rc,none"";
        text.psz_string = (char *)_(""Console"");
        var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    }",5,,87,9,,void
86158,BLOCK,-1,,"{
        msg_Err( p_intf, ""no suitable interface module"" );
        goto error;
    }",5,,112,2,,void
86172,BLOCK,1,,<empty>,,,,2,,void
86182,BLOCK,1,,<empty>,,,,2,,void
86200,BLOCK,-1,,<empty>,9,,126,2,,void
86218,BLOCK,-1,,"{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist == NULL)
    {
        playlist = playlist_Create(VLC_OBJECT(libvlc));
        libvlc_priv(libvlc)->playlist = playlist;
    }
    vlc_mutex_unlock(&lock);

    return playlist;
}",1,,138,2,,void
86233,BLOCK,-1,,"{
        playlist = playlist_Create(VLC_OBJECT(libvlc));
        libvlc_priv(libvlc)->playlist = playlist;
    }",5,,144,2,,void
86258,BLOCK,-1,,"{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    input_item_t *item = input_item_New(mrl, NULL);

    if (unlikely(item == NULL))
        return -1;

    int ret = -1;

    if (input_item_AddOptions(item, optc, optv, flags) == VLC_SUCCESS)
    {
        playlist_Lock(playlist);
        if (playlist_NodeAddInput(playlist, item, playlist->p_playing,
                                  0) != NULL)
            ret = 0;
        playlist_Unlock(playlist);
    }
    input_item_Release(item);
    return ret;
}",1,,165,6,,void
86275,BLOCK,-1,,<empty>,9,,170,2,,void
86292,BLOCK,-1,,"{
        playlist_Lock(playlist);
        if (playlist_NodeAddInput(playlist, item, playlist->p_playing,
                                  0) != NULL)
            ret = 0;
        playlist_Unlock(playlist);
    }",5,,175,2,,void
86305,BLOCK,-1,,<empty>,13,,179,2,,void
86319,BLOCK,-1,,"{
    playlist_t *pl;

    vlc_mutex_lock(&lock);
    pl = libvlc_priv(libvlc)->playlist;
    vlc_mutex_unlock(&lock);

    if (pl != NULL && var_GetBool(pl, ""playlist-autostart""))
        playlist_Control(pl, PLAYLIST_PLAY, false);
}",1,,187,2,,void
86341,BLOCK,-1,,<empty>,9,,195,2,,void
86351,BLOCK,-1,,"{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    int ret;

    if (unlikely(playlist == NULL))
        ret = VLC_ENOMEM;
    else
    if (name != NULL)
        ret = intf_Create(playlist, name);
    else
    {   /* Default interface */
        char *intf = var_InheritString(libvlc, ""intf"");
        if (intf == NULL) /* ""intf"" has not been set */
        {
#if !defined(_WIN32) && !defined(__OS2__)
            char *pidfile = var_InheritString(libvlc, ""pidfile"");
            if (pidfile != NULL)
                free(pidfile);
            else
#endif
                msg_Info(libvlc, _(""Running vlc with the default interface. ""
                         ""Use 'cvlc' to use vlc without interface.""));
        }
        ret = intf_Create(playlist, intf);
        free(intf);
        name = ""default"";
    }
    if (ret != VLC_SUCCESS)
        msg_Err(libvlc, ""interface \""%s\"" initialization failed"", name);
    return ret;
}",1,,202,3,,void
86363,BLOCK,-1,,<empty>,9,,207,2,,void
86368,BLOCK,-1,,<empty>,5,,209,1,,void
86373,BLOCK,-1,,<empty>,9,,210,2,,void
86380,BLOCK,-1,,"{   /* Default interface */
        char *intf = var_InheritString(libvlc, ""intf"");
        if (intf == NULL) /* ""intf"" has not been set */
        {
#if !defined(_WIN32) && !defined(__OS2__)
            char *pidfile = var_InheritString(libvlc, ""pidfile"");
            if (pidfile != NULL)
                free(pidfile);
            else
#endif
                msg_Info(libvlc, _(""Running vlc with the default interface. ""
                         ""Use 'cvlc' to use vlc without interface.""));
        }
        ret = intf_Create(playlist, intf);
        free(intf);
        name = ""default"";
    }",5,,212,1,,void
86391,BLOCK,-1,,"{
#if !defined(_WIN32) && !defined(__OS2__)
            char *pidfile = var_InheritString(libvlc, ""pidfile"");
            if (pidfile != NULL)
                free(pidfile);
            else
#endif
                msg_Info(libvlc, _(""Running vlc with the default interface. ""
                         ""Use 'cvlc' to use vlc without interface.""));
        }",9,,215,2,,void
86402,BLOCK,-1,,<empty>,17,,219,2,,void
86406,BLOCK,-1,,<empty>,17,,222,1,,void
86425,BLOCK,-1,,<empty>,9,,230,2,,void
86436,BLOCK,-1,,"{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist != NULL)
    {
        intf_thread_t *intf, **pp = &(pl_priv(playlist)->interface);

        while ((intf = *pp) != NULL)
        {
            *pp = intf->p_next;
            vlc_mutex_unlock(&lock);

            module_unneed(intf, intf->p_module);
            config_ChainDestroy(intf->p_cfg);
            var_DelCallback(intf, ""intf-add"", AddIntfCallback, playlist);
            vlc_object_release(intf);

            vlc_mutex_lock(&lock);
        }

        libvlc_priv(libvlc)->playlist = NULL;
    }
    vlc_mutex_unlock(&lock);

    if (playlist != NULL)
        playlist_Destroy(playlist);
}",1,,240,2,,void
86451,BLOCK,-1,,"{
        intf_thread_t *intf, **pp = &(pl_priv(playlist)->interface);

        while ((intf = *pp) != NULL)
        {
            *pp = intf->p_next;
            vlc_mutex_unlock(&lock);

            module_unneed(intf, intf->p_module);
            config_ChainDestroy(intf->p_cfg);
            var_DelCallback(intf, ""intf-add"", AddIntfCallback, playlist);
            vlc_object_release(intf);

            vlc_mutex_lock(&lock);
        }

        libvlc_priv(libvlc)->playlist = NULL;
    }",5,,246,2,,void
86459,BLOCK,1,,<empty>,,,,3,,void
86473,BLOCK,-1,,"{
            *pp = intf->p_next;
            vlc_mutex_unlock(&lock);

            module_unneed(intf, intf->p_module);
            config_ChainDestroy(intf->p_cfg);
            var_DelCallback(intf, ""intf-add"", AddIntfCallback, playlist);
            vlc_object_release(intf);

            vlc_mutex_lock(&lock);
        }",9,,250,2,,void
86515,BLOCK,-1,,<empty>,9,,267,2,,void
86526,BLOCK,-1,,"{
    playlist_t *playlist = data;

    int ret = intf_Create( playlist, cur.psz_string );
    if( ret )
        msg_Err( obj, ""interface \""%s\"" initialization failed"",
                 cur.psz_string );

    (void) var; (void) old;
    return ret;
}",1,,274,6,,void
86541,BLOCK,-1,,<empty>,9,,279,2,,void
86584,BLOCK,-1,,<empty>,1,,1,1,,ANY
86909,BLOCK,-1,,<empty>,,,,1,,<empty>
86915,BLOCK,-1,,<empty>,,,,2,,<empty>
86921,BLOCK,-1,,<empty>,,,,2,,<empty>
86987,BLOCK,-1,,<empty>,1,,1,1,,ANY
86992,BLOCK,-1,,<empty>,,,,4,,<empty>
86997,BLOCK,-1,,"{
    libvlc_int_t *p_libvlc;
    libvlc_priv_t *priv;

    /* Allocate a libvlc instance object */
    p_libvlc = (vlc_custom_create)( NULL, sizeof (*priv), ""libvlc"" );
    if( p_libvlc == NULL )
        return NULL;

    priv = libvlc_priv (p_libvlc);
    priv->playlist = NULL;
    priv->p_vlm = NULL;

    vlc_ExitInit( &priv->exit );

    return p_libvlc;
}",1,,84,2,,void
87012,BLOCK,-1,,<empty>,9,,91,2,,void
87042,BLOCK,-1,,"{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);
    char *       psz_modules = NULL;
    char *       psz_parser = NULL;
    char *       psz_control = NULL;
    char        *psz_val;
    int          i_ret = VLC_EGENERIC;

    /* System specific initialization code */
    system_Init();

    vlc_LogPreinit(p_libvlc);

    /* Initialize the module bank and load the configuration of the
     * core module. We need to do this at this stage to be able to display
     * a short help if required by the user. (short help == core module
     * options) */
    module_InitBank ();

    /* Get command line options that affect module loading. */
    if( config_LoadCmdLine( p_libvlc, i_argc, ppsz_argv, NULL ) )
    {
        module_EndBank (false);
        return VLC_EGENERIC;
    }

    vlc_threads_setup (p_libvlc);

    /* Load the builtins and plugins into the module_bank.
     * We have to do it before config_Load*() because this also gets the
     * list of configuration options export...",1,,112,4,,void
87075,BLOCK,1,,<empty>,,,,5,,void
87082,BLOCK,-1,,"{
        module_EndBank (false);
        return VLC_EGENERIC;
    }",5,,133,2,,void
87094,BLOCK,1,,<empty>,,,,2,,void
87103,BLOCK,-1,,"{
        if( var_InheritBool( p_libvlc, ""reset-config"" ) )
            config_SaveConfigFile( p_libvlc ); /* Save default config */
        else
            config_LoadConfigFile( p_libvlc );
    }",5,,150,2,,void
87108,BLOCK,-1,,<empty>,13,,152,2,,void
87112,BLOCK,-1,,<empty>,13,,154,1,,void
87115,BLOCK,1,,<empty>,,,,2,,void
87127,BLOCK,1,,<empty>,,,,6,,void
87135,BLOCK,-1,,<empty>,9,,162,2,,void
87148,BLOCK,-1,,"{
        libvlc_InternalCleanup (p_libvlc);
        exit(0);
    }",5,,177,2,,void
87157,BLOCK,-1,,"{
        msg_Err( p_libvlc, ""No plugins found! Check your VLC installation."");
        i_ret = VLC_ENOMOD;
        goto error;
    }",5,,183,2,,void
87173,BLOCK,-1,,<empty>,9,,226,2,,void
87180,BLOCK,-1,,<empty>,9,,228,2,,void
87199,BLOCK,-1,,<empty>,9,,238,2,,void
87213,BLOCK,-1,,<empty>,9,,245,2,,void
87303,BLOCK,-1,,"{
        char* psz_tmp;
        if( asprintf( &psz_tmp, ""%s:%s"", psz_modules, psz_control ) != -1 )
        {
            free( psz_modules );
            psz_modules = psz_tmp;
        }
    }",5,,305,2,,void
87315,BLOCK,-1,,"{
            free( psz_modules );
            psz_modules = psz_tmp;
        }",9,,308,2,,void
87322,BLOCK,-1,,<empty>,10,,313,1,,void
87325,BLOCK,-1,,"{
        free( psz_modules );
        psz_modules = strdup( psz_control );
    }",5,,314,2,,void
87340,BLOCK,-1,,"{
        char *psz_module, *psz_temp;
        psz_module = psz_parser;
        psz_parser = strchr( psz_module, ':' );
        if ( psz_parser )
        {
            *psz_parser = '\0';
            psz_parser++;
        }
        if( asprintf( &psz_temp, ""%s,none"", psz_module ) != -1)
        {
            libvlc_InternalAddIntf( p_libvlc, psz_temp );
            free( psz_temp );
        }
    }",5,,321,2,,void
87353,BLOCK,-1,,"{
            *psz_parser = '\0';
            psz_parser++;
        }",9,,326,2,,void
87369,BLOCK,-1,,"{
            libvlc_InternalAddIntf( p_libvlc, psz_temp );
            free( psz_temp );
        }",9,,331,2,,void
87383,BLOCK,-1,,<empty>,9,,340,2,,void
87404,BLOCK,-1,,"{
        intf_InsertItem( p_libvlc, psz_val, 0, NULL, 0 );
        free( psz_val );
    }",5,,366,2,,void
87424,BLOCK,-1,,"{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);

    if (priv->parser != NULL)
        playlist_preparser_Deactivate(priv->parser);

    /* Ask the interfaces to stop and destroy them */
    msg_Dbg( p_libvlc, ""removing all interfaces"" );
    intf_DestroyAll( p_libvlc );

    libvlc_InternalDialogClean( p_libvlc );
    libvlc_InternalKeystoreClean( p_libvlc );

#ifdef ENABLE_VLM
    /* Destroy VLM if created in libvlc_InternalInit */
    if( priv->p_vlm )
    {
        vlm_Delete( priv->p_vlm );
    }
#endif

#if !defined( _WIN32 ) && !defined( __OS2__ )
    char *pidfile = var_InheritString( p_libvlc, ""pidfile"" );
    if( pidfile != NULL )
    {
        msg_Dbg( p_libvlc, ""removing PID file %s"", pidfile );
        if( unlink( pidfile ) )
            msg_Warn( p_libvlc, ""cannot remove PID file %s: %s"",
                      pidfile, vlc_strerror_c(errno) );
        free( pidfile );
    }
#endif

    if (priv->parser != NULL)
        playlist_preparser_Delete(priv->parser);

    ...",1,,383,2,,void
87436,BLOCK,-1,,<empty>,9,,387,2,,void
87460,BLOCK,-1,,"{
        msg_Dbg( p_libvlc, ""removing PID file %s"", pidfile );
        if( unlink( pidfile ) )
            msg_Warn( p_libvlc, ""cannot remove PID file %s: %s"",
                      pidfile, vlc_strerror_c(errno) );
        free( pidfile );
    }",5,,407,2,,void
87468,BLOCK,-1,,<empty>,13,,410,2,,void
87483,BLOCK,-1,,<empty>,9,,417,2,,void
87495,BLOCK,-1,,<empty>,9,,423,2,,void
87507,BLOCK,-1,,"{
    libvlc_priv_t *priv = libvlc_priv( p_libvlc );

    vlc_ExitDestroy( &priv->exit );

    assert( atomic_load(&(vlc_internals(p_libvlc)->refs)) == 1 );
    vlc_object_release( p_libvlc );
}",1,,441,2,,void
87524,BLOCK,1,,<empty>,,,,2,,void
87542,BLOCK,-1,,"{
    while( n > 0 )
    {
        /* Count the input options */
        unsigned i_options = 0;

        while( args[--n][0] == ':' )
        {
            i_options++;
            if( n == 0 )
            {
                msg_Warn( p_vlc, ""options %s without item"", args[n] );
                return; /* syntax!? */
            }
        }

        char *mrl = NULL;
        if( strstr( args[n], ""://"" ) == NULL )
        {
            mrl = vlc_path2uri( args[n], NULL );
            if( !mrl )
                continue;
        }

        intf_InsertItem( p_vlc, (mrl != NULL) ? mrl : args[n], i_options,
                         ( i_options ? &args[n + 1] : NULL ),
                         VLC_INPUT_OPTION_TRUSTED );
        free( mrl );
    }
}",1,,458,4,,void
87547,BLOCK,-1,,"{
        /* Count the input options */
        unsigned i_options = 0;

        while( args[--n][0] == ':' )
        {
            i_options++;
            if( n == 0 )
            {
                msg_Warn( p_vlc, ""options %s without item"", args[n] );
                return; /* syntax!? */
            }
        }

        char *mrl = NULL;
        if( strstr( args[n], ""://"" ) == NULL )
        {
            mrl = vlc_path2uri( args[n], NULL );
            if( !mrl )
                continue;
        }

        intf_InsertItem( p_vlc, (mrl != NULL) ? mrl : args[n], i_options,
                         ( i_options ? &args[n + 1] : NULL ),
                         VLC_INPUT_OPTION_TRUSTED );
        free( mrl );
    }",5,,460,2,,void
87561,BLOCK,-1,,"{
            i_options++;
            if( n == 0 )
            {
                msg_Warn( p_vlc, ""options %s without item"", args[n] );
                return; /* syntax!? */
            }
        }",9,,465,2,,void
87568,BLOCK,-1,,"{
                msg_Warn( p_vlc, ""options %s without item"", args[n] );
                return; /* syntax!? */
            }",13,,468,2,,void
87588,BLOCK,-1,,"{
            mrl = vlc_path2uri( args[n], NULL );
            if( !mrl )
                continue;
        }",9,,476,2,,void
87599,BLOCK,-1,,<empty>,17,,479,2,,void
87632,BLOCK,-1,,"{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
    {
        vlc_mutex_lock( &item->lock );
        item->b_preparse_interact = true;
        vlc_mutex_unlock( &item->lock );
    }
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;

}",1,,492,6,,void
87645,BLOCK,-1,,<empty>,9,,496,2,,void
87652,BLOCK,-1,,"{
        vlc_mutex_lock( &item->lock );
        item->b_preparse_interact = true;
        vlc_mutex_unlock( &item->lock );
    }",5,,499,2,,void
87686,BLOCK,-1,,"{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    vlc_mutex_lock( &item->lock );
    if( item->i_preparse_depth == 0 )
        item->i_preparse_depth = 1;
    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
        item->b_preparse_interact = true;
    vlc_mutex_unlock( &item->lock );
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;
}",1,,517,6,,void
87699,BLOCK,-1,,<empty>,9,,521,2,,void
87713,BLOCK,-1,,<empty>,9,,525,2,,void
87723,BLOCK,-1,,<empty>,9,,527,2,,void
87750,BLOCK,-1,,"{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    playlist_preparser_fetcher_Push(priv->parser, item, i_options);
    return VLC_SUCCESS;
}",1,,539,4,,void
87763,BLOCK,-1,,<empty>,9,,543,2,,void
87779,BLOCK,-1,,"{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return;

    playlist_preparser_Cancel(priv->parser, id);
}",1,,556,3,,void
87792,BLOCK,-1,,<empty>,9,,560,2,,void
87807,BLOCK,-1,,<empty>,1,,1,1,,ANY
87814,BLOCK,-1,,<empty>,,,,2,,<empty>
87821,BLOCK,-1,,<empty>,,,,4,,<empty>
87826,BLOCK,-1,,<empty>,,,,2,,<empty>
87831,BLOCK,-1,,<empty>,,,,2,,<empty>
87839,BLOCK,-1,,<empty>,,,,5,,<empty>
87845,BLOCK,-1,,<empty>,,,,3,,<empty>
87850,BLOCK,-1,,<empty>,,,,2,,<empty>
87857,BLOCK,-1,,<empty>,,,,4,,<empty>
87864,BLOCK,-1,,<empty>,,,,2,,<empty>
87869,BLOCK,-1,,<empty>,,,,2,,<empty>
87874,BLOCK,-1,,<empty>,,,,2,,<empty>
87881,BLOCK,-1,,<empty>,,,,2,,<empty>
87888,BLOCK,-1,,<empty>,,,,2,,<empty>
87893,BLOCK,-1,,<empty>,,,,2,,<empty>
87900,BLOCK,-1,,<empty>,,,,4,,<empty>
87906,BLOCK,-1,,<empty>,,,,3,,<empty>
87911,BLOCK,-1,,<empty>,,,,2,,<empty>
87917,BLOCK,-1,,<empty>,,,,3,,<empty>
87923,BLOCK,-1,,<empty>,,,,3,,<empty>
87929,BLOCK,-1,,<empty>,,,,3,,<empty>
87934,BLOCK,-1,,<empty>,,,,2,,<empty>
87941,BLOCK,-1,,<empty>,,,,4,,<empty>
87966,BLOCK,-1,,"{
    return container_of(libvlc, libvlc_priv_t, public_data);
}",1,,200,2,,void
87980,BLOCK,-1,,<empty>,,,,6,,<empty>
87985,BLOCK,-1,,<empty>,,,,2,,<empty>
87994,BLOCK,-1,,<empty>,,,,6,,<empty>
88001,BLOCK,-1,,<empty>,,,,4,,<empty>
88039,BLOCK,-1,,<empty>,,,,2,,<empty>
88046,BLOCK,-1,,<empty>,,,,4,,<empty>
88051,BLOCK,-1,,<empty>,,,,2,,<empty>
88057,BLOCK,-1,,<empty>,,,,3,,<empty>
88062,BLOCK,-1,,<empty>,,,,2,,<empty>
88079,BLOCK,-1,,<empty>,1,,1,1,,ANY
88082,BLOCK,-1,,"{
    return 0;
}",1,,131,2,,void
88105,BLOCK,-1,,<empty>,1,,1,1,,ANY
88108,BLOCK,-1,,"{
    static struct
    {
        vlc_mutex_t lock;
        char path[PATH_MAX];
    } cache = {
        VLC_STATIC_MUTEX, """",
    };

    /* Reading and parsing /proc/self/maps is slow, so cache the value since
     * it's guaranteed not to change during the life-time of the process. */
    vlc_mutex_lock(&cache.lock);
    if (cache.path[0] != '\0')
    {
        char *ret = strdup(cache.path);
        vlc_mutex_unlock(&cache.lock);
        return ret;
    }
    char *path = NULL;

    /* Find the path to libvlc (i.e. ourselves) */
    FILE *maps = fopen (""/proc/self/maps"", ""rte"");
    if (maps == NULL)
        goto error;

    char *line = NULL;
    size_t linelen = 0;
    uintptr_t needle = (uintptr_t)config_GetLibDir;

    for (;;)
    {
        ssize_t len = getline (&line, &linelen, maps);
        if (len == -1)
            break;

        void *start, *end;
        if (sscanf (line, ""%p-%p"", &start, &end) < 2)
            continue;
        /* This mapping contains the address...",1,,34,2,,void
88128,BLOCK,-1,,"{
        char *ret = strdup(cache.path);
        vlc_mutex_unlock(&cache.lock);
        return ret;
    }",5,,47,2,,void
88157,BLOCK,-1,,<empty>,9,,57,2,,void
88174,BLOCK,-1,,<empty>,5,,63,1,,void
88175,BLOCK,4,,"{
        ssize_t len = getline (&line, &linelen, maps);
        if (len == -1)
            break;

        void *start, *end;
        if (sscanf (line, ""%p-%p"", &start, &end) < 2)
            continue;
        /* This mapping contains the address of this function. */
        if (needle < (uintptr_t)start || (uintptr_t)end <= needle)
            continue;

        char *dir = strchr (line, '/');
        if (dir == NULL)
            continue;

        char *file = strrchr (line, '/');
        if (end == NULL)
            continue;
        *file = '\0';

        if (asprintf (&path, ""%s/""PACKAGE, dir) == -1)
            path = NULL;
        break;
    }",5,,64,4,,void
88190,BLOCK,-1,,<empty>,13,,67,2,,void
88204,BLOCK,-1,,<empty>,13,,71,2,,void
88218,BLOCK,-1,,<empty>,13,,74,2,,void
88230,BLOCK,-1,,<empty>,13,,78,2,,void
88242,BLOCK,-1,,<empty>,13,,82,2,,void
88250,BLOCK,-1,,<empty>,13,,86,2,,void
88264,BLOCK,-1,,<empty>,9,,94,2,,void
88282,BLOCK,-1,,<empty>,9,,96,2,,void
88299,BLOCK,-1,,"{
    const char *path = getenv (""VLC_DATA_PATH"");
    if (path != NULL)
        return strdup (path);

    char *libdir = config_GetLibDir ();
    if (libdir == NULL)
        return NULL; /* OOM */

    char *datadir = NULL;

    /* There are no clean ways to do this, are there?
     * Due to multilibs, we cannot simply append ../share/. */
    char *p = strstr (libdir, ""/lib/"");
    if (p != NULL)
    {
        char *p2;
        /* Deal with nested ""lib"" directories. Grmbl. */
        while ((p2 = strstr (p + 4, ""/lib/"")) != NULL)
            p = p2;
        *p = '\0';

        if (unlikely(asprintf (&datadir, ""%s/share/""PACKAGE, libdir) == -1))
            datadir = NULL;
    }
    free (libdir);
    return (datadir != NULL) ? datadir : strdup (PKGDATADIR);
}",1,,102,2,,void
88309,BLOCK,-1,,<empty>,9,,105,2,,void
88321,BLOCK,-1,,<empty>,9,,109,2,,void
88338,BLOCK,-1,,"{
        char *p2;
        /* Deal with nested ""lib"" directories. Grmbl. */
        while ((p2 = strstr (p + 4, ""/lib/"")) != NULL)
            p = p2;
        *p = '\0';

        if (unlikely(asprintf (&datadir, ""%s/share/""PACKAGE, libdir) == -1))
            datadir = NULL;
    }",5,,117,2,,void
88359,BLOCK,-1,,<empty>,13,,125,2,,void
88395,BLOCK,-1,,<empty>,1,,1,1,,ANY
88398,BLOCK,-1,,"{
    vlc_sem_post(val.sival_ptr);
}",1,,35,2,,void
88410,BLOCK,-1,,"{
    struct gaicb req =
    {
        .ar_name = name,
        .ar_service = NULL,
        .ar_request = hints,
    };
    char portbuf[6];
    vlc_sem_t done;

    if (port != 0)
    {
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.ar_service = portbuf;
    }

    struct sigevent sev =
    {
        .sigev_notify = SIGEV_THREAD,
        .sigev_value = { .sival_ptr = &done, },
        .sigev_notify_function = vlc_getaddrinfo_notify,
    };

    vlc_sem_init(&done, 0);

    int val = getaddrinfo_a(GAI_NOWAIT, &(struct gaicb *){ &req }, 1, &sev);
    if (val)
    {
        vlc_sem_destroy(&done);
        return val;
    }

    vlc_sem_wait_i11e(&done);

    if (gai_cancel(&req) == EAI_CANCELED)
        vlc_sem_wait(&done);

    while (gai_suspend(&(const struct gaicb *){ &req }, 1, NULL) == EAI_INTR);

    val = gai_error(&req);
    assert(val != EAI_INPROGRESS);
    vlc...",1,,42,5,,void
88415,BLOCK,1,,<empty>,9,,45,1,,void
88419,BLOCK,2,,<empty>,9,,46,2,,void
88423,BLOCK,3,,<empty>,9,,47,3,,void
88433,BLOCK,-1,,"{
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.ar_service = portbuf;
    }",5,,53,2,,void
88446,BLOCK,-1,,<empty>,13,,56,2,,void
88458,BLOCK,1,,<empty>,9,,63,1,,void
88462,BLOCK,2,,<empty>,9,,64,2,,void
88466,BLOCK,1,,<empty>,26,,64,1,,void
88471,BLOCK,3,,<empty>,9,,65,3,,void
88495,BLOCK,-1,,"{
        vlc_sem_destroy(&done);
        return val;
    }",5,,72,2,,void
88510,BLOCK,-1,,<empty>,9,,80,2,,void
88542,BLOCK,-1,,<empty>,9,,89,2,,void
88575,BLOCK,-1,,<empty>,1,,1,1,,ANY
88578,BLOCK,-1,,"{
     static __thread pid_t tid = 0;

     if (unlikely(tid == 0))
         tid = syscall(__NR_gettid);

     return tid;
}",1,,41,2,,void
88588,BLOCK,-1,,<empty>,10,,45,2,,void
88604,BLOCK,-1,,"{
    return syscall(__NR_futex, addr, op, val, to, addr2, val3);
}",1,,52,7,,void
88619,BLOCK,-1,,"{
    return sys_futex(addr, FUTEX_WAKE_PRIVATE, nr, NULL, NULL, 0);
}",1,,57,3,,void
88624,BLOCK,1,,<empty>,,,,1,,void
88636,BLOCK,-1,,"{
    return sys_futex(addr, FUTEX_WAIT_PRIVATE, val, to, NULL, 0);
}",1,,62,4,,void
88641,BLOCK,1,,<empty>,,,,1,,void
88651,BLOCK,-1,,"{
    vlc_futex_wake(addr, 1);
}",1,,67,2,,void
88659,BLOCK,-1,,"{
    vlc_futex_wake(addr, INT_MAX);
}",1,,72,2,,void
88668,BLOCK,-1,,"{
    vlc_futex_wait(addr, val, NULL);
}",1,,77,3,,void
88679,BLOCK,-1,,"{
    lldiv_t d = lldiv(delay, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return (vlc_futex_wait(addr, val, &ts) == 0 || errno != ETIMEDOUT);
}",1,,82,4,,void
88740,BLOCK,-1,,<empty>,1,,1,1,,ANY
88745,BLOCK,-1,,<empty>,,,,1,,<empty>
89025,BLOCK,-1,,"{
    const char *sa = key, *sb = elem;
    return strcmp (sa, sb);
}",1,,123,3,,void
89043,BLOCK,-1,,"{
    if (cp < (1 << 7))
    {
        buf[1] = 0;
        buf[0] = cp;
    }
    else if (cp < (1 << 11))
    {
        buf[2] = 0;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xC0 | cp;
    }
    else if (cp < (1 << 16))
    {
        buf[3] = 0;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else if (cp < (1 << 21))
    {
        buf[4] = 0;
        buf[3] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else
        return NULL;
    return buf;
}",1,,130,3,,void
89050,BLOCK,-1,,"{
        buf[1] = 0;
        buf[0] = cp;
    }",5,,132,2,,void
89062,BLOCK,-1,,<empty>,10,,136,1,,void
89069,BLOCK,-1,,"{
        buf[2] = 0;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xC0 | cp;
    }",5,,137,2,,void
89095,BLOCK,-1,,<empty>,10,,143,1,,void
89102,BLOCK,-1,,"{
        buf[3] = 0;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }",5,,144,2,,void
89140,BLOCK,-1,,<empty>,10,,152,1,,void
89147,BLOCK,-1,,"{
        buf[4] = 0;
        buf[3] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }",5,,153,2,,void
89197,BLOCK,-1,,<empty>,9,,164,1,,void
89206,BLOCK,-1,,"{
    uint_fast32_t mods = 0;
    uint32_t code;

    for (;;)
    {
        size_t len = strcspn (name, ""-+"");
        if (len == 0 || name[len] == '\0')
            break;

        if (len == 4 && !strncasecmp (name, ""Ctrl"", 4))
            mods |= KEY_MODIFIER_CTRL;
        if (len == 3 && !strncasecmp (name, ""Alt"", 3))
            mods |= KEY_MODIFIER_ALT;
        if (len == 5 && !strncasecmp (name, ""Shift"", 5))
            mods |= KEY_MODIFIER_SHIFT;
        if (len == 4 && !strncasecmp (name, ""Meta"", 4))
            mods |= KEY_MODIFIER_META;
        if (len == 7 && !strncasecmp (name, ""Command"", 7))
            mods |= KEY_MODIFIER_COMMAND;

        name += len + 1;
    }

    struct key_descriptor *d = bsearch (name, s_keys, KEYS_COUNT,
                                        sizeof (s_keys[0]), keystrcmp);
    if (d != NULL)
        code = d->i_code;
    else
    if (vlc_towc (name, &code) <= 0)
        code = KEY_UNSET;

    if (code != KEY_UNSET)
        code |= mods;
   ...",1,,176,2,,void
89213,BLOCK,-1,,<empty>,5,,180,1,,void
89214,BLOCK,4,,"{
        size_t len = strcspn (name, ""-+"");
        if (len == 0 || name[len] == '\0')
            break;

        if (len == 4 && !strncasecmp (name, ""Ctrl"", 4))
            mods |= KEY_MODIFIER_CTRL;
        if (len == 3 && !strncasecmp (name, ""Alt"", 3))
            mods |= KEY_MODIFIER_ALT;
        if (len == 5 && !strncasecmp (name, ""Shift"", 5))
            mods |= KEY_MODIFIER_SHIFT;
        if (len == 4 && !strncasecmp (name, ""Meta"", 4))
            mods |= KEY_MODIFIER_META;
        if (len == 7 && !strncasecmp (name, ""Command"", 7))
            mods |= KEY_MODIFIER_COMMAND;

        name += len + 1;
    }",5,,181,4,,void
89231,BLOCK,-1,,<empty>,13,,184,2,,void
89243,BLOCK,-1,,<empty>,13,,187,2,,void
89257,BLOCK,-1,,<empty>,13,,189,2,,void
89271,BLOCK,-1,,<empty>,13,,191,2,,void
89285,BLOCK,-1,,<empty>,13,,193,2,,void
89299,BLOCK,-1,,<empty>,13,,195,2,,void
89315,BLOCK,1,,<empty>,,,,3,,void
89332,BLOCK,-1,,<empty>,9,,203,2,,void
89339,BLOCK,-1,,<empty>,5,,205,1,,void
89347,BLOCK,-1,,<empty>,9,,206,2,,void
89355,BLOCK,-1,,<empty>,9,,209,2,,void
89365,BLOCK,-1,,"{
    return (char *)txt;
}",1,,214,2,,void
89375,BLOCK,-1,,"{
    char *(*tr) (const char *) = locale ? vlc_gettext : nooptext;
    const char *name;
    char *str, buf[5];
    uintptr_t key = code & ~KEY_MODIFIER;

    for (size_t i = 0; i < KEYS_COUNT; i++)
        if (s_keys[i].i_code == key)
        {
            name = s_keys[i].psz;
            goto found;
        }

    if (utf8_cp (key, buf) == NULL)
        return NULL;
    name = buf;

found:
    if (asprintf (&str, ""%s%s%s%s%s%s"",
                  (code & KEY_MODIFIER_CTRL) ? tr(N_(""Ctrl+"")) : """",
                  (code & KEY_MODIFIER_ALT) ? tr(N_(""Alt+"")) : """",
                  (code & KEY_MODIFIER_SHIFT) ? tr(N_(""Shift+"")) : """",
                  (code & KEY_MODIFIER_META) ? tr(N_(""Meta+"")) : """",
                  (code & KEY_MODIFIER_COMMAND) ? tr(N_(""Command+"")) : """",
                  tr(name)) == -1)
        return NULL;
    return str;
}",1,,227,3,,void
89378,BLOCK,-1,,<empty>,,,,2,,<empty>
89392,BLOCK,-1,,<empty>,5,,233,1,,void
89400,BLOCK,1,,<empty>,,,,3,,void
89418,BLOCK,-1,,"{
            name = s_keys[i].psz;
            goto found;
        }",9,,235,2,,void
89433,BLOCK,-1,,<empty>,9,,241,2,,void
89490,BLOCK,-1,,<empty>,9,,252,2,,void
89501,BLOCK,-1,,<empty>,,,,1,,<empty>
89504,BLOCK,1,,<empty>,,,,1,,void
89851,BLOCK,-1,,"{
    const struct mapping *ka = a, *kb = b;

    return (ka->key < kb->key) ? -1 : (ka->key > kb->key) ? +1 : 0;
}",1,,388,3,,void
89889,BLOCK,-1,,<empty>,,,,1,,<empty>
89899,BLOCK,-1,,"{
    void *const *map = d;
    const struct mapping **pent;
    uint32_t keycode = curkey.i_int;

    pent = tfind (&keycode, map, keycmp);
    if (pent == NULL)
        return VLC_SUCCESS;

    (void) varname;
    (void) prevkey;
    return var_SetInteger (obj, ""key-action"", (*pent)->action);
}",1,,403,6,,void
89922,BLOCK,-1,,<empty>,9,,410,2,,void
89945,BLOCK,-1,,"{
    struct mapping *entry = malloc (sizeof (*entry));
    if (entry == NULL)
        return ENOMEM;
    entry->key = keycode;
    entry->action = action;

    struct mapping **pent = tsearch (entry, map, keycmp);
    if (unlikely(pent == NULL))
        return ENOMEM;
    if (*pent != entry)
    {
        free (entry);
        return EEXIST;
    }
    return 0;
}",1,,421,4,,void
89957,BLOCK,-1,,<empty>,9,,424,2,,void
89982,BLOCK,-1,,<empty>,9,,430,2,,void
89990,BLOCK,-1,,"{
        free (entry);
        return EEXIST;
    }",5,,432,2,,void
90004,BLOCK,-1,,"{
    vlc_action_id_t amore = ACTIONID_NONE, aless = ACTIONID_NONE;

    switch (mode)
    {
        case 0: /* volume up/down */
            amore = ACTIONID_COMBO_VOL_FOV_UP;
            aless = ACTIONID_COMBO_VOL_FOV_DOWN;
            break;
        case 2: /* position latter/earlier */
            amore = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            break;
        case 3: /* position earlier/latter */
            amore = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            break;
    }

    if (amore != ACTIONID_NONE)
        add_mapping (map, kmore, amore);
    if (aless != ACTIONID_NONE)
        add_mapping (map, kless, aless);
}",1,,441,5,,void
90015,BLOCK,-1,,"{
        case 0: /* volume up/down */
            amore = ACTIONID_COMBO_VOL_FOV_UP;
            aless = ACTIONID_COMBO_VOL_FOV_DOWN;
            break;
        case 2: /* position latter/earlier */
            amore = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            break;
        case 3: /* position earlier/latter */
            amore = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            break;
    }",5,,445,2,,void
90047,BLOCK,-1,,<empty>,9,,461,2,,void
90056,BLOCK,-1,,<empty>,9,,463,2,,void
90068,BLOCK,-1,,"{
    char *keys = var_InheritString (obj, confname);
    if (keys == NULL)
        return;

    for (char *buf, *key = strtok_r (keys, ""\t"", &buf);
         key != NULL;
         key = strtok_r (NULL, ""\t"", &buf))
    {
        uint32_t code = vlc_str2keycode (key);
        if (code == KEY_UNSET)
        {
            msg_Warn (obj, ""Key \""%s\"" unrecognized"", key);
            continue;
        }

        if (add_mapping (map, code, action) == EEXIST)
            msg_Warn (obj, ""Key \""%s\"" bound to multiple actions"", key);
    }
    free (keys);
}",1,,475,5,,void
90079,BLOCK,-1,,<empty>,9,,478,2,,void
90082,BLOCK,-1,,<empty>,5,,480,1,,void
90102,BLOCK,4,,"{
        uint32_t code = vlc_str2keycode (key);
        if (code == KEY_UNSET)
        {
            msg_Warn (obj, ""Key \""%s\"" unrecognized"", key);
            continue;
        }

        if (add_mapping (map, code, action) == EEXIST)
            msg_Warn (obj, ""Key \""%s\"" bound to multiple actions"", key);
    }",5,,483,4,,void
90112,BLOCK,-1,,"{
            msg_Warn (obj, ""Key \""%s\"" unrecognized"", key);
            continue;
        }",9,,486,2,,void
90125,BLOCK,-1,,<empty>,13,,492,2,,void
90136,BLOCK,-1,,"{
    assert(libvlc != NULL);

    vlc_object_t *obj = VLC_OBJECT(libvlc);
    vlc_actions_t *as = malloc (sizeof (*as) + (1 + ACTIONS_COUNT)
                      * sizeof (*as->ppsz_keys));

    if (unlikely(as == NULL))
        return VLC_ENOMEM;
    as->map = NULL;
    as->global_map = NULL;

    var_Create (obj, ""key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""global-key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""key-action"", VLC_VAR_INTEGER);

    /* Initialize from configuration */
    for (size_t i = 0; i < ACTIONS_COUNT; i++)
    {
#ifndef NDEBUG
        if (i > 0
         && strcmp (s_names2actions[i-1].psz, s_names2actions[i].psz) >= 0)
        {
            msg_Err (libvlc, ""key-%s and key-%s are not ordered properly"",
                     s_names2actions[i-1].psz, s_names2actions[i].psz);
            abort ();
        }
#endif
        as->ppsz_keys[i] = s_names2actions[i].psz;

        char name[12 + MAXACTION];

        snprintf (name, sizeof (name), ""glob...",1,,501,2,,void
90158,BLOCK,1,,<empty>,,,,3,,void
90176,BLOCK,-1,,<empty>,9,,509,2,,void
90202,BLOCK,-1,,<empty>,5,,518,1,,void
90210,BLOCK,1,,<empty>,,,,3,,void
90220,BLOCK,4,,"{
#ifndef NDEBUG
        if (i > 0
         && strcmp (s_names2actions[i-1].psz, s_names2actions[i].psz) >= 0)
        {
            msg_Err (libvlc, ""key-%s and key-%s are not ordered properly"",
                     s_names2actions[i-1].psz, s_names2actions[i].psz);
            abort ();
        }
#endif
        as->ppsz_keys[i] = s_names2actions[i].psz;

        char name[12 + MAXACTION];

        snprintf (name, sizeof (name), ""global-key-%s"", s_names2actions[i].psz);
        init_action (obj, &as->map, name + 7, s_names2actions[i].id);
        init_action (obj, &as->global_map, name, s_names2actions[i].id);
    }",5,,519,4,,void
90241,BLOCK,-1,,"{
            msg_Err (libvlc, ""key-%s and key-%s are not ordered properly"",
                     s_names2actions[i-1].psz, s_names2actions[i].psz);
            abort ();
        }",9,,523,2,,void
90312,BLOCK,1,,<empty>,,,,3,,void
90369,BLOCK,-1,,"{
    assert(libvlc != NULL);

    vlc_actions_t *as = libvlc_priv(libvlc)->actions;
    if (unlikely(as == NULL))
        return;

    var_DelCallback (libvlc, ""global-key-pressed"", vlc_key_to_action,
                     &as->global_map);
    var_DelCallback (libvlc, ""key-pressed"", vlc_key_to_action, &as->map);

    tdestroy (as->global_map, free);
    tdestroy (as->map, free);
    free (as);
    libvlc_priv(libvlc)->actions = NULL;
}",1,,556,2,,void
90386,BLOCK,-1,,<empty>,9,,561,2,,void
90427,BLOCK,-1,,"{
    const struct name2action *act = ent;
    return strcmp(key, act->psz);
}",1,,575,3,,void
90442,BLOCK,-1,,"{
    const struct name2action *act;

    if (strncmp (name, ""key-"", 4))
        return ACTIONID_NONE;
    name += 4;

    act = bsearch(name, s_names2actions, ACTIONS_COUNT, sizeof(*act), actcmp);
    return (act != NULL) ? act->id : ACTIONID_NONE;
}",1,,586,2,,void
90449,BLOCK,-1,,<empty>,9,,590,2,,void
90461,BLOCK,1,,<empty>,,,,3,,void
90489,BLOCK,-1,,"{
    char varname[12 /* ""global-key-"" */ + strlen( psz_key_name )];
    sprintf( varname, ""%skey-%s"", b_global ? ""global-"" : """", psz_key_name );

    *pp_keycodes = NULL;

    char *psz_keys = var_InheritString( p_obj, varname );
    if( psz_keys == NULL )
        return 0;

    size_t i_nb_keycodes = 0;
    for( const char* psz_it = psz_keys; *psz_it; ++psz_it )
    {
        if( *psz_it == '\t' )
            ++i_nb_keycodes;
    }
    ++i_nb_keycodes;
    *pp_keycodes = vlc_alloc( i_nb_keycodes, sizeof( **pp_keycodes ) );
    if( unlikely( !*pp_keycodes ) )
    {
        free( psz_keys );
        return 0;
    }
    size_t i = 0;
    for( char *buf, *key = strtok_r( psz_keys, ""\t"", &buf );
         key != NULL;
         key = strtok_r( NULL, ""\t"", &buf ), ++i )
    {
        (*pp_keycodes)[i] = vlc_str2keycode( key );
    }
    assert( i == i_nb_keycodes );
    free( psz_keys );
    return i_nb_keycodes;
}",1,,601,5,,void
90513,BLOCK,-1,,<empty>,9,,609,2,,void
90521,BLOCK,-1,,<empty>,5,,612,1,,void
90530,BLOCK,4,,"{
        if( *psz_it == '\t' )
            ++i_nb_keycodes;
    }",5,,613,4,,void
90536,BLOCK,-1,,<empty>,13,,615,2,,void
90555,BLOCK,-1,,"{
        free( psz_keys );
        return 0;
    }",5,,620,2,,void
90565,BLOCK,-1,,<empty>,5,,625,1,,void
90588,BLOCK,4,,"{
        (*pp_keycodes)[i] = vlc_str2keycode( key );
    }",5,,628,4,,void
90608,BLOCK,-1,,"{
    vlc_actions_t *as = libvlc_priv(p_obj->obj.libvlc)->actions;
    return as->ppsz_keys;
}",1,,639,2,,void
90646,BLOCK,-1,,<empty>,1,,1,1,,ANY
90661,BLOCK,-1,,<empty>,,,,2,,<empty>
90668,BLOCK,-1,,<empty>,,,,2,,<empty>
90682,BLOCK,-1,,<empty>,,,,2,,<empty>
90690,BLOCK,-1,,<empty>,,,,2,,<empty>
90695,BLOCK,-1,,<empty>,,,,2,,<empty>
90700,BLOCK,-1,,"{
    addon_entry_owner_t *owner = calloc( 1, sizeof(addon_entry_owner_t) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    addon_entry_t *p_entry = &owner->entry;
    vlc_mutex_init( &p_entry->lock );
    ARRAY_INIT( p_entry->files );
    return p_entry;
}",1,,78,2,,void
90713,BLOCK,-1,,<empty>,9,,81,2,,void
90744,BLOCK,-1,,"{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    atomic_fetch_add( &owner->refs, 1 );
    return p_entry;
}",1,,92,2,,void
90763,BLOCK,-1,,"{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    free( p_entry->psz_name );
    free( p_entry->psz_summary );
    free( p_entry->psz_description );
    free( p_entry->psz_archive_uri );
    free( p_entry->psz_author );
    free( p_entry->psz_source_uri );
    free( p_entry->psz_image_uri );
    free( p_entry->psz_image_data );
    free( p_entry->psz_source_module );
    free( p_entry->psz_version );
    free( p_entry->p_custom );

    addon_file_t *p_file;
    FOREACH_ARRAY( p_file, p_entry->files )
    free( p_file->psz_filename );
    free( p_file->psz_download_uri );
    free( p_file );
    FOREACH_END()
    ARRAY_RESET( p_entry->files );

    vlc_mutex_destroy( &p_entry->lock );
    free( owner );
}",1,,100,2,,void
90779,BLOCK,-1,,<empty>,9,,104,2,,void
90860,BLOCK,-1,,"{
    addons_manager_t *p_manager = malloc( sizeof(addons_manager_t) );
    if ( !p_manager ) return NULL;

    p_manager->p_priv = malloc( sizeof(addons_manager_private_t) );
    if ( !p_manager->p_priv )
    {
        free( p_manager );
        return NULL;
    }

    p_manager->owner = *owner;
    p_manager->p_priv->p_parent = p_this;

    p_manager->p_priv->finder.p_interrupt = vlc_interrupt_create();
    p_manager->p_priv->installer.p_interrupt = vlc_interrupt_create();
    if ( !p_manager->p_priv->finder.p_interrupt ||
         !p_manager->p_priv->installer.p_interrupt )
    {
        if( p_manager->p_priv->finder.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->finder.p_interrupt );
        if( p_manager->p_priv->installer.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->installer.p_interrupt );
        free( p_manager->p_priv );
        free( p_manager );
        return NULL;
    }

#define INIT_QUEUE( name ) \
    p_manager->p_priv->nam...",1,,132,3,,void
90870,BLOCK,-1,,<empty>,23,,134,2,,void
90885,BLOCK,-1,,"{
        free( p_manager );
        return NULL;
    }",5,,138,2,,void
90939,BLOCK,-1,,"{
        if( p_manager->p_priv->finder.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->finder.p_interrupt );
        if( p_manager->p_priv->installer.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->installer.p_interrupt );
        free( p_manager->p_priv );
        free( p_manager );
        return NULL;
    }",5,,150,2,,void
90948,BLOCK,-1,,<empty>,13,,152,2,,void
90965,BLOCK,-1,,<empty>,13,,154,2,,void
90983,BLOCK,1,,<empty>,,,,2,,void
91020,BLOCK,1,,<empty>,,,,2,,void
91070,BLOCK,-1,,"{
    bool b_live;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    b_live = p_manager->p_priv->finder.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->finder.p_interrupt );
        vlc_join( p_manager->p_priv->finder.thread, NULL );
    }

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    b_live = p_manager->p_priv->installer.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->installer.p_interrupt );
        vlc_join( p_manager->p_priv->installer.thread, NULL );
    }

#define FREE_QUEUE( name ) \
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->name.entries )\
        addon_entry_Release( p_entry );\
    FOREACH_END();\
    ARRAY_RESET( p_manager->p_priv->name.entries );\
    vlc_mutex_destroy( &p_manager->p_priv->name.lock );\
    vlc_cond_destroy( &p_manager->p_priv->name...",1,,174,2,,void
91101,BLOCK,-1,,"{
        vlc_interrupt_kill( p_manager->p_priv->finder.p_interrupt );
        vlc_join( p_manager->p_priv->finder.thread, NULL );
    }",5,,181,2,,void
91148,BLOCK,-1,,"{
        vlc_interrupt_kill( p_manager->p_priv->installer.p_interrupt );
        vlc_join( p_manager->p_priv->installer.thread, NULL );
    }",5,,190,2,,void
91167,BLOCK,1,,<empty>,,,,1,,void
91218,BLOCK,1,,<empty>,,,,1,,void
91289,BLOCK,-1,,"{
    if ( !psz_uri )
        return;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );

    ARRAY_APPEND( p_manager->p_priv->finder.uris, strdup( psz_uri ) );

    if( !p_manager->p_priv->finder.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->finder.thread, FinderThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn entries provider thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
            return;
        }
        p_manager->p_priv->finder.b_live = true;
    }

    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
}",1,,216,3,,void
91293,BLOCK,-1,,<empty>,9,,218,2,,void
91323,BLOCK,-1,,"{
        if( vlc_clone( &p_manager->p_priv->finder.thread, FinderThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn entries provider thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
            return;
        }
        p_manager->p_priv->finder.b_live = true;
    }",5,,225,2,,void
91337,BLOCK,-1,,"{
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn entries provider thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
            return;
        }",9,,228,2,,void
91387,BLOCK,-1,,"{
    addon_entry_t *p_return = NULL;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->finder.entries )
    if ( !memcmp( p_entry->uuid, uuid, sizeof( addon_uuid_t ) ) )
    {
        p_return = p_entry;
        addon_entry_Hold( p_return );
        break;
    }
    FOREACH_END()
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    return p_return;
}",1,,247,3,,void
91422,BLOCK,-1,,"{
        p_return = p_entry;
        addon_entry_Hold( p_return );
        break;
    }",5,,252,2,,void
91448,BLOCK,-1,,"{
    addon_entry_t *p_entry, *p_manager_entry;
    addon_uuid_t zerouuid;
    memset( zerouuid, 0, sizeof( addon_uuid_t ) );
    for ( int i=0; i < i_count; i++ )
    {
        p_entry = pp_addons[i];
        vlc_mutex_lock( &p_entry->lock );
        if ( memcmp( p_entry->uuid, zerouuid, sizeof( addon_uuid_t ) ) )
            p_manager_entry = getHeldEntryByUUID( p_manager, p_entry->uuid );
        else
            p_manager_entry = NULL;
        if ( !p_manager_entry )
        {
            ARRAY_APPEND( p_manager->p_priv->finder.entries, p_entry );
            p_manager->owner.addon_found( p_manager, p_entry );
        }
        else
        {
            vlc_mutex_lock( &p_manager_entry->lock );
            if ( ( p_manager_entry->psz_version && p_entry->psz_version )
                 && /* FIXME: better version comparison */
                 strcmp( p_manager_entry->psz_version, p_entry->psz_version )
                 )
            {
                p_manager_entry->e_flags |= ...",1,,264,4,,void
91458,BLOCK,-1,,<empty>,5,,268,1,,void
91468,BLOCK,4,,"{
        p_entry = pp_addons[i];
        vlc_mutex_lock( &p_entry->lock );
        if ( memcmp( p_entry->uuid, zerouuid, sizeof( addon_uuid_t ) ) )
            p_manager_entry = getHeldEntryByUUID( p_manager, p_entry->uuid );
        else
            p_manager_entry = NULL;
        if ( !p_manager_entry )
        {
            ARRAY_APPEND( p_manager->p_priv->finder.entries, p_entry );
            p_manager->owner.addon_found( p_manager, p_entry );
        }
        else
        {
            vlc_mutex_lock( &p_manager_entry->lock );
            if ( ( p_manager_entry->psz_version && p_entry->psz_version )
                 && /* FIXME: better version comparison */
                 strcmp( p_manager_entry->psz_version, p_entry->psz_version )
                 )
            {
                p_manager_entry->e_flags |= ADDON_UPDATABLE;
            }
            vlc_mutex_unlock( &p_manager_entry->lock );
            addon_entry_Release( p_manager_entry );
        }
        vlc_mutex_u...",5,,269,4,,void
91487,BLOCK,-1,,<empty>,13,,273,2,,void
91496,BLOCK,-1,,<empty>,13,,275,1,,void
91503,BLOCK,-1,,"{
            ARRAY_APPEND( p_manager->p_priv->finder.entries, p_entry );
            p_manager->owner.addon_found( p_manager, p_entry );
        }",9,,277,2,,void
91522,BLOCK,-1,,"{
            vlc_mutex_lock( &p_manager_entry->lock );
            if ( ( p_manager_entry->psz_version && p_entry->psz_version )
                 && /* FIXME: better version comparison */
                 strcmp( p_manager_entry->psz_version, p_entry->psz_version )
                 )
            {
                p_manager_entry->e_flags |= ADDON_UPDATABLE;
            }
            vlc_mutex_unlock( &p_manager_entry->lock );
            addon_entry_Release( p_manager_entry );
        }",9,,282,1,,void
91544,BLOCK,-1,,"{
                p_manager_entry->e_flags |= ADDON_UPDATABLE;
            }",13,,288,2,,void
91566,BLOCK,-1,,"{
    addons_finder_t *p_finder =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_finder ), ""entries finder"" );
    p_finder->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_finder, ""addons finder"",
                                      ""addons.store.list"", true );
    if( p_module )
    {
        ARRAY_INIT( p_finder->entries );
        p_finder->psz_uri = NULL;
        p_finder->pf_find( p_finder );
        module_unneed( p_finder, p_module );

        MergeSources( p_manager, p_finder->entries.p_elems, p_finder->entries.i_size );

        ARRAY_RESET( p_finder->entries );
    }
    vlc_object_release( p_finder );
}",1,,299,2,,void
91576,BLOCK,1,,<empty>,,,,3,,void
91605,BLOCK,-1,,"{
        ARRAY_INIT( p_finder->entries );
        p_finder->psz_uri = NULL;
        p_finder->pf_find( p_finder );
        module_unneed( p_finder, p_module );

        MergeSources( p_manager, p_finder->entries.p_elems, p_finder->entries.i_size );

        ARRAY_RESET( p_finder->entries );
    }",5,,307,2,,void
91645,BLOCK,-1,,"{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    p_manager->p_priv->finder.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
}",1,,321,2,,void
91690,BLOCK,-1,,"{
    addons_manager_t *p_manager = p_data;
    int i_cancel = vlc_savecancel();
    vlc_interrupt_set( p_manager->p_priv->finder.p_interrupt );

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    while( p_manager->p_priv->finder.b_live )
    {
        char *psz_uri;

        vlc_interrupt_register( finder_thread_interrupted, p_data );
        while( p_manager->p_priv->finder.uris.i_size == 0 &&
               p_manager->p_priv->finder.b_live )
        {
            vlc_cond_wait( &p_manager->p_priv->finder.waitcond,
                           &p_manager->p_priv->finder.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->finder.b_live )
            break;
        psz_uri = p_manager->p_priv->finder.uris.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->finder.uris, 0 );

        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );

        addons_finder_t *p_finder =
                vlc_custom_create( p_manager->p_priv->p_parent, sizeof( ...",1,,330,2,,void
91724,BLOCK,-1,,"{
        char *psz_uri;

        vlc_interrupt_register( finder_thread_interrupted, p_data );
        while( p_manager->p_priv->finder.uris.i_size == 0 &&
               p_manager->p_priv->finder.b_live )
        {
            vlc_cond_wait( &p_manager->p_priv->finder.waitcond,
                           &p_manager->p_priv->finder.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->finder.b_live )
            break;
        psz_uri = p_manager->p_priv->finder.uris.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->finder.uris, 0 );

        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );

        addons_finder_t *p_finder =
                vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_finder ), ""entries finder"" );

        if( p_finder != NULL )
        {
            p_finder->obj.flags |= OBJECT_FLAGS_NOINTERACT;
            module_t *p_module;
            ARRAY_INIT( p_finder->entries );
            p_finder->psz_uri = psz_uri...",5,,337,2,,void
91749,BLOCK,-1,,"{
            vlc_cond_wait( &p_manager->p_priv->finder.waitcond,
                           &p_manager->p_priv->finder.lock );
        }",9,,343,2,,void
91777,BLOCK,-1,,<empty>,13,,349,2,,void
91819,BLOCK,1,,<empty>,,,,4,,void
91835,BLOCK,-1,,"{
            p_finder->obj.flags |= OBJECT_FLAGS_NOINTERACT;
            module_t *p_module;
            ARRAY_INIT( p_finder->entries );
            p_finder->psz_uri = psz_uri;

            p_module = module_need( p_finder, ""addons finder"", NULL, false );
            if( p_module )
            {
                p_finder->pf_find( p_finder );
                module_unneed( p_finder, p_module );
                MergeSources( p_manager, p_finder->entries.p_elems, p_finder->entries.i_size );
            }
            ARRAY_RESET( p_finder->entries );
            free( psz_uri );
            vlc_object_release( p_finder );
        }",9,,359,2,,void
91862,BLOCK,-1,,"{
                p_finder->pf_find( p_finder );
                module_unneed( p_finder, p_module );
                MergeSources( p_manager, p_finder->entries.p_elems, p_finder->entries.i_size );
            }",13,,367,2,,void
91924,BLOCK,-1,,"{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        vlc_mutex_lock( &p_manager->p_priv->finder.lock );
        i_return = p_storage->pf_catalog( p_storage, p_manager->p_priv->finder.entries.p_elems,
                                          p_manager->p_priv->finder.entries.i_size );
        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
        module_unneed( p_storage, p_module );
    }
    vlc_object_release( p_storage );

    return i_return;
}",1,,387,2,,void
91938,BLOCK,1,,<empty>,,,,3,,void
91967,BLOCK,-1,,"{
        vlc_mutex_lock( &p_manager->p_priv->finder.lock );
        i_return = p_storage->pf_catalog( p_storage, p_manager->p_priv->finder.entries.p_elems,
                                          p_manager->p_priv->finder.entries.i_size );
        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
        module_unneed( p_storage, p_module );
    }",5,,397,2,,void
92022,BLOCK,-1,,"{
    LoadLocalStorage( p_manager );
    return VLC_SUCCESS;
}",1,,410,2,,void
92033,BLOCK,-1,,"{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        if ( b_install )
            i_return = p_storage->pf_install( p_storage, p_entry );
        else
            i_return = p_storage->pf_remove( p_storage, p_entry );
        module_unneed( p_storage, p_module );
        msg_Dbg( p_manager->p_priv->p_parent, ""InstallAddon returns %d"", i_return );
        if ( i_return == VLC_SUCCESS )
        {
            /* Reset flags */
            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_flags = ADDON_MANAGEABLE;
            vlc_mutex_unlock( &p_entry->lock );
        }
    }
    vlc_object_release( p_storage );

    return i_return;
}",1,,416,4,,void
92047,BLOCK,1,,<empty>,,,,3,,void
92076,BLOCK,-1,,"{
        if ( b_install )
            i_return = p_storage->pf_install( p_storage, p_entry );
        else
            i_return = p_storage->pf_remove( p_storage, p_entry );
        module_unneed( p_storage, p_module );
        msg_Dbg( p_manager->p_priv->p_parent, ""InstallAddon returns %d"", i_return );
        if ( i_return == VLC_SUCCESS )
        {
            /* Reset flags */
            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_flags = ADDON_MANAGEABLE;
            vlc_mutex_unlock( &p_entry->lock );
        }
    }",5,,426,2,,void
92079,BLOCK,-1,,<empty>,13,,428,2,,void
92089,BLOCK,-1,,<empty>,13,,430,1,,void
92113,BLOCK,-1,,"{
            /* Reset flags */
            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_flags = ADDON_MANAGEABLE;
            vlc_mutex_unlock( &p_entry->lock );
        }",9,,434,2,,void
92137,BLOCK,-1,,"{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    p_manager->p_priv->installer.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
}",1,,447,2,,void
92182,BLOCK,-1,,"{
    addons_manager_t *p_manager = p_data;
    int i_cancel = vlc_savecancel();
    vlc_interrupt_set( p_manager->p_priv->installer.p_interrupt );
    int i_ret;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    while( p_manager->p_priv->installer.b_live )
    {
        vlc_interrupt_register( installer_thread_interrupted, p_data );
        while ( !p_manager->p_priv->installer.entries.i_size &&
                p_manager->p_priv->installer.b_live )
        {
            /* No queued addons */
            vlc_cond_wait( &p_manager->p_priv->installer.waitcond,
                           &p_manager->p_priv->installer.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->installer.b_live )
            break;

        addon_entry_t *p_entry = p_manager->p_priv->installer.entries.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->installer.entries, 0 );
        addon_entry_Hold( p_entry );
        vlc_mutex_unlock( &p_manager->p_priv->instal...",1,,456,2,,void
92217,BLOCK,-1,,"{
        vlc_interrupt_register( installer_thread_interrupted, p_data );
        while ( !p_manager->p_priv->installer.entries.i_size &&
                p_manager->p_priv->installer.b_live )
        {
            /* No queued addons */
            vlc_cond_wait( &p_manager->p_priv->installer.waitcond,
                           &p_manager->p_priv->installer.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->installer.b_live )
            break;

        addon_entry_t *p_entry = p_manager->p_priv->installer.entries.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->installer.entries, 0 );
        addon_entry_Hold( p_entry );
        vlc_mutex_unlock( &p_manager->p_priv->installer.lock );

        vlc_mutex_lock( &p_entry->lock );
        /* DO WORK */
        if ( p_entry->e_state == ADDON_INSTALLED )
        {
            p_entry->e_state = ADDON_UNINSTALLING;
            vlc_mutex_unlock( &p_entry->lock );

            /* notify */
            ...",5,,464,2,,void
92240,BLOCK,-1,,"{
            /* No queued addons */
            vlc_cond_wait( &p_manager->p_priv->installer.waitcond,
                           &p_manager->p_priv->installer.lock );
        }",9,,468,2,,void
92268,BLOCK,-1,,<empty>,13,,475,2,,void
92315,BLOCK,-1,,"{
            p_entry->e_state = ADDON_UNINSTALLING;
            vlc_mutex_unlock( &p_entry->lock );

            /* notify */
            p_manager->owner.addon_changed( p_manager, p_entry );

            i_ret = installOrRemoveAddon( p_manager, p_entry, false );

            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_state = ( i_ret == VLC_SUCCESS ) ? ADDON_NOTINSTALLED
                                                        : ADDON_INSTALLED;
        }",9,,485,2,,void
92356,BLOCK,-1,,<empty>,14,,498,1,,void
92363,BLOCK,-1,,"{
            p_entry->e_state = ADDON_INSTALLING;
            vlc_mutex_unlock( &p_entry->lock );

            /* notify */
            p_manager->owner.addon_changed( p_manager, p_entry );

            i_ret = installOrRemoveAddon( p_manager, p_entry, true );

            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_state = ( i_ret == VLC_SUCCESS ) ? ADDON_INSTALLED
                                                        : ADDON_NOTINSTALLED;
        }",9,,499,2,,void
92447,BLOCK,-1,,"{
    if ( p_entry->e_type == ADDON_UNKNOWN ||
         p_entry->e_type == ADDON_PLUGIN ||
         p_entry->e_type == ADDON_OTHER )
        return VLC_EBADVAR;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    ARRAY_APPEND( p_manager->p_priv->installer.entries, p_entry );
    if( !p_manager->p_priv->installer.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->installer.thread, InstallerThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn addons installer thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
            return VLC_EGENERIC;
        }
        else
            p_manager->p_priv->installer.b_live = true;
    }
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    return VLC_SUCCESS;
}",1,,528,3,,void
92466,BLOCK,-1,,<empty>,9,,532,2,,void
92496,BLOCK,-1,,"{
        if( vlc_clone( &p_manager->p_priv->installer.thread, InstallerThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn addons installer thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
            return VLC_EGENERIC;
        }
        else
            p_manager->p_priv->installer.b_live = true;
    }",5,,537,2,,void
92510,BLOCK,-1,,"{
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn addons installer thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
            return VLC_EGENERIC;
        }",9,,540,2,,void
92530,BLOCK,-1,,<empty>,13,,547,1,,void
92565,BLOCK,-1,,"{
    addon_entry_t *p_install_entry = getHeldEntryByUUID( p_manager, uuid );
    if ( ! p_install_entry ) return VLC_EGENERIC;
    int i_ret = InstallEntry( p_manager, p_install_entry );
    addon_entry_Release( p_install_entry );
    return i_ret;
}",1,,555,3,,void
92575,BLOCK,-1,,<empty>,30,,557,2,,void
92593,BLOCK,-1,,"{
    return addons_manager_Install( p_manager, uuid );
}",1,,564,3,,void
92618,BLOCK,-1,,<empty>,1,,1,1,,ANY
92642,BLOCK,-1,,"{
    struct background_worker* worker = data;

    for( ;; )
    {
        struct bg_queued_item* item = NULL;
        void* handle;

        vlc_mutex_lock( &worker->lock );
        for( ;; )
        {
            if( vlc_array_count( &worker->tail.data ) )
            {
                item = vlc_array_item_at_index( &worker->tail.data, 0 );
                handle = NULL;

                vlc_array_remove( &worker->tail.data, 0 );
            }

            if( worker->head.deadline == VLC_TS_0 && item == NULL )
                worker->head.active = false;
            worker->head.id = item ? item->id : NULL;
            vlc_cond_broadcast( &worker->head.wait );

            if( item )
            {
                if( item->timeout > 0 )
                    worker->head.deadline = mdate() + item->timeout * 1000;
                else
                    worker->head.deadline = INT64_MAX;
            }
            else if( worker->head.deadline != VLC_TS_0 )
            {
        ...",1,,58,2,,void
92648,BLOCK,-1,,<empty>,5,,61,1,,void
92649,BLOCK,4,,"{
        struct bg_queued_item* item = NULL;
        void* handle;

        vlc_mutex_lock( &worker->lock );
        for( ;; )
        {
            if( vlc_array_count( &worker->tail.data ) )
            {
                item = vlc_array_item_at_index( &worker->tail.data, 0 );
                handle = NULL;

                vlc_array_remove( &worker->tail.data, 0 );
            }

            if( worker->head.deadline == VLC_TS_0 && item == NULL )
                worker->head.active = false;
            worker->head.id = item ? item->id : NULL;
            vlc_cond_broadcast( &worker->head.wait );

            if( item )
            {
                if( item->timeout > 0 )
                    worker->head.deadline = mdate() + item->timeout * 1000;
                else
                    worker->head.deadline = INT64_MAX;
            }
            else if( worker->head.deadline != VLC_TS_0 )
            {
                /* Wait 1 seconds for new inputs before terminating */
   ...",5,,62,4,,void
92661,BLOCK,-1,,<empty>,9,,67,1,,void
92662,BLOCK,4,,"{
            if( vlc_array_count( &worker->tail.data ) )
            {
                item = vlc_array_item_at_index( &worker->tail.data, 0 );
                handle = NULL;

                vlc_array_remove( &worker->tail.data, 0 );
            }

            if( worker->head.deadline == VLC_TS_0 && item == NULL )
                worker->head.active = false;
            worker->head.id = item ? item->id : NULL;
            vlc_cond_broadcast( &worker->head.wait );

            if( item )
            {
                if( item->timeout > 0 )
                    worker->head.deadline = mdate() + item->timeout * 1000;
                else
                    worker->head.deadline = INT64_MAX;
            }
            else if( worker->head.deadline != VLC_TS_0 )
            {
                /* Wait 1 seconds for new inputs before terminating */
                mtime_t deadline = mdate() + INT64_C(1000000);
                int ret = vlc_cond_timedwait( &worker->tail.wait,
          ...",9,,68,4,,void
92671,BLOCK,-1,,"{
                item = vlc_array_item_at_index( &worker->tail.data, 0 );
                handle = NULL;

                vlc_array_remove( &worker->tail.data, 0 );
            }",13,,70,2,,void
92705,BLOCK,-1,,<empty>,17,,78,2,,void
92734,BLOCK,-1,,"{
                if( item->timeout > 0 )
                    worker->head.deadline = mdate() + item->timeout * 1000;
                else
                    worker->head.deadline = INT64_MAX;
            }",13,,83,2,,void
92741,BLOCK,-1,,<empty>,21,,85,2,,void
92756,BLOCK,-1,,<empty>,21,,87,1,,void
92765,BLOCK,-1,,<empty>,18,,89,1,,void
92774,BLOCK,-1,,"{
                /* Wait 1 seconds for new inputs before terminating */
                mtime_t deadline = mdate() + INT64_C(1000000);
                int ret = vlc_cond_timedwait( &worker->tail.wait,
                                              &worker->lock, deadline );
                if( ret != 0 )
                {
                    /* Timeout: if there is still no items, the thread will be
                     * terminated at next loop iteration (active = false). */
                    worker->head.deadline = VLC_TS_0;
                }
                continue;
            }",13,,90,2,,void
92801,BLOCK,-1,,"{
                    /* Timeout: if there is still no items, the thread will be
                     * terminated at next loop iteration (active = false). */
                    worker->head.deadline = VLC_TS_0;
                }",17,,96,2,,void
92818,BLOCK,-1,,"{
            vlc_mutex_unlock( &worker->lock );
            break;
        }",9,,107,2,,void
92849,BLOCK,-1,,"{
            worker->conf.pf_release( item->entity );
            free( item );
            continue;
        }",9,,116,2,,void
92863,BLOCK,-1,,<empty>,9,,122,1,,void
92864,BLOCK,4,,"{
            vlc_mutex_lock( &worker->lock );

            bool const b_timeout = worker->head.deadline <= mdate();
            worker->head.probe_request = false;

            vlc_mutex_unlock( &worker->lock );

            if( b_timeout ||
                worker->conf.pf_probe( worker->owner, handle ) )
            {
                worker->conf.pf_stop( worker->owner, handle );
                worker->conf.pf_release( item->entity );
                free( item );
                break;
            }

            vlc_mutex_lock( &worker->lock );
            if( worker->head.probe_request == false &&
                worker->head.deadline > mdate() )
            {
                vlc_cond_timedwait( &worker->head.worker_wait, &worker->lock,
                                     worker->head.deadline );
            }
            vlc_mutex_unlock( &worker->lock );
        }",9,,123,4,,void
92905,BLOCK,-1,,"{
                worker->conf.pf_stop( worker->owner, handle );
                worker->conf.pf_release( item->entity );
                free( item );
                break;
            }",13,,133,2,,void
92949,BLOCK,-1,,"{
                vlc_cond_timedwait( &worker->head.worker_wait, &worker->lock,
                                     worker->head.deadline );
            }",13,,143,2,,void
92978,BLOCK,-1,,"{
    vlc_mutex_lock( &worker->lock );
    for( size_t i = 0; i < vlc_array_count( &worker->tail.data ); )
    {
        struct bg_queued_item* item =
            vlc_array_item_at_index( &worker->tail.data, i );

        if( id == NULL || item->id == id )
        {
            vlc_array_remove( &worker->tail.data, i );
            worker->conf.pf_release( item->entity );
            free( item );
            continue;
        }

        ++i;
    }

    while( ( id == NULL && worker->head.active )
        || ( id != NULL && worker->head.id == id ) )
    {
        worker->head.deadline = VLC_TS_0;
        vlc_cond_signal( &worker->head.worker_wait );
        vlc_cond_signal( &worker->tail.wait );
        vlc_cond_wait( &worker->head.wait, &worker->lock );
    }
    vlc_mutex_unlock( &worker->lock );
}",1,,155,3,,void
92985,BLOCK,-1,,<empty>,5,,157,1,,void
92999,BLOCK,4,,"{
        struct bg_queued_item* item =
            vlc_array_item_at_index( &worker->tail.data, i );

        if( id == NULL || item->id == id )
        {
            vlc_array_remove( &worker->tail.data, i );
            worker->conf.pf_release( item->entity );
            free( item );
            continue;
        }

        ++i;
    }",5,,158,4,,void
93021,BLOCK,-1,,"{
            vlc_array_remove( &worker->tail.data, i );
            worker->conf.pf_release( item->entity );
            free( item );
            continue;
        }",9,,163,2,,void
93066,BLOCK,-1,,"{
        worker->head.deadline = VLC_TS_0;
        vlc_cond_signal( &worker->head.worker_wait );
        vlc_cond_signal( &worker->tail.wait );
        vlc_cond_wait( &worker->head.wait, &worker->lock );
    }",5,,175,2,,void
93109,BLOCK,-1,,"{
    struct background_worker* worker = malloc( sizeof *worker );

    if( unlikely( !worker ) )
        return NULL;

    worker->conf = *conf;
    worker->owner = owner;
    worker->head.id = NULL;
    worker->head.active = false;
    worker->head.deadline = VLC_TS_INVALID;

    vlc_mutex_init( &worker->lock );
    vlc_cond_init( &worker->head.wait );
    vlc_cond_init( &worker->head.worker_wait );

    vlc_array_init( &worker->tail.data );
    vlc_cond_init( &worker->tail.wait );

    return worker;
}",1,,186,3,,void
93121,BLOCK,-1,,<empty>,9,,190,2,,void
93198,BLOCK,-1,,"{
    struct bg_queued_item* item = malloc( sizeof( *item ) );

    if( unlikely( !item ) )
        return VLC_EGENERIC;

    item->id = id;
    item->entity = entity;
    item->timeout = timeout < 0 ? worker->conf.default_timeout : timeout;

    vlc_mutex_lock( &worker->lock );
    int i_ret = vlc_array_append( &worker->tail.data, item );
    vlc_cond_signal( &worker->tail.wait );
    if( i_ret != 0 )
    {
        free( item );
        return VLC_EGENERIC;
    }

    if( worker->head.active == false )
    {
        worker->head.probe_request = false;
        worker->head.active =
            !vlc_clone_detach( NULL, Thread, worker, VLC_THREAD_PRIORITY_LOW );
    }

    if( worker->head.active )
        worker->conf.pf_hold( item->entity );

    int ret = worker->head.active ? VLC_SUCCESS : VLC_EGENERIC;
    vlc_mutex_unlock( &worker->lock );

    return ret;
}",1,,210,5,,void
93210,BLOCK,-1,,<empty>,9,,214,2,,void
93264,BLOCK,-1,,"{
        free( item );
        return VLC_EGENERIC;
    }",5,,224,2,,void
93277,BLOCK,-1,,"{
        worker->head.probe_request = false;
        worker->head.active =
            !vlc_clone_detach( NULL, Thread, worker, VLC_THREAD_PRIORITY_LOW );
    }",5,,230,2,,void
93303,BLOCK,-1,,<empty>,9,,237,2,,void
93336,BLOCK,-1,,"{
    BackgroundWorkerCancel( worker, id );
}",1,,246,3,,void
93344,BLOCK,-1,,"{
    vlc_mutex_lock( &worker->lock );
    worker->head.probe_request = true;
    vlc_cond_signal( &worker->head.worker_wait );
    vlc_mutex_unlock( &worker->lock );
}",1,,251,2,,void
93373,BLOCK,-1,,"{
    BackgroundWorkerCancel( worker, NULL );
    vlc_array_clear( &worker->tail.data );
    vlc_mutex_destroy( &worker->lock );
    vlc_cond_destroy( &worker->head.wait );
    vlc_cond_destroy( &worker->head.worker_wait );
    vlc_cond_destroy( &worker->tail.wait );
    free( worker );
}",1,,259,2,,void
93418,BLOCK,-1,,<empty>,1,,1,1,,ANY
93423,BLOCK,-1,,<empty>,,,,2,,<empty>
93428,BLOCK,-1,,<empty>,,,,2,,<empty>
93435,BLOCK,-1,,<empty>,,,,4,,<empty>
93441,BLOCK,-1,,<empty>,,,,3,,<empty>
93447,BLOCK,-1,,<empty>,,,,3,,<empty>
93454,BLOCK,-1,,<empty>,,,,2,,<empty>
93462,BLOCK,-1,,<empty>,,,,5,,<empty>
93468,BLOCK,-1,,<empty>,,,,3,,<empty>
93473,BLOCK,-1,,<empty>,,,,2,,<empty>
93504,BLOCK,-1,,<empty>,1,,1,1,,ANY
93507,BLOCK,-1,,"{
    fprintf( stderr, ""block %p has no release callback! This is a bug!\n"",
             (void *) b );
    abort();
}",1,,40,2,,void
93519,BLOCK,-1,,"{
    while (block != NULL)
    {
        unsigned char *start = block->p_start;
        unsigned char *end = block->p_start + block->i_size;
        unsigned char *bufstart = block->p_buffer;
        unsigned char *bufend = block->p_buffer + block->i_buffer;

        assert (block->pf_release != BlockNoRelease);
        assert (start <= end);
        assert (bufstart <= bufend);
        assert (bufstart >= start);
        assert (bufend <= end);

        block = block->p_next;
    }
}",1,,47,2,,void
93524,BLOCK,-1,,"{
        unsigned char *start = block->p_start;
        unsigned char *end = block->p_start + block->i_size;
        unsigned char *bufstart = block->p_buffer;
        unsigned char *bufend = block->p_buffer + block->i_buffer;

        assert (block->pf_release != BlockNoRelease);
        assert (start <= end);
        assert (bufstart <= bufend);
        assert (bufstart >= start);
        assert (bufend <= end);

        block = block->p_next;
    }",5,,49,2,,void
93588,BLOCK,-1,,"{
    block->p_next = NULL;
    block_Check (block);
    block->pf_release = BlockNoRelease;
}",1,,66,2,,void
93607,BLOCK,-1,,"{
    /* Fill all fields to their default */
    b->p_next = NULL;
    b->p_buffer = buf;
    b->i_buffer = size;
    b->p_start = buf;
    b->i_size = size;
    b->i_flags = 0;
    b->i_nb_samples = 0;
    b->i_pts =
    b->i_dts = VLC_TS_INVALID;
    b->i_length = 0;
#ifndef NDEBUG
    b->pf_release = BlockNoRelease;
#endif
}",1,,77,4,,void
93666,BLOCK,-1,,"{
    /* That is always true for blocks allocated with block_Alloc(). */
    assert (block->p_start == (unsigned char *)(block + 1));
    block_Invalidate (block);
    free (block);
}",1,,95,2,,void
93686,BLOCK,-1,,"{
    out->p_next    = in->p_next;
    out->i_nb_samples = in->i_nb_samples;
    out->i_dts     = in->i_dts;
    out->i_pts     = in->i_pts;
    out->i_flags   = in->i_flags;
    out->i_length  = in->i_length;
}",1,,103,3,,void
93733,BLOCK,-1,,"{
    if (unlikely(size >> 27))
    {
        errno = ENOBUFS;
        return NULL;
    }

    /* 2 * BLOCK_PADDING: pre + post padding */
    const size_t alloc = sizeof (block_t) + BLOCK_ALIGN + (2 * BLOCK_PADDING)
                       + size;
    if (unlikely(alloc <= size))
        return NULL;

    block_t *b = malloc (alloc);
    if (unlikely(b == NULL))
        return NULL;

    block_Init (b, b + 1, alloc - sizeof (*b));
    static_assert ((BLOCK_PADDING % BLOCK_ALIGN) == 0,
                   ""BLOCK_PADDING must be a multiple of BLOCK_ALIGN"");
    b->p_buffer += BLOCK_PADDING + BLOCK_ALIGN - 1;
    b->p_buffer = (void *)(((uintptr_t)b->p_buffer) & ~(BLOCK_ALIGN - 1));
    b->i_buffer = size;
    b->pf_release = block_generic_Release;
    return b;
}",1,,121,2,,void
93739,BLOCK,-1,,"{
        errno = ENOBUFS;
        return NULL;
    }",5,,123,2,,void
93754,BLOCK,1,,<empty>,,,,1,,void
93759,BLOCK,1,,<empty>,,,,1,,void
93767,BLOCK,-1,,<empty>,9,,132,2,,void
93780,BLOCK,-1,,<empty>,9,,136,2,,void
93797,BLOCK,1,,<empty>,,,,1,,void
93800,BLOCK,1,,<empty>,,,,1,,void
93811,BLOCK,1,,<empty>,,,,1,,void
93814,BLOCK,1,,<empty>,,,,1,,void
93832,BLOCK,1,,<empty>,,,,1,,void
93853,BLOCK,-1,,"{
    block_Check( p_block );

    /* Corner case: empty block requested */
    if( i_prebody <= 0 && i_body <= (size_t)(-i_prebody) )
        i_prebody = i_body = 0;

    assert( p_block->p_start <= p_block->p_buffer );
    assert( p_block->p_start + p_block->i_size
                                    >= p_block->p_buffer + p_block->i_buffer );

    /* First, shrink payload */

    /* Pull payload start */
    if( i_prebody < 0 )
    {
        if( p_block->i_buffer >= (size_t)-i_prebody )
        {
            p_block->p_buffer -= i_prebody;
            p_block->i_buffer += i_prebody;
        }
        else /* Discard current payload entirely */
            p_block->i_buffer = 0;
        i_body += i_prebody;
        i_prebody = 0;
    }

    /* Trim payload end */
    if( p_block->i_buffer > i_body )
        p_block->i_buffer = i_body;

    size_t requested = i_prebody + i_body;

    if( p_block->i_buffer == 0 )
    {   /* Corner case: nothing to preserve */
        if( requested <...",1,,149,4,,void
93866,BLOCK,-1,,<empty>,9,,154,2,,void
93900,BLOCK,-1,,"{
        if( p_block->i_buffer >= (size_t)-i_prebody )
        {
            p_block->p_buffer -= i_prebody;
            p_block->i_buffer += i_prebody;
        }
        else /* Discard current payload entirely */
            p_block->i_buffer = 0;
        i_body += i_prebody;
        i_prebody = 0;
    }",5,,164,2,,void
93909,BLOCK,-1,,"{
            p_block->p_buffer -= i_prebody;
            p_block->i_buffer += i_prebody;
        }",9,,166,2,,void
93921,BLOCK,-1,,<empty>,13,,171,1,,void
93939,BLOCK,-1,,<empty>,9,,178,2,,void
93957,BLOCK,-1,,"{   /* Corner case: nothing to preserve */
        if( requested <= p_block->i_size )
        {   /* Enough room: recycle buffer */
            size_t extra = p_block->i_size - requested;

            p_block->p_buffer = p_block->p_start + (extra / 2);
            p_block->i_buffer = requested;
            return p_block;
        }

        /* Not enough room: allocate a new buffer */
        block_t *p_rea = block_Alloc( requested );
        if( p_rea == NULL )
            return NULL;

        BlockMetaCopy( p_rea, p_block );
        block_Release( p_block );
        return p_rea;
    }",5,,183,2,,void
93964,BLOCK,-1,,"{   /* Enough room: recycle buffer */
            size_t extra = p_block->i_size - requested;

            p_block->p_buffer = p_block->p_start + (extra / 2);
            p_block->i_buffer = requested;
            return p_block;
        }",9,,185,2,,void
94000,BLOCK,-1,,<empty>,13,,196,2,,void
94048,BLOCK,-1,,"{
        block_t *p_rea = block_Alloc( requested );
        if( p_rea == NULL )
            return NULL;

        memcpy( p_rea->p_buffer + i_prebody, p_block->p_buffer,
                p_block->i_buffer );
        BlockMetaCopy( p_rea, p_block );
        block_Release( p_block );
        return p_rea;
    }",5,,210,2,,void
94058,BLOCK,-1,,<empty>,13,,213,2,,void
94084,BLOCK,-1,,"{
        p_block->p_buffer -= i_prebody;
        p_block->i_buffer += i_prebody;
        i_body += i_prebody;
        i_prebody = 0;
    }",5,,226,2,,void
94114,BLOCK,-1,,"{
    block_t *rea = block_TryRealloc (block, prebody, body);
    if (rea == NULL)
        block_Release(block);
    return rea;
}",1,,240,4,,void
94126,BLOCK,-1,,<empty>,9,,243,2,,void
94135,BLOCK,-1,,"{
    block_Invalidate (block);
    free (block->p_start);
    free (block);
}",1,,248,2,,void
94149,BLOCK,-1,,"{
    block_t *block = malloc (sizeof (*block));
    if (block == NULL)
    {
        free (addr);
        return NULL;
    }

    block_Init (block, addr, length);
    block->pf_release = block_heap_Release;
    return block;
}",1,,255,3,,void
94161,BLOCK,-1,,"{
        free (addr);
        return NULL;
    }",5,,258,2,,void
94182,BLOCK,-1,,"{
    (void)addr; (void)length; return NULL;
}",1,,302,3,,void
94196,BLOCK,-1,,"{
    (void) addr; (void) length;
    abort ();
}",1,,340,3,,void
94209,BLOCK,-1,,"{
    size_t length;
    struct stat st;

    /* First, get the file size */
    if (fstat (fd, &st))
        return NULL;

    /* st_size is meaningful for regular files, shared memory and typed memory.
     * It's also meaning for symlinks, but that's not possible with fstat().
     * In other cases, it's undefined, and we should really not go further. */
#ifndef S_TYPEISSHM
# define S_TYPEISSHM( buf ) (0)
#endif
    if (S_ISDIR (st.st_mode))
    {
        errno = EISDIR;
        return NULL;
    }
    if (!S_ISREG (st.st_mode) && !S_TYPEISSHM (&st))
    {
        errno = ESPIPE;
        return NULL;
    }

    /* Prevent an integer overflow in mmap() and malloc() */
    if ((uintmax_t)st.st_size >= SIZE_MAX)
    {
        errno = ENOMEM;
        return NULL;
    }
    length = (size_t)st.st_size;

#ifdef HAVE_MMAP
    if (length > 0)
    {
        int prot = PROT_READ | (write ? PROT_WRITE : 0);
        int flags = write ? MAP_PRIVATE : MAP_SHARED;
        void *addr = mmap(NULL,...",1,,369,3,,void
94217,BLOCK,-1,,<empty>,9,,375,2,,void
94225,BLOCK,-1,,"{
        errno = EISDIR;
        return NULL;
    }",5,,384,2,,void
94240,BLOCK,1,,<empty>,,,,1,,void
94242,BLOCK,-1,,"{
        errno = ESPIPE;
        return NULL;
    }",5,,389,2,,void
94256,BLOCK,-1,,"{
        errno = ENOMEM;
        return NULL;
    }",5,,396,2,,void
94278,BLOCK,-1,,<empty>,9,,417,2,,void
94284,BLOCK,-1,,<empty>,5,,420,1,,void
94292,BLOCK,4,,"{
        ssize_t len = pread (fd, block->p_buffer + i, length - i, i);
        if (len == -1)
        {
            block_Release (block);
            block = NULL;
            break;
        }
        i += len;
    }",5,,421,4,,void
94312,BLOCK,-1,,"{
            block_Release (block);
            block = NULL;
            break;
        }",9,,424,2,,void
94330,BLOCK,-1,,"{
    /* NOTE: Writeable shared mappings are not supported here. So there are no
     * needs to open the file for writing (even if the mapping is writable). */
    int fd = vlc_open (path, O_RDONLY);
    if (fd == -1)
        return NULL;

    block_t *block = block_File(fd, write);
    vlc_close (fd);
    return block;
}",1,,436,3,,void
94342,BLOCK,-1,,<empty>,9,,441,2,,void
94393,BLOCK,-1,,<empty>,1,,1,1,,ANY
94397,BLOCK,-1,,"{
    uint32_t i_capabilities = 0;

#if defined( __i386__ ) || defined( __x86_64__ )
     unsigned int i_eax, i_ebx, i_ecx, i_edx;
     bool b_amd;

    /* Needed for x86 CPU capabilities detection */
# if defined (__i386__) && defined (__PIC__)
#  define cpuid(reg) \
     asm volatile (""xchgl %%ebx,%1\n\t"" \
                   ""cpuid\n\t"" \
                   ""xchgl %%ebx,%1\n\t"" \
                   : ""=a"" (i_eax), ""=r"" (i_ebx), ""=c"" (i_ecx), ""=d"" (i_edx) \
                   : ""a"" (reg) \
                   : ""cc"");
# else
#  define cpuid(reg) \
     asm volatile (""cpuid\n\t"" \
                   : ""=a"" (i_eax), ""=b"" (i_ebx), ""=c"" (i_ecx), ""=d"" (i_edx) \
                   : ""a"" (reg) \
                   : ""cc"");
# endif
     /* Check if the OS really supports the requested instructions */
# if defined (__i386__) && !defined (__i486__) && !defined (__i586__) \
  && !defined (__i686__) && !defined (__pentium4__) \
  && !defined (__k6__) && !defined (__athlon__) && !defined (__k8_...",1,,125,2,,void
94409,BLOCK,-1,,"{
/* On Windows and OS/2,
 * initialized from DllMain() and _DLL_InitTerm() respectively, instead */
#if !defined(_WIN32) && !defined(__OS2__)
    static pthread_once_t once = PTHREAD_ONCE_INIT;
    pthread_once (&once, vlc_CPU_init);
#endif
    return cpu_flags;
}",1,,270,2,,void
94424,BLOCK,-1,,"{
    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

#if defined (__i386__) || defined (__x86_64__)
    if (vlc_CPU_MMX())
        vlc_memstream_puts(&stream, ""MMX "");
    if (vlc_CPU_MMXEXT())
        vlc_memstream_puts(&stream, ""MMXEXT "");
    if (vlc_CPU_SSE())
        vlc_memstream_puts(&stream, ""SSE "");
    if (vlc_CPU_SSE2())
        vlc_memstream_puts(&stream, ""SSE2 "");
    if (vlc_CPU_SSE3())
        vlc_memstream_puts(&stream, ""SSE3 "");
    if (vlc_CPU_SSSE3())
        vlc_memstream_puts(&stream, ""SSSE3 "");
    if (vlc_CPU_SSE4_1())
        vlc_memstream_puts(&stream, ""SSE4.1 "");
    if (vlc_CPU_SSE4_2())
        vlc_memstream_puts(&stream, ""SSE4.2 "");
    if (vlc_CPU_SSE4A())
        vlc_memstream_puts(&stream, ""SSE4A "");
    if (vlc_CPU_AVX())
        vlc_memstream_puts(&stream, ""AVX "");
    if (vlc_CPU_AVX2())
        vlc_memstream_puts(&stream, ""AVX2 "");
    if (vlc_CPU_3dNOW())
        vlc_memstream_puts(&stream, ""3DNow! "");
    if (vlc_CPU_XOP())
    ...",1,,282,2,,void
94435,BLOCK,-1,,"{
        msg_Dbg (obj, ""CPU has capabilities %s"", stream.ptr);
        free(stream.ptr);
    }",5,,332,2,,void
94458,BLOCK,-1,,<empty>,1,,1,1,,ANY
94461,BLOCK,-1,,"{
    for(int i=0; i<p_event->i_description_items; i++)
    {
        free(p_event->description_items[i].psz_key);
        free(p_event->description_items[i].psz_value);
    }
    free(p_event->description_items);
    free(p_event->psz_description);
    free(p_event->psz_short_description);
    free(p_event->psz_name);
}",1,,36,2,,void
94463,BLOCK,-1,,<empty>,5,,37,1,,void
94475,BLOCK,4,,"{
        free(p_event->description_items[i].psz_key);
        free(p_event->description_items[i].psz_value);
    }",5,,38,4,,void
94512,BLOCK,-1,,"{
    vlc_epg_event_Clean(p_event);
    free(p_event);
}",1,,49,2,,void
94524,BLOCK,-1,,"{
    memset(p_event, 0, sizeof(*p_event));
    p_event->i_start = i_start;
    p_event->i_id = i_id;
    p_event->i_duration = i_duration;
    p_event->i_description_items = 0;
    p_event->description_items = NULL;
}",1,,56,5,,void
94562,BLOCK,-1,,"{
    vlc_epg_event_t *p_event = (vlc_epg_event_t *) malloc(sizeof(*p_event));
    if(p_event)
        vlc_epg_event_Init(p_event, i_id, i_start, i_duration);

    return p_event;
}",1,,67,4,,void
94574,BLOCK,-1,,<empty>,9,,70,2,,void
94586,BLOCK,-1,,"{
    vlc_epg_event_t *p_evt = vlc_epg_event_New( p_src->i_id, p_src->i_start,
                                                p_src->i_duration );
    if( likely(p_evt) )
    {
        if( p_src->psz_description )
            p_evt->psz_description = strdup( p_src->psz_description );
        if( p_src->psz_name )
            p_evt->psz_name = strdup( p_src->psz_name );
        if( p_src->psz_short_description )
            p_evt->psz_short_description = strdup( p_src->psz_short_description );
        if( p_src->i_description_items )
        {
            p_evt->description_items = malloc( sizeof(*p_evt->description_items) *
                                               p_src->i_description_items );
            if( p_evt->description_items )
            {
                for( int i=0; i<p_src->i_description_items; i++ )
                {
                    p_evt->description_items[i].psz_key =
                            strdup( p_src->description_items[i].psz_key );
             ...",1,,76,2,,void
94603,BLOCK,-1,,"{
        if( p_src->psz_description )
            p_evt->psz_description = strdup( p_src->psz_description );
        if( p_src->psz_name )
            p_evt->psz_name = strdup( p_src->psz_name );
        if( p_src->psz_short_description )
            p_evt->psz_short_description = strdup( p_src->psz_short_description );
        if( p_src->i_description_items )
        {
            p_evt->description_items = malloc( sizeof(*p_evt->description_items) *
                                               p_src->i_description_items );
            if( p_evt->description_items )
            {
                for( int i=0; i<p_src->i_description_items; i++ )
                {
                    p_evt->description_items[i].psz_key =
                            strdup( p_src->description_items[i].psz_key );
                    p_evt->description_items[i].psz_value =
                            strdup( p_src->description_items[i].psz_value );
                    if(!p_evt->description_items[i]....",5,,80,2,,void
94608,BLOCK,-1,,<empty>,13,,82,2,,void
94621,BLOCK,-1,,<empty>,13,,84,2,,void
94634,BLOCK,-1,,<empty>,13,,86,2,,void
94647,BLOCK,-1,,"{
            p_evt->description_items = malloc( sizeof(*p_evt->description_items) *
                                               p_src->i_description_items );
            if( p_evt->description_items )
            {
                for( int i=0; i<p_src->i_description_items; i++ )
                {
                    p_evt->description_items[i].psz_key =
                            strdup( p_src->description_items[i].psz_key );
                    p_evt->description_items[i].psz_value =
                            strdup( p_src->description_items[i].psz_value );
                    if(!p_evt->description_items[i].psz_value ||
                       !p_evt->description_items[i].psz_key)
                    {
                        free(p_evt->description_items[i].psz_key);
                        free(p_evt->description_items[i].psz_value);
                        break;
                    }
                    p_evt->i_description_items++;
                }
            }
     ...",9,,88,2,,void
94666,BLOCK,-1,,"{
                for( int i=0; i<p_src->i_description_items; i++ )
                {
                    p_evt->description_items[i].psz_key =
                            strdup( p_src->description_items[i].psz_key );
                    p_evt->description_items[i].psz_value =
                            strdup( p_src->description_items[i].psz_value );
                    if(!p_evt->description_items[i].psz_value ||
                       !p_evt->description_items[i].psz_key)
                    {
                        free(p_evt->description_items[i].psz_key);
                        free(p_evt->description_items[i].psz_value);
                        break;
                    }
                    p_evt->i_description_items++;
                }
            }",13,,92,2,,void
94668,BLOCK,-1,,<empty>,17,,93,1,,void
94680,BLOCK,4,,"{
                    p_evt->description_items[i].psz_key =
                            strdup( p_src->description_items[i].psz_key );
                    p_evt->description_items[i].psz_value =
                            strdup( p_src->description_items[i].psz_value );
                    if(!p_evt->description_items[i].psz_value ||
                       !p_evt->description_items[i].psz_key)
                    {
                        free(p_evt->description_items[i].psz_key);
                        free(p_evt->description_items[i].psz_value);
                        break;
                    }
                    p_evt->i_description_items++;
                }",17,,94,4,,void
94731,BLOCK,-1,,"{
                        free(p_evt->description_items[i].psz_key);
                        free(p_evt->description_items[i].psz_value);
                        break;
                    }",21,,101,2,,void
94768,BLOCK,-1,,"{
    p_epg->i_id = i_id;
    p_epg->i_source_id = i_source_id;
    p_epg->psz_name = NULL;
    p_epg->p_current = NULL;
    p_epg->b_present = false;
    TAB_INIT( p_epg->i_event, p_epg->pp_event );
}",1,,116,4,,void
94805,BLOCK,-1,,"{
    size_t i;
    for( i = 0; i < p_epg->i_event; i++ )
        vlc_epg_event_Delete( p_epg->pp_event[i] );
    TAB_CLEAN( p_epg->i_event, p_epg->pp_event );
    free( p_epg->psz_name );
}",1,,126,2,,void
94808,BLOCK,-1,,<empty>,5,,128,1,,void
94841,BLOCK,-1,,"{
    ssize_t i_pos = -1;

    /* Insertions are supposed in sequential order first */
    if( p_epg->i_event )
    {
        if( p_epg->pp_event[0]->i_start > p_evt->i_start )
        {
            i_pos = 0;
        }
        else if ( p_epg->pp_event[p_epg->i_event - 1]->i_start >= p_evt->i_start )
        {
            /* Do bisect search lower start time entry */
            size_t i_lower = 0;
            size_t i_upper = p_epg->i_event - 1;

            while( i_lower < i_upper )
            {
                size_t i_split = ( i_lower + i_upper ) / 2;
                vlc_epg_event_t *p_cur = p_epg->pp_event[i_split];

                if( p_cur->i_start < p_evt->i_start )
                {
                    i_lower = i_split + 1;
                }
                else if ( p_cur->i_start >= p_evt->i_start )
                {
                    i_upper = i_split;
                }
            }
            i_pos = i_lower;
        }
    }

    if( i_pos != -1 )
    {
      ...",1,,135,3,,void
94851,BLOCK,-1,,"{
        if( p_epg->pp_event[0]->i_start > p_evt->i_start )
        {
            i_pos = 0;
        }
        else if ( p_epg->pp_event[p_epg->i_event - 1]->i_start >= p_evt->i_start )
        {
            /* Do bisect search lower start time entry */
            size_t i_lower = 0;
            size_t i_upper = p_epg->i_event - 1;

            while( i_lower < i_upper )
            {
                size_t i_split = ( i_lower + i_upper ) / 2;
                vlc_epg_event_t *p_cur = p_epg->pp_event[i_split];

                if( p_cur->i_start < p_evt->i_start )
                {
                    i_lower = i_split + 1;
                }
                else if ( p_cur->i_start >= p_evt->i_start )
                {
                    i_upper = i_split;
                }
            }
            i_pos = i_lower;
        }
    }",5,,140,2,,void
94864,BLOCK,-1,,"{
            i_pos = 0;
        }",9,,142,2,,void
94869,BLOCK,-1,,<empty>,14,,145,1,,void
94886,BLOCK,-1,,"{
            /* Do bisect search lower start time entry */
            size_t i_lower = 0;
            size_t i_upper = p_epg->i_event - 1;

            while( i_lower < i_upper )
            {
                size_t i_split = ( i_lower + i_upper ) / 2;
                vlc_epg_event_t *p_cur = p_epg->pp_event[i_split];

                if( p_cur->i_start < p_evt->i_start )
                {
                    i_lower = i_split + 1;
                }
                else if ( p_cur->i_start >= p_evt->i_start )
                {
                    i_upper = i_split;
                }
            }
            i_pos = i_lower;
        }",9,,146,2,,void
94903,BLOCK,-1,,"{
                size_t i_split = ( i_lower + i_upper ) / 2;
                vlc_epg_event_t *p_cur = p_epg->pp_event[i_split];

                if( p_cur->i_start < p_evt->i_start )
                {
                    i_lower = i_split + 1;
                }
                else if ( p_cur->i_start >= p_evt->i_start )
                {
                    i_upper = i_split;
                }
            }",13,,152,2,,void
94928,BLOCK,-1,,"{
                    i_lower = i_split + 1;
                }",17,,157,2,,void
94935,BLOCK,-1,,<empty>,22,,160,1,,void
94944,BLOCK,-1,,"{
                    i_upper = i_split;
                }",17,,161,2,,void
94956,BLOCK,-1,,"{
        /* There can be only one event at same time */
        if( p_epg->pp_event[i_pos]->i_start == p_evt->i_start )
        {
            vlc_epg_event_Delete( p_epg->pp_event[i_pos] );
            if( p_epg->p_current == p_epg->pp_event[i_pos] )
                p_epg->p_current = p_evt;
            p_epg->pp_event[i_pos] = p_evt;
            return true;
        }
        else
        {
            TAB_INSERT( p_epg->i_event, p_epg->pp_event, p_evt, i_pos );
        }
    }",5,,170,2,,void
94969,BLOCK,-1,,"{
            vlc_epg_event_Delete( p_epg->pp_event[i_pos] );
            if( p_epg->p_current == p_epg->pp_event[i_pos] )
                p_epg->p_current = p_evt;
            p_epg->pp_event[i_pos] = p_evt;
            return true;
        }",9,,173,2,,void
94986,BLOCK,-1,,<empty>,17,,176,2,,void
95002,BLOCK,-1,,"{
            TAB_INSERT( p_epg->i_event, p_epg->pp_event, p_evt, i_pos );
        }",9,,181,1,,void
95013,BLOCK,-1,,<empty>,9,,186,1,,void
95029,BLOCK,-1,,"{
    vlc_epg_t *p_epg = malloc( sizeof(*p_epg) );
    if( p_epg )
        vlc_epg_Init( p_epg, i_id, i_source_id );
    return p_epg;
}",1,,192,3,,void
95039,BLOCK,-1,,<empty>,9,,195,2,,void
95050,BLOCK,-1,,"{
    vlc_epg_Clean( p_epg );
    free( p_epg );
}",1,,200,2,,void
95060,BLOCK,-1,,"{
    size_t i;
    p_epg->p_current = NULL;
    if( i_start < 0 )
        return;

    for( i = 0; i < p_epg->i_event; i++ )
    {
        if( p_epg->pp_event[i]->i_start == i_start )
        {
            p_epg->p_current = p_epg->pp_event[i];
            break;
        }
    }
}",1,,206,3,,void
95071,BLOCK,-1,,<empty>,9,,210,2,,void
95074,BLOCK,-1,,<empty>,5,,212,1,,void
95085,BLOCK,4,,"{
        if( p_epg->pp_event[i]->i_start == i_start )
        {
            p_epg->p_current = p_epg->pp_event[i];
            break;
        }
    }",5,,213,4,,void
95096,BLOCK,-1,,"{
            p_epg->p_current = p_epg->pp_event[i];
            break;
        }",9,,215,2,,void
95111,BLOCK,-1,,"{
    vlc_epg_t *p_epg = vlc_epg_New( p_src->i_id, p_src->i_source_id );
    if( p_epg )
    {
        p_epg->psz_name = ( p_src->psz_name ) ? strdup( p_src->psz_name ) : NULL;
        p_epg->b_present = p_src->b_present;
        for( size_t i=0; i<p_src->i_event; i++ )
        {
            vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_src->pp_event[i] );
            if( p_dup )
            {
                if( p_src->p_current == p_src->pp_event[i] )
                    p_epg->p_current = p_dup;
                TAB_APPEND( p_epg->i_event, p_epg->pp_event, p_dup );
            }
        }
    }
    return p_epg;
}",1,,223,2,,void
95124,BLOCK,-1,,"{
        p_epg->psz_name = ( p_src->psz_name ) ? strdup( p_src->psz_name ) : NULL;
        p_epg->b_present = p_src->b_present;
        for( size_t i=0; i<p_src->i_event; i++ )
        {
            vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_src->pp_event[i] );
            if( p_dup )
            {
                if( p_src->p_current == p_src->pp_event[i] )
                    p_epg->p_current = p_dup;
                TAB_APPEND( p_epg->i_event, p_epg->pp_event, p_dup );
            }
        }
    }",5,,226,2,,void
95146,BLOCK,-1,,<empty>,9,,229,1,,void
95158,BLOCK,4,,"{
            vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_src->pp_event[i] );
            if( p_dup )
            {
                if( p_src->p_current == p_src->pp_event[i] )
                    p_epg->p_current = p_dup;
                TAB_APPEND( p_epg->i_event, p_epg->pp_event, p_dup );
            }
        }",9,,230,4,,void
95170,BLOCK,-1,,"{
                if( p_src->p_current == p_src->pp_event[i] )
                    p_epg->p_current = p_dup;
                TAB_APPEND( p_epg->i_event, p_epg->pp_event, p_dup );
            }",13,,233,2,,void
95181,BLOCK,-1,,<empty>,21,,235,2,,void
95207,BLOCK,-1,,<empty>,1,,1,1,,ANY
95210,BLOCK,-1,,"{
    switch( i_err )
    {
        case VLC_SUCCESS:
            return ""no error"";

        case VLC_ENOMEM:
            return ""not enough memory"";
        case VLC_ETIMEOUT:
            return ""timeout"";

        case VLC_ENOMOD:
            return ""module not found"";

        case VLC_ENOOBJ:
            return ""object not found"";

        case VLC_ENOVAR:
            return ""variable not found"";
        case VLC_EBADVAR:
            return ""bad variable value"";

        case VLC_EGENERIC:
            return ""generic error"";
        default:
            return ""unknown error"";
    }
}",1,,40,2,,void
95213,BLOCK,-1,,"{
        case VLC_SUCCESS:
            return ""no error"";

        case VLC_ENOMEM:
            return ""not enough memory"";
        case VLC_ETIMEOUT:
            return ""timeout"";

        case VLC_ENOMOD:
            return ""module not found"";

        case VLC_ENOOBJ:
            return ""object not found"";

        case VLC_ENOVAR:
            return ""variable not found"";
        case VLC_EBADVAR:
            return ""bad variable value"";

        case VLC_EGENERIC:
            return ""generic error"";
        default:
            return ""unknown error"";
    }",5,,42,2,,void
95263,BLOCK,-1,,<empty>,1,,1,1,,ANY
95266,BLOCK,-1,,"{
    int i_log = 0;

    if( i == 0 ) return -31337;

    if( i & 0xffff0000 ) i_log += 16;
    if( i & 0xff00ff00 ) i_log += 8;
    if( i & 0xf0f0f0f0 ) i_log += 4;
    if( i & 0xcccccccc ) i_log += 2;
    if( i & 0xaaaaaaaa ) i_log += 1;

    return i_log;
}",1,,45,2,,void
95275,BLOCK,-1,,<empty>,18,,48,2,,void
95283,BLOCK,-1,,<empty>,26,,50,2,,void
95291,BLOCK,-1,,<empty>,26,,51,2,,void
95299,BLOCK,-1,,<empty>,26,,52,2,,void
95307,BLOCK,-1,,<empty>,26,,53,2,,void
95315,BLOCK,-1,,<empty>,26,,54,2,,void
95327,BLOCK,-1,,"{
    uint32_t i_low, i_high;            /* lower and higher bits of the mask */

    if( !i_mask )
    {
        *pi_left = *pi_right = 0;
        return;
    }

    /* Get bits */
    i_low = i_high = i_mask;

    i_low &= - (int32_t)i_low;          /* lower bit of the mask */
    i_high += i_low;                    /* higher bit of the mask */

    /* Transform bits into an index. Also deal with i_high overflow, which
     * is faster than changing the BinaryLog code to handle 64 bit integers. */
    i_low =  BinaryLog (i_low);
    i_high = i_high ? BinaryLog (i_high) : 32;

    /* Update pointers and return */
    *pi_left =   i_low;
    *pi_right = (8 - i_high + i_low);
}",1,,64,4,,void
95333,BLOCK,-1,,"{
        *pi_left = *pi_right = 0;
        return;
    }",5,,68,2,,void
95383,BLOCK,-1,,"{
    /* FIXME find right default mask */
    if( !p_fmt->i_rmask || !p_fmt->i_gmask || !p_fmt->i_bmask )
    {
        switch( p_fmt->i_chroma )
        {
        case VLC_CODEC_RGB15:
            p_fmt->i_rmask = 0x7c00;
            p_fmt->i_gmask = 0x03e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB16:
            p_fmt->i_rmask = 0xf800;
            p_fmt->i_gmask = 0x07e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB24:
            p_fmt->i_rmask = 0xff0000;
            p_fmt->i_gmask = 0x00ff00;
            p_fmt->i_bmask = 0x0000ff;
            break;
        case VLC_CODEC_RGB32:
            p_fmt->i_rmask = 0x00ff0000;
            p_fmt->i_gmask = 0x0000ff00;
            p_fmt->i_bmask = 0x000000ff;
            break;

        default:
            return;
        }
    }

    MaskToShift( &p_fmt->i_lrshift, &p_fmt->i_rrshift,
                 p_fmt->i_rmask );
    MaskToShift( &p_fmt->i_lgshift, ...",1,,91,2,,void
95399,BLOCK,-1,,"{
        switch( p_fmt->i_chroma )
        {
        case VLC_CODEC_RGB15:
            p_fmt->i_rmask = 0x7c00;
            p_fmt->i_gmask = 0x03e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB16:
            p_fmt->i_rmask = 0xf800;
            p_fmt->i_gmask = 0x07e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB24:
            p_fmt->i_rmask = 0xff0000;
            p_fmt->i_gmask = 0x00ff00;
            p_fmt->i_bmask = 0x0000ff;
            break;
        case VLC_CODEC_RGB32:
            p_fmt->i_rmask = 0x00ff0000;
            p_fmt->i_gmask = 0x0000ff00;
            p_fmt->i_bmask = 0x000000ff;
            break;

        default:
            return;
        }
    }",5,,94,2,,void
95404,BLOCK,-1,,"{
        case VLC_CODEC_RGB15:
            p_fmt->i_rmask = 0x7c00;
            p_fmt->i_gmask = 0x03e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB16:
            p_fmt->i_rmask = 0xf800;
            p_fmt->i_gmask = 0x07e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB24:
            p_fmt->i_rmask = 0xff0000;
            p_fmt->i_gmask = 0x00ff00;
            p_fmt->i_bmask = 0x0000ff;
            break;
        case VLC_CODEC_RGB32:
            p_fmt->i_rmask = 0x00ff0000;
            p_fmt->i_gmask = 0x0000ff00;
            p_fmt->i_bmask = 0x000000ff;
            break;

        default:
            return;
        }",9,,96,2,,void
95526,BLOCK,-1,,"{
    p_fmt->i_chroma         = vlc_fourcc_GetCodec( VIDEO_ES, i_chroma );
    p_fmt->i_width          = i_width;
    p_fmt->i_visible_width  = i_visible_width;
    p_fmt->i_height         = i_height;
    p_fmt->i_visible_height = i_visible_height;
    p_fmt->i_x_offset       =
    p_fmt->i_y_offset       = 0;
    vlc_ureduce( &p_fmt->i_sar_num, &p_fmt->i_sar_den,
                 i_sar_num, i_sar_den, 0 );

    switch( p_fmt->i_chroma )
    {
    case VLC_CODEC_YUVA:
        p_fmt->i_bits_per_pixel = 32;
        break;
    case VLC_CODEC_YUV420A:
        p_fmt->i_bits_per_pixel = 20;
        break;
    case VLC_CODEC_YUV422A:
        p_fmt->i_bits_per_pixel = 24;
        break;
    case VLC_CODEC_I444:
    case VLC_CODEC_J444:
        p_fmt->i_bits_per_pixel = 24;
        break;
    case VLC_CODEC_I422:
    case VLC_CODEC_YUYV:
    case VLC_CODEC_YVYU:
    case VLC_CODEC_UYVY:
    case VLC_CODEC_VYUY:
    case VLC_CODEC_J422:
        p_fmt->i_bits_per_pixel = 16;
        break;
   ...",1,,137,9,,void
95579,BLOCK,-1,,"{
    case VLC_CODEC_YUVA:
        p_fmt->i_bits_per_pixel = 32;
        break;
    case VLC_CODEC_YUV420A:
        p_fmt->i_bits_per_pixel = 20;
        break;
    case VLC_CODEC_YUV422A:
        p_fmt->i_bits_per_pixel = 24;
        break;
    case VLC_CODEC_I444:
    case VLC_CODEC_J444:
        p_fmt->i_bits_per_pixel = 24;
        break;
    case VLC_CODEC_I422:
    case VLC_CODEC_YUYV:
    case VLC_CODEC_YVYU:
    case VLC_CODEC_UYVY:
    case VLC_CODEC_VYUY:
    case VLC_CODEC_J422:
        p_fmt->i_bits_per_pixel = 16;
        break;
    case VLC_CODEC_I440:
    case VLC_CODEC_J440:
        p_fmt->i_bits_per_pixel = 16;
        break;
    case VLC_CODEC_P010:
        p_fmt->i_bits_per_pixel = 15;
        break;
    case VLC_CODEC_I411:
    case VLC_CODEC_YV12:
    case VLC_CODEC_I420:
    case VLC_CODEC_J420:
    case VLC_CODEC_NV12:
        p_fmt->i_bits_per_pixel = 12;
        break;
    case VLC_CODEC_YV9:
    case VLC_CODEC_I410:
        p_fmt->i_bits_per_pixel = 9;
    ...",5,,149,2,,void
95762,BLOCK,-1,,"{
    p_dst->i_x_offset       = p_src->i_x_offset;
    p_dst->i_y_offset       = p_src->i_y_offset;
    p_dst->i_visible_width  = p_src->i_visible_width;
    p_dst->i_visible_height = p_src->i_visible_height;
}",1,,229,3,,void
95796,BLOCK,-1,,"{
    p_dst->i_x_offset       = (uint64_t)p_src->i_x_offset       * p_dst->i_width  / p_src->i_width;
    p_dst->i_y_offset       = (uint64_t)p_src->i_y_offset       * p_dst->i_height / p_src->i_height;
    p_dst->i_visible_width  = (uint64_t)p_src->i_visible_width  * p_dst->i_width  / p_src->i_width;
    p_dst->i_visible_height = (uint64_t)p_src->i_visible_height * p_dst->i_height / p_src->i_height;

    p_dst->i_sar_num *= p_src->i_width;
    p_dst->i_sar_den *= p_dst->i_width;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);

    p_dst->i_sar_num *= p_dst->i_height;
    p_dst->i_sar_den *= p_src->i_height;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);
}",1,,237,3,,void
95931,BLOCK,-1,,"{
    *hflip = ORIENT_IS_MIRROR(transform);

    switch ( transform )
    {
        case TRANSFORM_R90:
        case TRANSFORM_TRANSPOSE:
            *angle = 90;
            break;
        case TRANSFORM_R180:
        case TRANSFORM_VFLIP:
            *angle = 180;
            break;
        case TRANSFORM_R270:
        case TRANSFORM_ANTI_TRANSPOSE:
            *angle = 270;
            break;
        case TRANSFORM_HFLIP:
        case TRANSFORM_IDENTITY:
            *angle = 0;
            break;
        default:
            vlc_assert_unreachable ();
    }
}",1,,258,4,,void
95939,BLOCK,-1,,"{
        case TRANSFORM_R90:
        case TRANSFORM_TRANSPOSE:
            *angle = 90;
            break;
        case TRANSFORM_R180:
        case TRANSFORM_VFLIP:
            *angle = 180;
            break;
        case TRANSFORM_R270:
        case TRANSFORM_ANTI_TRANSPOSE:
            *angle = 270;
            break;
        case TRANSFORM_HFLIP:
        case TRANSFORM_IDENTITY:
            *angle = 0;
            break;
        default:
            vlc_assert_unreachable ();
    }",5,,262,2,,void
95983,BLOCK,-1,,"{
    switch ( angle )
    {
        case 90:
            return hflip ? TRANSFORM_TRANSPOSE : TRANSFORM_R90;
        case 180:
            return hflip ? TRANSFORM_VFLIP : TRANSFORM_R180;
        case 270:
            return hflip ? TRANSFORM_ANTI_TRANSPOSE : TRANSFORM_R270;
        default:
            return hflip ? TRANSFORM_HFLIP : TRANSFORM_IDENTITY;
    }
}",1,,285,3,,void
95986,BLOCK,-1,,"{
        case 90:
            return hflip ? TRANSFORM_TRANSPOSE : TRANSFORM_R90;
        case 180:
            return hflip ? TRANSFORM_VFLIP : TRANSFORM_R180;
        case 270:
            return hflip ? TRANSFORM_ANTI_TRANSPOSE : TRANSFORM_R270;
        default:
            return hflip ? TRANSFORM_HFLIP : TRANSFORM_IDENTITY;
    }",5,,287,2,,void
96019,BLOCK,-1,,"{
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps(  (video_transform_t)src, &angle1, &hflip1 );
    transform_GetBasicOps( transform_Inverse( (video_transform_t)dst ),
                           &angle2, &hflip2 );

    int angle = (angle1 + angle2) % 360;
    bool hflip = hflip1 ^ hflip2;

    return transform_FromBasicOps(angle, hflip);
}",1,,301,3,,void
96064,BLOCK,-1,,"{
    /* Get destination orientation */
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps( transform, &angle1, &hflip1 );
    transform_GetBasicOps( (video_transform_t)fmt->orientation, &angle2, &hflip2 );

    unsigned angle = (angle2 - angle1 + 360) % 360;
    bool hflip = hflip2 ^ hflip1;

    video_orientation_t dst_orient = ORIENT_NORMAL;

    if( hflip ) {

        if( angle == 0 )
            dst_orient = ORIENT_HFLIPPED;
        else if( angle == 90 )
            dst_orient = ORIENT_ANTI_TRANSPOSED;
        else if( angle == 180 )
            dst_orient = ORIENT_VFLIPPED;
        else if( angle == 270 )
            dst_orient = ORIENT_TRANSPOSED;
    }
    else {

        if( angle == 90 )
            dst_orient = ORIENT_ROTATED_90;
        else if( angle == 180 )
            dst_orient = ORIENT_ROTATED_180;
        else if( angle == 270 )
            dst_orient = ORIENT_ROTATED_270;
    }

    /* Apply transform */
    if( ORIENT_IS_SWAP( fmt-...",1,,316,3,,void
96107,BLOCK,-1,,"{

        if( angle == 0 )
            dst_orient = ORIENT_HFLIPPED;
        else if( angle == 90 )
            dst_orient = ORIENT_ANTI_TRANSPOSED;
        else if( angle == 180 )
            dst_orient = ORIENT_VFLIPPED;
        else if( angle == 270 )
            dst_orient = ORIENT_TRANSPOSED;
    }",17,,329,2,,void
96112,BLOCK,-1,,<empty>,13,,332,2,,void
96117,BLOCK,-1,,<empty>,14,,333,1,,void
96122,BLOCK,-1,,<empty>,13,,334,2,,void
96127,BLOCK,-1,,<empty>,14,,335,1,,void
96132,BLOCK,-1,,<empty>,13,,336,2,,void
96137,BLOCK,-1,,<empty>,14,,337,1,,void
96142,BLOCK,-1,,<empty>,13,,338,2,,void
96147,BLOCK,-1,,"{

        if( angle == 90 )
            dst_orient = ORIENT_ROTATED_90;
        else if( angle == 180 )
            dst_orient = ORIENT_ROTATED_180;
        else if( angle == 270 )
            dst_orient = ORIENT_ROTATED_270;
    }",10,,340,1,,void
96152,BLOCK,-1,,<empty>,13,,343,2,,void
96157,BLOCK,-1,,<empty>,14,,344,1,,void
96162,BLOCK,-1,,<empty>,13,,345,2,,void
96167,BLOCK,-1,,<empty>,14,,346,1,,void
96172,BLOCK,-1,,<empty>,13,,347,2,,void
96184,BLOCK,-1,,"{
        video_format_t scratch = *fmt;

        fmt->i_width = scratch.i_height;
        fmt->i_visible_width = scratch.i_visible_height;
        fmt->i_height = scratch.i_width;
        fmt->i_visible_height = scratch.i_visible_width;
        fmt->i_x_offset = scratch.i_y_offset;
        fmt->i_y_offset = scratch.i_x_offset;
        fmt->i_sar_num = scratch.i_sar_den;
        fmt->i_sar_den = scratch.i_sar_num;
    }",5,,352,2,,void
96256,BLOCK,-1,,"{
    video_transform_t transform = video_format_GetTransform(fmt->orientation,
                                                            dst_orientation);
    video_format_TransformBy(fmt, transform);
}",1,,370,3,,void
96273,BLOCK,-1,,"{
    *out = *in;

    video_format_TransformTo(out, ORIENT_NORMAL);
}",1,,378,3,,void
96287,BLOCK,-1,,"{
    if( f1->i_chroma != f2->i_chroma )
        return false;

    if( f1->i_width != f2->i_width || f1->i_height != f2->i_height ||
        f1->i_visible_width != f2->i_visible_width ||
        f1->i_visible_height != f2->i_visible_height ||
        f1->i_x_offset != f2->i_x_offset || f1->i_y_offset != f2->i_y_offset )
        return false;
    if( (int64_t)f1->i_sar_num * f2->i_sar_den !=
        (int64_t)f2->i_sar_num * f1->i_sar_den )
        return false;

    if( f1->orientation != f2->orientation)
        return false;

    if( f1->multiview_mode!= f2->multiview_mode )
       return false;

    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
        video_format_FixRgb( &v2 );

        if( v1.i_rmask != v2.i_rmask ||
            v1.i_gmask != v2.i_gma...",1,,386,3,,void
96296,BLOCK,-1,,<empty>,9,,388,2,,void
96347,BLOCK,-1,,<empty>,9,,394,2,,void
96370,BLOCK,-1,,<empty>,9,,397,2,,void
96381,BLOCK,-1,,<empty>,9,,400,2,,void
96392,BLOCK,-1,,<empty>,8,,403,2,,void
96419,BLOCK,-1,,"{
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
        video_format_FixRgb( &v2 );

        if( v1.i_rmask != v2.i_rmask ||
            v1.i_gmask != v2.i_gmask ||
            v1.i_bmask != v2.i_bmask )
            return false;
    }",5,,409,2,,void
96460,BLOCK,-1,,<empty>,13,,419,2,,void
96471,BLOCK,-1,,"{
    msg_Dbg( p_this,
             ""%s sz %ix%i, of (%i,%i), vsz %ix%i, 4cc %4.4s, sar %i:%i, msk r0x%x g0x%x b0x%x"",
             psz_text,
             fmt->i_width, fmt->i_height, fmt->i_x_offset, fmt->i_y_offset,
             fmt->i_visible_width, fmt->i_visible_height,
             (char*)&fmt->i_chroma,
             fmt->i_sar_num, fmt->i_sar_den,
             fmt->i_rmask, fmt->i_gmask, fmt->i_bmask );
}",1,,425,4,,void
96521,BLOCK,-1,,"{
    memset(fmt, 0, sizeof (*fmt));
    fmt->i_cat                  = i_cat;
    fmt->i_codec                = i_codec;
    fmt->i_profile              = -1;
    fmt->i_level                = -1;
    fmt->i_id                   = -1;
    fmt->i_priority             = ES_PRIORITY_SELECTABLE_MIN;
    fmt->psz_language           = NULL;
    fmt->psz_description        = NULL;
    fmt->p_extra_languages      = NULL;

    if (fmt->i_cat == VIDEO_ES)
        video_format_Init(&fmt->video, 0);

    fmt->b_packetized           = true;
    fmt->p_extra                = NULL;
}",1,,438,4,,void
96582,BLOCK,-1,,<empty>,9,,451,2,,void
96604,BLOCK,-1,,"{
    es_format_Init( p_es, VIDEO_ES, p_fmt->i_chroma );
    video_format_Copy( &p_es->video, p_fmt );
}",1,,458,3,,void
96622,BLOCK,-1,,"{
    int ret = VLC_SUCCESS;

    *dst = *src;

    if (src->psz_language != NULL)
    {
        dst->psz_language = strdup(src->psz_language);
        if (unlikely(dst->psz_language == NULL))
            ret = VLC_ENOMEM;
    }
    if (src->psz_description != NULL)
    {
        dst->psz_description = strdup(src->psz_description);
        if (unlikely(dst->psz_description == NULL))
            ret = VLC_ENOMEM;
    }

    if (src->i_extra > 0)
    {
        assert(src->p_extra != NULL);
        dst->p_extra = malloc( src->i_extra );

        if( likely(dst->p_extra != NULL) )
            memcpy(dst->p_extra, src->p_extra, src->i_extra);
        else
        {
            dst->i_extra = 0;
            ret = VLC_ENOMEM;
        }
    }
    else
        dst->p_extra = NULL;

    if (src->i_cat == VIDEO_ES)
        ret = video_format_Copy( &dst->video, &src->video );

    if (src->i_cat == SPU_ES)
    {
        if (src->subs.psz_encoding != NULL)
        {
            dst->subs.psz_enc...",1,,464,3,,void
96638,BLOCK,-1,,"{
        dst->psz_language = strdup(src->psz_language);
        if (unlikely(dst->psz_language == NULL))
            ret = VLC_ENOMEM;
    }",5,,470,2,,void
96654,BLOCK,-1,,<empty>,13,,473,2,,void
96664,BLOCK,-1,,"{
        dst->psz_description = strdup(src->psz_description);
        if (unlikely(dst->psz_description == NULL))
            ret = VLC_ENOMEM;
    }",5,,476,2,,void
96680,BLOCK,-1,,<empty>,13,,479,2,,void
96690,BLOCK,-1,,"{
        assert(src->p_extra != NULL);
        dst->p_extra = malloc( src->i_extra );

        if( likely(dst->p_extra != NULL) )
            memcpy(dst->p_extra, src->p_extra, src->i_extra);
        else
        {
            dst->i_extra = 0;
            ret = VLC_ENOMEM;
        }
    }",5,,483,2,,void
96712,BLOCK,-1,,<empty>,13,,488,2,,void
96724,BLOCK,-1,,"{
            dst->i_extra = 0;
            ret = VLC_ENOMEM;
        }",9,,490,1,,void
96734,BLOCK,-1,,<empty>,9,,496,1,,void
96746,BLOCK,-1,,<empty>,9,,499,2,,void
96764,BLOCK,-1,,"{
        if (src->subs.psz_encoding != NULL)
        {
            dst->subs.psz_encoding = strdup(src->subs.psz_encoding);
            if (unlikely(dst->subs.psz_encoding == NULL))
                ret = VLC_ENOMEM;
        }
        if (src->subs.p_style != NULL)
        {
            dst->subs.p_style = text_style_Duplicate(src->subs.p_style);
            if (unlikely(dst->subs.p_style == NULL))
                ret = VLC_ENOMEM;
        }
    }",5,,502,2,,void
96773,BLOCK,-1,,"{
            dst->subs.psz_encoding = strdup(src->subs.psz_encoding);
            if (unlikely(dst->subs.psz_encoding == NULL))
                ret = VLC_ENOMEM;
        }",9,,504,2,,void
96795,BLOCK,-1,,<empty>,17,,507,2,,void
96807,BLOCK,-1,,"{
            dst->subs.p_style = text_style_Duplicate(src->subs.p_style);
            if (unlikely(dst->subs.p_style == NULL))
                ret = VLC_ENOMEM;
        }",9,,510,2,,void
96829,BLOCK,-1,,<empty>,17,,513,2,,void
96839,BLOCK,-1,,"{
        assert(src->p_extra_languages != NULL);
        dst->p_extra_languages = calloc(dst->i_extra_languages,
                                        sizeof (*dst->p_extra_languages));
        if (likely(dst->p_extra_languages != NULL))
        {
            for (unsigned i = 0; i < dst->i_extra_languages; i++)
            {
                if (src->p_extra_languages[i].psz_language != NULL)
                    dst->p_extra_languages[i].psz_language = strdup(src->p_extra_languages[i].psz_language);
                if (src->p_extra_languages[i].psz_description != NULL)
                    dst->p_extra_languages[i].psz_description = strdup(src->p_extra_languages[i].psz_description);
            }
            dst->i_extra_languages = src->i_extra_languages;
        }
        else
        {
            dst->i_extra_languages = 0;
            ret = VLC_ENOMEM;
        }
    }",5,,518,2,,void
96866,BLOCK,-1,,"{
            for (unsigned i = 0; i < dst->i_extra_languages; i++)
            {
                if (src->p_extra_languages[i].psz_language != NULL)
                    dst->p_extra_languages[i].psz_language = strdup(src->p_extra_languages[i].psz_language);
                if (src->p_extra_languages[i].psz_description != NULL)
                    dst->p_extra_languages[i].psz_description = strdup(src->p_extra_languages[i].psz_description);
            }
            dst->i_extra_languages = src->i_extra_languages;
        }",9,,523,2,,void
96868,BLOCK,-1,,<empty>,13,,524,1,,void
96880,BLOCK,4,,"{
                if (src->p_extra_languages[i].psz_language != NULL)
                    dst->p_extra_languages[i].psz_language = strdup(src->p_extra_languages[i].psz_language);
                if (src->p_extra_languages[i].psz_description != NULL)
                    dst->p_extra_languages[i].psz_description = strdup(src->p_extra_languages[i].psz_description);
            }",13,,525,4,,void
96891,BLOCK,-1,,<empty>,21,,527,2,,void
96918,BLOCK,-1,,<empty>,21,,529,2,,void
96943,BLOCK,-1,,"{
            dst->i_extra_languages = 0;
            ret = VLC_ENOMEM;
        }",9,,534,1,,void
96958,BLOCK,-1,,"{
    free(fmt->psz_language);
    free(fmt->psz_description);
    assert(fmt->i_extra == 0 || fmt->p_extra != NULL);
    free(fmt->p_extra);

    if (fmt->i_cat == VIDEO_ES)
        video_format_Clean( &fmt->video );
    if (fmt->i_cat == SPU_ES)
    {
        free(fmt->subs.psz_encoding);

        if (fmt->subs.p_style != NULL)
            text_style_Delete(fmt->subs.p_style);
    }

    for (unsigned i = 0; i < fmt->i_extra_languages; i++)
    {
        free(fmt->p_extra_languages[i].psz_language);
        free(fmt->p_extra_languages[i].psz_description);
    }
    free(fmt->p_extra_languages);

    /* es_format_Clean can be called multiple times */
    es_format_Init(fmt, UNKNOWN_ES, 0);
}",1,,543,2,,void
96989,BLOCK,-1,,<empty>,9,,550,2,,void
97001,BLOCK,-1,,"{
        free(fmt->subs.psz_encoding);

        if (fmt->subs.p_style != NULL)
            text_style_Delete(fmt->subs.p_style);
    }",5,,552,2,,void
97016,BLOCK,-1,,<empty>,13,,556,2,,void
97024,BLOCK,-1,,<empty>,5,,559,1,,void
97036,BLOCK,4,,"{
        free(fmt->p_extra_languages[i].psz_language);
        free(fmt->p_extra_languages[i].psz_description);
    }",5,,560,4,,void
97066,BLOCK,-1,,"{
    if( p_fmt1->i_cat != p_fmt2->i_cat ||
        vlc_fourcc_GetCodec( p_fmt1->i_cat, p_fmt1->i_codec ) !=
        vlc_fourcc_GetCodec( p_fmt2->i_cat, p_fmt2->i_codec ) )
        return false;

    switch( p_fmt1->i_cat )
    {
    case AUDIO_ES:
    {
        audio_format_t a1 = p_fmt1->audio;
        audio_format_t a2 = p_fmt2->audio;

        if( a1.i_format && a2.i_format && a1.i_format != a2.i_format )
            return false;
        if( a1.channel_type != a2.channel_type ||
            a1.i_rate != a2.i_rate ||
            a1.i_channels != a2.i_channels ||
            a1.i_physical_channels != a2.i_physical_channels ||
            a1.i_chan_mode != a2.i_chan_mode )
            return false;
        if( p_fmt1->i_profile != p_fmt2->i_profile )
            return false;
        return true;
    }

    case VIDEO_ES:
    {
        video_format_t v1 = p_fmt1->video;
        video_format_t v2 = p_fmt2->video;
        if( !v1.i_chroma )
            v1.i_chroma = vlc_fourcc_GetCo...",1,,571,3,,void
97091,BLOCK,-1,,<empty>,9,,575,2,,void
97098,BLOCK,-1,,"{
    case AUDIO_ES:
    {
        audio_format_t a1 = p_fmt1->audio;
        audio_format_t a2 = p_fmt2->audio;

        if( a1.i_format && a2.i_format && a1.i_format != a2.i_format )
            return false;
        if( a1.channel_type != a2.channel_type ||
            a1.i_rate != a2.i_rate ||
            a1.i_channels != a2.i_channels ||
            a1.i_physical_channels != a2.i_physical_channels ||
            a1.i_chan_mode != a2.i_chan_mode )
            return false;
        if( p_fmt1->i_profile != p_fmt2->i_profile )
            return false;
        return true;
    }

    case VIDEO_ES:
    {
        video_format_t v1 = p_fmt1->video;
        video_format_t v2 = p_fmt2->video;
        if( !v1.i_chroma )
            v1.i_chroma = vlc_fourcc_GetCodec( p_fmt1->i_cat, p_fmt1->i_codec );
        if( !v2.i_chroma )
            v2.i_chroma = vlc_fourcc_GetCodec( p_fmt2->i_cat, p_fmt2->i_codec );
        return video_format_IsSimilar( &p_fmt1->video, &p_fmt2->video );
    }

 ...",5,,578,2,,void
97101,BLOCK,3,,"{
        audio_format_t a1 = p_fmt1->audio;
        audio_format_t a2 = p_fmt2->audio;

        if( a1.i_format && a2.i_format && a1.i_format != a2.i_format )
            return false;
        if( a1.channel_type != a2.channel_type ||
            a1.i_rate != a2.i_rate ||
            a1.i_channels != a2.i_channels ||
            a1.i_physical_channels != a2.i_physical_channels ||
            a1.i_chan_mode != a2.i_chan_mode )
            return false;
        if( p_fmt1->i_profile != p_fmt2->i_profile )
            return false;
        return true;
    }",5,,580,3,,void
97130,BLOCK,-1,,<empty>,13,,585,2,,void
97173,BLOCK,-1,,<empty>,13,,591,2,,void
97184,BLOCK,-1,,<empty>,13,,593,2,,void
97191,BLOCK,6,,"{
        video_format_t v1 = p_fmt1->video;
        video_format_t v2 = p_fmt2->video;
        if( !v1.i_chroma )
            v1.i_chroma = vlc_fourcc_GetCodec( p_fmt1->i_cat, p_fmt1->i_codec );
        if( !v2.i_chroma )
            v2.i_chroma = vlc_fourcc_GetCodec( p_fmt2->i_cat, p_fmt2->i_codec );
        return video_format_IsSimilar( &p_fmt1->video, &p_fmt2->video );
    }",5,,598,6,,void
97209,BLOCK,-1,,<empty>,13,,602,2,,void
97226,BLOCK,-1,,<empty>,13,,604,2,,void
97269,BLOCK,-1,,<empty>,1,,1,1,,ANY
97277,BLOCK,-1,,"{
    p_em->p_obj = p_obj;
    /* This is an unsafe work-around for a long-standing playlist bug.
     * Do not rely on this. */
    vlc_mutex_init_recursive( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
       ARRAY_INIT( p_em->events[i].listeners );
}",1,,67,3,,void
97289,BLOCK,-1,,<empty>,5,,73,1,,void
97314,BLOCK,-1,,"{
    struct vlc_event_listener_t * listener;

    vlc_mutex_destroy( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
    {
        struct vlc_event_listeners_group_t *slot = p_em->events + i;

        FOREACH_ARRAY( listener, slot->listeners )
            free( listener );
        FOREACH_END()
        ARRAY_RESET( slot->listeners );
    }
}",1,,81,2,,void
97322,BLOCK,-1,,<empty>,5,,86,1,,void
97335,BLOCK,4,,"{
        struct vlc_event_listeners_group_t *slot = p_em->events + i;

        FOREACH_ARRAY( listener, slot->listeners )
            free( listener );
        FOREACH_END()
        ARRAY_RESET( slot->listeners );
    }",5,,87,4,,void
97363,BLOCK,-1,,"{
    vlc_event_listeners_group_t *slot = &p_em->events[p_event->type];
    vlc_event_listener_t * listener;

    /* Fill event with the sending object now */
    p_event->p_obj = p_em->p_obj;

    vlc_mutex_lock( &p_em->lock ) ;

    FOREACH_ARRAY( listener, slot->listeners )
        listener->pf_callback( p_event, listener->p_user_data );
    FOREACH_END()

    vlc_mutex_unlock( &p_em->lock );
}",1,,102,3,,void
97416,BLOCK,-1,,"{
    vlc_event_listener_t * listener;
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];

    listener = malloc(sizeof(vlc_event_listener_t));
    if( !listener )
        return VLC_ENOMEM;

    listener->p_user_data = p_user_data;
    listener->pf_callback = pf_callback;

    vlc_mutex_lock( &p_em->lock );
    ARRAY_APPEND( slot->listeners, listener );
    vlc_mutex_unlock( &p_em->lock );
    return VLC_SUCCESS;
}",1,,126,5,,void
97435,BLOCK,-1,,<empty>,9,,132,2,,void
97472,BLOCK,-1,,"{
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];
    struct vlc_event_listener_t * listener;

    vlc_mutex_lock( &p_em->lock );

    FOREACH_ARRAY( listener, slot->listeners )
        if( listener->pf_callback == pf_callback &&
            listener->p_user_data == p_user_data )
        {
            /* that's our listener */
            ARRAY_REMOVE( slot->listeners,
                          fe_idx /* This comes from the macro (and that's why
                                    I hate macro) */ );
            vlc_mutex_unlock( &p_em->lock );
            free( listener );
            return;
        }
    FOREACH_END()

    vlc_assert_unreachable();
}",1,,151,5,,void
97506,BLOCK,-1,,"{
            /* that's our listener */
            ARRAY_REMOVE( slot->listeners,
                          fe_idx /* This comes from the macro (and that's why
                                    I hate macro) */ );
            vlc_mutex_unlock( &p_em->lock );
            free( listener );
            return;
        }",9,,160,2,,void
97539,BLOCK,-1,,<empty>,1,,1,1,,ANY
97542,BLOCK,-1,,"{
    vlc_mutex_init( &exit->lock );
    exit->handler = NULL;
    exit->opaque = NULL;
}",1,,31,2,,void
97562,BLOCK,-1,,"{
    vlc_mutex_destroy( &exit->lock );
}",1,,38,2,,void
97574,BLOCK,-1,,"{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    vlc_mutex_lock( &exit->lock );
    exit->handler = handler;
    exit->opaque = opaque;
    vlc_mutex_unlock( &exit->lock );
}",1,,48,4,,void
97607,BLOCK,-1,,"{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    msg_Dbg( p_libvlc, ""exiting"" );
    vlc_mutex_lock( &exit->lock );
    if( exit->handler != NULL )
        exit->handler( exit->opaque );
    else
        msg_Dbg( p_libvlc, ""no exit handler"" );
    vlc_mutex_unlock( &exit->lock );
}",1,,62,2,,void
97630,BLOCK,-1,,<empty>,9,,68,2,,void
97639,BLOCK,-1,,<empty>,9,,70,1,,void
97666,BLOCK,-1,,<empty>,1,,1,1,,ANY
97676,BLOCK,-1,,"{
    vlc_mutex_lock(&fifo->lock);
}",1,,50,2,,void
97686,BLOCK,-1,,"{
    vlc_mutex_unlock(&fifo->lock);
}",1,,55,2,,void
97696,BLOCK,-1,,"{
    vlc_cond_signal(&fifo->wait);
}",1,,60,2,,void
97706,BLOCK,-1,,"{
    vlc_fifo_WaitCond(fifo, &fifo->wait);
}",1,,65,2,,void
97718,BLOCK,-1,,"{
    vlc_cond_wait(condvar, &fifo->lock);
}",1,,70,3,,void
97731,BLOCK,-1,,"{
    return vlc_cond_timedwait(condvar, &fifo->lock, deadline);
}",1,,75,4,,void
97744,BLOCK,-1,,"{
    return fifo->i_depth;
}",1,,80,2,,void
97753,BLOCK,-1,,"{
    return fifo->i_size;
}",1,,85,2,,void
97763,BLOCK,-1,,"{
    vlc_assert_locked(&fifo->lock);
    assert(*(fifo->pp_last) == NULL);

    *(fifo->pp_last) = block;

    while (block != NULL)
    {
        fifo->pp_last = &block->p_next;
        fifo->i_depth++;
        fifo->i_size += block->i_buffer;

        block = block->p_next;
    }

    vlc_fifo_Signal(fifo);
}",1,,90,3,,void
97769,BLOCK,1,,<empty>,,,,2,,void
97793,BLOCK,-1,,"{
        fifo->pp_last = &block->p_next;
        fifo->i_depth++;
        fifo->i_size += block->i_buffer;

        block = block->p_next;
    }",5,,97,2,,void
97824,BLOCK,-1,,"{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    if (block == NULL)
        return NULL; /* Nothing to do */

    fifo->p_first = block->p_next;
    if (block->p_next == NULL)
        fifo->pp_last = &fifo->p_first;
    block->p_next = NULL;

    assert(fifo->i_depth > 0);
    fifo->i_depth--;
    assert(fifo->i_size >= block->i_buffer);
    fifo->i_size -= block->i_buffer;

    return block;
}",1,,109,2,,void
97830,BLOCK,1,,<empty>,,,,2,,void
97847,BLOCK,-1,,<empty>,9,,115,2,,void
97863,BLOCK,-1,,<empty>,9,,119,2,,void
97908,BLOCK,-1,,"{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    fifo->p_first = NULL;
    fifo->pp_last = &fifo->p_first;
    fifo->i_depth = 0;
    fifo->i_size = 0;

    return block;
}",1,,131,2,,void
97914,BLOCK,1,,<empty>,,,,2,,void
97956,BLOCK,-1,,"{
    block_fifo_t *p_fifo = malloc( sizeof( block_fifo_t ) );
    if( !p_fifo )
        return NULL;

    vlc_mutex_init( &p_fifo->lock );
    vlc_cond_init( &p_fifo->wait );
    p_fifo->p_first = NULL;
    p_fifo->pp_last = &p_fifo->p_first;
    p_fifo->i_depth = p_fifo->i_size = 0;

    return p_fifo;
}",1,,145,2,,void
97966,BLOCK,-1,,<empty>,9,,148,2,,void
98007,BLOCK,-1,,"{
    block_ChainRelease( p_fifo->p_first );
    vlc_cond_destroy( &p_fifo->wait );
    vlc_mutex_destroy( &p_fifo->lock );
    free( p_fifo );
}",1,,160,2,,void
98028,BLOCK,-1,,"{
    block_t *block;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    block_ChainRelease(block);
}",1,,168,2,,void
98045,BLOCK,-1,,"{
    vlc_fifo_Lock(fifo);
    vlc_fifo_QueueUnlocked(fifo, block);
    vlc_fifo_Unlock(fifo);
}",1,,178,3,,void
98057,BLOCK,-1,,"{
    block_t *block;

    vlc_testcancel();

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        vlc_fifo_CleanupPush(fifo);
        vlc_fifo_Wait(fifo);
        vlc_cleanup_pop();
    }
    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);

    return block;
}",1,,185,2,,void
98065,BLOCK,-1,,"{
        vlc_fifo_CleanupPush(fifo);
        vlc_fifo_Wait(fifo);
        vlc_cleanup_pop();
    }",5,,192,2,,void
98083,BLOCK,-1,,"{
    block_t *b;

    vlc_mutex_lock( &p_fifo->lock );
    assert(p_fifo->p_first != NULL);
    b = p_fifo->p_first;
    vlc_mutex_unlock( &p_fifo->lock );

    return b;
}",1,,204,2,,void
98112,BLOCK,-1,,"{
    size_t size;

    vlc_mutex_lock (&fifo->lock);
    size = fifo->i_size;
    vlc_mutex_unlock (&fifo->lock);
    return size;
}",1,,217,2,,void
98135,BLOCK,-1,,"{
    size_t depth;

    vlc_mutex_lock (&fifo->lock);
    depth = fifo->i_depth;
    vlc_mutex_unlock (&fifo->lock);
    return depth;
}",1,,228,2,,void
98176,BLOCK,-1,,<empty>,1,,1,1,,ANY
98183,BLOCK,-1,,"{
    (void) p_this; (void) oldval;
    var_Set((filter_t *)p_data, psz_var, newval);
    return 0;
}",1,,41,6,,void
98204,BLOCK,-1,,"{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        int var_type = var_Type(filter, name);
        if (var_Type(obj, name))
        {
            free(name);
            continue;
        }
        var_Create(obj, name,
                   var_type | VLC_VAR_DOINHERIT | VLC_VAR_ISCOMMAND);
        if ((var_type & VLC_VAR_ISCOMMAND))
            var_AddCallback(obj, name, TriggerFilterCallback, filter);
        else
            var_AddCallback(obj, name, restart_cb, obj);
        free(name);
    }
    free(names);
}",1,,50,4,,void
98215,BLOCK,-1,,<empty>,9,,53,2,,void
98218,BLOCK,-1,,<empty>,5,,55,1,,void
98229,BLOCK,4,,"{
        char *name = *pname;
        int var_type = var_Type(filter, name);
        if (var_Type(obj, name))
        {
            free(name);
            continue;
        }
        var_Create(obj, name,
                   var_type | VLC_VAR_DOINHERIT | VLC_VAR_ISCOMMAND);
        if ((var_type & VLC_VAR_ISCOMMAND))
            var_AddCallback(obj, name, TriggerFilterCallback, filter);
        else
            var_AddCallback(obj, name, restart_cb, obj);
        free(name);
    }",5,,56,4,,void
98245,BLOCK,-1,,"{
            free(name);
            continue;
        }",9,,60,2,,void
98261,BLOCK,-1,,<empty>,13,,67,2,,void
98268,BLOCK,-1,,<empty>,13,,69,1,,void
98284,BLOCK,-1,,"{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        if (!(var_Type(obj, name) & VLC_VAR_ISCOMMAND))
        {
            free(name);
            continue;
        }
        int filter_var_type = var_Type(filter, name);

        if (filter_var_type & VLC_VAR_ISCOMMAND)
            var_DelCallback(obj, name, TriggerFilterCallback, filter);
        else if (filter_var_type)
            var_DelCallback(obj, name, restart_cb, obj);
        var_Destroy(obj, name);
        free(name);
    }
    free(names);
}",1,,78,4,,void
98295,BLOCK,-1,,<empty>,9,,81,2,,void
98298,BLOCK,-1,,<empty>,5,,83,1,,void
98309,BLOCK,4,,"{
        char *name = *pname;
        if (!(var_Type(obj, name) & VLC_VAR_ISCOMMAND))
        {
            free(name);
            continue;
        }
        int filter_var_type = var_Type(filter, name);

        if (filter_var_type & VLC_VAR_ISCOMMAND)
            var_DelCallback(obj, name, TriggerFilterCallback, filter);
        else if (filter_var_type)
            var_DelCallback(obj, name, restart_cb, obj);
        var_Destroy(obj, name);
        free(name);
    }",5,,84,4,,void
98322,BLOCK,-1,,"{
            free(name);
            continue;
        }",9,,87,2,,void
98336,BLOCK,-1,,<empty>,13,,94,2,,void
98343,BLOCK,-1,,<empty>,14,,95,1,,void
98346,BLOCK,-1,,<empty>,13,,96,2,,void
98364,BLOCK,-1,,"{
    filter_t *p_blend = vlc_custom_create( p_this, sizeof(*p_blend), ""blend"" );
    if( !p_blend )
        return NULL;

    es_format_Init( &p_blend->fmt_in, VIDEO_ES, 0 );

    es_format_Init( &p_blend->fmt_out, VIDEO_ES, 0 );

    p_blend->fmt_out.i_codec        =
    p_blend->fmt_out.video.i_chroma = p_dst_chroma->i_chroma;
    p_blend->fmt_out.video.i_rmask  = p_dst_chroma->i_rmask;
    p_blend->fmt_out.video.i_gmask  = p_dst_chroma->i_gmask;
    p_blend->fmt_out.video.i_bmask  = p_dst_chroma->i_bmask;
    p_blend->fmt_out.video.i_rrshift= p_dst_chroma->i_rrshift;
    p_blend->fmt_out.video.i_rgshift= p_dst_chroma->i_rgshift;
    p_blend->fmt_out.video.i_rbshift= p_dst_chroma->i_rbshift;
    p_blend->fmt_out.video.i_lrshift= p_dst_chroma->i_lrshift;
    p_blend->fmt_out.video.i_lgshift= p_dst_chroma->i_lgshift;
    p_blend->fmt_out.video.i_lbshift= p_dst_chroma->i_lbshift;

    /* The blend module will be loaded when needed with the real
    * input format */
    p_blend->p_m...",1,,107,3,,void
98377,BLOCK,-1,,<empty>,9,,110,2,,void
98524,BLOCK,-1,,"{
    /* */
    if( p_blend->p_module &&
        p_blend->fmt_in.video.i_chroma != p_src->i_chroma )
    {
        /* The chroma is not the same, we need to reload the blend module */
        module_unneed( p_blend, p_blend->p_module );
        p_blend->p_module = NULL;
    }

    /* */

    p_blend->fmt_in.i_codec = p_src->i_chroma;
    p_blend->fmt_in.video   = *p_src;

    /* */
    p_blend->fmt_out.video.i_width          =
    p_blend->fmt_out.video.i_visible_width  = i_dst_width;
    p_blend->fmt_out.video.i_height         =
    p_blend->fmt_out.video.i_visible_height = i_dst_height;

    /* */
    if( !p_blend->p_module )
        p_blend->p_module = module_need( p_blend, ""video blending"", NULL, false );
    if( !p_blend->p_module )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,,138,5,,void
98541,BLOCK,-1,,"{
        /* The chroma is not the same, we need to reload the blend module */
        module_unneed( p_blend, p_blend->p_module );
        p_blend->p_module = NULL;
    }",5,,142,2,,void
98608,BLOCK,-1,,<empty>,9,,161,2,,void
98623,BLOCK,-1,,<empty>,9,,163,2,,void
98637,BLOCK,-1,,"{
    if( !p_blend->p_module )
        return VLC_EGENERIC;

    p_blend->pf_video_blend( p_blend, p_dst, p_src, i_dst_x, i_dst_y, i_alpha );
    return VLC_SUCCESS;
}",1,,170,7,,void
98643,BLOCK,-1,,<empty>,9,,172,2,,void
98662,BLOCK,-1,,"{
    if( p_blend->p_module )
        module_unneed( p_blend, p_blend->p_module );

    vlc_object_release( p_blend );
}",1,,179,2,,void
98667,BLOCK,-1,,<empty>,9,,181,2,,void
98681,BLOCK,-1,,"{
    video_splitter_t *p_splitter = vlc_custom_create( p_this,
                                       sizeof(*p_splitter), ""video splitter"" );
    if( !p_splitter )
        return NULL;

    video_format_Copy( &p_splitter->fmt, p_fmt );

    /* */
    p_splitter->p_module = module_need( p_splitter, ""video splitter"", psz_name, true );
    if( ! p_splitter->p_module )
    {
        video_splitter_Delete( p_splitter );
        return NULL;
    }

    return p_splitter;
}",1,,192,4,,void
98694,BLOCK,-1,,<empty>,9,,196,2,,void
98717,BLOCK,-1,,"{
        video_splitter_Delete( p_splitter );
        return NULL;
    }",5,,203,2,,void
98728,BLOCK,-1,,"{
    if( p_splitter->p_module )
        module_unneed( p_splitter, p_splitter->p_module );

    video_format_Clean( &p_splitter->fmt );

    vlc_object_release( p_splitter );
}",1,,212,2,,void
98733,BLOCK,-1,,<empty>,9,,214,2,,void
98766,BLOCK,-1,,<empty>,1,,1,1,,ANY
98777,BLOCK,-1,,"{
    return container_of(filter, chained_filter_t, filter);
}",1,,47,2,,void
98797,BLOCK,-1,,<empty>,,,,2,,<empty>
98807,BLOCK,-1,,"{
    assert( callbacks != NULL && callbacks->sys != NULL );
    assert( cap != NULL );

    filter_chain_t *chain = malloc( sizeof (*chain) );
    if( unlikely(chain == NULL) )
        return NULL;

    chain->callbacks = *callbacks;
    if( owner != NULL )
        chain->owner = *owner;
    chain->first = NULL;
    chain->last = NULL;
    es_format_Init( &chain->fmt_in, cat, 0 );
    es_format_Init( &chain->fmt_out, cat, 0 );
    chain->b_allow_fmt_out_change = fmt_out_change;
    chain->filter_cap = cap;
    chain->conv_cap = conv_cap;
    return chain;
}",1,,74,7,,void
98834,BLOCK,-1,,<empty>,9,,80,2,,void
98847,BLOCK,-1,,<empty>,9,,84,2,,void
98901,BLOCK,-1,,"{
    filter_owner_t callbacks = {
        .sys = obj,
    };

    return filter_chain_NewInner( &callbacks, cap, NULL, false, NULL, cat );
}",1,,101,4,,void
98906,BLOCK,1,,<empty>,9,,103,1,,void
98923,BLOCK,-1,,"{
    if( chained(filter)->next != NULL )
    {
        picture_t *pic = picture_NewFromFormat( &filter->fmt_out.video );
        if( pic == NULL )
            msg_Err( filter, ""Failed to allocate picture"" );
        return pic;
    }
    else
    {
        filter_chain_t *chain = filter->owner.sys;

        /* XXX ugly */
        filter->owner.sys = chain->owner.sys;
        picture_t *pic = chain->owner.video.buffer_new( filter );
        filter->owner.sys = chain;
        return pic;
    }
}",1,,111,2,,void
98931,BLOCK,-1,,"{
        picture_t *pic = picture_NewFromFormat( &filter->fmt_out.video );
        if( pic == NULL )
            msg_Err( filter, ""Failed to allocate picture"" );
        return pic;
    }",5,,113,2,,void
98946,BLOCK,-1,,<empty>,13,,116,2,,void
98953,BLOCK,-1,,"{
        filter_chain_t *chain = filter->owner.sys;

        /* XXX ugly */
        filter->owner.sys = chain->owner.sys;
        picture_t *pic = chain->owner.video.buffer_new( filter );
        filter->owner.sys = chain;
        return pic;
    }",5,,120,1,,void
99000,BLOCK,-1,,"{
    filter_owner_t callbacks = {
        .sys = obj,
        .video = {
            .buffer_new = filter_chain_VideoBufferNew,
        },
    };

    return filter_chain_NewInner( &callbacks, ""video filter"",
                                  ""video converter"", allow_change, owner, VIDEO_ES );
}",1,,134,4,,void
99005,BLOCK,1,,<empty>,9,,136,1,,void
99009,BLOCK,2,,<empty>,9,,137,2,,void
99013,BLOCK,1,,<empty>,13,,138,1,,void
99030,BLOCK,-1,,"{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    es_format_Clean( &p_chain->fmt_in );
    es_format_Clean( &p_chain->fmt_out );

    free( p_chain );
}",1,,150,2,,void
99063,BLOCK,-1,,"{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    if( p_fmt_in )
    {
        es_format_Clean( &p_chain->fmt_in );
        es_format_Copy( &p_chain->fmt_in, p_fmt_in );
    }
    if( p_fmt_out )
    {
        es_format_Clean( &p_chain->fmt_out );
        es_format_Copy( &p_chain->fmt_out, p_fmt_out );
    }
}",1,,164,4,,void
99080,BLOCK,-1,,"{
        es_format_Clean( &p_chain->fmt_in );
        es_format_Copy( &p_chain->fmt_in, p_fmt_in );
    }",5,,169,2,,void
99094,BLOCK,-1,,"{
        es_format_Clean( &p_chain->fmt_out );
        es_format_Copy( &p_chain->fmt_out, p_fmt_out );
    }",5,,174,2,,void
99115,BLOCK,-1,,"{
    vlc_object_t *parent = chain->callbacks.sys;
    chained_filter_t *chained =
        vlc_custom_create( parent, sizeof(*chained), ""filter"" );
    if( unlikely(chained == NULL) )
        return NULL;

    filter_t *filter = &chained->filter;

    if( fmt_in == NULL )
    {
        if( chain->last != NULL )
            fmt_in = &chain->last->filter.fmt_out;
        else
            fmt_in = &chain->fmt_in;
    }

    if( fmt_out == NULL )
        fmt_out = &chain->fmt_out;

    es_format_Copy( &filter->fmt_in, fmt_in );
    es_format_Copy( &filter->fmt_out, fmt_out );
    filter->b_allow_fmt_out_change = chain->b_allow_fmt_out_change;
    filter->p_cfg = cfg;
    filter->psz_name = name;

    filter->owner = chain->callbacks;
    filter->owner.sys = chain;

    assert( capability != NULL );
    if( name != NULL && filter->b_allow_fmt_out_change )
    {
        /* Append the ""chain"" video filter to the current list.
         * This filter will be used if the requested filter fail...",1,,183,7,,void
99138,BLOCK,-1,,<empty>,9,,188,2,,void
99152,BLOCK,-1,,"{
        if( chain->last != NULL )
            fmt_in = &chain->last->filter.fmt_out;
        else
            fmt_in = &chain->fmt_in;
    }",5,,193,2,,void
99159,BLOCK,-1,,<empty>,13,,195,2,,void
99171,BLOCK,-1,,<empty>,13,,197,1,,void
99182,BLOCK,-1,,<empty>,9,,201,2,,void
99244,BLOCK,-1,,"{
        /* Append the ""chain"" video filter to the current list.
         * This filter will be used if the requested filter fails to load.
         * It will then try to add a video converter before. */
        char name_chained[strlen(name) + sizeof("",chain"")];
        sprintf( name_chained, ""%s,chain"", name );
        filter->p_module = module_need( filter, capability, name_chained, true );
    }",5,,214,2,,void
99260,BLOCK,-1,,<empty>,9,,223,1,,void
99278,BLOCK,-1,,<empty>,9,,226,2,,void
99284,BLOCK,-1,,"{
        es_format_Clean( &chain->fmt_out );
        es_format_Copy( &chain->fmt_out, &filter->fmt_out );
    }",5,,229,2,,void
99305,BLOCK,-1,,"{
        assert( chain->first == NULL );
        chain->first = chained;
    }",5,,235,2,,void
99318,BLOCK,-1,,<empty>,9,,240,1,,void
99355,BLOCK,-1,,<empty>,9,,247,2,,void
99391,BLOCK,-1,,<empty>,9,,258,2,,void
99398,BLOCK,-1,,<empty>,9,,260,1,,void
99425,BLOCK,-1,,"{
    return filter_chain_AppendInner( chain, name, chain->filter_cap, cfg,
                                     fmt_in, fmt_out );
}",1,,270,6,,void
99442,BLOCK,-1,,"{
    return filter_chain_AppendInner( chain, NULL, chain->conv_cap, NULL,
                                     fmt_in, fmt_out ) != NULL ? 0 : -1;
}",1,,277,4,,void
99464,BLOCK,-1,,"{
    vlc_object_t *obj = chain->callbacks.sys;
    chained_filter_t *chained = (chained_filter_t *)filter;

    /* Remove it from the chain */
    if( chained->prev != NULL )
        chained->prev->next = chained->next;
    else
    {
        assert( chained == chain->first );
        chain->first = chained->next;
    }

    if( chained->next != NULL )
        chained->next->prev = chained->prev;
    else
    {
        assert( chained == chain->last );
        chain->last = chained->prev;
    }

    module_unneed( filter, filter->p_module );

    msg_Dbg( obj, ""Filter %p removed from chain"", (void *)filter );
    FilterDeletePictures( chained->pending );

    free( chained->mouse );
    es_format_Clean( &filter->fmt_out );
    es_format_Clean( &filter->fmt_in );

    vlc_object_release( filter );
    /* FIXME: check fmt_in/fmt_out consitency */
}",1,,283,3,,void
99485,BLOCK,-1,,<empty>,9,,289,2,,void
99496,BLOCK,-1,,"{
        assert( chained == chain->first );
        chain->first = chained->next;
    }",5,,291,1,,void
99516,BLOCK,-1,,<empty>,9,,297,2,,void
99527,BLOCK,-1,,"{
        assert( chained == chain->last );
        chain->last = chained->prev;
    }",5,,299,1,,void
99577,BLOCK,-1,,"{
    vlc_object_t *obj = chain->callbacks.sys;
    char *buf = NULL;
    int ret = 0;

    while( str != NULL && str[0] != '\0' )
    {
        config_chain_t *cfg;
        char *name;

        char *next = config_ChainCreate( &name, &cfg, str );

        str = next;
        free( buf );
        buf = next;

        filter_t *filter = filter_chain_AppendFilter( chain, name, cfg,
                                                      NULL, NULL );
        if( cfg )
            config_ChainDestroy( cfg );

        if( filter == NULL )
        {
            msg_Err( obj, ""Failed to append '%s' to chain"", name );
            free( name );
            goto error;
        }

        free( name );
        ret++;
    }

    free( buf );
    return ret;

error:
    while( ret > 0 ) /* Unwind */
    {
        filter_chain_DeleteFilter( chain, &chain->last->filter );
        ret--;
    }
    free( buf );
    return VLC_EGENERIC;
}",1,,319,3,,void
99604,BLOCK,-1,,"{
        config_chain_t *cfg;
        char *name;

        char *next = config_ChainCreate( &name, &cfg, str );

        str = next;
        free( buf );
        buf = next;

        filter_t *filter = filter_chain_AppendFilter( chain, name, cfg,
                                                      NULL, NULL );
        if( cfg )
            config_ChainDestroy( cfg );

        if( filter == NULL )
        {
            msg_Err( obj, ""Failed to append '%s' to chain"", name );
            free( name );
            goto error;
        }

        free( name );
        ret++;
    }",5,,325,2,,void
99635,BLOCK,-1,,<empty>,13,,338,2,,void
99642,BLOCK,-1,,"{
            msg_Err( obj, ""Failed to append '%s' to chain"", name );
            free( name );
            goto error;
        }",9,,341,2,,void
99663,BLOCK,-1,,"{
        filter_chain_DeleteFilter( chain, &chain->last->filter );
        ret--;
    }",5,,356,2,,void
99684,BLOCK,-1,,"{
    for( chained_filter_t *f = chain->first; f != NULL; f = f->next )
    {
        int ret = cb( &f->filter, opaque );
        if( ret )
            return ret;
    }
    return VLC_SUCCESS;
}",1,,366,4,,void
99686,BLOCK,-1,,<empty>,5,,367,1,,void
99701,BLOCK,4,,"{
        int ret = cb( &f->filter, opaque );
        if( ret )
            return ret;
    }",5,,368,4,,void
99713,BLOCK,-1,,<empty>,13,,371,2,,void
99722,BLOCK,-1,,"{
    return chain->first == NULL;
}",1,,377,2,,void
99733,BLOCK,-1,,"{

    if( p_chain->b_allow_fmt_out_change )
        return &p_chain->fmt_out;

    if( p_chain->last != NULL )
        return &p_chain->last->filter.fmt_out;

    /* Unless filter_chain_Reset has been called we are doomed */
    return &p_chain->fmt_out;
}",1,,382,2,,void
99738,BLOCK,-1,,<empty>,9,,385,2,,void
99750,BLOCK,-1,,<empty>,9,,388,2,,void
99770,BLOCK,-1,,"{
    for( ; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        p_pic = p_filter->pf_video_filter( p_filter, p_pic );
        if( !p_pic )
            break;
        if( f->pending )
        {
            msg_Warn( p_filter, ""dropping pictures"" );
            FilterDeletePictures( f->pending );
        }
        f->pending = p_pic->p_next;
        p_pic->p_next = NULL;
    }
    return p_pic;
}",1,,395,3,,void
99772,BLOCK,-1,,<empty>,5,,396,1,,void
99781,BLOCK,4,,"{
        filter_t *p_filter = &f->filter;
        p_pic = p_filter->pf_video_filter( p_filter, p_pic );
        if( !p_pic )
            break;
        if( f->pending )
        {
            msg_Warn( p_filter, ""dropping pictures"" );
            FilterDeletePictures( f->pending );
        }
        f->pending = p_pic->p_next;
        p_pic->p_next = NULL;
    }",5,,397,4,,void
99800,BLOCK,-1,,<empty>,13,,401,2,,void
99806,BLOCK,-1,,"{
            msg_Warn( p_filter, ""dropping pictures"" );
            FilterDeletePictures( f->pending );
        }",9,,403,2,,void
99833,BLOCK,-1,,"{
    if( p_pic )
    {
        p_pic = FilterChainVideoFilter( p_chain->first, p_pic );
        if( p_pic )
            return p_pic;
    }
    for( chained_filter_t *b = p_chain->last; b != NULL; b = b->prev )
    {
        p_pic = b->pending;
        if( !p_pic )
            continue;
        b->pending = p_pic->p_next;
        p_pic->p_next = NULL;

        p_pic = FilterChainVideoFilter( b->next, p_pic );
        if( p_pic )
            return p_pic;
    }
    return NULL;
}",1,,414,3,,void
99836,BLOCK,-1,,"{
        p_pic = FilterChainVideoFilter( p_chain->first, p_pic );
        if( p_pic )
            return p_pic;
    }",5,,416,2,,void
99846,BLOCK,-1,,<empty>,13,,419,2,,void
99850,BLOCK,-1,,<empty>,5,,421,1,,void
99865,BLOCK,4,,"{
        p_pic = b->pending;
        if( !p_pic )
            continue;
        b->pending = p_pic->p_next;
        p_pic->p_next = NULL;

        p_pic = FilterChainVideoFilter( b->next, p_pic );
        if( p_pic )
            return p_pic;
    }",5,,422,4,,void
99874,BLOCK,-1,,<empty>,13,,425,2,,void
99897,BLOCK,-1,,<empty>,13,,431,2,,void
99906,BLOCK,-1,,"{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        FilterDeletePictures( f->pending );
        f->pending = NULL;

        filter_Flush( p_filter );
    }
}",1,,437,2,,void
99908,BLOCK,-1,,<empty>,5,,438,1,,void
99923,BLOCK,4,,"{
        filter_t *p_filter = &f->filter;

        FilterDeletePictures( f->pending );
        f->pending = NULL;

        filter_Flush( p_filter );
    }",5,,439,4,,void
99948,BLOCK,-1,,"{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        subpicture_t *p_subpic = p_filter->pf_sub_source( p_filter, display_date );
        if( p_subpic )
            spu_PutSubpicture( spu, p_subpic );
    }
}",1,,451,4,,void
99950,BLOCK,-1,,<empty>,5,,452,1,,void
99965,BLOCK,4,,"{
        filter_t *p_filter = &f->filter;
        subpicture_t *p_subpic = p_filter->pf_sub_source( p_filter, display_date );
        if( p_subpic )
            spu_PutSubpicture( spu, p_subpic );
    }",5,,453,4,,void
99984,BLOCK,-1,,<empty>,13,,457,2,,void
99993,BLOCK,-1,,"{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        p_subpic = p_filter->pf_sub_filter( p_filter, p_subpic );

        if( !p_subpic )
            break;
    }
    return p_subpic;
}",1,,462,3,,void
99995,BLOCK,-1,,<empty>,5,,463,1,,void
100010,BLOCK,4,,"{
        filter_t *p_filter = &f->filter;

        p_subpic = p_filter->pf_sub_filter( p_filter, p_subpic );

        if( !p_subpic )
            break;
    }",5,,464,4,,void
100029,BLOCK,-1,,<empty>,13,,470,2,,void
100039,BLOCK,-1,,"{
    vlc_mouse_t current = *p_src;

    for( chained_filter_t *f = p_chain->last; f != NULL; f = f->prev )
    {
        filter_t *p_filter = &f->filter;
        vlc_mouse_t *p_mouse = f->mouse;

        if( p_filter->pf_video_mouse && p_mouse )
        {
            vlc_mouse_t old = *p_mouse;
            vlc_mouse_t filtered;

            *p_mouse = current;
            if( p_filter->pf_video_mouse( p_filter, &filtered, &old, &current ) )
                return VLC_EGENERIC;
            current = filtered;
        }
    }

    *p_dst = current;
    return VLC_SUCCESS;
}",1,,476,4,,void
100046,BLOCK,-1,,<empty>,5,,479,1,,void
100061,BLOCK,4,,"{
        filter_t *p_filter = &f->filter;
        vlc_mouse_t *p_mouse = f->mouse;

        if( p_filter->pf_video_mouse && p_mouse )
        {
            vlc_mouse_t old = *p_mouse;
            vlc_mouse_t filtered;

            *p_mouse = current;
            if( p_filter->pf_video_mouse( p_filter, &filtered, &old, &current ) )
                return VLC_EGENERIC;
            current = filtered;
        }
    }",5,,480,4,,void
100081,BLOCK,-1,,"{
            vlc_mouse_t old = *p_mouse;
            vlc_mouse_t filtered;

            *p_mouse = current;
            if( p_filter->pf_video_mouse( p_filter, &filtered, &old, &current ) )
                return VLC_EGENERIC;
            current = filtered;
        }",9,,485,2,,void
100104,BLOCK,-1,,<empty>,17,,491,2,,void
100122,BLOCK,-1,,"{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        if( p_filter->pf_sub_mouse )
        {
            vlc_mouse_t old = *f->mouse;
            *f->mouse = *p_mouse;
            if( p_filter->pf_sub_mouse( p_filter, &old, p_mouse, p_fmt ) )
                return VLC_EGENERIC;
        }
    }

    return VLC_SUCCESS;
}",1,,503,4,,void
100124,BLOCK,-1,,<empty>,5,,504,1,,void
100139,BLOCK,4,,"{
        filter_t *p_filter = &f->filter;

        if( p_filter->pf_sub_mouse )
        {
            vlc_mouse_t old = *f->mouse;
            *f->mouse = *p_mouse;
            if( p_filter->pf_sub_mouse( p_filter, &old, p_mouse, p_fmt ) )
                return VLC_EGENERIC;
        }
    }",5,,505,4,,void
100151,BLOCK,-1,,"{
            vlc_mouse_t old = *f->mouse;
            *f->mouse = *p_mouse;
            if( p_filter->pf_sub_mouse( p_filter, &old, p_mouse, p_fmt ) )
                return VLC_EGENERIC;
        }",9,,509,2,,void
100176,BLOCK,-1,,<empty>,17,,513,2,,void
100185,BLOCK,-1,,"{
    while( picture )
    {
        picture_t *next = picture->p_next;
        picture_Release( picture );
        picture = next;
    }
}",1,,522,2,,void
100188,BLOCK,-1,,"{
        picture_t *next = picture->p_next;
        picture_Release( picture );
        picture = next;
    }",5,,524,2,,void
100216,BLOCK,-1,,<empty>,1,,1,1,,ANY
100219,BLOCK,-1,,"{
    fingerprinter_thread_t *p_fingerprint;

    p_fingerprint = ( fingerprinter_thread_t * )
            vlc_custom_create( p_this, sizeof( *p_fingerprint ), ""fingerprinter"" );
    if( !p_fingerprint )
    {
        msg_Err( p_this, ""unable to create fingerprinter"" );
        return NULL;
    }

    p_fingerprint->p_module = module_need( p_fingerprint, ""fingerprinter"",
                                           NULL, false );
    if( !p_fingerprint->p_module )
    {
        vlc_object_release( p_fingerprint );
        msg_Err( p_this, ""AcoustID fingerprinter not found"" );
        return NULL;
    }

    return p_fingerprint;
}",1,,31,2,,void
100228,BLOCK,1,,<empty>,,,,4,,void
100239,BLOCK,-1,,"{
        msg_Err( p_this, ""unable to create fingerprinter"" );
        return NULL;
    }",5,,37,2,,void
100259,BLOCK,-1,,"{
        vlc_object_release( p_fingerprint );
        msg_Err( p_this, ""AcoustID fingerprinter not found"" );
        return NULL;
    }",5,,45,2,,void
100273,BLOCK,-1,,"{
    module_unneed( p_fingerprint, p_fingerprint->p_module );
    vlc_object_release( p_fingerprint );
}",1,,55,2,,void
100299,BLOCK,-1,,<empty>,1,,1,1,,ANY
100303,BLOCK,-1,,"{
    return memcmp(key, ent, 4);
}",1,,39,3,,void
100318,BLOCK,-1,,"{
    const struct fourcc_mapping *mapping;
    const struct fourcc_desc *desc;

    mapping = bsearch(&fourcc, mapv, mapc, sizeof (*mapv), fourcc_cmp);
    if (mapping != NULL)
    {
        if (dsc != NULL)
        {
            desc = bsearch(&fourcc, dscv, dscc, sizeof (*dscv), fourcc_cmp);
            if (desc != NULL)
            {
                *dsc = desc->desc;
                return mapping->fourcc;
            }
        }
        fourcc = mapping->fourcc;
    }

    desc = bsearch(&fourcc, dscv, dscc, sizeof (*dscv), fourcc_cmp);
    if (desc == NULL)
        return 0; /* Unknown FourCC */
    if (dsc != NULL)
        *dsc = desc->desc;
    return fourcc; /* Known FourCC (has a description) */
}",1,,46,7,,void
100336,BLOCK,-1,,"{
        if (dsc != NULL)
        {
            desc = bsearch(&fourcc, dscv, dscc, sizeof (*dscv), fourcc_cmp);
            if (desc != NULL)
            {
                *dsc = desc->desc;
                return mapping->fourcc;
            }
        }
        fourcc = mapping->fourcc;
    }",5,,52,2,,void
100341,BLOCK,-1,,"{
            desc = bsearch(&fourcc, dscv, dscc, sizeof (*dscv), fourcc_cmp);
            if (desc != NULL)
            {
                *dsc = desc->desc;
                return mapping->fourcc;
            }
        }",9,,54,2,,void
100357,BLOCK,-1,,"{
                *dsc = desc->desc;
                return mapping->fourcc;
            }",13,,57,2,,void
100388,BLOCK,-1,,<empty>,9,,67,2,,void
100395,BLOCK,-1,,<empty>,9,,69,2,,void
100409,BLOCK,-1,,"{
    return Lookup(fourcc, dsc, mapping_video,
                  sizeof (mapping_video) / sizeof (mapping_video[0]),
                  desc_video, sizeof (desc_video) / sizeof (desc_video[0]));
}",1,,74,3,,void
100431,BLOCK,-1,,"{
    return Lookup(fourcc, dsc, mapping_audio,
                  sizeof (mapping_audio) / sizeof (mapping_audio[0]),
                  desc_audio, sizeof (desc_audio) / sizeof (desc_audio[0]));
}",1,,81,3,,void
100453,BLOCK,-1,,"{
    return Lookup(fourcc, dsc, mapping_spu,
                  sizeof (mapping_spu) / sizeof (mapping_spu[0]),
                  desc_spu, sizeof (desc_spu) / sizeof (desc_spu[0]));
}",1,,88,3,,void
100476,BLOCK,-1,,"{
    switch (cat)
    {
        case VIDEO_ES:
            return LookupVideo(fourcc, dsc);
        case AUDIO_ES:
            return LookupAudio(fourcc, dsc);
        case SPU_ES:
            return LookupSpu(fourcc, dsc);
    }

    vlc_fourcc_t ret = LookupVideo(fourcc, dsc);
    if (!ret)
        ret = LookupAudio(fourcc, dsc);
    if (!ret)
        ret = LookupSpu(fourcc, dsc);
    return ret;
}",1,,96,4,,void
100479,BLOCK,-1,,"{
        case VIDEO_ES:
            return LookupVideo(fourcc, dsc);
        case AUDIO_ES:
            return LookupAudio(fourcc, dsc);
        case SPU_ES:
            return LookupSpu(fourcc, dsc);
    }",5,,98,2,,void
100507,BLOCK,-1,,<empty>,9,,109,2,,void
100516,BLOCK,-1,,<empty>,9,,111,2,,void
100529,BLOCK,-1,,"{
    vlc_fourcc_t codec = LookupCat(fourcc, NULL, cat);
    return codec ? codec : fourcc;
}",1,,116,3,,void
100547,BLOCK,-1,,"{
    if( !psz_fourcc || strlen(psz_fourcc) != 4 )
        return 0;
    return vlc_fourcc_GetCodec( i_cat,
                                VLC_FOURCC( psz_fourcc[0], psz_fourcc[1],
                                            psz_fourcc[2], psz_fourcc[3] ) );
}",1,,122,3,,void
100556,BLOCK,-1,,<empty>,9,,124,2,,void
100580,BLOCK,-1,,"{
    const int i_bytes = ( i_bits + 7 ) / 8;

    if( i_fourcc == VLC_FOURCC( 'a', 'f', 'l', 't' ) )
    {
        switch( i_bytes )
        {
        case 4:
            return VLC_CODEC_FL32;
        case 8:
            return VLC_CODEC_FL64;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 'a', 'r', 'a', 'w' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_U8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 't', 'w', 'o', 's' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16B;
        case 3:
            return VLC_CODEC_S24B;
        case 4:
            return VLC_CODEC_S32B;
        default:
            retu...",1,,131,3,,void
100597,BLOCK,-1,,"{
        switch( i_bytes )
        {
        case 4:
            return VLC_CODEC_FL32;
        case 8:
            return VLC_CODEC_FL64;
        default:
            return 0;
        }
    }",5,,135,2,,void
100600,BLOCK,-1,,"{
        case 4:
            return VLC_CODEC_FL32;
        case 8:
            return VLC_CODEC_FL64;
        default:
            return 0;
        }",9,,137,2,,void
100613,BLOCK,-1,,<empty>,10,,146,1,,void
100622,BLOCK,-1,,"{
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_U8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }
    }",5,,147,2,,void
100625,BLOCK,-1,,"{
        case 1:
            return VLC_CODEC_U8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }",9,,149,2,,void
100646,BLOCK,-1,,<empty>,10,,162,1,,void
100655,BLOCK,-1,,"{
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16B;
        case 3:
            return VLC_CODEC_S24B;
        case 4:
            return VLC_CODEC_S32B;
        default:
            return 0;
        }
    }",5,,163,2,,void
100658,BLOCK,-1,,"{
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16B;
        case 3:
            return VLC_CODEC_S24B;
        case 4:
            return VLC_CODEC_S32B;
        default:
            return 0;
        }",9,,165,2,,void
100679,BLOCK,-1,,<empty>,10,,178,1,,void
100688,BLOCK,-1,,"{
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }
    }",5,,179,2,,void
100691,BLOCK,-1,,"{
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }",9,,181,2,,void
100712,BLOCK,-1,,"{
        return vlc_fourcc_GetCodec( AUDIO_ES, i_fourcc );
    }",5,,195,1,,void
100722,BLOCK,-1,,"{
    const char *ret;

    return LookupCat(fourcc, &ret, cat) ? ret : """";
}",1,,201,3,,void
100743,BLOCK,1,,<empty>,,,,1,,void
100767,BLOCK,1,,<empty>,,,,1,,void
100791,BLOCK,1,,<empty>,,,,1,,void
100815,BLOCK,1,,<empty>,,,,1,,void
100838,BLOCK,1,,<empty>,,,,1,,void
100864,BLOCK,1,,<empty>,,,,1,,void
100890,BLOCK,1,,<empty>,,,,1,,void
100916,BLOCK,1,,<empty>,,,,1,,void
100942,BLOCK,1,,<empty>,,,,1,,void
100968,BLOCK,1,,<empty>,,,,1,,void
100994,BLOCK,1,,<empty>,,,,1,,void
101020,BLOCK,1,,<empty>,,,,1,,void
101045,BLOCK,1,,<empty>,,,,1,,void
101071,BLOCK,1,,<empty>,,,,1,,void
101095,BLOCK,1,,<empty>,,,,1,,void
101119,BLOCK,1,,<empty>,,,,1,,void
101145,BLOCK,1,,<empty>,,,,1,,void
101171,BLOCK,1,,<empty>,,,,1,,void
101197,BLOCK,1,,<empty>,,,,1,,void
101223,BLOCK,1,,<empty>,,,,1,,void
101249,BLOCK,1,,<empty>,,,,1,,void
101275,BLOCK,1,,<empty>,,,,1,,void
101299,BLOCK,1,,<empty>,,,,1,,void
101323,BLOCK,1,,<empty>,,,,1,,void
101349,BLOCK,1,,<empty>,,,,1,,void
101375,BLOCK,1,,<empty>,,,,1,,void
101401,BLOCK,1,,<empty>,,,,1,,void
101427,BLOCK,1,,<empty>,,,,1,,void
101453,BLOCK,1,,<empty>,,,,1,,void
101479,BLOCK,1,,<empty>,,,,1,,void
101505,BLOCK,1,,<empty>,,,,1,,void
101612,BLOCK,1,,<empty>,,,,1,,void
101617,BLOCK,1,,<empty>,,,,1,,void
101621,BLOCK,1,,<empty>,,,,1,,void
101625,BLOCK,1,,<empty>,,,,1,,void
101632,BLOCK,1,,<empty>,,,,1,,void
101646,BLOCK,1,,<empty>,,,,1,,void
101670,BLOCK,1,,<empty>,,,,1,,void
101694,BLOCK,1,,<empty>,,,,1,,void
101718,BLOCK,1,,<empty>,,,,1,,void
101789,BLOCK,1,,<empty>,,,,1,,void
101794,BLOCK,1,,<empty>,,,,1,,void
101798,BLOCK,1,,<empty>,,,,1,,void
101802,BLOCK,1,,<empty>,,,,1,,void
101806,BLOCK,1,,<empty>,,,,1,,void
101810,BLOCK,1,,<empty>,,,,1,,void
101814,BLOCK,1,,<empty>,,,,1,,void
101819,BLOCK,1,,<empty>,,,,1,,void
101823,BLOCK,1,,<empty>,,,,1,,void
101830,BLOCK,1,,<empty>,,,,1,,void
101835,BLOCK,1,,<empty>,,,,1,,void
101845,BLOCK,1,,<empty>,,,,1,,void
101848,BLOCK,1,,<empty>,,,,1,,void
101856,BLOCK,1,,<empty>,,,,1,,void
101944,BLOCK,-1,,"{
    for( unsigned i = 0; pp_fallback[i]; i++ )
    {
        if( pp_fallback[i][0] == i_fourcc )
            return pp_fallback[i];
    }
    return p_list;
}",1,,600,4,,void
101946,BLOCK,-1,,<empty>,5,,601,1,,void
101956,BLOCK,4,,"{
        if( pp_fallback[i][0] == i_fourcc )
            return pp_fallback[i];
    }",5,,602,4,,void
101965,BLOCK,-1,,<empty>,13,,604,2,,void
101976,BLOCK,-1,,"{
    return GetFallback( i_fourcc, pp_YUV_fallback, p_list_YUV );
}",1,,610,2,,void
101986,BLOCK,-1,,"{
    return GetFallback( i_fourcc, pp_RGB_fallback, p_RGB32_fallback );
}",1,,614,2,,void
101997,BLOCK,-1,,"{
    static const vlc_fourcc_t pp_swapped[][4] = {
        { VLC_CODEC_YV12, VLC_CODEC_I420, VLC_CODEC_J420, 0 },
        { VLC_CODEC_YV9,  VLC_CODEC_I410, 0 },
        { 0 }
    };

    for( int i = 0; pp_swapped[i][0]; i++ )
    {
        if( pp_swapped[i][0] == b )
        {
            vlc_fourcc_t t = a;
            a = b;
            b = t;
        }
        if( pp_swapped[i][0] != a )
            continue;
        for( int j = 1; pp_swapped[i][j]; j++ )
        {
            if( pp_swapped[i][j] == b )
                return true;
        }
    }
    return false;
}",1,,619,3,,void
102014,BLOCK,-1,,<empty>,5,,626,1,,void
102026,BLOCK,4,,"{
        if( pp_swapped[i][0] == b )
        {
            vlc_fourcc_t t = a;
            a = b;
            b = t;
        }
        if( pp_swapped[i][0] != a )
            continue;
        for( int j = 1; pp_swapped[i][j]; j++ )
        {
            if( pp_swapped[i][j] == b )
                return true;
        }
    }",5,,627,4,,void
102035,BLOCK,-1,,"{
            vlc_fourcc_t t = a;
            a = b;
            b = t;
        }",9,,629,2,,void
102054,BLOCK,-1,,<empty>,13,,635,2,,void
102057,BLOCK,-1,,<empty>,9,,636,1,,void
102069,BLOCK,4,,"{
            if( pp_swapped[i][j] == b )
                return true;
        }",9,,637,4,,void
102078,BLOCK,-1,,<empty>,17,,639,2,,void
102087,BLOCK,-1,,"{
    for( unsigned i = 0; p_list_YUV[i]; i++ )
    {
        if( p_list_YUV[i] == fcc )
            return true;
    }
    return false;
}",1,,646,2,,void
102089,BLOCK,-1,,<empty>,5,,647,1,,void
102099,BLOCK,4,,"{
        if( p_list_YUV[i] == fcc )
            return true;
    }",5,,648,4,,void
102106,BLOCK,-1,,<empty>,13,,650,2,,void
102117,BLOCK,-1,,<empty>,,,,1,,<empty>
102130,BLOCK,1,,<empty>,48,,692,1,,void
102134,BLOCK,2,,<empty>,48,,692,2,,void
102139,BLOCK,1,,<empty>,48,,692,1,,void
102145,BLOCK,2,,<empty>,48,,692,2,,void
102152,BLOCK,1,,<empty>,48,,692,1,,void
102158,BLOCK,2,,<empty>,48,,692,2,,void
102165,BLOCK,1,,<empty>,48,,692,1,,void
102171,BLOCK,2,,<empty>,48,,692,2,,void
102178,BLOCK,1,,<empty>,48,,692,1,,void
102184,BLOCK,2,,<empty>,48,,692,2,,void
102190,BLOCK,3,,<empty>,48,,692,3,,void
102194,BLOCK,4,,<empty>,48,,692,4,,void
102201,BLOCK,1,,<empty>,,,,1,,void
102205,BLOCK,1,,<empty>,48,,693,1,,void
102209,BLOCK,2,,<empty>,48,,693,2,,void
102214,BLOCK,1,,<empty>,48,,693,1,,void
102220,BLOCK,2,,<empty>,48,,693,2,,void
102227,BLOCK,1,,<empty>,48,,693,1,,void
102233,BLOCK,2,,<empty>,48,,693,2,,void
102240,BLOCK,1,,<empty>,48,,693,1,,void
102246,BLOCK,2,,<empty>,48,,693,2,,void
102253,BLOCK,1,,<empty>,48,,693,1,,void
102259,BLOCK,2,,<empty>,48,,693,2,,void
102265,BLOCK,3,,<empty>,48,,693,3,,void
102269,BLOCK,4,,<empty>,48,,693,4,,void
102276,BLOCK,1,,<empty>,,,,1,,void
102281,BLOCK,1,,<empty>,48,,694,1,,void
102285,BLOCK,2,,<empty>,48,,694,2,,void
102290,BLOCK,1,,<empty>,48,,694,1,,void
102296,BLOCK,2,,<empty>,48,,694,2,,void
102303,BLOCK,1,,<empty>,48,,694,1,,void
102309,BLOCK,2,,<empty>,48,,694,2,,void
102316,BLOCK,1,,<empty>,48,,694,1,,void
102322,BLOCK,2,,<empty>,48,,694,2,,void
102329,BLOCK,1,,<empty>,48,,694,1,,void
102335,BLOCK,2,,<empty>,48,,694,2,,void
102341,BLOCK,3,,<empty>,48,,694,3,,void
102345,BLOCK,4,,<empty>,48,,694,4,,void
102354,BLOCK,1,,<empty>,48,,695,1,,void
102358,BLOCK,2,,<empty>,48,,695,2,,void
102363,BLOCK,1,,<empty>,48,,695,1,,void
102369,BLOCK,2,,<empty>,48,,695,2,,void
102376,BLOCK,1,,<empty>,48,,695,1,,void
102382,BLOCK,2,,<empty>,48,,695,2,,void
102388,BLOCK,3,,<empty>,48,,695,3,,void
102392,BLOCK,4,,<empty>,48,,695,4,,void
102399,BLOCK,1,,<empty>,,,,1,,void
102403,BLOCK,1,,<empty>,48,,696,1,,void
102407,BLOCK,2,,<empty>,48,,696,2,,void
102412,BLOCK,1,,<empty>,48,,696,1,,void
102418,BLOCK,2,,<empty>,48,,696,2,,void
102425,BLOCK,1,,<empty>,48,,696,1,,void
102431,BLOCK,2,,<empty>,48,,696,2,,void
102438,BLOCK,1,,<empty>,48,,696,1,,void
102444,BLOCK,2,,<empty>,48,,696,2,,void
102451,BLOCK,1,,<empty>,48,,696,1,,void
102457,BLOCK,2,,<empty>,48,,696,2,,void
102463,BLOCK,3,,<empty>,48,,696,3,,void
102467,BLOCK,4,,<empty>,48,,696,4,,void
102476,BLOCK,1,,<empty>,48,,697,1,,void
102480,BLOCK,2,,<empty>,48,,697,2,,void
102485,BLOCK,1,,<empty>,48,,697,1,,void
102491,BLOCK,2,,<empty>,48,,697,2,,void
102498,BLOCK,1,,<empty>,48,,697,1,,void
102504,BLOCK,2,,<empty>,48,,697,2,,void
102511,BLOCK,1,,<empty>,48,,697,1,,void
102517,BLOCK,2,,<empty>,48,,697,2,,void
102524,BLOCK,1,,<empty>,48,,697,1,,void
102530,BLOCK,2,,<empty>,48,,697,2,,void
102536,BLOCK,3,,<empty>,48,,697,3,,void
102540,BLOCK,4,,<empty>,48,,697,4,,void
102547,BLOCK,1,,<empty>,,,,1,,void
102551,BLOCK,1,,<empty>,48,,698,1,,void
102555,BLOCK,2,,<empty>,48,,698,2,,void
102560,BLOCK,1,,<empty>,48,,698,1,,void
102566,BLOCK,2,,<empty>,48,,698,2,,void
102573,BLOCK,1,,<empty>,48,,698,1,,void
102579,BLOCK,2,,<empty>,48,,698,2,,void
102586,BLOCK,1,,<empty>,48,,698,1,,void
102592,BLOCK,2,,<empty>,48,,698,2,,void
102599,BLOCK,1,,<empty>,48,,698,1,,void
102605,BLOCK,2,,<empty>,48,,698,2,,void
102611,BLOCK,3,,<empty>,48,,698,3,,void
102615,BLOCK,4,,<empty>,48,,698,4,,void
102622,BLOCK,1,,<empty>,,,,1,,void
102626,BLOCK,1,,<empty>,48,,699,1,,void
102630,BLOCK,2,,<empty>,48,,699,2,,void
102635,BLOCK,1,,<empty>,48,,699,1,,void
102641,BLOCK,2,,<empty>,48,,699,2,,void
102648,BLOCK,1,,<empty>,48,,699,1,,void
102654,BLOCK,2,,<empty>,48,,699,2,,void
102661,BLOCK,1,,<empty>,48,,699,1,,void
102667,BLOCK,2,,<empty>,48,,699,2,,void
102674,BLOCK,1,,<empty>,48,,699,1,,void
102680,BLOCK,2,,<empty>,48,,699,2,,void
102686,BLOCK,3,,<empty>,48,,699,3,,void
102690,BLOCK,4,,<empty>,48,,699,4,,void
102698,BLOCK,1,,<empty>,48,,700,1,,void
102702,BLOCK,2,,<empty>,48,,700,2,,void
102707,BLOCK,1,,<empty>,48,,700,1,,void
102713,BLOCK,2,,<empty>,48,,700,2,,void
102720,BLOCK,1,,<empty>,48,,700,1,,void
102726,BLOCK,2,,<empty>,48,,700,2,,void
102733,BLOCK,1,,<empty>,48,,700,1,,void
102739,BLOCK,2,,<empty>,48,,700,2,,void
102746,BLOCK,1,,<empty>,48,,700,1,,void
102752,BLOCK,2,,<empty>,48,,700,2,,void
102758,BLOCK,3,,<empty>,48,,700,3,,void
102762,BLOCK,4,,<empty>,48,,700,4,,void
102770,BLOCK,1,,<empty>,48,,701,1,,void
102774,BLOCK,2,,<empty>,48,,701,2,,void
102779,BLOCK,1,,<empty>,48,,701,1,,void
102785,BLOCK,2,,<empty>,48,,701,2,,void
102792,BLOCK,1,,<empty>,48,,701,1,,void
102798,BLOCK,2,,<empty>,48,,701,2,,void
102805,BLOCK,1,,<empty>,48,,701,1,,void
102811,BLOCK,2,,<empty>,48,,701,2,,void
102818,BLOCK,1,,<empty>,48,,701,1,,void
102824,BLOCK,2,,<empty>,48,,701,2,,void
102830,BLOCK,3,,<empty>,48,,701,3,,void
102834,BLOCK,4,,<empty>,48,,701,4,,void
102842,BLOCK,1,,<empty>,48,,702,1,,void
102846,BLOCK,2,,<empty>,48,,702,2,,void
102851,BLOCK,1,,<empty>,48,,702,1,,void
102857,BLOCK,2,,<empty>,48,,702,2,,void
102864,BLOCK,1,,<empty>,48,,702,1,,void
102870,BLOCK,2,,<empty>,48,,702,2,,void
102877,BLOCK,1,,<empty>,48,,702,1,,void
102883,BLOCK,2,,<empty>,48,,702,2,,void
102890,BLOCK,1,,<empty>,48,,702,1,,void
102896,BLOCK,2,,<empty>,48,,702,2,,void
102902,BLOCK,3,,<empty>,48,,702,3,,void
102906,BLOCK,4,,<empty>,48,,702,4,,void
102914,BLOCK,1,,<empty>,48,,704,1,,void
102918,BLOCK,2,,<empty>,48,,704,2,,void
102923,BLOCK,1,,<empty>,48,,704,1,,void
102929,BLOCK,2,,<empty>,48,,704,2,,void
102936,BLOCK,1,,<empty>,48,,704,1,,void
102942,BLOCK,2,,<empty>,48,,704,2,,void
102949,BLOCK,1,,<empty>,48,,704,1,,void
102955,BLOCK,2,,<empty>,48,,704,2,,void
102962,BLOCK,1,,<empty>,48,,704,1,,void
102968,BLOCK,2,,<empty>,48,,704,2,,void
102974,BLOCK,3,,<empty>,48,,704,3,,void
102978,BLOCK,4,,<empty>,48,,704,4,,void
102987,BLOCK,1,,<empty>,48,,706,1,,void
102991,BLOCK,2,,<empty>,48,,706,2,,void
102996,BLOCK,1,,<empty>,48,,706,1,,void
103002,BLOCK,2,,<empty>,48,,706,2,,void
103009,BLOCK,1,,<empty>,48,,706,1,,void
103015,BLOCK,2,,<empty>,48,,706,2,,void
103022,BLOCK,1,,<empty>,48,,706,1,,void
103028,BLOCK,2,,<empty>,48,,706,2,,void
103035,BLOCK,1,,<empty>,48,,706,1,,void
103041,BLOCK,2,,<empty>,48,,706,2,,void
103047,BLOCK,3,,<empty>,48,,706,3,,void
103051,BLOCK,4,,<empty>,48,,706,4,,void
103060,BLOCK,1,,<empty>,48,,708,1,,void
103064,BLOCK,2,,<empty>,48,,708,2,,void
103069,BLOCK,1,,<empty>,48,,708,1,,void
103075,BLOCK,2,,<empty>,48,,708,2,,void
103082,BLOCK,1,,<empty>,48,,708,1,,void
103088,BLOCK,2,,<empty>,48,,708,2,,void
103095,BLOCK,1,,<empty>,48,,708,1,,void
103101,BLOCK,2,,<empty>,48,,708,2,,void
103108,BLOCK,1,,<empty>,48,,708,1,,void
103114,BLOCK,2,,<empty>,48,,708,2,,void
103120,BLOCK,3,,<empty>,48,,708,3,,void
103124,BLOCK,4,,<empty>,48,,708,4,,void
103133,BLOCK,1,,<empty>,48,,710,1,,void
103137,BLOCK,2,,<empty>,48,,710,2,,void
103142,BLOCK,1,,<empty>,48,,710,1,,void
103148,BLOCK,2,,<empty>,48,,710,2,,void
103155,BLOCK,1,,<empty>,48,,710,1,,void
103161,BLOCK,2,,<empty>,48,,710,2,,void
103168,BLOCK,1,,<empty>,48,,710,1,,void
103174,BLOCK,2,,<empty>,48,,710,2,,void
103181,BLOCK,1,,<empty>,48,,710,1,,void
103187,BLOCK,2,,<empty>,48,,710,2,,void
103193,BLOCK,3,,<empty>,48,,710,3,,void
103197,BLOCK,4,,<empty>,48,,710,4,,void
103206,BLOCK,1,,<empty>,48,,713,1,,void
103210,BLOCK,2,,<empty>,48,,713,2,,void
103215,BLOCK,1,,<empty>,48,,713,1,,void
103221,BLOCK,2,,<empty>,48,,713,2,,void
103228,BLOCK,1,,<empty>,48,,713,1,,void
103234,BLOCK,2,,<empty>,48,,713,2,,void
103241,BLOCK,1,,<empty>,48,,713,1,,void
103247,BLOCK,2,,<empty>,48,,713,2,,void
103254,BLOCK,1,,<empty>,48,,713,1,,void
103260,BLOCK,2,,<empty>,48,,713,2,,void
103266,BLOCK,3,,<empty>,48,,713,3,,void
103270,BLOCK,4,,<empty>,48,,713,4,,void
103279,BLOCK,1,,<empty>,48,,715,1,,void
103283,BLOCK,2,,<empty>,48,,715,2,,void
103288,BLOCK,1,,<empty>,48,,715,1,,void
103294,BLOCK,2,,<empty>,48,,715,2,,void
103301,BLOCK,1,,<empty>,48,,715,1,,void
103307,BLOCK,2,,<empty>,48,,715,2,,void
103314,BLOCK,1,,<empty>,48,,715,1,,void
103320,BLOCK,2,,<empty>,48,,715,2,,void
103327,BLOCK,1,,<empty>,48,,715,1,,void
103333,BLOCK,2,,<empty>,48,,715,2,,void
103339,BLOCK,3,,<empty>,48,,715,3,,void
103343,BLOCK,4,,<empty>,48,,715,4,,void
103352,BLOCK,1,,<empty>,48,,717,1,,void
103356,BLOCK,2,,<empty>,48,,717,2,,void
103361,BLOCK,1,,<empty>,48,,717,1,,void
103367,BLOCK,2,,<empty>,48,,717,2,,void
103374,BLOCK,1,,<empty>,48,,717,1,,void
103380,BLOCK,2,,<empty>,48,,717,2,,void
103387,BLOCK,1,,<empty>,48,,717,1,,void
103393,BLOCK,2,,<empty>,48,,717,2,,void
103400,BLOCK,1,,<empty>,48,,717,1,,void
103406,BLOCK,2,,<empty>,48,,717,2,,void
103412,BLOCK,3,,<empty>,48,,717,3,,void
103416,BLOCK,4,,<empty>,48,,717,4,,void
103425,BLOCK,1,,<empty>,48,,719,1,,void
103429,BLOCK,2,,<empty>,48,,719,2,,void
103434,BLOCK,1,,<empty>,48,,719,1,,void
103440,BLOCK,2,,<empty>,48,,719,2,,void
103447,BLOCK,1,,<empty>,48,,719,1,,void
103453,BLOCK,2,,<empty>,48,,719,2,,void
103460,BLOCK,1,,<empty>,48,,719,1,,void
103466,BLOCK,2,,<empty>,48,,719,2,,void
103473,BLOCK,1,,<empty>,48,,719,1,,void
103479,BLOCK,2,,<empty>,48,,719,2,,void
103485,BLOCK,3,,<empty>,48,,719,3,,void
103489,BLOCK,4,,<empty>,48,,719,4,,void
103498,BLOCK,1,,<empty>,48,,721,1,,void
103502,BLOCK,2,,<empty>,48,,721,2,,void
103507,BLOCK,1,,<empty>,48,,721,1,,void
103513,BLOCK,2,,<empty>,48,,721,2,,void
103520,BLOCK,1,,<empty>,48,,721,1,,void
103526,BLOCK,2,,<empty>,48,,721,2,,void
103533,BLOCK,1,,<empty>,48,,721,1,,void
103539,BLOCK,2,,<empty>,48,,721,2,,void
103546,BLOCK,1,,<empty>,48,,721,1,,void
103552,BLOCK,2,,<empty>,48,,721,2,,void
103558,BLOCK,3,,<empty>,48,,721,3,,void
103562,BLOCK,4,,<empty>,48,,721,4,,void
103571,BLOCK,1,,<empty>,48,,723,1,,void
103575,BLOCK,2,,<empty>,48,,723,2,,void
103580,BLOCK,1,,<empty>,48,,723,1,,void
103586,BLOCK,2,,<empty>,48,,723,2,,void
103593,BLOCK,1,,<empty>,48,,723,1,,void
103599,BLOCK,2,,<empty>,48,,723,2,,void
103606,BLOCK,1,,<empty>,48,,723,1,,void
103612,BLOCK,2,,<empty>,48,,723,2,,void
103619,BLOCK,1,,<empty>,48,,723,1,,void
103625,BLOCK,2,,<empty>,48,,723,2,,void
103631,BLOCK,3,,<empty>,48,,723,3,,void
103635,BLOCK,4,,<empty>,48,,723,4,,void
103644,BLOCK,1,,<empty>,48,,725,1,,void
103648,BLOCK,2,,<empty>,48,,725,2,,void
103653,BLOCK,1,,<empty>,48,,725,1,,void
103659,BLOCK,2,,<empty>,48,,725,2,,void
103666,BLOCK,1,,<empty>,48,,725,1,,void
103672,BLOCK,2,,<empty>,48,,725,2,,void
103679,BLOCK,1,,<empty>,48,,725,1,,void
103685,BLOCK,2,,<empty>,48,,725,2,,void
103692,BLOCK,1,,<empty>,48,,725,1,,void
103698,BLOCK,2,,<empty>,48,,725,2,,void
103704,BLOCK,3,,<empty>,48,,725,3,,void
103708,BLOCK,4,,<empty>,48,,725,4,,void
103717,BLOCK,1,,<empty>,48,,727,1,,void
103721,BLOCK,2,,<empty>,48,,727,2,,void
103726,BLOCK,1,,<empty>,48,,727,1,,void
103732,BLOCK,2,,<empty>,48,,727,2,,void
103739,BLOCK,1,,<empty>,48,,727,1,,void
103745,BLOCK,2,,<empty>,48,,727,2,,void
103752,BLOCK,1,,<empty>,48,,727,1,,void
103758,BLOCK,2,,<empty>,48,,727,2,,void
103765,BLOCK,1,,<empty>,48,,727,1,,void
103771,BLOCK,2,,<empty>,48,,727,2,,void
103777,BLOCK,3,,<empty>,48,,727,3,,void
103781,BLOCK,4,,<empty>,48,,727,4,,void
103790,BLOCK,1,,<empty>,48,,729,1,,void
103794,BLOCK,2,,<empty>,48,,729,2,,void
103799,BLOCK,1,,<empty>,48,,729,1,,void
103805,BLOCK,2,,<empty>,48,,729,2,,void
103812,BLOCK,1,,<empty>,48,,729,1,,void
103818,BLOCK,2,,<empty>,48,,729,2,,void
103825,BLOCK,1,,<empty>,48,,729,1,,void
103831,BLOCK,2,,<empty>,48,,729,2,,void
103838,BLOCK,1,,<empty>,48,,729,1,,void
103844,BLOCK,2,,<empty>,48,,729,2,,void
103850,BLOCK,3,,<empty>,48,,729,3,,void
103854,BLOCK,4,,<empty>,48,,729,4,,void
103863,BLOCK,1,,<empty>,48,,731,1,,void
103867,BLOCK,2,,<empty>,48,,731,2,,void
103872,BLOCK,1,,<empty>,48,,731,1,,void
103878,BLOCK,2,,<empty>,48,,731,2,,void
103885,BLOCK,1,,<empty>,48,,731,1,,void
103891,BLOCK,2,,<empty>,48,,731,2,,void
103898,BLOCK,1,,<empty>,48,,731,1,,void
103904,BLOCK,2,,<empty>,48,,731,2,,void
103911,BLOCK,1,,<empty>,48,,731,1,,void
103917,BLOCK,2,,<empty>,48,,731,2,,void
103923,BLOCK,3,,<empty>,48,,731,3,,void
103927,BLOCK,4,,<empty>,48,,731,4,,void
103936,BLOCK,1,,<empty>,48,,733,1,,void
103940,BLOCK,2,,<empty>,48,,733,2,,void
103945,BLOCK,1,,<empty>,48,,733,1,,void
103951,BLOCK,2,,<empty>,48,,733,2,,void
103958,BLOCK,1,,<empty>,48,,733,1,,void
103964,BLOCK,2,,<empty>,48,,733,2,,void
103971,BLOCK,1,,<empty>,48,,733,1,,void
103977,BLOCK,2,,<empty>,48,,733,2,,void
103984,BLOCK,1,,<empty>,48,,733,1,,void
103990,BLOCK,2,,<empty>,48,,733,2,,void
103996,BLOCK,3,,<empty>,48,,733,3,,void
104000,BLOCK,4,,<empty>,48,,733,4,,void
104009,BLOCK,1,,<empty>,48,,735,1,,void
104013,BLOCK,2,,<empty>,48,,735,2,,void
104018,BLOCK,1,,<empty>,48,,735,1,,void
104024,BLOCK,2,,<empty>,48,,735,2,,void
104031,BLOCK,1,,<empty>,48,,735,1,,void
104037,BLOCK,2,,<empty>,48,,735,2,,void
104044,BLOCK,1,,<empty>,48,,735,1,,void
104050,BLOCK,2,,<empty>,48,,735,2,,void
104057,BLOCK,1,,<empty>,48,,735,1,,void
104063,BLOCK,2,,<empty>,48,,735,2,,void
104069,BLOCK,3,,<empty>,48,,735,3,,void
104073,BLOCK,4,,<empty>,48,,735,4,,void
104081,BLOCK,1,,<empty>,48,,736,1,,void
104085,BLOCK,2,,<empty>,48,,736,2,,void
104090,BLOCK,1,,<empty>,48,,736,1,,void
104096,BLOCK,2,,<empty>,48,,736,2,,void
104103,BLOCK,1,,<empty>,48,,736,1,,void
104109,BLOCK,2,,<empty>,48,,736,2,,void
104115,BLOCK,3,,<empty>,48,,736,3,,void
104119,BLOCK,4,,<empty>,48,,736,4,,void
104126,BLOCK,1,,<empty>,,,,1,,void
104132,BLOCK,1,,<empty>,48,,738,1,,void
104136,BLOCK,2,,<empty>,48,,738,2,,void
104141,BLOCK,1,,<empty>,48,,738,1,,void
104147,BLOCK,2,,<empty>,48,,738,2,,void
104153,BLOCK,3,,<empty>,48,,738,3,,void
104157,BLOCK,4,,<empty>,48,,738,4,,void
104168,BLOCK,1,,<empty>,48,,740,1,,void
104172,BLOCK,2,,<empty>,48,,740,2,,void
104177,BLOCK,1,,<empty>,48,,740,1,,void
104183,BLOCK,2,,<empty>,48,,740,2,,void
104189,BLOCK,3,,<empty>,48,,740,3,,void
104193,BLOCK,4,,<empty>,48,,740,4,,void
104202,BLOCK,1,,<empty>,48,,742,1,,void
104206,BLOCK,2,,<empty>,48,,742,2,,void
104211,BLOCK,1,,<empty>,48,,742,1,,void
104217,BLOCK,2,,<empty>,48,,742,2,,void
104223,BLOCK,3,,<empty>,48,,742,3,,void
104227,BLOCK,4,,<empty>,48,,742,4,,void
104236,BLOCK,1,,<empty>,48,,743,1,,void
104240,BLOCK,2,,<empty>,48,,743,2,,void
104245,BLOCK,1,,<empty>,48,,743,1,,void
104251,BLOCK,2,,<empty>,48,,743,2,,void
104257,BLOCK,3,,<empty>,48,,743,3,,void
104261,BLOCK,4,,<empty>,48,,743,4,,void
104270,BLOCK,1,,<empty>,48,,744,1,,void
104274,BLOCK,2,,<empty>,48,,744,2,,void
104279,BLOCK,1,,<empty>,48,,744,1,,void
104285,BLOCK,2,,<empty>,48,,744,2,,void
104291,BLOCK,3,,<empty>,48,,744,3,,void
104295,BLOCK,4,,<empty>,48,,744,4,,void
104304,BLOCK,1,,<empty>,48,,745,1,,void
104308,BLOCK,2,,<empty>,48,,745,2,,void
104313,BLOCK,1,,<empty>,48,,745,1,,void
104319,BLOCK,2,,<empty>,48,,745,2,,void
104325,BLOCK,3,,<empty>,48,,745,3,,void
104329,BLOCK,4,,<empty>,48,,745,4,,void
104338,BLOCK,1,,<empty>,48,,746,1,,void
104342,BLOCK,2,,<empty>,48,,746,2,,void
104347,BLOCK,1,,<empty>,48,,746,1,,void
104353,BLOCK,2,,<empty>,48,,746,2,,void
104359,BLOCK,3,,<empty>,48,,746,3,,void
104363,BLOCK,4,,<empty>,48,,746,4,,void
104374,BLOCK,1,,<empty>,48,,748,1,,void
104378,BLOCK,2,,<empty>,48,,748,2,,void
104383,BLOCK,1,,<empty>,48,,748,1,,void
104389,BLOCK,2,,<empty>,48,,748,2,,void
104395,BLOCK,3,,<empty>,48,,748,3,,void
104399,BLOCK,4,,<empty>,48,,748,4,,void
104408,BLOCK,1,,<empty>,48,,749,1,,void
104412,BLOCK,2,,<empty>,48,,749,2,,void
104417,BLOCK,1,,<empty>,48,,749,1,,void
104423,BLOCK,2,,<empty>,48,,749,2,,void
104429,BLOCK,3,,<empty>,48,,749,3,,void
104433,BLOCK,4,,<empty>,48,,749,4,,void
104442,BLOCK,1,,<empty>,48,,750,1,,void
104446,BLOCK,2,,<empty>,48,,750,2,,void
104451,BLOCK,1,,<empty>,48,,750,1,,void
104457,BLOCK,2,,<empty>,48,,750,2,,void
104463,BLOCK,3,,<empty>,48,,750,3,,void
104467,BLOCK,4,,<empty>,48,,750,4,,void
104492,BLOCK,1,,<empty>,48,,753,1,,void
104496,BLOCK,2,,<empty>,48,,753,2,,void
104501,BLOCK,1,,<empty>,48,,753,1,,void
104507,BLOCK,2,,<empty>,48,,753,2,,void
104513,BLOCK,3,,<empty>,48,,753,3,,void
104517,BLOCK,4,,<empty>,48,,753,4,,void
104528,BLOCK,1,,<empty>,48,,757,1,,void
104532,BLOCK,2,,<empty>,48,,757,2,,void
104537,BLOCK,1,,<empty>,48,,757,1,,void
104543,BLOCK,2,,<empty>,48,,757,2,,void
104549,BLOCK,3,,<empty>,48,,757,3,,void
104553,BLOCK,4,,<empty>,48,,757,4,,void
104564,BLOCK,1,,<empty>,48,,760,1,,void
104568,BLOCK,2,,<empty>,48,,760,2,,void
104573,BLOCK,1,,<empty>,48,,760,1,,void
104579,BLOCK,2,,<empty>,48,,760,2,,void
104585,BLOCK,3,,<empty>,48,,760,3,,void
104589,BLOCK,4,,<empty>,48,,760,4,,void
104598,BLOCK,1,,<empty>,48,,762,1,,void
104602,BLOCK,2,,<empty>,48,,762,2,,void
104607,BLOCK,1,,<empty>,48,,762,1,,void
104613,BLOCK,2,,<empty>,48,,762,2,,void
104619,BLOCK,3,,<empty>,48,,762,3,,void
104623,BLOCK,4,,<empty>,48,,762,4,,void
104634,BLOCK,1,,<empty>,48,,766,1,,void
104638,BLOCK,2,,<empty>,48,,766,2,,void
104643,BLOCK,1,,<empty>,48,,766,1,,void
104649,BLOCK,2,,<empty>,48,,766,2,,void
104655,BLOCK,3,,<empty>,48,,766,3,,void
104659,BLOCK,4,,<empty>,48,,766,4,,void
104668,BLOCK,1,,<empty>,48,,768,1,,void
104672,BLOCK,2,,<empty>,48,,768,2,,void
104677,BLOCK,1,,<empty>,48,,768,1,,void
104683,BLOCK,2,,<empty>,48,,768,2,,void
104689,BLOCK,3,,<empty>,48,,768,3,,void
104693,BLOCK,4,,<empty>,48,,768,4,,void
104702,BLOCK,1,,<empty>,48,,771,1,,void
104706,BLOCK,2,,<empty>,48,,771,2,,void
104711,BLOCK,1,,<empty>,48,,771,1,,void
104717,BLOCK,2,,<empty>,48,,771,2,,void
104723,BLOCK,3,,<empty>,48,,771,3,,void
104727,BLOCK,4,,<empty>,48,,771,4,,void
104735,BLOCK,1,,<empty>,48,,773,1,,void
104739,BLOCK,2,,<empty>,48,,773,2,,void
104744,BLOCK,1,,<empty>,48,,773,1,,void
104750,BLOCK,2,,<empty>,48,,773,2,,void
104756,BLOCK,3,,<empty>,48,,773,3,,void
104760,BLOCK,4,,<empty>,48,,773,4,,void
104766,BLOCK,-1,,"{
    for( unsigned i = 0; p_list_chroma_description[i].p_fourcc[0]; i++ )
    {
        const vlc_fourcc_t *p_fourcc = p_list_chroma_description[i].p_fourcc;
        for( unsigned j = 0; j < 4 && p_fourcc[j] != 0; j++ )
        {
            if( p_fourcc[j] == i_fourcc )
                return &p_list_chroma_description[i].description;
        }
    }
    return NULL;
}",1,,782,2,,void
104768,BLOCK,-1,,<empty>,5,,783,1,,void
104782,BLOCK,4,,"{
        const vlc_fourcc_t *p_fourcc = p_list_chroma_description[i].p_fourcc;
        for( unsigned j = 0; j < 4 && p_fourcc[j] != 0; j++ )
        {
            if( p_fourcc[j] == i_fourcc )
                return &p_list_chroma_description[i].description;
        }
    }",5,,784,4,,void
104792,BLOCK,-1,,<empty>,9,,786,1,,void
104808,BLOCK,4,,"{
            if( p_fourcc[j] == i_fourcc )
                return &p_list_chroma_description[i].description;
        }",9,,787,4,,void
104815,BLOCK,-1,,<empty>,17,,789,2,,void
104849,BLOCK,-1,,<empty>,1,,1,1,,ANY
104860,BLOCK,-1,,<empty>,,,,1,,<empty>
104871,BLOCK,-1,,<empty>,,,,1,,<empty>
104881,BLOCK,-1,,"{
    const struct entry *ea = a, *eb = b;
    int d = memcmp(ea->alias, eb->alias, 4);
    if (d == 0)
        d = memcmp(ea->fourcc, eb->fourcc, 4);
    return d;
}",1,,59,3,,void
104905,BLOCK,-1,,<empty>,9,,63,2,,void
104924,BLOCK,-1,,"{
    struct entry *entries = malloc(sizeof (*entries) * n);
    if (entries == NULL)
        abort();

    const staticentry_t *klass = NULL;

    for (size_t i = 0; i < n; i++)
    {
        if (list[i].klass)
            klass = &list[i];

        if (klass == NULL)
        {
            fprintf(stderr, ""Error: FourCC \""%.4s\"" not mapped!\n"",
                    list[i].fourcc);
            exit(1);
        }

        memcpy(entries[i].fourcc, klass->fourcc, 4);
        memcpy(entries[i].alias, list[i].fourcc, 4);
        entries[i].desc = list[i].description;
    }

    qsort(entries, n, sizeof (*entries), cmp_entry);

    size_t dups = 0;
    for (size_t i = 1; i < n; i++)
        if (!memcmp(entries[i - 1].alias, entries[i].alias, 4)
         && memcmp(entries[i - 1].fourcc, entries[i].fourcc, 4))
        {
            fprintf(stderr, ""Error: FourCC alias \""%.4s\"" conflict: ""
                    ""\""%.4s\"" and \""%.4s\""\n"", entries[i].alias,
                    entries[i - 1].fo...",1,,68,4,,void
104938,BLOCK,-1,,<empty>,9,,71,2,,void
104945,BLOCK,-1,,<empty>,5,,75,1,,void
104955,BLOCK,4,,"{
        if (list[i].klass)
            klass = &list[i];

        if (klass == NULL)
        {
            fprintf(stderr, ""Error: FourCC \""%.4s\"" not mapped!\n"",
                    list[i].fourcc);
            exit(1);
        }

        memcpy(entries[i].fourcc, klass->fourcc, 4);
        memcpy(entries[i].alias, list[i].fourcc, 4);
        entries[i].desc = list[i].description;
    }",5,,76,4,,void
104962,BLOCK,-1,,<empty>,13,,78,2,,void
104973,BLOCK,-1,,"{
            fprintf(stderr, ""Error: FourCC \""%.4s\"" not mapped!\n"",
                    list[i].fourcc);
            exit(1);
        }",9,,81,2,,void
105029,BLOCK,-1,,<empty>,5,,95,1,,void
105070,BLOCK,-1,,"{
            fprintf(stderr, ""Error: FourCC alias \""%.4s\"" conflict: ""
                    ""\""%.4s\"" and \""%.4s\""\n"", entries[i].alias,
                    entries[i - 1].fourcc, entries[i].fourcc);
            dups++;
        }",9,,98,2,,void
105097,BLOCK,-1,,<empty>,9,,106,2,,void
105104,BLOCK,-1,,<empty>,5,,109,1,,void
105114,BLOCK,4,,"{
        if (!memcmp(entries[i].fourcc, entries[i].alias, 4))
            continue;
        printf(""    { { { 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx } }, ""
               ""{ { 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx } } },\n"",
               entries[i].alias[0], entries[i].alias[1], entries[i].alias[2],
               entries[i].alias[3], entries[i].fourcc[0], entries[i].fourcc[1],
               entries[i].fourcc[2], entries[i].fourcc[3]);
    }",5,,110,4,,void
105129,BLOCK,-1,,<empty>,13,,112,2,,void
105195,BLOCK,-1,,<empty>,5,,121,1,,void
105205,BLOCK,4,,"{
        if (entries[i].desc == NULL)
            continue;
        printf(""    { { { 0x%02hhx, 0x%02hhx, 0x%02hhx, 0x%02hhx } }, ""
               ""\""%s\"" },\n"", entries[i].alias[0], entries[i].alias[1],
               entries[i].alias[2], entries[i].alias[3], entries[i].desc);
    }",5,,122,4,,void
105214,BLOCK,-1,,<empty>,13,,124,2,,void
105264,BLOCK,-1,,"{
    puts(""/* This file is generated automatically. DO NOT EDIT! */"");
    puts(""struct fourcc_mapping {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    union { unsigned char fourcc_str[4]; vlc_fourcc_t fourcc; };"");
    puts(""};"");
    puts(""struct fourcc_desc {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    const char desc[52];"");
    puts(""};"");

#define p(t) \
    process_list(#t, p_list_##t, \
                 sizeof (p_list_##t) / sizeof ((p_list_##t)[0]))
    p(video);
    p(audio);
    p(spu);
    return 0;
}",1,,136,2,,void
105284,BLOCK,1,,<empty>,,,,1,,void
105296,BLOCK,1,,<empty>,,,,1,,void
105308,BLOCK,1,,<empty>,,,,1,,void
105327,BLOCK,-1,,<empty>,1,,1,1,,ANY
108243,BLOCK,-1,,<empty>,1,,1,1,,ANY
108255,BLOCK,-1,,"{
    size_t attrlen = strlen( attr );
    const char * str = strchr( cookie, ';' );
    while( str )
    {
        /* skip ; and blank */
        str++;
        str = str + strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=') )
        {
            str += attrlen + 1;
            size_t value_length = strcspn( str, "";"" );
            return strndup( str, value_length );
        }

        str = strchr( str, ';' );
    }
    return NULL;
}",1,,49,3,,void
108269,BLOCK,-1,,"{
        /* skip ; and blank */
        str++;
        str = str + strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=') )
        {
            str += attrlen + 1;
            size_t value_length = strcspn( str, "";"" );
            return strndup( str, value_length );
        }

        str = strchr( str, ';' );
    }",5,,53,2,,void
108291,BLOCK,-1,,"{
            str += attrlen + 1;
            size_t value_length = strcspn( str, "";"" );
            return strndup( str, value_length );
        }",9,,60,2,,void
108319,BLOCK,-1,,"{
    size_t attrlen = strlen(attr);
    const char * str = strchr(cookie, ';');
    while( str )
    {
        /* skip ; and blank */
        str++;
        str += strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=' || str[attrlen] == ';' || str[attrlen] == '\0') )
            return true;

        str = strchr(str, ';');
    }
    return false;
}",1,,72,3,,void
108333,BLOCK,-1,,"{
        /* skip ; and blank */
        str++;
        str += strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=' || str[attrlen] == ';' || str[attrlen] == '\0') )
            return true;

        str = strchr(str, ';');
    }",5,,76,2,,void
108365,BLOCK,-1,,<empty>,13,,83,2,,void
108379,BLOCK,-1,,"{
    char *domain = cookie_get_attribute_value( cookie, ""domain"" );
    if( domain == NULL )
        return NULL;

    if( domain[0] == '.' )
    {
        const char *real_domain = domain + strspn( domain, ""."" );
        memmove( domain, real_domain, strlen( real_domain ) + 1 );
    }
    return domain;
}",1,,92,2,,void
108390,BLOCK,-1,,<empty>,9,,95,2,,void
108399,BLOCK,-1,,"{
        const char *real_domain = domain + strspn( domain, ""."" );
        memmove( domain, real_domain, strlen( real_domain ) + 1 );
    }",5,,98,2,,void
108422,BLOCK,-1,,"{
    // TODO: should convert domain names to punycode before comparing

    if (host == NULL)
        return false;
    if ( vlc_ascii_strcasecmp(cookie->psz_domain, host) == 0 )
        return true;
    else if ( cookie->b_host_only )
        return false;

    size_t host_len = strlen(host);
    size_t cookie_domain_len = strlen(cookie->psz_domain);
    bool is_suffix = false, has_dot_before_suffix = false;

    if( host_len > cookie_domain_len )
    {
        size_t i = host_len - cookie_domain_len;

        is_suffix = vlc_ascii_strcasecmp( &host[i], cookie->psz_domain ) == 0;
        has_dot_before_suffix = host[i-1] == '.';
    }

    bool host_is_ipv4 = strspn(host, ""0123456789."") == host_len;
    bool host_is_ipv6 = strchr(host, ':') != NULL;
    return is_suffix && has_dot_before_suffix &&
        !( host_is_ipv4 || host_is_ipv6 );
}",1,,107,3,,void
108427,BLOCK,-1,,<empty>,9,,111,2,,void
108438,BLOCK,-1,,<empty>,9,,113,2,,void
108442,BLOCK,-1,,<empty>,10,,114,1,,void
108447,BLOCK,-1,,<empty>,9,,115,2,,void
108474,BLOCK,-1,,"{
        size_t i = host_len - cookie_domain_len;

        is_suffix = vlc_ascii_strcasecmp( &host[i], cookie->psz_domain ) == 0;
        has_dot_before_suffix = host[i-1] == '.';
    }",5,,122,2,,void
108531,BLOCK,-1,,"{
    return cookie_get_attribute_value(cookie, ""path"");
}",1,,136,2,,void
108541,BLOCK,-1,,"{
    if (uripath == NULL )
        return false;
    else if ( strcmp(cookie->psz_path, uripath) == 0 )
        return true;

    size_t path_len = strlen( uripath );
    size_t prefix_len = strlen( cookie->psz_path );
    return ( path_len > prefix_len ) &&
        ( strncmp(uripath, cookie->psz_path, prefix_len) == 0 ) &&
        ( uripath[prefix_len - 1] == '/' || uripath[prefix_len] == '/' );
}",1,,141,3,,void
108546,BLOCK,-1,,<empty>,9,,143,2,,void
108550,BLOCK,-1,,<empty>,10,,144,1,,void
108559,BLOCK,-1,,<empty>,9,,145,2,,void
108608,BLOCK,-1,,"{
    bool protocol_ok = secure || !cookie->b_secure;
    bool domain_ok = cookie_domain_matches(cookie, host);
    bool path_ok = cookie_path_matches(cookie, path);
    return protocol_ok && domain_ok && path_ok;
}",1,,156,5,,void
108640,BLOCK,-1,,"{
    if ( request_path == NULL || request_path[0] != '/' )
        return strdup(""/"");

    char *path;
    const char *query_start = strchr( request_path, '?' );
    if ( query_start != NULL )
        path = strndup( request_path, query_start - request_path );
    else
        path = strdup( request_path );

    if ( path == NULL )
        return NULL;

    char *last_slash = strrchr(path, '/');
    assert(last_slash != NULL);
    if ( last_slash == path )
        path[1] = '\0';
    else
        *last_slash = '\0';

    return path;
}",1,,164,2,,void
108651,BLOCK,-1,,<empty>,9,,166,2,,void
108666,BLOCK,-1,,<empty>,9,,171,2,,void
108675,BLOCK,-1,,<empty>,9,,173,1,,void
108684,BLOCK,-1,,<empty>,9,,176,2,,void
108701,BLOCK,-1,,<empty>,9,,181,2,,void
108708,BLOCK,-1,,<empty>,9,,183,1,,void
108719,BLOCK,-1,,"{
    assert(cookie != NULL);
    free(cookie->psz_name);
    free(cookie->psz_value);
    free(cookie->psz_domain);
    free(cookie->psz_path);
    free(cookie);
}",1,,189,2,,void
108750,BLOCK,-1,,"{
    http_cookie_t *cookie = malloc(sizeof (*cookie));
    if (unlikely(cookie == NULL))
        return NULL;

    cookie->psz_domain = NULL;
    cookie->psz_path = NULL;

    /* Get the NAME=VALUE part of the Cookie */
    size_t value_length = strcspn(value, "";"");
    const char *p = memchr(value, '=', value_length);

    if (p != NULL)
    {
        cookie->psz_name = strndup(value, p - value);
        p++;
        cookie->psz_value = strndup(p, value_length - (p - value));
        if (unlikely(cookie->psz_value == NULL))
            goto error;
    }
    else
    {
        cookie->psz_name = strndup(value, value_length);
        cookie->psz_value = NULL;
    }

    if (unlikely(cookie->psz_name == NULL))
        goto error;

    /* Cookie name is a token; it cannot be empty. */
    if (cookie->psz_name[0] == '\0')
        goto error;

    /* Get domain */
    cookie->psz_domain = cookie_get_domain(value);
    if (cookie->psz_domain == NULL)
    {
        cookie->psz_domain = st...",1,,201,4,,void
108763,BLOCK,-1,,<empty>,9,,204,2,,void
108793,BLOCK,-1,,"{
        cookie->psz_name = strndup(value, p - value);
        p++;
        cookie->psz_value = strndup(p, value_length - (p - value));
        if (unlikely(cookie->psz_value == NULL))
            goto error;
    }",5,,214,2,,void
108823,BLOCK,-1,,<empty>,13,,219,2,,void
108826,BLOCK,-1,,"{
        cookie->psz_name = strndup(value, value_length);
        cookie->psz_value = NULL;
    }",5,,222,1,,void
108846,BLOCK,-1,,<empty>,9,,228,2,,void
108856,BLOCK,-1,,<empty>,9,,232,2,,void
108870,BLOCK,-1,,"{
        cookie->psz_domain = strdup(host);
        if (unlikely(cookie->psz_domain == NULL))
            goto error;

        cookie->b_host_only = true;
    }",5,,237,2,,void
108884,BLOCK,-1,,<empty>,13,,240,2,,void
108892,BLOCK,-1,,<empty>,9,,245,1,,void
108910,BLOCK,-1,,"{
        cookie->psz_path = cookie_default_path(path);
        if (unlikely(cookie->psz_path == NULL))
            goto error;
    }",5,,250,2,,void
108924,BLOCK,-1,,<empty>,13,,253,2,,void
108947,BLOCK,-1,,"{
    vlc_http_cookie_jar_t * jar = malloc( sizeof( vlc_http_cookie_jar_t ) );
    if ( unlikely(jar == NULL) )
        return NULL;

    vlc_array_init( &jar->cookies );
    vlc_mutex_init( &jar->lock );

    return jar;
}",1,,273,2,,void
108959,BLOCK,-1,,<empty>,9,,276,2,,void
108978,BLOCK,-1,,"{
    if ( !p_jar )
        return;

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
        cookie_destroy( vlc_array_item_at_index( &p_jar->cookies, i ) );

    vlc_array_clear( &p_jar->cookies );
    vlc_mutex_destroy( &p_jar->lock );

    free( p_jar );
}",1,,285,2,,void
108982,BLOCK,-1,,<empty>,9,,287,2,,void
108985,BLOCK,-1,,<empty>,5,,289,1,,void
109025,BLOCK,-1,,"{
    assert(host != NULL);
    assert(path != NULL);

    http_cookie_t *cookie = cookie_parse(cookies, host, path);
    if (cookie == NULL)
        return false;

    /* Check if a cookie from host should be added to the cookie jar */
    // FIXME: should check if domain is one of ""public suffixes"" at
    // http://publicsuffix.org/. The purpose of this check is to
    // prevent a host from setting a ""too wide"" cookie, for example
    // ""example.com"" should not be able to set a cookie for ""com"".
    // The current implementation prevents all top-level domains.
    if (strchr(cookie->psz_domain, '.') == NULL
     || !cookie_domain_matches(cookie, host))
    {
        cookie_destroy(cookie);
        return false;
    }

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        http_cookie_t *iter = vlc_array_item_at_index( &p_jar->cookies, i );

        assert( iter->psz_name );
        assert( iter->psz_domain );
     ...",1,,300,5,,void
109045,BLOCK,-1,,<empty>,9,,306,2,,void
109061,BLOCK,-1,,"{
        cookie_destroy(cookie);
        return false;
    }",5,,316,2,,void
109072,BLOCK,-1,,<empty>,5,,323,1,,void
109086,BLOCK,4,,"{
        http_cookie_t *iter = vlc_array_item_at_index( &p_jar->cookies, i );

        assert( iter->psz_name );
        assert( iter->psz_domain );
        assert( iter->psz_path );

        bool domains_match =
            vlc_ascii_strcasecmp( cookie->psz_domain, iter->psz_domain ) == 0;
        bool paths_match = strcmp( cookie->psz_path, iter->psz_path ) == 0;
        bool names_match = strcmp( cookie->psz_name, iter->psz_name ) == 0;
        if( domains_match && paths_match && names_match )
        {
            /* Remove previous value for this cookie */
            vlc_array_remove( &p_jar->cookies, i );
            cookie_destroy(iter);
            break;
        }
    }",5,,324,4,,void
109150,BLOCK,-1,,"{
            /* Remove previous value for this cookie */
            vlc_array_remove( &p_jar->cookies, i );
            cookie_destroy(iter);
            break;
        }",9,,336,2,,void
109174,BLOCK,-1,,<empty>,9,,346,2,,void
109191,BLOCK,-1,,"{
    char *psz_cookiebuf = NULL;

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        const http_cookie_t * cookie = vlc_array_item_at_index( &p_jar->cookies, i );
        if (cookie_should_be_sent(cookie, secure, host, path))
        {
            char *psz_updated_buf = NULL;
            if ( asprintf(&psz_updated_buf, ""%s%s%s=%s"",
                          psz_cookiebuf ? psz_cookiebuf : """",
                          psz_cookiebuf ? ""; "" : """",
                          cookie->psz_name ? cookie->psz_name : """",
                          cookie->psz_value ? cookie->psz_value : """") == -1 )
            {
                // TODO: report error
                free( psz_cookiebuf );
                vlc_mutex_unlock( &p_jar->lock );
                return NULL;
            }
            free( psz_cookiebuf );
            psz_cookiebuf = psz_updated_buf;
        }
    }

    vlc_mutex_unlock( &p_jar->lock );

    return ...",1,,355,5,,void
109202,BLOCK,-1,,<empty>,5,,360,1,,void
109216,BLOCK,4,,"{
        const http_cookie_t * cookie = vlc_array_item_at_index( &p_jar->cookies, i );
        if (cookie_should_be_sent(cookie, secure, host, path))
        {
            char *psz_updated_buf = NULL;
            if ( asprintf(&psz_updated_buf, ""%s%s%s=%s"",
                          psz_cookiebuf ? psz_cookiebuf : """",
                          psz_cookiebuf ? ""; "" : """",
                          cookie->psz_name ? cookie->psz_name : """",
                          cookie->psz_value ? cookie->psz_value : """") == -1 )
            {
                // TODO: report error
                free( psz_cookiebuf );
                vlc_mutex_unlock( &p_jar->lock );
                return NULL;
            }
            free( psz_cookiebuf );
            psz_cookiebuf = psz_updated_buf;
        }
    }",5,,361,4,,void
109232,BLOCK,-1,,"{
            char *psz_updated_buf = NULL;
            if ( asprintf(&psz_updated_buf, ""%s%s%s=%s"",
                          psz_cookiebuf ? psz_cookiebuf : """",
                          psz_cookiebuf ? ""; "" : """",
                          cookie->psz_name ? cookie->psz_name : """",
                          cookie->psz_value ? cookie->psz_value : """") == -1 )
            {
                // TODO: report error
                free( psz_cookiebuf );
                vlc_mutex_unlock( &p_jar->lock );
                return NULL;
            }
            free( psz_cookiebuf );
            psz_cookiebuf = psz_updated_buf;
        }",9,,364,2,,void
109269,BLOCK,-1,,"{
                // TODO: report error
                free( psz_cookiebuf );
                vlc_mutex_unlock( &p_jar->lock );
                return NULL;
            }",13,,371,2,,void
109325,BLOCK,-1,,<empty>,1,,1,1,,ANY
109331,BLOCK,-1,,<empty>,,,,5,,<empty>
109339,BLOCK,-1,,<empty>,,,,5,,<empty>
109347,BLOCK,-1,,<empty>,,,,5,,<empty>
109356,BLOCK,-1,,<empty>,,,,6,,<empty>
109364,BLOCK,-1,,<empty>,,,,5,,<empty>
109370,BLOCK,-1,,<empty>,,,,3,,<empty>
109375,BLOCK,-1,,<empty>,,,,2,,<empty>
109382,BLOCK,-1,,<empty>,,,,4,,<empty>
109387,BLOCK,-1,,<empty>,,,,2,,<empty>
109394,BLOCK,-1,,<empty>,,,,4,,<empty>
109399,BLOCK,-1,,<empty>,,,,2,,<empty>
109404,BLOCK,-1,,<empty>,,,,2,,<empty>
109409,BLOCK,-1,,<empty>,,,,2,,<empty>
109414,BLOCK,-1,,"{
    image_handler_t *p_image = calloc( 1, sizeof(image_handler_t) );
    if( !p_image )
        return NULL;

    p_image->p_parent = p_this;

    p_image->pf_read = ImageRead;
    p_image->pf_read_url = ImageReadUrl;
    p_image->pf_write = ImageWrite;
    p_image->pf_write_url = ImageWriteUrl;
    p_image->pf_convert = ImageConvert;

    p_image->outfifo = picture_fifo_New();

    return p_image;
}",1,,83,2,,void
109425,BLOCK,-1,,<empty>,9,,86,2,,void
109469,BLOCK,-1,,"{
    if( !p_image ) return;

    if( p_image->p_dec ) DeleteDecoder( p_image->p_dec );
    if( p_image->p_enc ) DeleteEncoder( p_image->p_enc );
    if( p_image->p_filter ) DeleteFilter( p_image->p_filter );

    picture_fifo_Delete( p_image->outfifo );

    free( p_image );
    p_image = NULL;
}",1,,106,2,,void
109473,BLOCK,-1,,<empty>,20,,107,2,,void
109479,BLOCK,-1,,<empty>,26,,109,2,,void
109488,BLOCK,-1,,<empty>,26,,110,2,,void
109497,BLOCK,-1,,<empty>,29,,111,2,,void
109516,BLOCK,-1,,"{
    image_handler_t *p_image = p_dec->p_queue_ctx;
    picture_fifo_Push( p_image->outfifo, p_pic );
    return 0;
}",1,,125,3,,void
109537,BLOCK,-1,,"{
    picture_t *p_pic = NULL;

    /* Check if we can reuse the current decoder */
    if( p_image->p_dec &&
        p_image->p_dec->fmt_in.i_codec != p_fmt_in->i_chroma )
    {
        DeleteDecoder( p_image->p_dec );
        p_image->p_dec = 0;
    }

    /* Start a decoder */
    if( !p_image->p_dec )
    {
        p_image->p_dec = CreateDecoder( p_image->p_parent, p_fmt_in );
        if( !p_image->p_dec )
        {
            block_Release(p_block);
            return NULL;
        }
        if( p_image->p_dec->fmt_out.i_cat != VIDEO_ES )
        {
            DeleteDecoder( p_image->p_dec );
            p_image->p_dec = NULL;
            block_Release(p_block);
            return NULL;
        }
        p_image->p_dec->pf_queue_video = ImageQueueVideo;
        p_image->p_dec->p_queue_ctx = p_image;
    }

    p_block->i_pts = p_block->i_dts = mdate();
    int ret = p_image->p_dec->pf_decode( p_image->p_dec, p_block );
    if( ret == VLCDEC_SUCCESS )
    {
        /* Drain */
...",1,,134,5,,void
109558,BLOCK,-1,,"{
        DeleteDecoder( p_image->p_dec );
        p_image->p_dec = 0;
    }",5,,140,2,,void
109573,BLOCK,-1,,"{
        p_image->p_dec = CreateDecoder( p_image->p_parent, p_fmt_in );
        if( !p_image->p_dec )
        {
            block_Release(p_block);
            return NULL;
        }
        if( p_image->p_dec->fmt_out.i_cat != VIDEO_ES )
        {
            DeleteDecoder( p_image->p_dec );
            p_image->p_dec = NULL;
            block_Release(p_block);
            return NULL;
        }
        p_image->p_dec->pf_queue_video = ImageQueueVideo;
        p_image->p_dec->p_queue_ctx = p_image;
    }",5,,147,2,,void
109588,BLOCK,-1,,"{
            block_Release(p_block);
            return NULL;
        }",9,,150,2,,void
109603,BLOCK,-1,,"{
            DeleteDecoder( p_image->p_dec );
            p_image->p_dec = NULL;
            block_Release(p_block);
            return NULL;
        }",9,,155,2,,void
109657,BLOCK,-1,,"{
        /* Drain */
        p_image->p_dec->pf_decode( p_image->p_dec, NULL );

        p_pic = picture_fifo_Pop( p_image->outfifo );

        unsigned lostcount = 0;
        picture_t *lostpic;
        while( ( lostpic = picture_fifo_Pop( p_image->outfifo ) ) != NULL )
        {
            picture_Release( lostpic );
            lostcount++;
        }
        if( lostcount > 0 )
            msg_Warn( p_image->p_parent, ""Image decoder output more than one ""
                      ""picture (%d)"", lostcount );
    }",5,,168,2,,void
109688,BLOCK,-1,,"{
            picture_Release( lostpic );
            lostcount++;
        }",9,,177,2,,void
109697,BLOCK,-1,,<empty>,13,,182,2,,void
109708,BLOCK,-1,,"{
        msg_Warn( p_image->p_parent, ""no image decoded"" );
        return 0;
    }",5,,187,2,,void
109721,BLOCK,-1,,<empty>,9,,193,2,,void
109744,BLOCK,-1,,<empty>,9,,195,2,,void
109803,BLOCK,-1,,<empty>,9,,202,2,,void
109858,BLOCK,-1,,<empty>,9,,208,2,,void
109877,BLOCK,-1,,<empty>,9,,210,2,,void
109896,BLOCK,-1,,<empty>,9,,212,2,,void
109909,BLOCK,-1,,<empty>,9,,214,2,,void
109923,BLOCK,-1,,<empty>,9,,216,2,,void
109943,BLOCK,-1,,<empty>,9,,218,2,,void
109963,BLOCK,-1,,<empty>,9,,220,2,,void
110019,BLOCK,-1,,"{
        if( p_image->p_filter )
        if( p_image->p_filter->fmt_in.video.i_chroma !=
            p_image->p_dec->fmt_out.video.i_chroma ||
            p_image->p_filter->fmt_out.video.i_chroma != p_fmt_out->i_chroma )
        {
            /* We need to restart a new filter */
            DeleteFilter( p_image->p_filter );
            p_image->p_filter = 0;
        }

        /* Start a filter */
        if( !p_image->p_filter )
        {
            p_image->p_filter =
                CreateFilter( p_image->p_parent, &p_image->p_dec->fmt_out,
                              p_fmt_out );

            if( !p_image->p_filter )
            {
                picture_Release( p_pic );
                return NULL;
            }
        }
        else
        {
            /* Filters should handle on-the-fly size changes */
            p_image->p_filter->fmt_in = p_image->p_dec->fmt_out;
            p_image->p_filter->fmt_out = p_image->p_dec->fmt_out;
            p_image->p_filter->fmt...",5,,226,2,,void
110024,BLOCK,-1,,<empty>,9,,228,2,,void
110059,BLOCK,-1,,"{
            /* We need to restart a new filter */
            DeleteFilter( p_image->p_filter );
            p_image->p_filter = 0;
        }",9,,231,2,,void
110074,BLOCK,-1,,"{
            p_image->p_filter =
                CreateFilter( p_image->p_parent, &p_image->p_dec->fmt_out,
                              p_fmt_out );

            if( !p_image->p_filter )
            {
                picture_Release( p_pic );
                return NULL;
            }
        }",9,,239,2,,void
110095,BLOCK,-1,,"{
                picture_Release( p_pic );
                return NULL;
            }",13,,245,2,,void
110101,BLOCK,-1,,"{
            /* Filters should handle on-the-fly size changes */
            p_image->p_filter->fmt_in = p_image->p_dec->fmt_out;
            p_image->p_filter->fmt_out = p_image->p_dec->fmt_out;
            p_image->p_filter->fmt_out.i_codec = p_fmt_out->i_chroma;
            p_image->p_filter->fmt_out.video = *p_fmt_out;
        }",9,,251,1,,void
110170,BLOCK,-1,,"{
        video_format_Clean( p_fmt_out );
        video_format_Copy( p_fmt_out, &p_image->p_dec->fmt_out.video );
    }",5,,265,1,,void
110192,BLOCK,-1,,"{
    block_t *p_block;
    picture_t *p_pic;
    stream_t *p_stream = NULL;
    uint64_t i_size;

    p_stream = vlc_stream_NewURL( p_image->p_parent, psz_url );

    if( !p_stream )
    {
        msg_Dbg( p_image->p_parent, ""could not open %s for reading"",
                 psz_url );
        return NULL;
    }

    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > SSIZE_MAX )
    {
        msg_Dbg( p_image->p_parent, ""could not read %s"", psz_url );
        goto error;
    }

    p_block = vlc_stream_Block( p_stream, i_size );
    if( p_block == NULL )
        goto error;

    if( !p_fmt_in->i_chroma )
    {
        char *psz_mime = stream_MimeType( p_stream );
        if( psz_mime != NULL )
        {
            p_fmt_in->i_chroma = image_Mime2Fourcc( psz_mime );
            free( psz_mime );
        }
    }
    vlc_stream_Delete( p_stream );

    if( !p_fmt_in->i_chroma )
    {
        /* Try to guess format from file name */
        p_fmt_in->i_chroma = image_Ext2Fourcc( p...",1,,276,5,,void
110210,BLOCK,-1,,"{
        msg_Dbg( p_image->p_parent, ""could not open %s for reading"",
                 psz_url );
        return NULL;
    }",5,,285,2,,void
110228,BLOCK,-1,,"{
        msg_Dbg( p_image->p_parent, ""could not read %s"", psz_url );
        goto error;
    }",5,,292,2,,void
110245,BLOCK,-1,,<empty>,9,,299,2,,void
110252,BLOCK,-1,,"{
        char *psz_mime = stream_MimeType( p_stream );
        if( psz_mime != NULL )
        {
            p_fmt_in->i_chroma = image_Mime2Fourcc( psz_mime );
            free( psz_mime );
        }
    }",5,,302,2,,void
110262,BLOCK,-1,,"{
            p_fmt_in->i_chroma = image_Mime2Fourcc( psz_mime );
            free( psz_mime );
        }",9,,305,2,,void
110278,BLOCK,-1,,"{
        /* Try to guess format from file name */
        p_fmt_in->i_chroma = image_Ext2Fourcc( psz_url );
    }",5,,313,2,,void
110304,BLOCK,-1,,"{
    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
        video_format_FixRgb( &v2 );

        if( v1.i_rmask != v2.i_rmask ||
            v1.i_gmask != v2.i_gmask ||
            v1.i_bmask != v2.i_bmask )
            return false;
    }
    return true;
}",1,,329,3,,void
110329,BLOCK,-1,,"{
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
        video_format_FixRgb( &v2 );

        if( v1.i_rmask != v2.i_rmask ||
            v1.i_gmask != v2.i_gmask ||
            v1.i_bmask != v2.i_bmask )
            return false;
    }",5,,334,2,,void
110370,BLOCK,-1,,<empty>,13,,344,2,,void
110382,BLOCK,-1,,"{
    block_t *p_block;

    /* Check if we can reuse the current encoder */
    if( p_image->p_enc &&
        ( p_image->p_enc->fmt_out.i_codec != p_fmt_out->i_chroma ||
          p_image->p_enc->fmt_out.video.i_width != p_fmt_out->i_width ||
          p_image->p_enc->fmt_out.video.i_height != p_fmt_out->i_height ) )
    {
        DeleteEncoder( p_image->p_enc );
        p_image->p_enc = 0;
    }

    /* Start an encoder */
    if( !p_image->p_enc )
    {
        p_image->p_enc = CreateEncoder( p_image->p_parent,
                                        p_fmt_in, p_fmt_out );
        if( !p_image->p_enc ) return NULL;
    }

    /* Check if we need chroma conversion or resizing */
    if( p_image->p_enc->fmt_in.video.i_chroma != p_fmt_in->i_chroma ||
        p_image->p_enc->fmt_in.video.i_width != p_fmt_in->i_width ||
        p_image->p_enc->fmt_in.video.i_height != p_fmt_in->i_height ||
       !BitMapFormatIsSimilar( &p_image->p_enc->fmt_in.video, p_fmt_in ) )
    {
        picture...",1,,357,5,,void
110428,BLOCK,-1,,"{
        DeleteEncoder( p_image->p_enc );
        p_image->p_enc = 0;
    }",5,,365,2,,void
110443,BLOCK,-1,,"{
        p_image->p_enc = CreateEncoder( p_image->p_parent,
                                        p_fmt_in, p_fmt_out );
        if( !p_image->p_enc ) return NULL;
    }",5,,372,2,,void
110459,BLOCK,-1,,<empty>,31,,375,2,,void
110516,BLOCK,-1,,"{
        picture_t *p_tmp_pic;

        if( p_image->p_filter )
        if( p_image->p_filter->fmt_in.video.i_chroma != p_fmt_in->i_chroma ||
            p_image->p_filter->fmt_out.video.i_chroma !=
            p_image->p_enc->fmt_in.video.i_chroma ||
           !BitMapFormatIsSimilar( &p_image->p_filter->fmt_in.video, p_fmt_in ) )
        {
            /* We need to restart a new filter */
            DeleteFilter( p_image->p_filter );
            p_image->p_filter = 0;
        }

        /* Start a filter */
        if( !p_image->p_filter )
        {
            es_format_t fmt_in;
            es_format_Init( &fmt_in, VIDEO_ES, p_fmt_in->i_chroma );
            fmt_in.video = *p_fmt_in;

            p_image->p_filter =
                CreateFilter( p_image->p_parent, &fmt_in,
                              &p_image->p_enc->fmt_in.video );

            if( !p_image->p_filter )
            {
                return NULL;
            }
        }
        else
        {
            /* F...",5,,383,2,,void
110522,BLOCK,-1,,<empty>,9,,387,2,,void
110569,BLOCK,-1,,"{
            /* We need to restart a new filter */
            DeleteFilter( p_image->p_filter );
            p_image->p_filter = 0;
        }",9,,391,2,,void
110584,BLOCK,-1,,"{
            es_format_t fmt_in;
            es_format_Init( &fmt_in, VIDEO_ES, p_fmt_in->i_chroma );
            fmt_in.video = *p_fmt_in;

            p_image->p_filter =
                CreateFilter( p_image->p_parent, &fmt_in,
                              &p_image->p_enc->fmt_in.video );

            if( !p_image->p_filter )
            {
                return NULL;
            }
        }",9,,399,2,,void
110622,BLOCK,-1,,"{
                return NULL;
            }",13,,409,2,,void
110626,BLOCK,-1,,"{
            /* Filters should handle on-the-fly size changes */
            p_image->p_filter->fmt_in.i_codec = p_fmt_in->i_chroma;
            p_image->p_filter->fmt_out.video = *p_fmt_in;
            p_image->p_filter->fmt_out.i_codec =p_image->p_enc->fmt_in.i_codec;
            p_image->p_filter->fmt_out.video = p_image->p_enc->fmt_in.video;
        }",9,,414,1,,void
110697,BLOCK,-1,,"{
            p_block = p_image->p_enc->pf_encode_video( p_image->p_enc,
                                                       p_tmp_pic );
            picture_Release( p_tmp_pic );
        }",9,,428,2,,void
110713,BLOCK,-1,,<empty>,13,,434,1,,void
110718,BLOCK,-1,,"{
        p_block = p_image->p_enc->pf_encode_video( p_image->p_enc, p_pic );
    }",5,,437,1,,void
110734,BLOCK,-1,,"{
        msg_Dbg( p_image->p_parent, ""no image encoded"" );
        return 0;
    }",5,,442,2,,void
110752,BLOCK,-1,,"{
    block_t *p_block;
    FILE *file;

    if( !p_fmt_out->i_chroma )
    {
        /* Try to guess format from file name */
        p_fmt_out->i_chroma = image_Ext2Fourcc( psz_url );
    }

    file = vlc_fopen( psz_url, ""wb"" );
    if( !file )
    {
        msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
        return VLC_EGENERIC;
    }

    p_block = ImageWrite( p_image, p_pic, p_fmt_in, p_fmt_out );

    int err = 0;
    if( p_block )
    {
        if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, file ) != 1 )
            err = errno;
        block_Release( p_block );
    }

    if( fclose( file ) && !err )
        err = errno;

    if( err )
    {
       errno = err;
       msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
    }

    return err ? VLC_EGENERIC : VLC_SUCCESS;
}",1,,453,6,,void
110760,BLOCK,-1,,"{
        /* Try to guess format from file name */
        p_fmt_out->i_chroma = image_Ext2Fourcc( psz_url );
    }",5,,458,2,,void
110775,BLOCK,-1,,"{
        msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
        return VLC_EGENERIC;
    }",5,,465,2,,void
110799,BLOCK,-1,,"{
        if( fwrite( p_block->p_buffer, p_block->i_buffer, 1, file ) != 1 )
            err = errno;
        block_Release( p_block );
    }",5,,474,2,,void
110812,BLOCK,-1,,<empty>,13,,476,2,,void
110824,BLOCK,-1,,<empty>,9,,481,2,,void
110830,BLOCK,-1,,"{
       errno = err;
       msg_Err( p_image->p_parent, ""%s: %s"", psz_url, vlc_strerror_c(errno) );
    }",5,,484,2,,void
110854,BLOCK,-1,,"{
    picture_t *p_pif;

    if( !p_fmt_out->i_width && !p_fmt_out->i_height &&
        p_fmt_out->i_sar_num && p_fmt_out->i_sar_den &&
        p_fmt_out->i_sar_num * p_fmt_in->i_sar_den !=
        p_fmt_out->i_sar_den * p_fmt_in->i_sar_num )
    {
        p_fmt_out->i_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_width / p_fmt_in->i_sar_den / p_fmt_out->i_sar_num;
        p_fmt_out->i_visible_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_visible_width / p_fmt_in->i_sar_den /
            p_fmt_out->i_sar_num;
    }

    if( !p_fmt_out->i_chroma ) p_fmt_out->i_chroma = p_fmt_in->i_chroma;
    if( !p_fmt_out->i_width )
        p_fmt_out->i_width = p_fmt_out->i_visible_width = p_fmt_in->i_width;
    if( !p_fmt_out->i_height )
        p_fmt_out->i_height = p_fmt_out->i_visible_height = p_fmt_in->i_height;
    if( !p_fmt_out->i_sar_num ) p_fmt_out->i_sar_num = p_fmt_in->i_sar_num;
    ...",1,,500,5,,void
110890,BLOCK,-1,,"{
        p_fmt_out->i_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_width / p_fmt_in->i_sar_den / p_fmt_out->i_sar_num;
        p_fmt_out->i_visible_width =
            p_fmt_in->i_sar_num * (int64_t)p_fmt_out->i_sar_den *
            p_fmt_in->i_visible_width / p_fmt_in->i_sar_den /
            p_fmt_out->i_sar_num;
    }",5,,507,2,,void
110946,BLOCK,-1,,<empty>,32,,517,2,,void
110959,BLOCK,-1,,<empty>,9,,519,2,,void
110976,BLOCK,-1,,<empty>,9,,521,2,,void
110993,BLOCK,-1,,<empty>,33,,522,2,,void
111006,BLOCK,-1,,<empty>,33,,523,2,,void
111018,BLOCK,-1,,<empty>,5,,526,2,,void
111047,BLOCK,-1,,"{
        /* We need to restart a new filter */
        DeleteFilter( p_image->p_filter );
        p_image->p_filter = NULL;
    }",5,,528,2,,void
111062,BLOCK,-1,,"{
        es_format_t fmt_in;
        es_format_Init( &fmt_in, VIDEO_ES, p_fmt_in->i_chroma );
        fmt_in.video = *p_fmt_in;

        p_image->p_filter =
            CreateFilter( p_image->p_parent, &fmt_in, p_fmt_out );

        if( !p_image->p_filter )
        {
            return NULL;
        }
    }",5,,536,2,,void
111093,BLOCK,-1,,"{
            return NULL;
        }",9,,545,2,,void
111097,BLOCK,-1,,"{
        /* Filters should handle on-the-fly size changes */
        p_image->p_filter->fmt_in.video = *p_fmt_in;
        p_image->p_filter->fmt_out.video = *p_fmt_out;
    }",5,,550,1,,void
111156,BLOCK,-1,,"{
        /* Duplicate image */
        picture_Release( p_pif ); /* XXX: Better fix must be possible */
        p_pif = filter_NewPicture( p_image->p_filter );
        if( p_pif )
            picture_Copy( p_pif, p_pic );
    }",5,,563,2,,void
111167,BLOCK,-1,,<empty>,13,,568,2,,void
111179,BLOCK,-1,,<empty>,,,,1,,<empty>
111273,BLOCK,-1,,"{
    for( unsigned i = 0; i < ARRAY_SIZE(ext_table); i++ )
        if( !strcasecmp( ext_table[i].psz_ext, psz_type ) )
            return ext_table[i].i_codec;

    return 0;
}",1,,609,2,,void
111275,BLOCK,-1,,<empty>,5,,610,1,,void
111295,BLOCK,-1,,<empty>,13,,612,2,,void
111308,BLOCK,-1,,"{
    psz_name = strrchr( psz_name, '.' );
    if( !psz_name ) return 0;
    psz_name++;

    return image_Type2Fourcc( psz_name );
}",1,,618,2,,void
111317,BLOCK,-1,,<empty>,21,,620,2,,void
111394,BLOCK,-1,,"{
    for( int i = 0; mime_table[i].i_codec; i++ )
        if( !strcmp( psz_mime, mime_table[i].psz_mime ) )
            return mime_table[i].i_codec;
    return 0;
}",1,,653,2,,void
111396,BLOCK,-1,,<empty>,5,,654,1,,void
111417,BLOCK,-1,,<empty>,13,,656,2,,void
111430,BLOCK,-1,,"{
    p_dec->fmt_out.video.i_chroma = p_dec->fmt_out.i_codec;
    return 0;
}",1,,661,2,,void
111450,BLOCK,-1,,"{
    return picture_NewFromFormat( &p_dec->fmt_out.video );
}",1,,667,2,,void
111464,BLOCK,-1,,"{
    decoder_t *p_dec;

    p_dec = vlc_custom_create( p_this, sizeof( *p_dec ), ""image decoder"" );
    if( p_dec == NULL )
        return NULL;

    p_dec->p_module = NULL;
    es_format_InitFromVideo( &p_dec->fmt_in, fmt );
    es_format_Init( &p_dec->fmt_out, VIDEO_ES, 0 );
    p_dec->b_frame_drop_allowed = false;

    p_dec->pf_vout_format_update = video_update_format;
    p_dec->pf_vout_buffer_new = video_new_buffer;

    /* Find a suitable decoder module */
    p_dec->p_module = module_need( p_dec, ""video decoder"", ""$codec"", false );
    if( !p_dec->p_module )
    {
        msg_Err( p_dec, ""no suitable decoder module for fourcc `%4.4s'. ""
                 ""VLC probably does not support this image format."",
                 (char*)&p_dec->fmt_in.i_codec );

        DeleteDecoder( p_dec );
        return NULL;
    }

    return p_dec;
}",1,,672,3,,void
111478,BLOCK,-1,,<empty>,9,,677,2,,void
111528,BLOCK,-1,,"{
        msg_Err( p_dec, ""no suitable decoder module for fourcc `%4.4s'. ""
                 ""VLC probably does not support this image format."",
                 (char*)&p_dec->fmt_in.i_codec );

        DeleteDecoder( p_dec );
        return NULL;
    }",5,,690,2,,void
111550,BLOCK,-1,,"{
    if( p_dec->p_module ) module_unneed( p_dec, p_dec->p_module );

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );

    if( p_dec->p_description )
        vlc_meta_Delete( p_dec->p_description );

    vlc_object_release( p_dec );
    p_dec = NULL;
}",1,,703,2,,void
111555,BLOCK,-1,,<empty>,27,,704,2,,void
111575,BLOCK,-1,,<empty>,9,,710,2,,void
111591,BLOCK,-1,,"{
    encoder_t *p_enc;

    p_enc = sout_EncoderCreate( p_this );
    if( p_enc == NULL )
        return NULL;

    p_enc->p_module = NULL;
    es_format_InitFromVideo( &p_enc->fmt_in, fmt_in );

    if( p_enc->fmt_in.video.i_visible_width == 0 ||
        p_enc->fmt_in.video.i_visible_height == 0 ||
        p_enc->fmt_out.video.i_visible_width == 0 ||
        p_enc->fmt_out.video.i_visible_height == 0 )
    {
        if( fmt_out->i_width > 0 && fmt_out->i_height > 0 )
        {
            p_enc->fmt_in.video.i_width = fmt_out->i_width;
            p_enc->fmt_in.video.i_height = fmt_out->i_height;

            if( fmt_out->i_visible_width > 0 &&
                fmt_out->i_visible_height > 0 )
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_visible_width;
                p_enc->fmt_in.video.i_visible_height = fmt_out->i_visible_height;
            }
            else
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_width;
 ...",1,,718,4,,void
111601,BLOCK,-1,,<empty>,9,,723,2,,void
111655,BLOCK,-1,,"{
        if( fmt_out->i_width > 0 && fmt_out->i_height > 0 )
        {
            p_enc->fmt_in.video.i_width = fmt_out->i_width;
            p_enc->fmt_in.video.i_height = fmt_out->i_height;

            if( fmt_out->i_visible_width > 0 &&
                fmt_out->i_visible_height > 0 )
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_visible_width;
                p_enc->fmt_in.video.i_visible_height = fmt_out->i_visible_height;
            }
            else
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_width;
                p_enc->fmt_in.video.i_visible_height = fmt_out->i_height;
            }
        }
    }",5,,732,2,,void
111668,BLOCK,-1,,"{
            p_enc->fmt_in.video.i_width = fmt_out->i_width;
            p_enc->fmt_in.video.i_height = fmt_out->i_height;

            if( fmt_out->i_visible_width > 0 &&
                fmt_out->i_visible_height > 0 )
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_visible_width;
                p_enc->fmt_in.video.i_visible_height = fmt_out->i_visible_height;
            }
            else
            {
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_width;
                p_enc->fmt_in.video.i_visible_height = fmt_out->i_height;
            }
        }",9,,734,2,,void
111703,BLOCK,-1,,"{
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_visible_width;
                p_enc->fmt_in.video.i_visible_height = fmt_out->i_visible_height;
            }",13,,740,2,,void
111727,BLOCK,-1,,"{
                p_enc->fmt_in.video.i_visible_width = fmt_out->i_width;
                p_enc->fmt_in.video.i_visible_height = fmt_out->i_height;
            }",13,,745,1,,void
111751,BLOCK,-1,,<empty>,12,,750,1,,void
111776,BLOCK,-1,,"{
        p_enc->fmt_in.video.i_width =
            fmt_in->i_sar_num * (int64_t)fmt_out->i_sar_den * fmt_in->i_width /
            fmt_in->i_sar_den / fmt_out->i_sar_num;
        p_enc->fmt_in.video.i_visible_width =
            fmt_in->i_sar_num * (int64_t)fmt_out->i_sar_den *
            fmt_in->i_visible_width / fmt_in->i_sar_den / fmt_out->i_sar_num;
    }",5,,753,2,,void
111903,BLOCK,-1,,"{
        msg_Err( p_enc, ""no suitable encoder module for fourcc `%4.4s'.\n""
                 ""VLC probably does not support this image format."",
                 (char*)&p_enc->fmt_out.i_codec );

        DeleteEncoder( p_enc );
        return NULL;
    }",5,,772,2,,void
111938,BLOCK,-1,,"{
    if( p_enc->p_module ) module_unneed( p_enc, p_enc->p_module );

    es_format_Clean( &p_enc->fmt_in );
    es_format_Clean( &p_enc->fmt_out );

    vlc_object_release( p_enc );
    p_enc = NULL;
}",1,,786,2,,void
111943,BLOCK,-1,,<empty>,27,,787,2,,void
111968,BLOCK,-1,,"{
    return picture_NewFromFormat( &p_filter->fmt_out.video );
}",1,,797,2,,void
111983,BLOCK,-1,,"{
    filter_t *p_filter;

    p_filter = vlc_custom_create( p_this, sizeof(filter_t), ""filter"" );
    p_filter->owner.video.buffer_new = filter_new_picture;

    es_format_Copy( &p_filter->fmt_in, p_fmt_in );
    es_format_Copy( &p_filter->fmt_out, p_fmt_in );
    video_format_Copy( &p_filter->fmt_out.video, p_fmt_out );

    /* whatever the input offset, write at offset 0 in the target image */
    p_filter->fmt_out.video.i_x_offset = 0;
    p_filter->fmt_out.video.i_y_offset = 0;

    p_filter->fmt_out.i_codec = p_fmt_out->i_chroma;
    p_filter->p_module = module_need( p_filter, ""video converter"", NULL, false );

    if( !p_filter->p_module )
    {
        msg_Dbg( p_filter, ""no video converter found"" );
        DeleteFilter( p_filter );
        return NULL;
    }

    return p_filter;
}",1,,803,4,,void
112062,BLOCK,-1,,"{
        msg_Dbg( p_filter, ""no video converter found"" );
        DeleteFilter( p_filter );
        return NULL;
    }",5,,821,2,,void
112076,BLOCK,-1,,"{
    if( p_filter->p_module ) module_unneed( p_filter, p_filter->p_module );

    es_format_Clean( &p_filter->fmt_in );
    es_format_Clean( &p_filter->fmt_out );

    vlc_object_release( p_filter );
}",1,,831,2,,void
112081,BLOCK,-1,,<empty>,30,,832,2,,void
112137,BLOCK,-1,,<empty>,1,,1,1,,ANY
112141,BLOCK,-1,,"{
    vlc_mutex_init(&ctx->lock);
    ctx->interrupted = false;
    atomic_init(&ctx->killed, false);
    ctx->callback = NULL;
}",1,,52,2,,void
112167,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = malloc(sizeof (*ctx));
    if (likely(ctx != NULL))
        vlc_interrupt_init(ctx);
    return ctx;
}",1,,60,2,,void
112180,BLOCK,-1,,<empty>,9,,63,2,,void
112189,BLOCK,-1,,"{
    assert(ctx->callback == NULL);
    vlc_mutex_destroy(&ctx->lock);
}",1,,72,2,,void
112205,BLOCK,-1,,"{
    assert(ctx != NULL);
    vlc_interrupt_deinit(ctx);
    free(ctx);
}",1,,78,2,,void
112218,BLOCK,-1,,"{
    assert(ctx != NULL);

    /* This function must be reentrant. But the callback typically is not
     * reentrant. The lock ensures that all calls to the callback for a given
     * context are serialized. The lock also protects against invalid memory
     * accesses to the callback pointer proper, and the interrupted flag. */
    vlc_mutex_lock(&ctx->lock);
    ctx->interrupted = true;
    if (ctx->callback != NULL)
        ctx->callback(ctx->data);
    vlc_mutex_unlock(&ctx->lock);
}",1,,85,2,,void
112239,BLOCK,-1,,<empty>,9,,95,2,,void
112256,BLOCK,-1,,"{
    vlc_interrupt_t *oldctx = vlc_interrupt_var;

    vlc_interrupt_var = newctx;
    return oldctx;
}",1,,100,2,,void
112272,BLOCK,-1,,"{
    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    vlc_mutex_lock(&ctx->lock);
    assert(ctx->callback == NULL);
    ctx->callback = cb;
    ctx->data = data;

    if (unlikely(ctx->interrupted))
        cb(data);
    vlc_mutex_unlock(&ctx->lock);
}",1,,116,4,,void
112307,BLOCK,-1,,<empty>,9,,126,2,,void
112319,BLOCK,-1,,"{
    int ret = 0;

    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    /* Wait for pending callbacks to prevent access by other threads. */
    vlc_mutex_lock(&ctx->lock);
    ctx->callback = NULL;
    if (ctx->interrupted)
    {
        ret = EINTR;
        ctx->interrupted = false;
    }
    vlc_mutex_unlock(&ctx->lock);
    return ret;
}",1,,142,2,,void
112346,BLOCK,-1,,"{
        ret = EINTR;
        ctx->interrupted = false;
    }",5,,152,2,,void
112367,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx != NULL)
        vlc_interrupt_prepare(ctx, cb, opaque);
}",1,,161,3,,void
112376,BLOCK,-1,,<empty>,9,,164,2,,void
112385,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    return (ctx != NULL) ? vlc_interrupt_finish(ctx) : 0;
}",1,,168,2,,void
112402,BLOCK,-1,,"{
    vlc_interrupt_finish(opaque);
}",1,,174,2,,void
112409,BLOCK,-1,,"{
    assert(ctx != NULL);

    atomic_store(&ctx->killed, true);
    vlc_interrupt_raise(ctx);
}",1,,179,2,,void
112426,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = vlc_interrupt_var;

    return (ctx != NULL) && atomic_load(&ctx->killed);
}",1,,187,2,,void
112445,BLOCK,-1,,"{
    vlc_sem_post(opaque);
}",1,,194,2,,void
112452,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return vlc_sem_wait(sem), 0;

    vlc_interrupt_prepare(ctx, vlc_interrupt_sem, sem);

    vlc_cleanup_push(vlc_interrupt_cleanup, ctx);
    vlc_sem_wait(sem);
    vlc_cleanup_pop();

    return vlc_interrupt_finish(ctx);
}",1,,199,2,,void
112461,BLOCK,-1,,<empty>,9,,202,2,,void
112484,BLOCK,-1,,"{
    vlc_cond_signal(opaque);
}",1,,214,2,,void
112491,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = opaque;
    vlc_cond_t *cond = ctx->data;

    vlc_mutex_unlock(&ctx->lock);
    vlc_interrupt_finish(ctx);
    vlc_cond_destroy(cond);
}",1,,219,2,,void
112515,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return mwait(deadline), 0;

    vlc_cond_t wait;
    vlc_cond_init(&wait);

    vlc_interrupt_prepare(ctx, vlc_mwait_i11e_wake, &wait);

    vlc_mutex_lock(&ctx->lock);
    vlc_cleanup_push(vlc_mwait_i11e_cleanup, ctx);
    while (!ctx->interrupted
        && vlc_cond_timedwait(&wait, &ctx->lock, deadline) == 0);
    vlc_cleanup_pop();
    vlc_mutex_unlock(&ctx->lock);

    int ret = vlc_interrupt_finish(ctx);
    vlc_cond_destroy(&wait);
    return ret;
}",1,,229,2,,void
112524,BLOCK,-1,,<empty>,9,,232,2,,void
112583,BLOCK,-1,,"{
    void **data = opaque;
    vlc_interrupt_t *to = data[0];
    vlc_interrupt_t *from = data[1];

    (atomic_load(&from->killed) ? vlc_interrupt_kill
                                : vlc_interrupt_raise)(to);
}",1,,252,2,,void
112615,BLOCK,-1,,"{
    data[0] = data[1] = NULL;

    vlc_interrupt_t *from = vlc_interrupt_var;
    if (from == NULL)
        return;

    assert(from != to);
    data[0] = to;
    data[1] = from;
    vlc_interrupt_prepare(from, vlc_interrupt_forward_wake, data);
}",1,,262,3,,void
112633,BLOCK,-1,,<empty>,9,,267,2,,void
112657,BLOCK,-1,,"{
    vlc_interrupt_t *from = data[1];
    if (from == NULL)
        return 0;

    assert(from->callback == vlc_interrupt_forward_wake);
    assert(from->data == data);
    return vlc_interrupt_finish(from);
}",1,,276,2,,void
112668,BLOCK,-1,,<empty>,9,,279,2,,void
112690,BLOCK,-1,,"{
    uint64_t value = 1;
    int *fd = opaque;
    int canc;

    canc = vlc_savecancel();
    write(fd[1], &value, sizeof (value));
    vlc_restorecancel(canc);
}",1,,288,2,,void
112717,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = opaque;
    int *fd = ctx->data;

    vlc_interrupt_finish(ctx);
    if (fd[1] != fd[0])
        vlc_close(fd[1]);
    vlc_close(fd[0]);
}",1,,299,2,,void
112738,BLOCK,-1,,<empty>,9,,305,2,,void
112755,BLOCK,-1,,"{
    int fd[2];
    int ret = -1;
    int canc;

    /* TODO: cache this */
# if defined (HAVE_EVENTFD) && defined (EFD_CLOEXEC)
    canc = vlc_savecancel();
    fd[0] = eventfd(0, EFD_CLOEXEC);
    vlc_restorecancel(canc);
    if (fd[0] != -1)
        fd[1] = fd[0];
    else
# endif
    if (vlc_pipe(fd))
    {
        vlc_testcancel();
        errno = ENOMEM;
        return -1;
    }

    for (unsigned i = 0; i < nfds; i++)
    {
        ufd[i].fd = fds[i].fd;
        ufd[i].events = fds[i].events;
    }
    ufd[nfds].fd = fd[0];
    ufd[nfds].events = POLLIN;

    vlc_interrupt_prepare(ctx, vlc_poll_i11e_wake, fd);

    vlc_cleanup_push(vlc_poll_i11e_cleanup, ctx);
    ret = poll(ufd, nfds + 1, timeout);

    for (unsigned i = 0; i < nfds; i++)
        fds[i].revents = ufd[i].revents;

    if (ret > 0 && ufd[nfds].revents)
    {
        uint64_t dummy;

        read(fd[0], &dummy, sizeof (dummy));
        ret--;
    }
    vlc_cleanup_pop();

    if (vlc_interrupt_finish(ctx))
   ...",1,,312,6,,void
112766,BLOCK,-1,,"{
        vlc_testcancel();
        errno = ENOMEM;
        return -1;
    }",5,,327,2,,void
112775,BLOCK,-1,,<empty>,5,,333,1,,void
112785,BLOCK,4,,"{
        ufd[i].fd = fds[i].fd;
        ufd[i].events = fds[i].events;
    }",5,,334,4,,void
112840,BLOCK,-1,,<empty>,5,,346,1,,void
112871,BLOCK,-1,,"{
        uint64_t dummy;

        read(fd[0], &dummy, sizeof (dummy));
        ret--;
    }",5,,350,2,,void
112887,BLOCK,-1,,"{
        errno = EINTR;
        ret = -1;
    }",5,,359,2,,void
112906,BLOCK,-1,,<empty>,9,,366,2,,void
112925,BLOCK,-1,,"{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return poll(fds, nfds, timeout);

    int ret;

    if (likely(nfds < 255))
    {   /* Fast path with stack allocation */
        struct pollfd ufd[nfds + 1];

        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
    }
    else
    {   /* Slow path but poll() is slow with large nfds anyway. */
        struct pollfd *ufd = vlc_alloc(nfds + 1, sizeof (*ufd));
        if (unlikely(ufd == NULL))
            return -1; /* ENOMEM */

        vlc_cleanup_push(free, ufd);
        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
        vlc_cleanup_pop();
        free(ufd);
    }
    return ret;
}",1,,373,4,,void
112934,BLOCK,-1,,<empty>,9,,376,2,,void
112946,BLOCK,-1,,"{   /* Fast path with stack allocation */
        struct pollfd ufd[nfds + 1];

        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
    }",5,,381,2,,void
112957,BLOCK,-1,,"{   /* Slow path but poll() is slow with large nfds anyway. */
        struct pollfd *ufd = vlc_alloc(nfds + 1, sizeof (*ufd));
        if (unlikely(ufd == NULL))
            return -1; /* ENOMEM */

        vlc_cleanup_push(free, ufd);
        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
        vlc_cleanup_pop();
        free(ufd);
    }",5,,387,1,,void
112973,BLOCK,-1,,<empty>,13,,390,2,,void
112999,BLOCK,-1,,"{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return readv(fd, iov, count);
}",1,,418,4,,void
113020,BLOCK,-1,,<empty>,9,,425,2,,void
113035,BLOCK,-1,,"{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return writev(fd, iov, count);
}",1,,437,4,,void
113056,BLOCK,-1,,<empty>,9,,444,2,,void
113071,BLOCK,-1,,"{
    struct iovec iov = { .iov_base = buf, .iov_len = count };
    return vlc_readv_i11e(fd, &iov, 1);
}",1,,453,4,,void
113076,BLOCK,1,,<empty>,26,,454,1,,void
113080,BLOCK,2,,<empty>,43,,454,2,,void
113096,BLOCK,-1,,"{
    struct iovec iov = { .iov_base = (void*)buf, .iov_len = count };
    return vlc_writev_i11e(fd, &iov, 1);
}",1,,466,4,,void
113101,BLOCK,1,,<empty>,26,,467,1,,void
113107,BLOCK,2,,<empty>,50,,467,2,,void
113123,BLOCK,-1,,"{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_OOB and MSG_PEEK should work fine here.
     * MSG_WAITALL is not supported at this point. */
    return recvmsg(fd, msg, flags);
}",1,,472,4,,void
113144,BLOCK,-1,,<empty>,9,,479,2,,void
113162,BLOCK,-1,,"{
    struct iovec iov = { .iov_base = buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = addr,
        .msg_namelen = (addrlen != NULL) ? *addrlen : 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    ssize_t ret = vlc_recvmsg_i11e(fd, &msg, flags);
    if (ret >= 0 && addrlen != NULL)
        *addrlen = msg.msg_namelen;
    return ret;
}",1,,487,7,,void
113167,BLOCK,1,,<empty>,26,,488,1,,void
113171,BLOCK,2,,<empty>,43,,488,2,,void
113179,BLOCK,1,,<empty>,9,,490,1,,void
113183,BLOCK,2,,<empty>,9,,491,2,,void
113193,BLOCK,3,,<empty>,9,,492,3,,void
113198,BLOCK,4,,<empty>,9,,493,4,,void
113218,BLOCK,-1,,<empty>,9,,498,2,,void
113233,BLOCK,-1,,"{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_EOR, MSG_OOB and MSG_NOSIGNAL should all work fine here. */
    return sendmsg(fd, msg, flags);
}",1,,503,4,,void
113254,BLOCK,-1,,<empty>,9,,510,2,,void
113272,BLOCK,-1,,"{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = (struct sockaddr *)addr,
        .msg_namelen = addrlen,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    return vlc_sendmsg_i11e(fd, &msg, flags);
}",1,,517,7,,void
113277,BLOCK,1,,<empty>,26,,518,1,,void
113283,BLOCK,2,,<empty>,51,,518,2,,void
113291,BLOCK,1,,<empty>,9,,520,1,,void
113297,BLOCK,2,,<empty>,9,,521,2,,void
113301,BLOCK,3,,<empty>,9,,522,3,,void
113306,BLOCK,4,,<empty>,9,,523,4,,void
113323,BLOCK,-1,,"{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;

    return vlc_accept(fd, addr, addrlen, blocking);
}",1,,531,5,,void
113344,BLOCK,-1,,<empty>,9,,538,2,,void
113364,BLOCK,-1,,<empty>,1,,1,1,,ANY
113367,BLOCK,-1,,<empty>,,,,2,,<empty>
113372,BLOCK,-1,,<empty>,,,,2,,<empty>
113381,BLOCK,-1,,<empty>,,,,2,,<empty>
113407,BLOCK,-1,,<empty>,1,,1,1,,ANY
113411,BLOCK,-1,,"{
    vlc_keystore *p_keystore = vlc_custom_create(p_parent, sizeof (*p_keystore),
                                                 ""keystore"");
    if (unlikely(p_keystore == NULL))
        return NULL;

    p_keystore->p_module = module_need(p_keystore, ""keystore"", psz_name, true);
    if (p_keystore->p_module == NULL)
    {
        vlc_object_release(p_keystore);
        return NULL;
    }
    assert(p_keystore->pf_store);
    assert(p_keystore->pf_find);
    assert(p_keystore->pf_remove);

    return p_keystore;
}",1,,37,3,,void
113426,BLOCK,-1,,<empty>,9,,41,2,,void
113444,BLOCK,-1,,"{
        vlc_object_release(p_keystore);
        return NULL;
    }",5,,45,2,,void
113467,BLOCK,-1,,"{
    assert(p_parent);
    return keystore_create(p_parent, ""$keystore"");
}",1,,59,2,,void
113478,BLOCK,-1,,"{
    assert(p_keystore);
    module_unneed(p_keystore, p_keystore->p_module);

    vlc_object_release(p_keystore);
}",1,,66,2,,void
113496,BLOCK,-1,,"{
    assert(p_keystore && ppsz_values && p_secret && i_secret_len);

    if (!ppsz_values[KEY_PROTOCOL] || !ppsz_values[KEY_SERVER])
    {
        msg_Err(p_keystore, ""invalid store request: ""
                ""protocol and server should be valid"");
        return VLC_EGENERIC;
    }
    if (ppsz_values[KEY_PORT])
    {
        long int i_port = strtol(ppsz_values[KEY_PORT], NULL, 10);
        if (i_port == LONG_MIN || i_port == LONG_MAX)
        {
            msg_Err(p_keystore, ""invalid store request: ""
                    ""port is not valid number"");
            return VLC_EGENERIC;
        }
    }
    if (i_secret_len < 0)
        i_secret_len = strlen((const char *)p_secret) + 1;
    return p_keystore->pf_store(p_keystore, ppsz_values, p_secret, i_secret_len,
                                psz_label);
}",1,,78,6,,void
113515,BLOCK,-1,,"{
        msg_Err(p_keystore, ""invalid store request: ""
                ""protocol and server should be valid"");
        return VLC_EGENERIC;
    }",5,,82,2,,void
113525,BLOCK,-1,,"{
        long int i_port = strtol(ppsz_values[KEY_PORT], NULL, 10);
        if (i_port == LONG_MIN || i_port == LONG_MAX)
        {
            msg_Err(p_keystore, ""invalid store request: ""
                    ""port is not valid number"");
            return VLC_EGENERIC;
        }
    }",5,,88,2,,void
113543,BLOCK,-1,,"{
            msg_Err(p_keystore, ""invalid store request: ""
                    ""port is not valid number"");
            return VLC_EGENERIC;
        }",9,,91,2,,void
113553,BLOCK,-1,,<empty>,9,,98,2,,void
113578,BLOCK,-1,,"{
    assert(p_keystore && ppsz_values && pp_entries);
    return p_keystore->pf_find(p_keystore, ppsz_values, pp_entries);
}",1,,107,4,,void
113598,BLOCK,-1,,"{
    assert(p_keystore && ppsz_values);
    return p_keystore->pf_remove(p_keystore, ppsz_values);
}",1,,115,3,,void
113615,BLOCK,-1,,"{
    for (unsigned int i = 0; i < i_count; ++i)
        vlc_keystore_release_entry(&p_entries[i]);
    free(p_entries);
}",1,,122,3,,void
113617,BLOCK,-1,,<empty>,5,,123,1,,void
113638,BLOCK,-1,,"{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    p_priv->p_memory_keystore = keystore_create(VLC_OBJECT(p_libvlc), ""memory"");
    return p_priv->p_memory_keystore != NULL ? VLC_SUCCESS : VLC_EGENERIC;
}",1,,130,2,,void
113669,BLOCK,-1,,"{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    if (p_priv->p_memory_keystore != NULL)
    {
        vlc_keystore_release(p_priv->p_memory_keystore);
        p_priv->p_memory_keystore = NULL;
    }
}",1,,140,2,,void
113685,BLOCK,-1,,"{
        vlc_keystore_release(p_priv->p_memory_keystore);
        p_priv->p_memory_keystore = NULL;
    }",5,,145,2,,void
113699,BLOCK,-1,,"{
    return libvlc_priv(p_obj->obj.libvlc)->p_memory_keystore;
}",1,,153,2,,void
113715,BLOCK,-1,,"{
    vlc_keystore_entry *p_match_entry = NULL;
    size_t i_last_pathlen = 0;
    char *psz_decoded_path = vlc_uri_decode_duplicate(psz_path);
    if (psz_decoded_path == NULL)
        return NULL;

    /* Try to find the entry that has the closest path to psz_url */
    for (unsigned int i = 0; i < i_count; ++i)
    {
        vlc_keystore_entry *p_entry = &p_entries[i];
        const char *psz_entry_path = p_entry->ppsz_values[KEY_PATH];
        if (psz_entry_path == NULL)
        {
            if (p_match_entry == NULL)
                p_match_entry = p_entry;
            continue;
        }
        size_t i_entry_pathlen = strlen(psz_entry_path);

        if (strncasecmp(psz_decoded_path, psz_entry_path, i_entry_pathlen) == 0
         && i_entry_pathlen > i_last_pathlen)
        {
            i_last_pathlen = i_entry_pathlen;
            p_match_entry = p_entry;
        }
    }
    free(psz_decoded_path);
    return p_match_entry;
}",1,,160,4,,void
113733,BLOCK,-1,,<empty>,9,,165,2,,void
113737,BLOCK,-1,,<empty>,5,,168,1,,void
113747,BLOCK,4,,"{
        vlc_keystore_entry *p_entry = &p_entries[i];
        const char *psz_entry_path = p_entry->ppsz_values[KEY_PATH];
        if (psz_entry_path == NULL)
        {
            if (p_match_entry == NULL)
                p_match_entry = p_entry;
            continue;
        }
        size_t i_entry_pathlen = strlen(psz_entry_path);

        if (strncasecmp(psz_decoded_path, psz_entry_path, i_entry_pathlen) == 0
         && i_entry_pathlen > i_last_pathlen)
        {
            i_last_pathlen = i_entry_pathlen;
            p_match_entry = p_entry;
        }
    }",5,,169,4,,void
113767,BLOCK,-1,,"{
            if (p_match_entry == NULL)
                p_match_entry = p_entry;
            continue;
        }",9,,173,2,,void
113772,BLOCK,-1,,<empty>,17,,175,2,,void
113793,BLOCK,-1,,"{
            i_last_pathlen = i_entry_pathlen;
            p_match_entry = p_entry;
        }",9,,182,2,,void
113808,BLOCK,-1,,"{
    if (p_credential->psz_username && p_credential->psz_password)
        return true;
    p_credential->psz_password = NULL;
    return false;
}",1,,193,2,,void
113817,BLOCK,-1,,<empty>,9,,195,2,,void
113831,BLOCK,-1,,"{
    return p_url && p_url->psz_protocol && p_url->psz_protocol[0]
        && p_url->psz_host && p_url->psz_host[0];
}",1,,202,2,,void
113884,BLOCK,-1,,"{
    int i_port = -1;

    if (p_url->i_port != 0 && p_url->i_port <= UINT16_MAX)
        i_port = p_url->i_port;
    else
    {
        for (unsigned int i = 0; i < sizeof(protocol_default_ports)
                                   / sizeof(*protocol_default_ports); ++i)
        {
            if (strcasecmp(p_url->psz_protocol,
                           protocol_default_ports[i].psz_protocol) == 0)
            {
                i_port = protocol_default_ports[i].i_port;
                break;
            }
        }
    }
    if (i_port != -1)
    {
        sprintf(psz_port, ""%u"", (uint16_t) i_port);
        return true;
    }
    return false;
}",1,,224,3,,void
113902,BLOCK,-1,,<empty>,9,,228,2,,void
113909,BLOCK,-1,,"{
        for (unsigned int i = 0; i < sizeof(protocol_default_ports)
                                   / sizeof(*protocol_default_ports); ++i)
        {
            if (strcasecmp(p_url->psz_protocol,
                           protocol_default_ports[i].psz_protocol) == 0)
            {
                i_port = protocol_default_ports[i].i_port;
                break;
            }
        }
    }",5,,230,1,,void
113911,BLOCK,-1,,<empty>,9,,231,1,,void
113926,BLOCK,4,,"{
            if (strcasecmp(p_url->psz_protocol,
                           protocol_default_ports[i].psz_protocol) == 0)
            {
                i_port = protocol_default_ports[i].i_port;
                break;
            }
        }",9,,233,4,,void
113939,BLOCK,-1,,"{
                i_port = protocol_default_ports[i].i_port;
                break;
            }",13,,236,2,,void
113953,BLOCK,-1,,"{
        sprintf(psz_port, ""%u"", (uint16_t) i_port);
        return true;
    }",5,,243,2,,void
113968,BLOCK,-1,,"{
    return strcasecmp(p_url->psz_protocol, ""smb"") == 0;
}",1,,252,2,,void
113981,BLOCK,-1,,"{
    return p_url->psz_path
      && (strncasecmp(p_url->psz_protocol, ""http"", 4) == 0
      || strcasecmp(p_url->psz_protocol, ""rtsp"") == 0
      || protocol_is_smb(p_url));
}",1,,258,2,,void
114010,BLOCK,-1,,"{
    char *psz_delim = strchr(p_credential->psz_username, ';');
    if (psz_delim)
    {
        size_t i_len = psz_delim - p_credential->psz_username;
        if (i_len > 0)
        {
            free(p_credential->psz_split_domain);
            p_credential->psz_split_domain =
                strndup(p_credential->psz_username, i_len);
            p_credential->psz_realm = p_credential->psz_split_domain;
        }
        p_credential->psz_username = psz_delim + 1;
    }
}",1,,268,2,,void
114021,BLOCK,-1,,"{
        size_t i_len = psz_delim - p_credential->psz_username;
        if (i_len > 0)
        {
            free(p_credential->psz_split_domain);
            p_credential->psz_split_domain =
                strndup(p_credential->psz_username, i_len);
            p_credential->psz_realm = p_credential->psz_split_domain;
        }
        p_credential->psz_username = psz_delim + 1;
    }",5,,271,2,,void
114034,BLOCK,-1,,"{
            free(p_credential->psz_split_domain);
            p_credential->psz_split_domain =
                strndup(p_credential->psz_username, i_len);
            p_credential->psz_realm = p_credential->psz_split_domain;
        }",9,,274,2,,void
114067,BLOCK,-1,,"{
    const vlc_url_t *p_url = p_credential->p_url;

    const char *ppsz_values[KEY_MAX] = { 0 };
    ppsz_values[KEY_PROTOCOL] = p_url->psz_protocol;
    ppsz_values[KEY_USER] = p_credential->psz_username;
    ppsz_values[KEY_SERVER] = p_url->psz_host;
    /* don't try to match with the path */
    ppsz_values[KEY_REALM] = p_credential->psz_realm;
    ppsz_values[KEY_AUTHTYPE] = p_credential->psz_authtype;
    char psz_port[21];
    if (protocol_set_port(p_url, psz_port))
        ppsz_values[KEY_PORT] = psz_port;

    vlc_keystore_entry *p_entries;
    unsigned int i_entries_count;
    i_entries_count = vlc_keystore_find(p_keystore, ppsz_values, &p_entries);

    /* Remove last entries after vlc_keystore_find call since
     * p_credential->psz_username (default username) can be a pointer to an
     * entry */
    if (p_credential->i_entries_count > 0)
    {
        vlc_keystore_release_entries(p_credential->p_entries,
                                     p_credential->i_entries_c...",1,,286,3,,void
114119,BLOCK,-1,,<empty>,9,,298,2,,void
114140,BLOCK,-1,,"{
        vlc_keystore_release_entries(p_credential->p_entries,
                                     p_credential->i_entries_count);
        p_credential->psz_username = NULL;
    }",5,,308,2,,void
114169,BLOCK,-1,,"{
        vlc_keystore_entry *p_entry;

        if (protocol_store_path(p_url))
            p_entry = find_closest_path(p_credential->p_entries,
                                        p_credential->i_entries_count,
                                        p_url->psz_path);
        else
            p_entry = &p_credential->p_entries[0];

        if (!p_entry || p_entry->p_secret[p_entry->i_secret_len - 1] != '\0')
        {
            vlc_keystore_release_entries(p_credential->p_entries,
                                         p_credential->i_entries_count);
            p_credential->i_entries_count = 0;
        }
        else
        {
            p_credential->psz_password = (const char *)p_entry->p_secret;
            p_credential->psz_username = p_entry->ppsz_values[KEY_USER];
            p_credential->psz_realm = p_entry->ppsz_values[KEY_REALM];
            p_credential->psz_authtype = p_entry->ppsz_values[KEY_AUTHTYPE];
            p_credential->b_from_keystore = true;
      ...",5,,317,2,,void
114174,BLOCK,-1,,<empty>,13,,321,2,,void
114188,BLOCK,-1,,<empty>,13,,325,1,,void
114212,BLOCK,-1,,"{
            vlc_keystore_release_entries(p_credential->p_entries,
                                         p_credential->i_entries_count);
            p_credential->i_entries_count = 0;
        }",9,,328,2,,void
114226,BLOCK,-1,,"{
            p_credential->psz_password = (const char *)p_entry->p_secret;
            p_credential->psz_username = p_entry->ppsz_values[KEY_USER];
            p_credential->psz_realm = p_entry->ppsz_values[KEY_REALM];
            p_credential->psz_authtype = p_entry->ppsz_values[KEY_AUTHTYPE];
            p_credential->b_from_keystore = true;
        }",9,,334,1,,void
114273,BLOCK,-1,,"{
    assert(p_credential);

    memset(p_credential, 0, sizeof(*p_credential));
    p_credential->i_get_order = GET_FROM_URL;
    p_credential->p_url = p_url;
}",1,,346,3,,void
114296,BLOCK,-1,,"{
    if (p_credential->i_entries_count > 0)
        vlc_keystore_release_entries(p_credential->p_entries,
                                     p_credential->i_entries_count);
    if (p_credential->p_keystore)
        vlc_keystore_release(p_credential->p_keystore);

    free(p_credential->psz_split_domain);
    free(p_credential->psz_var_username);
    free(p_credential->psz_var_password);
    free(p_credential->psz_dialog_username);
    free(p_credential->psz_dialog_password);
}",1,,356,2,,void
114303,BLOCK,-1,,<empty>,9,,358,2,,void
114315,BLOCK,-1,,<empty>,9,,361,2,,void
114349,BLOCK,-1,,"{
    assert(p_credential && p_parent);
    const vlc_url_t *p_url = p_credential->p_url;

    if (!is_url_valid(p_url))
    {
        msg_Err(p_parent, ""vlc_credential_get: invalid url"");
        return false;
    }

    p_credential->b_from_keystore = false;
    /* Don't set username to NULL, we may want to use the last one set */
    p_credential->psz_password = NULL;

    while (!is_credential_valid(p_credential))
    {
        /* First, fetch credential from URL (if any).
         * Secondly, fetch credential from VLC Options (if any).
         * Thirdly, fetch credential from keystore (if any) using user and realm
         * previously set by the caller, the URL or by VLC Options.
         * Finally, fetch credential from the dialog (if any). This last will be
         * repeated until user cancel the dialog. */

        switch (p_credential->i_get_order)
        {
        case GET_FROM_URL:
            p_credential->psz_username = p_url->psz_username;
            p_credential...",1,,377,7,,void
114364,BLOCK,-1,,"{
        msg_Err(p_parent, ""vlc_credential_get: invalid url"");
        return false;
    }",5,,382,2,,void
114384,BLOCK,-1,,"{
        /* First, fetch credential from URL (if any).
         * Secondly, fetch credential from VLC Options (if any).
         * Thirdly, fetch credential from keystore (if any) using user and realm
         * previously set by the caller, the URL or by VLC Options.
         * Finally, fetch credential from the dialog (if any). This last will be
         * repeated until user cancel the dialog. */

        switch (p_credential->i_get_order)
        {
        case GET_FROM_URL:
            p_credential->psz_username = p_url->psz_username;
            p_credential->psz_password = p_url->psz_password;

            if (p_credential->psz_password)
                msg_Warn(p_parent, ""Password in a URI is DEPRECATED"");

            if (p_url->psz_username && protocol_is_smb(p_url))
                smb_split_domain(p_credential);
            p_credential->i_get_order++;
            break;

        case GET_FROM_OPTION:
            free(p_credential->psz_var_username);
            free(p_...",5,,392,2,,void
114389,BLOCK,-1,,"{
        case GET_FROM_URL:
            p_credential->psz_username = p_url->psz_username;
            p_credential->psz_password = p_url->psz_password;

            if (p_credential->psz_password)
                msg_Warn(p_parent, ""Password in a URI is DEPRECATED"");

            if (p_url->psz_username && protocol_is_smb(p_url))
                smb_split_domain(p_credential);
            p_credential->i_get_order++;
            break;

        case GET_FROM_OPTION:
            free(p_credential->psz_var_username);
            free(p_credential->psz_var_password);
            p_credential->psz_var_username =
            p_credential->psz_var_password = NULL;

            if (psz_option_username)
                p_credential->psz_var_username =
                    var_InheritString(p_parent, psz_option_username);
            if (psz_option_password)
                p_credential->psz_var_password =
                    var_InheritString(p_parent, psz_option_password);

            if ...",9,,401,2,,void
114410,BLOCK,-1,,<empty>,17,,407,2,,void
114421,BLOCK,-1,,<empty>,17,,410,2,,void
114450,BLOCK,-1,,<empty>,17,,421,2,,void
114460,BLOCK,-1,,<empty>,17,,424,2,,void
114472,BLOCK,-1,,<empty>,17,,428,2,,void
114484,BLOCK,-1,,<empty>,17,,430,2,,void
114499,BLOCK,22,,"{
            vlc_keystore *p_keystore = get_memory_keystore(p_parent);
            if (p_keystore != NULL)
                credential_find_keystore(p_credential, p_keystore);
            p_credential->i_get_order++;
            break;
        }",9,,436,22,,void
114509,BLOCK,-1,,<empty>,17,,439,2,,void
114526,BLOCK,-1,,<empty>,17,,446,2,,void
114535,BLOCK,-1,,<empty>,17,,449,2,,void
114548,BLOCK,-1,,<empty>,17,,451,2,,void
114568,BLOCK,-1,,<empty>,17,,459,2,,void
114637,BLOCK,-1,,"{
                p_credential->psz_username = p_credential->psz_password = NULL;
                return false;
            }",13,,483,2,,void
114666,BLOCK,-1,,<empty>,17,,492,2,,void
114678,BLOCK,-1,,"{
    if (!is_credential_valid(p_credential))
        return false;
    /* Don't need to store again */
    if (p_credential->b_from_keystore)
        return p_credential->b_from_keystore;

    vlc_keystore *p_keystore;
    if (p_credential->b_store)
    {
        /* Store in permanent keystore */
        assert(p_credential->p_keystore != NULL);
        p_keystore = p_credential->p_keystore;
    }
    else
    {
        /* Store in memory keystore */
        p_keystore = get_memory_keystore(p_parent);
    }
    if (p_keystore == NULL)
        return false;

    const vlc_url_t *p_url = p_credential->p_url;

    char *psz_path = NULL;
    if (protocol_store_path(p_url)
     && (psz_path =  vlc_uri_decode_duplicate(p_url->psz_path)) != NULL)
    {
        char *p_slash;
        if (protocol_is_smb(p_url))
        {
            /* Remove all characters after the first slash (store the share but
             * not the path) */
            p_slash = strchr(psz_path + 1, '/');
        }
...",1,,503,3,,void
114683,BLOCK,-1,,<empty>,9,,505,2,,void
114690,BLOCK,-1,,<empty>,9,,508,2,,void
114700,BLOCK,-1,,"{
        /* Store in permanent keystore */
        assert(p_credential->p_keystore != NULL);
        p_keystore = p_credential->p_keystore;
    }",5,,512,2,,void
114713,BLOCK,-1,,"{
        /* Store in memory keystore */
        p_keystore = get_memory_keystore(p_parent);
    }",5,,518,1,,void
114722,BLOCK,-1,,<empty>,9,,523,2,,void
114747,BLOCK,-1,,"{
        char *p_slash;
        if (protocol_is_smb(p_url))
        {
            /* Remove all characters after the first slash (store the share but
             * not the path) */
            p_slash = strchr(psz_path + 1, '/');
        }
        else
        {
            /* Remove all characters after the last slash (store the path
             * without the filename) */
            p_slash = strrchr(psz_path + 1, '/');
        }
        if (p_slash && psz_path != p_slash)
            *p_slash = '\0';
    }",5,,530,2,,void
114752,BLOCK,-1,,"{
            /* Remove all characters after the first slash (store the share but
             * not the path) */
            p_slash = strchr(psz_path + 1, '/');
        }",9,,533,2,,void
114761,BLOCK,-1,,"{
            /* Remove all characters after the last slash (store the path
             * without the filename) */
            p_slash = strrchr(psz_path + 1, '/');
        }",9,,539,1,,void
114775,BLOCK,-1,,<empty>,13,,545,2,,void
114830,BLOCK,-1,,<empty>,9,,558,2,,void
114855,BLOCK,-1,,"{
        free(psz_path);
        return false;
    }",5,,564,2,,void
114911,BLOCK,-1,,<empty>,1,,1,1,,ANY
114918,BLOCK,-1,,"{
  MD5_CONTEXT *ctx = context;

  ctx->A = 0x67452301;
  ctx->B = 0xefcdab89;
  ctx->C = 0x98badcfe;
  ctx->D = 0x10325476;

  ctx->nblocks = 0;
  ctx->count = 0;
}",1,,56,2,,void
114958,BLOCK,-1,,"{
  u32 correct_words[16];
  register u32 A = ctx->A;
  register u32 B = ctx->B;
  register u32 C = ctx->C;
  register u32 D = ctx->D;
  u32 *cwp = correct_words;

#ifdef WORDS_BIGENDIAN
  {
    int i;
    byte *p2, *p1;
    for(i=0, p1=data, p2=(byte*)correct_words; i < 16; i++, p2 += 4 )
      {
        p2[3] = *p1++;
	p2[2] = *p1++;
	p2[1] = *p1++;
	p2[0] = *p1++;
      }
  }
#else
  memcpy( correct_words, data, 64 );
#endif


#define OP(a, b, c, d, s, T) \
  do			         	   \
    {					   \
      a += FF (b, c, d) + (*cwp++) + T;    \
      a = rol(a, s);			   \
      a += b;				   \
    }					   \
  while (0)

  /* Before we start, one word about the strange constants.
     They are defined in RFC 1321 as

     T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
  */

  /* Round 1.  */
  OP (A, B, C, D,  7, 0xd76aa478);
  OP (D, A, B, C, 12, 0xe8c7b756);
  OP (C, D, A, B, 17, 0x242070db);
  OP (B, C, D, A, 22, 0xc1bdceee);
  OP (A, B, C, D,  7, 0xf57c0faf);
  OP (D, A, B, C...",1,,84,3,,void
114999,BLOCK,1,,<empty>,,,,18,,void
115001,BLOCK,-1,,"OP (A, B, C, D,  7, 0xd76aa478)",3,,125,1,,void
115039,BLOCK,1,,<empty>,,,,18,,void
115041,BLOCK,-1,,"OP (D, A, B, C, 12, 0xe8c7b756)",3,,126,1,,void
115079,BLOCK,1,,<empty>,,,,18,,void
115081,BLOCK,-1,,"OP (C, D, A, B, 17, 0x242070db)",3,,127,1,,void
115119,BLOCK,1,,<empty>,,,,18,,void
115121,BLOCK,-1,,"OP (B, C, D, A, 22, 0xc1bdceee)",3,,128,1,,void
115159,BLOCK,1,,<empty>,,,,18,,void
115161,BLOCK,-1,,"OP (A, B, C, D,  7, 0xf57c0faf)",3,,129,1,,void
115199,BLOCK,1,,<empty>,,,,18,,void
115201,BLOCK,-1,,"OP (D, A, B, C, 12, 0x4787c62a)",3,,130,1,,void
115239,BLOCK,1,,<empty>,,,,18,,void
115241,BLOCK,-1,,"OP (C, D, A, B, 17, 0xa8304613)",3,,131,1,,void
115279,BLOCK,1,,<empty>,,,,18,,void
115281,BLOCK,-1,,"OP (B, C, D, A, 22, 0xfd469501)",3,,132,1,,void
115319,BLOCK,1,,<empty>,,,,18,,void
115321,BLOCK,-1,,"OP (A, B, C, D,  7, 0x698098d8)",3,,133,1,,void
115359,BLOCK,1,,<empty>,,,,18,,void
115361,BLOCK,-1,,"OP (D, A, B, C, 12, 0x8b44f7af)",3,,134,1,,void
115399,BLOCK,1,,<empty>,,,,18,,void
115401,BLOCK,-1,,"OP (C, D, A, B, 17, 0xffff5bb1)",3,,135,1,,void
115439,BLOCK,1,,<empty>,,,,18,,void
115441,BLOCK,-1,,"OP (B, C, D, A, 22, 0x895cd7be)",3,,136,1,,void
115479,BLOCK,1,,<empty>,,,,18,,void
115481,BLOCK,-1,,"OP (A, B, C, D,  7, 0x6b901122)",3,,137,1,,void
115519,BLOCK,1,,<empty>,,,,18,,void
115521,BLOCK,-1,,"OP (D, A, B, C, 12, 0xfd987193)",3,,138,1,,void
115559,BLOCK,1,,<empty>,,,,18,,void
115561,BLOCK,-1,,"OP (C, D, A, B, 17, 0xa679438e)",3,,139,1,,void
115599,BLOCK,1,,<empty>,,,,18,,void
115601,BLOCK,-1,,"OP (B, C, D, A, 22, 0x49b40821)",3,,140,1,,void
115640,BLOCK,1,,<empty>,,,,19,,void
115642,BLOCK,-1,,"OP (FG, A, B, C, D,  1,  5, 0xf61e2562)",3,,153,1,,void
115681,BLOCK,1,,<empty>,,,,19,,void
115683,BLOCK,-1,,"OP (FG, D, A, B, C,  6,  9, 0xc040b340)",3,,154,1,,void
115722,BLOCK,1,,<empty>,,,,19,,void
115724,BLOCK,-1,,"OP (FG, C, D, A, B, 11, 14, 0x265e5a51)",3,,155,1,,void
115763,BLOCK,1,,<empty>,,,,19,,void
115765,BLOCK,-1,,"OP (FG, B, C, D, A,  0, 20, 0xe9b6c7aa)",3,,156,1,,void
115804,BLOCK,1,,<empty>,,,,19,,void
115806,BLOCK,-1,,"OP (FG, A, B, C, D,  5,  5, 0xd62f105d)",3,,157,1,,void
115845,BLOCK,1,,<empty>,,,,19,,void
115847,BLOCK,-1,,"OP (FG, D, A, B, C, 10,  9, 0x02441453)",3,,158,1,,void
115886,BLOCK,1,,<empty>,,,,19,,void
115888,BLOCK,-1,,"OP (FG, C, D, A, B, 15, 14, 0xd8a1e681)",3,,159,1,,void
115927,BLOCK,1,,<empty>,,,,19,,void
115929,BLOCK,-1,,"OP (FG, B, C, D, A,  4, 20, 0xe7d3fbc8)",3,,160,1,,void
115968,BLOCK,1,,<empty>,,,,19,,void
115970,BLOCK,-1,,"OP (FG, A, B, C, D,  9,  5, 0x21e1cde6)",3,,161,1,,void
116009,BLOCK,1,,<empty>,,,,19,,void
116011,BLOCK,-1,,"OP (FG, D, A, B, C, 14,  9, 0xc33707d6)",3,,162,1,,void
116050,BLOCK,1,,<empty>,,,,19,,void
116052,BLOCK,-1,,"OP (FG, C, D, A, B,  3, 14, 0xf4d50d87)",3,,163,1,,void
116091,BLOCK,1,,<empty>,,,,19,,void
116093,BLOCK,-1,,"OP (FG, B, C, D, A,  8, 20, 0x455a14ed)",3,,164,1,,void
116132,BLOCK,1,,<empty>,,,,19,,void
116134,BLOCK,-1,,"OP (FG, A, B, C, D, 13,  5, 0xa9e3e905)",3,,165,1,,void
116173,BLOCK,1,,<empty>,,,,19,,void
116175,BLOCK,-1,,"OP (FG, D, A, B, C,  2,  9, 0xfcefa3f8)",3,,166,1,,void
116214,BLOCK,1,,<empty>,,,,19,,void
116216,BLOCK,-1,,"OP (FG, C, D, A, B,  7, 14, 0x676f02d9)",3,,167,1,,void
116255,BLOCK,1,,<empty>,,,,19,,void
116257,BLOCK,-1,,"OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a)",3,,168,1,,void
116296,BLOCK,1,,<empty>,,,,18,,void
116298,BLOCK,-1,,"OP (FH, A, B, C, D,  5,  4, 0xfffa3942)",3,,171,1,,void
116335,BLOCK,1,,<empty>,,,,18,,void
116337,BLOCK,-1,,"OP (FH, D, A, B, C,  8, 11, 0x8771f681)",3,,172,1,,void
116374,BLOCK,1,,<empty>,,,,18,,void
116376,BLOCK,-1,,"OP (FH, C, D, A, B, 11, 16, 0x6d9d6122)",3,,173,1,,void
116413,BLOCK,1,,<empty>,,,,18,,void
116415,BLOCK,-1,,"OP (FH, B, C, D, A, 14, 23, 0xfde5380c)",3,,174,1,,void
116452,BLOCK,1,,<empty>,,,,18,,void
116454,BLOCK,-1,,"OP (FH, A, B, C, D,  1,  4, 0xa4beea44)",3,,175,1,,void
116491,BLOCK,1,,<empty>,,,,18,,void
116493,BLOCK,-1,,"OP (FH, D, A, B, C,  4, 11, 0x4bdecfa9)",3,,176,1,,void
116530,BLOCK,1,,<empty>,,,,18,,void
116532,BLOCK,-1,,"OP (FH, C, D, A, B,  7, 16, 0xf6bb4b60)",3,,177,1,,void
116569,BLOCK,1,,<empty>,,,,18,,void
116571,BLOCK,-1,,"OP (FH, B, C, D, A, 10, 23, 0xbebfbc70)",3,,178,1,,void
116608,BLOCK,1,,<empty>,,,,18,,void
116610,BLOCK,-1,,"OP (FH, A, B, C, D, 13,  4, 0x289b7ec6)",3,,179,1,,void
116647,BLOCK,1,,<empty>,,,,18,,void
116649,BLOCK,-1,,"OP (FH, D, A, B, C,  0, 11, 0xeaa127fa)",3,,180,1,,void
116686,BLOCK,1,,<empty>,,,,18,,void
116688,BLOCK,-1,,"OP (FH, C, D, A, B,  3, 16, 0xd4ef3085)",3,,181,1,,void
116725,BLOCK,1,,<empty>,,,,18,,void
116727,BLOCK,-1,,"OP (FH, B, C, D, A,  6, 23, 0x04881d05)",3,,182,1,,void
116764,BLOCK,1,,<empty>,,,,18,,void
116766,BLOCK,-1,,"OP (FH, A, B, C, D,  9,  4, 0xd9d4d039)",3,,183,1,,void
116803,BLOCK,1,,<empty>,,,,18,,void
116805,BLOCK,-1,,"OP (FH, D, A, B, C, 12, 11, 0xe6db99e5)",3,,184,1,,void
116842,BLOCK,1,,<empty>,,,,18,,void
116844,BLOCK,-1,,"OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8)",3,,185,1,,void
116881,BLOCK,1,,<empty>,,,,18,,void
116883,BLOCK,-1,,"OP (FH, B, C, D, A,  2, 23, 0xc4ac5665)",3,,186,1,,void
116920,BLOCK,1,,<empty>,,,,18,,void
116922,BLOCK,-1,,"OP (FI, A, B, C, D,  0,  6, 0xf4292244)",3,,189,1,,void
116960,BLOCK,1,,<empty>,,,,18,,void
116962,BLOCK,-1,,"OP (FI, D, A, B, C,  7, 10, 0x432aff97)",3,,190,1,,void
117000,BLOCK,1,,<empty>,,,,18,,void
117002,BLOCK,-1,,"OP (FI, C, D, A, B, 14, 15, 0xab9423a7)",3,,191,1,,void
117040,BLOCK,1,,<empty>,,,,18,,void
117042,BLOCK,-1,,"OP (FI, B, C, D, A,  5, 21, 0xfc93a039)",3,,192,1,,void
117080,BLOCK,1,,<empty>,,,,18,,void
117082,BLOCK,-1,,"OP (FI, A, B, C, D, 12,  6, 0x655b59c3)",3,,193,1,,void
117120,BLOCK,1,,<empty>,,,,18,,void
117122,BLOCK,-1,,"OP (FI, D, A, B, C,  3, 10, 0x8f0ccc92)",3,,194,1,,void
117160,BLOCK,1,,<empty>,,,,18,,void
117162,BLOCK,-1,,"OP (FI, C, D, A, B, 10, 15, 0xffeff47d)",3,,195,1,,void
117200,BLOCK,1,,<empty>,,,,18,,void
117202,BLOCK,-1,,"OP (FI, B, C, D, A,  1, 21, 0x85845dd1)",3,,196,1,,void
117240,BLOCK,1,,<empty>,,,,18,,void
117242,BLOCK,-1,,"OP (FI, A, B, C, D,  8,  6, 0x6fa87e4f)",3,,197,1,,void
117280,BLOCK,1,,<empty>,,,,18,,void
117282,BLOCK,-1,,"OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0)",3,,198,1,,void
117320,BLOCK,1,,<empty>,,,,18,,void
117322,BLOCK,-1,,"OP (FI, C, D, A, B,  6, 15, 0xa3014314)",3,,199,1,,void
117360,BLOCK,1,,<empty>,,,,18,,void
117362,BLOCK,-1,,"OP (FI, B, C, D, A, 13, 21, 0x4e0811a1)",3,,200,1,,void
117400,BLOCK,1,,<empty>,,,,18,,void
117402,BLOCK,-1,,"OP (FI, A, B, C, D,  4,  6, 0xf7537e82)",3,,201,1,,void
117440,BLOCK,1,,<empty>,,,,18,,void
117442,BLOCK,-1,,"OP (FI, D, A, B, C, 11, 10, 0xbd3af235)",3,,202,1,,void
117480,BLOCK,1,,<empty>,,,,18,,void
117482,BLOCK,-1,,"OP (FI, C, D, A, B,  2, 15, 0x2ad7d2bb)",3,,203,1,,void
117520,BLOCK,1,,<empty>,,,,18,,void
117522,BLOCK,-1,,"OP (FI, B, C, D, A,  9, 21, 0xeb86d391)",3,,204,1,,void
117578,BLOCK,-1,,"{
  const unsigned char *inbuf = inbuf_arg;
  MD5_CONTEXT *hd = context;

  if( hd->count == 64 )  /* flush the buffer */
    {
      transform( hd, hd->buf );
      hd->count = 0;
      hd->nblocks++;
    }
  if( !inbuf )
    return;

  if( hd->count )
    {
      for( ; inlen && hd->count < 64; inlen-- )
        hd->buf[hd->count++] = *inbuf++;
      md5_write( hd, NULL, 0 );
      if( !inlen )
        return;
    }

  while( inlen >= 64 )
    {
      transform( hd, inbuf );
      hd->count = 0;
      hd->nblocks++;
      inlen -= 64;
      inbuf += 64;
    }
  for( ; inlen && hd->count < 64; inlen-- )
    hd->buf[hd->count++] = *inbuf++;

}",1,,221,4,,void
117593,BLOCK,-1,,"{
      transform( hd, hd->buf );
      hd->count = 0;
      hd->nblocks++;
    }",5,,226,2,,void
117611,BLOCK,-1,,<empty>,5,,232,2,,void
117617,BLOCK,-1,,"{
      for( ; inlen && hd->count < 64; inlen-- )
        hd->buf[hd->count++] = *inbuf++;
      md5_write( hd, NULL, 0 );
      if( !inlen )
        return;
    }",5,,235,2,,void
117619,BLOCK,-1,,<empty>,7,,236,1,,void
117648,BLOCK,-1,,<empty>,9,,240,2,,void
117654,BLOCK,-1,,"{
      transform( hd, inbuf );
      hd->count = 0;
      hd->nblocks++;
      inlen -= 64;
      inbuf += 64;
    }",5,,244,2,,void
117674,BLOCK,-1,,<empty>,3,,251,1,,void
117700,BLOCK,-1,,"{
  MD5_CONTEXT *hd = context;
  u32 t, msb, lsb;
  byte *p;

  md5_write(hd, NULL, 0); /* flush */;

  t = hd->nblocks;
  /* multiply by 64 to make a byte count */
  lsb = t << 6;
  msb = t >> 26;
  /* add the count */
  t = lsb;
  if( (lsb += hd->count) < t )
    msb++;
  /* multiply by 8 to make a bit count */
  t = lsb;
  lsb <<= 3;
  msb <<= 3;
  msb |= t >> 29;

  if( hd->count < 56 )  /* enough room */
    {
      hd->buf[hd->count++] = 0x80; /* pad */
      while( hd->count < 56 )
        hd->buf[hd->count++] = 0;  /* pad */
    }
  else  /* need one extra block */
    {
      hd->buf[hd->count++] = 0x80; /* pad character */
      while( hd->count < 64 )
        hd->buf[hd->count++] = 0;
      md5_write(hd, NULL, 0);  /* flush */;
      memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
    }
  /* append the 64 bit count */
  hd->buf[56] = lsb	   ;
  hd->buf[57] = lsb >>  8;
  hd->buf[58] = lsb >> 16;
  hd->buf[59] = lsb >> 24;
  hd->buf[60] = msb	   ;
  hd->buf[61] ...",1,,266,2,,void
117739,BLOCK,-1,,<empty>,5,,280,2,,void
117762,BLOCK,-1,,"{
      hd->buf[hd->count++] = 0x80; /* pad */
      while( hd->count < 56 )
        hd->buf[hd->count++] = 0;  /* pad */
    }",5,,288,2,,void
117790,BLOCK,-1,,"{
      hd->buf[hd->count++] = 0x80; /* pad character */
      while( hd->count < 64 )
        hd->buf[hd->count++] = 0;
      md5_write(hd, NULL, 0);  /* flush */;
      memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
    }",5,,294,1,,void
117906,BLOCK,1,,<empty>,,,,4,,void
117908,BLOCK,-1,,X(A),3,,319,1,,void
117923,BLOCK,1,,<empty>,,,,4,,void
117925,BLOCK,-1,,X(B),3,,320,1,,void
117940,BLOCK,1,,<empty>,,,,4,,void
117942,BLOCK,-1,,X(C),3,,321,1,,void
117957,BLOCK,1,,<empty>,,,,4,,void
117959,BLOCK,-1,,X(D),3,,322,1,,void
117977,BLOCK,-1,,"{
    md5_init( h );
}",1,,337,2,,void
117986,BLOCK,-1,,"{
    md5_write( h, data, len );
}",1,,342,4,,void
117995,BLOCK,-1,,"{
    md5_final( h );
}",1,,347,2,,void
118024,BLOCK,-1,,<empty>,1,,1,1,,ANY
118038,BLOCK,-1,,"{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    int canc;

    assert(logger != NULL);
    canc = vlc_savecancel();
    vlc_rwlock_rdlock(&logger->lock);
    logger->log(logger->sys, type, item, format, ap);
    vlc_rwlock_unlock(&logger->lock);
    vlc_restorecancel(canc);
}",1,,58,6,,void
118084,BLOCK,-1,,"{
    va_list ap;

    va_start(ap, format);
    vlc_vaLogCallback(vlc, type, item, format, ap);
    va_end(ap);
}",1,,72,5,,void
118108,BLOCK,-1,,"{
    if (obj != NULL && obj->obj.flags & OBJECT_FLAGS_QUIET)
        return;

    /* Get basename from the module filename */
    char *p = strrchr(module, '/');
    if (p != NULL)
        module = p + 1;
    p = strchr(module, '.');

    size_t modlen = (p != NULL) ? (p - module) : 0;
    char modulebuf[modlen + 1];
    if (p != NULL)
    {
        memcpy(modulebuf, module, modlen);
        modulebuf[modlen] = '\0';
        module = modulebuf;
    }

    /* Fill message information fields */
    vlc_log_t msg;

    msg.i_object_id = (uintptr_t)obj;
    msg.psz_object_type = (obj != NULL) ? obj->obj.object_type : ""generic"";
    msg.psz_module = module;
    msg.psz_header = NULL;
    msg.file = file;
    msg.line = line;
    msg.func = func;
    msg.tid = vlc_thread_id();

    for (vlc_object_t *o = obj; o != NULL; o = o->obj.parent)
        if (o->obj.header != NULL)
        {
            msg.psz_header = o->obj.header;
            break;
        }

#ifdef _WIN32
    va_list ap;

 ...",1,,92,9,,void
118121,BLOCK,-1,,<empty>,9,,94,2,,void
118133,BLOCK,-1,,<empty>,9,,99,2,,void
118160,BLOCK,-1,,"{
        memcpy(modulebuf, module, modlen);
        modulebuf[modlen] = '\0';
        module = modulebuf;
    }",5,,105,2,,void
118226,BLOCK,-1,,<empty>,5,,123,1,,void
118249,BLOCK,-1,,"{
            msg.psz_header = o->obj.header;
            break;
        }",9,,125,2,,void
118264,BLOCK,-1,,<empty>,9,,140,2,,void
118286,BLOCK,-1,,"{
    va_list ap;

    va_start(ap, format);
    vlc_vaLog(obj, type, module, file, line, func, format, ap);
    va_end(ap);
}",1,,157,8,,void
118322,BLOCK,-1,,"{
    vlc_logger_early_t *sys = d;

    vlc_log_early_t *log = malloc(sizeof (*log));
    if (unlikely(log == NULL))
        return;

    log->next = NULL;
    log->type = type;
    log->meta.i_object_id = item->i_object_id;
    /* NOTE: Object types MUST be static constant - no need to copy them. */
    log->meta.psz_object_type = item->psz_object_type;
    log->meta.psz_module = item->psz_module; /* Ditto. */
    log->meta.psz_header = item->psz_header ? strdup(item->psz_header) : NULL;
    log->meta.file = item->file;
    log->meta.line = item->line;
    log->meta.func = item->func;

    if (vasprintf(&log->msg, format, ap) == -1)
        log->msg = NULL;

    vlc_mutex_lock(&sys->lock);
    assert(sys->tailp != NULL);
    assert(*(sys->tailp) == NULL);
    *(sys->tailp) = log;
    sys->tailp = &log->next;
    vlc_mutex_unlock(&sys->lock);
}",1,,225,6,,void
118339,BLOCK,-1,,<empty>,9,,230,2,,void
118431,BLOCK,-1,,<empty>,9,,244,2,,void
118478,BLOCK,-1,,"{
    vlc_logger_early_t *sys = malloc(sizeof (*sys));

    if (unlikely(sys == NULL))
        return -1;

    vlc_mutex_init(&sys->lock);
    sys->head = NULL;
    sys->tailp = &sys->head;

    logger->log = vlc_vaLogEarly;
    logger->sys = sys;
    return 0;
}",1,,255,2,,void
118491,BLOCK,-1,,<empty>,9,,259,2,,void
118530,BLOCK,-1,,"{
    libvlc_int_t *vlc = logger->obj.libvlc;
    vlc_logger_early_t *sys = d;

    /* Drain early log messages */
    for (vlc_log_early_t *log = sys->head, *next; log != NULL; log = next)
    {
        vlc_LogCallback(vlc, log->type, &log->meta, ""%s"",
                        (log->msg != NULL) ? log->msg : ""message lost"");
        free(log->msg);
        next = log->next;
        free(log);
    }

    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",1,,271,3,,void
118544,BLOCK,-1,,<empty>,5,,276,1,,void
118558,BLOCK,4,,"{
        vlc_LogCallback(vlc, log->type, &log->meta, ""%s"",
                        (log->msg != NULL) ? log->msg : ""message lost"");
        free(log->msg);
        next = log->next;
        free(log);
    }",5,,277,4,,void
118605,BLOCK,-1,,"{
    (void) d; (void) type; (void) item; (void) format; (void) ap;
}",1,,291,6,,void
118626,BLOCK,-1,,"{
    vlc_log_cb (*activate)(vlc_object_t *, void **) = func;
    vlc_logger_t *logger = va_arg(ap, vlc_logger_t *);
    vlc_log_cb *cb = va_arg(ap, vlc_log_cb *);
    void **sys = va_arg(ap, void **);

    *cb = activate(VLC_OBJECT(logger), sys);
    return (*cb != NULL) ? VLC_SUCCESS : VLC_EGENERIC;
}",1,,296,3,,void
118630,BLOCK,-1,,<empty>,,,,3,,<empty>
118656,BLOCK,-1,,"{
    void (*deactivate)(vlc_logger_t *) = func;
    void *sys = va_arg(ap, void *);

    deactivate(sys);
}",1,,307,3,,void
118659,BLOCK,-1,,<empty>,,,,2,,<empty>
118669,BLOCK,-1,,"{
    vlc_logger_t *logger = vlc_custom_create(vlc, sizeof (*logger), ""logger"");

    libvlc_priv(vlc)->logger = logger;

    if (unlikely(logger == NULL))
        return -1;

    vlc_rwlock_init(&logger->lock);

    if (vlc_LogEarlyOpen(logger))
    {
        logger->log = vlc_vaLogDiscard;
        return -1;
    }

    /* Announce who we are */
    msg_Dbg(vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg(vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg(vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg(vlc, ""configured with %s"", CONFIGURE_LINE);
    return 0;
}",1,,324,2,,void
118676,BLOCK,1,,<empty>,,,,4,,void
118695,BLOCK,-1,,<empty>,9,,330,2,,void
118707,BLOCK,-1,,"{
        logger->log = vlc_vaLogDiscard;
        return -1;
    }",5,,335,2,,void
118738,BLOCK,-1,,"{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    if (unlikely(logger == NULL))
        return -1;

    vlc_log_cb cb;
    void *sys, *early_sys = NULL;

    /* TODO: module configuration item */
    module_t *module = vlc_module_load(logger, ""logger"", NULL, false,
                                       vlc_logger_load, logger, &cb, &sys);
    if (module == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    if (logger->log == vlc_vaLogEarly)
        early_sys = logger->sys;

    logger->log = cb;
    logger->sys = sys;
    assert(logger->module == NULL); /* Only one call to vlc_LogInit()! */
    logger->module = module;
    vlc_rwlock_unlock(&logger->lock);

    if (early_sys != NULL)
        vlc_LogEarlyClose(logger, early_sys);

    return 0;
}",1,,355,2,,void
118751,BLOCK,-1,,<empty>,9,,358,2,,void
118779,BLOCK,-1,,<empty>,9,,367,2,,void
118794,BLOCK,-1,,<empty>,9,,371,2,,void
118830,BLOCK,-1,,<empty>,9,,380,2,,void
118842,BLOCK,-1,,"{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    module_t *module;
    void *sys;

    if (cb == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    sys = logger->sys;
    module = logger->module;

    logger->log = cb;
    logger->sys = opaque;
    logger->module = NULL;
    vlc_rwlock_unlock(&logger->lock);

    if (module != NULL)
        vlc_module_unload(vlc, module, vlc_logger_unload, sys);

    /* Announce who we are */
    msg_Dbg (vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg (vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg (vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg (vlc, ""configured with %s"", CONFIGURE_LINE);
}",1,,391,4,,void
118855,BLOCK,-1,,<empty>,9,,395,2,,void
118863,BLOCK,-1,,<empty>,9,,401,2,,void
118906,BLOCK,-1,,<empty>,9,,413,2,,void
118932,BLOCK,-1,,"{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    if (logger->module != NULL)
        vlc_module_unload(vlc, logger->module, vlc_logger_unload, logger->sys);
    else
    /* Flush early log messages (corner case: no call to vlc_LogInit()) */
    if (logger->log == vlc_vaLogEarly)
    {
        logger->log = vlc_vaLogDiscard;
        vlc_LogEarlyClose(logger, logger->sys);
    }

    vlc_rwlock_destroy(&logger->lock);
    vlc_object_release(logger);
    libvlc_priv(vlc)->logger = NULL;
}",1,,423,2,,void
118945,BLOCK,-1,,<empty>,9,,427,2,,void
118953,BLOCK,-1,,<empty>,9,,430,2,,void
118964,BLOCK,-1,,<empty>,5,,433,1,,void
118971,BLOCK,-1,,"{
        logger->log = vlc_vaLogDiscard;
        vlc_LogEarlyClose(logger, logger->sys);
    }",5,,434,2,,void
119009,BLOCK,-1,,<empty>,1,,1,1,,ANY
119014,BLOCK,-1,,<empty>,,,,1,,<empty>
119142,BLOCK,-1,,"{

    char *psz_ext;

    psz_ext = strrchr( psz_url, '.' );
    if( psz_ext )
    {
        int i;

        for( i = 0; ext_mime[i].psz_ext[0] ; i++ )
        {
            if( !strcasecmp( ext_mime[i].psz_ext, psz_ext ) )
            {
                return ext_mime[i].psz_mime;
            }
        }
    }
    return ""application/octet-stream"";
}",1,,90,2,,void
119151,BLOCK,-1,,"{
        int i;

        for( i = 0; ext_mime[i].psz_ext[0] ; i++ )
        {
            if( !strcasecmp( ext_mime[i].psz_ext, psz_ext ) )
            {
                return ext_mime[i].psz_mime;
            }
        }
    }",5,,96,2,,void
119154,BLOCK,-1,,<empty>,9,,99,1,,void
119167,BLOCK,4,,"{
            if( !strcasecmp( ext_mime[i].psz_ext, psz_ext ) )
            {
                return ext_mime[i].psz_mime;
            }
        }",9,,100,4,,void
119177,BLOCK,-1,,"{
                return ext_mime[i].psz_mime;
            }",13,,102,2,,void
119200,BLOCK,-1,,<empty>,1,,1,1,,ANY
119204,BLOCK,-1,,"{
    if( unlikely(i_seconds < 0) )
    {
        secstotimestr( psz_buffer + 1, -i_seconds );
        *psz_buffer = '-';
        return psz_buffer;
    }

    div_t d;

    d = div( i_seconds, 60 );
    i_seconds = d.rem;
    d = div( d.quot, 60 );

    if( d.quot )
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%u:%02u:%02u"",
                 d.quot, d.rem, i_seconds );
    else
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%02u:%02u"",
                  d.rem, i_seconds );
    return psz_buffer;
}",1,,52,3,,void
119210,BLOCK,-1,,"{
        secstotimestr( psz_buffer + 1, -i_seconds );
        *psz_buffer = '-';
        return psz_buffer;
    }",5,,54,2,,void
119245,BLOCK,-1,,<empty>,9,,67,2,,void
119258,BLOCK,-1,,<empty>,9,,70,1,,void
119275,BLOCK,-1,,"{
    p_date->date = 0;
    p_date->i_divider_num = i_divider_n;
    p_date->i_divider_den = i_divider_d;
    p_date->i_remainder = 0;
}",1,,88,4,,void
119302,BLOCK,-1,,"{
    /* change time scale of remainder */
    p_date->i_remainder = p_date->i_remainder * i_divider_n / p_date->i_divider_num;
    p_date->i_divider_num = i_divider_n;
    p_date->i_divider_den = i_divider_d;
}",1,,104,4,,void
119331,BLOCK,-1,,"{
    p_date->date = i_new_date;
    p_date->i_remainder = 0;
}",1,,118,3,,void
119346,BLOCK,-1,,"{
    return p_date->date;
}",1,,130,2,,void
119356,BLOCK,-1,,"{
    p_date->date += i_difference;
}",1,,141,3,,void
119367,BLOCK,-1,,"{
    assert( p_date->i_divider_num != 0 );
    mtime_t i_dividend = i_nb_samples * CLOCK_FREQ * p_date->i_divider_den;
    lldiv_t d = lldiv( i_dividend, p_date->i_divider_num );

    p_date->date += d.quot;
    p_date->i_remainder += (int)d.rem;

    if( p_date->i_remainder >= p_date->i_divider_num )
    {
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < 2*p_date->i_divider_num);
        p_date->date += 1;
        p_date->i_remainder -= p_date->i_divider_num;
    }

    return p_date->date;
}",1,,154,3,,void
119416,BLOCK,-1,,"{
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < 2*p_date->i_divider_num);
        p_date->date += 1;
        p_date->i_remainder -= p_date->i_divider_num;
    }",5,,163,2,,void
119448,BLOCK,-1,,"{
    mtime_t i_dividend = (mtime_t)i_nb_samples * CLOCK_FREQ * p_date->i_divider_den;
    p_date->date -= i_dividend / p_date->i_divider_num;
    unsigned i_rem_adjust = i_dividend % p_date->i_divider_num;

    if( p_date->i_remainder < i_rem_adjust )
    {
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < p_date->i_divider_num);
        p_date->date -= 1;
        p_date->i_remainder += p_date->i_divider_num;
    }

    p_date->i_remainder -= i_rem_adjust;

    return p_date->date;
}",1,,182,3,,void
119484,BLOCK,-1,,"{
        /* This is Bresenham algorithm. */
        assert( p_date->i_remainder < p_date->i_divider_num);
        p_date->date -= 1;
        p_date->i_remainder += p_date->i_divider_num;
    }",5,,188,2,,void
119518,BLOCK,-1,,"{
    struct timespec ts;

    timespec_get(&ts, TIME_UTC);

    /* Convert nanoseconds to 32-bits fraction (232 picosecond units) */
    uint64_t t = (uint64_t)(ts.tv_nsec) << 32;
    t /= 1000000000;

    /* The offset to Unix epoch is 70 years (incl. 17 leap ones). There were
     * no leap seconds during that period since they had not been invented yet.
     */
    t |= ((UINT64_C(70) * 365 + 17) * 24 * 60 * 60 + ts.tv_sec) << 32;
    return t;
}",1,,204,2,,void
119586,BLOCK,-1,,<empty>,1,,1,1,,ANY
119590,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals(obj);

    int canc = vlc_savecancel ();
    printf ("" %so %p %s, %u refs, parent %p\n"", prefix, (void *)obj,
            obj->obj.object_type, atomic_load(&priv->refs),
            (void *)obj->obj.parent);
    vlc_restorecancel (canc);
}",1,,59,3,,void
119596,BLOCK,1,,<empty>,,,,2,,void
119638,BLOCK,-1,,"{
    char back = psz_foo[level];

    psz_foo[level] = '\0';
    PrintObject (obj, psz_foo);
    psz_foo[level] = back;

    if (level / 2 >= MAX_DUMPSTRUCTURE_DEPTH)
    {
        msg_Warn (obj, ""structure tree is too deep"");
        return;
    }

    vlc_object_internals_t *priv = vlc_internals(obj);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = priv->first; priv != NULL; priv = priv->next)
    {
        if (level > 0)
        {
            assert(level >= 2);
            psz_foo[level - 1] = ' ';

            if (psz_foo[level - 2] == '`')
                psz_foo[level - 2] = ' ';
        }

        psz_foo[level] = priv->next ? '|' : '`';
        psz_foo[level + 1] = '-';
        psz_foo[level + 2] = '\0';

        DumpStructure (vlc_externals(priv), level + 2, psz_foo);
    }
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
}",1,,70,4,,void
119664,BLOCK,-1,,"{
        msg_Warn (obj, ""structure tree is too deep"");
        return;
    }",5,,78,2,,void
119674,BLOCK,1,,<empty>,,,,2,,void
119685,BLOCK,1,,<empty>,,,,2,,void
119695,BLOCK,-1,,<empty>,5,,87,1,,void
119709,BLOCK,4,,"{
        if (level > 0)
        {
            assert(level >= 2);
            psz_foo[level - 1] = ' ';

            if (psz_foo[level - 2] == '`')
                psz_foo[level - 2] = ' ';
        }

        psz_foo[level] = priv->next ? '|' : '`';
        psz_foo[level + 1] = '-';
        psz_foo[level + 2] = '\0';

        DumpStructure (vlc_externals(priv), level + 2, psz_foo);
    }",5,,88,4,,void
119714,BLOCK,-1,,"{
            assert(level >= 2);
            psz_foo[level - 1] = ' ';

            if (psz_foo[level - 2] == '`')
                psz_foo[level - 2] = ' ';
        }",9,,90,2,,void
119734,BLOCK,-1,,<empty>,17,,95,2,,void
119769,BLOCK,1,,<empty>,,,,3,,void
119783,BLOCK,1,,<empty>,,,,2,,void
119800,BLOCK,-1,,"{
    (void) cmd; (void) oldval; (void) newval; (void) data;

    if (cmd[0] == 't')
    {
        char psz_foo[2 * MAX_DUMPSTRUCTURE_DEPTH + 1];

        psz_foo[0] = '|';
        DumpStructure (obj, 0, psz_foo);
    }

    return VLC_SUCCESS;
}",1,,116,6,,void
119819,BLOCK,-1,,"{
        char psz_foo[2 * MAX_DUMPSTRUCTURE_DEPTH + 1];

        psz_foo[0] = '|';
        DumpStructure (obj, 0, psz_foo);
    }",5,,120,2,,void
119837,BLOCK,-1,,"{
    if (root == obj)
        return vlc_object_hold (root);

    vlc_object_internals_t *priv = vlc_internals(root);
    vlc_object_t *ret = NULL;

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(root)->tree_lock);

    for (priv = priv->first; priv != NULL && ret == NULL; priv = priv->next)
        ret = ObjectExists (vlc_externals (priv), obj);

    vlc_mutex_unlock (&vlc_internals(root)->tree_lock);
    return ret;
}",1,,131,3,,void
119842,BLOCK,-1,,<empty>,9,,133,2,,void
119851,BLOCK,1,,<empty>,,,,2,,void
119866,BLOCK,1,,<empty>,,,,2,,void
119876,BLOCK,-1,,<empty>,5,,141,1,,void
119899,BLOCK,1,,<empty>,,,,3,,void
119910,BLOCK,1,,<empty>,,,,2,,void
119929,BLOCK,-1,,"{
    void *p;

    (void) cmd; (void) oldval; (void) data;

    if (sscanf (newval.psz_string, ""%p"", &p) == 1)
    {
        p = ObjectExists (obj, p);
        if (p == NULL)
        {
            msg_Err (obj, ""no such object: %s"", newval.psz_string);
            return VLC_ENOOBJ;
        }
        obj = p;
    }
    else
        vlc_object_hold (obj);

    PrintObject (obj, """");
    DumpVariables (obj);
    vlc_object_release (obj);

    return VLC_SUCCESS;
}",1,,150,6,,void
119950,BLOCK,-1,,"{
        p = ObjectExists (obj, p);
        if (p == NULL)
        {
            msg_Err (obj, ""no such object: %s"", newval.psz_string);
            return VLC_ENOOBJ;
        }
        obj = p;
    }",5,,156,2,,void
119960,BLOCK,-1,,"{
            msg_Err (obj, ""no such object: %s"", newval.psz_string);
            return VLC_ENOOBJ;
        }",9,,159,2,,void
119973,BLOCK,-1,,<empty>,9,,166,1,,void
119991,BLOCK,-1,,"{
    /* NOTE:
     * VLC objects are laid out as follow:
     * - first the LibVLC-private per-object data,
     * - then VLC_COMMON members from vlc_object_t,
     * - finally, the type-specific data (if any).
     *
     * This function initializes the LibVLC and common data,
     * and zeroes the rest.
     */
    assert (length >= sizeof (vlc_object_t));

    vlc_object_internals_t *priv = malloc (sizeof (*priv) + length);
    if (unlikely(priv == NULL))
        return NULL;
    priv->psz_name = NULL;
    priv->var_root = NULL;
    vlc_mutex_init (&priv->var_lock);
    vlc_cond_init (&priv->var_wait);
    atomic_init (&priv->refs, 1);
    priv->pf_destructor = NULL;
    priv->prev = NULL;
    priv->first = NULL;
    vlc_mutex_init (&priv->tree_lock);
    priv->resources = NULL;

    vlc_object_t *obj = (vlc_object_t *)(priv + 1);
    obj->obj.object_type = typename;
    obj->obj.header = NULL;
    obj->obj.force = false;
    memset (obj + 1, 0, length - sizeof (*obj)); /* type-...",1,,178,4,,void
120011,BLOCK,-1,,<empty>,9,,192,2,,void
120109,BLOCK,-1,,"{
        vlc_object_internals_t *papriv = vlc_internals (parent);

        obj->obj.flags = parent->obj.flags;
        obj->obj.libvlc = parent->obj.libvlc;

        /* Attach the child to its parent (no lock needed) */
        obj->obj.parent = vlc_object_hold (parent);

        /* Attach the parent to its child (structure lock needed) */
        vlc_mutex_lock (&papriv->tree_lock);
        priv->next = papriv->first;
        if (priv->next != NULL)
            priv->next->prev = priv;
        papriv->first = priv;
        vlc_mutex_unlock (&papriv->tree_lock);
    }",5,,211,2,,void
120115,BLOCK,1,,<empty>,,,,2,,void
120170,BLOCK,-1,,<empty>,13,,224,2,,void
120189,BLOCK,-1,,"{
        libvlc_int_t *self = (libvlc_int_t *)obj;

        obj->obj.flags = 0;
        obj->obj.libvlc = self;
        obj->obj.parent = NULL;
        priv->next = NULL;

        /* TODO: should be in src/libvlc.c */
        int canc = vlc_savecancel ();
        var_Create (obj, ""tree"", VLC_VAR_STRING | VLC_VAR_ISCOMMAND);
        var_AddCallback (obj, ""tree"", TreeCommand, NULL);
        var_Create (obj, ""vars"", VLC_VAR_STRING | VLC_VAR_ISCOMMAND);
        var_AddCallback (obj, ""vars"", VarsCommand, NULL);
        vlc_restorecancel (canc);
    }",5,,229,1,,void
120257,BLOCK,-1,,"{
    return vlc_custom_create( p_this, i_size, ""generic"" );
}",1,,258,3,,void
120268,BLOCK,-1,,"{
    vlc_object_internals_t *p_priv = vlc_internals(p_this );

    p_priv->pf_destructor = pf_destructor;
}",1,,273,3,,void
120274,BLOCK,1,,<empty>,,,,2,,void
120295,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *newname = name ? strdup (name) : NULL;
    char *oldname;

    vlc_mutex_lock (&name_lock);
    oldname = priv->psz_name;
    priv->psz_name = newname;
    vlc_mutex_unlock (&name_lock);

    free (oldname);
    return (priv->psz_name || !name) ? VLC_SUCCESS : VLC_ENOMEM;
}",1,,283,3,,void
120301,BLOCK,1,,<empty>,,,,2,,void
120349,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *name;

    vlc_mutex_lock (&name_lock);
    name = priv->psz_name ? strdup (priv->psz_name) : NULL;
    vlc_mutex_unlock (&name_lock);

    return name;
}",1,,299,2,,void
120355,BLOCK,1,,<empty>,,,,2,,void
120386,BLOCK,-1,,"{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    assert(p_priv->resources == NULL);

    /* Call the custom ""subclass"" destructor */
    if( p_priv->pf_destructor )
        p_priv->pf_destructor( p_this );

    if (unlikely(p_this->obj.parent == NULL))
    {
        /* TODO: should be in src/libvlc.c */
        var_DelCallback (p_this, ""vars"", VarsCommand, NULL);
        var_DelCallback (p_this, ""tree"", TreeCommand, NULL);
    }

    /* Destroy the associated variables. */
    var_DestroyAll( p_this );

    vlc_mutex_destroy (&p_priv->tree_lock);
    vlc_cond_destroy( &p_priv->var_wait );
    vlc_mutex_destroy( &p_priv->var_lock );
    free( p_this->obj.header );
    free( p_priv->psz_name );
    free( p_priv );
}",1,,316,2,,void
120392,BLOCK,1,,<empty>,,,,2,,void
120409,BLOCK,-1,,<empty>,9,,323,2,,void
120424,BLOCK,-1,,"{
        /* TODO: should be in src/libvlc.c */
        var_DelCallback (p_this, ""vars"", VarsCommand, NULL);
        var_DelCallback (p_this, ""tree"", TreeCommand, NULL);
    }",5,,326,2,,void
120469,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals(obj);

    if (priv->psz_name != NULL && !strcmp (priv->psz_name, name))
        return vlc_object_hold (obj);

    vlc_object_t *found = NULL;
    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);

    for (priv = priv->first; priv != NULL && found == NULL; priv = priv->next)
        found = FindName (vlc_externals(priv), name);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return found;
}",1,,344,3,,void
120475,BLOCK,1,,<empty>,,,,2,,void
120495,BLOCK,-1,,<empty>,9,,348,2,,void
120507,BLOCK,1,,<empty>,,,,2,,void
120517,BLOCK,-1,,<empty>,5,,354,1,,void
120540,BLOCK,1,,<empty>,,,,3,,void
120551,BLOCK,1,,<empty>,,,,2,,void
120567,BLOCK,-1,,"{
    vlc_object_t *p_found;

    /* The object name is not thread-safe, provides no warranty that the
     * object is fully initialized and still active, and that its owner can
     * deal with asynchronous and external state changes. There may be multiple
     * objects with the same name, and the function may fail even if a matching
     * object exists. DO NOT USE THIS IN NEW CODE. */
#ifndef NDEBUG
    /* This was officially deprecated on August 19 2009. For the convenience of
     * wannabe code janitors, this is the list of names that remain used
     * and unfixed since then. */
    static const char bad[][11] = { ""adjust"", ""clone"", ""colorthres"",
        ""erase"", ""extract"", ""gradient"", ""logo"", ""marq"", ""motionblur"", ""puzzle"",
        ""rotate"", ""sharpen"", ""transform"", ""v4l2"", ""wall"" };
    static const char poor[][13] = { ""invert"", ""magnify"", ""motiondetect"",
        ""psychedelic"", ""ripple"", ""wave"" };
    if( bsearch( psz_name, bad, 15, 11, (void *)strcmp ) == NULL
     && bse...",1,,379,3,,void
120620,BLOCK,-1,,<empty>,9,,398,2,,void
120644,BLOCK,-1,,"{
    vlc_object_internals_t *internals = vlc_internals( p_this );
#ifndef NDEBUG
    unsigned refs = atomic_fetch_add (&internals->refs, 1);
    assert (refs > 0); /* Avoid obvious freed object uses */
#else
    atomic_fetch_add (&internals->refs, 1);
#endif
    return p_this;
}",1,,413,2,,void
120650,BLOCK,1,,<empty>,,,,2,,void
120676,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals(obj);
    unsigned refs = atomic_load (&priv->refs);

    /* Fast path */
    while (refs > 1)
    {
        if (atomic_compare_exchange_weak (&priv->refs, &refs, refs - 1))
            return; /* There are still other references to the object */

        assert (refs > 0);
    }

    vlc_object_t *parent = obj->obj.parent;

    if (unlikely(parent == NULL))
    {   /* Destroying the root object */
        refs = atomic_fetch_sub (&priv->refs, 1);
        assert (refs == 1); /* nobody to race against in this case */

        assert (priv->first == NULL); /* no children can be left */

        int canc = vlc_savecancel ();
        vlc_object_destroy (obj);
        vlc_restorecancel (canc);
        return;
    }

    /* Slow path */
    vlc_object_internals_t *papriv = vlc_internals (parent);

    vlc_mutex_lock (&papriv->tree_lock);
    refs = atomic_fetch_sub (&priv->refs, 1);
    assert (refs > 0);

    if (likely(refs == 1))
    {...",1,,430,2,,void
120682,BLOCK,1,,<empty>,,,,2,,void
120701,BLOCK,-1,,"{
        if (atomic_compare_exchange_weak (&priv->refs, &refs, refs - 1))
            return; /* There are still other references to the object */

        assert (refs > 0);
    }",5,,436,2,,void
120713,BLOCK,-1,,<empty>,13,,438,2,,void
120732,BLOCK,-1,,"{   /* Destroying the root object */
        refs = atomic_fetch_sub (&priv->refs, 1);
        assert (refs == 1); /* nobody to race against in this case */

        assert (priv->first == NULL); /* no children can be left */

        int canc = vlc_savecancel ();
        vlc_object_destroy (obj);
        vlc_restorecancel (canc);
        return;
    }",5,,446,2,,void
120765,BLOCK,1,,<empty>,,,,3,,void
120794,BLOCK,-1,,"{   /* Detach from parent to protect against vlc_object_find_name() */
        vlc_object_internals_t *prev = priv->prev;
        vlc_object_internals_t *next = priv->next;

        if (prev != NULL)
        {
            assert (prev->next == priv);
            prev->next = next;
        }
        else
        {
            assert (papriv->first == priv);
            papriv->first = next;
        }
        if (next != NULL)
        {
            assert (next->prev == priv);
            next->prev = prev;
        }
    }",5,,466,2,,void
120811,BLOCK,-1,,"{
            assert (prev->next == priv);
            prev->next = next;
        }",9,,471,2,,void
120824,BLOCK,-1,,"{
            assert (papriv->first == priv);
            papriv->first = next;
        }",9,,476,1,,void
120840,BLOCK,-1,,"{
            assert (next->prev == priv);
            next->prev = prev;
        }",9,,481,2,,void
120862,BLOCK,-1,,"{
        assert (priv->first == NULL); /* no children can be left */

        int canc = vlc_savecancel ();
        vlc_object_destroy (obj);
        vlc_restorecancel (canc);

        vlc_object_release (parent);
    }",5,,489,2,,void
120883,BLOCK,-1,,"{
    vlc_list_t *l = malloc (sizeof (*l));
    if (unlikely(l == NULL))
        return NULL;

    l->i_count = 0;
    l->p_values = NULL;

    vlc_object_internals_t *priv;
    unsigned count = 0;

    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
         count++;

    if (count > 0)
    {
        l->p_values = vlc_alloc (count, sizeof (vlc_value_t));
        if (unlikely(l->p_values == NULL))
        {
            vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
            free (l);
            return NULL;
        }
        l->i_count = count;
    }

    unsigned i = 0;

    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
        l->p_values[i++].p_address = vlc_object_hold (vlc_externals (priv));
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return l;
}",1,,507,2,,void
120896,BLOCK,-1,,<empty>,9,,510,2,,void
120918,BLOCK,1,,<empty>,,,,2,,void
120928,BLOCK,-1,,<empty>,5,,519,1,,void
120933,BLOCK,1,,<empty>,,,,2,,void
120954,BLOCK,-1,,"{
        l->p_values = vlc_alloc (count, sizeof (vlc_value_t));
        if (unlikely(l->p_values == NULL))
        {
            vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
            free (l);
            return NULL;
        }
        l->i_count = count;
    }",5,,523,2,,void
120970,BLOCK,-1,,"{
            vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
            free (l);
            return NULL;
        }",9,,526,2,,void
120975,BLOCK,1,,<empty>,,,,2,,void
120998,BLOCK,-1,,<empty>,5,,536,1,,void
121003,BLOCK,1,,<empty>,,,,2,,void
121030,BLOCK,1,,<empty>,,,,3,,void
121040,BLOCK,1,,<empty>,,,,2,,void
121055,BLOCK,-1,,"{
    for( int i = 0; i < p_list->i_count; i++ )
        vlc_object_release( p_list->p_values[i].p_address );

    free( p_list->p_values );
    free( p_list );
}",1,,549,2,,void
121057,BLOCK,-1,,<empty>,5,,550,1,,void
121105,BLOCK,-1,,<empty>,1,,1,1,,ANY
121111,BLOCK,-1,,<empty>,,,,2,,<empty>
121116,BLOCK,-1,,<empty>,,,,1,,<empty>
121122,BLOCK,-1,,"{
    return &vlc_internals(obj)->resources;
}",1,,43,2,,void
121127,BLOCK,1,,<empty>,,,,2,,void
121141,BLOCK,-1,,"{
    if (unlikely(add_overflow(sizeof (struct vlc_res), size, &size)))
    {
        errno = ENOMEM;
        return NULL;
    }

    struct vlc_res *res = malloc(size);
    if (unlikely(res == NULL))
        return NULL;

    res->release = release;
    return res->payload;
}",1,,48,3,,void
121150,BLOCK,-1,,"{
        errno = ENOMEM;
        return NULL;
    }",5,,50,2,,void
121166,BLOCK,-1,,<empty>,9,,57,2,,void
121183,BLOCK,-1,,"{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = container_of(data, struct vlc_res, payload);

    res->prev = *pp;
    *pp = res;
}",1,,64,3,,void
121205,BLOCK,-1,,"{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = *pp;

    if (res == NULL)
        return NULL;
    *pp = res->prev;
    return res->payload;
}",1,,73,2,,void
121220,BLOCK,-1,,<empty>,9,,78,2,,void
121237,BLOCK,-1,,"{
    void *data;

    while ((data = vlc_objres_pop(obj)) != NULL)
    {
        struct vlc_res *res = container_of(data, struct vlc_res, payload);

        res->release(res->payload);
        free(res);
    }
}",1,,84,2,,void
121246,BLOCK,-1,,"{
        struct vlc_res *res = container_of(data, struct vlc_res, payload);

        res->release(res->payload);
        free(res);
    }",5,,88,2,,void
121264,BLOCK,-1,,"{
    struct vlc_res **restrict pp = vlc_obj_res(obj);

    /* With a doubly-linked list, this function could have constant complexity.
     * But that would require one more pointer per resource.
     *
     * Any given list should contain a fairly small number of resources,
     * and in most cases, the resources are destroyed implicitly by
     * vlc_objres_clear().
     */
    for (;;)
    {
        struct vlc_res *res = *pp;

        assert(res != NULL); /* invalid free? */

        if (match(res->payload, data))
        {
            *pp = res->prev;
            res->release(res->payload);
            free(res);
            return;
        }

        pp = &res->prev;
    }
}",1,,98,4,,void
121271,BLOCK,-1,,<empty>,5,,108,1,,void
121272,BLOCK,4,,"{
        struct vlc_res *res = *pp;

        assert(res != NULL); /* invalid free? */

        if (match(res->payload, data))
        {
            *pp = res->prev;
            res->release(res->payload);
            free(res);
            return;
        }

        pp = &res->prev;
    }",5,,109,4,,void
121288,BLOCK,-1,,"{
            *pp = res->prev;
            res->release(res->payload);
            free(res);
            return;
        }",9,,115,2,,void
121315,BLOCK,-1,,"{
    (void) data;
}",1,,127,2,,void
121324,BLOCK,-1,,"{
    return a == b;
}",1,,132,3,,void
121334,BLOCK,-1,,"{
    void *ptr = vlc_objres_new(size, dummy_release);
    if (likely(ptr != NULL))
        vlc_objres_push(obj, ptr);
    return ptr;
}",1,,137,3,,void
121346,BLOCK,-1,,<empty>,9,,140,2,,void
121359,BLOCK,-1,,"{
    size_t tabsize;
    if (mul_overflow(nmemb, size, &tabsize))
    {
        errno = ENOMEM;
        return NULL;
    }

    void *ptr = vlc_objres_new(tabsize, dummy_release);
    if (likely(ptr != NULL))
    {
        if (do_memset)
            memset(ptr, 0, tabsize);
        vlc_objres_push(obj, ptr);
    }
    return ptr;
}",1,,146,5,,void
121367,BLOCK,-1,,"{
        errno = ENOMEM;
        return NULL;
    }",5,,149,2,,void
121384,BLOCK,-1,,"{
        if (do_memset)
            memset(ptr, 0, tabsize);
        vlc_objres_push(obj, ptr);
    }",5,,156,2,,void
121387,BLOCK,-1,,<empty>,13,,158,2,,void
121403,BLOCK,-1,,"{
    return vlc_obj_alloc_common(obj, nmemb, size, true);
}",1,,165,4,,void
121415,BLOCK,-1,,"{
    vlc_objres_remove(obj, ptr, ptrcmp);
}",1,,170,3,,void
121438,BLOCK,-1,,<empty>,1,,1,1,,ANY
121441,BLOCK,-1,,"{
    /* Calculate how big the new image should be */
    size_t i_bytes = 0;
    for( int i = 0; i < p_pic->i_planes; i++ )
    {
        const plane_t *p = &p_pic->p[i];

        if( p->i_pitch < 0 || p->i_lines <= 0 ||
            (size_t)p->i_pitch > (SIZE_MAX - i_bytes)/p->i_lines )
        {
            p_pic->i_planes = 0;
            return VLC_ENOMEM;
        }
        i_bytes += p->i_pitch * p->i_lines;
    }

    if( i_bytes >= PICTURE_SW_SIZE_MAX )
    {
        p_pic->i_planes = 0;
        return VLC_ENOMEM;
    }

    i_bytes = (i_bytes + 63) & ~63; /* must be a multiple of 64 */
    uint8_t *p_data = aligned_alloc( 64, i_bytes );
    if( i_bytes > 0 && p_data == NULL )
    {
        p_pic->i_planes = 0;
        return VLC_EGENERIC;
    }

    /* Fill the p_pixels field for each plane */
    p_pic->p[0].p_pixels = p_data;
    for( int i = 1; i < p_pic->i_planes; i++ )
    {
        p_pic->p[i].p_pixels = &p_pic->p[i-1].p_pixels[ p_pic->p[i-1].i_lines *
                ...",1,,51,2,,void
121447,BLOCK,-1,,<empty>,5,,54,1,,void
121459,BLOCK,4,,"{
        const plane_t *p = &p_pic->p[i];

        if( p->i_pitch < 0 || p->i_lines <= 0 ||
            (size_t)p->i_pitch > (SIZE_MAX - i_bytes)/p->i_lines )
        {
            p_pic->i_planes = 0;
            return VLC_ENOMEM;
        }
        i_bytes += p->i_pitch * p->i_lines;
    }",5,,55,4,,void
121495,BLOCK,-1,,"{
            p_pic->i_planes = 0;
            return VLC_ENOMEM;
        }",9,,60,2,,void
121516,BLOCK,1,,<empty>,,,,1,,void
121520,BLOCK,-1,,"{
        p_pic->i_planes = 0;
        return VLC_ENOMEM;
    }",5,,68,2,,void
121550,BLOCK,-1,,"{
        p_pic->i_planes = 0;
        return VLC_EGENERIC;
    }",5,,76,2,,void
121568,BLOCK,-1,,<empty>,5,,83,1,,void
121580,BLOCK,4,,"{
        p_pic->p[i].p_pixels = &p_pic->p[i-1].p_pixels[ p_pic->p[i-1].i_lines *
                                                        p_pic->p[i-1].i_pitch ];
    }",5,,84,4,,void
121625,BLOCK,-1,,"{
    picture_context_t *ctx = p_picture->context;
    if (ctx != NULL)
    {
        ctx->destroy(ctx);
        p_picture->context = NULL;
    }
}",1,,97,2,,void
121636,BLOCK,-1,,"{
        ctx->destroy(ctx);
        p_picture->context = NULL;
    }",5,,100,2,,void
121651,BLOCK,-1,,"{
    free( p_picture->p_sys );
    free( p_picture );
}",1,,111,2,,void
121662,BLOCK,-1,,"{
    aligned_free( p_picture->p[0].p_pixels );
    free( p_picture );
}",1,,121,2,,void
121677,BLOCK,-1,,"{
    /* */
    p_picture->date = VLC_TS_INVALID;
    p_picture->b_force = false;
    p_picture->b_progressive = false;
    p_picture->i_nb_fields = 2;
    p_picture->b_top_field_first = false;
    PictureDestroyContext( p_picture );
}",1,,130,2,,void
121710,BLOCK,-1,,"{
    return a * b / GCD( a, b );
}",1,,144,3,,void
121724,BLOCK,-1,,"{
    /* Store default values */
    p_picture->i_planes = 0;
    for( unsigned i = 0; i < VOUT_MAX_PLANES; i++ )
    {
        plane_t *p = &p_picture->p[i];
        p->p_pixels = NULL;
        p->i_pixel_pitch = 0;
    }

    p_picture->i_nb_fields = 2;

    video_format_Setup( &p_picture->format, fmt->i_chroma, fmt->i_width, fmt->i_height,
                        fmt->i_visible_width, fmt->i_visible_height,
                        fmt->i_sar_num, fmt->i_sar_den );

    const vlc_chroma_description_t *p_dsc =
        vlc_fourcc_GetChromaDescription( p_picture->format.i_chroma );
    if( !p_dsc )
        return VLC_EGENERIC;

    /* We want V (width/height) to respect:
        (V * p_dsc->p[i].w.i_num) % p_dsc->p[i].w.i_den == 0
        (V * p_dsc->p[i].w.i_num/p_dsc->p[i].w.i_den * p_dsc->i_pixel_size) % 16 == 0
       Which is respected if you have
       V % lcm( p_dsc->p[0..planes].w.i_den * 16) == 0
    */
    int i_modulo_w = 1;
    int i_modulo_h = 1;
    unsigned int i_rati...",1,,149,3,,void
121731,BLOCK,-1,,<empty>,5,,152,1,,void
121741,BLOCK,4,,"{
        plane_t *p = &p_picture->p[i];
        p->p_pixels = NULL;
        p->i_pixel_pitch = 0;
    }",5,,153,4,,void
121804,BLOCK,-1,,<empty>,9,,168,2,,void
121820,BLOCK,-1,,<empty>,5,,179,1,,void
121832,BLOCK,4,,"{
        i_modulo_w = LCM( i_modulo_w, 16 * p_dsc->p[i].w.den );
        i_modulo_h = LCM( i_modulo_h, 16 * p_dsc->p[i].h.den );
        if( i_ratio_h < p_dsc->p[i].h.den )
            i_ratio_h = p_dsc->p[i].h.den;
    }",5,,180,4,,void
121875,BLOCK,-1,,<empty>,13,,184,2,,void
121927,BLOCK,-1,,<empty>,5,,191,1,,void
121939,BLOCK,4,,"{
        plane_t *p = &p_picture->p[i];

        p->i_lines         = (i_height_aligned + i_height_extra ) * p_dsc->p[i].h.num / p_dsc->p[i].h.den;
        p->i_visible_lines = (fmt->i_visible_height + (p_dsc->p[i].h.den - 1)) / p_dsc->p[i].h.den * p_dsc->p[i].h.num;
        p->i_pitch         = i_width_aligned * p_dsc->p[i].w.num / p_dsc->p[i].w.den * p_dsc->pixel_size;
        p->i_visible_pitch = (fmt->i_visible_width + (p_dsc->p[i].w.den - 1)) / p_dsc->p[i].w.den * p_dsc->p[i].w.num * p_dsc->pixel_size;
        p->i_pixel_pitch   = p_dsc->pixel_size;

        assert( (p->i_pitch % 16) == 0 );
    }",5,,192,4,,void
122116,BLOCK,-1,,"{
    video_format_t fmt = *p_fmt;

    /* It is needed to be sure all information are filled */
    video_format_Setup( &fmt, p_fmt->i_chroma,
                              p_fmt->i_width, p_fmt->i_height,
                              p_fmt->i_visible_width, p_fmt->i_visible_height,
                              p_fmt->i_sar_num, p_fmt->i_sar_den );
    if( p_fmt->i_x_offset < p_fmt->i_width &&
        p_fmt->i_y_offset < p_fmt->i_height &&
        p_fmt->i_visible_width  > 0 && p_fmt->i_x_offset + p_fmt->i_visible_width  <= p_fmt->i_width &&
        p_fmt->i_visible_height > 0 && p_fmt->i_y_offset + p_fmt->i_visible_height <= p_fmt->i_height )
        video_format_CopyCrop( &fmt, p_fmt );

    /* */
    picture_priv_t *priv = malloc( sizeof (*priv) );
    if( unlikely(priv == NULL) )
        return NULL;

    picture_t *p_picture = &priv->picture;

    memset( p_picture, 0, sizeof( *p_picture ) );
    p_picture->format = fmt;

    /* Make sure the real dimensions are a multiple o...",1,,212,3,,void
122198,BLOCK,-1,,<empty>,9,,224,2,,void
122215,BLOCK,-1,,<empty>,9,,229,2,,void
122241,BLOCK,-1,,"{
        free( p_picture );
        return NULL;
    }",5,,238,2,,void
122263,BLOCK,-1,,"{
        p_picture->p_sys = p_resource->p_sys;

        if( p_resource->pf_destroy != NULL )
            priv->gc.destroy = p_resource->pf_destroy;
        else
            priv->gc.destroy = picture_DestroyFromResource;

        for( int i = 0; i < p_picture->i_planes; i++ )
        {
            p_picture->p[i].p_pixels = p_resource->p[i].p_pixels;
            p_picture->p[i].i_lines  = p_resource->p[i].i_lines;
            p_picture->p[i].i_pitch  = p_resource->p[i].i_pitch;
        }
    }",5,,247,2,,void
122277,BLOCK,-1,,<empty>,13,,251,2,,void
122288,BLOCK,-1,,<empty>,13,,253,1,,void
122297,BLOCK,-1,,<empty>,9,,255,1,,void
122309,BLOCK,4,,"{
            p_picture->p[i].p_pixels = p_resource->p[i].p_pixels;
            p_picture->p[i].i_lines  = p_resource->p[i].i_lines;
            p_picture->p[i].i_pitch  = p_resource->p[i].i_pitch;
        }",9,,256,4,,void
122356,BLOCK,-1,,"{
        if( AllocatePicture( p_picture ) )
        {
            free( p_picture );
            return NULL;
        }
        priv->gc.destroy = picture_Destroy;
    }",5,,263,1,,void
122360,BLOCK,-1,,"{
            free( p_picture );
            return NULL;
        }",9,,265,2,,void
122378,BLOCK,-1,,"{
    return picture_NewFromResource( p_fmt, NULL );
}",1,,276,2,,void
122391,BLOCK,-1,,"{
    video_format_t fmt;

    video_format_Init( &fmt, 0 );
    video_format_Setup( &fmt, i_chroma, i_width, i_height,
                        i_width, i_height, i_sar_num, i_sar_den );

    return picture_NewFromFormat( &fmt );
}",1,,281,6,,void
122415,BLOCK,-1,,"{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_add( &priv->gc.refs, 1 );
    assert( refs > 0 );
    return p_picture;
}",1,,296,2,,void
122447,BLOCK,-1,,"{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_sub( &priv->gc.refs, 1 );
    assert( refs != 0 );
    if( refs > 1 )
        return;

    PictureDestroyContext( p_picture );
    assert( priv->gc.destroy != NULL );
    priv->gc.destroy( p_picture );
}",1,,306,2,,void
122477,BLOCK,-1,,<empty>,9,,313,2,,void
122501,BLOCK,-1,,"{
    const unsigned i_width  = __MIN( p_dst->i_visible_pitch,
                                     p_src->i_visible_pitch );
    const unsigned i_height = __MIN( p_dst->i_lines, p_src->i_lines );

    /* The 2x visible pitch check does two things:
       1) Makes field plane_t's work correctly (see the deinterlacer module)
       2) Moves less data if the pitch and visible pitch differ much.
    */
    if( p_src->i_pitch == p_dst->i_pitch  &&
        p_src->i_pitch < 2*p_src->i_visible_pitch )
    {
        /* There are margins, but with the same width : perfect ! */
        memcpy( p_dst->p_pixels, p_src->p_pixels,
                    p_src->i_pitch * i_height );
    }
    else
    {
        /* We need to proceed line by line */
        uint8_t *p_in = p_src->p_pixels;
        uint8_t *p_out = p_dst->p_pixels;

        assert( p_in );
        assert( p_out );

        for( int i_line = i_height; i_line--; )
        {
            memcpy( p_out, p_in, i_width );
            p_in += ...",1,,324,3,,void
122540,BLOCK,-1,,"{
        /* There are margins, but with the same width : perfect ! */
        memcpy( p_dst->p_pixels, p_src->p_pixels,
                    p_src->i_pitch * i_height );
    }",5,,335,2,,void
122554,BLOCK,-1,,"{
        /* We need to proceed line by line */
        uint8_t *p_in = p_src->p_pixels;
        uint8_t *p_out = p_dst->p_pixels;

        assert( p_in );
        assert( p_out );

        for( int i_line = i_height; i_line--; )
        {
            memcpy( p_out, p_in, i_width );
            p_in += p_src->i_pitch;
            p_out += p_dst->i_pitch;
        }
    }",5,,341,1,,void
122572,BLOCK,-1,,<empty>,9,,349,1,,void
122579,BLOCK,4,,"{
            memcpy( p_out, p_in, i_width );
            p_in += p_src->i_pitch;
            p_out += p_dst->i_pitch;
        }",9,,350,4,,void
122599,BLOCK,-1,,"{
    p_dst->date = p_src->date;
    p_dst->b_force = p_src->b_force;

    p_dst->b_progressive = p_src->b_progressive;
    p_dst->i_nb_fields = p_src->i_nb_fields;
    p_dst->b_top_field_first = p_src->b_top_field_first;
}",1,,359,3,,void
122640,BLOCK,-1,,"{
    for( int i = 0; i < p_src->i_planes ; i++ )
        plane_CopyPixels( p_dst->p+i, p_src->p+i );

    assert( p_dst->context == NULL );

    if( p_src->context != NULL )
        p_dst->context = p_src->context->copy( p_src->context );
}",1,,369,3,,void
122642,BLOCK,-1,,<empty>,5,,370,1,,void
122677,BLOCK,-1,,<empty>,9,,376,2,,void
122696,BLOCK,-1,,"{
    picture_CopyPixels( p_dst, p_src );
    picture_CopyProperties( p_dst, p_src );
}",1,,380,3,,void
122707,BLOCK,-1,,"{
    picture_t *picture = ((picture_priv_t *)clone)->gc.opaque;

    free(clone);
    picture_Release(picture);
}",1,,386,2,,void
122726,BLOCK,-1,,"{
    /* TODO: merge common code with picture_pool_ClonePicture(). */
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_DestroyClone,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = picture;
        picture_Hold(picture);

        if (picture->context != NULL)
            clone->context = picture->context->copy(picture->context);
    }
    return clone;
}",1,,394,2,,void
122731,BLOCK,1,,<empty>,9,,397,1,,void
122737,BLOCK,2,,<empty>,9,,398,2,,void
122742,BLOCK,-1,,<empty>,5,,401,1,,void
122754,BLOCK,4,,"{
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }",49,,401,4,,void
122815,BLOCK,-1,,"{
        ((picture_priv_t *)clone)->gc.opaque = picture;
        picture_Hold(picture);

        if (picture->context != NULL)
            clone->context = picture->context->copy(picture->context);
    }",32,,408,2,,void
122833,BLOCK,-1,,<empty>,13,,413,2,,void
122859,BLOCK,-1,,"{
    /* */
    video_format_t fmt_in = p_picture->format;
    if( fmt_in.i_sar_num <= 0 || fmt_in.i_sar_den <= 0 )
    {
        fmt_in.i_sar_num =
        fmt_in.i_sar_den = 1;
    }

    /* */
    video_format_t fmt_out;
    memset( &fmt_out, 0, sizeof(fmt_out) );
    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 1;
    fmt_out.i_chroma  = i_format;

    /* compute original width/height */
    unsigned int i_width, i_height, i_original_width, i_original_height;
    if( fmt_in.i_visible_width > 0 && fmt_in.i_visible_height > 0 )
    {
        i_width = fmt_in.i_visible_width;
        i_height = fmt_in.i_visible_height;
    }
    else
    {
        i_width = fmt_in.i_width;
        i_height = fmt_in.i_height;
    }
    if( fmt_in.i_sar_num >= fmt_in.i_sar_den )
    {
        i_original_width = (int64_t)i_width * fmt_in.i_sar_num / fmt_in.i_sar_den;
        i_original_height = i_height;
    }
    else
    {
        i_original_width =  i_width;
        i_original_height = i_height * fm...",1,,427,8,,void
122878,BLOCK,-1,,"{
        fmt_in.i_sar_num =
        fmt_in.i_sar_den = 1;
    }",5,,431,2,,void
122925,BLOCK,-1,,"{
        i_width = fmt_in.i_visible_width;
        i_height = fmt_in.i_visible_height;
    }",5,,446,2,,void
122937,BLOCK,-1,,"{
        i_width = fmt_in.i_width;
        i_height = fmt_in.i_height;
    }",5,,451,1,,void
122956,BLOCK,-1,,"{
        i_original_width = (int64_t)i_width * fmt_in.i_sar_num / fmt_in.i_sar_den;
        i_original_height = i_height;
    }",5,,456,2,,void
122974,BLOCK,-1,,"{
        i_original_width =  i_width;
        i_original_height = i_height * fmt_in.i_sar_den / fmt_in.i_sar_num;
    }",5,,461,1,,void
123025,BLOCK,-1,,"{
        fmt_out.i_height = i_height * fmt_out.i_width
                         * fmt_in.i_sar_den / fmt_in.i_width / fmt_in.i_sar_num;
    }",5,,474,2,,void
123048,BLOCK,-1,,<empty>,10,,478,1,,void
123061,BLOCK,-1,,"{
        fmt_out.i_width  = i_width * fmt_out.i_height
                         * fmt_in.i_sar_num / fmt_in.i_height / fmt_in.i_sar_den;
    }",5,,479,2,,void
123091,BLOCK,-1,,<empty>,9,,486,2,,void
123109,BLOCK,-1,,<empty>,9,,493,2,,void
123125,BLOCK,-1,,<empty>,9,,499,2,,void
123146,BLOCK,-1,,<empty>,1,,1,1,,ANY
123153,BLOCK,-1,,<empty>,,,,2,,<empty>
123171,BLOCK,-1,,<empty>,1,,1,1,,ANY
123178,BLOCK,-1,,"{
    fifo->first    = NULL;
    fifo->last_ptr = &fifo->first;
}",1,,47,2,,void
123197,BLOCK,-1,,"{
    assert(!picture->p_next);
    *fifo->last_ptr = picture;
    fifo->last_ptr  = &picture->p_next;
}",1,,52,3,,void
123221,BLOCK,-1,,"{
    picture_t *picture = fifo->first;

    if (picture) {
        fifo->first = picture->p_next;
        if (!fifo->first)
            fifo->last_ptr = &fifo->first;
        picture->p_next = NULL;
    }
    return picture;
}",1,,58,2,,void
123230,BLOCK,-1,,"{
        fifo->first = picture->p_next;
        if (!fifo->first)
            fifo->last_ptr = &fifo->first;
        picture->p_next = NULL;
    }",18,,61,2,,void
123243,BLOCK,-1,,<empty>,13,,64,2,,void
123263,BLOCK,-1,,"{
    picture_fifo_t *fifo = malloc(sizeof(*fifo));
    if (!fifo)
        return NULL;

    vlc_mutex_init(&fifo->lock);
    PictureFifoReset(fifo);
    return fifo;
}",1,,71,2,,void
123274,BLOCK,-1,,<empty>,9,,74,2,,void
123291,BLOCK,-1,,"{
    vlc_mutex_lock(&fifo->lock);
    PictureFifoPush(fifo, picture);
    vlc_mutex_unlock(&fifo->lock);
}",1,,82,3,,void
123309,BLOCK,-1,,"{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = PictureFifoPop(fifo);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",1,,88,2,,void
123331,BLOCK,-1,,"{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = fifo->first;
    if (picture)
        picture_Hold(picture);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",1,,96,2,,void
123345,BLOCK,-1,,<empty>,9,,100,2,,void
123361,BLOCK,-1,,"{
    picture_t *picture;

    vlc_mutex_lock(&fifo->lock);

    picture = fifo->first;
    PictureFifoReset(fifo);

    picture_fifo_t tmp;
    PictureFifoReset(&tmp);

    while (picture) {
        picture_t *next = picture->p_next;

        picture->p_next = NULL;
        if (( flush_before && picture->date <= date) ||
            (!flush_before && picture->date >= date))
            PictureFifoPush(&tmp, picture);
        else
            PictureFifoPush(fifo, picture);
        picture = next;
    }
    vlc_mutex_unlock(&fifo->lock);

    while ((picture = PictureFifoPop(&tmp)) != NULL)
        picture_Release(picture);
}",1,,106,4,,void
123381,BLOCK,-1,,"{
        picture_t *next = picture->p_next;

        picture->p_next = NULL;
        if (( flush_before && picture->date <= date) ||
            (!flush_before && picture->date >= date))
            PictureFifoPush(&tmp, picture);
        else
            PictureFifoPush(fifo, picture);
        picture = next;
    }",21,,117,2,,void
123410,BLOCK,-1,,<empty>,13,,123,2,,void
123416,BLOCK,-1,,<empty>,13,,125,1,,void
123443,BLOCK,-1,,"{
    vlc_mutex_lock(&fifo->lock);
    for (picture_t *picture = fifo->first; picture != NULL;) {
        picture->date += delta;
        picture = picture->p_next;
    }
    vlc_mutex_unlock(&fifo->lock);
}",1,,134,3,,void
123450,BLOCK,-1,,<empty>,5,,136,1,,void
123460,BLOCK,4,,"{
        picture->date += delta;
        picture = picture->p_next;
    }",62,,136,4,,void
123480,BLOCK,-1,,"{
    picture_fifo_Flush(fifo, INT64_MAX, true);
    vlc_mutex_destroy(&fifo->lock);
    free(fifo);
}",1,,143,2,,void
123514,BLOCK,-1,,<empty>,1,,1,1,,ANY
123519,BLOCK,-1,,<empty>,,,,2,,<empty>
123524,BLOCK,-1,,<empty>,,,,2,,<empty>
123535,BLOCK,-1,,<empty>,,,,1,,<empty>
123541,BLOCK,-1,,"{
    if (atomic_fetch_sub(&pool->refs, 1) != 1)
        return;

    vlc_cond_destroy(&pool->wait);
    vlc_mutex_destroy(&pool->lock);
    aligned_free(pool);
}",1,,55,2,,void
123551,BLOCK,-1,,<empty>,9,,57,2,,void
123569,BLOCK,-1,,"{
    for (unsigned i = 0; i < pool->picture_count; i++)
        picture_Release(pool->picture[i]);
    picture_pool_Destroy(pool);
}",1,,65,2,,void
123571,BLOCK,-1,,<empty>,5,,66,1,,void
123595,BLOCK,-1,,"{
    picture_priv_t *priv = (picture_priv_t *)clone;
    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *pool = (void *)(sys & ~(POOL_MAX - 1));
    unsigned offset = sys & (POOL_MAX - 1);
    picture_t *picture = pool->picture[offset];

    free(clone);

    if (pool->pic_unlock != NULL)
        pool->pic_unlock(picture);
    picture_Release(picture);

    vlc_mutex_lock(&pool->lock);
    assert(!(pool->available & (1ULL << offset)));
    pool->available |= 1ULL << offset;
    vlc_cond_signal(&pool->wait);
    vlc_mutex_unlock(&pool->lock);

    picture_pool_Destroy(pool);
}",1,,72,2,,void
123622,BLOCK,1,,<empty>,,,,1,,void
123635,BLOCK,1,,<empty>,,,,1,,void
123657,BLOCK,-1,,<empty>,9,,82,2,,void
123703,BLOCK,-1,,"{
    picture_t *picture = pool->picture[offset];
    uintptr_t sys = ((uintptr_t)pool) + offset;
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_pool_ReleasePicture,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = (void *)sys;
        picture_Hold(picture);
    }
    return clone;
}",1,,96,3,,void
123724,BLOCK,1,,<empty>,9,,100,1,,void
123730,BLOCK,2,,<empty>,9,,101,2,,void
123735,BLOCK,-1,,<empty>,5,,104,1,,void
123747,BLOCK,4,,"{
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }",49,,104,4,,void
123808,BLOCK,-1,,"{
        ((picture_priv_t *)clone)->gc.opaque = (void *)sys;
        picture_Hold(picture);
    }",32,,111,2,,void
123828,BLOCK,-1,,"{
    if (unlikely(cfg->picture_count > POOL_MAX))
        return NULL;

    picture_pool_t *pool;
    size_t size = sizeof (*pool) + cfg->picture_count * sizeof (picture_t *);

    size += (-size) & (POOL_MAX - 1);
    pool = aligned_alloc(POOL_MAX, size);
    if (unlikely(pool == NULL))
        return NULL;

    pool->pic_lock   = cfg->lock;
    pool->pic_unlock = cfg->unlock;
    vlc_mutex_init(&pool->lock);
    vlc_cond_init(&pool->wait);
    if (cfg->picture_count == POOL_MAX)
        pool->available = ~0ULL;
    else
        pool->available = (1ULL << cfg->picture_count) - 1;
    atomic_init(&pool->refs,  1);
    pool->picture_count = cfg->picture_count;
    memcpy(pool->picture, cfg->picture,
           cfg->picture_count * sizeof (picture_t *));
    pool->canceled = false;
    return pool;
}",1,,119,2,,void
123836,BLOCK,1,,<empty>,,,,1,,void
123841,BLOCK,-1,,<empty>,9,,121,2,,void
123865,BLOCK,1,,<empty>,,,,1,,void
123875,BLOCK,1,,<empty>,,,,1,,void
123886,BLOCK,-1,,<empty>,9,,129,2,,void
123919,BLOCK,1,,<empty>,,,,1,,void
123924,BLOCK,-1,,<empty>,9,,136,2,,void
123932,BLOCK,-1,,<empty>,9,,138,1,,void
123982,BLOCK,-1,,"{
    picture_pool_configuration_t cfg = {
        .picture_count = count,
        .picture = tab,
    };

    return picture_pool_NewExtended(&cfg);
}",1,,148,3,,void
123987,BLOCK,1,,<empty>,9,,150,1,,void
123991,BLOCK,2,,<empty>,9,,151,2,,void
124004,BLOCK,-1,,"{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_NewFromFormat(fmt);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",1,,159,3,,void
124008,BLOCK,-1,,<empty>,5,,163,1,,void
124017,BLOCK,4,,"{
        picture[i] = picture_NewFromFormat(fmt);
        if (picture[i] == NULL)
            goto error;
    }",33,,163,4,,void
124030,BLOCK,-1,,<empty>,13,,166,2,,void
124041,BLOCK,-1,,<empty>,9,,171,2,,void
124062,BLOCK,-1,,"{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_pool_Get(master);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",1,,182,3,,void
124066,BLOCK,-1,,<empty>,5,,186,1,,void
124075,BLOCK,4,,"{
        picture[i] = picture_pool_Get(master);
        if (picture[i] == NULL)
            goto error;
    }",33,,186,4,,void
124088,BLOCK,-1,,<empty>,13,,189,2,,void
124099,BLOCK,-1,,<empty>,9,,194,2,,void
124120,BLOCK,-1,,"{
    if (i >= CHAR_BIT * sizeof (x))
        return 0;
    return ffsll(x & ~((1ULL << i) - 1));
}",1,,206,3,,void
124128,BLOCK,-1,,<empty>,9,,208,2,,void
124145,BLOCK,-1,,"{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    if (pool->canceled)
    {
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    for (unsigned i = ffsll(pool->available); i; i = fnsll(pool->available, i))
    {
        pool->available &= ~(1ULL << (i - 1));
        vlc_mutex_unlock(&pool->lock);

        picture_t *picture = pool->picture[i - 1];

        if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
            vlc_mutex_lock(&pool->lock);
            pool->available |= 1ULL << (i - 1);
            continue;
        }

        picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
        if (clone != NULL) {
            assert(clone->p_next == NULL);
            atomic_fetch_add(&pool->refs, 1);
        }
        return clone;
    }

    vlc_mutex_unlock(&pool->lock);
    return NULL;
}",1,,213,2,,void
124161,BLOCK,-1,,"{
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }",5,,218,2,,void
124170,BLOCK,-1,,<empty>,5,,223,1,,void
124186,BLOCK,4,,"{
        pool->available &= ~(1ULL << (i - 1));
        vlc_mutex_unlock(&pool->lock);

        picture_t *picture = pool->picture[i - 1];

        if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
            vlc_mutex_lock(&pool->lock);
            pool->available |= 1ULL << (i - 1);
            continue;
        }

        picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
        if (clone != NULL) {
            assert(clone->p_next == NULL);
            atomic_fetch_add(&pool->refs, 1);
        }
        return clone;
    }",5,,224,4,,void
124226,BLOCK,-1,,"{
            vlc_mutex_lock(&pool->lock);
            pool->available |= 1ULL << (i - 1);
            continue;
        }",79,,230,2,,void
124254,BLOCK,-1,,"{
            assert(clone->p_next == NULL);
            atomic_fetch_add(&pool->refs, 1);
        }",28,,237,2,,void
124280,BLOCK,-1,,"{
    unsigned i;

    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    while (pool->available == 0)
    {
        if (pool->canceled)
        {
            vlc_mutex_unlock(&pool->lock);
            return NULL;
        }
        vlc_cond_wait(&pool->wait, &pool->lock);
    }

    i = ffsll(pool->available);
    assert(i > 0);
    pool->available &= ~(1ULL << (i - 1));
    vlc_mutex_unlock(&pool->lock);

    picture_t *picture = pool->picture[i - 1];

    if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
        vlc_mutex_lock(&pool->lock);
        pool->available |= 1ULL << (i - 1);
        vlc_cond_signal(&pool->wait);
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
    if (clone != NULL) {
        assert(clone->p_next == NULL);
        atomic_fetch_add(&pool->refs, 1);
    }
    return clone;
}",1,,249,2,,void
124299,BLOCK,-1,,"{
        if (pool->canceled)
        {
            vlc_mutex_unlock(&pool->lock);
            return NULL;
        }
        vlc_cond_wait(&pool->wait, &pool->lock);
    }",5,,256,2,,void
124304,BLOCK,-1,,"{
            vlc_mutex_unlock(&pool->lock);
            return NULL;
        }",9,,258,2,,void
124370,BLOCK,-1,,"{
        vlc_mutex_lock(&pool->lock);
        pool->available |= 1ULL << (i - 1);
        vlc_cond_signal(&pool->wait);
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }",75,,272,2,,void
124409,BLOCK,-1,,"{
        assert(clone->p_next == NULL);
        atomic_fetch_add(&pool->refs, 1);
    }",24,,281,2,,void
124429,BLOCK,-1,,"{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    pool->canceled = canceled;
    if (canceled)
        vlc_cond_broadcast(&pool->wait);
    vlc_mutex_unlock(&pool->lock);
}",1,,289,3,,void
124448,BLOCK,-1,,<empty>,9,,295,2,,void
124464,BLOCK,-1,,"{
    picture_priv_t *priv = (picture_priv_t *)pic;

    while (priv->gc.destroy != picture_pool_ReleasePicture) {
        pic = priv->gc.opaque;
        priv = (picture_priv_t *)pic;
    }

    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *picpool = (void *)(sys & ~(POOL_MAX - 1));
    return pool == picpool;
}",1,,300,3,,void
124479,BLOCK,-1,,"{
        pic = priv->gc.opaque;
        priv = (picture_priv_t *)pic;
    }",61,,303,2,,void
124512,BLOCK,1,,<empty>,,,,1,,void
124526,BLOCK,-1,,"{
    return pool->picture_count;
}",1,,314,2,,void
124537,BLOCK,-1,,"{
    /* NOTE: So far, the pictures table cannot change after the pool is created
     * so there is no need to lock the pool mutex here. */
    for (unsigned i = 0; i < pool->picture_count; i++)
        cb(opaque, pool->picture[i]);
}",1,,320,4,,void
124539,BLOCK,-1,,<empty>,5,,323,1,,void
124574,BLOCK,-1,,<empty>,1,,1,1,,ANY
124579,BLOCK,-1,,"{
    vlc_probe_t *probe = vlc_custom_create (obj, sizeof(*probe), ""probe"");
    if (unlikely(probe == NULL))
    {
        *pcount = 0;
        return NULL;
    }
    probe->list = NULL;
    probe->count = 0;

    module_t *mod = module_need (probe, capability, NULL, false);
    if (mod != NULL)
    {
        msg_Warn (probe, ""probing halted"");
        module_unneed (probe, mod);
    }

    void *ret = probe->list;
    *pcount = probe->count;
    vlc_object_release (probe);
    return ret;
}",1,,33,4,,void
124586,BLOCK,1,,<empty>,,,,4,,void
124599,BLOCK,-1,,"{
        *pcount = 0;
        return NULL;
    }",5,,36,2,,void
124628,BLOCK,-1,,"{
        msg_Warn (probe, ""probing halted"");
        module_unneed (probe, mod);
    }",5,,45,2,,void
124663,BLOCK,-1,,<empty>,1,,1,1,,ANY
124669,BLOCK,-1,,<empty>,,,,1,,<empty>
124686,BLOCK,-1,,"{
    if (!rand48.init)
    {
        vlc_rand_bytes (rand48.subi, sizeof (rand48.subi));
        rand48.init = true;
#if 0 // short would be more than 16-bits ?
        for (unsigned i = 0; i < 3; i++)
            subi[i] &= 0xffff;
#endif
    }
}",1,,37,2,,void
124692,BLOCK,-1,,"{
        vlc_rand_bytes (rand48.subi, sizeof (rand48.subi));
        rand48.init = true;
#if 0 // short would be more than 16-bits ?
        for (unsigned i = 0; i < 3; i++)
            subi[i] &= 0xffff;
#endif
    }",5,,39,2,,void
124710,BLOCK,-1,,"{
    double ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = erand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",1,,59,2,,void
124735,BLOCK,-1,,"{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = nrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",1,,79,2,,void
124760,BLOCK,-1,,"{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = jrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",1,,99,2,,void
124803,BLOCK,-1,,<empty>,1,,1,1,,ANY
124814,BLOCK,-1,,"{
    free(p_item->psz_name);
    free(p_item->psz_type);
    free(p_item->psz_sout);
    free(p_item->psz_icon_uri);
    free(p_item->psz_demux_filter);
    free(p_item);
}",1,,47,2,,void
124847,BLOCK,-1,,"{
    assert(psz_uri != NULL);
    vlc_renderer_item_t *p_item = NULL;
    vlc_url_t url;
    vlc_UrlParse(&url, psz_uri);

    if (url.psz_protocol == NULL || url.psz_host == NULL)
        goto error;

    p_item = calloc(1, sizeof(vlc_renderer_item_t));
    if (unlikely(p_item == NULL))
        goto error;

    if ((p_item->psz_type = strdup(psz_type)) == NULL)
        goto error;

    if (psz_name != NULL)
        p_item->psz_name = strdup(psz_name);
    else if (asprintf(&p_item->psz_name, ""%s (%s)"", url.psz_protocol,
                      url.psz_host) == -1)
        p_item->psz_name = NULL;
    if (p_item->psz_name == NULL)
        goto error;

    if (asprintf(&p_item->psz_sout, ""%s{ip=%s,port=%d%s%s}"",
                 url.psz_protocol, url.psz_host, url.i_port,
                 psz_extra_sout != NULL ? "","" : """",
                 psz_extra_sout != NULL ? psz_extra_sout : """") == -1)
        goto error;

    if (psz_icon_uri && (p_item->psz_icon_uri = strdup(psz_icon_uri)) == ...",1,,61,8,,void
124873,BLOCK,-1,,<empty>,9,,68,2,,void
124886,BLOCK,-1,,<empty>,9,,72,2,,void
124897,BLOCK,-1,,<empty>,9,,75,2,,void
124903,BLOCK,-1,,<empty>,9,,78,2,,void
124911,BLOCK,-1,,<empty>,10,,79,1,,void
124928,BLOCK,-1,,<empty>,9,,81,2,,void
124940,BLOCK,-1,,<empty>,9,,83,2,,void
124973,BLOCK,-1,,<empty>,9,,89,2,,void
124986,BLOCK,-1,,<empty>,9,,92,2,,void
124999,BLOCK,-1,,<empty>,9,,95,2,,void
125025,BLOCK,-1,,<empty>,9,,105,2,,void
125034,BLOCK,-1,,"{
    assert(p_item != NULL);

    return p_item->psz_name;
}",1,,111,2,,void
125047,BLOCK,-1,,"{
    assert(p_item != NULL);

    return p_item->psz_type;
}",1,,119,2,,void
125060,BLOCK,-1,,"{
    assert(p_item != NULL);

    return p_item->psz_sout;
}",1,,127,2,,void
125073,BLOCK,-1,,"{
    assert(p_item != NULL);

    return p_item->psz_icon_uri;
}",1,,135,2,,void
125086,BLOCK,-1,,"{
    assert(p_item != NULL);

    return p_item->psz_demux_filter;
}",1,,143,2,,void
125099,BLOCK,-1,,"{
    assert(p_item != NULL);

    return p_item->i_flags;
}",1,,151,2,,void
125112,BLOCK,-1,,"{
    assert(p_item != NULL);

    atomic_fetch_add(&p_item->refs, 1);
    return p_item;
}",1,,159,2,,void
125129,BLOCK,-1,,"{
    assert(p_item != NULL);

    int refs = atomic_fetch_sub(&p_item->refs, 1);
    assert(refs != 0 );
    if( refs != 1 )
        return;
    item_free(p_item);
}",1,,168,2,,void
125151,BLOCK,-1,,<empty>,9,,174,2,,void
125164,BLOCK,-1,,"{
    struct vlc_rd_probe names = { strdup(psz_name), strdup(psz_longname) };

    if (unlikely(names.psz_name == NULL || names.psz_longname == NULL
                 || vlc_probe_add(probe, &names, sizeof(names))))
    {
        free(names.psz_name);
        free(names.psz_longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",1,,187,4,,void
125193,BLOCK,-1,,"{
        free(names.psz_name);
        free(names.psz_longname);
        return VLC_ENOMEM;
    }",5,,192,2,,void
125212,BLOCK,-1,,"{
    size_t i_count;
    struct vlc_rd_probe *p_tab = vlc_probe(p_obj, ""renderer probe"", &i_count);

    if (i_count == 0)
    {
        free(p_tab);
        return VLC_EGENERIC;
    }

    char **ppsz_names = vlc_alloc(i_count + 1, sizeof(char *));
    char **ppsz_longnames = vlc_alloc(i_count + 1, sizeof(char *));

    if (unlikely(ppsz_names == NULL || ppsz_longnames == NULL))
    {
        free(ppsz_names);
        free(ppsz_longnames);
        free(p_tab);
        return VLC_EGENERIC;
    }

    for (size_t i = 0; i < i_count; i++)
    {
        ppsz_names[i] = p_tab[i].psz_name;
        ppsz_longnames[i] = p_tab[i].psz_longname;
    }
    ppsz_names[i_count] = ppsz_longnames[i_count] = NULL;
    free(p_tab);
    *pppsz_names = ppsz_names;
    *pppsz_longnames = ppsz_longnames;
    return VLC_SUCCESS;
}",1,,204,4,,void
125226,BLOCK,-1,,"{
        free(p_tab);
        return VLC_EGENERIC;
    }",5,,209,2,,void
125258,BLOCK,-1,,"{
        free(ppsz_names);
        free(ppsz_longnames);
        free(p_tab);
        return VLC_EGENERIC;
    }",5,,218,2,,void
125268,BLOCK,-1,,<empty>,5,,225,1,,void
125278,BLOCK,4,,"{
        ppsz_names[i] = p_tab[i].psz_name;
        ppsz_longnames[i] = p_tab[i].psz_longname;
    }",5,,226,4,,void
125322,BLOCK,-1,,"{
    module_unneed(p_rd, p_rd->p_module);
    config_ChainDestroy(p_rd->p_cfg);
    free(p_rd->psz_name);
    vlc_object_release(p_rd);
}",1,,238,2,,void
125344,BLOCK,-1,,"{
    vlc_renderer_discovery_t *p_rd;

    p_rd = vlc_custom_create(p_obj, sizeof(*p_rd), ""renderer discovery"");
    if(!p_rd)
        return NULL;
    free(config_ChainCreate(&p_rd->psz_name, &p_rd->p_cfg, psz_name));

    p_rd->owner = *owner;
    p_rd->p_module = module_need(p_rd, ""renderer_discovery"",
                                 p_rd->psz_name, true);
    if (p_rd->p_module == NULL)
    {
        msg_Err(p_rd, ""no suitable renderer discovery module for '%s'"",
            psz_name);
        free(p_rd->psz_name);
        config_ChainDestroy(p_rd->p_cfg);
        vlc_object_release(p_rd);
        p_rd = NULL;
    }

    return p_rd;
}",1,,248,4,,void
125357,BLOCK,-1,,<empty>,9,,253,2,,void
125394,BLOCK,-1,,"{
        msg_Err(p_rd, ""no suitable renderer discovery module for '%s'"",
            psz_name);
        free(p_rd->psz_name);
        config_ChainDestroy(p_rd->p_cfg);
        vlc_object_release(p_rd);
        p_rd = NULL;
    }",5,,260,2,,void
125434,BLOCK,-1,,<empty>,1,,1,1,,ANY
125440,BLOCK,-1,,"{
    subpicture_t *p_subpic = calloc( 1, sizeof(*p_subpic) );
    if( !p_subpic )
        return NULL;

    p_subpic->i_order    = 0;
    p_subpic->b_absolute = true;
    p_subpic->b_fade     = false;
    p_subpic->b_subtitle = false;
    p_subpic->i_alpha    = 0xFF;
    p_subpic->p_region   = NULL;

    if( p_upd )
    {
        subpicture_private_t *p_private = malloc( sizeof(*p_private) );
        if( !p_private )
        {
            free( p_subpic );
            return NULL;
        }
        video_format_Init( &p_private->src, 0 );
        video_format_Init( &p_private->dst, 0 );

        p_subpic->updater   = *p_upd;
        p_subpic->p_private = p_private;
    }
    else
    {
        p_subpic->p_private = NULL;

        p_subpic->updater.pf_validate = NULL;
        p_subpic->updater.pf_update   = NULL;
        p_subpic->updater.pf_destroy  = NULL;
        p_subpic->updater.p_sys       = NULL;
    }
    return p_subpic;
}",1,,45,2,,void
125452,BLOCK,-1,,<empty>,9,,48,2,,void
125487,BLOCK,-1,,"{
        subpicture_private_t *p_private = malloc( sizeof(*p_private) );
        if( !p_private )
        {
            free( p_subpic );
            return NULL;
        }
        video_format_Init( &p_private->src, 0 );
        video_format_Init( &p_private->dst, 0 );

        p_subpic->updater   = *p_upd;
        p_subpic->p_private = p_private;
    }",5,,58,2,,void
125498,BLOCK,-1,,"{
            free( p_subpic );
            return NULL;
        }",9,,61,2,,void
125527,BLOCK,-1,,"{
        p_subpic->p_private = NULL;

        p_subpic->updater.pf_validate = NULL;
        p_subpic->updater.pf_update   = NULL;
        p_subpic->updater.pf_destroy  = NULL;
        p_subpic->updater.p_sys       = NULL;
    }",5,,72,1,,void
125567,BLOCK,-1,,"{
    subpicture_region_ChainDelete( p_subpic->p_region );
    p_subpic->p_region = NULL;

    if( p_subpic->updater.pf_destroy )
        p_subpic->updater.pf_destroy( p_subpic );

    if( p_subpic->p_private )
    {
        video_format_Clean( &p_subpic->p_private->src );
        video_format_Clean( &p_subpic->p_private->dst );
    }

    free( p_subpic->p_private );
    free( p_subpic );
}",1,,84,2,,void
125583,BLOCK,-1,,<empty>,9,,89,2,,void
125595,BLOCK,-1,,"{
        video_format_Clean( &p_subpic->p_private->src );
        video_format_Clean( &p_subpic->p_private->dst );
    }",5,,92,2,,void
125622,BLOCK,-1,,"{
    /* */
    video_format_t fmt_in = p_picture->format;

    /* */
    video_format_t fmt_out;
    fmt_out = fmt_in;
    fmt_out.i_chroma = i_chroma;

    /* */
    image_handler_t *p_image = image_HandlerCreate( p_obj );
    if( !p_image )
        return NULL;

    picture_t *p_pip = image_Convert( p_image, p_picture, &fmt_in, &fmt_out );

    image_HandlerDelete( p_image );

    if( !p_pip )
        return NULL;

    subpicture_t *p_subpic = subpicture_New( NULL );
    if( !p_subpic )
    {
         picture_Release( p_pip );
         return NULL;
    }

    p_subpic->i_original_picture_width  = fmt_out.i_visible_width;
    p_subpic->i_original_picture_height = fmt_out.i_visible_height;

    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 0;

    p_subpic->p_region = subpicture_region_New( &fmt_out );
    if( p_subpic->p_region )
    {
        picture_Release( p_subpic->p_region->p_picture );
        p_subpic->p_region->p_picture = p_pip;
    }
    else
    {
        picture_Release...",1,,103,4,,void
125646,BLOCK,-1,,<empty>,9,,115,2,,void
125664,BLOCK,-1,,<empty>,9,,122,2,,void
125675,BLOCK,-1,,"{
         picture_Release( p_pip );
         return NULL;
    }",5,,126,2,,void
125714,BLOCK,-1,,"{
        picture_Release( p_subpic->p_region->p_picture );
        p_subpic->p_region->p_picture = p_pip;
    }",5,,139,2,,void
125729,BLOCK,-1,,"{
        picture_Release( p_pip );
    }",5,,144,1,,void
125741,BLOCK,-1,,"{
    subpicture_updater_t *p_upd = &p_subpicture->updater;
    subpicture_private_t *p_private = p_subpicture->p_private;

    if( !p_upd->pf_validate )
        return;
    if( !p_upd->pf_validate( p_subpicture,
                          !video_format_IsSimilar( p_fmt_src,
                                                   &p_private->src ), p_fmt_src,
                          !video_format_IsSimilar( p_fmt_dst,
                                                   &p_private->dst ), p_fmt_dst,
                          i_ts ) )
        return;

    subpicture_region_ChainDelete( p_subpicture->p_region );
    p_subpicture->p_region = NULL;

    p_upd->pf_update( p_subpicture, p_fmt_src, p_fmt_dst, i_ts );

    video_format_Clean( &p_private->src );
    video_format_Clean( &p_private->dst );

    video_format_Copy( &p_private->src, p_fmt_src );
    video_format_Copy( &p_private->dst, p_fmt_dst );
}",1,,154,5,,void
125760,BLOCK,-1,,<empty>,9,,159,2,,void
125786,BLOCK,-1,,<empty>,9,,166,2,,void
125831,BLOCK,-1,,"{
    subpicture_region_private_t *p_private = malloc( sizeof(*p_private) );

    if( !p_private )
        return NULL;

    if ( video_format_Copy( &p_private->fmt, p_fmt ) != VLC_SUCCESS )
    {
        free( p_private );
        return NULL;
    }

    p_private->p_picture = NULL;
    return p_private;
}",1,,182,2,,void
125842,BLOCK,-1,,<empty>,9,,186,2,,void
125854,BLOCK,-1,,"{
        free( p_private );
        return NULL;
    }",5,,189,2,,void
125870,BLOCK,-1,,"{
    if( p_private->p_picture )
        picture_Release( p_private->p_picture );
    video_format_Clean( &p_private->fmt );
    free( p_private );
}",1,,199,2,,void
125875,BLOCK,-1,,<empty>,9,,201,2,,void
125891,BLOCK,-1,,"{
    subpicture_region_t *p_region = calloc( 1, sizeof(*p_region ) );
    if( !p_region )
        return NULL;

    if ( p_fmt->i_chroma == VLC_CODEC_YUVP )
    {
        video_format_Copy( &p_region->fmt, p_fmt );
        /* YUVP should have a palette */
        if( p_region->fmt.p_palette == NULL )
        {
            p_region->fmt.p_palette = calloc( 1, sizeof(*p_region->fmt.p_palette) );
            if( p_region->fmt.p_palette == NULL )
            {
                free( p_region );
                return NULL;
            }
        }
    }
    else
    {
        p_region->fmt = *p_fmt;
        p_region->fmt.p_palette = NULL;
    }

    p_region->i_alpha = 0xff;
    p_region->b_balanced_text = true;

    if( p_fmt->i_chroma == VLC_CODEC_TEXT )
        return p_region;

    p_region->p_picture = picture_NewFromFormat( p_fmt );
    if( !p_region->p_picture )
    {
        video_format_Clean( &p_region->fmt );
        free( p_region );
        return NULL;
    }

    return p_r...",1,,207,2,,void
125903,BLOCK,-1,,<empty>,9,,210,2,,void
125912,BLOCK,-1,,"{
        video_format_Copy( &p_region->fmt, p_fmt );
        /* YUVP should have a palette */
        if( p_region->fmt.p_palette == NULL )
        {
            p_region->fmt.p_palette = calloc( 1, sizeof(*p_region->fmt.p_palette) );
            if( p_region->fmt.p_palette == NULL )
            {
                free( p_region );
                return NULL;
            }
        }
    }",5,,213,2,,void
125927,BLOCK,-1,,"{
            p_region->fmt.p_palette = calloc( 1, sizeof(*p_region->fmt.p_palette) );
            if( p_region->fmt.p_palette == NULL )
            {
                free( p_region );
                return NULL;
            }
        }",9,,217,2,,void
125951,BLOCK,-1,,"{
                free( p_region );
                return NULL;
            }",13,,220,2,,void
125957,BLOCK,-1,,"{
        p_region->fmt = *p_fmt;
        p_region->fmt.p_palette = NULL;
    }",5,,227,1,,void
125987,BLOCK,-1,,<empty>,9,,236,2,,void
126001,BLOCK,-1,,"{
        video_format_Clean( &p_region->fmt );
        free( p_region );
        return NULL;
    }",5,,240,2,,void
126017,BLOCK,-1,,"{
    if( !p_region )
        return;

    if( p_region->p_private )
        subpicture_region_private_Delete( p_region->p_private );

    if( p_region->p_picture )
        picture_Release( p_region->p_picture );

    text_segment_ChainDelete( p_region->p_text );
    video_format_Clean( &p_region->fmt );
    free( p_region );
}",1,,250,2,,void
126021,BLOCK,-1,,<empty>,9,,252,2,,void
126027,BLOCK,-1,,<empty>,9,,255,2,,void
126036,BLOCK,-1,,<empty>,9,,258,2,,void
126056,BLOCK,-1,,"{
    while( p_head )
    {
        subpicture_region_t *p_next = p_head->p_next;

        subpicture_region_Delete( p_head );

        p_head = p_next;
    }
}",1,,266,2,,void
126059,BLOCK,-1,,"{
        subpicture_region_t *p_next = p_head->p_next;

        subpicture_region_Delete( p_head );

        p_head = p_next;
    }",5,,268,2,,void
126077,BLOCK,-1,,"{
    unsigned done = 0;

    assert(src && !src->b_fade && src->b_absolute);

    for (subpicture_region_t *r = src->p_region; r != NULL; r = r->p_next) {
        assert(r->p_picture && r->i_align == 0);
        if (filter_ConfigureBlend(blend, dst->format.i_width,
                                  dst->format.i_height,  &r->fmt)
         || filter_Blend(blend, dst, r->i_x, r->i_y, r->p_picture,
                         src->i_alpha * r->i_alpha / 255))
            msg_Err(blend, ""blending %4.4s to %4.4s failed"",
                    (char *)&blend->fmt_in.video.i_chroma,
                    (char *)&blend->fmt_out.video.i_chroma );
        else
            done++;
    }
    return done;
}",1,,281,4,,void
126094,BLOCK,-1,,<empty>,5,,286,1,,void
126109,BLOCK,4,,"{
        assert(r->p_picture && r->i_align == 0);
        if (filter_ConfigureBlend(blend, dst->format.i_width,
                                  dst->format.i_height,  &r->fmt)
         || filter_Blend(blend, dst, r->i_x, r->i_y, r->p_picture,
                         src->i_alpha * r->i_alpha / 255))
            msg_Err(blend, ""blending %4.4s to %4.4s failed"",
                    (char *)&blend->fmt_in.video.i_chroma,
                    (char *)&blend->fmt_out.video.i_chroma );
        else
            done++;
    }",76,,286,4,,void
126159,BLOCK,-1,,<empty>,13,,292,2,,void
126184,BLOCK,-1,,<empty>,13,,296,1,,void
126193,BLOCK,-1,,"{
    if (!p_region_src)
        return NULL;
    subpicture_region_t *p_region_dst = subpicture_region_New(&p_region_src->fmt);
    if (unlikely(!p_region_dst))
        return NULL;

    p_region_dst->i_x      = p_region_src->i_x;
    p_region_dst->i_y      = p_region_src->i_y;
    p_region_dst->i_align  = p_region_src->i_align;
    p_region_dst->i_alpha  = p_region_src->i_alpha;

    p_region_dst->p_text = text_segment_Copy( p_region_src->p_text );

    //Palette is already copied by subpicture_region_New, we just have to duplicate p_pixels
    for (int i = 0; i < p_region_src->p_picture->i_planes; i++)
        memcpy(p_region_dst->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].i_lines * p_region_src->p_picture->p[i].i_pitch);
    return p_region_dst;
}",1,,302,2,,void
126197,BLOCK,-1,,<empty>,9,,304,2,,void
126212,BLOCK,-1,,<empty>,9,,307,2,,void
126252,BLOCK,-1,,<empty>,5,,317,1,,void
126312,BLOCK,-1,,<empty>,1,,1,1,,ANY
126318,BLOCK,-1,,<empty>,,,,2,,<empty>
126323,BLOCK,-1,,<empty>,,,,2,,<empty>
126338,BLOCK,-1,,<empty>,1,,1,1,,ANY
126341,BLOCK,-1,,"{
    return text_style_Create( STYLE_FULLY_SET );
}",1,,35,2,,void
126349,BLOCK,-1,,"{
    text_style_t *p_style = calloc( 1, sizeof(*p_style) );
    if( !p_style )
        return NULL;

    if( i_defaults == STYLE_NO_DEFAULTS )
        return p_style;

    /* initialize to default text style (FIXME: by flag) */
    p_style->psz_fontname = NULL;
    p_style->psz_monofontname = NULL;
    p_style->i_features = STYLE_FULLY_SET;
    p_style->i_style_flags = STYLE_OUTLINE;
    p_style->f_font_relsize = STYLE_DEFAULT_REL_FONT_SIZE;
    p_style->i_font_size = STYLE_DEFAULT_FONT_SIZE;
    p_style->i_font_color = 0xffffff;
    p_style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_outline_color = 0x000000;
    p_style->i_outline_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_shadow_color = 0x808080;
    p_style->i_shadow_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_background_color = 0x000000;
    p_style->i_background_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_karaoke_background_color = 0xffffff;
    p_style->i_karaoke_background_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_out...",1,,40,2,,void
126361,BLOCK,-1,,<empty>,9,,43,2,,void
126368,BLOCK,-1,,<empty>,9,,46,2,,void
126479,BLOCK,-1,,"{
    if( !p_src )
        return p_dst;

    /* */
    *p_dst = *p_src;

    if( p_src->psz_fontname )
        p_dst->psz_fontname = strdup( p_src->psz_fontname );

    if( p_src->psz_monofontname )
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );

    return p_dst;
}",1,,74,3,,void
126483,BLOCK,-1,,<empty>,9,,76,2,,void
126495,BLOCK,-1,,<empty>,9,,82,2,,void
126508,BLOCK,-1,,<empty>,9,,85,2,,void
126525,BLOCK,-1,,"{
    if( p_src->psz_fontname && (!p_dst->psz_fontname || b_override) )
    {
        free( p_dst->psz_fontname );
        p_dst->psz_fontname = strdup( p_src->psz_fontname );
    }

    if( p_src->psz_monofontname && (!p_dst->psz_monofontname || b_override) )
    {
        free( p_dst->psz_monofontname );
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );
    }

    if( p_src->i_features != STYLE_NO_DEFAULTS )
    {
        MERGE(i_font_color,         STYLE_HAS_FONT_COLOR);
        MERGE(i_font_alpha,         STYLE_HAS_FONT_ALPHA);
        MERGE(i_outline_color,      STYLE_HAS_OUTLINE_COLOR);
        MERGE(i_outline_alpha,      STYLE_HAS_OUTLINE_ALPHA);
        MERGE(i_shadow_color,       STYLE_HAS_SHADOW_COLOR);
        MERGE(i_shadow_alpha,       STYLE_HAS_SHADOW_ALPHA);
        MERGE(i_background_color,   STYLE_HAS_BACKGROUND_COLOR);
        MERGE(i_background_alpha,   STYLE_HAS_BACKGROUND_ALPHA);
        MERGE(i_karaoke_background_color, STYLE_HAS_K_BACKGROUND...",1,,99,4,,void
126537,BLOCK,-1,,"{
        free( p_dst->psz_fontname );
        p_dst->psz_fontname = strdup( p_src->psz_fontname );
    }",5,,101,2,,void
126561,BLOCK,-1,,"{
        free( p_dst->psz_monofontname );
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );
    }",5,,107,2,,void
126580,BLOCK,-1,,"{
        MERGE(i_font_color,         STYLE_HAS_FONT_COLOR);
        MERGE(i_font_alpha,         STYLE_HAS_FONT_ALPHA);
        MERGE(i_outline_color,      STYLE_HAS_OUTLINE_COLOR);
        MERGE(i_outline_alpha,      STYLE_HAS_OUTLINE_ALPHA);
        MERGE(i_shadow_color,       STYLE_HAS_SHADOW_COLOR);
        MERGE(i_shadow_alpha,       STYLE_HAS_SHADOW_ALPHA);
        MERGE(i_background_color,   STYLE_HAS_BACKGROUND_COLOR);
        MERGE(i_background_alpha,   STYLE_HAS_BACKGROUND_ALPHA);
        MERGE(i_karaoke_background_color, STYLE_HAS_K_BACKGROUND_COLOR);
        MERGE(i_karaoke_background_alpha, STYLE_HAS_K_BACKGROUND_ALPHA);
        MERGE(e_wrapinfo,            STYLE_HAS_WRAP_INFO);
        p_dst->i_features |= p_src->i_features;
        p_dst->i_style_flags |= p_src->i_style_flags;
    }",5,,113,2,,void
126583,BLOCK,1,,<empty>,,,,2,,void
126599,BLOCK,-1,,<empty>,9,,114,2,,void
126609,BLOCK,1,,<empty>,,,,2,,void
126625,BLOCK,-1,,<empty>,9,,115,2,,void
126635,BLOCK,1,,<empty>,,,,2,,void
126651,BLOCK,-1,,<empty>,9,,116,2,,void
126661,BLOCK,1,,<empty>,,,,2,,void
126677,BLOCK,-1,,<empty>,9,,117,2,,void
126687,BLOCK,1,,<empty>,,,,2,,void
126703,BLOCK,-1,,<empty>,9,,118,2,,void
126713,BLOCK,1,,<empty>,,,,2,,void
126729,BLOCK,-1,,<empty>,9,,119,2,,void
126739,BLOCK,1,,<empty>,,,,2,,void
126755,BLOCK,-1,,<empty>,9,,120,2,,void
126765,BLOCK,1,,<empty>,,,,2,,void
126781,BLOCK,-1,,<empty>,9,,121,2,,void
126791,BLOCK,1,,<empty>,,,,2,,void
126807,BLOCK,-1,,<empty>,9,,122,2,,void
126817,BLOCK,1,,<empty>,,,,2,,void
126833,BLOCK,-1,,<empty>,9,,123,2,,void
126843,BLOCK,1,,<empty>,,,,2,,void
126859,BLOCK,-1,,<empty>,9,,124,2,,void
126882,BLOCK,1,,<empty>,,,,1,,void
126897,BLOCK,-1,,<empty>,5,,129,2,,void
126906,BLOCK,1,,<empty>,,,,1,,void
126921,BLOCK,-1,,<empty>,5,,130,2,,void
126930,BLOCK,1,,<empty>,,,,1,,void
126945,BLOCK,-1,,<empty>,5,,131,2,,void
126954,BLOCK,1,,<empty>,,,,1,,void
126969,BLOCK,-1,,<empty>,5,,132,2,,void
126978,BLOCK,1,,<empty>,,,,1,,void
126993,BLOCK,-1,,<empty>,5,,133,2,,void
127005,BLOCK,-1,,"{
    if( !p_src )
        return NULL;

    text_style_t *p_dst = calloc( 1, sizeof(*p_dst) );
    if( p_dst )
        text_style_Copy( p_dst, p_src );
    return p_dst;
}",1,,140,2,,void
127009,BLOCK,-1,,<empty>,9,,142,2,,void
127022,BLOCK,-1,,<empty>,9,,146,2,,void
127032,BLOCK,-1,,"{
    if( p_style )
        free( p_style->psz_fontname );
    if( p_style )
        free( p_style->psz_monofontname );
    free( p_style );
}",1,,151,2,,void
127035,BLOCK,-1,,<empty>,9,,153,2,,void
127042,BLOCK,-1,,<empty>,9,,155,2,,void
127053,BLOCK,-1,,"{
    text_segment_t* segment = calloc( 1, sizeof(*segment) );
    if( !segment )
        return NULL;

    if ( psz_text )
        segment->psz_text = strdup( psz_text );

    return segment;
}",1,,160,2,,void
127065,BLOCK,-1,,<empty>,9,,163,2,,void
127070,BLOCK,-1,,<empty>,9,,166,2,,void
127083,BLOCK,-1,,"{
    if ( !p_style )
        return NULL; //FIXME: Allow this, even if it is an alias to text_segment_New( NULL ) ?
    text_segment_t* p_segment = text_segment_New( NULL );
    if ( unlikely( !p_segment ) )
        return NULL;
    p_segment->style = text_style_Duplicate( p_style );
    if ( unlikely( !p_segment->style ) )
    {
        text_segment_Delete( p_segment );
        return NULL;
    }
    return p_segment;
}",1,,172,2,,void
127087,BLOCK,-1,,<empty>,9,,174,2,,void
127099,BLOCK,-1,,<empty>,9,,177,2,,void
127114,BLOCK,-1,,"{
        text_segment_Delete( p_segment );
        return NULL;
    }",5,,180,2,,void
127125,BLOCK,-1,,"{
    if ( segment != NULL )
    {
        free( segment->psz_text );
        text_style_Delete( segment->style );
        free( segment );
    }
}",1,,188,2,,void
127130,BLOCK,-1,,"{
        free( segment->psz_text );
        text_style_Delete( segment->style );
        free( segment );
    }",5,,190,2,,void
127145,BLOCK,-1,,"{
    while( segment != NULL )
    {
        text_segment_t *p_next = segment->p_next;

        text_segment_Delete( segment );

        segment = p_next;
    }
}",1,,198,2,,void
127150,BLOCK,-1,,"{
        text_segment_t *p_next = segment->p_next;

        text_segment_Delete( segment );

        segment = p_next;
    }",5,,200,2,,void
127166,BLOCK,-1,,"{
    text_segment_t *p_dst = NULL, *p_dst0 = NULL;

    while( p_src ) {
        text_segment_t *p_new = text_segment_New( p_src->psz_text );

        if( unlikely( !p_new ) )
            break;

        p_new->style = text_style_Duplicate( p_src->style );

        if( p_dst == NULL )
        {
            p_dst = p_dst0 = p_new;
        }
        else
        {
            p_dst->p_next = p_new;
            p_dst = p_dst->p_next;
        }

        p_src = p_src->p_next;
    }

    return p_dst0;
}",1,,210,2,,void
127177,BLOCK,-1,,"{
        text_segment_t *p_new = text_segment_New( p_src->psz_text );

        if( unlikely( !p_new ) )
            break;

        p_new->style = text_style_Duplicate( p_src->style );

        if( p_dst == NULL )
        {
            p_dst = p_dst0 = p_new;
        }
        else
        {
            p_dst->p_next = p_new;
            p_dst = p_dst->p_next;
        }

        p_src = p_src->p_next;
    }",20,,213,2,,void
127189,BLOCK,-1,,<empty>,13,,217,2,,void
127203,BLOCK,-1,,"{
            p_dst = p_dst0 = p_new;
        }",9,,222,2,,void
127210,BLOCK,-1,,"{
            p_dst->p_next = p_new;
            p_dst = p_dst->p_next;
        }",9,,226,1,,void
127233,BLOCK,-1,,"{
    unsigned int color = 0;
    char* psz_end;
    bool b_ret = false;

    const char *psz_hex = (*psz_value == '#') ? psz_value + 1 : psz_value;

    if( psz_hex != psz_value ||
        (*psz_hex >= '0' && *psz_hex <= '9') ||
        (*psz_hex >= 'A' && *psz_hex <= 'F') )
    {
        uint32_t i_value = strtol( psz_hex, &psz_end, 16 );
        if( *psz_end == 0 || isspace( *psz_end ) )
        {
            switch( psz_end - psz_hex )
            {
                case 8:
                    color = (i_value << 24) | (i_value >> 8);
                    b_ret = true;
                    break;
                case 6:
                    color = i_value | 0xFF000000;
                    b_ret = true;
                    break;
                default:
                    break;
            }
        }
    }

    if( !b_ret && psz_hex == psz_value &&
        !strncmp( ""rgb"", psz_value, 3 ) )
    {
        unsigned r,g,b,a = 0xFF;
        if( psz_value[3] == 'a' )
            b_ret...",1,,238,3,,void
127279,BLOCK,-1,,"{
        uint32_t i_value = strtol( psz_hex, &psz_end, 16 );
        if( *psz_end == 0 || isspace( *psz_end ) )
        {
            switch( psz_end - psz_hex )
            {
                case 8:
                    color = (i_value << 24) | (i_value >> 8);
                    b_ret = true;
                    break;
                case 6:
                    color = i_value | 0xFF000000;
                    b_ret = true;
                    break;
                default:
                    break;
            }
        }
    }",5,,248,2,,void
127297,BLOCK,-1,,"{
            switch( psz_end - psz_hex )
            {
                case 8:
                    color = (i_value << 24) | (i_value >> 8);
                    b_ret = true;
                    break;
                case 6:
                    color = i_value | 0xFF000000;
                    b_ret = true;
                    break;
                default:
                    break;
            }
        }",9,,251,2,,void
127302,BLOCK,-1,,"{
                case 8:
                    color = (i_value << 24) | (i_value >> 8);
                    b_ret = true;
                    break;
                case 6:
                    color = i_value | 0xFF000000;
                    b_ret = true;
                    break;
                default:
                    break;
            }",13,,253,2,,void
127344,BLOCK,-1,,"{
        unsigned r,g,b,a = 0xFF;
        if( psz_value[3] == 'a' )
            b_ret = (sscanf( psz_value, ""rgba(%3u,%3u,%3u,%3u)"", &r, &g, &b, &a ) == 4);
        else
            b_ret = (sscanf( psz_value, ""rgb(%3u,%3u,%3u)"", &r, &g, &b ) == 3);
        color = (a << 24) | (r << 16) | (g << 8) | b;
    }",5,,270,2,,void
127358,BLOCK,-1,,<empty>,13,,273,2,,void
127375,BLOCK,-1,,<empty>,13,,275,1,,void
127411,BLOCK,-1,,"{
        for( int i = 0; p_html_colors[i].psz_name != NULL; i++ )
        {
            if( !strcasecmp( psz_value, p_html_colors[i].psz_name ) )
            {
                // Assume opaque color since the table doesn't specify an alpha
                color = p_html_colors[i].i_value | 0xFF000000;
                b_ret = true;
                break;
            }
        }
    }",5,,280,2,,void
127413,BLOCK,-1,,<empty>,9,,281,1,,void
127427,BLOCK,4,,"{
            if( !strcasecmp( psz_value, p_html_colors[i].psz_name ) )
            {
                // Assume opaque color since the table doesn't specify an alpha
                color = p_html_colors[i].i_value | 0xFF000000;
                b_ret = true;
                break;
            }
        }",9,,282,4,,void
127437,BLOCK,-1,,"{
                // Assume opaque color since the table doesn't specify an alpha
                color = p_html_colors[i].i_value | 0xFF000000;
                b_ret = true;
                break;
            }",13,,284,2,,void
127455,BLOCK,-1,,<empty>,9,,294,2,,void
127488,BLOCK,-1,,<empty>,1,,1,1,,ANY
127492,BLOCK,-1,,"{
    static vlc_mutex_t locks[] = {
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
#ifdef _WIN32
        VLC_STATIC_MUTEX, // For MTA holder
#endif
    };
    static_assert (VLC_MAX_MUTEX == (sizeof (locks) / sizeof (locks[0])),
                   ""Wrong number of global mutexes"");
    assert (n < (sizeof (locks) / sizeof (locks[0])));

    vlc_mutex_t *lock = locks + n;
    if (acquire)
        vlc_mutex_lock (lock);
    else
        vlc_mutex_unlock (lock);
}",1,,33,3,,void
127531,BLOCK,-1,,<empty>,9,,50,2,,void
127535,BLOCK,-1,,<empty>,9,,52,1,,void
127574,BLOCK,-1,,<empty>,1,,1,1,,ANY
127577,BLOCK,-1,,"{
    update_t *p_update;
    assert( p_this );

    p_update = (update_t *)malloc( sizeof( update_t ) );
    if( !p_update ) return NULL;

    vlc_mutex_init( &p_update->lock );

    p_update->p_libvlc = p_this->obj.libvlc;

    p_update->release.psz_url = NULL;
    p_update->release.psz_desc = NULL;

    p_update->p_download = NULL;
    p_update->p_check = NULL;

    p_update->p_pkey = NULL;
    vlc_gcrypt_init();

    return p_update;
}",1,,105,2,,void
127591,BLOCK,-1,,<empty>,21,,110,2,,void
127644,BLOCK,-1,,"{
    assert( p_update );

    if( p_update->p_check )
    {
        vlc_join( p_update->p_check->thread, NULL );
        free( p_update->p_check );
    }

    if( p_update->p_download )
    {
        atomic_store( &p_update->p_download->aborted, true );
        vlc_join( p_update->p_download->thread, NULL );
        vlc_object_release( p_update->p_download );
    }

    vlc_mutex_destroy( &p_update->lock );

    free( p_update->release.psz_url );
    free( p_update->release.psz_desc );
    free( p_update->p_pkey );

    free( p_update );
}",1,,135,2,,void
127651,BLOCK,-1,,"{
        vlc_join( p_update->p_check->thread, NULL );
        free( p_update->p_check );
    }",5,,139,2,,void
127667,BLOCK,-1,,"{
        atomic_store( &p_update->p_download->aborted, true );
        vlc_join( p_update->p_download->thread, NULL );
        vlc_object_release( p_update->p_download );
    }",5,,145,2,,void
127714,BLOCK,-1,,"{
    p_update->release.i_major = 0;
    p_update->release.i_minor = 0;
    p_update->release.i_revision = 0;

    FREENULL( p_update->release.psz_url );
    FREENULL( p_update->release.psz_desc );
}",1,,167,2,,void
127752,BLOCK,-1,,"{
    stream_t *p_stream = NULL;
    char *psz_version_line = NULL;
    char *psz_update_data = NULL;

    p_stream = vlc_stream_NewURL( p_update->p_libvlc, UPDATE_VLC_STATUS_URL );
    if( !p_stream )
    {
        msg_Err( p_update->p_libvlc, ""Failed to open %s for reading"",
                 UPDATE_VLC_STATUS_URL );
        goto error;
    }

    uint64_t i_read;
    if( vlc_stream_GetSize( p_stream, &i_read ) || i_read >= UINT16_MAX )
    {
        msg_Err(p_update->p_libvlc, ""Status file too large"");
        goto error;
    }

    psz_update_data = malloc( i_read + 1 ); /* terminating '\0' */
    if( !psz_update_data )
        goto error;

    if( vlc_stream_Read( p_stream, psz_update_data,
                         i_read ) != (ssize_t)i_read )
    {
        msg_Err( p_update->p_libvlc, ""Couldn't download update file %s"",
                UPDATE_VLC_STATUS_URL );
        goto error;
    }
    psz_update_data[i_read] = '\0';

    vlc_stream_Delete( p_stream );
    p_stream = NULL;...",1,,184,2,,void
127772,BLOCK,1,,<empty>,,,,1,,void
127777,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc, ""Failed to open %s for reading"",
                 UPDATE_VLC_STATUS_URL );
        goto error;
    }",5,,191,2,,void
127784,BLOCK,1,,<empty>,,,,1,,void
127797,BLOCK,-1,,"{
        msg_Err(p_update->p_libvlc, ""Status file too large"");
        goto error;
    }",5,,199,2,,void
127813,BLOCK,-1,,<empty>,9,,206,2,,void
127824,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc, ""Couldn't download update file %s"",
                UPDATE_VLC_STATUS_URL );
        goto error;
    }",5,,210,2,,void
127831,BLOCK,1,,<empty>,,,,1,,void
127877,BLOCK,-1,,<empty>,9,,228,2,,void
127933,BLOCK,-1,,"{
            msg_Err( p_update->p_libvlc, ""Update version false formatted"" );
            goto error;
    }",5,,237,2,,void
127949,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc, ""Update file %s is corrupted: URL missing"",
                 UPDATE_VLC_STATUS_URL );

        goto error;
    }",5,,245,2,,void
127956,BLOCK,1,,<empty>,,,,1,,void
127971,BLOCK,-1,,<empty>,9,,253,2,,void
128013,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc,
                ""Update file %s is corrupted: description missing"",
                UPDATE_VLC_STATUS_URL );
        goto error;
    }",5,,264,2,,void
128020,BLOCK,1,,<empty>,,,,1,,void
128035,BLOCK,-1,,<empty>,9,,272,2,,void
128065,BLOCK,1,,<empty>,,,,1,,void
128068,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc, ""Couldn't download signature of status file"" );
        goto error;
    }",5,,281,2,,void
128087,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc, ""Invalid signature type"" );
        goto error;
    }",5,,287,2,,void
128108,BLOCK,-1,,<empty>,9,,294,2,,void
128121,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc, ""Couldn't parse embedded public key, something went really wrong..."" );
        FREENULL( p_update->p_pkey );
        goto error;
    }",5,,298,2,,void
128153,BLOCK,-1,,"{
        msg_Dbg( p_update->p_libvlc, ""Need to download the GPG key"" );
        public_key_t *p_new_pkey = download_key(
                VLC_OBJECT(p_update->p_libvlc),
                sign.issuer_longid, videolan_public_key_longid );
        if( !p_new_pkey )
        {
            msg_Err( p_update->p_libvlc, ""Couldn't download GPG key"" );
            FREENULL( p_update->p_pkey );
            goto error;
        }

        uint8_t *p_hash = hash_from_public_key( p_new_pkey );
        if( !p_hash )
        {
            msg_Err( p_update->p_libvlc, ""Failed to hash signature"" );
            free( p_new_pkey );
            FREENULL( p_update->p_pkey );
            goto error;
        }

        if( verify_signature( &p_new_pkey->sig,
                    &p_update->p_pkey->key, p_hash ) == VLC_SUCCESS )
        {
            free( p_hash );
            msg_Info( p_update->p_libvlc, ""Key authenticated"" );
            free( p_update->p_pkey );
            p_update->p_pkey = p_new_pkey;
...",5,,307,2,,void
128174,BLOCK,-1,,"{
            msg_Err( p_update->p_libvlc, ""Couldn't download GPG key"" );
            FREENULL( p_update->p_pkey );
            goto error;
        }",9,,313,2,,void
128193,BLOCK,-1,,"{
            msg_Err( p_update->p_libvlc, ""Failed to hash signature"" );
            free( p_new_pkey );
            FREENULL( p_update->p_pkey );
            goto error;
        }",9,,321,2,,void
128221,BLOCK,-1,,"{
            free( p_hash );
            msg_Info( p_update->p_libvlc, ""Key authenticated"" );
            free( p_update->p_pkey );
            p_update->p_pkey = p_new_pkey;
        }",9,,330,2,,void
128239,BLOCK,-1,,"{
            free( p_hash );
            msg_Err( p_update->p_libvlc, ""Key signature invalid !"" );
            goto error;
        }",9,,337,1,,void
128258,BLOCK,-1,,"{
        msg_Warn( p_update->p_libvlc, ""Can't compute hash for status file"" );
        goto error;
    }",5,,346,2,,void
128266,BLOCK,-1,,<empty>,10,,351,1,,void
128287,BLOCK,-1,,"{
        msg_Warn( p_update->p_libvlc, ""Bad hash for status file"" );
        free( p_hash );
        goto error;
    }",5,,353,2,,void
128297,BLOCK,-1,,<empty>,10,,359,1,,void
128311,BLOCK,-1,,"{
        msg_Err( p_update->p_libvlc, ""BAD SIGNATURE for status file"" );
        free( p_hash );
        goto error;
    }",5,,361,2,,void
128321,BLOCK,-1,,"{
        msg_Info( p_update->p_libvlc, ""Status file authenticated"" );
        free( p_hash );
        free( psz_version_line );
        free( psz_update_data );
        return true;
    }",5,,368,1,,void
128338,BLOCK,-1,,<empty>,9,,378,2,,void
128351,BLOCK,-1,,<empty>,,,,2,,<empty>
128358,BLOCK,-1,,"{
    assert( p_update );

    // If the object already exist, destroy it
    if( p_update->p_check )
    {
        vlc_join( p_update->p_check->thread, NULL );
        free( p_update->p_check );
    }

    update_check_thread_t *p_uct = calloc( 1, sizeof( *p_uct ) );
    if( !p_uct ) return;

    p_uct->p_update = p_update;
    p_update->p_check = p_uct;
    p_uct->pf_callback = pf_callback;
    p_uct->p_data = p_data;

    vlc_clone( &p_uct->thread, update_CheckReal, p_uct, VLC_THREAD_PRIORITY_LOW );
}",1,,395,4,,void
128365,BLOCK,-1,,"{
        vlc_join( p_update->p_check->thread, NULL );
        free( p_update->p_check );
    }",5,,400,2,,void
128388,BLOCK,-1,,<empty>,18,,406,2,,void
128422,BLOCK,-1,,"{
    update_check_thread_t *p_uct = (update_check_thread_t *)obj;
    bool b_ret;
    int canc;

    canc = vlc_savecancel ();
    vlc_mutex_lock( &p_uct->p_update->lock );

    EmptyRelease( p_uct->p_update );
    b_ret = GetUpdateFile( p_uct->p_update );
    vlc_mutex_unlock( &p_uct->p_update->lock );

    if( p_uct->pf_callback )
        (p_uct->pf_callback)( p_uct->p_data, b_ret );

    vlc_restorecancel (canc);
    return NULL;
}",1,,417,2,,void
128462,BLOCK,-1,,<empty>,9,,430,2,,void
128479,BLOCK,-1,,"{
    assert( p_update );

    static const int current[4] = {
        PACKAGE_VERSION_MAJOR,
        PACKAGE_VERSION_MINOR,
        PACKAGE_VERSION_REVISION,
        PACKAGE_VERSION_EXTRA
    };
    const int latest[4] = {
        p_update->release.i_major,
        p_update->release.i_minor,
        p_update->release.i_revision,
        p_update->release.i_extra
    };

    for (unsigned i = 0; i < sizeof latest / sizeof *latest; i++) {
        /* there is a new version available */
        if (latest[i] > current[i])
            return true;

        /* current version is more recent than the latest version ?! */
        if (latest[i] < current[i])
            return false;
    }

    /* current version is not a release, it's a -git or -rc version */
    if (*PACKAGE_VERSION_DEV)
        return true;

    /* current version is latest version */
    return false;
}",1,,437,2,,void
128515,BLOCK,-1,,<empty>,5,,453,1,,void
128530,BLOCK,4,,"{
        /* there is a new version available */
        if (latest[i] > current[i])
            return true;

        /* current version is more recent than the latest version ?! */
        if (latest[i] < current[i])
            return false;
    }",67,,453,4,,void
128539,BLOCK,-1,,<empty>,13,,456,2,,void
128550,BLOCK,-1,,<empty>,13,,460,2,,void
128556,BLOCK,-1,,<empty>,9,,465,2,,void
128565,BLOCK,-1,,"{
    char *psz_tmp = NULL;
    int i_retval = 0;
    if( l_size >> 30 )
        i_retval = asprintf( &psz_tmp, _(""%.1f GiB""), (float)l_size/(1<<30) );
    else if( l_size >> 20 )
        i_retval = asprintf( &psz_tmp, _(""%.1f MiB""), (float)l_size/(1<<20) );
    else if( l_size >> 10 )
        i_retval = asprintf( &psz_tmp, _(""%.1f KiB""), (float)l_size/(1<<10) );
    else
        i_retval = asprintf( &psz_tmp, _(""%""PRIu64"" B""), l_size );

    return i_retval == -1 ? NULL : psz_tmp;
}",1,,478,2,,void
128587,BLOCK,-1,,<empty>,,,,2,,<empty>
128593,BLOCK,-1,,"{
    assert( p_update );

    // If the object already exist, destroy it
    if( p_update->p_download )
    {
        atomic_store( &p_update->p_download->aborted, true );
        vlc_join( p_update->p_download->thread, NULL );
        vlc_object_release( p_update->p_download );
    }

    update_download_thread_t *p_udt =
        vlc_custom_create( p_update->p_libvlc, sizeof( *p_udt ),
                           ""update download"" );
    if( !p_udt )
        return;

    p_udt->p_update = p_update;
    p_update->p_download = p_udt;
    p_udt->psz_destdir = psz_destdir ? strdup( psz_destdir ) : NULL;

    atomic_store(&p_udt->aborted, false);
    vlc_clone( &p_udt->thread, update_DownloadReal, p_udt, VLC_THREAD_PRIORITY_LOW );
}",1,,503,3,,void
128600,BLOCK,-1,,"{
        atomic_store( &p_update->p_download->aborted, true );
        vlc_join( p_update->p_download->thread, NULL );
        vlc_object_release( p_update->p_download );
    }",5,,508,2,,void
128627,BLOCK,1,,<empty>,,,,3,,void
128640,BLOCK,-1,,<empty>,9,,518,2,,void
128679,BLOCK,-1,,"{
    update_download_thread_t *p_udt = (update_download_thread_t *)obj;
    uint64_t l_size;
    uint64_t l_downloaded = 0;
    float f_progress;
    char *psz_downloaded = NULL;
    char *psz_size = NULL;
    char *psz_destfile = NULL;
    char *psz_tmpdestfile = NULL;

    FILE *p_file = NULL;
    stream_t *p_stream = NULL;
    void* p_buffer = NULL;
    int i_read;
    int canc;

    vlc_dialog_id *p_dialog_id = NULL;
    update_t *p_update = p_udt->p_update;
    char *psz_destdir = p_udt->psz_destdir;

    msg_Dbg( p_udt, ""Opening Stream '%s'"", p_update->release.psz_url );
    canc = vlc_savecancel ();

    /* Open the stream */
    p_stream = vlc_stream_NewURL( p_udt, p_update->release.psz_url );
    if( !p_stream )
    {
        msg_Err( p_udt, ""Failed to open %s for reading"", p_update->release.psz_url );
        goto end;
    }

    /* Get the stream size */
    if( vlc_stream_GetSize( p_stream, &l_size ) || l_size == 0 )
        goto end;

    /* Get the file name and open ...",1,,529,2,,void
128761,BLOCK,-1,,"{
        msg_Err( p_udt, ""Failed to open %s for reading"", p_update->release.psz_url );
        goto end;
    }",5,,555,2,,void
128780,BLOCK,-1,,<empty>,9,,562,2,,void
128794,BLOCK,-1,,"{
        msg_Err( p_udt, ""The URL %s is badly formatted"",
                 p_update->release.psz_url );
        goto end;
    }",5,,567,2,,void
128816,BLOCK,-1,,<empty>,9,,574,2,,void
128826,BLOCK,-1,,"{
        msg_Err( p_udt, ""Failed to open %s for writing"", psz_destfile );
        dialog_FatalWait( p_udt, _(""Saving file failed""),
            _(""Failed to open \""%s\"" for writing""),
             psz_destfile );
        goto end;
    }",5,,578,2,,void
128834,BLOCK,1,,<empty>,,,,5,,void
128860,BLOCK,-1,,<empty>,9,,589,2,,void
128897,BLOCK,-1,,<empty>,9,,603,2,,void
128920,BLOCK,-1,,"{
        if( fwrite( p_buffer, i_read, 1, p_file ) < 1 )
        {
            msg_Err( p_udt, ""Failed to write into %s"", psz_destfile );
            break;
        }

        l_downloaded += i_read;
        psz_downloaded = size_str( l_downloaded );
        f_progress = (float)l_downloaded/(float)l_size;

        vlc_dialog_update_progress_text( p_udt, p_dialog_id, f_progress,
                                         ""%s\nDownloading... %s/%s - %.1f%% done"",
                                         p_update->release.psz_url,
                                         psz_downloaded, psz_size,
                                         f_progress*100 );
        free( psz_downloaded );
    }",5,,608,2,,void
128929,BLOCK,-1,,"{
            msg_Err( p_udt, ""Failed to write into %s"", psz_destfile );
            break;
        }",9,,610,2,,void
128985,BLOCK,-1,,"{
        vlc_dialog_release( p_udt, p_dialog_id );
        p_dialog_id = NULL;
    }",5,,633,2,,void
128993,BLOCK,-1,,"{
        vlc_unlink( psz_destfile );
        goto end;
    }",5,,638,1,,void
129011,BLOCK,-1,,"{
        vlc_unlink( psz_destfile );

        dialog_FatalWait( p_udt, _(""File could not be verified""),
            _(""It was not possible to download a cryptographic signature for ""
              ""the downloaded file \""%s\"". Thus, it was deleted.""),
            psz_destfile );
        msg_Err( p_udt, ""Couldn't download signature of downloaded file"" );
        goto end;
    }",5,,646,2,,void
129017,BLOCK,1,,<empty>,,,,5,,void
129044,BLOCK,-1,,"{
        vlc_unlink( psz_destfile );
        msg_Err( p_udt, ""Invalid signature issuer"" );
        dialog_FatalWait( p_udt, _(""Invalid signature""),
            _(""The cryptographic signature for the downloaded file \""%s\"" was ""
              ""invalid and could not be used to securely verify it. Thus, the ""
              ""file was deleted.""),
            psz_destfile );
        goto end;
    }",5,,658,2,,void
129053,BLOCK,1,,<empty>,,,,5,,void
129072,BLOCK,-1,,"{
        vlc_unlink( psz_destfile );
        msg_Err( p_udt, ""Invalid signature type"" );
        dialog_FatalWait( p_udt, _(""Invalid signature""),
            _(""The cryptographic signature for the downloaded file \""%s\"" was ""
              ""invalid and could not be used to securely verify it. Thus, the ""
              ""file was deleted.""),
            psz_destfile );
        goto end;
    }",5,,670,2,,void
129081,BLOCK,1,,<empty>,,,,5,,void
129104,BLOCK,-1,,"{
        msg_Err( p_udt, ""Unable to hash %s"", psz_destfile );
        vlc_unlink( psz_destfile );
        dialog_FatalWait( p_udt, _(""File not verifiable""),
            _(""It was not possible to securely verify the downloaded file""
              "" \""%s\"". Thus, it was deleted.""),
            psz_destfile );

        goto end;
    }",5,,683,2,,void
129114,BLOCK,1,,<empty>,,,,5,,void
129147,BLOCK,-1,,"{
        vlc_unlink( psz_destfile );
        dialog_FatalWait( p_udt, _(""File corrupted""),
            _(""Downloaded file \""%s\"" was corrupted. Thus, it was deleted.""),
             psz_destfile );
        msg_Err( p_udt, ""Bad hash for %s"", psz_destfile );
        free( p_hash );
        goto end;
    }",5,,696,2,,void
129153,BLOCK,1,,<empty>,,,,5,,void
129185,BLOCK,-1,,"{
        vlc_unlink( psz_destfile );
        dialog_FatalWait( p_udt, _(""File corrupted""),
            _(""Downloaded file \""%s\"" was corrupted. Thus, it was deleted.""),
             psz_destfile );
        msg_Err( p_udt, ""BAD SIGNATURE for %s"", psz_destfile );
        free( p_hash );
        goto end;
    }",5,,708,2,,void
129191,BLOCK,1,,<empty>,,,,5,,void
129221,BLOCK,-1,,<empty>,9,,742,2,,void
129227,BLOCK,-1,,<empty>,9,,744,2,,void
129232,BLOCK,-1,,<empty>,9,,746,2,,void
129251,BLOCK,-1,,"{
    return &p_update->release;
}",1,,757,2,,void
129267,BLOCK,-1,,<empty>,1,,1,1,,ANY
129273,BLOCK,-1,,<empty>,,,,1,,<empty>
129293,BLOCK,-1,,<empty>,,,,1,,<empty>
129317,BLOCK,-1,,<empty>,,,,1,,<empty>
129334,BLOCK,-1,,<empty>,,,,1,,<empty>
129366,BLOCK,-1,,<empty>,,,,1,,<empty>
129384,BLOCK,-1,,<empty>,,,,1,,<empty>
129403,BLOCK,-1,,<empty>,,,,1,,<empty>
129415,BLOCK,-1,,<empty>,,,,1,,<empty>
129427,BLOCK,-1,,<empty>,,,,1,,<empty>
129446,BLOCK,-1,,<empty>,,,,1,,<empty>
129458,BLOCK,-1,,<empty>,,,,1,,<empty>
129475,BLOCK,-1,,<empty>,,,,1,,<empty>
129496,BLOCK,-1,,<empty>,,,,3,,<empty>
129513,BLOCK,-1,,<empty>,,,,4,,<empty>
129521,BLOCK,-1,,<empty>,,,,5,,<empty>
129528,BLOCK,-1,,<empty>,,,,4,,<empty>
129535,BLOCK,-1,,<empty>,,,,4,,<empty>
129541,BLOCK,-1,,<empty>,,,,3,,<empty>
129547,BLOCK,-1,,<empty>,,,,3,,<empty>
129552,BLOCK,-1,,<empty>,,,,2,,<empty>
129577,BLOCK,-1,,<empty>,1,,1,1,,ANY
129581,BLOCK,-1,,"{
    assert( header_len == 1 || header_len == 2 || header_len == 4 );

    if( header_len == 1 )
        return( p[0] );
    else if( header_len == 2 )
        return( (p[0] << 8) + p[1] );
    else if( header_len == 4 )
        return( ((uint32_t)p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3] );
    else
        abort();
}",1,,58,3,,void
129598,BLOCK,-1,,<empty>,9,,62,2,,void
129604,BLOCK,-1,,<empty>,10,,63,1,,void
129609,BLOCK,-1,,<empty>,9,,64,2,,void
129621,BLOCK,-1,,<empty>,10,,65,1,,void
129626,BLOCK,-1,,<empty>,9,,66,2,,void
129652,BLOCK,-1,,<empty>,9,,68,1,,void
129658,BLOCK,-1,,"{
    return (scalar_number(mpi, 2) + 7) / 8;
}",1,,74,2,,void
129674,BLOCK,-1,,"{
    if (buflen < 2)
        return 0;

    size_t n = mpi_len(buf);

    if (n * 8 > bits)
        return 0;

    n += 2;

    if (buflen < n)
        return 0;

    memcpy(dst, buf, n);
    return n;
}",1,,79,5,,void
129679,BLOCK,-1,,<empty>,9,,81,2,,void
129693,BLOCK,-1,,<empty>,9,,86,2,,void
129703,BLOCK,-1,,<empty>,9,,91,2,,void
129718,BLOCK,-1,,"{
    if( i_packet_len < 6 )
        return VLC_EGENERIC;

    size_t i_read = 0;

    p_key->version   = *p_buf++; i_read++;
    if( p_key->version != 4 )
        return VLC_EGENERIC;

    /* XXX: warn when timestamp is > date ? */
    memcpy( p_key->timestamp, p_buf, 4 ); p_buf += 4; i_read += 4;

    p_key->algo      = *p_buf++; i_read++;
    if( p_key->algo == GCRY_PK_DSA ) {
        READ_MPI(p_key->sig.dsa.p, 3072);
        READ_MPI(p_key->sig.dsa.q, 256);
        READ_MPI(p_key->sig.dsa.g, 3072);
        READ_MPI(p_key->sig.dsa.y, 3072);
    } else if ( p_key->algo == GCRY_PK_RSA ) {
        READ_MPI(p_key->sig.rsa.n, 4096);
        READ_MPI(p_key->sig.rsa.e, 4096);
    } else
        return VLC_EGENERIC;

    if( i_read == i_packet_len )
        return VLC_SUCCESS;

    /* some extra data eh ? */

error:
    return VLC_EGENERIC;
}",1,,110,4,,void
129723,BLOCK,-1,,<empty>,9,,112,2,,void
129745,BLOCK,-1,,<empty>,9,,118,2,,void
129775,BLOCK,-1,,"{
        READ_MPI(p_key->sig.dsa.p, 3072);
        READ_MPI(p_key->sig.dsa.q, 256);
        READ_MPI(p_key->sig.dsa.g, 3072);
        READ_MPI(p_key->sig.dsa.y, 3072);
    }",38,,124,2,,void
129786,BLOCK,1,,<empty>,,,,8,,void
129788,BLOCK,-1,,"READ_MPI(p_key->sig.dsa.p, 3072)",9,,125,1,,void
129808,BLOCK,-1,,<empty>,9,,125,2,,void
129827,BLOCK,1,,<empty>,,,,8,,void
129829,BLOCK,-1,,"READ_MPI(p_key->sig.dsa.q, 256)",9,,126,1,,void
129849,BLOCK,-1,,<empty>,9,,126,2,,void
129868,BLOCK,1,,<empty>,,,,8,,void
129870,BLOCK,-1,,"READ_MPI(p_key->sig.dsa.g, 3072)",9,,127,1,,void
129890,BLOCK,-1,,<empty>,9,,127,2,,void
129909,BLOCK,1,,<empty>,,,,8,,void
129911,BLOCK,-1,,"READ_MPI(p_key->sig.dsa.y, 3072)",9,,128,1,,void
129931,BLOCK,-1,,<empty>,9,,128,2,,void
129941,BLOCK,-1,,<empty>,12,,129,1,,void
129948,BLOCK,-1,,"{
        READ_MPI(p_key->sig.rsa.n, 4096);
        READ_MPI(p_key->sig.rsa.e, 4096);
    }",46,,129,2,,void
129959,BLOCK,1,,<empty>,,,,8,,void
129961,BLOCK,-1,,"READ_MPI(p_key->sig.rsa.n, 4096)",9,,130,1,,void
129981,BLOCK,-1,,<empty>,9,,130,2,,void
130000,BLOCK,1,,<empty>,,,,8,,void
130002,BLOCK,-1,,"READ_MPI(p_key->sig.rsa.e, 4096)",9,,131,1,,void
130022,BLOCK,-1,,<empty>,9,,131,2,,void
130032,BLOCK,-1,,<empty>,9,,133,1,,void
130039,BLOCK,-1,,<empty>,9,,136,2,,void
130051,BLOCK,-1,,"{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 19 ) /* signature is at least 19 bytes + the 2 MPIs */
        return 0;

    p_sig->specific.v3.hashed_data_len = *p_buf++; i_read++;
    if( p_sig->specific.v3.hashed_data_len != 5 )
        return 0;

    p_sig->type = *p_buf++; i_read++;

    memcpy( p_sig->specific.v3.timestamp, p_buf, 4 );
    p_buf += 4; i_read += 4;

    memcpy( p_sig->issuer_longid, p_buf, 8 );
    p_buf += 8; i_read += 8;

    p_sig->public_key_algo = *p_buf++; i_read++;

    p_sig->digest_algo = *p_buf++; i_read++;

    p_sig->hash_verification[0] = *p_buf++; i_read++;
    p_sig->hash_verification[1] = *p_buf++; i_read++;

    assert( i_read == 19 );

    return i_read;
}",1,,147,4,,void
130060,BLOCK,-1,,<empty>,9,,151,2,,void
130086,BLOCK,-1,,<empty>,9,,155,2,,void
130178,BLOCK,-1,,"{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 10 ) /* signature is at least 10 bytes + the 2 MPIs */
        return 0;

    p_sig->type = *p_buf++; i_read++;

    p_sig->public_key_algo = *p_buf++; i_read++;
    if (p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
            return 0;

    p_sig->digest_algo = *p_buf++; i_read++;

    memcpy( p_sig->specific.v4.hashed_data_len, p_buf, 2 );
    p_buf += 2; i_read += 2;

    size_t i_hashed_data_len =
        scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
    i_read += i_hashed_data_len;
    if( i_read + 4 > i_sig_len )
        return 0;

    p_sig->specific.v4.hashed_data = (uint8_t*) malloc( i_hashed_data_len );
    if( !p_sig->specific.v4.hashed_data )
        return 0;
    memcpy( p_sig->specific.v4.hashed_data, p_buf, i_hashed_data_len );
    p_buf += i_hashed_data_len;

    memcpy( p_sig->specific.v4.unhashed_data_len, p_buf, 2 );
    p_buf += 2; i_...",1,,184,4,,void
130187,BLOCK,-1,,<empty>,9,,188,2,,void
130220,BLOCK,-1,,<empty>,13,,194,2,,void
130269,BLOCK,-1,,<empty>,9,,205,2,,void
130293,BLOCK,-1,,<empty>,9,,209,2,,void
130346,BLOCK,-1,,<empty>,9,,220,2,,void
130370,BLOCK,-1,,<empty>,9,,224,2,,void
130423,BLOCK,-1,,<empty>,5,,236,1,,void
130424,BLOCK,4,,"{
        if( p > max_pos )
            return 0;

        size_t i_subpacket_len;
        if( *p < 192 )
        {
            if( p + 1 > max_pos )
                return 0;
            i_subpacket_len = *p++;
        }
        else if( *p < 255 )
        {
            if( p + 2 > max_pos )
                return 0;
            i_subpacket_len = (*p++ - 192) << 8;
            i_subpacket_len += *p++ + 192;
        }
        else
        {
            if( ++p + 4 > max_pos )
                return 0;
            i_subpacket_len = U32_AT(p);
            p += 4;
        }

        if( *p == ISSUER_SUBPACKET )
        {
            if( p + 9 > max_pos )
                return 0;

            memcpy( &p_sig->issuer_longid, p+1, 8 );

            return i_read;
        }

        p += i_subpacket_len;
    }",5,,237,4,,void
130429,BLOCK,-1,,<empty>,13,,239,2,,void
130438,BLOCK,-1,,"{
            if( p + 1 > max_pos )
                return 0;
            i_subpacket_len = *p++;
        }",9,,243,2,,void
130445,BLOCK,-1,,<empty>,17,,245,2,,void
130454,BLOCK,-1,,<empty>,14,,248,1,,void
130460,BLOCK,-1,,"{
            if( p + 2 > max_pos )
                return 0;
            i_subpacket_len = (*p++ - 192) << 8;
            i_subpacket_len += *p++ + 192;
        }",9,,249,2,,void
130467,BLOCK,-1,,<empty>,17,,251,2,,void
130487,BLOCK,-1,,"{
            if( ++p + 4 > max_pos )
                return 0;
            i_subpacket_len = U32_AT(p);
            p += 4;
        }",9,,256,1,,void
130495,BLOCK,-1,,<empty>,17,,258,2,,void
130510,BLOCK,-1,,"{
            if( p + 9 > max_pos )
                return 0;

            memcpy( &p_sig->issuer_longid, p+1, 8 );

            return i_read;
        }",9,,264,2,,void
130517,BLOCK,-1,,<empty>,17,,266,2,,void
130540,BLOCK,-1,,"{
    if( !i_packet_len ) /* 1st sanity check, we need at least the version */
        return VLC_EGENERIC;

    p_sig->version = *p_buf++;

    size_t i_read;
    switch( p_sig->version )
    {
        case 3:
            i_read = parse_signature_v3_packet( p_sig, p_buf, i_packet_len );
            break;
        case 4:
            p_sig->specific.v4.hashed_data = NULL;
            p_sig->specific.v4.unhashed_data = NULL;
            i_read = parse_signature_v4_packet( p_sig, p_buf, i_packet_len );
            break;
        default:
            return VLC_EGENERIC;
    }

    if( i_read == 0 ) /* signature packet parsing has failed */
        goto error;

    if( p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
        goto error;

    switch( p_sig->type )
    {
        case BINARY_SIGNATURE:
        case TEXT_SIGNATURE:
        case GENERIC_KEY_SIGNATURE:
        case PERSONA_KEY_SIGNATURE:
        case CASUAL_KEY_SIGNATURE:
        case POSITIVE...",1,,280,4,,void
130544,BLOCK,-1,,<empty>,9,,282,2,,void
130559,BLOCK,-1,,"{
        case 3:
            i_read = parse_signature_v3_packet( p_sig, p_buf, i_packet_len );
            break;
        case 4:
            p_sig->specific.v4.hashed_data = NULL;
            p_sig->specific.v4.unhashed_data = NULL;
            i_read = parse_signature_v4_packet( p_sig, p_buf, i_packet_len );
            break;
        default:
            return VLC_EGENERIC;
    }",5,,288,2,,void
130603,BLOCK,-1,,<empty>,9,,302,2,,void
130617,BLOCK,-1,,<empty>,9,,305,2,,void
130623,BLOCK,-1,,"{
        case BINARY_SIGNATURE:
        case TEXT_SIGNATURE:
        case GENERIC_KEY_SIGNATURE:
        case PERSONA_KEY_SIGNATURE:
        case CASUAL_KEY_SIGNATURE:
        case POSITIVE_KEY_SIGNATURE:
            break;
        default:
            goto error;
    }",5,,308,2,,void
130650,BLOCK,-1,,"{
        READ_MPI(p_sig->algo_specific.dsa.r, 256);
        READ_MPI(p_sig->algo_specific.dsa.s, 256);
    }",49,,323,2,,void
130661,BLOCK,1,,<empty>,,,,8,,void
130663,BLOCK,-1,,"READ_MPI(p_sig->algo_specific.dsa.r, 256)",9,,324,1,,void
130683,BLOCK,-1,,<empty>,9,,324,2,,void
130702,BLOCK,1,,<empty>,,,,8,,void
130704,BLOCK,-1,,"READ_MPI(p_sig->algo_specific.dsa.s, 256)",9,,325,1,,void
130724,BLOCK,-1,,<empty>,9,,325,2,,void
130734,BLOCK,-1,,<empty>,12,,326,1,,void
130741,BLOCK,-1,,"{
        READ_MPI(p_sig->algo_specific.rsa.s, 4096);
    }",57,,326,2,,void
130752,BLOCK,1,,<empty>,,,,8,,void
130754,BLOCK,-1,,"READ_MPI(p_sig->algo_specific.rsa.s, 4096)",9,,327,1,,void
130774,BLOCK,-1,,<empty>,9,,327,2,,void
130784,BLOCK,-1,,<empty>,9,,329,1,,void
130794,BLOCK,-1,,<empty>,9,,333,2,,void
130805,BLOCK,-1,,"{
        free( p_sig->specific.v4.hashed_data );
        free( p_sig->specific.v4.unhashed_data );
    }",5,,340,2,,void
130829,BLOCK,-1,,"{
    long crc = CRC24_INIT;
    int i;
    while (len--)
    {
        crc ^= (*octets++) << 16;
        for (i = 0; i < 8; i++)
        {
            crc <<= 1;
            if (crc & 0x1000000)
                crc ^= CRC24_POLY;
        }
    }
    return crc & 0xFFFFFFL;
}",1,,357,3,,void
130834,BLOCK,1,,<empty>,,,,1,,void
130840,BLOCK,-1,,"{
        crc ^= (*octets++) << 16;
        for (i = 0; i < 8; i++)
        {
            crc <<= 1;
            if (crc & 0x1000000)
                crc ^= CRC24_POLY;
        }
    }",5,,361,2,,void
130849,BLOCK,-1,,<empty>,9,,363,1,,void
130858,BLOCK,4,,"{
            crc <<= 1;
            if (crc & 0x1000000)
                crc ^= CRC24_POLY;
        }",9,,364,4,,void
130866,BLOCK,-1,,<empty>,17,,367,2,,void
130870,BLOCK,1,,<empty>,,,,1,,void
130883,BLOCK,-1,,"{
    const char *p_ipos = p_ibuf;
    uint8_t *p_opos = p_obuf;
    int i_end = 0;
    int i_header_skipped = 0;

    while( !i_end && p_ipos < p_ibuf + i_ibuf_len && *p_ipos != '=' )
    {
        if( *p_ipos == '\r' || *p_ipos == '\n' )
        {
            p_ipos++;
            continue;
        }

        size_t i_line_len = strcspn( p_ipos, ""\r\n"" );
        if( i_line_len == 0 )
            continue;

        if( !i_header_skipped )
        {
            if( !strncmp( p_ipos, ""-----BEGIN PGP"", 14 ) )
                i_header_skipped = 1;

            p_ipos += i_line_len + 1;
            continue;
        }

        if( !strncmp( p_ipos, ""Version:"", 8 ) )
        {
            p_ipos += i_line_len + 1;
            continue;
        }

        if( p_ipos[i_line_len - 1] == '=' )
        {
            i_end = 1;
        }

        p_opos += vlc_b64_decode_binary_to_buffer(  p_opos,
                        p_obuf - p_opos + i_obuf_len, p_ipos );
        p_ipos += i_line_len + 1...",1,,380,5,,void
130914,BLOCK,-1,,"{
        if( *p_ipos == '\r' || *p_ipos == '\n' )
        {
            p_ipos++;
            continue;
        }

        size_t i_line_len = strcspn( p_ipos, ""\r\n"" );
        if( i_line_len == 0 )
            continue;

        if( !i_header_skipped )
        {
            if( !strncmp( p_ipos, ""-----BEGIN PGP"", 14 ) )
                i_header_skipped = 1;

            p_ipos += i_line_len + 1;
            continue;
        }

        if( !strncmp( p_ipos, ""Version:"", 8 ) )
        {
            p_ipos += i_line_len + 1;
            continue;
        }

        if( p_ipos[i_line_len - 1] == '=' )
        {
            i_end = 1;
        }

        p_opos += vlc_b64_decode_binary_to_buffer(  p_opos,
                        p_obuf - p_opos + i_obuf_len, p_ipos );
        p_ipos += i_line_len + 1;
    }",5,,387,2,,void
130925,BLOCK,-1,,"{
            p_ipos++;
            continue;
        }",9,,389,2,,void
130939,BLOCK,-1,,<empty>,13,,396,2,,void
130944,BLOCK,-1,,"{
            if( !strncmp( p_ipos, ""-----BEGIN PGP"", 14 ) )
                i_header_skipped = 1;

            p_ipos += i_line_len + 1;
            continue;
        }",9,,399,2,,void
130951,BLOCK,-1,,<empty>,17,,401,2,,void
130967,BLOCK,-1,,"{
            p_ipos += i_line_len + 1;
            continue;
        }",9,,408,2,,void
130982,BLOCK,-1,,"{
            i_end = 1;
        }",9,,414,2,,void
131015,BLOCK,-1,,<empty>,9,,425,2,,void
131026,BLOCK,-1,,<empty>,9,,429,2,,void
131075,BLOCK,-1,,"{
    uint8_t asn[100];
    uint8_t frame[4096/8];

    size_t asnlen = sizeof(asn);
    size_t hashlen = gcry_md_get_algo_dlen(algo);

    if (gcry_md_algo_info(algo, GCRYCTL_GET_ASNOID, asn, &asnlen))
        return VLC_EGENERIC;

    if (!hashlen || hashlen + asnlen + 4 > size)
        return VLC_EGENERIC;

    frame[0] = 0;
    frame[1] = 1; /* block type */
    int pad = size - hashlen - asnlen - 3 ;
    memset (&frame[2], 0xff, pad );
    frame[2+pad] = 0;
    memcpy(&frame[3+pad], asn, asnlen);
    memcpy(&frame[3+pad+asnlen], hash, hashlen);

    if (gcry_mpi_scan(r_result, GCRYMPI_FMT_USG, frame, size, &size))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,,439,5,,void
131095,BLOCK,-1,,<empty>,9,,447,2,,void
131109,BLOCK,-1,,<empty>,9,,450,2,,void
131174,BLOCK,-1,,<empty>,9,,461,2,,void
131185,BLOCK,-1,,"{
    int ret = VLC_EGENERIC;
    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(rsa(n %m)(e %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(rsa(s%m)))"";

    size_t erroff;
    gcry_mpi_t n, e, s, hash;
    n = e = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_e_len = mpi_len( p_key->sig.rsa.e );
    size_t i_n_len = mpi_len( p_key->sig.rsa.n );
    if( gcry_mpi_scan( &n, GCRYMPI_FMT_USG, p_key->sig.rsa.n + 2, i_n_len, NULL ) ||
        gcry_mpi_scan( &e, GCRYMPI_FMT_USG, p_key->sig.rsa.e + 2, i_e_len, NULL ) ||
        gcry_sexp_build( &key_sexp, &erroff, key_sexp_s, n, e ) )
        goto out;

    uint8_t *p_s = sign->algo_specific.rsa.s;
    size_t i_s_len = mpi_len( p_s );
    if( gcry_mpi_scan( &s, GCRYMPI_FMT_USG, p_s + 2, i_s_len, NULL ) ||
        gcry_sexp_b...",1,,470,4,,void
131289,BLOCK,-1,,<empty>,9,,490,2,,void
131324,BLOCK,-1,,<empty>,9,,496,2,,void
131343,BLOCK,-1,,<empty>,9,,500,2,,void
131350,BLOCK,-1,,<empty>,9,,503,2,,void
131358,BLOCK,-1,,<empty>,13,,508,2,,void
131363,BLOCK,-1,,<empty>,13,,509,2,,void
131368,BLOCK,-1,,<empty>,13,,510,2,,void
131373,BLOCK,-1,,<empty>,16,,511,2,,void
131378,BLOCK,-1,,<empty>,20,,512,2,,void
131383,BLOCK,-1,,<empty>,20,,513,2,,void
131388,BLOCK,-1,,<empty>,21,,514,2,,void
131399,BLOCK,-1,,"{
    int ret = VLC_EGENERIC;

    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(dsa(p %m)(q %m)(g %m)(y %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(dsa(r %m )(s %m )))"";

    size_t erroff;
    gcry_mpi_t p, q, g, y, r, s, hash;
    p = q = g = y = r = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_p_len = mpi_len( p_key->sig.dsa.p );
    size_t i_q_len = mpi_len( p_key->sig.dsa.q );
    size_t i_g_len = mpi_len( p_key->sig.dsa.g );
    size_t i_y_len = mpi_len( p_key->sig.dsa.y );
    if( gcry_mpi_scan( &p, GCRYMPI_FMT_USG, p_key->sig.dsa.p + 2, i_p_len, NULL ) ||
        gcry_mpi_scan( &q, GCRYMPI_FMT_USG, p_key->sig.dsa.q + 2, i_q_len, NULL ) ||
        gcry_mpi_scan( &g, GCRYMPI_FMT_USG, p_key->sig.dsa.g + 2, i_g_len, NULL ) ||
        gcry_mpi_scan( &y, GCRY...",1,,523,4,,void
131568,BLOCK,-1,,<empty>,9,,548,2,,void
131629,BLOCK,-1,,<empty>,9,,557,2,,void
131642,BLOCK,-1,,<empty>,9,,561,2,,void
131662,BLOCK,-1,,<empty>,9,,564,2,,void
131669,BLOCK,-1,,<empty>,9,,567,2,,void
131677,BLOCK,-1,,<empty>,13,,572,2,,void
131682,BLOCK,-1,,<empty>,13,,573,2,,void
131687,BLOCK,-1,,<empty>,13,,574,2,,void
131692,BLOCK,-1,,<empty>,13,,575,2,,void
131697,BLOCK,-1,,<empty>,13,,576,2,,void
131702,BLOCK,-1,,<empty>,13,,577,2,,void
131707,BLOCK,-1,,<empty>,16,,578,2,,void
131712,BLOCK,-1,,<empty>,20,,579,2,,void
131717,BLOCK,-1,,<empty>,20,,580,2,,void
131722,BLOCK,-1,,<empty>,21,,581,2,,void
131733,BLOCK,-1,,"{
    if (sign->public_key_algo == GCRY_PK_DSA)
        return verify_signature_dsa(sign, p_key, p_hash);
    else if (sign->public_key_algo == GCRY_PK_RSA)
        return verify_signature_rsa(sign, p_key, p_hash);
    else
        return VLC_EGENERIC;
}",1,,591,4,,void
131740,BLOCK,-1,,<empty>,9,,593,2,,void
131747,BLOCK,-1,,<empty>,10,,594,1,,void
131754,BLOCK,-1,,<empty>,9,,595,2,,void
131761,BLOCK,-1,,<empty>,9,,597,1,,void
131771,BLOCK,-1,,"{
    const uint8_t *pos = p_key_data;
    const uint8_t *max_pos = pos + i_key_len;

    int i_status = 0;
#define PUBLIC_KEY_FOUND    0x01
#define USER_ID_FOUND       0x02
#define SIGNATURE_FOUND     0X04

    uint8_t *p_key_unarmored = NULL;

    p_key->psz_username = NULL;
    p_key->sig.specific.v4.hashed_data = NULL;
    p_key->sig.specific.v4.unhashed_data = NULL;

    if( !( *pos & 0x80 ) )
    {   /* first byte is ASCII, unarmoring */
        p_key_unarmored = (uint8_t*)malloc( i_key_len );
        if( !p_key_unarmored )
            return VLC_ENOMEM;
        int i_len = pgp_unarmor( (char*)p_key_data, i_key_len,
                                 p_key_unarmored, i_key_len );

        if( i_len == 0 )
            goto error;

        pos = p_key_unarmored;
        max_pos = pos + i_len;
    }

    while( pos < max_pos )
    {
        if( !(*pos & 0x80) || *pos & 0x40 )
            goto error;

        int i_type = packet_type( *pos );

        int i_header_len = packet_heade...",1,,609,5,,void
131823,BLOCK,-1,,"{   /* first byte is ASCII, unarmoring */
        p_key_unarmored = (uint8_t*)malloc( i_key_len );
        if( !p_key_unarmored )
            return VLC_ENOMEM;
        int i_len = pgp_unarmor( (char*)p_key_data, i_key_len,
                                 p_key_unarmored, i_key_len );

        if( i_len == 0 )
            goto error;

        pos = p_key_unarmored;
        max_pos = pos + i_len;
    }",5,,625,2,,void
131833,BLOCK,-1,,<empty>,13,,628,2,,void
131850,BLOCK,-1,,<empty>,13,,633,2,,void
131864,BLOCK,-1,,"{
        if( !(*pos & 0x80) || *pos & 0x40 )
            goto error;

        int i_type = packet_type( *pos );

        int i_header_len = packet_header_len( *pos++ );
        if( pos + i_header_len > max_pos ||
            ( i_header_len != 1 && i_header_len != 2 && i_header_len != 4 ) )
            goto error;

        size_t i_packet_len = scalar_number( pos, i_header_len );
        pos += i_header_len;

        if( pos + i_packet_len > max_pos )
            goto error;

        switch( i_type )
        {
            case PUBLIC_KEY_PACKET:
                i_status |= PUBLIC_KEY_FOUND;
                if( parse_public_key_packet( &p_key->key, pos, i_packet_len ) != VLC_SUCCESS )
                    goto error;
                break;

            case SIGNATURE_PACKET: /* we accept only v4 signatures here */
                if( i_status & SIGNATURE_FOUND || !p_sig_issuer )
                    break;
                int i_ret = parse_signature_packet( &p_key->sig, pos,
          ...",5,,640,2,,void
131876,BLOCK,-1,,<empty>,13,,642,2,,void
131884,BLOCK,1,,<empty>,,,,3,,void
131898,BLOCK,1,,<empty>,,,,3,,void
131924,BLOCK,-1,,<empty>,13,,649,2,,void
131941,BLOCK,-1,,<empty>,13,,655,2,,void
131945,BLOCK,-1,,"{
            case PUBLIC_KEY_PACKET:
                i_status |= PUBLIC_KEY_FOUND;
                if( parse_public_key_packet( &p_key->key, pos, i_packet_len ) != VLC_SUCCESS )
                    goto error;
                break;

            case SIGNATURE_PACKET: /* we accept only v4 signatures here */
                if( i_status & SIGNATURE_FOUND || !p_sig_issuer )
                    break;
                int i_ret = parse_signature_packet( &p_key->sig, pos,
                                                    i_packet_len );
                if( i_ret == VLC_SUCCESS )
                {
                    if( p_key->sig.version != 4 )
                        break;
                    if( memcmp( p_key->sig.issuer_longid, p_sig_issuer, 8 ) )
                    {
                        free( p_key->sig.specific.v4.hashed_data );
                        free( p_key->sig.specific.v4.unhashed_data );
                        p_key->sig.specific.v4.hashed_data = NULL;
         ...",9,,658,2,,void
131951,BLOCK,1,,<empty>,,,,1,,void
131963,BLOCK,-1,,<empty>,21,,662,2,,void
131973,BLOCK,1,,<empty>,,,,1,,void
131977,BLOCK,-1,,<empty>,21,,667,2,,void
131993,BLOCK,-1,,"{
                    if( p_key->sig.version != 4 )
                        break;
                    if( memcmp( p_key->sig.issuer_longid, p_sig_issuer, 8 ) )
                    {
                        free( p_key->sig.specific.v4.hashed_data );
                        free( p_key->sig.specific.v4.unhashed_data );
                        p_key->sig.specific.v4.hashed_data = NULL;
                        p_key->sig.specific.v4.unhashed_data = NULL;
                        break;
                    }
                    i_status |= SIGNATURE_FOUND;
                }",17,,671,2,,void
132002,BLOCK,-1,,<empty>,25,,673,2,,void
132013,BLOCK,-1,,"{
                        free( p_key->sig.specific.v4.hashed_data );
                        free( p_key->sig.specific.v4.unhashed_data );
                        p_key->sig.specific.v4.hashed_data = NULL;
                        p_key->sig.specific.v4.unhashed_data = NULL;
                        break;
                    }",21,,675,2,,void
132060,BLOCK,1,,<empty>,,,,1,,void
132069,BLOCK,-1,,<empty>,21,,688,2,,void
132074,BLOCK,1,,<empty>,,,,1,,void
132091,BLOCK,-1,,<empty>,21,,692,2,,void
132120,BLOCK,1,,<empty>,,,,1,,void
132123,BLOCK,1,,<empty>,,,,1,,void
132125,BLOCK,-1,,<empty>,9,,706,2,,void
132135,BLOCK,1,,<empty>,,,,1,,void
132137,BLOCK,-1,,<empty>,9,,709,2,,void
132151,BLOCK,-1,,"{
        free( p_key->sig.specific.v4.hashed_data );
        free( p_key->sig.specific.v4.unhashed_data );
    }",5,,715,2,,void
132185,BLOCK,-1,,"{
    uint8_t buffer[4096];
    size_t i_read;

    FILE *f = vlc_fopen( psz_file, ""r"" );
    if( !f )
        return -1;

    while( ( i_read = fread( buffer, 1, sizeof(buffer), f ) ) > 0 )
        gcry_md_write( hd, buffer, i_read );

    fclose( f );

    return 0;
}",1,,727,3,,void
132197,BLOCK,-1,,<empty>,9,,733,2,,void
132225,BLOCK,-1,,"{
    if( p_sig->version == 3 )
    {
        gcry_md_putc( hd, p_sig->type );
        gcry_md_write( hd, &p_sig->specific.v3.timestamp, 4 );
    }
    else if( p_sig->version == 4 )
    {
        gcry_md_putc( hd, p_sig->version );
        gcry_md_putc( hd, p_sig->type );
        gcry_md_putc( hd, p_sig->public_key_algo );
        gcry_md_putc( hd, p_sig->digest_algo );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data_len, 2 );
        size_t i_len = scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data, i_len );

        gcry_md_putc( hd, 0x04 );
        gcry_md_putc( hd, 0xFF );

        i_len += 6; /* hashed data + 6 bytes header */

        gcry_md_putc( hd, (i_len >> 24) & 0xff );
        gcry_md_putc( hd, (i_len >> 16) & 0xff );
        gcry_md_putc( hd, (i_len >> 8) & 0xff );
        gcry_md_putc( hd, (i_len) & 0xff );
    }
    else
    {   /* RFC 4880 only tells about versions 3 and 4 */
        return NU...",1,,746,3,,void
132232,BLOCK,-1,,"{
        gcry_md_putc( hd, p_sig->type );
        gcry_md_write( hd, &p_sig->specific.v3.timestamp, 4 );
    }",5,,748,2,,void
132250,BLOCK,-1,,<empty>,10,,752,1,,void
132257,BLOCK,-1,,"{
        gcry_md_putc( hd, p_sig->version );
        gcry_md_putc( hd, p_sig->type );
        gcry_md_putc( hd, p_sig->public_key_algo );
        gcry_md_putc( hd, p_sig->digest_algo );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data_len, 2 );
        size_t i_len = scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data, i_len );

        gcry_md_putc( hd, 0x04 );
        gcry_md_putc( hd, 0xFF );

        i_len += 6; /* hashed data + 6 bytes header */

        gcry_md_putc( hd, (i_len >> 24) & 0xff );
        gcry_md_putc( hd, (i_len >> 16) & 0xff );
        gcry_md_putc( hd, (i_len >> 8) & 0xff );
        gcry_md_putc( hd, (i_len) & 0xff );
    }",5,,753,2,,void
132346,BLOCK,-1,,"{   /* RFC 4880 only tells about versions 3 and 4 */
        return NULL;
    }",5,,773,1,,void
132375,BLOCK,-1,,<empty>,9,,783,2,,void
132389,BLOCK,-1,,"{
    gcry_md_hd_t hd;
    if( gcry_md_open( &hd, p_sig->digest_algo, 0 ) )
        return NULL;

    if( p_sig->type == TEXT_SIGNATURE )
    while( *psz_string )
    {
        size_t i_len = strcspn( psz_string, ""\r\n"" );

        if( i_len )
        {
            gcry_md_write( hd, psz_string, i_len );
            psz_string += i_len;
        }
        gcry_md_putc( hd, '\r' );
        gcry_md_putc( hd, '\n' );

        if( *psz_string == '\r' )
            psz_string++;
        if( *psz_string == '\n' )
            psz_string++;
    }
    else
        gcry_md_write( hd, psz_string, strlen( psz_string ) );

    return hash_finish( hd, p_sig );
}",1,,794,3,,void
132399,BLOCK,-1,,<empty>,9,,797,2,,void
132408,BLOCK,-1,,<empty>,5,,800,2,,void
132412,BLOCK,-1,,"{
        size_t i_len = strcspn( psz_string, ""\r\n"" );

        if( i_len )
        {
            gcry_md_write( hd, psz_string, i_len );
            psz_string += i_len;
        }
        gcry_md_putc( hd, '\r' );
        gcry_md_putc( hd, '\n' );

        if( *psz_string == '\r' )
            psz_string++;
        if( *psz_string == '\n' )
            psz_string++;
    }",5,,801,2,,void
132421,BLOCK,-1,,"{
            gcry_md_write( hd, psz_string, i_len );
            psz_string += i_len;
        }",9,,805,2,,void
132440,BLOCK,-1,,<empty>,13,,813,2,,void
132448,BLOCK,-1,,<empty>,13,,815,2,,void
132452,BLOCK,-1,,<empty>,9,,818,1,,void
132467,BLOCK,-1,,"{
    gcry_md_hd_t hd;
    if( gcry_md_open( &hd, p_sig->digest_algo, 0 ) )
        return NULL;

    if( hash_from_binary_file( psz_file, hd ) < 0 )
    {
        gcry_md_close( hd );
        return NULL;
    }

    return hash_finish( hd, p_sig );
}",1,,828,3,,void
132477,BLOCK,-1,,<empty>,9,,831,2,,void
132486,BLOCK,-1,,"{
        gcry_md_close( hd );
        return NULL;
    }",5,,834,2,,void
132499,BLOCK,-1,,"{
    const uint8_t pk_algo = p_pkey->key.algo;
    size_t i_size;
    size_t i_p_len, i_g_len, i_q_len, i_y_len;
    size_t i_n_len, i_e_len;

    if( p_pkey->sig.version != 4 )
        return NULL;

    if( p_pkey->sig.type < GENERIC_KEY_SIGNATURE ||
        p_pkey->sig.type > POSITIVE_KEY_SIGNATURE )
        return NULL;

    if( p_pkey->psz_username == NULL )
        return NULL;

    gcry_error_t error = 0;
    gcry_md_hd_t hd;

    if (pk_algo == GCRY_PK_DSA) {
        i_p_len = mpi_len( p_pkey->key.sig.dsa.p );
        i_g_len = mpi_len( p_pkey->key.sig.dsa.g );
        i_q_len = mpi_len( p_pkey->key.sig.dsa.q );
        i_y_len = mpi_len( p_pkey->key.sig.dsa.y );

        i_size = 6 + 2*4 + i_p_len + i_g_len + i_q_len + i_y_len;
    } else if (pk_algo == GCRY_PK_RSA) {
        i_n_len = mpi_len( p_pkey->key.sig.rsa.n );
        i_e_len = mpi_len( p_pkey->key.sig.rsa.e );

        i_size = 6 + 2*2 + i_n_len + i_e_len;
    } else
        return NULL;

    error = gcry_md_open(...",1,,848,2,,void
132523,BLOCK,-1,,<empty>,9,,855,2,,void
132542,BLOCK,-1,,<empty>,9,,859,2,,void
132551,BLOCK,-1,,<empty>,9,,862,2,,void
132563,BLOCK,-1,,"{
        i_p_len = mpi_len( p_pkey->key.sig.dsa.p );
        i_g_len = mpi_len( p_pkey->key.sig.dsa.g );
        i_q_len = mpi_len( p_pkey->key.sig.dsa.q );
        i_y_len = mpi_len( p_pkey->key.sig.dsa.y );

        i_size = 6 + 2*4 + i_p_len + i_g_len + i_q_len + i_y_len;
    }",33,,867,2,,void
132628,BLOCK,-1,,<empty>,12,,874,1,,void
132633,BLOCK,-1,,"{
        i_n_len = mpi_len( p_pkey->key.sig.rsa.n );
        i_e_len = mpi_len( p_pkey->key.sig.rsa.e );

        i_size = 6 + 2*2 + i_n_len + i_e_len;
    }",40,,874,2,,void
132670,BLOCK,-1,,<empty>,9,,880,1,,void
132686,BLOCK,-1,,<empty>,9,,884,2,,void
132730,BLOCK,-1,,"{
        gcry_md_write( hd, (uint8_t*)&p_pkey->key.sig.dsa.p, 2 + i_p_len );
        gcry_md_write( hd, (uint8_t*)&p_pkey->key.sig.dsa.q, 2 + i_q_len );
        gcry_md_write( hd, (uint8_t*)&p_pkey->key.sig.dsa.g, 2 + i_g_len );
        gcry_md_write( hd, (uint8_t*)&p_pkey->key.sig.dsa.y, 2 + i_y_len );
    }",33,,895,2,,void
132800,BLOCK,-1,,<empty>,12,,900,1,,void
132805,BLOCK,-1,,"{
        gcry_md_write( hd, (uint8_t*)&p_pkey->key.sig.rsa.n, 2 + i_n_len );
        gcry_md_write( hd, (uint8_t*)&p_pkey->key.sig.rsa.e, 2 + i_e_len );
    }",40,,900,2,,void
132920,BLOCK,-1,,"{
        free(p_hash);
        return NULL;
    }",5,,920,2,,void
132933,BLOCK,-1,,"{
    char *psz_url;
    if( asprintf( &psz_url, ""http://download.videolan.org/pub/keys/%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X.asc"",
                    p_longid[0], p_longid[1], p_longid[2], p_longid[3],
                    p_longid[4], p_longid[5], p_longid[6], p_longid[7] ) == -1 )
        return NULL;

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_url );
    free( psz_url );
    if( !p_stream )
        return NULL;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );
    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
    {
        msg_Dbg( p_this, ""Couldn't read full GPG key"" );
        free( p_buf );
        return NULL;
    }

    public_key_t *...",1,,934,4,,void
132967,BLOCK,-1,,<empty>,9,,939,2,,void
132981,BLOCK,-1,,<empty>,9,,944,2,,void
132994,BLOCK,-1,,"{
        vlc_stream_Delete( p_stream );
        return NULL;
    }",5,,948,2,,void
133009,BLOCK,-1,,"{
        vlc_stream_Delete( p_stream );
        return NULL;
    }",5,,955,2,,void
133031,BLOCK,-1,,"{
        msg_Dbg( p_this, ""Couldn't read full GPG key"" );
        free( p_buf );
        return NULL;
    }",5,,964,2,,void
133050,BLOCK,-1,,"{
        free( p_buf );
        return NULL;
    }",5,,972,2,,void
133075,BLOCK,-1,,"{
        msg_Dbg( p_this, ""Couldn't parse GPG key"" );
        free( p_pkey );
        return NULL;
    }",5,,983,2,,void
133091,BLOCK,-1,,"{
    char *psz_sig = (char*) malloc( strlen( psz_url ) + 4 + 1 ); /* "".asc"" + \0 */
    if( !psz_sig )
        return VLC_ENOMEM;

    strcpy( psz_sig, psz_url );
    strcat( psz_sig, "".asc"" );

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_sig );
    free( psz_sig );

    if( !p_stream )
        return VLC_ENOMEM;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return VLC_EGENERIC;
    }

    msg_Dbg( p_this, ""Downloading signature (%""PRIu64"" bytes)"", i_size );
    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return VLC_ENOMEM;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );

    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
    {
        msg_Dbg( p_this,
            ""Couldn't download full signature (only %d bytes)"", i_read );
        free( p_buf );
        return...",1,,999,4,,void
133107,BLOCK,-1,,<empty>,9,,1002,2,,void
133127,BLOCK,-1,,<empty>,9,,1011,2,,void
133140,BLOCK,-1,,"{
        vlc_stream_Delete( p_stream );
        return VLC_EGENERIC;
    }",5,,1015,2,,void
133156,BLOCK,-1,,"{
        vlc_stream_Delete( p_stream );
        return VLC_ENOMEM;
    }",5,,1023,2,,void
133178,BLOCK,-1,,"{
        msg_Dbg( p_this,
            ""Couldn't download full signature (only %d bytes)"", i_read );
        free( p_buf );
        return VLC_EGENERIC;
    }",5,,1033,2,,void
133193,BLOCK,-1,,"{
        msg_Dbg( p_this, ""Unarmoring signature"" );

        uint8_t* p_unarmored = (uint8_t*) malloc( ( i_size * 3 ) / 4 + 1 );
        if( !p_unarmored )
        {
            free( p_buf );
            return VLC_EGENERIC;
        }

        int i_bytes = pgp_unarmor( (char*)p_buf, i_size, p_unarmored, i_size );
        free( p_buf );

        p_buf = p_unarmored;
        i_size = i_bytes;

        if( i_bytes < 2 )
        {
            free( p_buf );
            msg_Dbg( p_this, ""Unarmoring failed : corrupted signature ?"" );
            return VLC_EGENERIC;
        }
    }",5,,1041,2,,void
133213,BLOCK,-1,,"{
            free( p_buf );
            return VLC_EGENERIC;
        }",9,,1046,2,,void
133240,BLOCK,-1,,"{
            free( p_buf );
            msg_Dbg( p_this, ""Unarmoring failed : corrupted signature ?"" );
            return VLC_EGENERIC;
        }",9,,1058,2,,void
133253,BLOCK,1,,<empty>,,,,3,,void
133261,BLOCK,-1,,"{
        msg_Dbg( p_this, ""Not a signature: %d"", *p_buf );
        free( p_buf );
        return VLC_EGENERIC;
    }",5,,1066,2,,void
133277,BLOCK,1,,<empty>,,,,3,,void
133304,BLOCK,-1,,"{
        free( p_buf );
        msg_Dbg( p_this, ""Invalid signature packet header"" );
        return VLC_EGENERIC;
    }",5,,1075,2,,void
133330,BLOCK,-1,,"{
        free( p_buf );
        msg_Dbg( p_this, ""Invalid signature packet"" );
        return VLC_EGENERIC;
    }",5,,1083,2,,void
133355,BLOCK,-1,,"{
        msg_Dbg( p_this, ""Couldn't parse signature"" );
        return i_ret;
    }",5,,1092,2,,void
133373,BLOCK,-1,,"{
        msg_Dbg( p_this, ""Invalid signature type: %d"", p_sig->type );
        if( p_sig->version == 4 )
        {
            free( p_sig->specific.v4.hashed_data );
            free( p_sig->specific.v4.unhashed_data );
        }
        return VLC_EGENERIC;
    }",5,,1098,2,,void
133386,BLOCK,-1,,"{
            free( p_sig->specific.v4.hashed_data );
            free( p_sig->specific.v4.unhashed_data );
        }",9,,1101,2,,void
133437,BLOCK,-1,,<empty>,1,,1,1,,ANY
133449,BLOCK,-1,,<empty>,,,,3,,<empty>
133454,BLOCK,-1,,<empty>,,,,2,,<empty>
133459,BLOCK,-1,,<empty>,,,,2,,<empty>
133485,BLOCK,-1,,"{
    return v.b_bool ? w.b_bool ? 0 : 1 : w.b_bool ? -1 : 0;
}",1,,107,3,,void
133509,BLOCK,-1,,"{
    return v.i_int == w.i_int ? 0 : v.i_int > w.i_int ? 1 : -1;
}",1,,112,3,,void
133536,BLOCK,-1,,"{
    if( !v.psz_string )
        return !w.psz_string ? 0 : -1;
    else
        return !w.psz_string ? 1 : strcmp( v.psz_string, w.psz_string );
}",1,,117,3,,void
133542,BLOCK,-1,,<empty>,9,,119,2,,void
133553,BLOCK,-1,,<empty>,9,,121,1,,void
133573,BLOCK,-1,,{ return v.f_float == w.f_float ? 0 : v.f_float > w.f_float ? 1 : -1; },53,,123,3,,void
133600,BLOCK,-1,,{ return v.p_address == w.p_address ? 0 : v.p_address > w.p_address ? 1 : -1; },55,,124,3,,void
133626,BLOCK,-1,,{ (void)p_val; /* unused */ },44,,126,2,,void
133634,BLOCK,-1,,"{
    p_val->psz_string = strdup( p_val->psz_string ? p_val->psz_string :  """" );
}",1,,128,2,,void
133652,BLOCK,-1,,{ (void)p_val; /* unused */ },45,,132,2,,void
133660,BLOCK,-1,,{ free( p_val->psz_string ); },46,,133,2,,void
133720,BLOCK,-1,,"{
    const variable_t *va = a, *vb = b;

    /* psz_name must be first */
    assert( va == (const void *)&va->psz_name );
    return strcmp( va->psz_name, vb->psz_name );
}",1,,145,3,,void
133751,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals( obj );
    variable_t **pp_var;

    vlc_mutex_lock(&priv->var_lock);
    pp_var = tfind( &psz_name, &priv->var_root, varcmp );
    return (pp_var != NULL) ? *pp_var : NULL;
}",1,,154,3,,void
133757,BLOCK,1,,<empty>,,,,2,,void
133792,BLOCK,-1,,"{
    p_var->ops->pf_free( &p_var->val );
    if( p_var->choices.i_count )
    {
        for( int i = 0 ; i < p_var->choices.i_count ; i++ )
        {
            p_var->ops->pf_free( &p_var->choices.p_values[i] );
            free( p_var->choices_text.p_values[i].psz_string );
        }
        free( p_var->choices.p_values );
        free( p_var->choices_text.p_values );
    }

    free( p_var->psz_name );
    free( p_var->psz_text );
    free( p_var->value_callbacks.p_entries );
    free( p_var );
}",1,,164,2,,void
133809,BLOCK,-1,,"{
        for( int i = 0 ; i < p_var->choices.i_count ; i++ )
        {
            p_var->ops->pf_free( &p_var->choices.p_values[i] );
            free( p_var->choices_text.p_values[i].psz_string );
        }
        free( p_var->choices.p_values );
        free( p_var->choices_text.p_values );
    }",5,,167,2,,void
133811,BLOCK,-1,,<empty>,9,,168,1,,void
133825,BLOCK,4,,"{
            p_var->ops->pf_free( &p_var->choices.p_values[i] );
            free( p_var->choices_text.p_values[i].psz_string );
        }",9,,169,4,,void
133883,BLOCK,-1,,"{
    /* Check that our variable is within the bounds */
    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_INTEGER:
            if (val->i_int < var->min.i_int)
               val->i_int = var->min.i_int;
            if (val->i_int > var->max.i_int)
                val->i_int = var->max.i_int;
            if (var->step.i_int != 0 && (val->i_int % var->step.i_int))
            {
                if (val->i_int > 0)
                    val->i_int = (val->i_int + (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
                else
                    val->i_int = (val->i_int - (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
            }
            break;

        case VLC_VAR_FLOAT:
            if (isless(val->f_float, var->min.f_float))
                val->f_float = var->min.f_float;
            if (isgreater(val->f_float, var->max.f_float))
                val->f_float = var->...",1,,190,3,,void
133890,BLOCK,-1,,"{
        case VLC_VAR_INTEGER:
            if (val->i_int < var->min.i_int)
               val->i_int = var->min.i_int;
            if (val->i_int > var->max.i_int)
                val->i_int = var->max.i_int;
            if (var->step.i_int != 0 && (val->i_int % var->step.i_int))
            {
                if (val->i_int > 0)
                    val->i_int = (val->i_int + (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
                else
                    val->i_int = (val->i_int - (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
            }
            break;

        case VLC_VAR_FLOAT:
            if (isless(val->f_float, var->min.f_float))
                val->f_float = var->min.f_float;
            if (isgreater(val->f_float, var->max.f_float))
                val->f_float = var->max.f_float;
            if (var->step.f_float != 0.f)
                val->f_float = var->step.f_flo...",5,,193,2,,void
133903,BLOCK,-1,,<empty>,16,,196,2,,void
133923,BLOCK,-1,,<empty>,17,,198,2,,void
133951,BLOCK,-1,,"{
                if (val->i_int > 0)
                    val->i_int = (val->i_int + (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
                else
                    val->i_int = (val->i_int - (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
            }",13,,200,2,,void
133958,BLOCK,-1,,<empty>,21,,202,2,,void
133987,BLOCK,-1,,<empty>,21,,205,1,,void
134028,BLOCK,-1,,<empty>,17,,212,2,,void
134048,BLOCK,-1,,<empty>,17,,214,2,,void
134066,BLOCK,-1,,<empty>,17,,216,2,,void
134093,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals(obj);

    mutex_cleanup_push(&priv->var_lock);
    while (var->b_incallback)
        vlc_cond_wait(&priv->var_wait, &priv->var_lock);
    vlc_cleanup_pop();
}",1,,226,3,,void
134099,BLOCK,1,,<empty>,,,,2,,void
134132,BLOCK,-1,,"{
    assert(obj != NULL);

    size_t count = var->value_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->value_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_value_callback(obj, name, prev, var->val,
                                     entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",1,,237,5,,void
134149,BLOCK,-1,,<empty>,9,,242,2,,void
134164,BLOCK,1,,<empty>,,,,2,,void
134187,BLOCK,-1,,<empty>,5,,251,1,,void
134237,BLOCK,-1,,"{
    assert(obj != NULL);

    size_t count = var->list_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->list_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_list_callback(obj, name, action, val,
                                      entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",1,,262,6,,void
134254,BLOCK,-1,,<empty>,9,,267,2,,void
134269,BLOCK,1,,<empty>,,,,2,,void
134292,BLOCK,-1,,<empty>,5,,276,1,,void
134338,BLOCK,-1,,"{
    assert( p_this );

    variable_t *p_var = calloc( 1, sizeof( *p_var ) );
    if( p_var == NULL )
        return VLC_ENOMEM;

    p_var->psz_name = strdup( psz_name );
    p_var->psz_text = NULL;

    p_var->i_type = i_type & ~VLC_VAR_DOINHERIT;

    p_var->i_usage = 1;

    p_var->choices.i_count = 0;
    p_var->choices.p_values = NULL;
    p_var->choices_text.i_count = 0;
    p_var->choices_text.p_values = NULL;

    p_var->b_incallback = false;
    p_var->value_callbacks = (callback_table_t){ 0, NULL };

    /* Always initialize the variable, even if it is a list variable; this
     * will lead to errors if the variable is not initialized, but it will
     * not cause crashes in the variable handling. */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_BOOL:
            p_var->ops = &bool_ops;
            p_var->val.b_bool = false;
            break;
        case VLC_VAR_INTEGER:
            p_var->ops = &int_ops;
            p_var->val.i_int = 0;
           ...",1,,299,4,,void
134353,BLOCK,-1,,<empty>,9,,304,2,,void
134426,BLOCK,-1,,"{
        case VLC_VAR_BOOL:
            p_var->ops = &bool_ops;
            p_var->val.b_bool = false;
            break;
        case VLC_VAR_INTEGER:
            p_var->ops = &int_ops;
            p_var->val.i_int = 0;
            p_var->min.i_int = INT64_MIN;
            p_var->max.i_int = INT64_MAX;
            break;
        case VLC_VAR_STRING:
            p_var->ops = &string_ops;
            p_var->val.psz_string = NULL;
            break;
        case VLC_VAR_FLOAT:
            p_var->ops = &float_ops;
            p_var->val.f_float = 0.f;
            p_var->min.f_float = -FLT_MAX;
            p_var->max.f_float = FLT_MAX;
            break;
        case VLC_VAR_COORDS:
            p_var->ops = &coords_ops;
            p_var->val.coords.x = p_var->val.coords.y = 0;
            break;
        case VLC_VAR_ADDRESS:
            p_var->ops = &addr_ops;
            p_var->val.p_address = NULL;
            break;
        case VLC_VAR_VOID:
            p_var->ops = &void_ops;
   ...",5,,325,2,,void
134577,BLOCK,-1,,<empty>,9,,362,2,,void
134591,BLOCK,1,,<empty>,,,,2,,void
134623,BLOCK,-1,,<empty>,9,,372,2,,void
134628,BLOCK,-1,,<empty>,10,,373,1,,void
134636,BLOCK,-1,,<empty>,9,,374,2,,void
134641,BLOCK,-1,,"{
        assert (((i_type ^ p_oldvar->i_type) & VLC_VAR_CLASS) == 0);
        p_oldvar->i_usage++;
        p_oldvar->i_type |= i_type & VLC_VAR_ISCOMMAND;
    }",5,,376,1,,void
134672,BLOCK,-1,,<empty>,9,,385,2,,void
134682,BLOCK,-1,,"{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
        msg_Dbg( p_this, ""attempt to destroy nonexistent variable \""%s\"""",
                 psz_name );
    else if( --p_var->i_usage == 0 )
    {
        assert(!p_var->b_incallback);
        tdelete( p_var, &p_priv->var_root, varcmp );
    }
    else
    {
        assert(p_var->i_usage != -1u);
        p_var = NULL;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    if( p_var != NULL )
        Destroy( p_var );
}",1,,399,3,,void
134691,BLOCK,1,,<empty>,,,,2,,void
134707,BLOCK,-1,,<empty>,9,,408,2,,void
134713,BLOCK,-1,,<empty>,10,,410,1,,void
134721,BLOCK,-1,,"{
        assert(!p_var->b_incallback);
        tdelete( p_var, &p_priv->var_root, varcmp );
    }",5,,411,2,,void
134735,BLOCK,-1,,"{
        assert(p_var->i_usage != -1u);
        p_var = NULL;
    }",5,,416,1,,void
134755,BLOCK,-1,,<empty>,9,,423,2,,void
134762,BLOCK,-1,,"{
    Destroy( var );
}",1,,427,2,,void
134769,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals( obj );

    tdestroy( priv->var_root, CleanupVar );
    priv->var_root = NULL;
}",1,,432,2,,void
134775,BLOCK,1,,<empty>,,,,2,,void
134800,BLOCK,-1,,"{
    int ret = VLC_SUCCESS;
    variable_t *p_var;
    vlc_value_t oldval;
    vlc_value_t newval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    switch( i_action )
    {
        case VLC_VAR_GETMIN:
            *p_val = p_var->min;
            break;
        case VLC_VAR_GETMAX:
            *p_val = p_var->max;
            break;
        case VLC_VAR_SETMINMAX:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->min = *p_val;
            p_var->max = *p_val2;
            break;
        case VLC_VAR_SETSTEP:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->step = *p_val;
            CheckValue( p_var, &p_var->val );
            break;
        case VLC_VAR_GETSTEP:
            switch (p_var->i_type & VLC_VAR_TYPE)
            {
                cas...",1,,451,6,,void
134815,BLOCK,1,,<empty>,,,,2,,void
134831,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }",5,,463,2,,void
134841,BLOCK,-1,,"{
        case VLC_VAR_GETMIN:
            *p_val = p_var->min;
            break;
        case VLC_VAR_GETMAX:
            *p_val = p_var->max;
            break;
        case VLC_VAR_SETMINMAX:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->min = *p_val;
            p_var->max = *p_val2;
            break;
        case VLC_VAR_SETSTEP:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->step = *p_val;
            CheckValue( p_var, &p_var->val );
            break;
        case VLC_VAR_GETSTEP:
            switch (p_var->i_type & VLC_VAR_TYPE)
            {
                case VLC_VAR_INTEGER:
                    if (p_var->step.i_int == 0)
                        ret = VLC_EGENERIC;
                    break;
                case VLC_VAR_FLOAT:
                    if (p_var->step.f_float == 0.f)
                        ret = VLC_EGENERIC;
                    break;
                default:
                    ret = VLC_EGENERIC;
   ...",5,,469,2,,void
134914,BLOCK,-1,,"{
                case VLC_VAR_INTEGER:
                    if (p_var->step.i_int == 0)
                        ret = VLC_EGENERIC;
                    break;
                case VLC_VAR_FLOAT:
                    if (p_var->step.f_float == 0.f)
                        ret = VLC_EGENERIC;
                    break;
                default:
                    ret = VLC_EGENERIC;
            }",13,,488,2,,void
134925,BLOCK,-1,,<empty>,25,,491,2,,void
134940,BLOCK,-1,,<empty>,25,,495,2,,void
134953,BLOCK,-1,,<empty>,17,,501,2,,void
134963,BLOCK,28,,"{
            int i = p_var->choices.i_count;

            TAB_APPEND(p_var->choices.i_count,
                       p_var->choices.p_values, *p_val);
            assert(i == p_var->choices_text.i_count);
            TAB_APPEND(p_var->choices_text.i_count,
                       p_var->choices_text.p_values, *p_val);
            p_var->ops->pf_dup( &p_var->choices.p_values[i] );
            p_var->choices_text.p_values[i].psz_string =
                ( p_val2 && p_val2->psz_string ) ?
                strdup( p_val2->psz_string ) : NULL;

            TriggerListCallback(p_this, p_var, psz_name, VLC_VAR_ADDCHOICE, p_val);
            break;
        }",9,,504,28,,void
135050,BLOCK,31,,"{
            int i;

            for( i = 0 ; i < p_var->choices.i_count ; i++ )
                if( p_var->ops->pf_cmp( p_var->choices.p_values[i], *p_val ) == 0 )
                    break;

            if( i == p_var->choices.i_count )
            {
                /* Not found */
                vlc_mutex_unlock( &p_priv->var_lock );
                return VLC_EGENERIC;
            }

            p_var->ops->pf_free( &p_var->choices.p_values[i] );
            free( p_var->choices_text.p_values[i].psz_string );
            TAB_ERASE(p_var->choices.i_count, p_var->choices.p_values, i);
            TAB_ERASE(p_var->choices_text.i_count,
                      p_var->choices_text.p_values, i);

            TriggerListCallback(p_this, p_var, psz_name, VLC_VAR_DELCHOICE, p_val);
            break;
        }",9,,521,31,,void
135053,BLOCK,-1,,<empty>,13,,524,1,,void
135084,BLOCK,-1,,<empty>,21,,526,2,,void
135094,BLOCK,-1,,"{
                /* Not found */
                vlc_mutex_unlock( &p_priv->var_lock );
                return VLC_EGENERIC;
            }",13,,529,2,,void
135172,BLOCK,-1,,<empty>,13,,548,1,,void
135201,BLOCK,-1,,<empty>,13,,550,1,,void
135231,BLOCK,-1,,<empty>,42,,553,2,,void
135244,BLOCK,-1,,<empty>,47,,554,2,,void
135369,BLOCK,-1,,"{
                p_val2->p_list = xmalloc( sizeof(vlc_list_t) );
                p_val2->p_list->p_values =
                    xmalloc( p_var->choices.i_count * sizeof(vlc_value_t) );
                p_val2->p_list->i_type = VLC_VAR_STRING;
                p_val2->p_list->i_count = p_var->choices.i_count;
            }",13,,582,2,,void
135411,BLOCK,-1,,<empty>,13,,589,1,,void
135425,BLOCK,4,,"{
                p_val->p_list->p_values[i] = p_var->choices.p_values[i];
                p_var->ops->pf_dup( &p_val->p_list->p_values[i] );
                if( p_val2 )
                {
                    p_val2->p_list->p_values[i].psz_string =
                        p_var->choices_text.p_values[i].psz_string ?
                    strdup(p_var->choices_text.p_values[i].psz_string) : NULL;
                }
            }",13,,590,4,,void
135457,BLOCK,-1,,"{
                    p_val2->p_list->p_values[i].psz_string =
                        p_var->choices_text.p_values[i].psz_string ?
                    strdup(p_var->choices_text.p_values[i].psz_string) : NULL;
                }",17,,594,2,,void
135502,BLOCK,-1,,<empty>,17,,604,2,,void
135512,BLOCK,-1,,<empty>,17,,606,1,,void
135551,BLOCK,-1,,"{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );
    assert( p_val );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    WaitUnused( p_this, p_var );

    /* Duplicated data if needed */
    //p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* depending of the action requiered */
    switch( i_action )
    {
    case VLC_VAR_BOOL_TOGGLE:
        assert( ( p_var->i_type & VLC_VAR_BOOL ) == VLC_VAR_BOOL );
        p_var->val.b_bool = !p_var->val.b_bool;
        break;
    case VLC_VAR_INTEGER_ADD:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int += p_val->i_int;
        break;
    case VLC_VAR_INTEGER_OR:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int |= p_...",1,,633,5,,void
135563,BLOCK,1,,<empty>,,,,2,,void
135579,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }",5,,644,2,,void
135597,BLOCK,-1,,"{
    case VLC_VAR_BOOL_TOGGLE:
        assert( ( p_var->i_type & VLC_VAR_BOOL ) == VLC_VAR_BOOL );
        p_var->val.b_bool = !p_var->val.b_bool;
        break;
    case VLC_VAR_INTEGER_ADD:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int += p_val->i_int;
        break;
    case VLC_VAR_INTEGER_OR:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int |= p_val->i_int;
        break;
    case VLC_VAR_INTEGER_NAND:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int &= ~p_val->i_int;
        break;
    default:
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_EGENERIC;
    }",5,,659,2,,void
135719,BLOCK,-1,,"{
    variable_t *p_var;
    int i_type = 0;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        i_type = p_var->i_type;
        if( p_var->choices.i_count > 0 )
            i_type |= VLC_VAR_HASCHOICE;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    return i_type;
}",1,,701,3,,void
135732,BLOCK,1,,<empty>,,,,2,,void
135748,BLOCK,-1,,"{
        i_type = p_var->i_type;
        if( p_var->choices.i_count > 0 )
            i_type |= VLC_VAR_HASCHOICE;
    }",5,,711,2,,void
135762,BLOCK,-1,,<empty>,13,,714,2,,void
135780,BLOCK,-1,,"{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    assert( expected_type == 0 ||
            (p_var->i_type & VLC_VAR_CLASS) == expected_type );
    assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

    WaitUnused( p_this, p_var );

    /* Duplicate data if needed */
    p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* Check boundaries and list */
    CheckValue( p_var, &val );

    /* Set the variable */
    p_var->val = val;

    /* Deal with callbacks */
    TriggerCallback( p_this, p_var, psz_name, oldval );

    /* Free data if needed */
    p_var->ops->pf_free( &oldval );

    vlc_mutex_unlock( &p_priv->var_lock );
    return VLC_SUCCESS;
}",1,,724,5,,void
135790,BLOCK,1,,<empty>,,,,2,,void
135806,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }",5,,734,2,,void
135885,BLOCK,-1,,"{
    return var_SetChecked( p_this, psz_name, 0, val );
}",1,,776,4,,void
135899,BLOCK,-1,,"{
    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var;
    int err = VLC_SUCCESS;

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        assert( expected_type == 0 ||
                (p_var->i_type & VLC_VAR_CLASS) == expected_type );
        assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

        /* Really get the variable */
        *p_val = p_var->val;

        /* Duplicate value if needed */
        p_var->ops->pf_dup( p_val );
    }
    else
        err = VLC_ENOVAR;

    vlc_mutex_unlock( &p_priv->var_lock );
    return err;
}",1,,783,5,,void
135907,BLOCK,1,,<empty>,,,,2,,void
135928,BLOCK,-1,,"{
        assert( expected_type == 0 ||
                (p_var->i_type & VLC_VAR_CLASS) == expected_type );
        assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

        /* Really get the variable */
        *p_val = p_var->val;

        /* Duplicate value if needed */
        p_var->ops->pf_dup( p_val );
    }",5,,792,2,,void
135963,BLOCK,-1,,<empty>,9,,804,1,,void
135980,BLOCK,-1,,"{
    return var_GetChecked( p_this, psz_name, 0, p_val );
}",1,,820,4,,void
135998,BLOCK,-1,,"{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot add callback %p to nonexistent variable '%s'"",
                 entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;
    TAB_APPEND(p_table->i_entries, p_table->p_entries, entry);

    vlc_mutex_unlock( &p_priv->var_lock );
}",1,,832,5,,void
136007,BLOCK,1,,<empty>,,,,2,,void
136023,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot add callback %p to nonexistent variable '%s'"",
                 entry.p_callback, psz_name );
        return;
    }",5,,841,2,,void
136045,BLOCK,-1,,<empty>,9,,852,2,,void
136053,BLOCK,-1,,<empty>,9,,854,1,,void
136080,BLOCK,-1,,"{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_value_callback);
}",1,,879,5,,void
136104,BLOCK,-1,,"{
    int i_entry;
    variable_t *p_var;
#ifndef NDEBUG
    bool b_found_similar = false;
#endif

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot delete callback %p from nonexistent ""
                 ""variable '%s'"", entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;

    for( i_entry = p_table->i_entries ; i_entry-- ; )
    {
        if( p_table->p_entries[i_entry].p_callback == entry.p_callback
            && p_table->p_entries[i_entry].p_data == entry.p_data )
        {
            break;
        }
#ifndef NDEBUG
        else if( p_table->p_entries[i_entry].p_callback == entry.p_callback )
        ...",1,,889,5,,void
136118,BLOCK,1,,<empty>,,,,2,,void
136134,BLOCK,-1,,"{
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot delete callback %p from nonexistent ""
                 ""variable '%s'"", entry.p_callback, psz_name );
        return;
    }",5,,902,2,,void
136156,BLOCK,-1,,<empty>,9,,913,2,,void
136164,BLOCK,-1,,<empty>,9,,915,1,,void
136172,BLOCK,-1,,<empty>,5,,917,1,,void
136180,BLOCK,4,,"{
        if( p_table->p_entries[i_entry].p_callback == entry.p_callback
            && p_table->p_entries[i_entry].p_data == entry.p_data )
        {
            break;
        }
#ifndef NDEBUG
        else if( p_table->p_entries[i_entry].p_callback == entry.p_callback )
            b_found_similar = true;
#endif
    }",5,,918,4,,void
136205,BLOCK,-1,,"{
            break;
        }",9,,921,2,,void
136208,BLOCK,-1,,<empty>,14,,925,1,,void
136221,BLOCK,-1,,<empty>,13,,926,2,,void
136229,BLOCK,-1,,"{
#ifndef NDEBUG
        if( b_found_similar )
            fprintf( stderr, ""Calling var_DelCallback for '%s' with the same ""
                             ""function but not the same data."", psz_name );
        vlc_assert_unreachable();
#endif
        vlc_mutex_unlock( &p_priv->var_lock );
        return;
    }",5,,931,2,,void
136232,BLOCK,-1,,<empty>,13,,934,2,,void
136264,BLOCK,-1,,"{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_value_callback);
}",1,,956,5,,void
136286,BLOCK,-1,,"{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        WaitUnused( p_this, p_var );

        /* Deal with callbacks. Tell we're in a callback, release the lock,
         * call stored functions, retake the lock. */
        TriggerCallback( p_this, p_var, psz_name, p_var->val );
    }
    vlc_mutex_unlock( &p_priv->var_lock );
}",1,,972,3,,void
136292,BLOCK,1,,<empty>,,,,2,,void
136309,BLOCK,-1,,"{
        WaitUnused( p_this, p_var );

        /* Deal with callbacks. Tell we're in a callback, release the lock,
         * call stored functions, retake the lock. */
        TriggerCallback( p_this, p_var, psz_name, p_var->val );
    }",5,,976,2,,void
136332,BLOCK,-1,,"{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_list_callback);
}",1,,997,5,,void
136356,BLOCK,-1,,"{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_list_callback);
}",1,,1013,5,,void
136379,BLOCK,-1,,"{
    char *psz_name, *psz_value;
    int  i_type;
    bool b_isno = false;
    vlc_value_t val;

    val.psz_string = NULL;

    /* It's too much of a hassle to remove the ':' when we parse
     * the cmd line :) */
    if( psz_option[0] == ':' )
        psz_option++;

    if( !psz_option[0] )
        return;

    psz_name = strdup( psz_option );
    if( psz_name == NULL )
        return;

    psz_value = strchr( psz_name, '=' );
    if( psz_value != NULL )
        *psz_value++ = '\0';

    i_type = config_GetType( psz_name );
    if( !i_type && !psz_value )
    {
        /* check for ""no-foo"" or ""nofoo"" */
        if( !strncmp( psz_name, ""no-"", 3 ) )
        {
            memmove( psz_name, psz_name + 3, strlen(psz_name) + 1 - 3 );
        }
        else if( !strncmp( psz_name, ""no"", 2 ) )
        {
            memmove( psz_name, psz_name + 2, strlen(psz_name) + 1 - 2 );
        }
        else goto cleanup;           /* Option doesn't exist */

        b_isno = true;
        i_typ...",1,,1033,4,,void
136399,BLOCK,-1,,<empty>,9,,1044,2,,void
136407,BLOCK,-1,,<empty>,9,,1047,2,,void
136417,BLOCK,-1,,<empty>,9,,1051,2,,void
136428,BLOCK,-1,,<empty>,9,,1055,2,,void
136444,BLOCK,-1,,"{
        /* check for ""no-foo"" or ""nofoo"" */
        if( !strncmp( psz_name, ""no-"", 3 ) )
        {
            memmove( psz_name, psz_name + 3, strlen(psz_name) + 1 - 3 );
        }
        else if( !strncmp( psz_name, ""no"", 2 ) )
        {
            memmove( psz_name, psz_name + 2, strlen(psz_name) + 1 - 2 );
        }
        else goto cleanup;           /* Option doesn't exist */

        b_isno = true;
        i_type = config_GetType( psz_name );
    }",5,,1059,2,,void
136451,BLOCK,-1,,"{
            memmove( psz_name, psz_name + 3, strlen(psz_name) + 1 - 3 );
        }",9,,1062,2,,void
136464,BLOCK,-1,,<empty>,14,,1065,1,,void
136471,BLOCK,-1,,"{
            memmove( psz_name, psz_name + 2, strlen(psz_name) + 1 - 2 );
        }",9,,1066,2,,void
136484,BLOCK,-1,,<empty>,14,,1069,1,,void
136496,BLOCK,-1,,<empty>,19,,1074,2,,void
136509,BLOCK,-1,,<empty>,41,,1077,2,,void
136518,BLOCK,-1,,"{
        msg_Err( p_obj, ""unsafe option \""%s\"" has been ignored for ""
                        ""security reasons"", psz_name );
        free( psz_name );
        return;
    }",5,,1081,2,,void
136532,BLOCK,-1,,"{
    case VLC_VAR_BOOL:
        val.b_bool = !b_isno;
        break;

    case VLC_VAR_INTEGER:
        val.i_int = strtoll( psz_value, NULL, 0 );
        break;

    case VLC_VAR_FLOAT:
        val.f_float = us_atof( psz_value );
        break;

    case VLC_VAR_STRING:
        val.psz_string = psz_value;
        break;

    default:
        goto cleanup;
    }",5,,1094,2,,void
136585,BLOCK,-1,,"{
    int ret = VLC_SUCCESS;
    size_t preflen = strlen (pref) + 1;

    assert(mrl != NULL);
    while (*mrl != '\0')
    {
        mrl += strspn (mrl, "":;""); /* skip leading colon(s) */

        size_t len = strcspn (mrl, "":;"");
        char *buf = malloc (preflen + len);

        if (likely(buf != NULL))
        {
            /* NOTE: this does not support the ""no-<varname>"" bool syntax. */
            /* DO NOT use asprintf() here; it won't work! Think again. */
            snprintf (buf, preflen + len, ""%s%s"", pref, mrl);
            var_OptionParse (obj, buf, false);
            free (buf);
        }
        else
            ret = VLC_ENOMEM;
        mrl += len;
    }

    return ret;
}",1,,1139,4,,void
136606,BLOCK,-1,,"{
        mrl += strspn (mrl, "":;""); /* skip leading colon(s) */

        size_t len = strcspn (mrl, "":;"");
        char *buf = malloc (preflen + len);

        if (likely(buf != NULL))
        {
            /* NOTE: this does not support the ""no-<varname>"" bool syntax. */
            /* DO NOT use asprintf() here; it won't work! Think again. */
            snprintf (buf, preflen + len, ""%s%s"", pref, mrl);
            var_OptionParse (obj, buf, false);
            free (buf);
        }
        else
            ret = VLC_ENOMEM;
        mrl += len;
    }",5,,1145,2,,void
136630,BLOCK,-1,,"{
            /* NOTE: this does not support the ""no-<varname>"" bool syntax. */
            /* DO NOT use asprintf() here; it won't work! Think again. */
            snprintf (buf, preflen + len, ""%s%s"", pref, mrl);
            var_OptionParse (obj, buf, false);
            free (buf);
        }",9,,1152,2,,void
136646,BLOCK,-1,,<empty>,13,,1160,1,,void
136662,BLOCK,-1,,"{
    i_type &= VLC_VAR_CLASS;
    for( vlc_object_t *obj = p_this; obj != NULL; obj = obj->obj.parent )
    {
        if( var_GetChecked( obj, psz_name, i_type, p_val ) == VLC_SUCCESS )
            return VLC_SUCCESS;
    }

    /* else take value from config */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_STRING:
            p_val->psz_string = config_GetPsz( p_this, psz_name );
            if( !p_val->psz_string ) p_val->psz_string = strdup("""");
            break;
        case VLC_VAR_FLOAT:
            p_val->f_float = config_GetFloat( p_this, psz_name );
            break;
        case VLC_VAR_INTEGER:
            p_val->i_int = config_GetInt( p_this, psz_name );
            break;
        case VLC_VAR_BOOL:
            p_val->b_bool = config_GetInt( p_this, psz_name ) > 0;
            break;
        default:
            vlc_assert_unreachable();
        case VLC_VAR_ADDRESS:
            return VLC_ENOOBJ;
    }
    return VLC_SUCCESS;
}",1,,1175,5,,void
136667,BLOCK,-1,,<empty>,5,,1177,1,,void
136682,BLOCK,4,,"{
        if( var_GetChecked( obj, psz_name, i_type, p_val ) == VLC_SUCCESS )
            return VLC_SUCCESS;
    }",5,,1178,4,,void
136691,BLOCK,-1,,<empty>,13,,1180,2,,void
136698,BLOCK,-1,,"{
        case VLC_VAR_STRING:
            p_val->psz_string = config_GetPsz( p_this, psz_name );
            if( !p_val->psz_string ) p_val->psz_string = strdup("""");
            break;
        case VLC_VAR_FLOAT:
            p_val->f_float = config_GetFloat( p_this, psz_name );
            break;
        case VLC_VAR_INTEGER:
            p_val->i_int = config_GetInt( p_this, psz_name );
            break;
        case VLC_VAR_BOOL:
            p_val->b_bool = config_GetInt( p_this, psz_name ) > 0;
            break;
        default:
            vlc_assert_unreachable();
        case VLC_VAR_ADDRESS:
            return VLC_ENOOBJ;
    }",5,,1185,2,,void
136713,BLOCK,-1,,<empty>,38,,1188,2,,void
136768,BLOCK,-1,,"{
    char *str = var_InheritString(object, var);
    if (str == NULL)
        goto error;

    char *sep;
    unsigned n = strtoul(str, &sep, 10);
    unsigned d;

    switch (*sep) {
        case '\0':
            /* Decimal integer */
            d = 1;
            break;

        case ':':
        case '/':
            /* Decimal fraction */
            d = strtoul(sep + 1, &sep, 10);
            if (*sep != '\0')
                goto error;
            break;

        case '.': {
            /* Decimal number */
            unsigned char c;

            d = 1;
            while ((c = *(++sep)) != '\0') {
                c -= '0';

                if (c >= 10)
                    goto error;

                n = n * 10 + c;
                d *= 10;
            }
            break;
        }

        default:
            goto error;
    }

    free(str);

    if (n == 0) {
        *num = 0;
        *den = d ? 1 : 0;
    } else if (d == 0) {
        *num = 1;
        *den = 0;
   ...",1,,1218,5,,void
136779,BLOCK,-1,,<empty>,9,,1221,2,,void
136794,BLOCK,-1,,"{
        case '\0':
            /* Decimal integer */
            d = 1;
            break;

        case ':':
        case '/':
            /* Decimal fraction */
            d = strtoul(sep + 1, &sep, 10);
            if (*sep != '\0')
                goto error;
            break;

        case '.': {
            /* Decimal number */
            unsigned char c;

            d = 1;
            while ((c = *(++sep)) != '\0') {
                c -= '0';

                if (c >= 10)
                    goto error;

                n = n * 10 + c;
                d *= 10;
            }
            break;
        }

        default:
            goto error;
    }",19,,1227,2,,void
136819,BLOCK,-1,,<empty>,17,,1238,2,,void
136824,BLOCK,14,,"{
            /* Decimal number */
            unsigned char c;

            d = 1;
            while ((c = *(++sep)) != '\0') {
                c -= '0';

                if (c >= 10)
                    goto error;

                n = n * 10 + c;
                d *= 10;
            }
            break;
        }",19,,1241,14,,void
136837,BLOCK,-1,,"{
                c -= '0';

                if (c >= 10)
                    goto error;

                n = n * 10 + c;
                d *= 10;
            }",44,,1246,2,,void
136845,BLOCK,-1,,<empty>,21,,1250,2,,void
136866,BLOCK,-1,,"{
        *num = 0;
        *den = d ? 1 : 0;
    }",17,,1264,2,,void
136879,BLOCK,-1,,<empty>,12,,1267,1,,void
136884,BLOCK,-1,,"{
        *num = 1;
        *den = 0;
    }",24,,1267,2,,void
136894,BLOCK,-1,,<empty>,9,,1271,1,,void
136921,BLOCK,-1,,"{
    switch( p_val->p_list->i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_STRING:
            for( int i = 0; i < p_val->p_list->i_count; i++ )
                free( p_val->p_list->p_values[i].psz_string );
            break;
    }

    free( p_val->p_list->p_values );
    free( p_val->p_list );

    if( p_val2 != NULL )
    {
        assert( p_val2->p_list != NULL );
        assert( p_val2->p_list->i_type == VLC_VAR_STRING );

        for( int i = 0; i < p_val2->p_list->i_count; i++ )
            free( p_val2->p_list->p_values[i].psz_string );
        free( p_val2->p_list->p_values );
        free( p_val2->p_list );
    }
}",1,,1288,3,,void
136930,BLOCK,-1,,"{
        case VLC_VAR_STRING:
            for( int i = 0; i < p_val->p_list->i_count; i++ )
                free( p_val->p_list->p_values[i].psz_string );
            break;
    }",5,,1290,2,,void
136934,BLOCK,-1,,<empty>,13,,1292,1,,void
136973,BLOCK,-1,,"{
        assert( p_val2->p_list != NULL );
        assert( p_val2->p_list->i_type == VLC_VAR_STRING );

        for( int i = 0; i < p_val2->p_list->i_count; i++ )
            free( p_val2->p_list->p_values[i].psz_string );
        free( p_val2->p_list->p_values );
        free( p_val2->p_list );
    }",5,,1301,2,,void
136989,BLOCK,-1,,<empty>,9,,1305,1,,void
137029,BLOCK,-1,,"{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    const char *typename = ""unknown"";

    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_VOID:     typename = ""void"";        break;
        case VLC_VAR_BOOL:     typename = ""bool"";        break;
        case VLC_VAR_INTEGER:  typename = ""integer"";     break;
        case VLC_VAR_STRING:   typename = ""string"";      break;
        case VLC_VAR_FLOAT:    typename = ""float"";       break;
        case VLC_VAR_COORDS:   typename = ""coordinates""; break;
        case VLC_VAR_ADDRESS:  typename = ""address"";     break;
        default:               typename = ""unknown"";     break;
    }

    printf("" *-o \""%s\"" (%s"", var->psz_name, typename);
    if (var->psz_text != NULL)
        printf("", %s"", var->psz_text);
    putchar(')');
    if (var->i_type & VLC_VAR_HASCHOICE)
        fputs("", has choices"", stdout);
    if (var->i_type & VLC_VAR_...",1,,1313,4,,void
137038,BLOCK,-1,,<empty>,9,,1315,2,,void
137060,BLOCK,-1,,"{
        case VLC_VAR_VOID:     typename = ""void"";        break;
        case VLC_VAR_BOOL:     typename = ""bool"";        break;
        case VLC_VAR_INTEGER:  typename = ""integer"";     break;
        case VLC_VAR_STRING:   typename = ""string"";      break;
        case VLC_VAR_FLOAT:    typename = ""float"";       break;
        case VLC_VAR_COORDS:   typename = ""coordinates""; break;
        case VLC_VAR_ADDRESS:  typename = ""address"";     break;
        default:               typename = ""unknown"";     break;
    }",5,,1322,2,,void
137120,BLOCK,-1,,<empty>,9,,1335,2,,void
137134,BLOCK,-1,,<empty>,9,,1338,2,,void
137144,BLOCK,-1,,<empty>,9,,1340,2,,void
137154,BLOCK,-1,,<empty>,9,,1342,2,,void
137168,BLOCK,-1,,"{
        case VLC_VAR_VOID:
            break;
        case VLC_VAR_BOOL:
            printf("": %s"", var->val.b_bool ? ""true"" : ""false"");
            break;
        case VLC_VAR_INTEGER:
            printf("": %""PRId64, var->val.i_int );
            break;
        case VLC_VAR_STRING:
            printf("": \""%s\"""", var->val.psz_string );
            break;
        case VLC_VAR_FLOAT:
            printf("": %f"", var->val.f_float );
            break;
        case VLC_VAR_COORDS:
            printf("": %""PRId32""x%""PRId32,
                   var->val.coords.x, var->val.coords.y);
            break;
        case VLC_VAR_ADDRESS:
            printf("": %p"", var->val.p_address);
            break;
    }",5,,1345,2,,void
137229,BLOCK,-1,,"{
    vlc_mutex_lock(&vlc_internals(obj)->var_lock);
    if (vlc_internals(obj)->var_root == NULL)
        puts("" `-o No variables"");
    else
        twalk(vlc_internals(obj)->var_root, DumpVariable);
    vlc_mutex_unlock(&vlc_internals(obj)->var_lock);
}",1,,1372,2,,void
137234,BLOCK,1,,<empty>,,,,2,,void
137247,BLOCK,1,,<empty>,,,,2,,void
137257,BLOCK,-1,,<empty>,9,,1375,2,,void
137261,BLOCK,-1,,<empty>,9,,1377,1,,void
137265,BLOCK,1,,<empty>,,,,2,,void
137279,BLOCK,1,,<empty>,,,,2,,void
137295,BLOCK,-1,,"{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    DECL_ARRAY(char *) *names = twalk_ctx;
    char *dup = strdup(var->psz_name);
    if (dup != NULL)
        ARRAY_APPEND(*names, dup);
}",1,,1384,4,,void
137304,BLOCK,-1,,<empty>,9,,1386,2,,void
137328,BLOCK,-1,,<empty>,9,,1393,2,,void
137337,BLOCK,-1,,"{
    vlc_object_internals_t *priv = vlc_internals(obj);

    DECL_ARRAY(char *) names;
    ARRAY_INIT(names);

    twalk_ctx = &names;
    vlc_mutex_lock(&priv->var_lock);
    twalk(priv->var_root, TwalkGetNames);
    vlc_mutex_unlock(&priv->var_lock);

    if (names.i_size == 0)
        return NULL;
    ARRAY_APPEND(names, NULL);
    return names.p_elems;
}",1,,1397,2,,void
137343,BLOCK,1,,<empty>,,,,2,,void
137378,BLOCK,-1,,<empty>,9,,1409,2,,void
137398,BLOCK,-1,,<empty>,1,,1,1,,ANY
137419,BLOCK,-1,,<empty>,,,,2,,<empty>
137424,BLOCK,-1,,<empty>,,,,2,,<empty>
137429,BLOCK,-1,,<empty>,,,,2,,<empty>
137446,BLOCK,-1,,<empty>,1,,1,1,,ANY
137449,BLOCK,-1,,"{
    xml_t *p_xml;

    p_xml = vlc_custom_create( p_this, sizeof( *p_xml ), ""xml"" );

    p_xml->p_module = module_need( p_xml, ""xml"", NULL, false );
    if( !p_xml->p_module )
    {
        vlc_object_release( p_xml );
        msg_Err( p_this, ""XML provider not found"" );
        return NULL;
    }

    return p_xml;
}",1,,40,2,,void
137456,BLOCK,1,,<empty>,,,,4,,void
137478,BLOCK,-1,,"{
        vlc_object_release( p_xml );
        msg_Err( p_this, ""XML provider not found"" );
        return NULL;
    }",5,,47,2,,void
137492,BLOCK,-1,,"{
    module_unneed( p_xml, p_xml->p_module );
    vlc_object_release( p_xml );
}",1,,60,2,,void
137505,BLOCK,-1,,"{
    xml_reader_t *reader;

    reader = vlc_custom_create(obj, sizeof(*reader), ""xml reader"");

    reader->p_stream = stream;
    reader->p_module = module_need(reader, ""xml reader"", NULL, false);
    if (unlikely(reader->p_module == NULL))
    {
        msg_Err(reader, ""XML reader not found"");
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",1,,74,3,,void
137511,BLOCK,1,,<empty>,,,,3,,void
137540,BLOCK,-1,,"{
        msg_Err(reader, ""XML reader not found"");
        vlc_object_release(reader);
        return NULL;
    }",5,,82,2,,void
137554,BLOCK,-1,,"{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);
    vlc_object_release(reader);
}",1,,96,2,,void
137559,BLOCK,-1,,<empty>,9,,98,2,,void
137572,BLOCK,-1,,"{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);

    reader->p_stream = stream;
    if ((stream != NULL) && module_start(reader, reader->p_module))
    {
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",1,,116,3,,void
137577,BLOCK,-1,,<empty>,9,,118,2,,void
137598,BLOCK,-1,,"{
        vlc_object_release(reader);
        return NULL;
    }",5,,122,2,,void
137623,BLOCK,-1,,<empty>,1,,1,1,,ANY
137636,BLOCK,-1,,"{
    VLC_UNUSED (sdp); VLC_UNUSED (type); VLC_UNUSED (protocol);
    VLC_UNUSED (dport); VLC_UNUSED (pt); VLC_UNUSED (bw_indep);
    VLC_UNUSED (bw); VLC_UNUSED (ptname); VLC_UNUSED (clockrate);
    VLC_UNUSED (channels); VLC_UNUSED (fmtp);
    assert (sdp == NULL);
}",1,,48,12,,void
137669,BLOCK,-1,,"{
    VLC_UNUSED (sdp); VLC_UNUSED (name); VLC_UNUSED (fmt);
    assert (sdp == NULL);
}",1,,57,4,,void
137685,BLOCK,-1,,"{
    VLC_UNUSED (out); VLC_UNUSED (query);
    vlc_assert_unreachable ();
}",1,,63,3,,void
137695,BLOCK,-1,,"{
    VLC_UNUSED (out);
    vlc_assert_unreachable ();
}",1,,69,2,,void
137705,BLOCK,-1,,"{
    VLC_UNUSED (access); VLC_UNUSED (name);
    msg_Err (obj, ""Output support not compiled-in!"");
    return NULL;
}",1,,77,4,,void
137720,BLOCK,-1,,"{
    VLC_UNUSED (out); VLC_UNUSED (block);
    vlc_assert_unreachable ();
}",1,,84,3,,void
137731,BLOCK,-1,,"{
    VLC_UNUSED (out); VLC_UNUSED (offset);
    vlc_assert_unreachable ();
}",1,,90,3,,void
137742,BLOCK,-1,,"{
    VLC_UNUSED (out); VLC_UNUSED (block);
    vlc_assert_unreachable ();
}",1,,96,3,,void
137754,BLOCK,-1,,"{
    VLC_UNUSED (sdp); VLC_UNUSED (dst);
    msg_Err (obj, ""SDP export not compiled-in!"");
    return NULL;
}",1,,105,4,,void
137769,BLOCK,-1,,"{
    VLC_UNUSED (obj); VLC_UNUSED (d);
    vlc_assert_unreachable ();
}",1,,113,3,,void
137779,BLOCK,-1,,"{
    msg_Err (p_this, ""Encoding support not compiled-in!"");
    return NULL;
}",1,,120,2,,void
137790,BLOCK,-1,,"{
    VLC_UNUSED (mux); VLC_UNUSED (fmt);
    vlc_assert_unreachable ();
}",1,,126,3,,void
137800,BLOCK,-1,,"{
    VLC_UNUSED (mux);
    vlc_assert_unreachable ();
}",1,,132,2,,void
137809,BLOCK,-1,,"{
    VLC_UNUSED (mux); VLC_UNUSED (input);
    vlc_assert_unreachable ();
}",1,,138,3,,void
137821,BLOCK,-1,,"{
    VLC_UNUSED (p_mux); VLC_UNUSED (i_blocks); VLC_UNUSED (pi_dts);
    vlc_assert_unreachable ();
}",1,,144,4,,void
137835,BLOCK,-1,,"{
    VLC_UNUSED (instance); VLC_UNUSED (mux); VLC_UNUSED (out);
    vlc_assert_unreachable ();
}",1,,151,4,,void
137849,BLOCK,-1,,"{
    VLC_UNUSED (mux); VLC_UNUSED (input); VLC_UNUSED (block);
    vlc_assert_unreachable ();
}",1,,157,4,,void
137862,BLOCK,-1,,"{
    VLC_UNUSED (mux); VLC_UNUSED (input);
    vlc_assert_unreachable ();
}",1,,163,3,,void
137873,BLOCK,-1,,"{
    VLC_UNUSED (p_first); VLC_UNUSED (p_last);
    vlc_assert_unreachable ();
}",1,,169,3,,void
137886,BLOCK,-1,,"{
    VLC_UNUSED (p_sout); VLC_UNUSED (psz_chain); VLC_UNUSED (p_next);
    VLC_UNUSED (pp_last);
    vlc_assert_unreachable ();
}",1,,177,5,,void
137906,BLOCK,-1,,"{
    VLC_UNUSED (obj); VLC_UNUSED (cfg); VLC_UNUSED (src); VLC_UNUSED (srclen);
    VLC_UNUSED (addr); VLC_UNUSED (addrlen);
    return 0;
}",1,,186,8,,void
137926,BLOCK,-1,,"{
    VLC_UNUSED (query);
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",1,,197,3,,void
137936,BLOCK,-1,,"{
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",1,,204,2,,void
137946,BLOCK,-1,,"{
    VLC_UNUSED (vlm);
    VLC_UNUSED (cmd);
    VLC_UNUSED (pm);
    vlc_assert_unreachable ();
}",1,,210,4,,void
137959,BLOCK,-1,,"{
    VLC_UNUSED (a);
    VLC_UNUSED (b);
    vlc_assert_unreachable ();
}",1,,218,3,,void
137969,BLOCK,-1,,"{
    VLC_UNUSED (m);
    vlc_assert_unreachable ();
}",1,,225,2,,void
137977,BLOCK,-1,,"{
    VLC_UNUSED (a);
    return NULL;
}",1,,231,2,,void
137987,BLOCK,-1,,"{
    VLC_UNUSED (a);
    VLC_UNUSED (fmt);
    return vlm_MessageSimpleNew (a);
}",1,,237,3,,void
137999,BLOCK,-1,,"{
     msg_Err (obj, ""VLM not compiled-in!"");
     return NULL;
}",1,,245,2,,void
138009,BLOCK,-1,,"{
    (void) obj;
    return NULL;
}",1,,255,2,,void
138019,BLOCK,-1,,"{
    (void) u;
    vlc_assert_unreachable();
}",1,,261,2,,void
138030,BLOCK,-1,,"{
    (void) u; (void) cb; (void) opaque;
    vlc_assert_unreachable();
}",1,,267,4,,void
138045,BLOCK,-1,,"{
    (void) u;
    vlc_assert_unreachable();
}",1,,273,2,,void
138055,BLOCK,-1,,"{
    (void) u; (void) dir;
    vlc_assert_unreachable();
}",1,,279,3,,void
138067,BLOCK,-1,,"{
    (void) u;
    vlc_assert_unreachable();
}",1,,285,2,,void
138112,BLOCK,-1,,<empty>,1,,1,1,,ANY
138121,BLOCK,-1,,"{
    const vlc_modcap_t *capa = a, *capb = b;
    return strcmp(capa->name, capb->name);
}",1,,60,3,,void
138142,BLOCK,-1,,"{
    vlc_modcap_t *cap = data;

    free(cap->modv);
    free(cap->name);
    free(cap);
}",1,,66,2,,void
138162,BLOCK,-1,,"{
    const module_t *const *ma = a, *const *mb = b;
    /* Note that qsort() uses _ascending_ order,
     * so the smallest module is the one with the biggest score. */
    return (*mb)->i_score - (*ma)->i_score;
}",1,,75,3,,void
138187,BLOCK,-1,,"{
    vlc_modcap_t *const *cp = node, *cap = *cp;

    if (which != postorder && which != leaf)
        return;

    qsort(cap->modv, cap->modc, sizeof (*cap->modv), vlc_module_cmp);
    (void) depth;
}",1,,84,4,,void
138205,BLOCK,-1,,<empty>,9,,88,2,,void
138244,BLOCK,-1,,"{
    const char *name = module_get_capability(mod);
    vlc_modcap_t *cap = malloc(sizeof (*cap));
    if (unlikely(cap == NULL))
        return -1;

    cap->name = strdup(name);
    cap->modv = NULL;
    cap->modc = 0;

    if (unlikely(cap->name == NULL))
        goto error;

    vlc_modcap_t **cp = tsearch(cap, &modules.caps_tree, vlc_modcap_cmp);
    if (unlikely(cp == NULL))
        goto error;

    if (*cp != cap)
    {
        vlc_modcap_free(cap);
        cap = *cp;
    }

    module_t **modv = realloc(cap->modv, sizeof (*modv) * (cap->modc + 1));
    if (unlikely(modv == NULL))
        return -1;

    cap->modv = modv;
    cap->modv[cap->modc] = mod;
    cap->modc++;
    return 0;
error:
    vlc_modcap_free(cap);
    return -1;
}",1,,108,2,,void
138262,BLOCK,-1,,<empty>,9,,112,2,,void
138289,BLOCK,-1,,<empty>,9,,119,2,,void
138306,BLOCK,-1,,<empty>,9,,123,2,,void
138313,BLOCK,-1,,"{
        vlc_modcap_free(cap);
        cap = *cp;
    }",5,,126,2,,void
138341,BLOCK,-1,,<empty>,9,,133,2,,void
138375,BLOCK,-1,,"{
    /*vlc_assert_locked (&modules.lock);*/

    lib->next = vlc_plugins;
    vlc_plugins = lib;

    for (module_t *m = lib->module; m != NULL; m = m->next)
        vlc_module_store(m);
}",1,,148,2,,void
138385,BLOCK,-1,,<empty>,5,,154,1,,void
138406,BLOCK,-1,,"{
    /* Initializes the statically-linked library */
    vlc_plugin_t *lib = vlc_plugin_describe (entry);
    if (unlikely(lib == NULL))
        return NULL;

#ifdef HAVE_DYNAMIC_PLUGINS
    atomic_init(&lib->loaded, true);
    lib->unloadable = false;
#endif
    return lib;
}",1,,162,2,,void
138417,BLOCK,-1,,<empty>,9,,166,2,,void
138428,BLOCK,-1,,"{
    if (!vlc_static_modules)
        return;

    for (unsigned i = 0; vlc_static_modules[i]; i++)
    {
        vlc_plugin_t *lib = module_InitStatic(vlc_static_modules[i]);
        if (likely(lib != NULL))
            vlc_plugin_store(lib);
    }
}",1,,184,2,,void
138432,BLOCK,-1,,<empty>,9,,186,2,,void
138435,BLOCK,-1,,<empty>,5,,188,1,,void
138445,BLOCK,4,,"{
        vlc_plugin_t *lib = module_InitStatic(vlc_static_modules[i]);
        if (likely(lib != NULL))
            vlc_plugin_store(lib);
    }",5,,189,4,,void
138458,BLOCK,-1,,<empty>,13,,192,2,,void
138466,BLOCK,-1,,"{
    (void) obj; (void) plugin;
    return 0;
}",1,,561,3,,void
138479,BLOCK,-1,,"{
    (void) plugin;
}",1,,567,2,,void
138487,BLOCK,-1,,"{
    vlc_mutex_lock (&modules.lock);

    if (modules.usage == 0)
    {
        /* Fills the module bank structure with the core module infos.
         * This is very useful as it will allow us to consider the core
         * library just as another module, and for instance the configuration
         * options of core will be available in the module bank structure just
         * as for every other module. */
        vlc_plugin_t *plugin = module_InitStatic(vlc_entry__core);
        if (likely(plugin != NULL))
            vlc_plugin_store(plugin);
        config_SortConfig ();
    }
    modules.usage++;

    /* We do retain the module bank lock until the plugins are loaded as well.
     * This is ugly, this staged loading approach is needed: LibVLC gets
     * some configuration parameters relevant to loading the plugins from
     * the core (builtin) module. The module bank becomes shared read-only data
     * once it is ready, so we need to fully serialize initialization.
     * ...",1,,579,2,,void
138499,BLOCK,-1,,"{
        /* Fills the module bank structure with the core module infos.
         * This is very useful as it will allow us to consider the core
         * library just as another module, and for instance the configuration
         * options of core will be available in the module bank structure just
         * as for every other module. */
        vlc_plugin_t *plugin = module_InitStatic(vlc_entry__core);
        if (likely(plugin != NULL))
            vlc_plugin_store(plugin);
        config_SortConfig ();
    }",5,,583,2,,void
138510,BLOCK,-1,,<empty>,13,,591,2,,void
138522,BLOCK,-1,,"{
    vlc_plugin_t *libs = NULL;
    block_t *caches = NULL;
    void *caps_tree = NULL;

    /* If plugins were _not_ loaded, then the caller still has the bank lock
     * from module_InitBank(). */
    if( b_plugins )
        vlc_mutex_lock (&modules.lock);
    /*else
        vlc_assert_locked (&modules.lock); not for static mutexes :( */

    assert (modules.usage > 0);
    if (--modules.usage == 0)
    {
        config_UnsortConfig ();
        libs = vlc_plugins;
        caches = modules.caches;
        caps_tree = modules.caps_tree;
        vlc_plugins = NULL;
        modules.caches = NULL;
        modules.caps_tree = NULL;
    }
    vlc_mutex_unlock (&modules.lock);

    tdestroy(caps_tree, vlc_modcap_free);

    while (libs != NULL)
    {
        vlc_plugin_t *lib = libs;

        libs = lib->next;
        module_Unmap(lib);
        vlc_plugin_destroy(lib);
    }

    block_ChainRelease(caches);
}",1,,611,2,,void
138537,BLOCK,-1,,<empty>,9,,619,2,,void
138556,BLOCK,-1,,"{
        config_UnsortConfig ();
        libs = vlc_plugins;
        caches = modules.caches;
        caps_tree = modules.caps_tree;
        vlc_plugins = NULL;
        modules.caches = NULL;
        modules.caps_tree = NULL;
    }",5,,625,2,,void
138596,BLOCK,-1,,"{
        vlc_plugin_t *lib = libs;

        libs = lib->next;
        module_Unmap(lib);
        vlc_plugin_destroy(lib);
    }",5,,639,2,,void
138616,BLOCK,-1,,"{
    /*vlc_assert_locked (&modules.lock); not for static mutexes :( */

    if (modules.usage == 1)
    {
        module_InitStaticModules ();
#ifdef HAVE_DYNAMIC_PLUGINS
        msg_Dbg (obj, ""searching plug-in modules"");
        AllocateAllPlugins (obj);
#endif
        config_UnsortConfig ();
        config_SortConfig ();

        twalk(modules.caps_tree, vlc_modcap_sort);
    }
    vlc_mutex_unlock (&modules.lock);

    size_t count;
    module_t **list = module_list_get (&count);
    module_list_free (list);
    msg_Dbg (obj, ""plug-ins loaded: %zu modules"", count);
    return count;
}",1,,659,2,,void
138623,BLOCK,-1,,"{
        module_InitStaticModules ();
#ifdef HAVE_DYNAMIC_PLUGINS
        msg_Dbg (obj, ""searching plug-in modules"");
        AllocateAllPlugins (obj);
#endif
        config_UnsortConfig ();
        config_SortConfig ();

        twalk(modules.caps_tree, vlc_modcap_sort);
    }",5,,663,2,,void
138656,BLOCK,-1,,"{
    free (list);
}",1,,690,2,,void
138663,BLOCK,-1,,"{
    module_t **tab = NULL;
    size_t i = 0;

    assert (n != NULL);

    for (vlc_plugin_t *lib = vlc_plugins; lib != NULL; lib = lib->next)
    {
        module_t **nt = realloc(tab, (i + lib->modules_count) * sizeof (*tab));
        if (unlikely(nt == NULL))
        {
            free (tab);
            *n = 0;
            return NULL;
        }

        tab = nt;
        for (module_t *m = lib->module; m != NULL; m = m->next)
            tab[i++] = m;
    }
    *n = i;
    return tab;
}",1,,701,2,,void
138677,BLOCK,-1,,<empty>,5,,707,1,,void
138690,BLOCK,4,,"{
        module_t **nt = realloc(tab, (i + lib->modules_count) * sizeof (*tab));
        if (unlikely(nt == NULL))
        {
            free (tab);
            *n = 0;
            return NULL;
        }

        tab = nt;
        for (module_t *m = lib->module; m != NULL; m = m->next)
            tab[i++] = m;
    }",5,,708,4,,void
138710,BLOCK,-1,,"{
            free (tab);
            *n = 0;
            return NULL;
        }",9,,711,2,,void
138723,BLOCK,-1,,<empty>,9,,718,1,,void
138755,BLOCK,-1,,"{
    const vlc_modcap_t **cp = tfind(&name, &modules.caps_tree, vlc_modcap_cmp);
    if (cp == NULL)
    {
        *list = NULL;
        return 0;
    }

    const vlc_modcap_t *cap = *cp;
    size_t n = cap->modc;
    module_t **tab = vlc_alloc (n, sizeof (*tab));
    *list = tab;
    if (unlikely(tab == NULL))
        return -1;

    memcpy(tab, cap->modv, sizeof (*tab) * n);
    return n;
}",1,,734,3,,void
138771,BLOCK,-1,,"{
        *list = NULL;
        return 0;
    }",5,,737,2,,void
138806,BLOCK,-1,,<empty>,9,,747,2,,void
138862,BLOCK,-1,,<empty>,1,,1,1,,ANY
138891,BLOCK,-1,,<empty>,1,,1,1,,ANY
138894,BLOCK,-1,,"{
    module_t *module = malloc (sizeof (*module));
    if (module == NULL)
        return NULL;

    /* NOTE XXX: For backward compatibility with preferences UIs, the first
     * module must stay first. That defines under which module, the
     * configuration items of the plugin belong. The order of the following
     * entries is irrelevant. */
    module_t *parent = plugin->module;
    if (parent == NULL)
    {
        module->next = NULL;
        plugin->module = module;
    }
    else
    {
        module->next = parent->next;
        parent->next = module;
    }

    plugin->modules_count++;
    module->plugin = plugin;

    module->psz_shortname = NULL;
    module->psz_longname = NULL;
    module->psz_help = NULL;
    module->pp_shortcuts = NULL;
    module->i_shortcuts = 0;
    module->psz_capability = NULL;
    module->i_score = (parent != NULL) ? parent->i_score : 1;
    module->activate_name = NULL;
    module->deactivate_name = NULL;
    module->pf_activate = NULL;
   ...",1,,42,2,,void
138906,BLOCK,-1,,<empty>,9,,45,2,,void
138919,BLOCK,-1,,"{
        module->next = NULL;
        plugin->module = module;
    }",5,,53,2,,void
138931,BLOCK,-1,,"{
        module->next = parent->next;
        parent->next = module;
    }",5,,58,1,,void
139021,BLOCK,-1,,"{
    while (module != NULL)
    {
        module_t *next = module->next;

        free(module->pp_shortcuts);
        free(module);
        module = next;
    }
}",1,,84,2,,void
139026,BLOCK,-1,,"{
        module_t *next = module->next;

        free(module->pp_shortcuts);
        free(module);
        module = next;
    }",5,,86,2,,void
139046,BLOCK,-1,,"{
    vlc_plugin_t *plugin = malloc(sizeof (*plugin));
    if (unlikely(plugin == NULL))
        return NULL;

    plugin->modules_count = 0;
    plugin->textdomain = NULL;
    plugin->conf.items = NULL;
    plugin->conf.size = 0;
    plugin->conf.count = 0;
    plugin->conf.booleans = 0;
#ifdef HAVE_DYNAMIC_PLUGINS
    plugin->abspath = NULL;
    atomic_init(&plugin->loaded, false);
    plugin->unloadable = true;
    plugin->handle = NULL;
    plugin->abspath = NULL;
    plugin->path = NULL;
#endif
    plugin->module = NULL;

    return plugin;
}",1,,96,2,,void
139059,BLOCK,-1,,<empty>,9,,99,2,,void
139111,BLOCK,-1,,"{
    assert(plugin != NULL);
#ifdef HAVE_DYNAMIC_PLUGINS
    assert(!plugin->unloadable || !atomic_load(&plugin->loaded));
#endif

    if (plugin->module != NULL)
        vlc_module_destroy(plugin->module);

    config_Free(plugin->conf.items, plugin->conf.size);
#ifdef HAVE_DYNAMIC_PLUGINS
    free(plugin->abspath);
    free(plugin->path);
#endif
    free(plugin);
}",1,,126,2,,void
139122,BLOCK,-1,,<empty>,9,,133,2,,void
139145,BLOCK,-1,,"{
    unsigned confsize = plugin->conf.size;
    module_config_t *tab = plugin->conf.items;

    if ((confsize & 0xf) == 0)
    {
        tab = realloc_or_free (tab, (confsize + 17) * sizeof (*tab));
        if (tab == NULL)
            return NULL;

        plugin->conf.items = tab;
    }

    memset (tab + confsize, 0, sizeof (tab[confsize]));
    tab += confsize;
    tab->owner = plugin;

    if (IsConfigIntegerType (type))
    {
        tab->max.i = INT64_MAX;
        tab->min.i = INT64_MIN;
    }
    else if( IsConfigFloatType (type))
    {
        tab->max.f = FLT_MAX;
        tab->min.f = -FLT_MAX;
    }
    tab->i_type = type;

    if (CONFIG_ITEM(type))
    {
        plugin->conf.count++;
        if (type == CONFIG_ITEM_BOOL)
            plugin->conf.booleans++;
    }
    plugin->conf.size++;

    return tab;
}",1,,144,3,,void
139168,BLOCK,-1,,"{
        tab = realloc_or_free (tab, (confsize + 17) * sizeof (*tab));
        if (tab == NULL)
            return NULL;

        plugin->conf.items = tab;
    }",5,,149,2,,void
139184,BLOCK,-1,,<empty>,13,,152,2,,void
139214,BLOCK,1,,<empty>,,,,2,,void
139220,BLOCK,-1,,"{
        tab->max.i = INT64_MAX;
        tab->min.i = INT64_MIN;
    }",5,,162,2,,void
139236,BLOCK,-1,,<empty>,10,,166,1,,void
139240,BLOCK,1,,<empty>,,,,2,,void
139244,BLOCK,-1,,"{
        tab->max.f = FLT_MAX;
        tab->min.f = -FLT_MAX;
    }",5,,167,2,,void
139268,BLOCK,-1,,"{
        plugin->conf.count++;
        if (type == CONFIG_ITEM_BOOL)
            plugin->conf.booleans++;
    }",5,,174,2,,void
139279,BLOCK,-1,,<empty>,13,,177,2,,void
139300,BLOCK,-1,,"{
    vlc_plugin_t *plugin = ctx;
    module_t *module = tgt;
    module_config_t *item = tgt;
    va_list ap;
    int ret = 0;

    va_start (ap, propid);
    switch (propid)
    {
        case VLC_MODULE_CREATE:
        {
            module_t *super = plugin->module;
            module_t *submodule = vlc_module_create(plugin);
            if (unlikely(submodule == NULL))
            {
                ret = -1;
                break;
            }

            *(va_arg (ap, module_t **)) = submodule;
            if (super == NULL)
                break;

            /* Inheritance. Ugly!! */
            submodule->pp_shortcuts = xmalloc (sizeof ( *submodule->pp_shortcuts ));
            submodule->pp_shortcuts[0] = super->pp_shortcuts[0];
            submodule->i_shortcuts = 1; /* object name */

            submodule->psz_shortname = super->psz_shortname;
            submodule->psz_longname = super->psz_longname;
            submodule->psz_capability = super->psz_capability;
     ...",1,,191,4,,void
139323,BLOCK,-1,,"{
        case VLC_MODULE_CREATE:
        {
            module_t *super = plugin->module;
            module_t *submodule = vlc_module_create(plugin);
            if (unlikely(submodule == NULL))
            {
                ret = -1;
                break;
            }

            *(va_arg (ap, module_t **)) = submodule;
            if (super == NULL)
                break;

            /* Inheritance. Ugly!! */
            submodule->pp_shortcuts = xmalloc (sizeof ( *submodule->pp_shortcuts ));
            submodule->pp_shortcuts[0] = super->pp_shortcuts[0];
            submodule->i_shortcuts = 1; /* object name */

            submodule->psz_shortname = super->psz_shortname;
            submodule->psz_longname = super->psz_longname;
            submodule->psz_capability = super->psz_capability;
            break;
        }

        case VLC_CONFIG_CREATE:
        {
            int type = va_arg (ap, int);
            module_config_t **pp = va_arg (ap, module_config_t **);

   ...",5,,200,2,,void
139326,BLOCK,3,,"{
            module_t *super = plugin->module;
            module_t *submodule = vlc_module_create(plugin);
            if (unlikely(submodule == NULL))
            {
                ret = -1;
                break;
            }

            *(va_arg (ap, module_t **)) = submodule;
            if (super == NULL)
                break;

            /* Inheritance. Ugly!! */
            submodule->pp_shortcuts = xmalloc (sizeof ( *submodule->pp_shortcuts ));
            submodule->pp_shortcuts[0] = super->pp_shortcuts[0];
            submodule->i_shortcuts = 1; /* object name */

            submodule->psz_shortname = super->psz_shortname;
            submodule->psz_longname = super->psz_longname;
            submodule->psz_capability = super->psz_capability;
            break;
        }",9,,202,3,,void
139343,BLOCK,-1,,"{
                ret = -1;
                break;
            }",13,,206,2,,void
139354,BLOCK,-1,,<empty>,17,,213,2,,void
139406,BLOCK,6,,"{
            int type = va_arg (ap, int);
            module_config_t **pp = va_arg (ap, module_config_t **);

            item = vlc_config_create(plugin, type);
            if (unlikely(item == NULL))
            {
                ret = -1;
                break;
            }
            *pp = item;
            break;
        }",9,,227,6,,void
139419,BLOCK,-1,,"{
                ret = -1;
                break;
            }",13,,233,2,,void
139432,BLOCK,9,,"{
            unsigned i_shortcuts = va_arg (ap, unsigned);
            unsigned index = module->i_shortcuts;
            /* The cache loader accept only a small number of shortcuts */
            assert(i_shortcuts + index <= MODULE_SHORTCUT_MAX);

            const char *const *tab = va_arg (ap, const char *const *);
            const char **pp = realloc (module->pp_shortcuts,
                                       sizeof (pp[0]) * (index + i_shortcuts));
            if (unlikely(pp == NULL))
            {
                ret = -1;
                break;
            }
            module->pp_shortcuts = pp;
            module->i_shortcuts = index + i_shortcuts;
            pp += index;
            for (unsigned i = 0; i < i_shortcuts; i++)
                pp[i] = tab[i];
            break;
        }",9,,242,9,,void
139446,BLOCK,1,,<empty>,,,,1,,void
139469,BLOCK,-1,,"{
                ret = -1;
                break;
            }",13,,252,2,,void
139491,BLOCK,-1,,<empty>,13,,259,1,,void
139532,BLOCK,33,,"{
            const char *value = va_arg (ap, const char *);

            assert (module->i_shortcuts == 0);
            module->pp_shortcuts = malloc( sizeof( *module->pp_shortcuts ) );
            module->pp_shortcuts[0] = value;
            module->i_shortcuts = 1;

            assert (module->psz_longname == NULL);
            module->psz_longname = value;
            break;
        }",9,,289,33,,void
139592,BLOCK,52,,"{
            const char *name = va_arg (ap, const char *);

            assert (name != NULL);
            item->psz_name = name;
            break;
        }",9,,320,52,,void
139606,BLOCK,55,,"{
            if (IsConfigIntegerType (item->i_type)
             || !CONFIG_ITEM(item->i_type))
            {
                item->orig.i =
                item->value.i = va_arg (ap, int64_t);
            }
            else
            if (IsConfigFloatType (item->i_type))
            {
                item->orig.f =
                item->value.f = va_arg (ap, double);
            }
            else
            if (IsConfigStringType (item->i_type))
            {
                const char *value = va_arg (ap, const char *);
                item->value.psz = value ? strdup (value) : NULL;
                item->orig.psz = (char *)value;
            }
            break;
        }",9,,329,55,,void
139613,BLOCK,1,,<empty>,,,,3,,void
139626,BLOCK,-1,,"{
                item->orig.i =
                item->value.i = va_arg (ap, int64_t);
            }",13,,332,2,,void
139643,BLOCK,-1,,<empty>,13,,337,1,,void
139649,BLOCK,1,,<empty>,,,,3,,void
139655,BLOCK,-1,,"{
                item->orig.f =
                item->value.f = va_arg (ap, double);
            }",13,,338,2,,void
139658,BLOCK,-1,,<empty>,13,,343,1,,void
139664,BLOCK,1,,<empty>,,,,3,,void
139672,BLOCK,-1,,"{
                const char *value = va_arg (ap, const char *);
                item->value.psz = value ? strdup (value) : NULL;
                item->orig.psz = (char *)value;
            }",13,,344,2,,void
139697,BLOCK,58,,"{
            if (IsConfigFloatType (item->i_type))
            {
                item->min.f = va_arg (ap, double);
                item->max.f = va_arg (ap, double);
            }
            else
            {
                item->min.i = va_arg (ap, int64_t);
                item->max.i = va_arg (ap, int64_t);
            }
            break;
        }",9,,353,58,,void
139703,BLOCK,1,,<empty>,,,,3,,void
139709,BLOCK,-1,,"{
                item->min.f = va_arg (ap, double);
                item->max.f = va_arg (ap, double);
            }",13,,355,2,,void
139713,BLOCK,-1,,"{
                item->min.i = va_arg (ap, int64_t);
                item->max.i = va_arg (ap, int64_t);
            }",13,,360,1,,void
139788,BLOCK,94,,"{
            size_t len = va_arg (ap, size_t);

            assert (item->list_count == 0); /* cannot replace choices */
            assert (item->list.psz_cb == NULL);
            if (len == 0)
                break; /* nothing to do */
            /* Copy values */
            if (IsConfigIntegerType (item->i_type))
                item->list.i = va_arg(ap, const int *);
            else
            if (IsConfigStringType (item->i_type))
            {
                const char *const *src = va_arg (ap, const char *const *);
                const char **dst = xmalloc (sizeof (const char *) * len);

                memcpy(dst, src, sizeof (const char *) * len);
                item->list.psz = dst;
            }
            else
                break;

            /* Copy textual descriptions */
            /* XXX: item->list_text[len + 1] is probably useless. */
            const char *const *text = va_arg (ap, const char *const *);
            const char **dtext = xmalloc (sizeo...",9,,401,94,,void
139813,BLOCK,-1,,<empty>,17,,407,2,,void
139849,BLOCK,97,,"{
            void *cb;

            item->list_cb_name = va_arg(ap, const char *);
            cb = va_arg(ap, void *);

            if (IsConfigIntegerType (item->i_type))
               item->list.i_cb = cb;
            else
            if (IsConfigStringType (item->i_type))
               item->list.psz_cb = cb;
            else
                break;
            break;
        }",9,,435,97,,void
139858,BLOCK,1,,<empty>,,,,3,,void
139866,BLOCK,-1,,<empty>,16,,442,2,,void
139875,BLOCK,-1,,<empty>,13,,444,1,,void
139881,BLOCK,1,,<empty>,,,,3,,void
139889,BLOCK,-1,,<empty>,16,,445,2,,void
139898,BLOCK,-1,,<empty>,17,,447,1,,void
139922,BLOCK,-1,,"{
    vlc_plugin_t *plugin = vlc_plugin_create();
    if (unlikely(plugin == NULL))
        return NULL;

    if (entry(vlc_plugin_desc_cb, plugin) != 0)
    {
        vlc_plugin_destroy(plugin); /* partially initialized plug-in... */
        plugin = NULL;
    }
    return plugin;
}",1,,468,2,,void
139932,BLOCK,-1,,<empty>,9,,471,2,,void
139941,BLOCK,-1,,"{
        vlc_plugin_destroy(plugin); /* partially initialized plug-in... */
        plugin = NULL;
    }",5,,474,2,,void
139957,BLOCK,-1,,"{
    const struct vlc_plugin_symbol *sa = a , *sb = b;

    return strcmp(sa->name, sb->name);
}",1,,488,3,,void
139980,BLOCK,-1,,"{
    void **rootp = ctx;
    const char *name;
    void *addr;

    (void) tgt;

    switch (propid)
    {
        case VLC_MODULE_CB_OPEN:
        case VLC_MODULE_CB_CLOSE:
        case VLC_CONFIG_LIST_CB:
        {
            va_list ap;

            va_start(ap, propid);
            name = va_arg(ap, const char *);
            addr = va_arg(ap, void *);
            va_end (ap);
            break;
        }
        default:
            return 0;
    }

    struct vlc_plugin_symbol *sym = malloc(sizeof (*sym));

    sym->name = name;
    sym->addr = addr;

    struct vlc_plugin_symbol **symp = tsearch(sym, rootp,
                                              vlc_plugin_symbol_compare);
    if (unlikely(symp == NULL))
    {   /* Memory error */
        free(sym);
        return -1;
    }

    if (*symp != sym)
    {   /* Duplicate symbol */
        assert((*symp)->addr == sym->addr);
        free(sym);
    }
    return 0;
}",1,,501,4,,void
139992,BLOCK,-1,,"{
        case VLC_MODULE_CB_OPEN:
        case VLC_MODULE_CB_CLOSE:
        case VLC_CONFIG_LIST_CB:
        {
            va_list ap;

            va_start(ap, propid);
            name = va_arg(ap, const char *);
            addr = va_arg(ap, void *);
            va_end (ap);
            break;
        }
        default:
            return 0;
    }",5,,509,2,,void
139999,BLOCK,7,,"{
            va_list ap;

            va_start(ap, propid);
            name = va_arg(ap, const char *);
            addr = va_arg(ap, void *);
            va_end (ap);
            break;
        }",9,,513,7,,void
140041,BLOCK,-1,,"{   /* Memory error */
        free(sym);
        return -1;
    }",5,,534,2,,void
140052,BLOCK,-1,,"{   /* Duplicate symbol */
        assert((*symp)->addr == sym->addr);
        free(sym);
    }",5,,540,2,,void
140070,BLOCK,-1,,"{
    void *root = NULL;

    if (entry(vlc_plugin_gpa_cb, &root))
    {
        tdestroy(root, free);
        return NULL;
    }

    return root;
}",1,,558,2,,void
140080,BLOCK,-1,,"{
        tdestroy(root, free);
        return NULL;
    }",5,,562,2,,void
140092,BLOCK,-1,,"{
    tdestroy(root, free);
}",1,,571,2,,void
140102,BLOCK,-1,,"{
    if (name == NULL)
    {   /* TODO: use this; do not define ""NULL"" as a name for NULL? */
        *addrp = NULL;
        return 0;
    }

    const struct vlc_plugin_symbol **symp = tfind(&name, &root,
                                                  vlc_plugin_symbol_compare);

    if (symp == NULL)
        return -1;

    *addrp = (*symp)->addr;
    return 0;
}",1,,577,4,,void
140107,BLOCK,-1,,"{   /* TODO: use this; do not define ""NULL"" as a name for NULL? */
        *addrp = NULL;
        return 0;
    }",5,,579,2,,void
140127,BLOCK,-1,,<empty>,9,,588,2,,void
140145,BLOCK,-1,,"{
    void *syms = vlc_plugin_get_symbols(entry);
    int ret = -1;

    /* Resolve modules activate/deactivate callbacks */
    for (module_t *module = plugin->module;
         module != NULL;
         module = module->next)
    {
        if (vlc_plugin_get_symbol(syms, module->activate_name,
                                  &module->pf_activate)
         || vlc_plugin_get_symbol(syms, module->deactivate_name,
                                  &module->pf_deactivate))
            goto error;
    }

    /* Resolve configuration callbacks */
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        module_config_t *item = plugin->conf.items + i;
        void *cb;

        if (item->list_cb_name == NULL)
            continue;
        if (vlc_plugin_get_symbol(syms, item->list_cb_name, &cb))
            goto error;

        if (IsConfigIntegerType (item->i_type))
            item->list.i_cb = cb;
        else
        if (IsConfigStringType (item->i_type))
            item->list...",1,,595,3,,void
140157,BLOCK,-1,,<empty>,5,,600,1,,void
140172,BLOCK,4,,"{
        if (vlc_plugin_get_symbol(syms, module->activate_name,
                                  &module->pf_activate)
         || vlc_plugin_get_symbol(syms, module->deactivate_name,
                                  &module->pf_deactivate))
            goto error;
    }",5,,603,4,,void
140193,BLOCK,-1,,<empty>,13,,608,2,,void
140196,BLOCK,-1,,<empty>,5,,612,1,,void
140210,BLOCK,4,,"{
        module_config_t *item = plugin->conf.items + i;
        void *cb;

        if (item->list_cb_name == NULL)
            continue;
        if (vlc_plugin_get_symbol(syms, item->list_cb_name, &cb))
            goto error;

        if (IsConfigIntegerType (item->i_type))
            item->list.i_cb = cb;
        else
        if (IsConfigStringType (item->i_type))
            item->list.psz_cb = cb;
    }",5,,613,4,,void
140228,BLOCK,-1,,<empty>,13,,618,2,,void
140238,BLOCK,-1,,<empty>,13,,620,2,,void
140245,BLOCK,1,,<empty>,,,,3,,void
140253,BLOCK,-1,,<empty>,13,,623,2,,void
140262,BLOCK,-1,,<empty>,9,,625,1,,void
140268,BLOCK,1,,<empty>,,,,3,,void
140276,BLOCK,-1,,<empty>,13,,626,2,,void
140320,BLOCK,-1,,<empty>,1,,1,1,,ANY
140324,BLOCK,-1,,"{
    return !strcmp (module_get_capability (m), cap);
}",1,,54,3,,void
140335,BLOCK,-1,,"{
    if (unlikely(m->i_shortcuts == 0))
        return ""unnamed"";
    return m->pp_shortcuts[0];
}",1,,65,2,,void
140343,BLOCK,-1,,<empty>,9,,67,2,,void
140357,BLOCK,-1,,"{
    if( long_name && ( m->psz_longname != NULL) )
        return m->psz_longname;

    if (m->psz_shortname != NULL)
        return m->psz_shortname;
    return module_get_object (m);
}",1,,79,3,,void
140366,BLOCK,-1,,<empty>,9,,81,2,,void
140377,BLOCK,-1,,<empty>,9,,84,2,,void
140389,BLOCK,-1,,"{
    return m->psz_help;
}",1,,95,2,,void
140398,BLOCK,-1,,"{
    return (m->psz_capability != NULL) ? m->psz_capability : ""none"";
}",1,,106,2,,void
140414,BLOCK,-1,,"{
    return m->i_score;
}",1,,117,2,,void
140424,BLOCK,-1,,"{
    if (unlikely(str == NULL || *str == '\0'))
        return """";
#ifdef ENABLE_NLS
    const char *domain = m->plugin->textdomain;
    return dgettext ((domain != NULL) ? domain : PACKAGE_NAME, str);
#else
    (void)m;
    return str;
#endif
}",1,,129,3,,void
140435,BLOCK,-1,,<empty>,9,,131,2,,void
140448,BLOCK,-1,,"{
   int (*activate) (vlc_object_t *) = m->pf_activate;

   return (activate != NULL) ? activate (obj) : VLC_SUCCESS;
}",1,,143,3,,void
140451,BLOCK,-1,,<empty>,,,,2,,<empty>
140467,BLOCK,-1,,"{
   void (*deactivate) (vlc_object_t *) = m->pf_deactivate;

    if (deactivate != NULL)
        deactivate (obj);
}",1,,151,3,,void
140470,BLOCK,-1,,<empty>,,,,2,,<empty>
140477,BLOCK,-1,,<empty>,9,,155,2,,void
140485,BLOCK,-1,,"{
     /* Plugins with zero score must be matched explicitly. */
     if (!strcasecmp (""any"", name))
         return m->i_score > 0;

     for (unsigned i = 0; i < m->i_shortcuts; i++)
          if (!strcasecmp (m->pp_shortcuts[i], name))
              return true;
     return false;
}",1,,159,3,,void
140491,BLOCK,-1,,<empty>,10,,162,2,,void
140499,BLOCK,-1,,<empty>,6,,164,1,,void
140520,BLOCK,-1,,<empty>,15,,166,2,,void
140532,BLOCK,-1,,"{
    int ret = VLC_SUCCESS;

    if (module_Map(obj, m->plugin))
        return VLC_EGENERIC;

    if (m->pf_activate != NULL)
    {
        va_list ap;

        va_copy (ap, args);
        ret = init (m->pf_activate, ap);
        va_end (ap);
    }

    if (ret != VLC_SUCCESS)
        vlc_objres_clear(obj);

    return ret;
}",1,,172,5,,void
140543,BLOCK,-1,,<empty>,9,,176,2,,void
140552,BLOCK,-1,,"{
        va_list ap;

        va_copy (ap, args);
        ret = init (m->pf_activate, ap);
        va_end (ap);
    }",5,,179,2,,void
140570,BLOCK,-1,,<empty>,9,,188,2,,void
140583,BLOCK,-1,,"{
    char *var = NULL;

    if (name == NULL || name[0] == '\0')
        name = ""any"";

    /* Deal with variables */
    if (name[0] == '$')
    {
        var = var_InheritString (obj, name + 1);
        name = (var != NULL) ? var : ""any"";
    }

    /* Find matching modules */
    module_t **mods;
    ssize_t total = module_list_cap (&mods, capability);

    msg_Dbg (obj, ""looking for %s module matching \""%s\"": %zd candidates"",
             capability, name, total);
    if (total <= 0)
    {
        module_list_free (mods);
        msg_Dbg (obj, ""no %s modules"", capability);
        return NULL;
    }

    module_t *module = NULL;
    const bool b_force_backup = obj->obj.force; /* FIXME: remove this */
    va_list args;

    va_start(args, probe);
    while (*name)
    {
        char buf[32];
        size_t slen = strcspn (name, "","");

        if (likely(slen < sizeof (buf)))
        {
            memcpy(buf, name, slen);
            buf[slen] = '\0';
        }
        name += sl...",1,,217,6,,void
140598,BLOCK,-1,,<empty>,9,,221,2,,void
140608,BLOCK,-1,,"{
        var = var_InheritString (obj, name + 1);
        name = (var != NULL) ? var : ""any"";
    }",5,,225,2,,void
140642,BLOCK,-1,,"{
        module_list_free (mods);
        msg_Dbg (obj, ""no %s modules"", capability);
        return NULL;
    }",5,,237,2,,void
140670,BLOCK,-1,,"{
        char buf[32];
        size_t slen = strcspn (name, "","");

        if (likely(slen < sizeof (buf)))
        {
            memcpy(buf, name, slen);
            buf[slen] = '\0';
        }
        name += slen;
        name += strspn (name, "","");
        if (unlikely(slen >= sizeof (buf)))
            continue;

        const char *shortcut = buf;
        assert (shortcut != NULL);

        if (!strcasecmp (""none"", shortcut))
            goto done;

        obj->obj.force = strict && strcasecmp (""any"", shortcut);
        for (ssize_t i = 0; i < total; i++)
        {
            module_t *cand = mods[i];
            if (cand == NULL)
                continue; // module failed in previous iteration
            if (!module_match_name (cand, shortcut))
                continue;
            mods[i] = NULL; // only try each module once at most...

            int ret = module_load (obj, cand, probe, args);
            switch (ret)
            {
                case VLC_SUCCESS:
   ...",5,,249,2,,void
140684,BLOCK,-1,,"{
            memcpy(buf, name, slen);
            buf[slen] = '\0';
        }",9,,254,2,,void
140708,BLOCK,-1,,<empty>,13,,261,2,,void
140723,BLOCK,-1,,<empty>,13,,267,2,,void
140737,BLOCK,-1,,<empty>,9,,270,1,,void
140747,BLOCK,4,,"{
            module_t *cand = mods[i];
            if (cand == NULL)
                continue; // module failed in previous iteration
            if (!module_match_name (cand, shortcut))
                continue;
            mods[i] = NULL; // only try each module once at most...

            int ret = module_load (obj, cand, probe, args);
            switch (ret)
            {
                case VLC_SUCCESS:
                    module = cand;
                    /* fall through */
                case VLC_ETIMEOUT:
                    goto done;
            }
        }",9,,271,4,,void
140758,BLOCK,-1,,<empty>,17,,274,2,,void
140765,BLOCK,-1,,<empty>,17,,276,2,,void
140782,BLOCK,-1,,"{
                case VLC_SUCCESS:
                    module = cand;
                    /* fall through */
                case VLC_ETIMEOUT:
                    goto done;
            }",13,,281,2,,void
140794,BLOCK,-1,,"{
        obj->obj.force = false;
        for (ssize_t i = 0; i < total; i++)
        {
            module_t *cand = mods[i];
            if (cand == NULL || module_get_score (cand) <= 0)
                continue;

            int ret = module_load (obj, cand, probe, args);
            switch (ret)
            {
                case VLC_SUCCESS:
                    module = cand;
                    /* fall through */
                case VLC_ETIMEOUT:
                    goto done;
            }
        }
    }",5,,293,2,,void
140803,BLOCK,-1,,<empty>,9,,295,1,,void
140813,BLOCK,4,,"{
            module_t *cand = mods[i];
            if (cand == NULL || module_get_score (cand) <= 0)
                continue;

            int ret = module_load (obj, cand, probe, args);
            switch (ret)
            {
                case VLC_SUCCESS:
                    module = cand;
                    /* fall through */
                case VLC_ETIMEOUT:
                    goto done;
            }
        }",9,,296,4,,void
140829,BLOCK,-1,,<empty>,17,,299,2,,void
140841,BLOCK,-1,,"{
                case VLC_SUCCESS:
                    module = cand;
                    /* fall through */
                case VLC_ETIMEOUT:
                    goto done;
            }",13,,303,2,,void
140868,BLOCK,-1,,"{
        msg_Dbg (obj, ""using %s module \""%s\"""", capability,
                 module_get_object (module));
        vlc_object_set_name (obj, module_get_object (module));
    }",5,,319,2,,void
140879,BLOCK,1,,<empty>,,,,4,,void
140886,BLOCK,-1,,<empty>,9,,325,1,,void
140899,BLOCK,-1,,"{
    if (module->pf_deactivate != NULL)
    {
        va_list ap;

        va_start(ap, deinit);
        deinit(module->pf_deactivate, ap);
        va_end(ap);
    }

    vlc_objres_clear(obj);
}",1,,337,4,,void
140906,BLOCK,-1,,"{
        va_list ap;

        va_start(ap, deinit);
        deinit(module->pf_deactivate, ap);
        va_end(ap);
    }",5,,339,2,,void
140925,BLOCK,-1,,"{
    vlc_object_t *obj = va_arg(ap, vlc_object_t *);
    int (*activate)(vlc_object_t *) = func;

    return activate(obj);
}",1,,352,3,,void
140929,BLOCK,-1,,<empty>,,,,2,,<empty>
140940,BLOCK,-1,,"{
    vlc_object_t *obj = va_arg(ap, vlc_object_t *);
    void (*deactivate)(vlc_object_t *) = func;

    deactivate(obj);
}",1,,360,3,,void
140944,BLOCK,-1,,<empty>,,,,2,,<empty>
140956,BLOCK,-1,,"{
    return vlc_module_load(obj, cap, name, strict, generic_start, obj);
}",1,,370,5,,void
140970,BLOCK,-1,,"{
    msg_Dbg(obj, ""removing module \""%s\"""", module_get_object(module));
    vlc_module_unload(obj, module, generic_stop, obj);
}",1,,376,3,,void
140985,BLOCK,-1,,"{
    size_t count;
    module_t **list = module_list_get (&count);

    assert (name != NULL);

    for (size_t i = 0; i < count; i++)
    {
        module_t *module = list[i];

        if (unlikely(module->i_shortcuts == 0))
            continue;
        if (!strcmp (module->pp_shortcuts[0], name))
        {
            module_list_free (list);
            return module;
        }
    }
    module_list_free (list);
    return NULL;
}",1,,388,2,,void
140998,BLOCK,-1,,<empty>,5,,394,1,,void
141008,BLOCK,4,,"{
        module_t *module = list[i];

        if (unlikely(module->i_shortcuts == 0))
            continue;
        if (!strcmp (module->pp_shortcuts[0], name))
        {
            module_list_free (list);
            return module;
        }
    }",5,,395,4,,void
141022,BLOCK,-1,,<empty>,13,,399,2,,void
141033,BLOCK,-1,,"{
            module_list_free (list);
            return module;
        }",9,,401,2,,void
141046,BLOCK,-1,,"{
    return module_find (psz_name) != NULL;
}",1,,417,2,,void
141057,BLOCK,-1,,"{
    const vlc_plugin_t *plugin = module->plugin;

    if (plugin->module != module)
    {   /* For backward compatibility, pretend non-first modules have no
         * configuration items. */
        *psize = 0;
        return NULL;
    }

    unsigned i,j;
    size_t size = plugin->conf.size;
    module_config_t *config = vlc_alloc( size, sizeof( *config ) );

    assert( psize != NULL );
    *psize = 0;

    if( !config )
        return NULL;

    for( i = 0, j = 0; i < size; i++ )
    {
        const module_config_t *item = plugin->conf.items + i;
        if( item->b_internal /* internal option */
         || item->b_removed /* removed option */ )
            continue;

        memcpy( config + j, item, sizeof( *config ) );
        j++;
    }
    *psize = j;

    return config;
}",1,,429,3,,void
141070,BLOCK,-1,,"{   /* For backward compatibility, pretend non-first modules have no
         * configuration items. */
        *psize = 0;
        return NULL;
    }",5,,433,2,,void
141106,BLOCK,-1,,<empty>,9,,447,2,,void
141110,BLOCK,-1,,<empty>,5,,449,1,,void
141123,BLOCK,4,,"{
        const module_config_t *item = plugin->conf.items + i;
        if( item->b_internal /* internal option */
         || item->b_removed /* removed option */ )
            continue;

        memcpy( config + j, item, sizeof( *config ) );
        j++;
    }",5,,450,4,,void
141142,BLOCK,-1,,<empty>,13,,454,2,,void
141164,BLOCK,-1,,"{
    free( config );
}",1,,471,2,,void
141175,BLOCK,-1,,<empty>,1,,1,1,,ANY
141202,BLOCK,-1,,<empty>,,,,3,,<empty>
141208,BLOCK,-1,,<empty>,,,,3,,<empty>
141227,BLOCK,-1,,<empty>,,,,2,,<empty>
141232,BLOCK,-1,,<empty>,,,,2,,<empty>
141237,BLOCK,-1,,<empty>,,,,2,,<empty>
141242,BLOCK,-1,,<empty>,,,,2,,<empty>
141247,BLOCK,-1,,<empty>,,,,2,,<empty>
141253,BLOCK,-1,,<empty>,,,,3,,<empty>
141258,BLOCK,-1,,<empty>,,,,2,,<empty>
141263,BLOCK,-1,,<empty>,,,,2,,<empty>
141268,BLOCK,-1,,<empty>,,,,2,,<empty>
141274,BLOCK,-1,,<empty>,,,,3,,<empty>
141280,BLOCK,-1,,<empty>,,,,3,,<empty>
141285,BLOCK,-1,,<empty>,,,,2,,<empty>
141293,BLOCK,-1,,<empty>,,,,5,,<empty>
141299,BLOCK,-1,,<empty>,,,,3,,<empty>
141304,BLOCK,-1,,<empty>,,,,2,,<empty>
141311,BLOCK,-1,,<empty>,,,,4,,<empty>
141317,BLOCK,-1,,<empty>,,,,3,,<empty>
141325,BLOCK,-1,,<empty>,,,,5,,<empty>
141342,BLOCK,-1,,<empty>,1,,1,1,,ANY
141345,BLOCK,-1,,"{
#if defined (ENABLE_NLS)
    /* Specify where to find the locales for current domain */
    char *datadir = config_GetDataDir();
    if (unlikely(datadir == NULL))
        return -1;

# if !defined (__APPLE__) && !defined (_WIN32) && !defined(__OS2__)
    const char *fmt = ""%s/../locale"";
# else
    const char *fmt = ""%s""DIR_SEP""locale"";
# endif
    char *upath;
    int ret = asprintf(&upath, fmt, datadir);
    free (datadir);
    if (unlikely(ret == -1))
        return -1;

    char *lpath = ToLocaleDup (upath);
    if (lpath == NULL || bindtextdomain (domain, lpath) == NULL)
    {
        free (lpath);
        fprintf (stderr, ""%s: text domain not found in %s\n"", domain, upath);
        free (upath);
        return -1;
    }
    free (lpath);
    free (upath);

    /* LibVLC wants all messages in UTF-8.
     * Unfortunately, we cannot ask UTF-8 for strerror_r(), strsignal_r()
     * and other functions that are not part of our text domain.
     */
    if (bind_textdomain_codeset...",1,,34,2,,void
141355,BLOCK,-1,,"{
#ifdef ENABLE_NLS
    if (likely(*msgid))
        return dgettext (PACKAGE_NAME, msgid);
#endif
    return (char *)msgid;
}",1,,91,2,,void
141366,BLOCK,-1,,"{
#ifdef ENABLE_NLS
    if (likely(*msgid))
        return dngettext (PACKAGE_NAME, msgid, plural, n);
#endif
    return (char *)((n == 1) ? msgid : plural);
}",1,,100,4,,void
141400,BLOCK,-1,,<empty>,1,,1,1,,ANY
141408,BLOCK,-1,,"{
    char psz_servbuf[6], *psz_serv;
    int i_servlen, i_val;

    flags |= NI_NUMERICSERV;
    if( portnum != NULL )
    {
        psz_serv = psz_servbuf;
        i_servlen = sizeof( psz_servbuf );
    }
    else
    {
        psz_serv = NULL;
        i_servlen = 0;
    }

    i_val = getnameinfo(sa, salen, host, hostlen, psz_serv, i_servlen, flags);

    if( portnum != NULL )
        *portnum = atoi( psz_serv );

    return i_val;
}",1,,42,7,,void
141420,BLOCK,-1,,"{
        psz_serv = psz_servbuf;
        i_servlen = sizeof( psz_servbuf );
    }",5,,48,2,,void
141429,BLOCK,-1,,"{
        psz_serv = NULL;
        i_servlen = 0;
    }",5,,53,1,,void
141450,BLOCK,-1,,<empty>,9,,61,2,,void
141465,BLOCK,-1,,"{
    char hostbuf[NI_MAXHOST], portbuf[6], *servname;

    /*
     * In VLC, we always use port number as integer rather than strings
     * for historical reasons (and portability).
     */
    if (port != 0)
    {
        if (port > 65535)
            return EAI_SERVICE;
        /* cannot overflow */
        snprintf (portbuf, sizeof (portbuf), ""%u"", port);
        servname = portbuf;
    }
    else
        servname = NULL;

    /*
     * VLC extensions :
     * - accept the empty string as unspecified host (i.e. NULL)
     * - ignore square brackets (for IPv6 numerals)
     */
    if (node != NULL)
    {
        if (node[0] == '[')
        {
            size_t len = strlen (node + 1);
            if ((len <= sizeof (hostbuf)) && (node[len] == ']'))
            {
                assert (len > 0);
                memcpy (hostbuf, node + 1, len - 1);
                hostbuf[len - 1] = '\0';
                node = hostbuf;
            }
        }
        if (node[0] == '\0')
       ...",1,,80,5,,void
141473,BLOCK,-1,,"{
        if (port > 65535)
            return EAI_SERVICE;
        /* cannot overflow */
        snprintf (portbuf, sizeof (portbuf), ""%u"", port);
        servname = portbuf;
    }",5,,88,2,,void
141478,BLOCK,-1,,<empty>,13,,90,2,,void
141491,BLOCK,-1,,<empty>,9,,96,1,,void
141499,BLOCK,-1,,"{
        if (node[0] == '[')
        {
            size_t len = strlen (node + 1);
            if ((len <= sizeof (hostbuf)) && (node[len] == ']'))
            {
                assert (len > 0);
                memcpy (hostbuf, node + 1, len - 1);
                hostbuf[len - 1] = '\0';
                node = hostbuf;
            }
        }
        if (node[0] == '\0')
            node = NULL;
    }",5,,104,2,,void
141506,BLOCK,-1,,"{
            size_t len = strlen (node + 1);
            if ((len <= sizeof (hostbuf)) && (node[len] == ']'))
            {
                assert (len > 0);
                memcpy (hostbuf, node + 1, len - 1);
                hostbuf[len - 1] = '\0';
                node = hostbuf;
            }
        }",9,,106,2,,void
141525,BLOCK,-1,,"{
                assert (len > 0);
                memcpy (hostbuf, node + 1, len - 1);
                hostbuf[len - 1] = '\0';
                node = hostbuf;
            }",13,,109,2,,void
141554,BLOCK,-1,,<empty>,13,,117,2,,void
141584,BLOCK,-1,,<empty>,1,,1,1,,ANY
141588,BLOCK,-1,,"{
    char psz_what[strlen(psz_param)+3];
    sprintf( psz_what, ""%s=\"""", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, '""' );
        if ( !psz_end ) /* Invalid since we should have a closing quote */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",1,,47,3,,void
141601,BLOCK,-1,,"{
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, '""' );
        if ( !psz_end ) /* Invalid since we should have a closing quote */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }",5,,52,2,,void
141615,BLOCK,-1,,<empty>,13,,57,2,,void
141626,BLOCK,-1,,"{
        return NULL;
    }",5,,61,1,,void
141634,BLOCK,-1,,"{
    char psz_what[strlen(psz_param)+2];
    sprintf( psz_what, ""%s="", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, ',' );
        /* XXX: Do we need to filter out trailing space between the value and
         * the comma/end of line? */
        if ( !psz_end ) /* Can be valid if this is the last parameter */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",1,,67,3,,void
141647,BLOCK,-1,,"{
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, ',' );
        /* XXX: Do we need to filter out trailing space between the value and
         * the comma/end of line? */
        if ( !psz_end ) /* Can be valid if this is the last parameter */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }",5,,72,2,,void
141661,BLOCK,-1,,<empty>,13,,79,2,,void
141672,BLOCK,-1,,"{
        return NULL;
    }",5,,83,1,,void
141678,BLOCK,-1,,"{
    char ps_random[32];
    struct md5_s md5;

    vlc_rand_bytes( ps_random, sizeof( ps_random ) );

    InitMD5( &md5 );
    AddMD5( &md5, ps_random, sizeof( ps_random ) );
    EndMD5( &md5 );

    return psz_md5_hash( &md5 );
}",1,,89,1,,void
141710,BLOCK,-1,,"{
    char *psz_HA1 = NULL;
    char *psz_HA2 = NULL;
    char *psz_ent = NULL;
    char *psz_result = NULL;
    char psz_inonce[9];
    struct md5_s md5;
    struct md5_s ent;

    if ( p_auth->psz_realm == NULL )
    {
        msg_Warn( p_this, ""Digest Authentication: ""
                  ""Mandatory 'realm' value not available"" );
        goto error;
    }

    /* H(A1) */
    if ( p_auth->psz_HA1 )
    {
        psz_HA1 = strdup( p_auth->psz_HA1 );
        if ( psz_HA1 == NULL )
            goto error;
    }
    else
    {
        InitMD5( &md5 );
        AddMD5( &md5, psz_username, strlen( psz_username ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, p_auth->psz_realm, strlen( p_auth->psz_realm ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, psz_password, strlen( psz_password ) );
        EndMD5( &md5 );

        psz_HA1 = psz_md5_hash( &md5 );
        if ( psz_HA1 == NULL )
            goto error;

        if ( p_auth->psz_algorithm &&
             strcmp( p...",1,,105,7,,void
141736,BLOCK,-1,,"{
        msg_Warn( p_this, ""Digest Authentication: ""
                  ""Mandatory 'realm' value not available"" );
        goto error;
    }",5,,115,2,,void
141745,BLOCK,-1,,"{
        psz_HA1 = strdup( p_auth->psz_HA1 );
        if ( psz_HA1 == NULL )
            goto error;
    }",5,,123,2,,void
141756,BLOCK,-1,,<empty>,13,,126,2,,void
141759,BLOCK,-1,,"{
        InitMD5( &md5 );
        AddMD5( &md5, psz_username, strlen( psz_username ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, p_auth->psz_realm, strlen( p_auth->psz_realm ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, psz_password, strlen( psz_password ) );
        EndMD5( &md5 );

        psz_HA1 = psz_md5_hash( &md5 );
        if ( psz_HA1 == NULL )
            goto error;

        if ( p_auth->psz_algorithm &&
             strcmp( p_auth->psz_algorithm, ""MD5-sess"" ) == 0 )
        {
            InitMD5( &md5 );
            AddMD5( &md5, psz_HA1, 32 );
            AddMD5( &md5, "":"", 1 );
            AddMD5( &md5, p_auth->psz_nonce, strlen( p_auth->psz_nonce ) );
            AddMD5( &md5, "":"", 1 );
            AddMD5( &md5, p_auth->psz_cnonce, strlen( p_auth->psz_cnonce ) );
            EndMD5( &md5 );

            free( psz_HA1 );

            psz_HA1 = psz_md5_hash( &md5 );
            if ( psz_HA1 == NULL )
                goto error;

            p_...",5,,129,1,,void
141807,BLOCK,-1,,<empty>,13,,140,2,,void
141821,BLOCK,-1,,"{
            InitMD5( &md5 );
            AddMD5( &md5, psz_HA1, 32 );
            AddMD5( &md5, "":"", 1 );
            AddMD5( &md5, p_auth->psz_nonce, strlen( p_auth->psz_nonce ) );
            AddMD5( &md5, "":"", 1 );
            AddMD5( &md5, p_auth->psz_cnonce, strlen( p_auth->psz_cnonce ) );
            EndMD5( &md5 );

            free( psz_HA1 );

            psz_HA1 = psz_md5_hash( &md5 );
            if ( psz_HA1 == NULL )
                goto error;

            p_auth->psz_HA1 = strdup( psz_HA1 );
            if ( p_auth->psz_HA1 == NULL )
                goto error;
        }",9,,144,2,,void
141874,BLOCK,-1,,<empty>,17,,157,2,,void
141888,BLOCK,-1,,<empty>,17,,161,2,,void
141896,BLOCK,-1,,<empty>,9,,168,2,,void
141910,BLOCK,-1,,<empty>,9,,171,2,,void
141918,BLOCK,-1,,<empty>,9,,173,1,,void
141936,BLOCK,-1,,"{
        InitMD5( &ent );
        /* TODO: Support for ""qop=auth-int"" */
        AddMD5( &ent, """", 0 );
        EndMD5( &ent );

        psz_ent = psz_md5_hash( &ent );
        if ( psz_ent == NULL )
            goto error;

        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, psz_ent, 32 );
    }",5,,175,2,,void
141957,BLOCK,-1,,<empty>,13,,183,2,,void
141981,BLOCK,-1,,<empty>,9,,192,2,,void
142031,BLOCK,-1,,"{
        snprintf( psz_inonce, sizeof( psz_inonce ), ""%08x"", p_auth->i_nonce );
        AddMD5( &md5, psz_inonce, 8 );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, p_auth->psz_cnonce, strlen( p_auth->psz_cnonce ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, p_auth->psz_qop, strlen( p_auth->psz_qop ) );
        AddMD5( &md5, "":"", 1 );
    }",5,,203,2,,void
142108,BLOCK,-1,,"{
    static const char psz_basic_prefix[] = ""Basic "";
    static const char psz_digest_prefix[] = ""Digest "";

    /* FIXME: multiple auth methods can be listed (comma separated) */

    if ( strncasecmp( psz_header, psz_basic_prefix,
                      sizeof( psz_basic_prefix ) - 1 ) == 0 )
    {
        /* 2 Basic Authentication Scheme */
        msg_Dbg( p_this, ""Using Basic Authentication"" );
        psz_header += sizeof( psz_basic_prefix ) - 1;
        p_auth->psz_realm = AuthGetParam( psz_header, ""realm"" );
        if ( p_auth->psz_realm == NULL )
            msg_Warn( p_this, ""Basic Authentication: ""
                      ""Mandatory 'realm' parameter is missing"" );
    }
    else if ( strncasecmp( psz_header, psz_digest_prefix,
                           sizeof( psz_digest_prefix ) - 1 ) == 0 )
    {
        /* 3 Digest Access Authentication Scheme */
        msg_Dbg( p_this, ""Using Digest Access Authentication"" );

        if ( p_auth->psz_nonce )
            /* FIXME */...",1,,234,4,,void
142127,BLOCK,-1,,"{
        /* 2 Basic Authentication Scheme */
        msg_Dbg( p_this, ""Using Basic Authentication"" );
        psz_header += sizeof( psz_basic_prefix ) - 1;
        p_auth->psz_realm = AuthGetParam( psz_header, ""realm"" );
        if ( p_auth->psz_realm == NULL )
            msg_Warn( p_this, ""Basic Authentication: ""
                      ""Mandatory 'realm' parameter is missing"" );
    }",5,,242,2,,void
142150,BLOCK,-1,,<empty>,13,,248,2,,void
142155,BLOCK,-1,,<empty>,10,,251,1,,void
142166,BLOCK,-1,,"{
        /* 3 Digest Access Authentication Scheme */
        msg_Dbg( p_this, ""Using Digest Access Authentication"" );

        if ( p_auth->psz_nonce )
            /* FIXME */
            return;

        psz_header += sizeof( psz_digest_prefix ) - 1;
        p_auth->psz_realm = AuthGetParam( psz_header, ""realm"" );
        p_auth->psz_domain = AuthGetParam( psz_header, ""domain"" );
        p_auth->psz_nonce = AuthGetParam( psz_header, ""nonce"" );
        p_auth->psz_opaque = AuthGetParam( psz_header, ""opaque"" );
        p_auth->psz_stale = AuthGetParamNoQuotes( psz_header, ""stale"" );
        p_auth->psz_algorithm = AuthGetParamNoQuotes( psz_header, ""algorithm"" );
        p_auth->psz_qop = AuthGetParam( psz_header, ""qop"" );
        p_auth->i_nonce = 0;

        /* printf(""realm: |%s|\ndomain: |%s|\nnonce: |%s|\nopaque: |%s|\n""
                  ""stale: |%s|\nalgorithm: |%s|\nqop: |%s|\n"",
                  p_auth->psz_realm,p_auth->psz_domain,p_auth->psz_nonce,
                  p_aut...",5,,253,2,,void
142174,BLOCK,-1,,<empty>,13,,259,2,,void
142242,BLOCK,-1,,<empty>,13,,278,2,,void
142252,BLOCK,-1,,<empty>,13,,281,2,,void
142260,BLOCK,-1,,"{
            char *psz_tmp = strchr( p_auth->psz_qop, ',' );
            if ( psz_tmp )
                *psz_tmp = '\0';
        }",9,,286,2,,void
142271,BLOCK,-1,,<empty>,17,,289,2,,void
142277,BLOCK,-1,,"{
        const char *psz_end = strchr( psz_header, ' ' );
        if ( psz_end )
            msg_Warn( p_this, ""Unknown authentication scheme: '%*s'"",
                      (int)(psz_end - psz_header), psz_header );
        else
            msg_Warn( p_this, ""Unknown authentication scheme: '%s'"",
                      psz_header );
    }",5,,293,1,,void
142286,BLOCK,-1,,<empty>,13,,296,2,,void
142297,BLOCK,-1,,<empty>,13,,299,1,,void
142312,BLOCK,-1,,"{
    char *psz_nextnonce = AuthGetParam( psz_header, ""nextnonce"" );
    char *psz_qop = AuthGetParamNoQuotes( psz_header, ""qop"" );
    char *psz_rspauth = AuthGetParam( psz_header, ""rspauth"" );
    char *psz_cnonce = AuthGetParam( psz_header, ""cnonce"" );
    char *psz_nc = AuthGetParamNoQuotes( psz_header, ""nc"" );
    char *psz_digest = NULL;
    int i_err = VLC_SUCCESS;
    int i_nonce;

    if ( psz_cnonce )
    {
        if ( strcmp( psz_cnonce, p_auth->psz_cnonce ) != 0 )
        {
            msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                             ""replied with a different client nonce value."" );
            i_err = VLC_EGENERIC;
            goto error;
        }

        if ( psz_nc )
        {
            i_nonce = strtol( psz_nc, NULL, 16 );

            if ( i_nonce != p_auth->i_nonce )
            {
                msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                                 ""replied with a different non...",1,,313,8,,void
142354,BLOCK,-1,,"{
        if ( strcmp( psz_cnonce, p_auth->psz_cnonce ) != 0 )
        {
            msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                             ""replied with a different client nonce value."" );
            i_err = VLC_EGENERIC;
            goto error;
        }

        if ( psz_nc )
        {
            i_nonce = strtol( psz_nc, NULL, 16 );

            if ( i_nonce != p_auth->i_nonce )
            {
                msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                                 ""replied with a different nonce count ""
                                 ""value."" );
                i_err = VLC_EGENERIC;
                goto error;
            }
        }

        if ( psz_qop && p_auth->psz_qop &&
             strcmp( psz_qop, p_auth->psz_qop ) != 0 )
            msg_Warn( p_this, ""HTTP Digest Access Authentication: server ""
                              ""replied using a different 'quality of ""
                            ...",5,,324,2,,void
142363,BLOCK,-1,,"{
            msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                             ""replied with a different client nonce value."" );
            i_err = VLC_EGENERIC;
            goto error;
        }",9,,326,2,,void
142373,BLOCK,-1,,"{
            i_nonce = strtol( psz_nc, NULL, 16 );

            if ( i_nonce != p_auth->i_nonce )
            {
                msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                                 ""replied with a different nonce count ""
                                 ""value."" );
                i_err = VLC_EGENERIC;
                goto error;
            }
        }",9,,334,2,,void
142386,BLOCK,-1,,"{
                msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                                 ""replied with a different nonce count ""
                                 ""value."" );
                i_err = VLC_EGENERIC;
                goto error;
            }",13,,338,2,,void
142408,BLOCK,-1,,<empty>,13,,349,2,,void
142431,BLOCK,-1,,"{
            msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                             ""replied with an invalid response digest ""
                             ""(expected value: %s)."", psz_digest );
            i_err = VLC_EGENERIC;
            goto error;
        }",9,,361,2,,void
142442,BLOCK,-1,,"{
        free( p_auth->psz_nonce );
        p_auth->psz_nonce = psz_nextnonce;
        psz_nextnonce = NULL;
    }",5,,371,2,,void
142479,BLOCK,-1,,"{
    char *psz_result = NULL;
    char *psz_buffer = NULL;
    char *psz_base64 = NULL;
    int i_rc;

    if ( p_auth->psz_nonce )
    {
        /* Digest Access Authentication */
        if ( p_auth->psz_algorithm &&
             strcmp( p_auth->psz_algorithm, ""MD5"" ) != 0 &&
             strcmp( p_auth->psz_algorithm, ""MD5-sess"" ) != 0 )
        {
            msg_Err( p_this, ""Digest Access Authentication: ""
                     ""Unknown algorithm '%s'"", p_auth->psz_algorithm );
            goto error;
        }

        if ( p_auth->psz_qop != NULL || p_auth->psz_cnonce == NULL )
        {
            free( p_auth->psz_cnonce );

            p_auth->psz_cnonce = GenerateCnonce();
            if ( p_auth->psz_cnonce == NULL )
                goto error;
        }

        ++p_auth->i_nonce;

        psz_buffer = AuthDigest( p_this, p_auth, psz_method, psz_path,
                                 psz_username, psz_password );
        if ( psz_buffer == NULL )
            goto error...",1,,392,7,,void
142497,BLOCK,-1,,"{
        /* Digest Access Authentication */
        if ( p_auth->psz_algorithm &&
             strcmp( p_auth->psz_algorithm, ""MD5"" ) != 0 &&
             strcmp( p_auth->psz_algorithm, ""MD5-sess"" ) != 0 )
        {
            msg_Err( p_this, ""Digest Access Authentication: ""
                     ""Unknown algorithm '%s'"", p_auth->psz_algorithm );
            goto error;
        }

        if ( p_auth->psz_qop != NULL || p_auth->psz_cnonce == NULL )
        {
            free( p_auth->psz_cnonce );

            p_auth->psz_cnonce = GenerateCnonce();
            if ( p_auth->psz_cnonce == NULL )
                goto error;
        }

        ++p_auth->i_nonce;

        psz_buffer = AuthDigest( p_this, p_auth, psz_method, psz_path,
                                 psz_username, psz_password );
        if ( psz_buffer == NULL )
            goto error;

        i_rc = asprintf( &psz_result,
            ""Digest ""
            /* Mandatory parameters */
            ""username=\""%s\"", ""
   ...",5,,399,2,,void
142518,BLOCK,-1,,"{
            msg_Err( p_this, ""Digest Access Authentication: ""
                     ""Unknown algorithm '%s'"", p_auth->psz_algorithm );
            goto error;
        }",9,,404,2,,void
142538,BLOCK,-1,,"{
            free( p_auth->psz_cnonce );

            p_auth->psz_cnonce = GenerateCnonce();
            if ( p_auth->psz_cnonce == NULL )
                goto error;
        }",9,,411,2,,void
142554,BLOCK,-1,,<empty>,17,,416,2,,void
142573,BLOCK,-1,,<empty>,13,,424,2,,void
142686,BLOCK,-1,,<empty>,13,,464,2,,void
142689,BLOCK,-1,,"{
        /* Basic Access Authentication */
        i_rc = asprintf( &psz_buffer, ""%s:%s"", psz_username, psz_password );
        if ( i_rc < 0 )
            goto error;

        psz_base64 = vlc_b64_encode( psz_buffer );
        if ( psz_base64 == NULL )
            goto error;

        i_rc = asprintf( &psz_result, ""Basic %s"", psz_base64 );
        if ( i_rc < 0 )
            goto error;
    }",5,,467,1,,void
142702,BLOCK,-1,,<empty>,13,,471,2,,void
142712,BLOCK,-1,,<empty>,13,,475,2,,void
142725,BLOCK,-1,,<empty>,13,,479,2,,void
142738,BLOCK,-1,,"{
    memset( p_auth, 0, sizeof( *p_auth ) );
}",1,,490,2,,void
142749,BLOCK,-1,,"{
    free( p_auth->psz_realm );
    free( p_auth->psz_domain );
    free( p_auth->psz_nonce );
    free( p_auth->psz_opaque );
    free( p_auth->psz_stale );
    free( p_auth->psz_algorithm );
    free( p_auth->psz_qop );
    free( p_auth->psz_cnonce );
    free( p_auth->psz_HA1 );
}",1,,495,2,,void
142832,BLOCK,-1,,<empty>,1,,1,1,,ANY
142835,BLOCK,-1,,<empty>,,,,2,,<empty>
142842,BLOCK,-1,,<empty>,,,,4,,<empty>
142873,BLOCK,-1,,<empty>,,,,1,,<empty>
142902,BLOCK,-1,,"{
    typedef struct
    {
        unsigned   i_code;
        const char psz_reason[36];
    } http_status_info;

    static const http_status_info http_reason[] =
    {
        /*{ 100, ""Continue"" },
          { 101, ""Switching Protocols"" },*/
        { 200, ""OK"" },
        /*{ 201, ""Created"" },
          { 202, ""Accepted"" },
          { 203, ""Non-authoritative information"" },
          { 204, ""No content"" },
          { 205, ""Reset content"" },
          { 206, ""Partial content"" },
          { 250, ""Low on storage space"" },
          { 300, ""Multiple choices"" },*/
        { 301, ""Moved permanently"" },
        /*{ 302, ""Moved temporarily"" },
          { 303, ""See other"" },
          { 304, ""Not modified"" },
          { 305, ""Use proxy"" },
          { 307, ""Temporary redirect"" },
          { 400, ""Bad request"" },*/
        { 401, ""Unauthorized"" },
        /*{ 402, ""Payment Required"" },*/
        { 403, ""Forbidden"" },
        { 404, ""Not found"" },
        { 405, ""Method not allowed"" }...",1,,175,2,,void
143000,BLOCK,-1,,<empty>,9,,252,2,,void
143019,BLOCK,-1,,"{
    const char *errname = httpd_ReasonFromCode (code);
    assert (errname);

    char *url_Encoded = vlc_xml_encode (url ? url : """");

    int res = asprintf (body,
        ""<?xml version=\""1.0\"" encoding=\""ascii\"" ?>\n""
        ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Strict//EN\""""
        "" \""http://www.w3.org/TR/xhtml10/DTD/xhtml10strict.dtd\"">\n""
        ""<html lang=\""en\"">\n""
        ""<head>\n""
        ""<title>%s</title>\n""
        ""</head>\n""
        ""<body>\n""
        ""<h1>%d %s%s%s%s</h1>\n""
        ""<hr />\n""
        ""<a href=\""http://www.videolan.org\"">VideoLAN</a>\n""
        ""</body>\n""
        ""</html>\n"", errname, code, errname,
        (url_Encoded ? "" ("" : """"), (url_Encoded ? url_Encoded : """"), (url_Encoded ? "")"" : """"));

    free (url_Encoded);

    if (res == -1) {
        *body = NULL;
        return 0;
    }

    return (size_t)res;
}",1,,258,4,,void
143063,BLOCK,-1,,"{
        *body = NULL;
        return 0;
    }",20,,282,2,,void
143082,BLOCK,-1,,<empty>,,,,1,,<empty>
143092,BLOCK,-1,,"{
    httpd_file_t *file = (httpd_file_t*)p_sys;
    uint8_t **pp_body, *p_body;
    int *pi_body, i_body;

    if (!answer || !query )
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;

    answer->i_status = 200;

    httpd_MsgAdd(answer, ""Content-type"",  ""%s"", file->mime);
    httpd_MsgAdd(answer, ""Cache-Control"", ""%s"", ""no-cache"");

    if (query->i_type != HTTPD_MSG_HEAD) {
        pp_body = &answer->p_body;
        pi_body = &answer->i_body;
    } else {
        /* The file still needs to be executed. */
        p_body = NULL;
        i_body = 0;
        pp_body = &p_body;
        pi_body = &i_body;
    }

    if (query->i_type == HTTPD_MSG_POST) {
        /* msg_Warn not supported */
    }

    uint8_t *psz_args = query->psz_args;
    file->pf_fill(file->p_sys, file, psz_args, pp_body, pi_body);

    if (query->i_type == HTTPD_MSG_HEAD)
        free(p_body);

    /* We respect client reques...",1,,305,5,,void
143109,BLOCK,-1,,<empty>,9,,311,2,,void
143150,BLOCK,-1,,"{
        pp_body = &answer->p_body;
        pi_body = &answer->i_body;
    }",42,,322,2,,void
143164,BLOCK,-1,,"{
        /* The file still needs to be executed. */
        p_body = NULL;
        i_body = 0;
        pp_body = &p_body;
        pi_body = &i_body;
    }",12,,325,1,,void
143185,BLOCK,-1,,"{
        /* msg_Warn not supported */
    }",42,,333,2,,void
143209,BLOCK,-1,,<empty>,9,,341,2,,void
143221,BLOCK,-1,,<empty>,9,,345,2,,void
143245,BLOCK,-1,,"{
    const char *mime = psz_mime;
    if (mime == NULL || mime[0] == '\0')
        mime = vlc_mime_Ext2Mime(psz_url);

    size_t mimelen = strlen(mime);
    httpd_file_t *file = malloc(sizeof(*file) + mimelen);
    if (unlikely(file == NULL))
        return NULL;

    file->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!file->url) {
        free(file);
        return NULL;
    }

    file->pf_fill = pf_fill;
    file->p_sys   = p_sys;
    memcpy(file->mime, mime, mimelen + 1);

    httpd_UrlCatch(file->url, HTTPD_MSG_HEAD, httpd_FileCallBack,
                    (httpd_callback_sys_t*)file);
    httpd_UrlCatch(file->url, HTTPD_MSG_GET,  httpd_FileCallBack,
                    (httpd_callback_sys_t*)file);
    httpd_UrlCatch(file->url, HTTPD_MSG_POST, httpd_FileCallBack,
                    (httpd_callback_sys_t*)file);

    return file;
}",1,,357,8,,void
143260,BLOCK,-1,,<empty>,9,,360,2,,void
143284,BLOCK,-1,,<empty>,9,,365,2,,void
143301,BLOCK,-1,,"{
        free(file);
        return NULL;
    }",21,,368,2,,void
143357,BLOCK,-1,,"{
    httpd_file_sys_t *p_sys = file->p_sys;

    httpd_UrlDelete(file->url);
    free(file);
    return p_sys;
}",1,,388,2,,void
143383,BLOCK,-1,,"{
    httpd_handler_t *handler = (httpd_handler_t*)p_sys;
    char psz_remote_addr[NI_MAXNUMERICHOST];

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_NONE;
    answer->i_type   = HTTPD_MSG_ANSWER;

    /* We do it ourselves, thanks */
    answer->i_status = 0;

    if (!httpd_ClientIP(cl, psz_remote_addr, NULL))
        *psz_remote_addr = '\0';

    uint8_t *psz_args = query->psz_args;
    handler->pf_fill(handler->p_sys, handler, query->psz_url, psz_args,
                      query->i_type, query->p_body, query->i_body,
                      psz_remote_addr, NULL,
                      &answer->p_body, &answer->i_body);

    if (query->i_type == HTTPD_MSG_HEAD) {
        char *p = (char *)answer->p_body;

        /* Looks for end of header (i.e. one empty line) */
        while ((p = strchr(p, '\r')))
            if (p[1] == '\n' && p[2] == '\r' && p[3] == '\n')
                break;

        if (p) {
            p[4] = '\0';
         ...",1,,411,5,,void
143397,BLOCK,-1,,<empty>,9,,416,2,,void
143421,BLOCK,-1,,<empty>,9,,425,2,,void
143469,BLOCK,-1,,"{
        char *p = (char *)answer->p_body;

        /* Looks for end of header (i.e. one empty line) */
        while ((p = strchr(p, '\r')))
            if (p[1] == '\n' && p[2] == '\r' && p[3] == '\n')
                break;

        if (p) {
            p[4] = '\0';
            answer->i_body = strlen((char*)answer->p_body) + 1;
            answer->p_body = xrealloc(answer->p_body, answer->i_body);
        }
    }",42,,433,2,,void
143502,BLOCK,-1,,<empty>,17,,439,2,,void
143506,BLOCK,-1,,"{
            p[4] = '\0';
            answer->i_body = strlen((char*)answer->p_body) + 1;
            answer->p_body = xrealloc(answer->p_body, answer->i_body);
        }",16,,441,2,,void
143544,BLOCK,-1,,"{
        int i_status, i_headers;
        char *psz_headers, *psz_new;
        const char *psz_status;

        if (!strncmp((char *)answer->p_body, ""Status: "", 8)) {
            /* Apache-style */
            i_status = strtol((char *)&answer->p_body[8], &psz_headers, 0);
            if (*psz_headers == '\r' || *psz_headers == '\n') psz_headers++;
            if (*psz_headers == '\n') psz_headers++;
            i_headers = answer->i_body - (psz_headers - (char *)answer->p_body);
        } else {
            i_status = 200;
            psz_headers = (char *)answer->p_body;
            i_headers = answer->i_body;
        }

        psz_status = httpd_ReasonFromCode(i_status);
        answer->i_body = sizeof(""HTTP/1.0 xxx \r\n"")
                        + strlen(psz_status) + i_headers - 1;
        psz_new = (char *)xmalloc(answer->i_body + 1);
        sprintf(psz_new, ""HTTP/1.0 %03d %s\r\n"", i_status, psz_status);
        memcpy(&psz_new[strlen(psz_new)], psz_headers, i_headers);
   ...",56,,448,2,,void
143560,BLOCK,-1,,"{
            /* Apache-style */
            i_status = strtol((char *)&answer->p_body[8], &psz_headers, 0);
            if (*psz_headers == '\r' || *psz_headers == '\n') psz_headers++;
            if (*psz_headers == '\n') psz_headers++;
            i_headers = answer->i_body - (psz_headers - (char *)answer->p_body);
        }",62,,453,2,,void
143585,BLOCK,-1,,<empty>,63,,456,2,,void
143593,BLOCK,-1,,<empty>,39,,457,2,,void
143610,BLOCK,-1,,"{
            i_status = 200;
            psz_headers = (char *)answer->p_body;
            i_headers = answer->i_body;
        }",16,,459,1,,void
143688,BLOCK,-1,,"{
    httpd_handler_t *handler = malloc(sizeof(*handler));
    if (!handler)
        return NULL;

    handler->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!handler->url) {
        free(handler);
        return NULL;
    }

    handler->pf_fill = pf_fill;
    handler->p_sys   = p_sys;

    httpd_UrlCatch(handler->url, HTTPD_MSG_HEAD, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_GET,  httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_POST, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);

    return handler;
}",1,,483,7,,void
143699,BLOCK,-1,,<empty>,9,,486,2,,void
143716,BLOCK,-1,,"{
        free(handler);
        return NULL;
    }",24,,489,2,,void
143764,BLOCK,-1,,"{
    void *p_sys = handler->p_sys;
    httpd_UrlDelete(handler->url);
    free(handler);
    return p_sys;
}",1,,508,2,,void
143785,BLOCK,-1,,<empty>,,,,1,,<empty>
143795,BLOCK,-1,,"{
    httpd_redirect_t *rdir = (httpd_redirect_t*)p_sys;
    char *p_body;
    (void)cl;

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;
    answer->i_status = 301;

    answer->i_body = httpd_HtmlError (&p_body, 301, rdir->dst);
    answer->p_body = (unsigned char *)p_body;

    /* XXX check if it's ok or we need to set an absolute url */
    httpd_MsgAdd(answer, ""Location"",  ""%s"", rdir->dst);

    httpd_MsgAdd(answer, ""Content-Length"", ""%d"", answer->i_body);

    if (httpd_MsgGet(&cl->query, ""Connection"") != NULL)
        httpd_MsgAdd(answer, ""Connection"", ""close"");

    return VLC_SUCCESS;
}",1,,527,5,,void
143812,BLOCK,-1,,<empty>,9,,533,2,,void
143876,BLOCK,-1,,<empty>,9,,549,2,,void
143889,BLOCK,-1,,"{
    size_t dstlen = strlen(psz_url_dst);

    httpd_redirect_t *rdir = malloc(sizeof(*rdir) + dstlen);
    if (unlikely(rdir == NULL))
        return NULL;

    rdir->url = httpd_UrlNew(host, psz_url_src, NULL, NULL);
    if (!rdir->url) {
        free(rdir);
        return NULL;
    }
    memcpy(rdir->dst, psz_url_dst, dstlen + 1);

    /* Redirect apply for all HTTP request and RTSP DESCRIBE resquest */
    httpd_UrlCatch(rdir->url, HTTPD_MSG_HEAD, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_GET, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_POST, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_DESCRIBE, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);

    return rdir;
}",1,,556,4,,void
143909,BLOCK,-1,,<empty>,9,,561,2,,void
143926,BLOCK,-1,,"{
        free(rdir);
        return NULL;
    }",21,,564,2,,void
143981,BLOCK,-1,,"{
    httpd_UrlDelete(rdir->url);
    free(rdir);
}",1,,583,2,,void
144009,BLOCK,-1,,"{
    httpd_stream_t *stream = (httpd_stream_t*)p_sys;

    if (!answer || !query || !cl)
        return VLC_SUCCESS;

    if (answer->i_body_offset > 0) {
        int     i_pos;

        if (answer->i_body_offset >= stream->i_buffer_pos)
            return VLC_EGENERIC;    /* wait, no data available */

        if (cl->i_keyframe_wait_to_pass >= 0) {
            if (stream->i_last_keyframe_seen_pos <= cl->i_keyframe_wait_to_pass)
                /* still waiting for the next keyframe */
                return VLC_EGENERIC;

            /* seek to the new keyframe */
            answer->i_body_offset = stream->i_last_keyframe_seen_pos;
            cl->i_keyframe_wait_to_pass = -1;
        }

        if (answer->i_body_offset + stream->i_buffer_size < stream->i_buffer_pos)
            answer->i_body_offset = stream->i_buffer_last_pos; /* this client isn't fast enough */

        i_pos   = answer->i_body_offset % stream->i_buffer_size;
        int64_t i_write = stream->i_buffer_pos - ...",1,,624,5,,void
144025,BLOCK,-1,,<empty>,9,,628,2,,void
144034,BLOCK,-1,,"{
        int     i_pos;

        if (answer->i_body_offset >= stream->i_buffer_pos)
            return VLC_EGENERIC;    /* wait, no data available */

        if (cl->i_keyframe_wait_to_pass >= 0) {
            if (stream->i_last_keyframe_seen_pos <= cl->i_keyframe_wait_to_pass)
                /* still waiting for the next keyframe */
                return VLC_EGENERIC;

            /* seek to the new keyframe */
            answer->i_body_offset = stream->i_last_keyframe_seen_pos;
            cl->i_keyframe_wait_to_pass = -1;
        }

        if (answer->i_body_offset + stream->i_buffer_size < stream->i_buffer_pos)
            answer->i_body_offset = stream->i_buffer_last_pos; /* this client isn't fast enough */

        i_pos   = answer->i_body_offset % stream->i_buffer_size;
        int64_t i_write = stream->i_buffer_pos - answer->i_body_offset;

        if (i_write > HTTPD_CL_BUFSIZE)
            i_write = HTTPD_CL_BUFSIZE;
        else if (i_write <= 0)
            return ...",36,,630,2,,void
144044,BLOCK,-1,,<empty>,13,,634,2,,void
144053,BLOCK,-1,,"{
            if (stream->i_last_keyframe_seen_pos <= cl->i_keyframe_wait_to_pass)
                /* still waiting for the next keyframe */
                return VLC_EGENERIC;

            /* seek to the new keyframe */
            answer->i_body_offset = stream->i_last_keyframe_seen_pos;
            cl->i_keyframe_wait_to_pass = -1;
        }",47,,636,2,,void
144062,BLOCK,-1,,<empty>,17,,639,2,,void
144090,BLOCK,-1,,<empty>,13,,647,2,,void
144121,BLOCK,1,,<empty>,,,,1,,void
144123,BLOCK,-1,,<empty>,13,,653,2,,void
144127,BLOCK,1,,<empty>,,,,1,,void
144130,BLOCK,-1,,<empty>,14,,654,1,,void
144135,BLOCK,-1,,<empty>,13,,655,2,,void
144192,BLOCK,-1,,"{
        answer->i_proto  = HTTPD_PROTO_HTTP;
        answer->i_version= 0;
        answer->i_type   = HTTPD_MSG_ANSWER;

        answer->i_status = 200;

        bool b_has_content_type = false;
        bool b_has_cache_control = false;

        vlc_mutex_lock(&stream->lock);
        for (size_t i = 0; i < stream->i_http_headers; i++)
            if (strncasecmp(stream->p_http_headers[i].name, ""Content-Length"", 14)) {
                httpd_MsgAdd(answer, stream->p_http_headers[i].name, ""%s"",
                              stream->p_http_headers[i].value);

                if (!strncasecmp(stream->p_http_headers[i].name, ""Content-Type"", 12))
                    b_has_content_type = true;
                else if (!strncasecmp(stream->p_http_headers[i].name, ""Cache-Control"", 13))
                    b_has_cache_control = true;
            }
        vlc_mutex_unlock(&stream->lock);

        if (query->i_type != HTTPD_MSG_HEAD) {
            cl->b_stream_mode = true;
            vlc_mut...",12,,672,1,,void
144227,BLOCK,-1,,<empty>,9,,683,1,,void
144250,BLOCK,-1,,"{
                httpd_MsgAdd(answer, stream->p_http_headers[i].name, ""%s"",
                              stream->p_http_headers[i].value);

                if (!strncasecmp(stream->p_http_headers[i].name, ""Content-Type"", 12))
                    b_has_content_type = true;
                else if (!strncasecmp(stream->p_http_headers[i].name, ""Cache-Control"", 13))
                    b_has_cache_control = true;
            }",84,,684,2,,void
144280,BLOCK,-1,,<empty>,21,,689,2,,void
144285,BLOCK,-1,,<empty>,22,,690,1,,void
144298,BLOCK,-1,,<empty>,21,,691,2,,void
144313,BLOCK,-1,,"{
            cl->b_stream_mode = true;
            vlc_mutex_lock(&stream->lock);
            /* Send the header */
            if (stream->i_header > 0) {
                answer->i_body = stream->i_header;
                answer->p_body = xmalloc(stream->i_header);
                memcpy(answer->p_body, stream->p_header, stream->i_header);
            }
            answer->i_body_offset = stream->i_buffer_last_pos;
            if (stream->b_has_keyframes)
                cl->i_keyframe_wait_to_pass = stream->i_last_keyframe_seen_pos;
            else
                cl->i_keyframe_wait_to_pass = -1;
            vlc_mutex_unlock(&stream->lock);
        }",46,,695,2,,void
144330,BLOCK,-1,,"{
                answer->i_body = stream->i_header;
                answer->p_body = xmalloc(stream->i_header);
                memcpy(answer->p_body, stream->p_header, stream->i_header);
            }",39,,699,2,,void
144367,BLOCK,-1,,<empty>,17,,706,2,,void
144376,BLOCK,-1,,<empty>,17,,708,1,,void
144389,BLOCK,-1,,"{
            httpd_MsgAdd(answer, ""Content-Length"", ""0"");
            answer->i_body_offset = 0;
        }",16,,710,1,,void
144406,BLOCK,-1,,"{
            bool b_xplaystream = false;

            httpd_MsgAdd(answer, ""Content-type"", ""application/octet-stream"");
            httpd_MsgAdd(answer, ""Server"", ""Cougar 4.1.0.3921"");
            httpd_MsgAdd(answer, ""Pragma"", ""no-cache"");
            httpd_MsgAdd(answer, ""Pragma"", ""client-id=%lu"",
                          vlc_mrand48()&0x7fff);
            httpd_MsgAdd(answer, ""Pragma"", ""features=\""broadcast\"""");

            /* Check if there is a xPlayStrm=1 */
            for (size_t i = 0; i < query->i_headers; i++)
                if (!strcasecmp(query->p_headers[i].name,  ""Pragma"") &&
                    strstr(query->p_headers[i].value, ""xPlayStrm=1""))
                    b_xplaystream = true;

            if (!b_xplaystream)
                answer->i_body_offset = 0;
        }",65,,716,2,,void
144435,BLOCK,-1,,<empty>,13,,727,1,,void
144468,BLOCK,-1,,<empty>,21,,730,2,,void
144475,BLOCK,-1,,<empty>,17,,733,2,,void
144482,BLOCK,-1,,<empty>,16,,734,1,,void
144486,BLOCK,-1,,<empty>,13,,735,2,,void
144497,BLOCK,-1,,<empty>,13,,738,2,,void
144516,BLOCK,-1,,"{
    httpd_stream_t *stream = malloc(sizeof(*stream));
    if (!stream)
        return NULL;

    stream->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!stream->url) {
        free(stream);
        return NULL;
    }

    vlc_mutex_init(&stream->lock);
    if (psz_mime == NULL || psz_mime[0] == '\0')
        psz_mime = vlc_mime_Ext2Mime(psz_url);
    stream->psz_mime = xstrdup(psz_mime);

    stream->i_header = 0;
    stream->p_header = NULL;
    stream->i_buffer_size = 5000000;    /* 5 Mo per stream */
    stream->p_buffer = xmalloc(stream->i_buffer_size);
    /* We set to 1 to make life simpler
     * (this way i_body_offset can never be 0) */
    stream->i_buffer_pos = 1;
    stream->i_buffer_last_pos = 1;
    stream->b_has_keyframes = false;
    stream->i_last_keyframe_seen_pos = 0;
    stream->i_http_headers = 0;
    stream->p_http_headers = NULL;

    httpd_UrlCatch(stream->url, HTTPD_MSG_HEAD, httpd_StreamCallBack,
                    (httpd_callback_sys...",1,,749,6,,void
144527,BLOCK,-1,,<empty>,9,,752,2,,void
144544,BLOCK,-1,,"{
        free(stream);
        return NULL;
    }",23,,755,2,,void
144564,BLOCK,-1,,<empty>,9,,762,2,,void
144663,BLOCK,-1,,"{
    vlc_mutex_lock(&stream->lock);
    free(stream->p_header);
    stream->p_header = NULL;

    stream->i_header = i_data;
    if (i_data > 0) {
        stream->p_header = xmalloc(i_data);
        memcpy(stream->p_header, p_data, i_data);
    }
    vlc_mutex_unlock(&stream->lock);

    return VLC_SUCCESS;
}",1,,789,4,,void
144687,BLOCK,-1,,"{
        stream->p_header = xmalloc(i_data);
        memcpy(stream->p_header, p_data, i_data);
    }",21,,795,2,,void
144713,BLOCK,-1,,"{
    int i_pos = stream->i_buffer_pos % stream->i_buffer_size;
    int i_count = i_data;
    while (i_count > 0) {
        int i_copy = __MIN(i_count, stream->i_buffer_size - i_pos);

        /* Ok, we can't go past the end of our buffer */
        memcpy(&stream->p_buffer[i_pos], p_data, i_copy);

        i_pos = (i_pos + i_copy) % stream->i_buffer_size;
        i_count -= i_copy;
        p_data  += i_copy;
    }

    stream->i_buffer_pos += i_data;
}",1,,805,4,,void
144732,BLOCK,-1,,"{
        int i_copy = __MIN(i_count, stream->i_buffer_size - i_pos);

        /* Ok, we can't go past the end of our buffer */
        memcpy(&stream->p_buffer[i_pos], p_data, i_copy);

        i_pos = (i_pos + i_copy) % stream->i_buffer_size;
        i_count -= i_copy;
        p_data  += i_copy;
    }",25,,808,2,,void
144777,BLOCK,-1,,"{
    if (!p_block || !p_block->p_buffer)
        return VLC_SUCCESS;

    vlc_mutex_lock(&stream->lock);

    /* save this pointer (to be used by new connection) */
    stream->i_buffer_last_pos = stream->i_buffer_pos;

    if (p_block->i_flags & BLOCK_FLAG_TYPE_I) {
        stream->b_has_keyframes = true;
        stream->i_last_keyframe_seen_pos = stream->i_buffer_pos;
    }

    httpd_AppendData(stream, p_block->p_buffer, p_block->i_buffer);

    vlc_mutex_unlock(&stream->lock);
    return VLC_SUCCESS;
}",1,,823,3,,void
144786,BLOCK,-1,,<empty>,9,,825,2,,void
144807,BLOCK,-1,,"{
        stream->b_has_keyframes = true;
        stream->i_last_keyframe_seen_pos = stream->i_buffer_pos;
    }",47,,832,2,,void
144839,BLOCK,-1,,"{
    httpd_UrlDelete(stream->url);
    for (size_t i = 0; i < stream->i_http_headers; i++) {
        free(stream->p_http_headers[i].name);
        free(stream->p_http_headers[i].value);
    }
    free(stream->p_http_headers);
    vlc_mutex_destroy(&stream->lock);
    free(stream->psz_mime);
    free(stream->p_header);
    free(stream->p_buffer);
    free(stream);
}",1,,844,2,,void
144845,BLOCK,-1,,<empty>,5,,846,1,,void
144857,BLOCK,4,,"{
        free(stream->p_http_headers[i].name);
        free(stream->p_http_headers[i].value);
    }",57,,846,4,,void
144901,BLOCK,-1,,<empty>,,,,2,,<empty>
144910,BLOCK,-1,,<empty>,,,,6,,<empty>
144915,BLOCK,-1,,"{
    return httpd_HostCreate(p_this, ""http-host"", ""http-port"", NULL, 10);
}",1,,868,2,,void
144927,BLOCK,-1,,"{
    char *cert = var_InheritString(obj, ""http-cert"");
    if (!cert) {
        msg_Err(obj, ""HTTP/TLS certificate not specified!"");
        return NULL;
    }

    char *key = var_InheritString(obj, ""http-key"");
    vlc_tls_creds_t *tls = vlc_tls_ServerCreate(obj, cert, key);

    if (!tls) {
        msg_Err(obj, ""HTTP/TLS certificate error (%s and %s)"",
                 cert, key ? key : cert);
        free(key);
        free(cert);
        return NULL;
    }
    free(key);
    free(cert);

    return httpd_HostCreate(obj, ""http-host"", ""https-port"", tls, 10);
}",1,,873,2,,void
144937,BLOCK,-1,,"{
        msg_Err(obj, ""HTTP/TLS certificate not specified!"");
        return NULL;
    }",16,,875,2,,void
144959,BLOCK,-1,,"{
        msg_Err(obj, ""HTTP/TLS certificate error (%s and %s)"",
                 cert, key ? key : cert);
        free(key);
        free(cert);
        return NULL;
    }",15,,883,2,,void
144989,BLOCK,-1,,"{
    unsigned timeout = var_InheritInteger(p_this, ""rtsp-timeout"");
    return httpd_HostCreate(p_this, ""rtsp-host"", ""rtsp-port"", NULL, timeout);
}",1,,897,2,,void
145022,BLOCK,-1,,"{
    httpd_host_t *host;
    unsigned port = var_InheritInteger(p_this, portvar);

    /* to be sure to avoid multiple creation */
    vlc_mutex_lock(&httpd.mutex);

    /* verify if it already exist */
    for (int i = 0; i < httpd.i_host; i++) {
        host = httpd.host[i];

        /* cannot mix TLS and non-TLS hosts */
        if (host->port != port
         || (host->p_tls != NULL) != (p_tls != NULL))
            continue;

        /* Increase existing matching host reference count.
         * The reference count is written under both the global httpd and the
         * host lock. It is read with either or both locks held. The global
         * lock is always acquired first. */
        vlc_mutex_lock(&host->lock);
        host->i_ref++;
        vlc_mutex_unlock(&host->lock);

        vlc_mutex_unlock(&httpd.mutex);
        vlc_tls_Delete(p_tls);
        return host;
    }

    /* create the new host */
    host = (httpd_host_t *)vlc_custom_create(p_this, sizeof (*host),
     ...",1,,915,6,,void
145036,BLOCK,-1,,<empty>,5,,923,1,,void
145048,BLOCK,4,,"{
        host = httpd.host[i];

        /* cannot mix TLS and non-TLS hosts */
        if (host->port != port
         || (host->p_tls != NULL) != (p_tls != NULL))
            continue;

        /* Increase existing matching host reference count.
         * The reference count is written under both the global httpd and the
         * host lock. It is read with either or both locks held. The global
         * lock is always acquired first. */
        vlc_mutex_lock(&host->lock);
        host->i_ref++;
        vlc_mutex_unlock(&host->lock);

        vlc_mutex_unlock(&httpd.mutex);
        vlc_tls_Delete(p_tls);
        return host;
    }",44,,923,4,,void
145072,BLOCK,-1,,<empty>,13,,929,2,,void
145103,BLOCK,1,,<empty>,,,,3,,void
145114,BLOCK,-1,,<empty>,9,,948,2,,void
145144,BLOCK,-1,,<empty>,9,,956,2,,void
145169,BLOCK,-1,,"{
        msg_Err(p_this, ""cannot create socket(s) for HTTP host"");
        goto error;
    }",21,,963,2,,void
145175,BLOCK,-1,,<empty>,5,,967,1,,void
145239,BLOCK,-1,,"{
        msg_Err(p_this, ""cannot spawn http host thread"");
        goto error;
    }",46,,979,2,,void
145267,BLOCK,-1,,"{
        net_ListenClose(host->fds);
        vlc_cond_destroy(&host->wait);
        vlc_mutex_destroy(&host->lock);
        vlc_object_release(host);
    }",15,,993,2,,void
145292,BLOCK,-1,,"{
    bool delete = false;

    vlc_mutex_lock(&httpd.mutex);

    vlc_mutex_lock(&host->lock);
    host->i_ref--;
    if (host->i_ref == 0)
        delete = true;
    vlc_mutex_unlock(&host->lock);
    if (!delete) {
        /* still used */
        vlc_mutex_unlock(&httpd.mutex);
        msg_Dbg(host, ""httpd_HostDelete: host still in use"");
        return;
    }
    TAB_REMOVE(httpd.i_host, httpd.host, host);

    vlc_cancel(host->thread);
    vlc_join(host->thread, NULL);

    msg_Dbg(host, ""HTTP host removed"");

    for (int i = 0; i < host->i_url; i++)
        msg_Err(host, ""url still registered: %s"", host->url[i]->psz_url);

    for (int i = 0; i < host->i_client; i++) {
        msg_Warn(host, ""client still connected"");
        httpd_ClientDestroy(host->client[i]);
    }
    TAB_CLEAN(host->i_client, host->client);

    vlc_tls_Delete(host->p_tls);
    net_ListenClose(host->fds);
    vlc_cond_destroy(&host->wait);
    vlc_mutex_destroy(&host->lock);
    vlc_object_release(host...",1,,1006,2,,void
145317,BLOCK,-1,,<empty>,9,,1014,2,,void
145329,BLOCK,-1,,"{
        /* still used */
        vlc_mutex_unlock(&httpd.mutex);
        msg_Dbg(host, ""httpd_HostDelete: host still in use"");
        return;
    }",18,,1016,2,,void
145360,BLOCK,-1,,<empty>,5,,1029,1,,void
145383,BLOCK,-1,,<empty>,5,,1032,1,,void
145395,BLOCK,4,,"{
        msg_Warn(host, ""client still connected"");
        httpd_ClientDestroy(host->client[i]);
    }",46,,1032,4,,void
145444,BLOCK,-1,,"{
    httpd_url_t *url;

    assert(psz_url);

    vlc_mutex_lock(&host->lock);
    for (int i = 0; i < host->i_url; i++)
        if (!strcmp(psz_url, host->url[i]->psz_url)) {
            msg_Warn(host, ""cannot add '%s' (url already defined)"", psz_url);
            vlc_mutex_unlock(&host->lock);
            return NULL;
        }

    url = xmalloc(sizeof(httpd_url_t));
    url->host = host;

    vlc_mutex_init(&url->lock);
    url->psz_url = xstrdup(psz_url);
    url->psz_user = xstrdup(psz_user ? psz_user : """");
    url->psz_password = xstrdup(psz_password ? psz_password : """");
    for (int i = 0; i < HTTPD_MSG_MAX; i++) {
        url->catch[i].cb = NULL;
        url->catch[i].p_sys = NULL;
    }

    TAB_APPEND(host->i_url, host->url, url);
    vlc_cond_signal(&host->wait);
    vlc_mutex_unlock(&host->lock);

    return url;
}",1,,1049,5,,void
145454,BLOCK,-1,,<empty>,5,,1055,1,,void
145477,BLOCK,-1,,"{
            msg_Warn(host, ""cannot add '%s' (url already defined)"", psz_url);
            vlc_mutex_unlock(&host->lock);
            return NULL;
        }",54,,1056,2,,void
145529,BLOCK,-1,,<empty>,5,,1069,1,,void
145539,BLOCK,4,,"{
        url->catch[i].cb = NULL;
        url->catch[i].p_sys = NULL;
    }",45,,1069,4,,void
145585,BLOCK,-1,,"{
    vlc_mutex_lock(&url->lock);
    url->catch[i_msg].cb   = cb;
    url->catch[i_msg].p_sys= p_sys;
    vlc_mutex_unlock(&url->lock);

    return VLC_SUCCESS;
}",1,,1084,5,,void
145620,BLOCK,-1,,"{
    httpd_host_t *host = url->host;

    vlc_mutex_lock(&host->lock);
    TAB_REMOVE(host->i_url, host->url, url);

    vlc_mutex_destroy(&url->lock);
    free(url->psz_url);
    free(url->psz_user);
    free(url->psz_password);

    for (int i = 0; i < host->i_client; i++) {
        httpd_client_t *client = host->client[i];

        if (client->url != url)
            continue;

        /* TODO complete it */
        msg_Warn(host, ""force closing connections"");
        TAB_REMOVE(host->i_client, host->client, client);
        httpd_ClientDestroy(client);
        i--;
    }
    free(url);
    vlc_mutex_unlock(&host->lock);
}",1,,1095,2,,void
145658,BLOCK,-1,,<empty>,5,,1106,1,,void
145670,BLOCK,4,,"{
        httpd_client_t *client = host->client[i];

        if (client->url != url)
            continue;

        /* TODO complete it */
        msg_Warn(host, ""force closing connections"");
        TAB_REMOVE(host->i_client, host->client, client);
        httpd_ClientDestroy(client);
        i--;
    }",46,,1106,4,,void
145685,BLOCK,-1,,<empty>,13,,1110,2,,void
145713,BLOCK,-1,,"{
    msg->cl         = NULL;
    msg->i_type     = HTTPD_MSG_NONE;
    msg->i_proto    = HTTPD_PROTO_NONE;
    msg->i_version  = -1; /* FIXME */

    msg->i_status   = 0;

    msg->psz_url    = NULL;
    msg->psz_args   = NULL;

    msg->i_headers  = 0;
    msg->p_headers  = NULL;

    msg->i_body_offset = 0;
    msg->i_body        = 0;
    msg->p_body        = NULL;
}",1,,1123,2,,void
145779,BLOCK,-1,,"{
    free(msg->psz_url);
    free(msg->psz_args);
    for (size_t i = 0; i < msg->i_headers; i++) {
        free(msg->p_headers[i].name);
        free(msg->p_headers[i].value);
    }
    free(msg->p_headers);
    free(msg->p_body);
    httpd_MsgInit(msg);
}",1,,1143,2,,void
145789,BLOCK,-1,,<empty>,5,,1146,1,,void
145801,BLOCK,4,,"{
        free(msg->p_headers[i].name);
        free(msg->p_headers[i].value);
    }",49,,1146,4,,void
145833,BLOCK,-1,,"{
    for (size_t i = 0; i < msg->i_headers; i++)
        if (!strcasecmp(msg->p_headers[i].name, name))
            return msg->p_headers[i].value;
    return NULL;
}",1,,1156,3,,void
145835,BLOCK,-1,,<empty>,5,,1157,1,,void
145858,BLOCK,-1,,<empty>,13,,1159,2,,void
145875,BLOCK,-1,,"{
    httpd_header *p_tmp = realloc(msg->p_headers, sizeof(httpd_header) * (msg->i_headers + 1));
    if (!p_tmp)
        return;

    msg->p_headers = p_tmp;

    httpd_header *h = &msg->p_headers[msg->i_headers];
    h->name = strdup(name);
    if (!h->name)
        return;

    h->value = NULL;

    va_list args;
    va_start(args, psz_value);
    int ret = us_vasprintf(&h->value, psz_value, args);
    va_end(args);

    if (ret == -1) {
        free(h->name);
        return;
    }

    msg->i_headers++;
}",1,,1164,4,,void
145894,BLOCK,-1,,<empty>,9,,1167,2,,void
145923,BLOCK,-1,,<empty>,9,,1174,2,,void
145951,BLOCK,-1,,"{
        free(h->name);
        return;
    }",20,,1183,2,,void
145965,BLOCK,-1,,"{
    cl->i_state = HTTPD_CLIENT_RECEIVING;
    cl->i_buffer_size = HTTPD_CL_BUFSIZE;
    cl->i_buffer = 0;
    cl->p_buffer = xmalloc(cl->i_buffer_size);
    cl->i_keyframe_wait_to_pass = -1;
    cl->b_stream_mode = false;

    httpd_MsgInit(&cl->query);
    httpd_MsgInit(&cl->answer);
}",1,,1192,2,,void
145976,BLOCK,1,,<empty>,,,,1,,void
146018,BLOCK,-1,,"{
    return net_GetPeerAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1,,1205,4,,void
146036,BLOCK,-1,,"{
    return net_GetSockAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1,,1210,4,,void
146052,BLOCK,-1,,"{
    vlc_tls_Close(cl->sock);
    httpd_MsgClean(&cl->answer);
    httpd_MsgClean(&cl->query);

    free(cl->p_buffer);
    free(cl);
}",1,,1215,2,,void
146077,BLOCK,-1,,"{
    httpd_client_t *cl = malloc(sizeof(httpd_client_t));

    if (!cl) return NULL;

    cl->i_ref   = 0;
    cl->sock    = sock;
    cl->url     = NULL;

    httpd_ClientInit(cl);
    return cl;
}",1,,1225,2,,void
146087,BLOCK,-1,,<empty>,14,,1228,2,,void
146115,BLOCK,-1,,"{
    vlc_tls_t *sock = cl->sock;
    struct iovec iov = { .iov_base = p, .iov_len = i_len };
    return sock->readv(sock, &iov, 1);
}",1,,1240,4,,void
146126,BLOCK,1,,<empty>,26,,1242,1,,void
146130,BLOCK,2,,<empty>,41,,1242,2,,void
146149,BLOCK,-1,,"{
    vlc_tls_t *sock = cl->sock;
    const struct iovec iov = { .iov_base = (void *)p, .iov_len = i_len };
    return sock->writev(sock, &iov, 1);
}",1,,1248,4,,void
146160,BLOCK,1,,<empty>,32,,1250,1,,void
146166,BLOCK,2,,<empty>,55,,1250,2,,void
146186,BLOCK,-1,,<empty>,,,,1,,<empty>
146241,BLOCK,-1,,"{
    int i_len;

    /* ignore leading whites */
    if (cl->query.i_proto == HTTPD_PROTO_NONE && cl->i_buffer == 0) {
        unsigned char c;

        i_len = httpd_NetRecv(cl, &c, 1);

        if (i_len > 0 && !strchr(""\r\n\t "", c)) {
            cl->p_buffer[0] = c;
            cl->i_buffer++;
        }
    } else if (cl->query.i_proto == HTTPD_PROTO_NONE) {
        /* enough to see if it's Interleaved RTP over RTSP or RTSP/HTTP */
        i_len = httpd_NetRecv(cl, &cl->p_buffer[cl->i_buffer],
                               7 - cl->i_buffer);
        if (i_len > 0)
            cl->i_buffer += i_len;

        /* The smallest legal request is 7 bytes (""GET /\r\n""),
         * this is the maximum we can ask at this point. */
        if (cl->i_buffer >= 7) {
            if (!memcmp(cl->p_buffer, ""HTTP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } else if (!memcmp(cl->p_buffer, ""RTSP/1."", 7)) {
  ...",1,,1278,2,,void
146257,BLOCK,-1,,"{
        unsigned char c;

        i_len = httpd_NetRecv(cl, &c, 1);

        if (i_len > 0 && !strchr(""\r\n\t "", c)) {
            cl->p_buffer[0] = c;
            cl->i_buffer++;
        }
    }",69,,1282,2,,void
146275,BLOCK,-1,,"{
            cl->p_buffer[0] = c;
            cl->i_buffer++;
        }",49,,1287,2,,void
146288,BLOCK,-1,,<empty>,12,,1291,1,,void
146297,BLOCK,-1,,"{
        /* enough to see if it's Interleaved RTP over RTSP or RTSP/HTTP */
        i_len = httpd_NetRecv(cl, &cl->p_buffer[cl->i_buffer],
                               7 - cl->i_buffer);
        if (i_len > 0)
            cl->i_buffer += i_len;

        /* The smallest legal request is 7 bytes (""GET /\r\n""),
         * this is the maximum we can ask at this point. */
        if (cl->i_buffer >= 7) {
            if (!memcmp(cl->p_buffer, ""HTTP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } else if (!memcmp(cl->p_buffer, ""RTSP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_RTSP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } else {
                /* We need the full request line to determine the protocol. */
                cl->query.i_proto = HTTPD_PROTO_HTTP0;
                cl->query.i_type  = HTTPD_MSG_NONE;
            }
        }
    }",55,,1291,2,,void
146319,BLOCK,-1,,<empty>,13,,1296,2,,void
146331,BLOCK,-1,,"{
            if (!memcmp(cl->p_buffer, ""HTTP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } else if (!memcmp(cl->p_buffer, ""RTSP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_RTSP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } else {
                /* We need the full request line to determine the protocol. */
                cl->query.i_proto = HTTPD_PROTO_HTTP0;
                cl->query.i_type  = HTTPD_MSG_NONE;
            }
        }",32,,1300,2,,void
146340,BLOCK,-1,,"{
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            }",54,,1301,2,,void
146356,BLOCK,-1,,<empty>,20,,1304,1,,void
146365,BLOCK,-1,,"{
                cl->query.i_proto = HTTPD_PROTO_RTSP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            }",61,,1304,2,,void
146381,BLOCK,-1,,"{
                /* We need the full request line to determine the protocol. */
                cl->query.i_proto = HTTPD_PROTO_HTTP0;
                cl->query.i_type  = HTTPD_MSG_NONE;
            }",20,,1307,1,,void
146397,BLOCK,-1,,<empty>,12,,1313,1,,void
146406,BLOCK,-1,,"{
        /* we are reading the body of a request or a channel */
        assert (cl->query.p_body != NULL);
        i_len = httpd_NetRecv(cl, &cl->query.p_body[cl->i_buffer],
                               cl->query.i_body - cl->i_buffer);
        if (i_len > 0)
            cl->i_buffer += i_len;

        if (cl->i_buffer >= cl->query.i_body)
            cl->i_state = HTTPD_CLIENT_RECEIVE_DONE;
    }",38,,1313,2,,void
146442,BLOCK,-1,,<empty>,13,,1319,2,,void
146458,BLOCK,-1,,<empty>,13,,1322,2,,void
146465,BLOCK,-1,,<empty>,12,,1323,1,,void
146467,BLOCK,-1,,<empty>,12,,1323,1,,void
146468,BLOCK,4,,"{ /* we are reading a header -> char by char */
        if (cl->i_buffer == cl->i_buffer_size) {
            // Allocate an extra byte for the termination null byte
            uint8_t *newbuf = realloc(cl->p_buffer, cl->i_buffer_size + 1025);
            if (!newbuf) {
                i_len = 0;
                break;
            }

            cl->p_buffer = newbuf;
            cl->i_buffer_size += 1024;
        }

        i_len = httpd_NetRecv (cl, &cl->p_buffer[cl->i_buffer], 1);
        if (i_len <= 0)
            break;

        cl->i_buffer++;

        if ((cl->query.i_proto == HTTPD_PROTO_HTTP0)
                && (cl->p_buffer[cl->i_buffer - 1] == '\n'))
        {
            /* Request line is now complete */
            const char *p = memchr(cl->p_buffer, ' ', cl->i_buffer);
            size_t len;

            assert(cl->query.i_type == HTTPD_MSG_NONE);

            if (!p) { /* no URI: evil guy */
                i_len = 0; /* drop connection */
                break;
...",21,,1323,4,,void
146477,BLOCK,-1,,"{
            // Allocate an extra byte for the termination null byte
            uint8_t *newbuf = realloc(cl->p_buffer, cl->i_buffer_size + 1025);
            if (!newbuf) {
                i_len = 0;
                break;
            }

            cl->p_buffer = newbuf;
            cl->i_buffer_size += 1024;
        }",48,,1324,2,,void
146493,BLOCK,-1,,"{
                i_len = 0;
                break;
            }",26,,1327,2,,void
146525,BLOCK,-1,,<empty>,13,,1338,2,,void
146551,BLOCK,-1,,"{
            /* Request line is now complete */
            const char *p = memchr(cl->p_buffer, ' ', cl->i_buffer);
            size_t len;

            assert(cl->query.i_type == HTTPD_MSG_NONE);

            if (!p) { /* no URI: evil guy */
                i_len = 0; /* drop connection */
                break;
            }

            do
                p++; /* skips extra spaces */
            while (*p == ' ');

            p = memchr(p, ' ', ((char *)cl->p_buffer) + cl->i_buffer - p);
            if (!p) { /* no explicit protocol: HTTP/0.9 */
                i_len = 0; /* not supported currently -> drop */
                break;
            }

            do
                p++; /* skips extra spaces ever again */
            while (*p == ' ');

            len = ((char *)cl->p_buffer) + cl->i_buffer - p;
            if (len < 7) /* foreign protocol */
                i_len = 0; /* I don't understand -> drop */
            else if (!memcmp(p, ""HTTP/1."", 7)) {
             ...",9,,1344,2,,void
146575,BLOCK,-1,,"{ /* no URI: evil guy */
                i_len = 0; /* drop connection */
                break;
            }",21,,1351,2,,void
146606,BLOCK,-1,,"{ /* no explicit protocol: HTTP/0.9 */
                i_len = 0; /* not supported currently -> drop */
                break;
            }",21,,1361,2,,void
146635,BLOCK,-1,,<empty>,17,,1372,2,,void
146640,BLOCK,-1,,<empty>,18,,1373,1,,void
146647,BLOCK,-1,,"{
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_version = atoi(p + 7);
            }",48,,1373,2,,void
146666,BLOCK,-1,,<empty>,20,,1376,1,,void
146673,BLOCK,-1,,"{
                cl->query.i_proto = HTTPD_PROTO_RTSP;
                cl->query.i_version = atoi(p + 7);
            }",50,,1376,2,,void
146692,BLOCK,-1,,<empty>,20,,1379,1,,void
146699,BLOCK,-1,,"{
                const uint8_t sorry[] =
                    ""HTTP/1.1 505 Unknown HTTP version\r\n\r\n"";
                httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                i_len = 0; /* drop */
            }",48,,1379,2,,void
146715,BLOCK,-1,,<empty>,20,,1384,1,,void
146722,BLOCK,-1,,"{
                const uint8_t sorry[] =
                    ""RTSP/1.0 505 Unknown RTSP version\r\n\r\n"";
                httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                i_len = 0; /* drop */
            }",48,,1384,2,,void
146738,BLOCK,-1,,<empty>,17,,1390,1,,void
146746,BLOCK,-1,,<empty>,17,,1393,2,,void
146790,BLOCK,-1,,"{
            char *p;

            /* we have finished the header so parse it and set i_body */
            cl->p_buffer[cl->i_buffer] = '\0';

            if (cl->query.i_type == HTTPD_MSG_ANSWER) {
                /* FIXME:
                 * assume strlen(""HTTP/1.x"") = 8
                 */
                cl->query.i_status =
                    strtol((char *)&cl->p_buffer[8],
                            &p, 0);
                while (*p == ' ')
                    p++;
            } else {
                p = NULL;
                cl->query.i_type = HTTPD_MSG_NONE;

                for (unsigned i = 0; msg_type[i].name[0]; i++)
                    if (!strncmp((char *)cl->p_buffer, msg_type[i].name,
                                strlen(msg_type[i].name))) {
                        p = (char *)&cl->p_buffer[strlen(msg_type[i].name) + 1 ];
                        cl->query.i_type = msg_type[i].i_type;
                        if (cl->query.i_proto != msg_type[i].i_proto) {
   ...",9,,1398,2,,void
146809,BLOCK,-1,,"{
                /* FIXME:
                 * assume strlen(""HTTP/1.x"") = 8
                 */
                cl->query.i_status =
                    strtol((char *)&cl->p_buffer[8],
                            &p, 0);
                while (*p == ' ')
                    p++;
            }",55,,1404,2,,void
146836,BLOCK,-1,,"{
                p = NULL;
                cl->query.i_type = HTTPD_MSG_NONE;

                for (unsigned i = 0; msg_type[i].name[0]; i++)
                    if (!strncmp((char *)cl->p_buffer, msg_type[i].name,
                                strlen(msg_type[i].name))) {
                        p = (char *)&cl->p_buffer[strlen(msg_type[i].name) + 1 ];
                        cl->query.i_type = msg_type[i].i_type;
                        if (cl->query.i_proto != msg_type[i].i_proto) {
                            p = NULL;
                            cl->query.i_proto = HTTPD_PROTO_NONE;
                            cl->query.i_type = HTTPD_MSG_NONE;
                        }
                        break;
                    }

                if (!p) {
                    if (strstr((char *)cl->p_buffer, ""HTTP/1.""))
                        cl->query.i_proto = HTTPD_PROTO_HTTP;
                    else if (strstr((char *)cl->p_buffer, ""RTSP/1.""))
                        cl->query...",20,,1413,1,,void
146848,BLOCK,-1,,<empty>,17,,1417,1,,void
146881,BLOCK,-1,,"{
                        p = (char *)&cl->p_buffer[strlen(msg_type[i].name) + 1 ];
                        cl->query.i_type = msg_type[i].i_type;
                        if (cl->query.i_proto != msg_type[i].i_proto) {
                            p = NULL;
                            cl->query.i_proto = HTTPD_PROTO_NONE;
                            cl->query.i_type = HTTPD_MSG_NONE;
                        }
                        break;
                    }",60,,1419,2,,void
146922,BLOCK,-1,,"{
                            p = NULL;
                            cl->query.i_proto = HTTPD_PROTO_NONE;
                            cl->query.i_type = HTTPD_MSG_NONE;
                        }",71,,1422,2,,void
146944,BLOCK,-1,,"{
                    if (strstr((char *)cl->p_buffer, ""HTTP/1.""))
                        cl->query.i_proto = HTTPD_PROTO_HTTP;
                    else if (strstr((char *)cl->p_buffer, ""RTSP/1.""))
                        cl->query.i_proto = HTTPD_PROTO_RTSP;
                }",25,,1430,2,,void
146953,BLOCK,-1,,<empty>,25,,1432,2,,void
146962,BLOCK,-1,,<empty>,26,,1433,1,,void
146971,BLOCK,-1,,<empty>,25,,1434,2,,void
146980,BLOCK,-1,,"{
                    char *p2;
                    char *p3;

                    while (*p == ' ')
                        p++;

                    p2 = strchr(p, ' ');
                    if (p2)
                        *p2++ = '\0';

                    if (!strncasecmp(p, (cl->query.i_proto == HTTPD_PROTO_HTTP) ? ""http:"" : ""rtsp:"", 5)) {
                        /* Skip hier-part of URL (if present) */
                        p += 5;
                        if (!strncmp(p, ""//"", 2)) { /* skip authority */
                            /* see RFC3986 §3.2 */
                            p += 2;
                            p += strcspn(p, ""/?#"");
                        }
                    }
                    else if (!strncasecmp(p, (cl->query.i_proto == HTTPD_PROTO_HTTP) ? ""https:"" : ""rtsps:"", 6)) {
                        /* Skip hier-part of URL (if present) */
                        p += 6;
                        if (!strncmp(p, ""//"", 2)) { /* skip authority */
          ...",24,,1435,1,,void
146997,BLOCK,-1,,<empty>,25,,1444,2,,void
147018,BLOCK,-1,,"{
                        /* Skip hier-part of URL (if present) */
                        p += 5;
                        if (!strncmp(p, ""//"", 2)) { /* skip authority */
                            /* see RFC3986 §3.2 */
                            p += 2;
                            p += strcspn(p, ""/?#"");
                        }
                    }",106,,1446,2,,void
147028,BLOCK,-1,,"{ /* skip authority */
                            /* see RFC3986 §3.2 */
                            p += 2;
                            p += strcspn(p, ""/?#"");
                        }",51,,1449,2,,void
147038,BLOCK,-1,,<empty>,26,,1455,1,,void
147054,BLOCK,-1,,"{
                        /* Skip hier-part of URL (if present) */
                        p += 6;
                        if (!strncmp(p, ""//"", 2)) { /* skip authority */
                            /* see RFC3986 §3.2 */
                            p += 2;
                            p += strcspn(p, ""/?#"");
                        }
                    }",113,,1455,2,,void
147064,BLOCK,-1,,"{ /* skip authority */
                            /* see RFC3986 §3.2 */
                            p += 2;
                            p += strcspn(p, ""/?#"");
                        }",51,,1458,2,,void
147081,BLOCK,-1,,"{
                        cl->query.psz_url = strdup(p);
                        if ((p3 = strchr(cl->query.psz_url, '?')) ) {
                            *p3++ = '\0';
                            cl->query.psz_args = (uint8_t *)strdup(p3);
                        }
                    }",51,,1465,2,,void
147100,BLOCK,-1,,"{
                            *p3++ = '\0';
                            cl->query.psz_args = (uint8_t *)strdup(p3);
                        }",69,,1467,2,,void
147121,BLOCK,-1,,<empty>,17,,1476,2,,void
147129,BLOCK,-1,,"{
                while (*p == '\n' || *p == '\r')
                    p++;

                while (p && *p) {
                    char *line = p;
                    char *eol = p = strchr(p, '\n');
                    char *colon;

                    while (eol && eol >= line && (*eol == '\n' || *eol == '\r'))
                        *eol-- = '\0';

                    if ((colon = strchr(line, ':'))) {
                        *colon++ = '\0';
                        while (*colon == ' ')
                            colon++;
                        httpd_MsgAdd(&cl->query, line, ""%s"", colon);

                        if (!strcasecmp(line, ""Content-Length""))
                            cl->query.i_body = atol(colon);
                    }

                    if (p) {
                        p++;
                        while (*p == '\n' || *p == '\r')
                            p++;
                    }
                }
            }",20,,1478,2,,void
147147,BLOCK,-1,,"{
                    char *line = p;
                    char *eol = p = strchr(p, '\n');
                    char *colon;

                    while (eol && eol >= line && (*eol == '\n' || *eol == '\r'))
                        *eol-- = '\0';

                    if ((colon = strchr(line, ':'))) {
                        *colon++ = '\0';
                        while (*colon == ' ')
                            colon++;
                        httpd_MsgAdd(&cl->query, line, ""%s"", colon);

                        if (!strcasecmp(line, ""Content-Length""))
                            cl->query.i_body = atol(colon);
                    }

                    if (p) {
                        p++;
                        while (*p == '\n' || *p == '\r')
                            p++;
                    }
                }",33,,1482,2,,void
147188,BLOCK,-1,,"{
                        *colon++ = '\0';
                        while (*colon == ' ')
                            colon++;
                        httpd_MsgAdd(&cl->query, line, ""%s"", colon);

                        if (!strcasecmp(line, ""Content-Length""))
                            cl->query.i_body = atol(colon);
                    }",54,,1490,2,,void
147214,BLOCK,-1,,<empty>,29,,1497,2,,void
147225,BLOCK,-1,,"{
                        p++;
                        while (*p == '\n' || *p == '\r')
                            p++;
                    }",28,,1500,2,,void
147248,BLOCK,-1,,"{
                /* TODO Mhh, handle the case where the client only
                 * sends a request and closes the connection to
                 * mark the end of the body (probably only RTSP) */
                if (cl->query.i_body < 65536)
                    cl->query.p_body = malloc(cl->query.i_body);
                else
                    cl->query.p_body = NULL;
                cl->i_buffer = 0;
                if (!cl->query.p_body) {
                    switch (cl->query.i_proto) {
                        case HTTPD_PROTO_HTTP: {
                            const uint8_t sorry[] = ""HTTP/1.1 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                            break;
                        }
                        case HTTPD_PROTO_RTSP: {
                            const uint8_t sorry[] = ""RTSP/1.0 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(s...",39,,1507,2,,void
147257,BLOCK,-1,,<empty>,21,,1512,2,,void
147271,BLOCK,-1,,<empty>,21,,1514,1,,void
147291,BLOCK,-1,,"{
                    switch (cl->query.i_proto) {
                        case HTTPD_PROTO_HTTP: {
                            const uint8_t sorry[] = ""HTTP/1.1 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                            break;
                        }
                        case HTTPD_PROTO_RTSP: {
                            const uint8_t sorry[] = ""RTSP/1.0 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                            break;
                        }
                        default:
                            vlc_assert_unreachable();
                    }
                    i_len = 0; /* drop */
                }",40,,1516,2,,void
147298,BLOCK,-1,,"{
                        case HTTPD_PROTO_HTTP: {
                            const uint8_t sorry[] = ""HTTP/1.1 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                            break;
                        }
                        case HTTPD_PROTO_RTSP: {
                            const uint8_t sorry[] = ""RTSP/1.0 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                            break;
                        }
                        default:
                            vlc_assert_unreachable();
                    }",48,,1517,2,,void
147301,BLOCK,3,,"{
                            const uint8_t sorry[] = ""HTTP/1.1 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                            break;
                        }",48,,1518,3,,void
147316,BLOCK,6,,"{
                            const uint8_t sorry[] = ""RTSP/1.0 413 Request Entity Too Large\r\n\r\n"";
                            httpd_NetSend(cl, sorry, sizeof(sorry) - 1);
                            break;
                        }",48,,1523,6,,void
147336,BLOCK,-1,,<empty>,17,,1535,1,,void
147346,BLOCK,-1,,"{
        if (cl->query.i_proto != HTTPD_PROTO_NONE && cl->query.i_type != HTTPD_MSG_NONE) {
            /* connection closed -> end of data */
            if (cl->query.i_body > 0)
                cl->query.i_body = cl->i_buffer;
            cl->i_state = HTTPD_CLIENT_RECEIVE_DONE;
        }
        else
            cl->i_state = HTTPD_CLIENT_DEAD; /* connection failed */
        return 0;
    }",21,,1539,2,,void
147363,BLOCK,-1,,"{
            /* connection closed -> end of data */
            if (cl->query.i_body > 0)
                cl->query.i_body = cl->i_buffer;
            cl->i_state = HTTPD_CLIENT_RECEIVE_DONE;
        }",90,,1540,2,,void
147372,BLOCK,-1,,<empty>,17,,1543,2,,void
147388,BLOCK,-1,,<empty>,13,,1547,1,,void
147400,BLOCK,-1,,"{
#if defined(_WIN32)
        if (WSAGetLastError() == WSAEWOULDBLOCK)
#else
        if (errno == EAGAIN)
#endif
            return -1;

        cl->i_state = HTTPD_CLIENT_DEAD; /* connection failed */
        return 0;
    }",20,,1552,2,,void
147405,BLOCK,-1,,<empty>,13,,1558,2,,void
147422,BLOCK,-1,,"{
    int i_len;

    if (cl->i_buffer < 0) {
        /* We need to create the header */
        int i_size = 0;
        char *p;
        const char *psz_status = httpd_ReasonFromCode(cl->answer.i_status);

        i_size = strlen(""HTTP/1."") + 10 + 10 + strlen(psz_status) + 5;
        for (size_t i = 0; i < cl->answer.i_headers; i++)
            i_size += strlen(cl->answer.p_headers[i].name) + 2 +
                      strlen(cl->answer.p_headers[i].value) + 2;

        if (cl->i_buffer_size < i_size) {
            cl->i_buffer_size = i_size;
            free(cl->p_buffer);
            cl->p_buffer = xmalloc(i_size);
        }
        p = (char *)cl->p_buffer;

        p += sprintf(p, ""%s.%u %d %s\r\n"",
                      cl->answer.i_proto ==  HTTPD_PROTO_HTTP ? ""HTTP/1"" : ""RTSP/1"",
                      cl->answer.i_version,
                      cl->answer.i_status, psz_status);
        for (size_t i = 0; i < cl->answer.i_headers; i++)
            p += sprintf(p, ""%s: %s\r\n"",...",1,,1568,2,,void
147430,BLOCK,-1,,"{
        /* We need to create the header */
        int i_size = 0;
        char *p;
        const char *psz_status = httpd_ReasonFromCode(cl->answer.i_status);

        i_size = strlen(""HTTP/1."") + 10 + 10 + strlen(psz_status) + 5;
        for (size_t i = 0; i < cl->answer.i_headers; i++)
            i_size += strlen(cl->answer.p_headers[i].name) + 2 +
                      strlen(cl->answer.p_headers[i].value) + 2;

        if (cl->i_buffer_size < i_size) {
            cl->i_buffer_size = i_size;
            free(cl->p_buffer);
            cl->p_buffer = xmalloc(i_size);
        }
        p = (char *)cl->p_buffer;

        p += sprintf(p, ""%s.%u %d %s\r\n"",
                      cl->answer.i_proto ==  HTTPD_PROTO_HTTP ? ""HTTP/1"" : ""RTSP/1"",
                      cl->answer.i_version,
                      cl->answer.i_status, psz_status);
        for (size_t i = 0; i < cl->answer.i_headers; i++)
            p += sprintf(p, ""%s: %s\r\n"", cl->answer.p_headers[i].name,
             ...",27,,1571,2,,void
147459,BLOCK,-1,,<empty>,9,,1578,1,,void
147506,BLOCK,-1,,"{
            cl->i_buffer_size = i_size;
            free(cl->p_buffer);
            cl->p_buffer = xmalloc(i_size);
        }",41,,1582,2,,void
147556,BLOCK,-1,,<empty>,9,,1593,1,,void
147637,BLOCK,-1,,"{
#if defined(_WIN32)
        if (WSAGetLastError() == WSAEWOULDBLOCK)
#else
        if (errno == EAGAIN)
#endif
            return -1;

        /* Connection failed, or hung up (EPIPE) */
        cl->i_state = HTTPD_CLIENT_DEAD;
        return 0;
    }",20,,1605,2,,void
147642,BLOCK,-1,,<empty>,13,,1611,2,,void
147666,BLOCK,-1,,"{
        if (cl->answer.i_body == 0  && cl->answer.i_body_offset > 0) {
            /* catch more body data */
            int     i_msg = cl->query.i_type;
            int64_t i_offset = cl->answer.i_body_offset;

            httpd_MsgClean(&cl->answer);
            cl->answer.i_body_offset = i_offset;

            cl->url->catch[i_msg].cb(cl->url->catch[i_msg].p_sys, cl,
                                     &cl->answer, &cl->query);
        }

        if (cl->answer.i_body > 0) {
            /* send the body data */
            free(cl->p_buffer);
            cl->p_buffer = cl->answer.p_body;
            cl->i_buffer_size = cl->answer.i_body;
            cl->i_buffer = 0;

            cl->answer.i_body = 0;
            cl->answer.p_body = NULL;
        } else /* send finished */
            cl->i_state = HTTPD_CLIENT_SEND_DONE;
    }",44,,1620,2,,void
147683,BLOCK,-1,,"{
            /* catch more body data */
            int     i_msg = cl->query.i_type;
            int64_t i_offset = cl->answer.i_body_offset;

            httpd_MsgClean(&cl->answer);
            cl->answer.i_body_offset = i_offset;

            cl->url->catch[i_msg].cb(cl->url->catch[i_msg].p_sys, cl,
                                     &cl->answer, &cl->query);
        }",70,,1621,2,,void
147748,BLOCK,-1,,"{
            /* send the body data */
            free(cl->p_buffer);
            cl->p_buffer = cl->answer.p_body;
            cl->i_buffer_size = cl->answer.i_body;
            cl->i_buffer = 0;

            cl->answer.i_body = 0;
            cl->answer.p_body = NULL;
        }",36,,1633,2,,void
147791,BLOCK,-1,,<empty>,13,,1643,1,,void
147804,BLOCK,-1,,"{
    switch (vlc_tls_SessionHandshake(host->p_tls, cl->sock))
    {
        case -1: cl->i_state = HTTPD_CLIENT_DEAD;       break;
        case 0:  cl->i_state = HTTPD_CLIENT_RECEIVING;  break;
        case 1:  cl->i_state = HTTPD_CLIENT_TLS_HS_IN;  break;
        case 2:  cl->i_state = HTTPD_CLIENT_TLS_HS_OUT; break;
    }
}",1,,1649,3,,void
147813,BLOCK,-1,,"{
        case -1: cl->i_state = HTTPD_CLIENT_DEAD;       break;
        case 0:  cl->i_state = HTTPD_CLIENT_RECEIVING;  break;
        case 1:  cl->i_state = HTTPD_CLIENT_TLS_HS_IN;  break;
        case 2:  cl->i_state = HTTPD_CLIENT_TLS_HS_OUT; break;
    }",5,,1651,2,,void
147853,BLOCK,-1,,"{
    if (!*user && !*pass)
        return true;

    if (!b64)
        return false;

    if (strncasecmp(b64, ""BASIC"", 5))
        return false;

    b64 += 5;
    while (*b64 == ' ')
        b64++;

    char *given_user = vlc_b64_decode(b64);
    if (!given_user)
        return false;

    char *given_pass = NULL;
    given_pass = strchr (given_user, ':');
    if (!given_pass)
        goto auth_failed;

    *given_pass++ = '\0';

    if (strcmp (given_user, user))
        goto auth_failed;

    if (strcmp (given_pass, pass))
        goto auth_failed;

    free(given_user);
    return true;

auth_failed:
    free(given_user);
    return false;
}",1,,1660,4,,void
147862,BLOCK,-1,,<empty>,9,,1662,2,,void
147868,BLOCK,-1,,<empty>,9,,1665,2,,void
147876,BLOCK,-1,,<empty>,9,,1668,2,,void
147897,BLOCK,-1,,<empty>,9,,1676,2,,void
147912,BLOCK,-1,,<empty>,9,,1681,2,,void
147923,BLOCK,-1,,<empty>,9,,1686,2,,void
147929,BLOCK,-1,,<empty>,9,,1689,2,,void
147944,BLOCK,-1,,"{
    struct pollfd ufd[host->nfd + host->i_client];
    unsigned nfd;
    for (nfd = 0; nfd < host->nfd; nfd++) {
        ufd[nfd].fd = host->fds[nfd];
        ufd[nfd].events = POLLIN;
        ufd[nfd].revents = 0;
    }

    /* add all socket that should be read/write and close dead connection */
    while (host->i_url <= 0) {
        mutex_cleanup_push(&host->lock);
        vlc_cond_wait(&host->wait, &host->lock);
        vlc_cleanup_pop();
    }

    mtime_t now = mdate();
    int delay = -1;
    int canc = vlc_savecancel();
    for (int i_client = 0; i_client < host->i_client; i_client++) {
        httpd_client_t *cl = host->client[i_client];
        int val = -1;

        switch (cl->i_state) {
            case HTTPD_CLIENT_RECEIVING:
                val = httpd_ClientRecv(cl);
                break;
            case HTTPD_CLIENT_SENDING:
                val = httpd_ClientSend(cl);
                break;
            case HTTPD_CLIENT_TLS_HS_IN:
            case HTTPD_CLIENT_T...",1,,1700,2,,void
147948,BLOCK,-1,,<empty>,5,,1703,1,,void
147959,BLOCK,4,,"{
        ufd[nfd].fd = host->fds[nfd];
        ufd[nfd].events = POLLIN;
        ufd[nfd].revents = 0;
    }",43,,1703,4,,void
147991,BLOCK,-1,,"{
        mutex_cleanup_push(&host->lock);
        vlc_cond_wait(&host->wait, &host->lock);
        vlc_cleanup_pop();
    }",30,,1710,2,,void
148021,BLOCK,-1,,<empty>,5,,1719,1,,void
148033,BLOCK,4,,"{
        httpd_client_t *cl = host->client[i_client];
        int val = -1;

        switch (cl->i_state) {
            case HTTPD_CLIENT_RECEIVING:
                val = httpd_ClientRecv(cl);
                break;
            case HTTPD_CLIENT_SENDING:
                val = httpd_ClientSend(cl);
                break;
            case HTTPD_CLIENT_TLS_HS_IN:
            case HTTPD_CLIENT_TLS_HS_OUT:
                httpd_ClientTlsHandshake(host, cl);
                break;
        }

        if (cl->i_ref < 0 || (cl->i_ref == 0 &&
                    (cl->i_state == HTTPD_CLIENT_DEAD ||
                      (host->timeout_sec > 0 &&
                        cl->i_timeout_date < now)))) {
            TAB_REMOVE(host->i_client, host->client, cl);
            i_client--;
            httpd_ClientDestroy(cl);
            continue;
        }

        if (val == 0) {
            cl->i_timeout_date = now + (host->timeout_sec * 1000 * 1000);
            delay = 0;
        }

        struc...",67,,1719,4,,void
148051,BLOCK,-1,,"{
            case HTTPD_CLIENT_RECEIVING:
                val = httpd_ClientRecv(cl);
                break;
            case HTTPD_CLIENT_SENDING:
                val = httpd_ClientSend(cl);
                break;
            case HTTPD_CLIENT_TLS_HS_IN:
            case HTTPD_CLIENT_TLS_HS_OUT:
                httpd_ClientTlsHandshake(host, cl);
                break;
        }",30,,1723,2,,void
148104,BLOCK,-1,,"{
            TAB_REMOVE(host->i_client, host->client, cl);
            i_client--;
            httpd_ClientDestroy(cl);
            continue;
        }",54,,1739,2,,void
148122,BLOCK,-1,,"{
            cl->i_timeout_date = now + (host->timeout_sec * 1000 * 1000);
            delay = 0;
        }",23,,1746,2,,void
148178,BLOCK,-1,,"{
            case HTTPD_CLIENT_RECEIVING:
            case HTTPD_CLIENT_TLS_HS_IN:
                pufd->events = POLLIN;
                break;

            case HTTPD_CLIENT_SENDING:
            case HTTPD_CLIENT_TLS_HS_OUT:
                pufd->events = POLLOUT;
                break;

            case HTTPD_CLIENT_RECEIVE_DONE: {
                httpd_message_t *answer = &cl->answer;
                httpd_message_t *query  = &cl->query;

                httpd_MsgInit(answer);

                /* Handle what we received */
                switch (query->i_type) {
                    case HTTPD_MSG_ANSWER:
                        cl->url     = NULL;
                        cl->i_state = HTTPD_CLIENT_DEAD;
                        break;

                    case HTTPD_MSG_OPTIONS:
                        answer->i_type   = HTTPD_MSG_ANSWER;
                        answer->i_proto  = query->i_proto;
                        answer->i_status = 200;
                        answer->i_...",30,,1757,2,,void
148201,BLOCK,15,,"{
                httpd_message_t *answer = &cl->answer;
                httpd_message_t *query  = &cl->query;

                httpd_MsgInit(answer);

                /* Handle what we received */
                switch (query->i_type) {
                    case HTTPD_MSG_ANSWER:
                        cl->url     = NULL;
                        cl->i_state = HTTPD_CLIENT_DEAD;
                        break;

                    case HTTPD_MSG_OPTIONS:
                        answer->i_type   = HTTPD_MSG_ANSWER;
                        answer->i_proto  = query->i_proto;
                        answer->i_status = 200;
                        answer->i_body = 0;
                        answer->p_body = NULL;

                        httpd_MsgAdd(answer, ""Server"", ""VLC/%s"", VERSION);
                        httpd_MsgAdd(answer, ""Content-Length"", ""0"");

                        switch(query->i_proto) {
                        case HTTPD_PROTO_HTTP:
                            answer->i...",45,,1768,15,,void
148222,BLOCK,-1,,"{
                    case HTTPD_MSG_ANSWER:
                        cl->url     = NULL;
                        cl->i_state = HTTPD_CLIENT_DEAD;
                        break;

                    case HTTPD_MSG_OPTIONS:
                        answer->i_type   = HTTPD_MSG_ANSWER;
                        answer->i_proto  = query->i_proto;
                        answer->i_status = 200;
                        answer->i_body = 0;
                        answer->p_body = NULL;

                        httpd_MsgAdd(answer, ""Server"", ""VLC/%s"", VERSION);
                        httpd_MsgAdd(answer, ""Content-Length"", ""0"");

                        switch(query->i_proto) {
                        case HTTPD_PROTO_HTTP:
                            answer->i_version = 1;
                            httpd_MsgAdd(answer, ""Allow"", ""GET,HEAD,POST,OPTIONS"");
                            break;

                        case HTTPD_PROTO_RTSP:
                            answer->i_version = 0;

    ...",40,,1775,2,,void
148278,BLOCK,-1,,"{
                        case HTTPD_PROTO_HTTP:
                            answer->i_version = 1;
                            httpd_MsgAdd(answer, ""Allow"", ""GET,HEAD,POST,OPTIONS"");
                            break;

                        case HTTPD_PROTO_RTSP:
                            answer->i_version = 0;

                            const char *p = httpd_MsgGet(query, ""Cseq"");
                            if (p)
                                httpd_MsgAdd(answer, ""Cseq"", ""%s"", p);
                            p = httpd_MsgGet(query, ""Timestamp"");
                            if (p)
                                httpd_MsgAdd(answer, ""Timestamp"", ""%s"", p);

                            p = httpd_MsgGet(query, ""Require"");
                            if (p) {
                                answer->i_status = 551;
                                httpd_MsgAdd(query, ""Unsupported"", ""%s"", p);
                            }

                            httpd_MsgAdd(answer, ""Public...",48,,1791,2,,void
148306,BLOCK,-1,,<empty>,33,,1802,2,,void
148319,BLOCK,-1,,<empty>,33,,1805,2,,void
148332,BLOCK,-1,,"{
                                answer->i_status = 551;
                                httpd_MsgAdd(query, ""Unsupported"", ""%s"", p);
                            }",36,,1808,2,,void
148357,BLOCK,-1,,<empty>,29,,1819,2,,void
148382,BLOCK,-1,,"{
                            cl->url = NULL;
                            cl->i_state = HTTPD_CLIENT_DEAD;
                        }",65,,1827,2,,void
148394,BLOCK,-1,,"{
                            /* unimplemented */
                            answer->i_proto  = query->i_proto ;
                            answer->i_type   = HTTPD_MSG_ANSWER;
                            answer->i_version= 0;
                            answer->i_status = 501;

                            char *p;
                            answer->i_body = httpd_HtmlError (&p, 501, NULL);
                            answer->p_body = (uint8_t *)p;
                            httpd_MsgAdd(answer, ""Content-Length"", ""%d"", answer->i_body);
                            httpd_MsgAdd(answer, ""Connection"", ""close"");

                            cl->i_buffer = -1;  /* Force the creation of the answer in httpd_ClientSend */
                            cl->i_state = HTTPD_CLIENT_SENDING;
                        }",32,,1830,1,,void
148458,BLOCK,25,,"{
                        int i_msg = query->i_type;
                        bool b_auth_failed = false;

                        /* Search the url and trigger callbacks */
                        for (int i = 0; i < host->i_url; i++) {
                            httpd_url_t *url = host->url[i];

                            if (strcmp(url->psz_url, query->psz_url))
                                continue;
                            if (!url->catch[i_msg].cb)
                                continue;

                            if (answer) {
                                b_auth_failed = !httpdAuthOk(url->psz_user,
                                   url->psz_password,
                                   httpd_MsgGet(query, ""Authorization"")); /* BASIC id */
                                if (b_auth_failed)
                                   break;
                            }

                            if (url->catch[i_msg].cb(url->catch[i_msg].p_sys, cl, answer, query))
     ...",30,,1848,25,,void
148470,BLOCK,-1,,<empty>,25,,1853,1,,void
148482,BLOCK,4,,"{
                            httpd_url_t *url = host->url[i];

                            if (strcmp(url->psz_url, query->psz_url))
                                continue;
                            if (!url->catch[i_msg].cb)
                                continue;

                            if (answer) {
                                b_auth_failed = !httpdAuthOk(url->psz_user,
                                   url->psz_password,
                                   httpd_MsgGet(query, ""Authorization"")); /* BASIC id */
                                if (b_auth_failed)
                                   break;
                            }

                            if (url->catch[i_msg].cb(url->catch[i_msg].p_sys, cl, answer, query))
                                continue;

                            if (answer->i_proto == HTTPD_PROTO_NONE)
                                cl->i_buffer = cl->i_buffer_size; /* Raw answer from a CGI */
                            else
 ...",63,,1853,4,,void
148499,BLOCK,-1,,<empty>,33,,1857,2,,void
148510,BLOCK,-1,,<empty>,33,,1859,2,,void
148514,BLOCK,-1,,"{
                                b_auth_failed = !httpdAuthOk(url->psz_user,
                                   url->psz_password,
                                   httpd_MsgGet(query, ""Authorization"")); /* BASIC id */
                                if (b_auth_failed)
                                   break;
                            }",41,,1861,2,,void
148530,BLOCK,-1,,<empty>,36,,1866,2,,void
148551,BLOCK,-1,,<empty>,33,,1870,2,,void
148559,BLOCK,-1,,<empty>,33,,1873,2,,void
148568,BLOCK,-1,,<empty>,33,,1875,1,,void
148583,BLOCK,-1,,<empty>,33,,1880,2,,void
148591,BLOCK,-1,,"{
                            answer->i_proto  = query->i_proto;
                            answer->i_type   = HTTPD_MSG_ANSWER;
                            answer->i_version= 0;

                           if (b_auth_failed) {
                                httpd_MsgAdd(answer, ""WWW-Authenticate"",
                                        ""Basic realm=\""VLC stream\"""");
                                answer->i_status = 401;
                            } else
                                answer->i_status = 404; /* no url registered */

                            char *p;
                            answer->i_body = httpd_HtmlError (&p, answer->i_status,
                                    query->psz_url);
                            answer->p_body = (uint8_t *)p;

                            cl->i_buffer = -1;  /* Force the creation of the answer in httpd_ClientSend */
                            httpd_MsgAdd(answer, ""Content-Length"", ""%d"", answer->i_body);
                     ...",37,,1883,2,,void
148611,BLOCK,-1,,"{
                                httpd_MsgAdd(answer, ""WWW-Authenticate"",
                                        ""Basic realm=\""VLC stream\"""");
                                answer->i_status = 401;
                            }",47,,1888,2,,void
148622,BLOCK,-1,,<empty>,33,,1893,1,,void
148676,BLOCK,-1,,<empty>,33,,1904,2,,void
148702,BLOCK,-1,,"{
                    bool do_close = false;

                    cl->url = NULL;

                    if (cl->query.i_proto != HTTPD_PROTO_HTTP
                     || cl->query.i_version > 0)
                    {
                        const char *psz_connection = httpd_MsgGet(&cl->answer,
                                                                 ""Connection"");
                        if (psz_connection != NULL)
                            do_close = !strcasecmp(psz_connection, ""close"");
                    }
                    else
                        do_close = true;

                    if (!do_close) {
                        httpd_MsgClean(&cl->query);
                        httpd_MsgInit(&cl->query);

                        cl->i_buffer = 0;
                        cl->i_buffer_size = 1000;
                        free(cl->p_buffer);
                        // Allocate an extra byte for the null terminating byte
                        cl->p_buffer = xmalloc(...",74,,1914,2,,void
148728,BLOCK,-1,,"{
                        const char *psz_connection = httpd_MsgGet(&cl->answer,
                                                                 ""Connection"");
                        if (psz_connection != NULL)
                            do_close = !strcasecmp(psz_connection, ""close"");
                    }",21,,1921,2,,void
148742,BLOCK,-1,,<empty>,29,,1925,2,,void
148750,BLOCK,-1,,<empty>,25,,1928,1,,void
148757,BLOCK,-1,,"{
                        httpd_MsgClean(&cl->query);
                        httpd_MsgInit(&cl->query);

                        cl->i_buffer = 0;
                        cl->i_buffer_size = 1000;
                        free(cl->p_buffer);
                        // Allocate an extra byte for the null terminating byte
                        cl->p_buffer = xmalloc(cl->i_buffer_size + 1);
                        cl->i_state = HTTPD_CLIENT_RECEIVING;
                    }",36,,1930,2,,void
148798,BLOCK,-1,,<empty>,25,,1941,1,,void
148810,BLOCK,-1,,"{
                    int64_t i_offset = cl->answer.i_body_offset;
                    httpd_MsgClean(&cl->answer);

                    cl->answer.i_body_offset = i_offset;
                    free(cl->p_buffer);
                    cl->p_buffer = NULL;
                    cl->i_buffer = 0;
                    cl->i_buffer_size = 0;

                    cl->i_state = HTTPD_CLIENT_WAITING;
                }",24,,1943,1,,void
148858,BLOCK,22,,"{
                int64_t i_offset = cl->answer.i_body_offset;
                int i_msg = cl->query.i_type;

                httpd_MsgInit(&cl->answer);
                cl->answer.i_body_offset = i_offset;

                cl->url->catch[i_msg].cb(cl->url->catch[i_msg].p_sys, cl,
                        &cl->answer, &cl->query);
                if (cl->answer.i_type != HTTPD_MSG_NONE) {
                    /* we have new data, so re-enter send mode */
                    cl->i_buffer      = 0;
                    cl->p_buffer      = cl->answer.p_body;
                    cl->i_buffer_size = cl->answer.i_body;
                    cl->answer.p_body = NULL;
                    cl->answer.i_body = 0;
                    cl->i_state = HTTPD_CLIENT_SENDING;
                }
            }",40,,1957,22,,void
148923,BLOCK,-1,,"{
                    /* we have new data, so re-enter send mode */
                    cl->i_buffer      = 0;
                    cl->p_buffer      = cl->answer.p_body;
                    cl->i_buffer_size = cl->answer.i_body;
                    cl->answer.p_body = NULL;
                    cl->answer.i_body = 0;
                    cl->i_state = HTTPD_CLIENT_SENDING;
                }",58,,1966,2,,void
148972,BLOCK,-1,,<empty>,13,,1979,2,,void
148976,BLOCK,-1,,<empty>,14,,1981,1,,void
148981,BLOCK,-1,,<empty>,13,,1982,2,,void
148999,BLOCK,-1,,"{
        if (errno != EINTR)
            msg_Err(host, ""polling error: %s"", vlc_strerror_c(errno));
    }",5,,1988,2,,void
149004,BLOCK,-1,,<empty>,13,,1990,2,,void
149022,BLOCK,-1,,<empty>,5,,1999,1,,void
149033,BLOCK,4,,"{
        httpd_client_t *cl;
        int fd = ufd[nfd].fd;

        assert (fd == host->fds[nfd]);

        if (ufd[nfd].revents == 0)
            continue;

        /* */
        fd = vlc_accept (fd, NULL, NULL, true);
        if (fd == -1)
            continue;
        setsockopt (fd, SOL_SOCKET, SO_REUSEADDR,
                &(int){ 1 }, sizeof(int));

        vlc_tls_t *sk = vlc_tls_SocketOpen(fd);
        if (unlikely(sk == NULL))
        {
            vlc_close(fd);
            continue;
        }

        if (host->p_tls != NULL)
        {
            const char *alpn[] = { ""http/1.1"", NULL };
            vlc_tls_t *tls;

            tls = vlc_tls_ServerSessionCreate(host->p_tls, sk, alpn);
            if (tls == NULL)
            {
                vlc_tls_SessionDelete(sk);
                continue;
            }
            sk = tls;
        }

        cl = httpd_ClientNew(sk);
        if (host->b_no_timeout)
            host->timeout_sec = 0;

        if (host->p_tls != N...",43,,1999,4,,void
149059,BLOCK,-1,,<empty>,13,,2006,2,,void
149073,BLOCK,-1,,<empty>,13,,2011,2,,void
149096,BLOCK,-1,,"{
            vlc_close(fd);
            continue;
        }",9,,2017,2,,void
149106,BLOCK,-1,,"{
            const char *alpn[] = { ""http/1.1"", NULL };
            vlc_tls_t *tls;

            tls = vlc_tls_ServerSessionCreate(host->p_tls, sk, alpn);
            if (tls == NULL)
            {
                vlc_tls_SessionDelete(sk);
                continue;
            }
            sk = tls;
        }",9,,2023,2,,void
149126,BLOCK,-1,,"{
                vlc_tls_SessionDelete(sk);
                continue;
            }",13,,2029,2,,void
149141,BLOCK,-1,,<empty>,13,,2038,2,,void
149153,BLOCK,-1,,<empty>,13,,2041,2,,void
149186,BLOCK,-1,,"{
    httpd_host_t *host = data;

    vlc_mutex_lock(&host->lock);
    while (host->i_ref > 0)
        httpdLoop(host);
    vlc_mutex_unlock(&host->lock);
    return NULL;
}",1,,2051,2,,void
149217,BLOCK,-1,,"{
    if (!p_stream)
        return VLC_EGENERIC;

    vlc_mutex_lock(&p_stream->lock);
    if (p_stream->p_http_headers) {
        for (size_t i = 0; i < p_stream->i_http_headers; i++) {
            free(p_stream->p_http_headers[i].name);
            free(p_stream->p_http_headers[i].value);
        }
        free(p_stream->p_http_headers);
        p_stream->p_http_headers = NULL;
        p_stream->i_http_headers = 0;
    }

    if (!p_headers || !i_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_SUCCESS;
    }

    p_stream->p_http_headers = vlc_alloc(i_headers, sizeof(httpd_header));
    if (!p_stream->p_http_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_ENOMEM;
    }

    size_t j = 0;
    for (size_t i = 0; i < i_headers; i++) {
        if (unlikely(!p_headers[i].name || !p_headers[i].value))
            continue;

        p_stream->p_http_headers[j].name = strdup(p_headers[i].name);
        p_stream->p_http_headers[j].value = ...",1,,2063,4,,void
149221,BLOCK,-1,,<empty>,9,,2065,2,,void
149233,BLOCK,-1,,"{
        for (size_t i = 0; i < p_stream->i_http_headers; i++) {
            free(p_stream->p_http_headers[i].name);
            free(p_stream->p_http_headers[i].value);
        }
        free(p_stream->p_http_headers);
        p_stream->p_http_headers = NULL;
        p_stream->i_http_headers = 0;
    }",35,,2068,2,,void
149235,BLOCK,-1,,<empty>,9,,2069,1,,void
149247,BLOCK,4,,"{
            free(p_stream->p_http_headers[i].name);
            free(p_stream->p_http_headers[i].value);
        }",63,,2069,4,,void
149284,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_SUCCESS;
    }",35,,2078,2,,void
149305,BLOCK,-1,,"{
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_ENOMEM;
    }",36,,2084,2,,void
149318,BLOCK,-1,,<empty>,5,,2090,1,,void
149328,BLOCK,4,,"{
        if (unlikely(!p_headers[i].name || !p_headers[i].value))
            continue;

        p_stream->p_http_headers[j].name = strdup(p_headers[i].name);
        p_stream->p_http_headers[j].value = strdup(p_headers[i].value);

        if (unlikely(!p_stream->p_http_headers[j].name ||
                      !p_stream->p_http_headers[j].value)) {
            free(p_stream->p_http_headers[j].name);
            free(p_stream->p_http_headers[j].value);
            break;
        }
        j++;
    }",44,,2090,4,,void
149344,BLOCK,-1,,<empty>,13,,2092,2,,void
149393,BLOCK,-1,,"{
            free(p_stream->p_http_headers[j].name);
            free(p_stream->p_http_headers[j].value);
            break;
        }",60,,2098,2,,void
149453,BLOCK,-1,,<empty>,1,,1,1,,ANY
149460,BLOCK,-1,,<empty>,,,,6,,<empty>
149468,BLOCK,-1,,"{
    int fd = vlc_socket (family, socktype, protocol, true);
    if (fd == -1)
    {
        if (net_errno != EAFNOSUPPORT)
            msg_Err (p_this, ""cannot create socket: %s"",
                     vlc_strerror_c(net_errno));
        return -1;
    }

    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

#ifdef IPV6_V6ONLY
    /*
     * Accepts only IPv6 connections on IPv6 sockets.
     * If possible, we should open two sockets, but it is not always possible.
     */
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_V6ONLY, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)
# ifndef IPV6_PROTECTION_LEVEL
#  warning Please update your C library headers.
#  define IPV6_PROTECTION_LEVEL 23
#  define PROTECTION_LEVEL_UNRESTRICTED 10
# endif
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_PROTECTION_LEVEL,
                    &(int){ PROTECTION_LEVEL_UNRESTRICTED }, sizeof (int));
#endif

#ifdef DCCP_SOCKOPT_SER...",1,,57,5,,void
149482,BLOCK,-1,,"{
        if (net_errno != EAFNOSUPPORT)
            msg_Err (p_this, ""cannot create socket: %s"",
                     vlc_strerror_c(net_errno));
        return -1;
    }",5,,60,2,,void
149487,BLOCK,-1,,<empty>,13,,62,2,,void
149517,BLOCK,-1,,"{
    struct addrinfo hints = {
        .ai_socktype = type,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    msg_Dbg (p_this, ""net: listening to %s port %d"",
             (psz_host != NULL) ? psz_host : ""*"", i_port);

    int i_val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (i_val)
    {
        msg_Err (p_this, ""Cannot resolve %s port %d : %s"",
                 (psz_host != NULL) ? psz_host : """", i_port,
                 gai_strerror (i_val));
        return NULL;
    }

    int *sockv = NULL;
    unsigned sockc = 0;

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (p_this, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }

        /* Bind the socket */
#if defined (_WIN32)
       ...",1,,108,6,,void
149523,BLOCK,1,,<empty>,9,,110,1,,void
149527,BLOCK,2,,<empty>,9,,111,2,,void
149531,BLOCK,3,,<empty>,9,,112,3,,void
149561,BLOCK,-1,,"{
        msg_Err (p_this, ""Cannot resolve %s port %d : %s"",
                 (psz_host != NULL) ? psz_host : """", i_port,
                 gai_strerror (i_val));
        return NULL;
    }",5,,120,2,,void
149585,BLOCK,-1,,<empty>,5,,130,1,,void
149598,BLOCK,4,,"{
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (p_this, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }

        /* Bind the socket */
#if defined (_WIN32)
        /*
         * Under Win32 and for multicasting, we bind to INADDR_ANY.
         * This is of course a severe bug, since the socket would logically
         * receive unicast traffic, and multicast traffic of groups subscribed
         * to via other sockets.
         */
        if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
         && (sizeof (struct sockaddr_storage) >= ptr->ai_addrlen))
        {
            // This works for IPv4 too - don't worry!
            struct sockaddr_in6 dumb =
            {
                .sin6_family = ptr->ai_addr->sa_family,
                .sin6_port =  ((struct sockaddr_in *)(ptr->ai_addr))->sin_port
            };

 ...",5,,131,4,,void
149618,BLOCK,-1,,"{
            msg_Dbg (p_this, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }",9,,135,2,,void
149634,BLOCK,-1,,"{
            int err = net_errno;
            net_Close (fd);
#if !defined(_WIN32)
            fd = rootwrap_bind (ptr->ai_family, ptr->ai_socktype,
                                ptr->ai_protocol,
                                ptr->ai_addr, ptr->ai_addrlen);
            if (fd != -1)
            {
                msg_Dbg (p_this, ""got socket %d from rootwrap"", fd);
            }
            else
#endif
            {
                msg_Err (p_this, ""socket bind error: %s"", vlc_strerror_c(err));
                continue;
            }
        }",9,,163,2,,void
149664,BLOCK,-1,,"{
                msg_Dbg (p_this, ""got socket %d from rootwrap"", fd);
            }",13,,171,2,,void
149670,BLOCK,-1,,"{
                msg_Err (p_this, ""socket bind error: %s"", vlc_strerror_c(err));
                continue;
            }",13,,176,1,,void
149685,BLOCK,-1,,"{
            if (net_Subscribe (p_this, fd, ptr->ai_addr, ptr->ai_addrlen))
            {
                net_Close (fd);
                continue;
            }
        }",9,,183,2,,void
149696,BLOCK,-1,,"{
                net_Close (fd);
                continue;
            }",13,,185,2,,void
149704,BLOCK,-1,,"{
            case SOCK_STREAM:
            case SOCK_RDM:
            case SOCK_SEQPACKET:
#ifdef SOCK_DCCP
            case SOCK_DCCP:
#endif
                if (listen (fd, INT_MAX))
                {
                    msg_Err (p_this, ""socket listen error: %s"",
                             vlc_strerror_c(net_errno));
                    net_Close (fd);
                    continue;
                }
        }",9,,193,2,,void
149715,BLOCK,-1,,"{
                    msg_Err (p_this, ""socket listen error: %s"",
                             vlc_strerror_c(net_errno));
                    net_Close (fd);
                    continue;
                }",17,,201,2,,void
149741,BLOCK,-1,,"{
            nsockv[sockc++] = fd;
            sockv = nsockv;
        }",9,,211,2,,void
149752,BLOCK,-1,,<empty>,13,,216,1,,void
149761,BLOCK,-1,,<empty>,9,,222,2,,void
149777,BLOCK,-1,,"{
    size_t rd = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_recv_i11e(fd, buf, len, 0);
        if (val < 0)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;
#ifdef _WIN32
            else if (WSAGetLastError() == WSAEMSGSIZE) /* datagram too big */
            {
                msg_Warn(obj, ""read truncated to %zu bytes"", len);
                val = len;
            }
#endif
            else
            {
                msg_Err(obj, ""read error: %s"", vlc_strerror_c(errno));
                return rd ? (ssize_t)rd : -1;
            }
        }

        rd += val;

        if (val == 0)
            break;

        assert(len >= (size_t)val);
        len -= val;
        buf = ((char *)buf) + val;
    }
    while (len > 0);

    return rd;
}",1,,235,5,,void
149783,BLOCK,-1,,"{
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_recv_i11e(fd, buf, len, 0);
        if (val < 0)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;
#ifdef _WIN32
            else if (WSAGetLastError() == WSAEMSGSIZE) /* datagram too big */
            {
                msg_Warn(obj, ""read truncated to %zu bytes"", len);
                val = len;
            }
#endif
            else
            {
                msg_Err(obj, ""read error: %s"", vlc_strerror_c(errno));
                return rd ? (ssize_t)rd : -1;
            }
        }

        rd += val;

        if (val == 0)
            break;

        assert(len >= (size_t)val);
        len -= val;
        buf = ((char *)buf) + val;
    }",5,,239,1,,void
149786,BLOCK,-1,,"{
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }",9,,241,2,,void
149806,BLOCK,-1,,"{
            if (errno == EINTR || errno == EAGAIN)
                continue;
#ifdef _WIN32
            else if (WSAGetLastError() == WSAEMSGSIZE) /* datagram too big */
            {
                msg_Warn(obj, ""read truncated to %zu bytes"", len);
                val = len;
            }
#endif
            else
            {
                msg_Err(obj, ""read error: %s"", vlc_strerror_c(errno));
                return rd ? (ssize_t)rd : -1;
            }
        }",9,,249,2,,void
149815,BLOCK,-1,,<empty>,17,,251,2,,void
149818,BLOCK,-1,,"{
                msg_Err(obj, ""read error: %s"", vlc_strerror_c(errno));
                return rd ? (ssize_t)rd : -1;
            }",13,,260,1,,void
149839,BLOCK,-1,,<empty>,13,,269,2,,void
149869,BLOCK,-1,,"{
    size_t written = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_send_i11e (fd, buf, len, MSG_NOSIGNAL);
        if (val == -1)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;

            msg_Err(obj, ""write error: %s"", vlc_strerror_c(errno));
            return written ? (ssize_t)written : -1;
        }

        if (val == 0)
            break;

        written += val;
        assert(len >= (size_t)val);
        len -= val;
        buf = ((const char *)buf) + val;
    }
    while (len > 0);

    return written;
}",1,,290,5,,void
149875,BLOCK,-1,,"{
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_send_i11e (fd, buf, len, MSG_NOSIGNAL);
        if (val == -1)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;

            msg_Err(obj, ""write error: %s"", vlc_strerror_c(errno));
            return written ? (ssize_t)written : -1;
        }

        if (val == 0)
            break;

        written += val;
        assert(len >= (size_t)val);
        len -= val;
        buf = ((const char *)buf) + val;
    }",5,,294,1,,void
149878,BLOCK,-1,,"{
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }",9,,296,2,,void
149899,BLOCK,-1,,"{
            if (errno == EINTR || errno == EAGAIN)
                continue;

            msg_Err(obj, ""write error: %s"", vlc_strerror_c(errno));
            return written ? (ssize_t)written : -1;
        }",9,,304,2,,void
149908,BLOCK,-1,,<empty>,17,,306,2,,void
149927,BLOCK,-1,,<empty>,13,,313,2,,void
149958,BLOCK,-1,,"{
    char *buf = NULL;
    size_t size = 0, len = 0;

    for (;;)
    {
        if (len == size)
        {
            if (unlikely(size >= (1 << 16)))
            {
                errno = EMSGSIZE;
                goto error; /* put sane buffer size limit */
            }

            char *newbuf = realloc(buf, size + 1024);
            if (unlikely(newbuf == NULL))
                goto error;
            buf = newbuf;
            size += 1024;
        }
        assert(len < size);

        ssize_t val = vlc_recv_i11e(fd, buf + len, size - len, MSG_PEEK);
        if (val <= 0)
            goto error;

        char *end = memchr(buf + len, '\n', val);
        if (end != NULL)
            val = (end + 1) - (buf + len);
        if (recv(fd, buf + len, val, 0) != val)
            goto error;
        len += val;
        if (end != NULL)
            break;
    }

    assert(len > 0);
    buf[--len] = '\0';
    if (len > 0 && buf[--len] == '\r')
        buf[len] = '\0';
    return buf...",1,,337,3,,void
149972,BLOCK,-1,,<empty>,5,,341,1,,void
149973,BLOCK,4,,"{
        if (len == size)
        {
            if (unlikely(size >= (1 << 16)))
            {
                errno = EMSGSIZE;
                goto error; /* put sane buffer size limit */
            }

            char *newbuf = realloc(buf, size + 1024);
            if (unlikely(newbuf == NULL))
                goto error;
            buf = newbuf;
            size += 1024;
        }
        assert(len < size);

        ssize_t val = vlc_recv_i11e(fd, buf + len, size - len, MSG_PEEK);
        if (val <= 0)
            goto error;

        char *end = memchr(buf + len, '\n', val);
        if (end != NULL)
            val = (end + 1) - (buf + len);
        if (recv(fd, buf + len, val, 0) != val)
            goto error;
        len += val;
        if (end != NULL)
            break;
    }",5,,342,4,,void
149978,BLOCK,-1,,"{
            if (unlikely(size >= (1 << 16)))
            {
                errno = EMSGSIZE;
                goto error; /* put sane buffer size limit */
            }

            char *newbuf = realloc(buf, size + 1024);
            if (unlikely(newbuf == NULL))
                goto error;
            buf = newbuf;
            size += 1024;
        }",9,,344,2,,void
149986,BLOCK,-1,,"{
                errno = EMSGSIZE;
                goto error; /* put sane buffer size limit */
            }",13,,346,2,,void
150004,BLOCK,-1,,<empty>,17,,353,2,,void
150032,BLOCK,-1,,<empty>,13,,361,2,,void
150047,BLOCK,-1,,<empty>,13,,365,2,,void
150067,BLOCK,-1,,<empty>,13,,367,2,,void
150076,BLOCK,-1,,<empty>,13,,370,2,,void
150099,BLOCK,-1,,<empty>,9,,376,2,,void
150123,BLOCK,-1,,"{
    int i_ret;
    va_list args;
    va_start( args, psz_fmt );
    i_ret = net_vaPrintf( p_this, fd, psz_fmt, args );
    va_end( args );

    return i_ret;
}",1,,386,4,,void
150147,BLOCK,-1,,"{
    char    *psz;
    int      i_ret;

    int i_size = vasprintf( &psz, psz_fmt, args );
    if( i_size == -1 )
        return -1;
    i_ret = net_Write( p_this, fd, psz, i_size ) < i_size
        ? -1 : i_size;
    free( psz );

    return i_ret;
}",1,,399,5,,void
150163,BLOCK,-1,,<empty>,9,,405,2,,void
150214,BLOCK,-1,,<empty>,1,,1,1,,ANY
150222,BLOCK,-1,,<empty>,,,,6,,<empty>
150227,BLOCK,-1,,"{
    struct msghdr hdr;
    struct iovec iov;
    struct cmsghdr *cmsg;
    int val, fd;
    char buf[CMSG_SPACE (sizeof (fd))];

    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = buf;
    hdr.msg_controllen = sizeof (buf);

    iov.iov_base = &val;
    iov.iov_len = sizeof (val);

    if (recvmsg (p, &hdr, 0) != sizeof (val))
        return -1;

    for (cmsg = CMSG_FIRSTHDR (&hdr); cmsg != NULL;
         cmsg = CMSG_NXTHDR (&hdr, cmsg))
    {
        if ((cmsg->cmsg_level == SOL_SOCKET)
         && (cmsg->cmsg_type == SCM_RIGHTS)
         && (cmsg->cmsg_len >= CMSG_LEN (sizeof (fd))))
        {
            memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));
            return fd;
        }
    }

    errno = val;
    return -1;
}",1,,76,2,,void
150287,BLOCK,-1,,<empty>,9,,94,2,,void
150292,BLOCK,-1,,<empty>,5,,96,1,,void
150307,BLOCK,4,,"{
        if ((cmsg->cmsg_level == SOL_SOCKET)
         && (cmsg->cmsg_type == SCM_RIGHTS)
         && (cmsg->cmsg_len >= CMSG_LEN (sizeof (fd))))
        {
            memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));
            return fd;
        }
    }",5,,98,4,,void
150326,BLOCK,1,,<empty>,,,,2,,void
150343,BLOCK,-1,,"{
            memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));
            return fd;
        }",9,,102,2,,void
150367,BLOCK,-1,,"{
    /* can't use libvlc */
    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    struct sockaddr_storage ss;
    int fd, sock = -1;

    const char *sockenv = getenv (""VLC_ROOTWRAP_SOCK"");
    if (sockenv != NULL)
        sock = atoi (sockenv);
    if (sock == -1)
    {
        errno = EACCES;
        return -1;
    }

    switch (family)
    {
        case AF_INET:
            if (alen < sizeof (struct sockaddr_in))
            {
                errno = EINVAL;
                return -1;
            }
            break;

#ifdef AF_INET6
        case AF_INET6:
            if (alen < sizeof (struct sockaddr_in6))
            {
                errno = EINVAL;
                return -1;
            }
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            return -1;
    }

    if (family != addr->sa_family)
    {
        errno = EAFNOSUPPORT;
        return -1;
    }

    /* Only TCP is implemented at the moment */
    if ((socktype != SO...",1,,117,6,,void
150388,BLOCK,-1,,<empty>,9,,125,2,,void
150398,BLOCK,-1,,"{
        errno = EACCES;
        return -1;
    }",5,,127,2,,void
150407,BLOCK,-1,,"{
        case AF_INET:
            if (alen < sizeof (struct sockaddr_in))
            {
                errno = EINVAL;
                return -1;
            }
            break;

#ifdef AF_INET6
        case AF_INET6:
            if (alen < sizeof (struct sockaddr_in6))
            {
                errno = EINVAL;
                return -1;
            }
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            return -1;
    }",5,,133,2,,void
150415,BLOCK,-1,,"{
                errno = EINVAL;
                return -1;
            }",13,,136,2,,void
150436,BLOCK,-1,,"{
        errno = EAFNOSUPPORT;
        return -1;
    }",5,,158,2,,void
150453,BLOCK,-1,,"{
        errno = EACCES;
        return -1;
    }",5,,166,2,,void
150490,BLOCK,1,,<empty>,,,,1,,void
150494,BLOCK,-1,,"{
        pthread_mutex_unlock (&mutex);
        return -1;
    }",5,,176,2,,void
150534,BLOCK,-1,,<empty>,1,,1,1,,ANY
150541,BLOCK,-1,,<empty>,,,,6,,<empty>
150552,BLOCK,-1,,<empty>,,,,8,,<empty>
150560,BLOCK,-1,,<empty>,,,,5,,<empty>
150569,BLOCK,-1,,"{
    const char      *psz_realhost;
    char            *psz_socks;
    int             i_realport, i_handle = -1;

    psz_socks = var_InheritString( p_this, ""socks"" );
    if( psz_socks != NULL )
    {
        char *psz = strchr( psz_socks, ':' );

        if( psz )
            *psz++ = '\0';

        psz_realhost = psz_socks;
        i_realport = ( psz != NULL ) ? atoi( psz ) : 1080;

        msg_Dbg( p_this, ""net: connecting to %s port %d (SOCKS) ""
                 ""for %s port %d"", psz_realhost, i_realport,
                 psz_host, i_port );

        /* We only implement TCP with SOCKS */
        switch( type )
        {
            case 0:
                type = SOCK_STREAM;
            case SOCK_STREAM:
                break;
            default:
                msg_Err( p_this, ""Socket type not supported through SOCKS"" );
                free( psz_socks );
                return -1;
        }
        switch( proto )
        {
            case 0:
                proto = IP...",1,,72,6,,void
150587,BLOCK,-1,,"{
        char *psz = strchr( psz_socks, ':' );

        if( psz )
            *psz++ = '\0';

        psz_realhost = psz_socks;
        i_realport = ( psz != NULL ) ? atoi( psz ) : 1080;

        msg_Dbg( p_this, ""net: connecting to %s port %d (SOCKS) ""
                 ""for %s port %d"", psz_realhost, i_realport,
                 psz_host, i_port );

        /* We only implement TCP with SOCKS */
        switch( type )
        {
            case 0:
                type = SOCK_STREAM;
            case SOCK_STREAM:
                break;
            default:
                msg_Err( p_this, ""Socket type not supported through SOCKS"" );
                free( psz_socks );
                return -1;
        }
        switch( proto )
        {
            case 0:
                proto = IPPROTO_TCP;
            case IPPROTO_TCP:
                break;
            default:
                msg_Err( p_this, ""Transport not supported through SOCKS"" );
                free( psz_socks );
       ...",5,,79,2,,void
150596,BLOCK,-1,,<empty>,13,,83,2,,void
150623,BLOCK,-1,,"{
            case 0:
                type = SOCK_STREAM;
            case SOCK_STREAM:
                break;
            default:
                msg_Err( p_this, ""Socket type not supported through SOCKS"" );
                free( psz_socks );
                return -1;
        }",9,,94,2,,void
150643,BLOCK,-1,,"{
            case 0:
                proto = IPPROTO_TCP;
            case IPPROTO_TCP:
                break;
            default:
                msg_Err( p_this, ""Transport not supported through SOCKS"" );
                free( psz_socks );
                return -1;
        }",9,,105,2,,void
150662,BLOCK,-1,,"{
        psz_realhost = psz_host;
        i_realport = i_port;

        msg_Dbg( p_this, ""net: connecting to %s port %d"", psz_realhost,
                 i_realport );
    }",5,,117,1,,void
150679,BLOCK,1,,<empty>,9,,126,1,,void
150683,BLOCK,2,,<empty>,9,,127,2,,void
150687,BLOCK,3,,<empty>,9,,128,3,,void
150705,BLOCK,-1,,"{
        msg_Err (p_this, ""cannot resolve %s port %d : %s"", psz_realhost,
                 i_realport, gai_strerror (val));
        free( psz_socks );
        return -1;
    }",5,,133,2,,void
150731,BLOCK,-1,,<empty>,5,,144,1,,void
150744,BLOCK,4,,"{
        int fd = net_Socket( p_this, ptr->ai_family,
                             ptr->ai_socktype, ptr->ai_protocol );
        if( fd == -1 )
        {
            msg_Dbg( p_this, ""socket error: %s"", vlc_strerror_c(net_errno) );
            continue;
        }

        if( connect( fd, ptr->ai_addr, ptr->ai_addrlen ) )
        {
            if( net_errno != EINPROGRESS && errno != EINTR )
            {
                msg_Err( p_this, ""connection failed: %s"",
                         vlc_strerror_c(net_errno) );
                goto next_ai;
            }

            struct pollfd ufd;
            mtime_t deadline = VLC_TS_INVALID;

            ufd.fd = fd;
            ufd.events = POLLOUT;
            deadline = mdate() + timeout;

            do
            {
                mtime_t now = mdate();

                if (vlc_killed())
                    goto next_ai;

                if (now > deadline)
                    now = deadline;

                val = vlc_poll_i11e(&u...",5,,145,4,,void
150764,BLOCK,-1,,"{
            msg_Dbg( p_this, ""socket error: %s"", vlc_strerror_c(net_errno) );
            continue;
        }",9,,149,2,,void
150780,BLOCK,-1,,"{
            if( net_errno != EINPROGRESS && errno != EINTR )
            {
                msg_Err( p_this, ""connection failed: %s"",
                         vlc_strerror_c(net_errno) );
                goto next_ai;
            }

            struct pollfd ufd;
            mtime_t deadline = VLC_TS_INVALID;

            ufd.fd = fd;
            ufd.events = POLLOUT;
            deadline = mdate() + timeout;

            do
            {
                mtime_t now = mdate();

                if (vlc_killed())
                    goto next_ai;

                if (now > deadline)
                    now = deadline;

                val = vlc_poll_i11e(&ufd, 1, (deadline - now) / 1000);
            }
            while (val == -1 && errno == EINTR);

            switch (val)
            {
                 case -1: /* error */
                     msg_Err (p_this, ""polling error: %s"",
                              vlc_strerror_c(net_errno));
                     goto next_ai;

      ...",9,,155,2,,void
150789,BLOCK,-1,,"{
                msg_Err( p_this, ""connection failed: %s"",
                         vlc_strerror_c(net_errno) );
                goto next_ai;
            }",13,,157,2,,void
150817,BLOCK,-1,,"{
                mtime_t now = mdate();

                if (vlc_killed())
                    goto next_ai;

                if (now > deadline)
                    now = deadline;

                val = vlc_poll_i11e(&ufd, 1, (deadline - now) / 1000);
            }",13,,171,1,,void
150824,BLOCK,-1,,<empty>,21,,175,2,,void
150830,BLOCK,-1,,<empty>,21,,178,2,,void
150855,BLOCK,-1,,"{
                 case -1: /* error */
                     msg_Err (p_this, ""polling error: %s"",
                              vlc_strerror_c(net_errno));
                     goto next_ai;

                 case 0: /* timeout */
                     msg_Warn (p_this, ""connection timed out"");
                     goto next_ai;
            }",13,,185,2,,void
150886,BLOCK,-1,,"{
                msg_Err (p_this, ""connection failed: %s"",
                         vlc_strerror_c(val));
                goto next_ai;
            }",13,,200,2,,void
150911,BLOCK,-1,,<empty>,9,,218,2,,void
150919,BLOCK,-1,,"{
        /* NOTE: psz_socks already free'd! */
        char *psz_user = var_InheritString( p_this, ""socks-user"" );
        char *psz_pwd  = var_InheritString( p_this, ""socks-pwd"" );

        if( SocksHandshakeTCP( p_this, i_handle, 5, psz_user, psz_pwd,
                               psz_host, i_port ) )
        {
            msg_Err( p_this, ""SOCKS handshake failed"" );
            net_Close( i_handle );
            i_handle = -1;
        }

        free( psz_user );
        free( psz_pwd );
    }",5,,221,2,,void
150941,BLOCK,-1,,"{
            msg_Err( p_this, ""SOCKS handshake failed"" );
            net_Close( i_handle );
            i_handle = -1;
        }",9,,228,2,,void
150962,BLOCK,-1,,"{
    int fd = vlc_accept (lfd, NULL, NULL, true);
    if (fd == -1)
    {
        if (net_errno != EAGAIN)
#if (EAGAIN != EWOULDBLOCK)
          if (net_errno != EWOULDBLOCK)
#endif
            msg_Err (obj, ""accept failed (from socket %d): %s"", lfd,
                     vlc_strerror_c(net_errno));
        return -1;
    }

    msg_Dbg (obj, ""accepted socket %d (from socket %d)"", fd, lfd);
    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof(int));
    return fd;
}",1,,243,3,,void
150976,BLOCK,-1,,"{
        if (net_errno != EAGAIN)
#if (EAGAIN != EWOULDBLOCK)
          if (net_errno != EWOULDBLOCK)
#endif
            msg_Err (obj, ""accept failed (from socket %d): %s"", lfd,
                     vlc_strerror_c(net_errno));
        return -1;
    }",5,,246,2,,void
150981,BLOCK,-1,,<empty>,13,,251,2,,void
151014,BLOCK,-1,,"{
    assert (pi_fd != NULL);

    unsigned n = 0;
    while (pi_fd[n] != -1)
        n++;

    struct pollfd ufd[n];
    /* Initialize file descriptor set */
    for (unsigned i = 0; i < n; i++)
    {
        ufd[i].fd = pi_fd[i];
        ufd[i].events = POLLIN;
    }

    for (;;)
    {
        while (poll (ufd, n, -1) == -1)
        {
            if (net_errno != EINTR)
            {
                msg_Err (p_this, ""poll error: %s"", vlc_strerror_c(net_errno));
                return -1;
            }
        }

        for (unsigned i = 0; i < n; i++)
        {
            if (ufd[i].revents == 0)
                continue;

            int sfd = ufd[i].fd;
            int fd = net_AcceptSingle (p_this, sfd);
            if (fd == -1)
                continue;

            /*
             * Move listening socket to the end to let the others in the
             * set a chance next time.
             */
            memmove (pi_fd + i, pi_fd + i + 1, n - (i + 1));
            pi_fd[...",1,,275,3,,void
151034,BLOCK,-1,,<empty>,5,,284,1,,void
151044,BLOCK,4,,"{
        ufd[i].fd = pi_fd[i];
        ufd[i].events = POLLIN;
    }",5,,285,4,,void
151062,BLOCK,-1,,<empty>,5,,290,1,,void
151063,BLOCK,4,,"{
        while (poll (ufd, n, -1) == -1)
        {
            if (net_errno != EINTR)
            {
                msg_Err (p_this, ""poll error: %s"", vlc_strerror_c(net_errno));
                return -1;
            }
        }

        for (unsigned i = 0; i < n; i++)
        {
            if (ufd[i].revents == 0)
                continue;

            int sfd = ufd[i].fd;
            int fd = net_AcceptSingle (p_this, sfd);
            if (fd == -1)
                continue;

            /*
             * Move listening socket to the end to let the others in the
             * set a chance next time.
             */
            memmove (pi_fd + i, pi_fd + i + 1, n - (i + 1));
            pi_fd[n - 1] = sfd;
            return fd;
        }
    }",5,,291,4,,void
151073,BLOCK,-1,,"{
            if (net_errno != EINTR)
            {
                msg_Err (p_this, ""poll error: %s"", vlc_strerror_c(net_errno));
                return -1;
            }
        }",9,,293,2,,void
151078,BLOCK,-1,,"{
                msg_Err (p_this, ""poll error: %s"", vlc_strerror_c(net_errno));
                return -1;
            }",13,,295,2,,void
151088,BLOCK,-1,,<empty>,9,,301,1,,void
151098,BLOCK,4,,"{
            if (ufd[i].revents == 0)
                continue;

            int sfd = ufd[i].fd;
            int fd = net_AcceptSingle (p_this, sfd);
            if (fd == -1)
                continue;

            /*
             * Move listening socket to the end to let the others in the
             * set a chance next time.
             */
            memmove (pi_fd + i, pi_fd + i + 1, n - (i + 1));
            pi_fd[n - 1] = sfd;
            return fd;
        }",9,,302,4,,void
151107,BLOCK,-1,,<empty>,17,,304,2,,void
151128,BLOCK,-1,,<empty>,17,,309,2,,void
151164,BLOCK,-1,,"{
    uint8_t buffer[128+2*256];
    int i_len;
    bool b_auth = false;

    if( i_socks_version != 5 )
        return VLC_SUCCESS;

    /* We negotiate authentication */
    buffer[0] = i_socks_version;    /* SOCKS version */
    if( psz_socks_user != NULL && psz_socks_passwd != NULL )
    {
        buffer[1] = 2;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        buffer[3] = 0x02;               /* - USer/Password */
        i_len = 4;
        b_auth = true;
    }
    else
    {
        buffer[1] = 1;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        i_len = 3;
    }

    if( net_Write( p_obj, fd, buffer, i_len ) != i_len )
        return VLC_EGENERIC;
    if( net_Read( p_obj, fd, buffer, 2) != 2 )
        return VLC_EGENERIC;

    msg_Dbg( p_obj, ""socks: v=%d method=%x"", buffer[0], buffer[1] );

    if( buffer[1] == 0x00 )
    {
        msg_Dbg( p_obj, ""s...",1,,333,6,,void
151175,BLOCK,-1,,<empty>,9,,339,2,,void
151191,BLOCK,-1,,"{
        buffer[1] = 2;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        buffer[3] = 0x02;               /* - USer/Password */
        i_len = 4;
        b_auth = true;
    }",5,,344,2,,void
151214,BLOCK,-1,,"{
        buffer[1] = 1;                  /* Number of methods */
        buffer[2] = 0x00;               /* - No auth required */
        i_len = 3;
    }",5,,352,1,,void
151236,BLOCK,-1,,<empty>,9,,359,2,,void
151247,BLOCK,-1,,<empty>,9,,361,2,,void
151265,BLOCK,-1,,"{
        msg_Dbg( p_obj, ""socks: no authentication required"" );
    }",5,,366,2,,void
151270,BLOCK,-1,,<empty>,10,,369,1,,void
151277,BLOCK,-1,,"{
        if( psz_socks_user == NULL || psz_socks_passwd == NULL )
        {
            msg_Err( p_obj, ""socks: server mandates authentication but ""
                            ""a username and/or password was not supplied"" );
            return VLC_EGENERIC;
        }

        int const i_user = strlen( psz_socks_user );
        int const i_pasw = strlen( psz_socks_passwd );

        if( i_user > 255 || i_pasw > 255 )
        {
            msg_Err( p_obj, ""socks: rejecting username and/or password due to ""
                            ""violation of RFC1929 (longer than 255 bytes)"" );
            return VLC_EGENERIC;
        }

        msg_Dbg( p_obj, ""socks: username/password authentication"" );

        buffer[0] = i_socks_version;        /* Version */
        buffer[1] = i_user;                 /* User length */
        memcpy( &buffer[2], psz_socks_user, i_user );
        buffer[2+i_user] = i_pasw;          /* Password length */
        memcpy( &buffer[2+i_user+1], psz_socks_passw...",5,,370,2,,void
151286,BLOCK,-1,,"{
            msg_Err( p_obj, ""socks: server mandates authentication but ""
                            ""a username and/or password was not supplied"" );
            return VLC_EGENERIC;
        }",9,,372,2,,void
151310,BLOCK,-1,,"{
            msg_Err( p_obj, ""socks: rejecting username and/or password due to ""
                            ""violation of RFC1929 (longer than 255 bytes)"" );
            return VLC_EGENERIC;
        }",9,,382,2,,void
151369,BLOCK,-1,,<empty>,13,,399,2,,void
151380,BLOCK,-1,,<empty>,13,,402,2,,void
151398,BLOCK,-1,,"{
            msg_Err( p_obj, ""socks: authentication rejected"" );
            return VLC_EGENERIC;
        }",9,,406,2,,void
151405,BLOCK,-1,,"{
        if( b_auth )
            msg_Err( p_obj, ""socks: unsupported authentication method %x"",
                     buffer[0] );
        else
            msg_Err( p_obj, ""socks: authentication needed"" );
        return VLC_EGENERIC;
    }",5,,412,1,,void
151408,BLOCK,-1,,<empty>,13,,414,2,,void
151416,BLOCK,-1,,<empty>,13,,417,1,,void
151434,BLOCK,-1,,"{
    uint8_t buffer[128+2*256];

    if( i_socks_version != 4 && i_socks_version != 5 )
    {
        msg_Warn( p_obj, ""invalid socks protocol version %d"", i_socks_version );
        i_socks_version = 5;
    }

    if( i_socks_version == 5 &&
        SocksNegotiate( p_obj, fd, i_socks_version,
                        psz_user, psz_passwd ) )
        return VLC_EGENERIC;

    if( i_socks_version == 4 )
    {
        /* v4 only support ipv4 */
        static const struct addrinfo hints = {
            .ai_family = AF_INET,
            .ai_socktype = SOCK_STREAM,
            .ai_protocol = IPPROTO_TCP,
            .ai_flags = AI_IDN,
        };
        struct addrinfo *res;

        if (vlc_getaddrinfo_i11e(psz_host, 0, &hints, &res))
            return VLC_EGENERIC;

        buffer[0] = i_socks_version;
        buffer[1] = 0x01;               /* CONNECT */
        SetWBE( &buffer[2], i_port );   /* Port */
        memcpy (&buffer[4],             /* Address */
                &((struc...",1,,434,8,,void
151444,BLOCK,-1,,"{
        msg_Warn( p_obj, ""invalid socks protocol version %d"", i_socks_version );
        i_socks_version = 5;
    }",5,,438,2,,void
151463,BLOCK,-1,,<empty>,9,,446,2,,void
151470,BLOCK,-1,,"{
        /* v4 only support ipv4 */
        static const struct addrinfo hints = {
            .ai_family = AF_INET,
            .ai_socktype = SOCK_STREAM,
            .ai_protocol = IPPROTO_TCP,
            .ai_flags = AI_IDN,
        };
        struct addrinfo *res;

        if (vlc_getaddrinfo_i11e(psz_host, 0, &hints, &res))
            return VLC_EGENERIC;

        buffer[0] = i_socks_version;
        buffer[1] = 0x01;               /* CONNECT */
        SetWBE( &buffer[2], i_port );   /* Port */
        memcpy (&buffer[4],             /* Address */
                &((struct sockaddr_in *)(res->ai_addr))->sin_addr, 4);
        freeaddrinfo (res);

        buffer[8] = 0;                  /* Empty user id */

        if( net_Write( p_obj, fd, buffer, 9 ) != 9 )
            return VLC_EGENERIC;
        if( net_Read( p_obj, fd, buffer, 8 ) != 8 )
            return VLC_EGENERIC;

        msg_Dbg( p_obj, ""socks: v=%d cd=%d"",
                 buffer[0], buffer[1] );

        if( bu...",5,,449,2,,void
151475,BLOCK,1,,<empty>,13,,452,1,,void
151479,BLOCK,2,,<empty>,13,,453,2,,void
151483,BLOCK,3,,<empty>,13,,454,3,,void
151487,BLOCK,4,,<empty>,13,,455,4,,void
151500,BLOCK,-1,,<empty>,13,,460,2,,void
151548,BLOCK,-1,,<empty>,13,,472,2,,void
151559,BLOCK,-1,,<empty>,13,,474,2,,void
151577,BLOCK,-1,,<empty>,13,,480,2,,void
151581,BLOCK,-1,,<empty>,10,,482,1,,void
151586,BLOCK,-1,,"{
        int i_hlen = __MIN(strlen( psz_host ), 255);
        int i_len;

        buffer[0] = i_socks_version;    /* Version */
        buffer[1] = 0x01;               /* Cmd: connect */
        buffer[2] = 0x00;               /* Reserved */
        buffer[3] = 3;                  /* ATYP: for now domainname */

        buffer[4] = i_hlen;
        memcpy( &buffer[5], psz_host, i_hlen );
        SetWBE( &buffer[5+i_hlen], i_port );

        i_len = 5 + i_hlen + 2;


        if( net_Write( p_obj, fd, buffer, i_len ) != i_len )
            return VLC_EGENERIC;

        /* Read the header */
        if( net_Read( p_obj, fd, buffer, 5 ) != 5 )
            return VLC_EGENERIC;

        msg_Dbg( p_obj, ""socks: v=%d rep=%d atyp=%d"",
                 buffer[0], buffer[1], buffer[3] );

        if( buffer[1] != 0x00 )
        {
            msg_Err( p_obj, ""socks: CONNECT request failed"" );
            return VLC_EGENERIC;
        }

        /* Read the remaining bytes */
        if( buffer[3...",5,,483,2,,void
151650,BLOCK,-1,,<empty>,13,,500,2,,void
151661,BLOCK,-1,,<empty>,13,,504,2,,void
151682,BLOCK,-1,,"{
            msg_Err( p_obj, ""socks: CONNECT request failed"" );
            return VLC_EGENERIC;
        }",9,,510,2,,void
151694,BLOCK,-1,,<empty>,13,,517,2,,void
151703,BLOCK,-1,,<empty>,14,,518,1,,void
151710,BLOCK,-1,,<empty>,13,,519,2,,void
151719,BLOCK,-1,,<empty>,14,,520,1,,void
151726,BLOCK,-1,,<empty>,13,,521,2,,void
151735,BLOCK,-1,,<empty>,13,,523,1,,void
151746,BLOCK,-1,,<empty>,13,,526,2,,void
151755,BLOCK,-1,,"{
    if( pi_fd != NULL )
    {
        int *pi;

        for( pi = pi_fd; *pi != -1; pi++ )
            net_Close( *pi );
        free( pi_fd );
    }
}",1,,533,2,,void
151760,BLOCK,-1,,"{
        int *pi;

        for( pi = pi_fd; *pi != -1; pi++ )
            net_Close( *pi );
        free( pi_fd );
    }",5,,535,2,,void
151763,BLOCK,-1,,<empty>,9,,538,1,,void
151813,BLOCK,-1,,<empty>,1,,1,1,,ANY
151817,BLOCK,-1,,"{
    int (*activate) (vlc_tls_creds_t *, const char *, const char *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);
    const char *cert = va_arg (ap, const char *);
    const char *key = va_arg (ap, const char *);

    return activate (crd, cert, key);
}",1,,61,3,,void
151822,BLOCK,-1,,<empty>,,,,4,,<empty>
151838,BLOCK,-1,,"{
    int (*activate) (vlc_tls_creds_t *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);

    return activate (crd);
}",1,,71,3,,void
151841,BLOCK,-1,,<empty>,,,,2,,<empty>
151853,BLOCK,-1,,"{
    void (*deactivate) (vlc_tls_creds_t *) = func;
    vlc_tls_creds_t *crd = va_arg (ap, vlc_tls_creds_t *);

    deactivate (crd);
}",1,,79,3,,void
151856,BLOCK,-1,,<empty>,,,,2,,<empty>
151868,BLOCK,-1,,"{
    vlc_tls_creds_t *srv = vlc_custom_create (obj, sizeof (*srv),
                                              ""tls server"");
    if (unlikely(srv == NULL))
        return NULL;

    if (key_path == NULL)
        key_path = cert_path;

    srv->module = vlc_module_load (srv, ""tls server"", NULL, false,
                                   tls_server_load, srv, cert_path, key_path);
    if (srv->module == NULL)
    {
        msg_Err (srv, ""TLS server plugin not available"");
        vlc_object_release (srv);
        return NULL;
    }

    return srv;
}",1,,89,4,,void
151874,BLOCK,1,,<empty>,,,,3,,void
151887,BLOCK,-1,,<empty>,9,,93,2,,void
151894,BLOCK,-1,,<empty>,9,,96,2,,void
151917,BLOCK,-1,,"{
        msg_Err (srv, ""TLS server plugin not available"");
        vlc_object_release (srv);
        return NULL;
    }",5,,101,2,,void
151931,BLOCK,-1,,"{
    vlc_tls_creds_t *crd = vlc_custom_create (obj, sizeof (*crd),
                                              ""tls client"");
    if (unlikely(crd == NULL))
        return NULL;

    crd->module = vlc_module_load (crd, ""tls client"", NULL, false,
                                   tls_client_load, crd);
    if (crd->module == NULL)
    {
        msg_Err (crd, ""TLS client plugin not available"");
        vlc_object_release (crd);
        return NULL;
    }

    return crd;
}",1,,111,2,,void
151937,BLOCK,1,,<empty>,,,,3,,void
151950,BLOCK,-1,,<empty>,9,,115,2,,void
151970,BLOCK,-1,,"{
        msg_Err (crd, ""TLS client plugin not available"");
        vlc_object_release (crd);
        return NULL;
    }",5,,120,2,,void
151984,BLOCK,-1,,"{
    if (crd == NULL)
        return;

    vlc_module_unload(crd, crd->module, tls_unload, crd);
    vlc_object_release (crd);
}",1,,130,2,,void
151989,BLOCK,-1,,<empty>,9,,132,2,,void
152007,BLOCK,-1,,"{
    vlc_tls_t *session;
    int canc = vlc_savecancel();
    session = crd->open(crd, sock, host, alpn);
    vlc_restorecancel(canc);
    if (session != NULL)
        session->p = sock;
    return session;
}",1,,145,5,,void
152029,BLOCK,-1,,<empty>,9,,151,2,,void
152041,BLOCK,-1,,"{
    int canc = vlc_savecancel();
    session->close(session);
    vlc_restorecancel(canc);
}",1,,156,2,,void
152057,BLOCK,-1,,"{
    vlc_tls_t *session = data;

    vlc_tls_SessionDelete (session);
}",1,,163,2,,void
152073,BLOCK,-1,,"{
    int val;

    vlc_tls_t *session = vlc_tls_SessionCreate(crd, sock, host, alpn);
    if (session == NULL)
        return NULL;

    int canc = vlc_savecancel();
    mtime_t deadline = mdate ();
    deadline += var_InheritInteger (crd, ""ipv4-timeout"") * 1000;

    struct pollfd ufd[1];
    ufd[0].fd = vlc_tls_GetFD(sock);

    vlc_cleanup_push (cleanup_tls, session);
    while ((val = crd->handshake(crd, session, host, service, alp)) != 0)
    {
        if (val < 0 || vlc_killed() )
        {
            if (val < 0)
                msg_Err(crd, ""TLS session handshake error"");
error:
            vlc_tls_SessionDelete (session);
            session = NULL;
            break;
        }

        mtime_t now = mdate ();
        if (now > deadline)
           now = deadline;

        assert (val <= 2);
        ufd[0] .events = (val == 1) ? POLLIN : POLLOUT;

        vlc_restorecancel(canc);
        val = vlc_poll_i11e(ufd, 1, (deadline - now) / 1000);
        canc = vlc_savecancel()...",1,,173,7,,void
152087,BLOCK,-1,,<empty>,9,,178,2,,void
152131,BLOCK,-1,,"{
        if (val < 0 || vlc_killed() )
        {
            if (val < 0)
                msg_Err(crd, ""TLS session handshake error"");
error:
            vlc_tls_SessionDelete (session);
            session = NULL;
            break;
        }

        mtime_t now = mdate ();
        if (now > deadline)
           now = deadline;

        assert (val <= 2);
        ufd[0] .events = (val == 1) ? POLLIN : POLLOUT;

        vlc_restorecancel(canc);
        val = vlc_poll_i11e(ufd, 1, (deadline - now) / 1000);
        canc = vlc_savecancel();
        if (val == 0)
        {
            msg_Err(crd, ""TLS session handshake timeout"");
            goto error;
        }
    }",5,,189,2,,void
152138,BLOCK,-1,,"{
            if (val < 0)
                msg_Err(crd, ""TLS session handshake error"");
error:
            vlc_tls_SessionDelete (session);
            session = NULL;
            break;
        }",9,,191,2,,void
152143,BLOCK,-1,,<empty>,17,,193,2,,void
152162,BLOCK,-1,,<empty>,12,,202,2,,void
152201,BLOCK,-1,,"{
            msg_Err(crd, ""TLS session handshake timeout"");
            goto error;
        }",9,,211,2,,void
152217,BLOCK,-1,,"{
    return vlc_tls_SessionCreate(crd, sock, NULL, alpn);
}",1,,224,4,,void
152231,BLOCK,-1,,"{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLIN;
    iov.iov_base = buf;
    iov.iov_len = len;

    for (size_t rcvd = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->readv(session, &iov, 1);
        if (val > 0)
        {
            if (!waitall)
                return val;
            iov.iov_base = (char *)iov.iov_base + val;
            iov.iov_len -= val;
            rcvd += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return rcvd;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return rcvd ? (ssize_t)rcvd : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",1,,229,5,,void
152256,BLOCK,-1,,<empty>,5,,238,1,,void
152261,BLOCK,4,,"{
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->readv(session, &iov, 1);
        if (val > 0)
        {
            if (!waitall)
                return val;
            iov.iov_base = (char *)iov.iov_base + val;
            iov.iov_len -= val;
            rcvd += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return rcvd;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return rcvd ? (ssize_t)rcvd : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }",5,,239,4,,void
152264,BLOCK,-1,,"{
            errno = EINTR;
            return -1;
        }",9,,241,2,,void
152286,BLOCK,-1,,"{
            if (!waitall)
                return val;
            iov.iov_base = (char *)iov.iov_base + val;
            iov.iov_len -= val;
            rcvd += val;
        }",9,,248,2,,void
152290,BLOCK,-1,,<empty>,17,,250,2,,void
152322,BLOCK,-1,,<empty>,13,,256,2,,void
152330,BLOCK,-1,,"{
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return rcvd ? (ssize_t)rcvd : -1;
        }",9,,258,2,,void
152333,BLOCK,-1,,<empty>,17,,260,2,,void
152345,BLOCK,-1,,<empty>,17,,262,2,,void
152366,BLOCK,-1,,"{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLOUT;
    iov.iov_base = (void *)buf;
    iov.iov_len = len;

    for (size_t sent = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->writev(session, &iov, 1);
        if (val > 0)
        {
            iov.iov_base = ((char *)iov.iov_base) + val;
            iov.iov_len -= val;
            sent += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return sent;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return sent ? (ssize_t)sent : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",1,,270,4,,void
152393,BLOCK,-1,,<empty>,5,,279,1,,void
152398,BLOCK,4,,"{
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->writev(session, &iov, 1);
        if (val > 0)
        {
            iov.iov_base = ((char *)iov.iov_base) + val;
            iov.iov_len -= val;
            sent += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return sent;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return sent ? (ssize_t)sent : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }",5,,280,4,,void
152401,BLOCK,-1,,"{
            errno = EINTR;
            return -1;
        }",9,,282,2,,void
152423,BLOCK,-1,,"{
            iov.iov_base = ((char *)iov.iov_base) + val;
            iov.iov_len -= val;
            sent += val;
        }",9,,289,2,,void
152453,BLOCK,-1,,<empty>,13,,295,2,,void
152461,BLOCK,-1,,"{
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return sent ? (ssize_t)sent : -1;
        }",9,,297,2,,void
152464,BLOCK,-1,,<empty>,17,,299,2,,void
152476,BLOCK,-1,,<empty>,17,,301,2,,void
152495,BLOCK,-1,,"{
    char *line = NULL;
    size_t linelen = 0, linesize = 0;

    do
    {
        if (linelen == linesize)
        {
            linesize += 1024;

            char *newline = realloc(line, linesize);
            if (unlikely(newline == NULL))
                goto error;
            line = newline;
        }

        if (vlc_tls_Read(session, line + linelen, 1, false) <= 0)
            goto error;
    }
    while (line[linelen++] != '\n');

    if (linelen >= 2 && line[linelen - 2] == '\r')
        line[linelen - 2] = '\0';
    else
        line[linelen - 1] = '\0';
    return line;

error:
    free(line);
    return NULL;
}",1,,309,2,,void
152509,BLOCK,-1,,"{
        if (linelen == linesize)
        {
            linesize += 1024;

            char *newline = realloc(line, linesize);
            if (unlikely(newline == NULL))
                goto error;
            line = newline;
        }

        if (vlc_tls_Read(session, line + linelen, 1, false) <= 0)
            goto error;
    }",5,,314,1,,void
152514,BLOCK,-1,,"{
            linesize += 1024;

            char *newline = realloc(line, linesize);
            if (unlikely(newline == NULL))
                goto error;
            line = newline;
        }",9,,316,2,,void
152529,BLOCK,-1,,<empty>,17,,321,2,,void
152544,BLOCK,-1,,<empty>,13,,326,2,,void
152564,BLOCK,-1,,<empty>,9,,331,2,,void
152573,BLOCK,-1,,<empty>,9,,333,1,,void
152598,BLOCK,-1,,<empty>,,,,1,,<empty>
152605,BLOCK,-1,,"{
    vlc_tls_socket_t *sock = (struct vlc_tls_socket *)tls;

    return sock->fd;
}",1,,350,2,,void
152622,BLOCK,-1,,"{
    struct msghdr msg =
    {
        .msg_iov = iov,
        .msg_iovlen = count,
    };

    return recvmsg(vlc_tls_SocketGetFD(tls), &msg, 0);
}",1,,358,4,,void
152627,BLOCK,1,,<empty>,9,,361,1,,void
152631,BLOCK,2,,<empty>,9,,362,2,,void
152648,BLOCK,-1,,"{
    const struct msghdr msg =
    {
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };

    return sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL);
}",1,,370,4,,void
152653,BLOCK,1,,<empty>,9,,373,1,,void
152659,BLOCK,2,,<empty>,9,,374,2,,void
152675,BLOCK,-1,,"{
    return shutdown(vlc_tls_SocketGetFD(tls), duplex ? SHUT_RDWR : SHUT_WR);
}",1,,381,3,,void
152688,BLOCK,-1,,"{
    net_Close(vlc_tls_SocketGetFD(tls));
    free(tls);
}",1,,386,2,,void
152700,BLOCK,-1,,"{
    vlc_tls_socket_t *sock = malloc(sizeof (*sock) + peerlen);
    if (unlikely(sock == NULL))
        return NULL;

    vlc_tls_t *tls = &sock->tls;

    tls->get_fd = vlc_tls_SocketGetFD;
    tls->readv = vlc_tls_SocketRead;
    tls->writev = vlc_tls_SocketWrite;
    tls->shutdown = vlc_tls_SocketShutdown;
    tls->close = vlc_tls_SocketClose;
    tls->p = NULL;

    sock->fd = fd;
    sock->peerlen = peerlen;
    if (peerlen > 0)
        memcpy(sock->peer, peer, peerlen);
    return tls;
}",1,,394,4,,void
152715,BLOCK,-1,,<empty>,9,,397,2,,void
152769,BLOCK,-1,,<empty>,9,,411,2,,void
152782,BLOCK,-1,,"{
    return vlc_tls_SocketAlloc(fd, NULL, 0);
}",1,,416,2,,void
152794,BLOCK,-1,,"{
    int fds[2];

    if (vlc_socketpair(family, SOCK_STREAM, protocol, fds, true))
        return -1;

    for (size_t i = 0; i < 2; i++)
    {
        setsockopt(fds[i], SOL_SOCKET, SO_REUSEADDR,
                   &(int){ 1 }, sizeof (int));

        pair[i] = vlc_tls_SocketAlloc(fds[i], NULL, 0);
        if (unlikely(pair[i] == NULL))
        {
            net_Close(fds[i]);
            if (i)
                vlc_tls_SessionDelete(pair[0]);
            else
                net_Close(fds[1]);
            return -1;
        }
    }
    return 0;
}",1,,421,4,,void
152803,BLOCK,-1,,<empty>,9,,425,2,,void
152808,BLOCK,-1,,<empty>,5,,427,1,,void
152818,BLOCK,4,,"{
        setsockopt(fds[i], SOL_SOCKET, SO_REUSEADDR,
                   &(int){ 1 }, sizeof (int));

        pair[i] = vlc_tls_SocketAlloc(fds[i], NULL, 0);
        if (unlikely(pair[i] == NULL))
        {
            net_Close(fds[i]);
            if (i)
                vlc_tls_SessionDelete(pair[0]);
            else
                net_Close(fds[1]);
            return -1;
        }
    }",5,,428,4,,void
152849,BLOCK,-1,,"{
            net_Close(fds[i]);
            if (i)
                vlc_tls_SessionDelete(pair[0]);
            else
                net_Close(fds[1]);
            return -1;
        }",9,,434,2,,void
152856,BLOCK,-1,,<empty>,17,,437,2,,void
152862,BLOCK,-1,,<empty>,17,,439,1,,void
152876,BLOCK,-1,,"{
    int fd = vlc_socket(info->ai_family, info->ai_socktype, info->ai_protocol,
                        true /* nonblocking */);
    if (fd == -1)
        return NULL;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

    if (info->ai_socktype == SOCK_STREAM && info->ai_protocol == IPPROTO_TCP)
        setsockopt(fd, SOL_TCP, TCP_NODELAY, &(int){ 1 }, sizeof (int));

    vlc_tls_t *sk = vlc_tls_SocketAlloc(fd, info->ai_addr, info->ai_addrlen);
    if (unlikely(sk == NULL))
        net_Close(fd);
    return sk;
}",1,,450,2,,void
152896,BLOCK,-1,,<empty>,9,,454,2,,void
152922,BLOCK,-1,,<empty>,9,,459,2,,void
152926,BLOCK,1,,<empty>,,,,1,,void
152952,BLOCK,-1,,<empty>,9,,463,2,,void
152961,BLOCK,-1,,"{
    const int fd = vlc_tls_GetFD(tls);
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    do
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }
    }
    while (vlc_poll_i11e(&ufd, 1, -1) <= 0);

    int val;
    socklen_t len = sizeof (val);

    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &val, &len))
        return -1;

    if (val != 0)
    {
        errno = val;
        return -1;
    }
    return 0;
}",1,,471,2,,void
152979,BLOCK,-1,,"{
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }
    }",5,,479,1,,void
152982,BLOCK,-1,,"{
            errno = EINTR;
            return -1;
        }",9,,481,2,,void
153012,BLOCK,-1,,<empty>,9,,492,2,,void
153020,BLOCK,-1,,"{
        errno = val;
        return -1;
    }",5,,495,2,,void
153033,BLOCK,-1,,"{
    const vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;

    if (connect(sock->fd, sock->peer, sock->peerlen) == 0)
        return 0;
#ifndef _WIN32
    if (errno != EINPROGRESS)
        return -1;
#else
    if (WSAGetLastError() != WSAEWOULDBLOCK)
        return -1;
#endif
    return vlc_tls_WaitConnect(tls);
}",1,,506,2,,void
153053,BLOCK,-1,,<empty>,9,,510,2,,void
153060,BLOCK,-1,,<empty>,9,,513,2,,void
153073,BLOCK,-1,,"{
#ifdef MSG_FASTOPEN
    vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;
    const struct msghdr msg =
    {
        .msg_name = sock->peer,
        .msg_namelen = sock->peerlen,
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };
    ssize_t ret;

    /* Next time, write directly. Do not retry to connect. */
    tls->writev = vlc_tls_SocketWrite;

    ret = sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL|MSG_FASTOPEN);
    if (ret >= 0)
    {   /* Fast open in progress */
        return ret;
    }

    if (errno == EINPROGRESS)
    {
        if (vlc_tls_WaitConnect(tls))
            return -1;
    }
    else
    if (errno != EOPNOTSUPP)
        return -1;
    /* Fast open not supported or disabled... fallback to normal mode */
#else
    tls->writev = vlc_tls_SocketWrite;
#endif

    if (vlc_tls_Connect(tls))
        return -1;

    return vlc_tls_SocketWrite(tls, iov, count);
}",1,,524,4,,void
153082,BLOCK,-1,,<empty>,9,,559,2,,void
153096,BLOCK,-1,,"{
    vlc_tls_t *sock = vlc_tls_SocketAddrInfo(info);
    if (sock == NULL)
        return NULL;

    if (defer_connect)
    {   /* The socket is not connected yet.
         * The connection will be triggered on the first send. */
        sock->writev = vlc_tls_ConnectWrite;
    }
    else
    {
        if (vlc_tls_Connect(sock))
        {
            vlc_tls_SessionDelete(sock);
            sock = NULL;
        }
    }
    return sock;
}",1,,566,3,,void
153106,BLOCK,-1,,<empty>,9,,569,2,,void
153111,BLOCK,-1,,"{   /* The socket is not connected yet.
         * The connection will be triggered on the first send. */
        sock->writev = vlc_tls_ConnectWrite;
    }",5,,572,2,,void
153118,BLOCK,-1,,"{
        if (vlc_tls_Connect(sock))
        {
            vlc_tls_SessionDelete(sock);
            sock = NULL;
        }
    }",5,,577,1,,void
153122,BLOCK,-1,,"{
            vlc_tls_SessionDelete(sock);
            sock = NULL;
        }",9,,579,2,,void
153136,BLOCK,-1,,"{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    assert(name != NULL);
    msg_Dbg(obj, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(obj, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    msg_Dbg(obj, ""connecting to %s port %u ..."", name, port);

    /* TODO: implement RFC6555 */
    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tls = vlc_tls_SocketOpenAddrInfo(p, false);
        if (tls == NULL)
        {
            msg_Err(obj, ""connection error: %s"", vlc_strerror_c(errno));
            continue;
        }

        freeaddrinfo(res);
        return tls;
    }

    freeaddrinfo(res);
    return NULL;
}",1,,589,4,,void
153142,BLOCK,1,,<empty>,9,,592,1,,void
153146,BLOCK,2,,<empty>,9,,593,2,,void
153172,BLOCK,-1,,"{   /* TODO: C locale for gai_strerror() */
        msg_Err(obj, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }",5,,601,2,,void
153188,BLOCK,-1,,<empty>,5,,610,1,,void
153201,BLOCK,4,,"{
        vlc_tls_t *tls = vlc_tls_SocketOpenAddrInfo(p, false);
        if (tls == NULL)
        {
            msg_Err(obj, ""connection error: %s"", vlc_strerror_c(errno));
            continue;
        }

        freeaddrinfo(res);
        return tls;
    }",5,,611,4,,void
153212,BLOCK,-1,,"{
            msg_Err(obj, ""connection error: %s"", vlc_strerror_c(errno));
            continue;
        }",9,,614,2,,void
153236,BLOCK,-1,,"{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    msg_Dbg(creds, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(creds, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tcp = vlc_tls_SocketOpenAddrInfo(p, true);
        if (tcp == NULL)
        {
            msg_Err(creds, ""socket error: %s"", vlc_strerror_c(errno));
            continue;
        }

        vlc_tls_t *tls = vlc_tls_ClientSessionCreate(creds, tcp, name, service,
                                                     alpn, alp);
        if (tls != NULL)
        {   /* Success! */
            freeaddrinfo(res);
            return tls;
        }

        msg_Err(creds, ""connec...",1,,630,7,,void
153242,BLOCK,1,,<empty>,9,,633,1,,void
153246,BLOCK,2,,<empty>,9,,634,2,,void
153268,BLOCK,-1,,"{   /* TODO: C locale for gai_strerror() */
        msg_Err(creds, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }",5,,641,2,,void
153279,BLOCK,-1,,<empty>,5,,647,1,,void
153292,BLOCK,4,,"{
        vlc_tls_t *tcp = vlc_tls_SocketOpenAddrInfo(p, true);
        if (tcp == NULL)
        {
            msg_Err(creds, ""socket error: %s"", vlc_strerror_c(errno));
            continue;
        }

        vlc_tls_t *tls = vlc_tls_ClientSessionCreate(creds, tcp, name, service,
                                                     alpn, alp);
        if (tls != NULL)
        {   /* Success! */
            freeaddrinfo(res);
            return tls;
        }

        msg_Err(creds, ""connection error: %s"", vlc_strerror_c(errno));
        vlc_tls_SessionDelete(tcp);
    }",5,,648,4,,void
153303,BLOCK,-1,,"{
            msg_Err(creds, ""socket error: %s"", vlc_strerror_c(errno));
            continue;
        }",9,,651,2,,void
153324,BLOCK,-1,,"{   /* Success! */
            freeaddrinfo(res);
            return tls;
        }",9,,659,2,,void
153366,BLOCK,-1,,<empty>,1,,1,1,,ANY
153372,BLOCK,-1,,<empty>,,,,5,,<empty>
153379,BLOCK,-1,,"{
#if defined (SO_REUSEPORT) && !defined (__linux__)
    setsockopt (fd, SOL_SOCKET, SO_REUSEPORT, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)

    /* Check windows version so we know if we need to increase receive buffers
     * for Windows 7 and earlier

     * SetSocketMediaStreamingMode is present in win 8 and later, so we set
     * receive buffer if that isn't present
     */
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    HINSTANCE h_Network = LoadLibrary(TEXT(""Windows.Networking.dll""));
    if( (h_Network == NULL) ||
        (GetProcAddress( h_Network, ""SetSocketMediaStreamingMode"" ) == NULL ) )
    {
        setsockopt (fd, SOL_SOCKET, SO_RCVBUF,
                         (void *)&(int){ 0x80000 }, sizeof (int));
    }
    if( h_Network )
        FreeLibrary( h_Network );
#endif

    if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
     && (sizeof (struct sockaddr_storage) >= ptr->ai_addrlen))
    {
        // This works for IPv4 too - don't worry!
       ...",1,,95,4,,void
153389,BLOCK,-1,,"{
        msg_Err( p_obj, ""socket bind error: %s"", vlc_strerror_c(net_errno) );
        net_Close (fd);
        return -1;
    }",5,,135,2,,void
153409,BLOCK,-1,,"{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    if (host && !*host)
        host = NULL;

    msg_Dbg (obj, ""net: opening %s datagram port %d"",
             host ? host : ""any"", port);

    int val = vlc_getaddrinfo (host, port, &hints, &res);
    if (val)
    {
        msg_Err (obj, ""Cannot resolve %s port %d : %s"", host, port,
                 gai_strerror (val));
        return -1;
    }

    val = -1;

    for (const struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (obj, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }

#ifdef IPV6_V6ONLY
        /* Try dual-mode IPv6 if available. */
        if (ptr->ai_family == AF_INET6)
            sets...",1,,146,5,,void
153415,BLOCK,1,,<empty>,9,,148,1,,void
153419,BLOCK,2,,<empty>,9,,149,2,,void
153423,BLOCK,3,,<empty>,9,,150,3,,void
153437,BLOCK,-1,,<empty>,9,,154,2,,void
153461,BLOCK,-1,,"{
        msg_Err (obj, ""Cannot resolve %s port %d : %s"", host, port,
                 gai_strerror (val));
        return -1;
    }",5,,161,2,,void
153477,BLOCK,-1,,<empty>,5,,169,1,,void
153490,BLOCK,4,,"{
        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (obj, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }

#ifdef IPV6_V6ONLY
        /* Try dual-mode IPv6 if available. */
        if (ptr->ai_family == AF_INET6)
            setsockopt (fd, SOL_IPV6, IPV6_V6ONLY, &(int){ 0 }, sizeof (int));
#endif
        fd = net_SetupDgramSocket( obj, fd, ptr );
        if( fd == -1 )
            continue;

        if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
         && net_Subscribe (obj, fd, ptr->ai_addr, ptr->ai_addrlen))
        {
            net_Close (fd);
            continue;
        }

        val = fd;
        break;
    }",5,,170,4,,void
153510,BLOCK,-1,,"{
            msg_Dbg (obj, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }",9,,174,2,,void
153528,BLOCK,-1,,<empty>,13,,186,2,,void
153548,BLOCK,-1,,"{
            net_Close (fd);
            continue;
        }",9,,190,2,,void
153567,BLOCK,-1,,"{
    int proto, cmd;

    /* There is some confusion in the world whether IP_MULTICAST_TTL
     * takes a byte or an int as an argument.
     * BSD seems to indicate byte so we are going with that and use
     * int as a fallback to be safe */
    switch( family )
    {
#ifdef IP_MULTICAST_TTL
        case AF_INET:
            proto = SOL_IP;
            cmd = IP_MULTICAST_TTL;
            break;
#endif

#ifdef IPV6_MULTICAST_HOPS
        case AF_INET6:
            proto = SOL_IPV6;
            cmd = IPV6_MULTICAST_HOPS;
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            msg_Warn( p_this, ""%s"", vlc_strerror_c(EAFNOSUPPORT) );
            return VLC_EGENERIC;
    }

    if( setsockopt( fd, proto, cmd, &hlim, sizeof( hlim ) ) < 0 )
    {
        /* BSD compatibility */
        unsigned char buf;

        msg_Dbg( p_this, ""cannot set hop limit (%d): %s"", hlim,
                 vlc_strerror_c(net_errno) );
        buf = (unsigned char)(( hlim > 25...",1,,206,5,,void
153572,BLOCK,-1,,"{
#ifdef IP_MULTICAST_TTL
        case AF_INET:
            proto = SOL_IP;
            cmd = IP_MULTICAST_TTL;
            break;
#endif

#ifdef IPV6_MULTICAST_HOPS
        case AF_INET6:
            proto = SOL_IPV6;
            cmd = IPV6_MULTICAST_HOPS;
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            msg_Warn( p_this, ""%s"", vlc_strerror_c(EAFNOSUPPORT) );
            return VLC_EGENERIC;
    }",5,,214,2,,void
153595,BLOCK,-1,,"{
        /* BSD compatibility */
        unsigned char buf;

        msg_Dbg( p_this, ""cannot set hop limit (%d): %s"", hlim,
                 vlc_strerror_c(net_errno) );
        buf = (unsigned char)(( hlim > 255 ) ? 255 : hlim);
        if( setsockopt( fd, proto, cmd, &buf, sizeof( buf ) ) )
        {
            msg_Err( p_this, ""cannot set hop limit (%d): %s"", hlim,
                     vlc_strerror_c(net_errno) );
            return VLC_EGENERIC;
        }
    }",5,,236,2,,void
153622,BLOCK,-1,,"{
            msg_Err( p_this, ""cannot set hop limit (%d): %s"", hlim,
                     vlc_strerror_c(net_errno) );
            return VLC_EGENERIC;
        }",9,,244,2,,void
153640,BLOCK,-1,,"{
    int scope = if_nametoindex (iface);
    if (scope == 0)
    {
        msg_Err (p_this, ""invalid multicast interface: %s"", iface);
        return -1;
    }

    switch (family)
    {
#ifdef IPV6_MULTICAST_IF
        case AF_INET6:
            if (setsockopt (fd, SOL_IPV6, IPV6_MULTICAST_IF,
                            &scope, sizeof (scope)) == 0)
                return 0;
            break;
#endif

#ifdef __linux__
        case AF_INET:
        {
            struct ip_mreqn req = { .imr_ifindex = scope };
            if (setsockopt (fd, SOL_IP, IP_MULTICAST_IF,
                            &req, sizeof (req)) == 0)
                return 0;
            break;
        }
#endif
        default:
            errno = EAFNOSUPPORT;
    }
    msg_Err (p_this, ""cannot force multicast interface %s: %s"", iface,
             vlc_strerror_c(errno));
    return -1;
}",1,,257,5,,void
153650,BLOCK,-1,,"{
        msg_Err (p_this, ""invalid multicast interface: %s"", iface);
        return -1;
    }",5,,260,2,,void
153660,BLOCK,-1,,"{
#ifdef IPV6_MULTICAST_IF
        case AF_INET6:
            if (setsockopt (fd, SOL_IPV6, IPV6_MULTICAST_IF,
                            &scope, sizeof (scope)) == 0)
                return 0;
            break;
#endif

#ifdef __linux__
        case AF_INET:
        {
            struct ip_mreqn req = { .imr_ifindex = scope };
            if (setsockopt (fd, SOL_IP, IP_MULTICAST_IF,
                            &req, sizeof (req)) == 0)
                return 0;
            break;
        }
#endif
        default:
            errno = EAFNOSUPPORT;
    }",5,,266,2,,void
153678,BLOCK,-1,,"{
    char *ifname = var_InheritString (obj, ""miface"");
    if (ifname == NULL)
        return 0;

    unsigned ifindex = if_nametoindex (ifname);
    if (ifindex == 0)
        msg_Err (obj, ""invalid multicast interface: %s"", ifname);
    free (ifname);
    return ifindex;
}",1,,295,2,,void
153689,BLOCK,-1,,<empty>,9,,298,2,,void
153701,BLOCK,-1,,<empty>,9,,302,2,,void
153719,BLOCK,-1,,"{
/* MCAST_JOIN_SOURCE_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code path as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_SOURCE_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Source-Specific Multicast join */
    int level;
    struct group_source_req gsr;

    memset (&gsr, 0, sizeof (gsr));
    gsr.gsr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gsr.gsr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
            level = SOL_IP;
            break;
        default:
            errno = EAFNOSUPPORT;
            return -1;
    }

    assert (grplen <= sizeof (gsr.gsr_group));
    memcpy (&gsr.g...",1,,316,7,,void
153728,BLOCK,-1,,"{
        errno = EAFNOSUPPORT;
        return -1;
    }",5,,359,2,,void
153739,BLOCK,-1,,"{
# ifdef IP_ADD_SOURCE_MEMBERSHIP
        /* IPv4-specific API */
        case AF_INET:
        {
            struct ip_mreq_source imr;

            memset (&imr, 0, sizeof (imr));
            assert (grplen >= sizeof (struct sockaddr_in));
            imr.imr_multiaddr = ((const struct sockaddr_in *)grp)->sin_addr;
            assert (srclen >= sizeof (struct sockaddr_in));
            imr.imr_sourceaddr = ((const struct sockaddr_in *)src)->sin_addr;
            if (setsockopt (fd, SOL_IP, IP_ADD_SOURCE_MEMBERSHIP,
                            &imr, sizeof (imr)) == 0)
                return 0;
            break;
        }
# endif
        default:
            errno = EAFNOSUPPORT;
    }",5,,365,2,,void
153765,BLOCK,-1,,"{
/* MCAST_JOIN_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Any-Source Multicast join */
    int level;
    struct group_req gr;

    memset (&gr, 0, sizeof (gr));
    gr.gr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gr.gr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
            level = SOL_IP;
            break;
        default:
            errno = EAFNOSUPPORT;
            return -1;
    }

    assert (grplen <= sizeof (gr.gr_group));
    memcpy (&gr.gr_group, grp, grplen);
    if (setsockopt...",1,,397,5,,void
153770,BLOCK,-1,,"{
# ifdef IPV6_JOIN_GROUP
        case AF_INET6:
        {
            struct ipv6_mreq ipv6mr;
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            memset (&ipv6mr, 0, sizeof (ipv6mr));
            assert (grplen >= sizeof (struct sockaddr_in6));
            ipv6mr.ipv6mr_multiaddr = g6->sin6_addr;
            ipv6mr.ipv6mr_interface = g6->sin6_scope_id;
            if (!setsockopt (fd, SOL_IPV6, IPV6_JOIN_GROUP,
                             &ipv6mr, sizeof (ipv6mr)))
                return 0;
            break;
        }
# endif
# ifdef IP_ADD_MEMBERSHIP
        case AF_INET:
        {
            struct ip_mreq imr;

            memset (&imr, 0, sizeof (imr));
            assert (grplen >= sizeof (struct sockaddr_in));
            imr.imr_multiaddr = ((const struct sockaddr_in *)grp)->sin_addr;
            if (setsockopt (fd, SOL_IP, IP_ADD_MEMBERSHIP,
                            &imr, sizeof (imr)) == 0)
                return 0;
           ...",5,,437,2,,void
153788,BLOCK,-1,,"{
    struct sockaddr_storage addr;
    if( getsockname( fd, (struct sockaddr *)&addr, &(socklen_t){ sizeof (addr) }) )
        return -1;

    int level, cmd;

    switch( addr.ss_family )
    {
#ifdef IPV6_TCLASS
        case AF_INET6:
            level = SOL_IPV6;
            cmd = IPV6_TCLASS;
            break;
#endif

        case AF_INET:
            level = SOL_IP;
            cmd = IP_TOS;
            break;

        default:
#ifdef ENOPROTOOPT
            errno = ENOPROTOOPT;
#endif
            return -1;
    }

    return setsockopt( fd, level, cmd, &(int){ dscp }, sizeof (int));
}",1,,480,3,,void
153803,BLOCK,-1,,<empty>,9,,483,2,,void
153813,BLOCK,-1,,"{
#ifdef IPV6_TCLASS
        case AF_INET6:
            level = SOL_IPV6;
            cmd = IPV6_TCLASS;
            break;
#endif

        case AF_INET:
            level = SOL_IP;
            cmd = IP_TOS;
            break;

        default:
#ifdef ENOPROTOOPT
            errno = ENOPROTOOPT;
#endif
            return -1;
    }",5,,488,2,,void
153819,BLOCK,1,,<empty>,,,,1,,void
153849,BLOCK,-1,,"{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = proto,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *res;
    int       i_handle = -1;
    bool      b_unreach = false;

    if( i_hlim < 0 )
        i_hlim = var_InheritInteger( p_this, ""ttl"" );

    msg_Dbg( p_this, ""net: connecting to [%s]:%d"", psz_host, i_port );

    int val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (val)
    {
        msg_Err (p_this, ""cannot resolve [%s]:%d : %s"", psz_host, i_port,
                 gai_strerror (val));
        return -1;
    }

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        char *str;
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
            continue;

        /* Allow broadcast sending */
        setsockopt (fd, SOL_SOCKET, SO_BROADCAST, &(int){ 1 }, sizeof (int));

        if( i_hlim >= 0 )
        ...",1,,520,6,,void
153855,BLOCK,1,,<empty>,9,,522,1,,void
153859,BLOCK,2,,<empty>,9,,523,2,,void
153863,BLOCK,3,,<empty>,9,,524,3,,void
153882,BLOCK,-1,,<empty>,9,,530,2,,void
153905,BLOCK,-1,,"{
        msg_Err (p_this, ""cannot resolve [%s]:%d : %s"", psz_host, i_port,
                 gai_strerror (val));
        return -1;
    }",5,,536,2,,void
153917,BLOCK,-1,,<empty>,5,,542,1,,void
153930,BLOCK,4,,"{
        char *str;
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
            continue;

        /* Allow broadcast sending */
        setsockopt (fd, SOL_SOCKET, SO_BROADCAST, &(int){ 1 }, sizeof (int));

        if( i_hlim >= 0 )
            net_SetMcastHopLimit( p_this, fd, ptr->ai_family, i_hlim );

        str = var_InheritString (p_this, ""miface"");
        if (str != NULL)
        {
            net_SetMcastOut (p_this, fd, ptr->ai_family, str);
            free (str);
        }

        net_SetDSCP (fd, var_InheritInteger (p_this, ""dscp""));

        if( connect( fd, ptr->ai_addr, ptr->ai_addrlen ) == 0 )
        {
            /* success */
            i_handle = fd;
            break;
        }

#if defined( _WIN32 )
        if( WSAGetLastError () == WSAENETUNREACH )
#else
        if( errno == ENETUNREACH )
#endif
            b_unreach = true;
        else
            msg_Warn( p_th...",5,,543,4,,void
153951,BLOCK,-1,,<empty>,13,,548,2,,void
153968,BLOCK,-1,,<empty>,13,,554,2,,void
153985,BLOCK,-1,,"{
            net_SetMcastOut (p_this, fd, ptr->ai_family, str);
            free (str);
        }",9,,558,2,,void
154011,BLOCK,-1,,"{
            /* success */
            i_handle = fd;
            break;
        }",9,,566,2,,void
154020,BLOCK,-1,,<empty>,13,,577,2,,void
154025,BLOCK,-1,,<empty>,13,,579,1,,void
154042,BLOCK,-1,,"{
        if( b_unreach )
            msg_Err( p_this, ""Host %s port %d is unreachable"", psz_host,
                     i_port );
        return -1;
    }",5,,587,2,,void
154045,BLOCK,-1,,<empty>,13,,589,2,,void
154065,BLOCK,-1,,"{
    if ((psz_server == NULL) || (psz_server[0] == '\0'))
        return net_ListenSingle (obj, psz_bind, i_bind, protocol);

    msg_Dbg (obj, ""net: connecting to [%s]:%d from [%s]:%d"",
             psz_server, i_server, psz_bind, i_bind);

    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *loc, *rem;

    int val = vlc_getaddrinfo (psz_server, i_server, &hints, &rem);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_server, i_server,
                 gai_strerror (val));
        return -1;
    }

    hints.ai_flags |= AI_PASSIVE;
    val = vlc_getaddrinfo (psz_bind, i_bind, &hints, &loc);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_bind, i_bind,
                 gai_strerror (val));
        freeaddrinfo (rem);
        return -1;
    }

    val = -1;
    for (struct addrinfo *ptr = loc; ptr != NULL; ptr = ptr->ai_next)...",1,,605,7,,void
154076,BLOCK,-1,,<empty>,9,,607,2,,void
154096,BLOCK,1,,<empty>,9,,613,1,,void
154100,BLOCK,2,,<empty>,9,,614,2,,void
154104,BLOCK,3,,<empty>,9,,615,3,,void
154122,BLOCK,-1,,"{
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_server, i_server,
                 gai_strerror (val));
        return -1;
    }",5,,620,2,,void
154149,BLOCK,-1,,"{
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_bind, i_bind,
                 gai_strerror (val));
        freeaddrinfo (rem);
        return -1;
    }",5,,629,2,,void
154167,BLOCK,-1,,<empty>,5,,637,1,,void
154180,BLOCK,4,,"{
        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
            continue; // usually, address family not supported

        fd = net_SetupDgramSocket( obj, fd, ptr );
        if( fd == -1 )
            continue;

        for (struct addrinfo *ptr2 = rem; ptr2 != NULL; ptr2 = ptr2->ai_next)
        {
            if ((ptr2->ai_family != ptr->ai_family)
             || (ptr2->ai_socktype != ptr->ai_socktype)
             || (ptr2->ai_protocol != ptr->ai_protocol))
                continue;

            if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
              ? net_SourceSubscribe (obj, fd,
                                     ptr2->ai_addr, ptr2->ai_addrlen,
                                     ptr->ai_addr, ptr->ai_addrlen)
              : connect (fd, ptr2->ai_addr, ptr2->ai_addrlen))
            {
                msg_Err (obj, ""cannot connect to %s port %d: %s"",
                 ...",5,,638,4,,void
154200,BLOCK,-1,,<empty>,13,,642,2,,void
154213,BLOCK,-1,,<empty>,13,,646,2,,void
154216,BLOCK,-1,,<empty>,9,,648,1,,void
154229,BLOCK,4,,"{
            if ((ptr2->ai_family != ptr->ai_family)
             || (ptr2->ai_socktype != ptr->ai_socktype)
             || (ptr2->ai_protocol != ptr->ai_protocol))
                continue;

            if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
              ? net_SourceSubscribe (obj, fd,
                                     ptr2->ai_addr, ptr2->ai_addrlen,
                                     ptr->ai_addr, ptr->ai_addrlen)
              : connect (fd, ptr2->ai_addr, ptr2->ai_addrlen))
            {
                msg_Err (obj, ""cannot connect to %s port %d: %s"",
                         psz_server, i_server, vlc_strerror_c(net_errno));
                continue;
            }
            val = fd;
            break;
        }",9,,649,4,,void
154254,BLOCK,-1,,<empty>,17,,653,2,,void
154288,BLOCK,-1,,"{
                msg_Err (obj, ""cannot connect to %s port %d: %s"",
                         psz_server, i_server, vlc_strerror_c(net_errno));
                continue;
            }",13,,660,2,,void
154306,BLOCK,-1,,<empty>,13,,670,2,,void
154322,BLOCK,-1,,"{
    int type;

    if (getsockopt (fd, SOL_SOCKET, SO_TYPE,
                    &type, &(socklen_t){ sizeof (type) }))
        return VLC_EGENERIC;

    switch (type)
    {
#ifdef UDPLITE_RECV_CSCOV
        case SOCK_DGRAM: /* UDP-Lite */
            if (sendcov == -1)
                sendcov = 0;
            else
                sendcov += 8; /* partial */
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &sendcov,
                            sizeof (sendcov)))
                return VLC_EGENERIC;

            if (recvcov == -1)
                recvcov = 0;
            else
                recvcov += 8;
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_RECV_CSCOV,
                            &recvcov, sizeof (recvcov)))
                return VLC_EGENERIC;

            return VLC_SUCCESS;
#endif
#ifdef DCCP_SOCKOPT_SEND_CSCOV
        case SOCK_DCCP: /* DCCP and its ill-named socket type */
            if ((sendcov == -1) || (sendcov > 56))
                sendco...",1,,689,4,,void
154337,BLOCK,-1,,<empty>,9,,694,2,,void
154342,BLOCK,-1,,"{
#ifdef UDPLITE_RECV_CSCOV
        case SOCK_DGRAM: /* UDP-Lite */
            if (sendcov == -1)
                sendcov = 0;
            else
                sendcov += 8; /* partial */
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_SEND_CSCOV, &sendcov,
                            sizeof (sendcov)))
                return VLC_EGENERIC;

            if (recvcov == -1)
                recvcov = 0;
            else
                recvcov += 8;
            if (setsockopt (fd, SOL_UDPLITE, UDPLITE_RECV_CSCOV,
                            &recvcov, sizeof (recvcov)))
                return VLC_EGENERIC;

            return VLC_SUCCESS;
#endif
#ifdef DCCP_SOCKOPT_SEND_CSCOV
        case SOCK_DCCP: /* DCCP and its ill-named socket type */
            if ((sendcov == -1) || (sendcov > 56))
                sendcov = 0;
            else
                sendcov = (sendcov + 3) / 4;
            if (setsockopt (fd, SOL_DCCP, DCCP_SOCKOPT_SEND_CSCOV,
                            &sendcov,...",5,,697,2,,void
154365,BLOCK,-1,,<empty>,1,,1,1,,ANY
154368,BLOCK,-1,,"{
    HMODULE hmod;
    CHAR    psz_path[CCHMAXPATH + 4];

    DosQueryModFromEIP( &hmod, NULL, 0, NULL, NULL, ( ULONG )system_Init );
    DosQueryModuleName( hmod, sizeof( psz_path ), psz_path );

    /* remove the DLL name */
    char *slash = strrchr( psz_path, '\\');
    if( slash == NULL )
        abort();
    strcpy(slash + 1, PACKAGE);
    return FromLocaleDup(psz_path);
}",1,,34,2,,void
154396,BLOCK,-1,,<empty>,9,,44,2,,void
154410,BLOCK,-1,,"{
    const char *path = getenv (""VLC_DATA_PATH"");
    if (path)
        return strdup (path);

    char *datadir = config_GetLibDir();
    if (datadir)
        /* replace last lib\vlc with share */
        strcpy ( datadir + strlen (datadir) - 7, ""share"");
    return datadir;
}",1,,55,2,,void
154418,BLOCK,-1,,<empty>,9,,58,2,,void
154428,BLOCK,-1,,<empty>,9,,63,2,,void
154443,BLOCK,-1,,"{
    const char *home = getenv (""HOME"");
    if (home != NULL)
        return FromLocaleDup (home);

    return config_GetLibDir();
}",1,,68,2,,void
154453,BLOCK,-1,,<empty>,9,,71,2,,void
154463,BLOCK,-1,,"{
    switch (type)
    {
        case VLC_HOME_DIR:
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
        case VLC_CACHE_DIR:
        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
        case VLC_MUSIC_DIR:
        case VLC_PICTURES_DIR:
        case VLC_VIDEOS_DIR:
            break;
    }
    return config_GetHomeDir ();
}",1,,77,2,,void
154466,BLOCK,-1,,"{
        case VLC_HOME_DIR:
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
        case VLC_CACHE_DIR:
        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
        case VLC_MUSIC_DIR:
        case VLC_PICTURES_DIR:
        case VLC_VIDEOS_DIR:
            break;
    }",5,,79,2,,void
154534,BLOCK,-1,,<empty>,1,,1,1,,ANY
154538,BLOCK,-1,,"{
    unsigned int mode = 0;
    va_list ap;

    va_start (ap, flags);
    if (flags & O_CREAT)
        mode = va_arg (ap, unsigned int);
    va_end (ap);

    const char *local_name = ToLocaleDup (filename);

    if (local_name == NULL)
    {
        errno = ENOENT;
        return -1;
    }

    int fd = open (local_name, flags, mode);
    if (fd != -1)
        fcntl (fd, F_SETFD, FD_CLOEXEC);

    free (local_name);
    return fd;
}",1,,51,3,,void
154559,BLOCK,-1,,"{
        errno = ENOENT;
        return -1;
    }",5,,63,2,,void
154578,BLOCK,-1,,<empty>,9,,70,2,,void
154593,BLOCK,-1,,"{
    errno = ENOSYS;

    return -1;
}",1,,77,4,,void
154604,BLOCK,-1,,"{
    errno = ENOSYS;
    return -1;
}",1,,84,2,,void
154615,BLOCK,-1,,"{
    return close (fd);
}",1,,90,2,,void
154624,BLOCK,-1,,"{
    char *locname = ToLocaleDup (dirname);
    if (unlikely(locname == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int res = mkdir (locname, mode);
    free (locname);
    return res;
}",1,,95,3,,void
154635,BLOCK,-1,,"{
        errno = ENOENT;
        return -1;
    }",5,,98,2,,void
154656,BLOCK,-1,,"{
    const char *locname = ToLocaleDup (dirname);
    if (unlikely(locname == NULL))
    {
        errno = ENOENT;
        return NULL;
    }

    DIR *dir = opendir (locname);

    free (locname);

    return dir;
}",1,,109,2,,void
154667,BLOCK,-1,,"{
        errno = ENOENT;
        return NULL;
    }",5,,112,2,,void
154686,BLOCK,-1,,"{
    /* Beware that readdir_r() assumes <buf> is large enough to hold the result
     * dirent including the file name. A buffer overflow could occur otherwise.
     * In particular, pathconf() and _POSIX_NAME_MAX cannot be used here. */
    struct dirent *ent;
    char *path = NULL;

    /* In the implementation of Innotek LIBC, aka kLIBC on OS/2,
     * fpathconf (_PC_NAME_MAX) is broken, and errno is set to EBADF.
     * Moreover, d_name is not the last member of struct dirent.
     * So just allocate as many as the size of struct dirent. */
#if 1
    long len = sizeof (struct dirent);
#else
    long len = fpathconf (dirfd (dir), _PC_NAME_MAX);
    len += offsetof (struct dirent, d_name) + 1;
#endif

    struct dirent *buf = malloc (len);
    if (unlikely(buf == NULL))
        return NULL;

    int val = readdir_r (dir, buf, &ent);
    if (val != 0)
        errno = val;
    else if (ent != NULL)
        path = FromCharset ("""", ent->d_name, strlen(ent->d_name));
    free (buf);
 ...",1,,125,2,,void
154707,BLOCK,-1,,<empty>,9,,145,2,,void
154722,BLOCK,-1,,<empty>,9,,149,2,,void
154727,BLOCK,-1,,<empty>,10,,150,1,,void
154732,BLOCK,-1,,<empty>,9,,151,2,,void
154754,BLOCK,-1,,"{
    const char *local_name = ToLocaleDup (filename);
    if (unlikely(local_name == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int res = deref ? stat (local_name, buf)
                    : lstat (local_name, buf);
    free (local_name);
    return res;
}",1,,157,4,,void
154765,BLOCK,-1,,"{
        errno = ENOENT;
        return -1;
    }",5,,160,2,,void
154792,BLOCK,-1,,"{
    return vlc_statEx (filename, buf, true);
}",1,,172,3,,void
154803,BLOCK,-1,,"{
    return vlc_statEx (filename, buf, false);
}",1,,177,3,,void
154813,BLOCK,-1,,"{
    const char *local_name = ToLocaleDup (filename);
    if (unlikely(local_name == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int ret = unlink (local_name);
    free (local_name);
    return ret;
}",1,,182,2,,void
154824,BLOCK,-1,,"{
        errno = ENOENT;
        return -1;
    }",5,,185,2,,void
154845,BLOCK,-1,,"{
    const char *lo = ToLocaleDup (oldpath);
    if (lo == NULL)
        goto error;

    const char *ln = ToLocaleDup (newpath);
    if (ln == NULL)
    {
        free (lo);
error:
        errno = ENOENT;
        return -1;
    }

    int ret = rename (lo, ln);
    free (lo);
    free (ln);
    return ret;
}",1,,196,3,,void
154855,BLOCK,-1,,<empty>,9,,199,2,,void
154866,BLOCK,-1,,"{
        free (lo);
error:
        errno = ENOENT;
        return -1;
    }",5,,203,2,,void
154892,BLOCK,-1,,"{
    /* Try $PWD */
    const char *pwd = getenv (""PWD"");
    if (pwd != NULL)
    {
        struct stat s1, s2;
        /* Make sure $PWD is correct */
        if (stat (pwd, &s1) == 0 && stat (""."", &s2) == 0
         && s1.st_dev == s2.st_dev && s1.st_ino == s2.st_ino)
            return ToLocaleDup (pwd);
    }

    /* Otherwise iterate getcwd() until the buffer is big enough */
    long path_max = pathconf (""."", _PC_PATH_MAX);
    size_t size = (path_max == -1 || path_max > 4096) ? 4096 : path_max;

    for (;; size *= 2)
    {
        char *buf = malloc (size);
        if (unlikely(buf == NULL))
            break;

        if (getcwd (buf, size) != NULL)
        {
            char *ret = ToLocaleDup (buf);
            free (buf);
            return ret; /* success */
        }
        free (buf);

        if (errno != ERANGE)
            break;
    }
    return NULL;
}",1,,217,2,,void
154902,BLOCK,-1,,"{
        struct stat s1, s2;
        /* Make sure $PWD is correct */
        if (stat (pwd, &s1) == 0 && stat (""."", &s2) == 0
         && s1.st_dev == s2.st_dev && s1.st_ino == s2.st_ino)
            return ToLocaleDup (pwd);
    }",5,,221,2,,void
154935,BLOCK,-1,,<empty>,13,,226,2,,void
154960,BLOCK,-1,,<empty>,5,,233,1,,void
154964,BLOCK,4,,"{
        char *buf = malloc (size);
        if (unlikely(buf == NULL))
            break;

        if (getcwd (buf, size) != NULL)
        {
            char *ret = ToLocaleDup (buf);
            free (buf);
            return ret; /* success */
        }
        free (buf);

        if (errno != ERANGE)
            break;
    }",5,,234,4,,void
154975,BLOCK,-1,,<empty>,13,,237,2,,void
154983,BLOCK,-1,,"{
            char *ret = ToLocaleDup (buf);
            free (buf);
            return ret; /* success */
        }",9,,240,2,,void
154999,BLOCK,-1,,<empty>,13,,248,2,,void
155007,BLOCK,-1,,"{
    int newfd;

    newfd = dup (oldfd);
    if (likely(newfd != -1))
        fcntl (newfd, F_SETFD, FD_CLOEXEC);

    return newfd;
}",1,,254,2,,void
155019,BLOCK,-1,,<empty>,9,,259,2,,void
155030,BLOCK,-1,,"{
    if (vlc_socketpair (AF_LOCAL, SOCK_STREAM, 0, fds, false))
        return -1;

    shutdown (fds[0], SHUT_WR);
    shutdown (fds[1], SHUT_RD);

    setmode (fds[0], O_BINARY);
    setmode (fds[1], O_BINARY);

    return 0;
}",1,,265,2,,void
155038,BLOCK,-1,,<empty>,9,,267,2,,void
155070,BLOCK,-1,,"{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };

    return vlc_writev(fd, &iov, 1);
}",1,,279,4,,void
155075,BLOCK,1,,<empty>,26,,280,1,,void
155081,BLOCK,2,,<empty>,51,,280,2,,void
155097,BLOCK,-1,,"{
    sigset_t set, oset;

    sigemptyset(&set);
    sigaddset(&set, SIGPIPE);
    pthread_sigmask(SIG_BLOCK, &set, &oset);

    ssize_t val = writev(fd, iov, count);
    if (val < 0 && errno == EPIPE)
    {
        siginfo_t info;
        struct timespec ts = { 0, 0 };

        while (sigtimedwait(&set, &info, &ts) >= 0 || errno != EAGAIN);
    }

    if (!sigismember(&oset, SIGPIPE)) /* Restore the signal mask if changed */
        pthread_sigmask(SIG_SETMASK, &oset, NULL);

    return val;
}",1,,286,4,,void
155128,BLOCK,-1,,"{
        siginfo_t info;
        struct timespec ts = { 0, 0 };

        while (sigtimedwait(&set, &info, &ts) >= 0 || errno != EAGAIN);
    }",5,,295,2,,void
155156,BLOCK,-1,,<empty>,9,,303,2,,void
155169,BLOCK,-1,,"{
    fcntl(fd, F_SETFD, FD_CLOEXEC);

    if (nonblock)
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}",1,,309,3,,void
155176,BLOCK,-1,,<empty>,9,,313,2,,void
155193,BLOCK,-1,,"{
    int fd = socket(pf, type, proto);
    if (fd != -1)
        vlc_socket_setup(fd, nonblock);
    return fd;
}",1,,317,5,,void
155206,BLOCK,-1,,<empty>,9,,320,2,,void
155220,BLOCK,-1,,"{
    if (socketpair(pf, type, proto, fds))
        return -1;

    vlc_socket_setup(fds[0], nonblock);
    vlc_socket_setup(fds[1], nonblock);
    return 0;
}",1,,325,6,,void
155227,BLOCK,-1,,<empty>,9,,327,2,,void
155250,BLOCK,-1,,"{
    do
    {
        int fd = accept (lfd, addr, alen);
        if (fd != -1)
        {
            fcntl (fd, F_SETFD, FD_CLOEXEC);
            if (nonblock)
                fcntl (fd, F_SETFL, fcntl (fd, F_GETFL, 0) | O_NONBLOCK);
            return fd;
        }
    }
    while (errno == EINTR);

    return -1;
}",1,,335,5,,void
155252,BLOCK,-1,,"{
        int fd = accept (lfd, addr, alen);
        if (fd != -1)
        {
            fcntl (fd, F_SETFD, FD_CLOEXEC);
            if (nonblock)
                fcntl (fd, F_SETFL, fcntl (fd, F_GETFL, 0) | O_NONBLOCK);
            return fd;
        }
    }",5,,337,1,,void
155265,BLOCK,-1,,"{
            fcntl (fd, F_SETFD, FD_CLOEXEC);
            if (nonblock)
                fcntl (fd, F_SETFL, fcntl (fd, F_GETFL, 0) | O_NONBLOCK);
            return fd;
        }",9,,340,2,,void
155272,BLOCK,-1,,<empty>,17,,343,2,,void
155304,BLOCK,-1,,<empty>,1,,1,1,,ANY
155313,BLOCK,-1,,"{
    if (((size_t)salen < sizeof (struct sockaddr_in))
     || (sa->sa_family != AF_INET))
        return EAI_FAMILY;
    else if (flags & (~_NI_MASK))
        return EAI_BADFLAGS;
    else
    {
        const struct sockaddr_in *addr;

        addr = (const struct sockaddr_in *)sa;

        if (host != NULL)
        {
            /* host name resolution */
            if (!(flags & NI_NUMERICHOST))
            {
                if (flags & NI_NAMEREQD)
                    return EAI_NONAME;
            }

            /* inet_ntoa() is not thread-safe, do not use it */
            uint32_t ipv4 = ntohl (addr->sin_addr.s_addr);

            if (snprintf (host, hostlen, ""%u.%u.%u.%u"", ipv4 >> 24,
                          (ipv4 >> 16) & 0xff, (ipv4 >> 8) & 0xff,
                          ipv4 & 0xff) >= (int)hostlen)
                return EAI_OVERFLOW;
        }

        if (serv != NULL)
        {
            if (snprintf (serv, servlen, ""%u"",
                          (unsigned in...",1,,49,8,,void
155327,BLOCK,-1,,<empty>,9,,52,2,,void
155331,BLOCK,-1,,<empty>,10,,53,1,,void
155337,BLOCK,1,,<empty>,,,,1,,void
155347,BLOCK,-1,,<empty>,9,,54,2,,void
155351,BLOCK,-1,,"{
        const struct sockaddr_in *addr;

        addr = (const struct sockaddr_in *)sa;

        if (host != NULL)
        {
            /* host name resolution */
            if (!(flags & NI_NUMERICHOST))
            {
                if (flags & NI_NAMEREQD)
                    return EAI_NONAME;
            }

            /* inet_ntoa() is not thread-safe, do not use it */
            uint32_t ipv4 = ntohl (addr->sin_addr.s_addr);

            if (snprintf (host, hostlen, ""%u.%u.%u.%u"", ipv4 >> 24,
                          (ipv4 >> 16) & 0xff, (ipv4 >> 8) & 0xff,
                          ipv4 & 0xff) >= (int)hostlen)
                return EAI_OVERFLOW;
        }

        if (serv != NULL)
        {
            if (snprintf (serv, servlen, ""%u"",
                          (unsigned int)ntohs (addr->sin_port)) >= (int)servlen)
                return EAI_OVERFLOW;
        }
    }",5,,56,1,,void
155362,BLOCK,-1,,"{
            /* host name resolution */
            if (!(flags & NI_NUMERICHOST))
            {
                if (flags & NI_NAMEREQD)
                    return EAI_NONAME;
            }

            /* inet_ntoa() is not thread-safe, do not use it */
            uint32_t ipv4 = ntohl (addr->sin_addr.s_addr);

            if (snprintf (host, hostlen, ""%u.%u.%u.%u"", ipv4 >> 24,
                          (ipv4 >> 16) & 0xff, (ipv4 >> 8) & 0xff,
                          ipv4 & 0xff) >= (int)hostlen)
                return EAI_OVERFLOW;
        }",9,,62,2,,void
155368,BLOCK,-1,,"{
                if (flags & NI_NAMEREQD)
                    return EAI_NONAME;
            }",13,,65,2,,void
155373,BLOCK,-1,,<empty>,21,,67,2,,void
155410,BLOCK,-1,,<empty>,17,,76,2,,void
155417,BLOCK,-1,,"{
            if (snprintf (serv, servlen, ""%u"",
                          (unsigned int)ntohs (addr->sin_port)) >= (int)servlen)
                return EAI_OVERFLOW;
        }",9,,80,2,,void
155433,BLOCK,-1,,<empty>,17,,83,2,,void
155442,BLOCK,-1,,"{
    switch (h_errno)
    {
        case HOST_NOT_FOUND:
            return EAI_NONAME;

        case NO_ADDRESS:
# if (NO_ADDRESS != NO_DATA)
        case NO_DATA:
# endif
            return EAI_NODATA;

        case NO_RECOVERY:
            return EAI_FAIL;

        case TRY_AGAIN:
            return EAI_AGAIN;
    }
    return EAI_SYSTEM;
}",1,,96,2,,void
155445,BLOCK,-1,,"{
        case HOST_NOT_FOUND:
            return EAI_NONAME;

        case NO_ADDRESS:
# if (NO_ADDRESS != NO_DATA)
        case NO_DATA:
# endif
            return EAI_NODATA;

        case NO_RECOVERY:
            return EAI_FAIL;

        case TRY_AGAIN:
            return EAI_AGAIN;
    }",5,,98,2,,void
155473,BLOCK,-1,,"{
    struct addrinfo *res;

    res = (struct addrinfo *)malloc (sizeof (struct addrinfo));
    if (res != NULL)
    {
        res->ai_flags = 0;
        res->ai_family = af;
        res->ai_socktype = type;
        res->ai_protocol = proto;
        res->ai_addrlen = addrlen;
        res->ai_addr = malloc (addrlen);
        res->ai_canonname = NULL;
        res->ai_next = NULL;

        if (res->ai_addr != NULL)
        {
            memcpy (res->ai_addr, addr, addrlen);

            if (canonname != NULL)
            {
                res->ai_canonname = strdup (canonname);
                if (res->ai_canonname != NULL)
                    return res; /* success ! */
            }
            else
                return res;
        }
    }
    /* failsafe */
    freeaddrinfo (res);
    return NULL;
}",1,,124,7,,void
155486,BLOCK,-1,,"{
        res->ai_flags = 0;
        res->ai_family = af;
        res->ai_socktype = type;
        res->ai_protocol = proto;
        res->ai_addrlen = addrlen;
        res->ai_addr = malloc (addrlen);
        res->ai_canonname = NULL;
        res->ai_next = NULL;

        if (res->ai_addr != NULL)
        {
            memcpy (res->ai_addr, addr, addrlen);

            if (canonname != NULL)
            {
                res->ai_canonname = strdup (canonname);
                if (res->ai_canonname != NULL)
                    return res; /* success ! */
            }
            else
                return res;
        }
    }",5,,129,2,,void
155534,BLOCK,-1,,"{
            memcpy (res->ai_addr, addr, addrlen);

            if (canonname != NULL)
            {
                res->ai_canonname = strdup (canonname);
                if (res->ai_canonname != NULL)
                    return res; /* success ! */
            }
            else
                return res;
        }",9,,140,2,,void
155545,BLOCK,-1,,"{
                res->ai_canonname = strdup (canonname);
                if (res->ai_canonname != NULL)
                    return res; /* success ! */
            }",13,,144,2,,void
155558,BLOCK,-1,,<empty>,21,,147,2,,void
155562,BLOCK,-1,,<empty>,17,,150,1,,void
155577,BLOCK,-1,,"{
    struct sockaddr_in addr;

    memset (&addr, 0, sizeof (addr));
    addr.sin_family = AF_INET;
# ifdef HAVE_SA_LEN
    addr.sin_len = sizeof (addr);
# endif
    addr.sin_port = port;
    addr.sin_addr.s_addr = ip;

    return makeaddrinfo (AF_INET, type, proto,
                         (struct sockaddr*)&addr, sizeof (addr), name);
}",1,,160,6,,void
155621,BLOCK,-1,,"{
    struct addrinfo *info;
    u_long ip;
    u_short port;
    int protocol = 0, flags = 0;
    const char *name = NULL;

    if (hints != NULL)
    {
        flags = hints->ai_flags;

        if (flags & ~_AI_MASK)
            return EAI_BADFLAGS;
        /* only accept AF_INET and AF_UNSPEC */
        if (hints->ai_family && (hints->ai_family != AF_INET))
            return EAI_FAMILY;

        /* protocol sanity check */
        switch (hints->ai_socktype)
        {
            case SOCK_STREAM:
                protocol = IPPROTO_TCP;
                break;

            case SOCK_DGRAM:
                protocol = IPPROTO_UDP;
                break;

#ifdef SOCK_RAW
            case SOCK_RAW:
#endif
            case 0:
                break;

            default:
                return EAI_SOCKTYPE;
        }
        if (hints->ai_protocol && protocol
         && (protocol != hints->ai_protocol))
            return EAI_SERVICE;
    }

    *res = NULL;

    /* default values */
...",1,,187,5,,void
155641,BLOCK,-1,,"{
        flags = hints->ai_flags;

        if (flags & ~_AI_MASK)
            return EAI_BADFLAGS;
        /* only accept AF_INET and AF_UNSPEC */
        if (hints->ai_family && (hints->ai_family != AF_INET))
            return EAI_FAMILY;

        /* protocol sanity check */
        switch (hints->ai_socktype)
        {
            case SOCK_STREAM:
                protocol = IPPROTO_TCP;
                break;

            case SOCK_DGRAM:
                protocol = IPPROTO_UDP;
                break;

#ifdef SOCK_RAW
            case SOCK_RAW:
#endif
            case 0:
                break;

            default:
                return EAI_SOCKTYPE;
        }
        if (hints->ai_protocol && protocol
         && (protocol != hints->ai_protocol))
            return EAI_SERVICE;
    }",5,,195,2,,void
155652,BLOCK,1,,<empty>,,,,1,,void
155658,BLOCK,-1,,<empty>,13,,199,2,,void
155671,BLOCK,-1,,<empty>,13,,202,2,,void
155678,BLOCK,-1,,"{
            case SOCK_STREAM:
                protocol = IPPROTO_TCP;
                break;

            case SOCK_DGRAM:
                protocol = IPPROTO_UDP;
                break;

#ifdef SOCK_RAW
            case SOCK_RAW:
#endif
            case 0:
                break;

            default:
                return EAI_SOCKTYPE;
        }",9,,206,2,,void
155709,BLOCK,-1,,<empty>,13,,226,2,,void
155720,BLOCK,-1,,"{
        if (flags & AI_PASSIVE)
            ip = htonl (INADDR_ANY);
        else
            ip = htonl (INADDR_LOOPBACK);
    }",5,,233,2,,void
155725,BLOCK,-1,,<empty>,13,,235,2,,void
155731,BLOCK,-1,,<empty>,13,,237,1,,void
155737,BLOCK,-1,,<empty>,5,,240,1,,void
155745,BLOCK,-1,,"{
        struct hostent *entry = NULL;

        /* hostname resolution */
        if (!(flags & AI_NUMERICHOST))
            entry = gethostbyname (node);

        if (entry == NULL)
            return gai_error_from_herrno ();

        if ((entry->h_length != 4) || (entry->h_addrtype != AF_INET))
            return EAI_FAMILY;

        ip = *((u_long *) entry->h_addr);
        if (flags & AI_CANONNAME)
            name = entry->h_name;
    }",5,,241,2,,void
155755,BLOCK,-1,,<empty>,13,,246,2,,void
155764,BLOCK,-1,,<empty>,13,,249,2,,void
155779,BLOCK,-1,,<empty>,13,,252,2,,void
155794,BLOCK,-1,,<empty>,13,,256,2,,void
155808,BLOCK,-1,,<empty>,9,,260,2,,void
155816,BLOCK,-1,,<empty>,9,,264,2,,void
155821,BLOCK,-1,,"{
        unsigned long d;
        char *end;

        d = strtoul (service, &end, 0);
        if (end[0] || (d > 65535u))
            return EAI_SERVICE;

        port = htons ((u_short)d);
    }",5,,266,1,,void
155839,BLOCK,-1,,<empty>,13,,272,2,,void
155855,BLOCK,-1,,"{
        info = makeipv4info (SOCK_DGRAM, IPPROTO_UDP, ip, port, name);
        if (info == NULL)
        {
            errno = ENOMEM;
            return EAI_SYSTEM;
        }
        if (flags & AI_PASSIVE)
            info->ai_flags |= AI_PASSIVE;
        *res = info;
    }",5,,279,2,,void
155868,BLOCK,-1,,"{
            errno = ENOMEM;
            return EAI_SYSTEM;
        }",9,,282,2,,void
155878,BLOCK,-1,,<empty>,13,,287,2,,void
155895,BLOCK,-1,,"{
        info = makeipv4info (SOCK_STREAM, IPPROTO_TCP, ip, port, name);
        if (info == NULL)
        {
            errno = ENOMEM;
            return EAI_SYSTEM;
        }
        info->ai_next = *res;
        if (flags & AI_PASSIVE)
            info->ai_flags |= AI_PASSIVE;
        *res = info;
    }",5,,291,2,,void
155908,BLOCK,-1,,"{
            errno = ENOMEM;
            return EAI_SYSTEM;
        }",9,,294,2,,void
155924,BLOCK,-1,,<empty>,13,,300,2,,void
155948,BLOCK,-1,,<empty>,1,,1,1,,ANY
155951,BLOCK,-1,,"{
    VLC_UNUSED(url);

    return NULL;
}",1,,34,2,,void
155976,BLOCK,-1,,<empty>,1,,1,1,,ANY
155982,BLOCK,-1,,"{
    const int flags = lazy ? RTLD_LAZY : RTLD_NOW;
    char *path = ToLocaleDup( psz_file );

    module_handle_t handle = dlopen( path, flags );
    if( handle == NULL )
    {
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", path, dlerror() );
        free( path );
        return -1;
    }
    free( path );
    *p_handle = handle;
    return 0;
}",1,,52,5,,void
156005,BLOCK,-1,,"{
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", path, dlerror() );
        free( path );
        return -1;
    }",5,,58,2,,void
156028,BLOCK,-1,,"{
    dlclose( handle );
}",1,,78,2,,void
156036,BLOCK,-1,,"{
    char buf[strlen(psz_function) + 2];
    buf[0] = '_';
    strcpy(buf + 1, psz_function);
    return dlsym( handle, buf );
}",1,,94,3,,void
156064,BLOCK,-1,,<empty>,1,,1,1,,ANY
156068,BLOCK,-1,,"{
    QWORD qwTime;
    uint8_t *p_buf = (uint8_t *)buf;

    while (len > 0)
    {
        DosTmrQueryTime( &qwTime );

        *p_buf++ = ( uint8_t )( qwTime.ulLo * rand());
        len--;
    }
}",1,,29,3,,void
156080,BLOCK,-1,,"{
        DosTmrQueryTime( &qwTime );

        *p_buf++ = ( uint8_t )( qwTime.ulLo * rand());
        len--;
    }",5,,34,2,,void
156120,BLOCK,-1,,<empty>,1,,1,1,,ANY
156138,BLOCK,-1,,"{
    libvlc_int_t *libvlc = arg;

    ULONG  ulCmd;
    int    i_argc;
    char **ppsz_argv;
    size_t i_len;
    ULONG  cbActual;
    int    i_options;

    /* Add files to the playlist */
    playlist_t *p_playlist;

    do
    {
        DosConnectNPipe( hpipeIPC );

        /* Read command */
        DosRead( hpipeIPC, &ulCmd, sizeof( ulCmd ), &cbActual );
        if( ulCmd == IPC_CMD_QUIT )
            continue;

        /* Read a count of arguments */
        DosRead( hpipeIPC, &i_argc, sizeof( i_argc ), &cbActual );

        ppsz_argv = vlc_alloc( i_argc, sizeof( *ppsz_argv ));

        for( int i_opt = 0; i_opt < i_argc; i_opt++ )
        {
            /* Read a length of argv */
            DosRead( hpipeIPC, &i_len, sizeof( i_len ), &cbActual );

            ppsz_argv[ i_opt ] = malloc( i_len );

            /* Read argv */
            DosRead( hpipeIPC, ppsz_argv[ i_opt ], i_len, &cbActual );
        }

        p_playlist = libvlc_priv(libvlc)->playlist;

        for( in...",1,,48,2,,void
156151,BLOCK,-1,,"{
        DosConnectNPipe( hpipeIPC );

        /* Read command */
        DosRead( hpipeIPC, &ulCmd, sizeof( ulCmd ), &cbActual );
        if( ulCmd == IPC_CMD_QUIT )
            continue;

        /* Read a count of arguments */
        DosRead( hpipeIPC, &i_argc, sizeof( i_argc ), &cbActual );

        ppsz_argv = vlc_alloc( i_argc, sizeof( *ppsz_argv ));

        for( int i_opt = 0; i_opt < i_argc; i_opt++ )
        {
            /* Read a length of argv */
            DosRead( hpipeIPC, &i_len, sizeof( i_len ), &cbActual );

            ppsz_argv[ i_opt ] = malloc( i_len );

            /* Read argv */
            DosRead( hpipeIPC, ppsz_argv[ i_opt ], i_len, &cbActual );
        }

        p_playlist = libvlc_priv(libvlc)->playlist;

        for( int i_opt = 0; i_opt < i_argc;)
        {
            i_options = 0;

            /* Count the input options */
            while( i_opt + i_options + 1 < i_argc &&
                   *ppsz_argv[ i_opt + i_options + 1 ] == ':' )
     ...",5,,62,1,,void
156166,BLOCK,-1,,<empty>,13,,68,2,,void
156184,BLOCK,-1,,<empty>,9,,75,1,,void
156194,BLOCK,4,,"{
            /* Read a length of argv */
            DosRead( hpipeIPC, &i_len, sizeof( i_len ), &cbActual );

            ppsz_argv[ i_opt ] = malloc( i_len );

            /* Read argv */
            DosRead( hpipeIPC, ppsz_argv[ i_opt ], i_len, &cbActual );
        }",9,,76,4,,void
156224,BLOCK,-1,,<empty>,9,,88,1,,void
156232,BLOCK,4,,"{
            i_options = 0;

            /* Count the input options */
            while( i_opt + i_options + 1 < i_argc &&
                   *ppsz_argv[ i_opt + i_options + 1 ] == ':' )
                i_options++;


            if( p_playlist )
            {
                playlist_AddExt( p_playlist, ppsz_argv[ i_opt ], NULL,
                                 i_opt == 0 && ulCmd != IPC_CMD_ENQUEUE,
                                 i_options,
                                 ( char const ** )
                                     ( i_options ? &ppsz_argv[ i_opt + 1 ] :
                                                   NULL ),
                                 VLC_INPUT_OPTION_TRUSTED,
                                 true );
            }

            for( ; i_options >= 0; i_options-- )
                free( ppsz_argv[ i_opt++ ]);
        }",9,,89,4,,void
156259,BLOCK,-1,,"{
                playlist_AddExt( p_playlist, ppsz_argv[ i_opt ], NULL,
                                 i_opt == 0 && ulCmd != IPC_CMD_ENQUEUE,
                                 i_options,
                                 ( char const ** )
                                     ( i_options ? &ppsz_argv[ i_opt + 1 ] :
                                                   NULL ),
                                 VLC_INPUT_OPTION_TRUSTED,
                                 true );
            }",13,,99,2,,void
156273,BLOCK,1,,<empty>,,,,1,,void
156290,BLOCK,-1,,<empty>,13,,110,1,,void
156310,BLOCK,1,,<empty>,,,,1,,void
156329,BLOCK,-1,,"{
    /* Set the default file-translation mode */
    _fmode_bin = 1;
    setmode( fileno( stdin ), O_BINARY ); /* Needed for pipes */
}",1,,125,2,,void
156343,BLOCK,-1,,"{
    if( var_InheritBool( p_this, ""high-priority"" ) )
    {
        if( !DosSetPriority( PRTYS_PROCESS, PRTYC_REGULAR, PRTYD_MAXIMUM, 0 ) )
        {
            msg_Dbg( p_this, ""raised process priority"" );
        }
        else
        {
            msg_Dbg( p_this, ""could not raise process priority"" );
        }
    }

    if( var_InheritBool( p_this, ""one-instance"" )
        || ( var_InheritBool( p_this, ""one-instance-when-started-from-file"" )
             && var_InheritBool( p_this, ""started-from-file"" ) ) )
    {
        HPIPE hpipe;
        ULONG ulAction;
        ULONG rc;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named pipe to check if another instance is already running */
        for(;;)
        {
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYREADWRITE |
                          OPEN_FLAGS_FAIL_ON_ERR...",1,,132,4,,void
156348,BLOCK,-1,,"{
        if( !DosSetPriority( PRTYS_PROCESS, PRTYC_REGULAR, PRTYD_MAXIMUM, 0 ) )
        {
            msg_Dbg( p_this, ""raised process priority"" );
        }
        else
        {
            msg_Dbg( p_this, ""could not raise process priority"" );
        }
    }",5,,134,2,,void
156356,BLOCK,-1,,"{
            msg_Dbg( p_this, ""raised process priority"" );
        }",9,,136,2,,void
156361,BLOCK,-1,,"{
            msg_Dbg( p_this, ""could not raise process priority"" );
        }",9,,140,1,,void
156377,BLOCK,-1,,"{
        HPIPE hpipe;
        ULONG ulAction;
        ULONG rc;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named pipe to check if another instance is already running */
        for(;;)
        {
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYREADWRITE |
                          OPEN_FLAGS_FAIL_ON_ERROR,
                          NULL );

            if( rc == ERROR_PIPE_BUSY )
                DosWaitNPipe( VLC_IPC_PIPE, -1 );
            else
                break;
        }

        if( rc )
        {
            rc = DosCreateNPipe( VLC_IPC_PIPE,  &hpipeIPC,
                                 NP_ACCESS_DUPLEX,
                                 NP_WAIT | NP_TYPE_MESSAGE |
                                 NP_READMODE_MESSAGE | 0x01,
                                 32768, 32768, 0 );
            if( rc )
            {...",5,,148,2,,void
156385,BLOCK,-1,,<empty>,9,,156,1,,void
156386,BLOCK,4,,"{
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYREADWRITE |
                          OPEN_FLAGS_FAIL_ON_ERROR,
                          NULL );

            if( rc == ERROR_PIPE_BUSY )
                DosWaitNPipe( VLC_IPC_PIPE, -1 );
            else
                break;
        }",9,,157,4,,void
156392,BLOCK,-1,,"{
            rc = DosCreateNPipe( VLC_IPC_PIPE,  &hpipeIPC,
                                 NP_ACCESS_DUPLEX,
                                 NP_WAIT | NP_TYPE_MESSAGE |
                                 NP_READMODE_MESSAGE | 0x01,
                                 32768, 32768, 0 );
            if( rc )
            {
                /* Failed to create a named pipe. Just ignore the option and
                 * go on as normal. */
                msg_Err( p_this, ""one instance mode DISABLED ""
                         ""(a named pipe couldn't be created)"" );
                return;
            }

            /* We are the 1st instance. */

            /* Save the tid of the first instance */
            tidIPCFirst = _gettid();

            /* Run the helper thread */
            tidIPCHelper = _beginthread( IPCHelperThread, NULL, 1024 * 1024,
                                         p_this );
            if( tidIPCHelper == -1 )
            {
                msg_Err( p_this, ""one i...",9,,171,2,,void
156396,BLOCK,-1,,"{
                /* Failed to create a named pipe. Just ignore the option and
                 * go on as normal. */
                msg_Err( p_this, ""one instance mode DISABLED ""
                         ""(a named pipe couldn't be created)"" );
                return;
            }",13,,178,2,,void
156418,BLOCK,-1,,"{
                msg_Err( p_this, ""one instance mode DISABLED ""
                         ""(IPC helper thread couldn't be created)"");

                tidIPCFirst = -1;
            }",13,,195,2,,void
156427,BLOCK,-1,,"{
            /* Another instance is running */
            ULONG ulCmd = var_InheritBool( p_this, ""playlist-enqueue"") ?
                              IPC_CMD_ENQUEUE : IPC_CMD_GO;
            ULONG cbActual;

            /* Write a command */
            DosWrite( hpipe, &ulCmd, sizeof( ulCmd ), &cbActual );

            /* We assume that the remaining parameters are filenames
             * and their input options */

            /* Write a count of arguments */
            DosWrite( hpipe, &i_argc, sizeof( i_argc ), &cbActual );

            for( int i_opt = 0; i_opt < i_argc; i_opt++ )
            {
                /* We need to resolve relative paths in this instance */
                char *mrl;
                if( strstr( ppsz_argv[ i_opt ], ""://"" ))
                    mrl = strdup( ppsz_argv[ i_opt ] );
                else
                    mrl = vlc_path2uri( ppsz_argv[ i_opt ], NULL );

                if( !mrl )
                    mrl = ( char * )ppsz_argv[ i_opt ];
...",9,,203,1,,void
156436,BLOCK,1,,<empty>,,,,1,,void
156439,BLOCK,1,,<empty>,,,,1,,void
156459,BLOCK,-1,,<empty>,13,,218,1,,void
156469,BLOCK,4,,"{
                /* We need to resolve relative paths in this instance */
                char *mrl;
                if( strstr( ppsz_argv[ i_opt ], ""://"" ))
                    mrl = strdup( ppsz_argv[ i_opt ] );
                else
                    mrl = vlc_path2uri( ppsz_argv[ i_opt ], NULL );

                if( !mrl )
                    mrl = ( char * )ppsz_argv[ i_opt ];

                size_t i_len = strlen( mrl ) + 1;

                /* Write a length of an argument */
                DosWrite( hpipe, &i_len, sizeof( i_len ), &cbActual );

                /* Write an argument */
                DosWrite( hpipe, mrl, i_len, &cbActual );

                if( mrl != ppsz_argv[ i_opt ])
                    free( mrl );
            }",13,,219,4,,void
156477,BLOCK,-1,,<empty>,21,,223,2,,void
156485,BLOCK,-1,,<empty>,21,,225,1,,void
156496,BLOCK,-1,,<empty>,21,,228,2,,void
156531,BLOCK,-1,,<empty>,21,,239,2,,void
156543,BLOCK,-1,,"{
    if( tidIPCFirst == _gettid())
    {
        HPIPE hpipe;
        ULONG ulAction;
        ULONG cbActual;
        ULONG rc;

        do
        {
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYREADWRITE |
                          OPEN_FLAGS_FAIL_ON_ERROR,
                          NULL );

            if( rc == ERROR_PIPE_BUSY )
                DosWaitNPipe( VLC_IPC_PIPE, -1 );
            else if( rc )
                DosSleep( 1 );
        } while( rc );

        /* Ask for IPCHelper to quit */
        ULONG ulCmd = IPC_CMD_QUIT;
        DosWrite( hpipe, &ulCmd, sizeof( ulCmd ), &cbActual );

        DosClose( hpipe );

        TID tid = tidIPCHelper;
        DosWaitThread( &tid, DCWW_WAIT );
    }
}",1,,256,2,,void
156548,BLOCK,-1,,"{
        HPIPE hpipe;
        ULONG ulAction;
        ULONG cbActual;
        ULONG rc;

        do
        {
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYREADWRITE |
                          OPEN_FLAGS_FAIL_ON_ERROR,
                          NULL );

            if( rc == ERROR_PIPE_BUSY )
                DosWaitNPipe( VLC_IPC_PIPE, -1 );
            else if( rc )
                DosSleep( 1 );
        } while( rc );

        /* Ask for IPCHelper to quit */
        ULONG ulCmd = IPC_CMD_QUIT;
        DosWrite( hpipe, &ulCmd, sizeof( ulCmd ), &cbActual );

        DosClose( hpipe );

        TID tid = tidIPCHelper;
        DosWaitThread( &tid, DCWW_WAIT );
    }",5,,258,2,,void
156554,BLOCK,-1,,"{
            rc = DosOpen( VLC_IPC_PIPE, &hpipe, &ulAction, 0, 0,
                          OPEN_ACTION_OPEN_IF_EXISTS,
                          OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYREADWRITE |
                          OPEN_FLAGS_FAIL_ON_ERROR,
                          NULL );

            if( rc == ERROR_PIPE_BUSY )
                DosWaitNPipe( VLC_IPC_PIPE, -1 );
            else if( rc )
                DosSleep( 1 );
        }",9,,265,1,,void
156563,BLOCK,1,,<empty>,,,,1,,void
156617,BLOCK,-1,,<empty>,1,,1,1,,ANY
156630,BLOCK,-1,,<empty>,,,,2,,<empty>
156636,BLOCK,-1,,<empty>,,,,2,,<empty>
156642,BLOCK,-1,,"{
    HMUX      hmux;
    SEMRECORD asr[ 2 ];
    ULONG     ulUser;
    int       n;
    ULONG     rc;

    struct vlc_thread *th = vlc_thread_self ();
    if( th == NULL || !th->killable )
    {
        /* Main thread - cannot be cancelled anyway
         * Alien thread - out of our control
         * Cancel disabled thread - ignore cancel
         */
        if( hev != NULLHANDLE )
            return DosWaitEventSem( hev, ulTimeout );

        return DosSleep( ulTimeout );
    }

    n = 0;
    if( hev != NULLHANDLE )
    {
        asr[ n ].hsemCur = ( HSEM )hev;
        asr[ n ].ulUser  = 0;
        n++;
    }
    asr[ n ].hsemCur = ( HSEM )th->cancel_event;
    asr[ n ].ulUser  = 0xFFFF;
    n++;

    DosCreateMuxWaitSem( NULL, &hmux, n, asr, DCMW_WAIT_ANY );
    rc = DosWaitMuxWaitSem( hmux, ulTimeout, &ulUser );
    DosCloseMuxWaitSem( hmux );
    if( rc )
        return rc;

    if( ulUser == 0xFFFF )
    {
        vlc_cancel_self( th );
        return ERROR_INTERRUPT;
    }
...",1,,73,3,,void
156661,BLOCK,-1,,"{
        /* Main thread - cannot be cancelled anyway
         * Alien thread - out of our control
         * Cancel disabled thread - ignore cancel
         */
        if( hev != NULLHANDLE )
            return DosWaitEventSem( hev, ulTimeout );

        return DosSleep( ulTimeout );
    }",5,,82,2,,void
156666,BLOCK,-1,,<empty>,13,,88,2,,void
156681,BLOCK,-1,,"{
        asr[ n ].hsemCur = ( HSEM )hev;
        asr[ n ].ulUser  = 0;
        n++;
    }",5,,95,2,,void
156738,BLOCK,-1,,<empty>,9,,108,2,,void
156745,BLOCK,-1,,"{
        vlc_cancel_self( th );
        return ERROR_INTERRUPT;
    }",5,,111,2,,void
156757,BLOCK,-1,,"{
    return vlc_DosWaitEventSemEx( hev, ulTimeout );
}",1,,120,3,,void
156766,BLOCK,-1,,"{
    ULONG rc = vlc_DosWaitEventSemEx( NULLHANDLE, ulTimeout );

    return ( rc != ERROR_TIMEOUT ) ? rc : 0;
}",1,,125,2,,void
156787,BLOCK,-1,,<empty>,,,,2,,<empty>
156792,BLOCK,-1,,<empty>,,,,2,,<empty>
156797,BLOCK,-1,,<empty>,,,,2,,<empty>
156804,BLOCK,-1,,"{
    /* This creates a recursive mutex. This is OK as fast mutexes have
     * no defined behavior in case of recursive locking. */
    DosCreateMutexSem( NULL, &p_mutex->hmtx, 0, FALSE );
    p_mutex->dynamic = true;
}",1,,177,2,,void
156822,BLOCK,-1,,"{
    DosCreateMutexSem( NULL, &p_mutex->hmtx, 0, FALSE );
    p_mutex->dynamic = true;
}",1,,185,2,,void
156840,BLOCK,-1,,"{
    assert (p_mutex->dynamic);
    DosCloseMutexSem( p_mutex->hmtx );
}",1,,192,2,,void
156853,BLOCK,-1,,"{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int canc = vlc_savecancel ();
        assert (p_mutex != &super_mutex); /* this one cannot be static */

        vlc_mutex_lock (&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            vlc_cond_wait (&super_variable, &super_mutex);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        vlc_mutex_unlock (&super_mutex);
        vlc_restorecancel (canc);
        return;
    }

    DosRequestMutexSem(p_mutex->hmtx, SEM_INDEFINITE_WAIT);
}",1,,198,2,,void
156859,BLOCK,-1,,"{   /* static mutexes */
        int canc = vlc_savecancel ();
        assert (p_mutex != &super_mutex); /* this one cannot be static */

        vlc_mutex_lock (&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            vlc_cond_wait (&super_variable, &super_mutex);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        vlc_mutex_unlock (&super_mutex);
        vlc_restorecancel (canc);
        return;
    }",5,,200,2,,void
156876,BLOCK,-1,,"{
            p_mutex->contention++;
            vlc_cond_wait (&super_variable, &super_mutex);
            p_mutex->contention--;
        }",9,,206,2,,void
156910,BLOCK,-1,,"{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int ret = EBUSY;

        assert (p_mutex != &super_mutex); /* this one cannot be static */
        vlc_mutex_lock (&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        vlc_mutex_unlock (&super_mutex);
        return ret;
    }

    return DosRequestMutexSem( p_mutex->hmtx, 0 ) ? EBUSY : 0;
}",1,,221,2,,void
156916,BLOCK,-1,,"{   /* static mutexes */
        int ret = EBUSY;

        assert (p_mutex != &super_mutex); /* this one cannot be static */
        vlc_mutex_lock (&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        vlc_mutex_unlock (&super_mutex);
        return ret;
    }",5,,223,2,,void
156934,BLOCK,-1,,"{
            p_mutex->locked = true;
            ret = 0;
        }",9,,229,2,,void
156961,BLOCK,-1,,"{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        assert (p_mutex != &super_mutex); /* this one cannot be static */

        vlc_mutex_lock (&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            vlc_cond_broadcast (&super_variable);
        vlc_mutex_unlock (&super_mutex);
        return;
    }

    DosReleaseMutexSem( p_mutex->hmtx );
}",1,,241,2,,void
156967,BLOCK,-1,,"{   /* static mutexes */
        assert (p_mutex != &super_mutex); /* this one cannot be static */

        vlc_mutex_lock (&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            vlc_cond_broadcast (&super_variable);
        vlc_mutex_unlock (&super_mutex);
        return;
    }",5,,243,2,,void
156989,BLOCK,-1,,<empty>,13,,250,2,,void
157014,BLOCK,-1,,"{
    vlc_mutex_lock (&super_mutex);

    if (p_condvar->hev == NULLHANDLE)
    {
        vlc_cond_init (p_condvar);

        vlc_static_cond_t *new_static_condvar;

        new_static_condvar = malloc (sizeof (*new_static_condvar));
        if (unlikely (!new_static_condvar))
            abort();

        memcpy (&new_static_condvar->condvar, p_condvar, sizeof (*p_condvar));
        new_static_condvar->next = static_condvar_start;
        static_condvar_start = new_static_condvar;
    }

    vlc_mutex_unlock (&super_mutex);
}",1,,270,2,,void
157024,BLOCK,-1,,"{
        vlc_cond_init (p_condvar);

        vlc_static_cond_t *new_static_condvar;

        new_static_condvar = malloc (sizeof (*new_static_condvar));
        if (unlikely (!new_static_condvar))
            abort();

        memcpy (&new_static_condvar->condvar, p_condvar, sizeof (*p_condvar));
        new_static_condvar->next = static_condvar_start;
        static_condvar_start = new_static_condvar;
    }",5,,274,2,,void
157038,BLOCK,-1,,<empty>,13,,281,2,,void
157064,BLOCK,-1,,"{
    vlc_static_cond_t *static_condvar;
    vlc_static_cond_t *static_condvar_next;


    for (static_condvar = static_condvar_start; static_condvar;
         static_condvar = static_condvar_next)
    {
        static_condvar_next = static_condvar->next;

        vlc_cond_destroy (&static_condvar->condvar);
        free (static_condvar);
    }
}",1,,292,2,,void
157068,BLOCK,-1,,<empty>,5,,297,1,,void
157076,BLOCK,4,,"{
        static_condvar_next = static_condvar->next;

        vlc_cond_destroy (&static_condvar->condvar);
        free (static_condvar);
    }",5,,299,4,,void
157093,BLOCK,-1,,"{
    if (DosCreateEventSem (NULL, &p_condvar->hev, 0, FALSE) ||
        DosCreateEventSem (NULL, &p_condvar->hevAck, 0, FALSE))
        abort();

    p_condvar->waiters = 0;
    p_condvar->signaled = 0;
}",1,,308,2,,void
157112,BLOCK,-1,,<empty>,9,,311,2,,void
157128,BLOCK,-1,,"{
    vlc_cond_init (p_condvar);
}",1,,318,2,,void
157135,BLOCK,-1,,"{
    DosCloseEventSem( p_condvar->hev );
    DosCloseEventSem( p_condvar->hevAck );
}",1,,323,2,,void
157148,BLOCK,-1,,"{
    if (p_condvar->hev == NULLHANDLE)
        vlc_static_cond_init (p_condvar);

    if (!__atomic_cmpxchg32 (&p_condvar->waiters, 0, 0))
    {
        ULONG ulPost;

        __atomic_xchg (&p_condvar->signaled, 1);
        DosPostEventSem (p_condvar->hev);

        DosWaitEventSem (p_condvar->hevAck, SEM_INDEFINITE_WAIT);
        DosResetEventSem (p_condvar->hevAck, &ulPost);
    }
}",1,,329,2,,void
157155,BLOCK,-1,,<empty>,9,,331,2,,void
157167,BLOCK,-1,,"{
        ULONG ulPost;

        __atomic_xchg (&p_condvar->signaled, 1);
        DosPostEventSem (p_condvar->hev);

        DosWaitEventSem (p_condvar->hevAck, SEM_INDEFINITE_WAIT);
        DosResetEventSem (p_condvar->hevAck, &ulPost);
    }",5,,334,2,,void
157194,BLOCK,-1,,"{
    if (p_condvar->hev == NULLHANDLE)
        vlc_static_cond_init (p_condvar);

    while (!__atomic_cmpxchg32 (&p_condvar->waiters, 0, 0))
        vlc_cond_signal (p_condvar);
}",1,,346,2,,void
157201,BLOCK,-1,,<empty>,9,,348,2,,void
157221,BLOCK,-1,,"{
    ULONG ulPost;
    ULONG rc;

    assert(p_condvar->hev != NULLHANDLE);

    do
    {
        vlc_testcancel();

        __atomic_increment (&p_condvar->waiters);

        vlc_mutex_unlock (p_mutex);

        do
        {
            rc = vlc_WaitForSingleObject( p_condvar->hev, ulTimeout );
            if (rc == NO_ERROR)
                DosResetEventSem (p_condvar->hev, &ulPost);
        } while (rc == NO_ERROR &&
                 __atomic_cmpxchg32 (&p_condvar->signaled, 0, 1) == 0);

        __atomic_decrement (&p_condvar->waiters);

        DosPostEventSem (p_condvar->hevAck);

        vlc_mutex_lock (p_mutex);
    } while( rc == ERROR_INTERRUPT );

    return rc ? ETIMEDOUT : 0;
}",1,,356,4,,void
157231,BLOCK,-1,,"{
        vlc_testcancel();

        __atomic_increment (&p_condvar->waiters);

        vlc_mutex_unlock (p_mutex);

        do
        {
            rc = vlc_WaitForSingleObject( p_condvar->hev, ulTimeout );
            if (rc == NO_ERROR)
                DosResetEventSem (p_condvar->hev, &ulPost);
        } while (rc == NO_ERROR &&
                 __atomic_cmpxchg32 (&p_condvar->signaled, 0, 1) == 0);

        __atomic_decrement (&p_condvar->waiters);

        DosPostEventSem (p_condvar->hevAck);

        vlc_mutex_lock (p_mutex);
    }",5,,363,1,,void
157241,BLOCK,-1,,"{
            rc = vlc_WaitForSingleObject( p_condvar->hev, ulTimeout );
            if (rc == NO_ERROR)
                DosResetEventSem (p_condvar->hev, &ulPost);
        }",9,,371,1,,void
157253,BLOCK,-1,,<empty>,17,,374,2,,void
157297,BLOCK,-1,,"{
    if (p_condvar->hev == NULLHANDLE)
        vlc_static_cond_init (p_condvar);

    vlc_cond_wait_common (p_condvar, p_mutex, SEM_INDEFINITE_WAIT);
}",1,,389,3,,void
157304,BLOCK,-1,,<empty>,9,,391,2,,void
157317,BLOCK,-1,,"{
    ULONG ulTimeout;

    mtime_t total = mdate();
    total = (deadline - total) / 1000;
    if( total < 0 )
        total = 0;

    ulTimeout = ( total > 0x7fffffff ) ? 0x7fffffff : total;

    return vlc_cond_wait_common (p_condvar, p_mutex, ulTimeout);
}",1,,398,4,,void
157334,BLOCK,-1,,<empty>,9,,404,2,,void
157357,BLOCK,-1,,"{
    ULONG ulTimeout;
    mtime_t total;
    struct timeval tv;

    gettimeofday (&tv, NULL);

    total = CLOCK_FREQ * tv.tv_sec +
            CLOCK_FREQ * tv.tv_usec / 1000000L;
    total = (deadline - total) / 1000;
    if( total < 0 )
        total = 0;

    ulTimeout = ( total > 0x7fffffff ) ? 0x7fffffff : total;

    return vlc_cond_wait_common (p_condvar, p_mutex, ulTimeout);
}",1,,413,4,,void
157391,BLOCK,-1,,<empty>,9,,424,2,,void
157414,BLOCK,-1,,<empty>,,,,2,,<empty>
157428,BLOCK,-1,,"{
    ULONG rc;

    struct vlc_threadvar *var = malloc (sizeof (*var));
    if (unlikely(var == NULL))
        return errno;

    rc = DosAllocThreadLocalMemory( 1, &var->id );
    if( rc )
    {
        free (var);
        return EAGAIN;
    }

    var->destroy = destr;
    var->next = NULL;
    *p_tls = var;

    vlc_mutex_lock (&super_mutex);
    var->prev = vlc_threadvar_last;
    if (var->prev)
        var->prev->next = var;

    vlc_threadvar_last = var;
    vlc_mutex_unlock (&super_mutex);
    return 0;
}",1,,441,3,,void
157442,BLOCK,-1,,<empty>,9,,446,2,,void
157455,BLOCK,-1,,"{
        free (var);
        return EAGAIN;
    }",5,,450,2,,void
157486,BLOCK,-1,,<empty>,9,,462,2,,void
157506,BLOCK,-1,,"{
    struct vlc_threadvar *var = *p_tls;

    vlc_mutex_lock (&super_mutex);
    if (var->prev != NULL)
        var->prev->next = var->next;

    if (var->next != NULL)
        var->next->prev = var->prev;
    else
        vlc_threadvar_last = var->prev;

    vlc_mutex_unlock (&super_mutex);

    DosFreeThreadLocalMemory( var->id );
    free (var);
}",1,,470,2,,void
157521,BLOCK,-1,,<empty>,9,,475,2,,void
157537,BLOCK,-1,,<empty>,9,,478,2,,void
157548,BLOCK,-1,,<empty>,9,,480,1,,void
157568,BLOCK,-1,,"{
    *key->id = ( ULONG )value;
    return 0;
}",1,,489,3,,void
157583,BLOCK,-1,,"{
    return ( void * )*key->id;
}",1,,495,2,,void
157595,BLOCK,-1,,"{
    (void) p_libvlc;
}",1,,502,2,,void
157603,BLOCK,-1,,"{
    vlc_threadvar_t key;

retry:
    /* TODO: use RW lock or something similar */
    vlc_mutex_lock (&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get (key);
        if (value != NULL && key->destroy != NULL)
        {
            vlc_mutex_unlock (&super_mutex);
            vlc_threadvar_set (key, NULL);
            key->destroy (value);
            goto retry;
        }
    }
    vlc_mutex_unlock (&super_mutex);

    if (th->detached)
    {
        DosCloseEventSem (th->cancel_event);
        DosCloseEventSem (th->done_event );

        soclose (th->cancel_sock);

        free (th);
    }
}",1,,507,2,,void
157610,BLOCK,-1,,<empty>,5,,513,1,,void
157622,BLOCK,4,,"{
        void *value = vlc_threadvar_get (key);
        if (value != NULL && key->destroy != NULL)
        {
            vlc_mutex_unlock (&super_mutex);
            vlc_threadvar_set (key, NULL);
            key->destroy (value);
            goto retry;
        }
    }",5,,514,4,,void
157638,BLOCK,-1,,"{
            vlc_mutex_unlock (&super_mutex);
            vlc_threadvar_set (key, NULL);
            key->destroy (value);
            goto retry;
        }",9,,517,2,,void
157658,BLOCK,-1,,"{
        DosCloseEventSem (th->cancel_event);
        DosCloseEventSem (th->done_event );

        soclose (th->cancel_sock);

        free (th);
    }",5,,527,2,,void
157677,BLOCK,-1,,"{
    struct vlc_thread *th = p;

    vlc_threadvar_set (thread_key, th);
    th->killable = true;
    th->data = th->entry (th->data);
    DosPostEventSem( th->done_event );
    vlc_thread_cleanup (th);
}",1,,538,2,,void
157715,BLOCK,-1,,"{
    struct vlc_thread *th = malloc (sizeof (*th));
    if (unlikely(th == NULL))
        return ENOMEM;
    th->entry = entry;
    th->data = data;
    th->detached = detached;
    th->killable = false; /* not until vlc_entry() ! */
    th->killed = false;
    th->cleaners = NULL;

    if( DosCreateEventSem (NULL, &th->cancel_event, 0, FALSE))
        goto error;
    if( DosCreateEventSem (NULL, &th->done_event, 0, FALSE))
        goto error;

    th->cancel_sock = socket (AF_LOCAL, SOCK_STREAM, 0);
    if( th->cancel_sock < 0 )
        goto error;

    th->tid = _beginthread (vlc_entry, NULL, 1024 * 1024, th);
    if((int)th->tid == -1)
        goto error;

    if (p_handle != NULL)
        *p_handle = th;

    if (priority)
        DosSetPriority(PRTYS_THREAD,
                       HIBYTE(priority),
                       LOBYTE(priority),
                       th->tid);

    return 0;

error:
    soclose (th->cancel_sock);
    DosCloseEventSem (th->cancel_event);
    DosClose...",1,,550,6,,void
157728,BLOCK,-1,,<empty>,9,,553,2,,void
157770,BLOCK,-1,,<empty>,9,,562,2,,void
157781,BLOCK,-1,,<empty>,9,,564,2,,void
157797,BLOCK,-1,,<empty>,9,,568,2,,void
157819,BLOCK,-1,,<empty>,9,,572,2,,void
157825,BLOCK,-1,,<empty>,9,,575,2,,void
157832,BLOCK,-1,,<empty>,9,,578,2,,void
157868,BLOCK,-1,,"{
    return vlc_clone_attr (p_handle, false, entry, data, priority);
}",1,,596,5,,void
157881,BLOCK,-1,,"{
    ULONG rc;

    do
    {
        vlc_testcancel();
        rc = vlc_WaitForSingleObject( th->done_event, SEM_INDEFINITE_WAIT );
    } while( rc == ERROR_INTERRUPT );

    if (result != NULL)
        *result = th->data;

    DosCloseEventSem( th->cancel_event );
    DosCloseEventSem( th->done_event );

    soclose( th->cancel_sock );

    free( th );
}",1,,601,3,,void
157884,BLOCK,-1,,"{
        vlc_testcancel();
        rc = vlc_WaitForSingleObject( th->done_event, SEM_INDEFINITE_WAIT );
    }",5,,605,1,,void
157900,BLOCK,-1,,<empty>,9,,611,2,,void
157928,BLOCK,-1,,"{
    vlc_thread_t th;
    if (p_handle == NULL)
        p_handle = &th;

    return vlc_clone_attr (p_handle, true, entry, data, priority);
}",1,,623,5,,void
157934,BLOCK,-1,,<empty>,9,,626,2,,void
157951,BLOCK,-1,,"{
    if (DosSetPriority(PRTYS_THREAD,
                       HIBYTE(priority),
                       LOBYTE(priority),
                       th->tid))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,,632,3,,void
157962,BLOCK,-1,,<empty>,9,,637,2,,void
157971,BLOCK,-1,,"{
    return vlc_threadvar_get (thread_key);
}",1,,642,2,,void
157979,BLOCK,-1,,"{
    return _gettid();
}",1,,647,2,,void
157986,BLOCK,-1,,"{
    struct vlc_thread *th = self;

    if (likely(th != NULL))
        th->killed = true;
}",1,,655,2,,void
157996,BLOCK,-1,,<empty>,9,,659,2,,void
158006,BLOCK,-1,,"{
    DosPostEventSem( thread_id->cancel_event );
    so_cancel( thread_id->cancel_sock );
}",1,,663,2,,void
158019,BLOCK,-1,,"{
    int state;

    struct vlc_thread *th = vlc_thread_self ();
    if (th == NULL)
        return false; /* Main thread - cannot be cancelled anyway */

    state = th->killable;
    th->killable = false;
    return state;
}",1,,669,2,,void
158029,BLOCK,-1,,<empty>,9,,674,2,,void
158048,BLOCK,-1,,"{
    struct vlc_thread *th = vlc_thread_self ();
    assert (state == false || state == true);

    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    assert (!th->killable);
    th->killable = state != 0;
}",1,,682,2,,void
158065,BLOCK,-1,,<empty>,9,,687,2,,void
158083,BLOCK,-1,,"{
    struct vlc_thread *th = vlc_thread_self ();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    /* This check is needed for the case that vlc_cancel() is followed by
     * vlc_testcancel() without any cancellation point */
    if( DosWaitEventSem( th->cancel_event, 0 ) == NO_ERROR )
        vlc_cancel_self( th );

    if (th->killable && th->killed)
    {
        for (vlc_cleanup_t *p = th->cleaners; p != NULL; p = p->next)
             p->proc (p->data);

        DosPostEventSem( th->done_event );
        th->data = NULL; /* TODO: special value? */
        vlc_thread_cleanup (th);
        _endthread();
    }
}",1,,694,2,,void
158092,BLOCK,-1,,<empty>,9,,697,2,,void
158102,BLOCK,-1,,<empty>,9,,702,2,,void
158113,BLOCK,-1,,"{
        for (vlc_cleanup_t *p = th->cleaners; p != NULL; p = p->next)
             p->proc (p->data);

        DosPostEventSem( th->done_event );
        th->data = NULL; /* TODO: special value? */
        vlc_thread_cleanup (th);
        _endthread();
    }",5,,705,2,,void
158115,BLOCK,-1,,<empty>,9,,706,1,,void
158153,BLOCK,-1,,"{
    /* NOTE: This function only modifies thread-specific data, so there is no
     * need to lock anything. */
    va_list ap;

    struct vlc_thread *th = vlc_thread_self ();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    va_start (ap, cmd);
    switch (cmd)
    {
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }
    }
    va_end (ap);
}",1,,717,2,,void
158163,BLOCK,-1,,<empty>,9,,724,2,,void
158170,BLOCK,-1,,"{
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }
    }",5,,728,2,,void
158173,BLOCK,3,,"{
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }",9,,730,3,,void
158190,BLOCK,6,,"{
            th->cleaners = th->cleaners->next;
            break;
        }",9,,740,6,,void
158211,BLOCK,-1,,"{
    struct vlc_thread *th = vlc_thread_self( );

    int rc;

    if( th )
    {
        FD_SET( th->cancel_sock, rdset );

        nfds = MAX( nfds, th->cancel_sock + 1 );
    }

    rc = select( nfds, rdset, wrset, exset, timeout );

    vlc_testcancel();

    return rc;

}",1,,750,6,,void
158219,BLOCK,-1,,"{
        FD_SET( th->cancel_sock, rdset );

        nfds = MAX( nfds, th->cancel_sock + 1 );
    }",5,,756,2,,void
158251,BLOCK,-1,,<empty>,,,,4,,<empty>
158258,BLOCK,-1,,"{
    fd_set rdset, wrset, exset;

    int non_sockets = 0;

    struct timeval tv = { 0, 0 };

    int val = -1;

    FD_ZERO( &rdset );
    FD_ZERO( &wrset );
    FD_ZERO( &exset );
    for( unsigned i = 0; i < nfds; i++ )
    {
        int fd = fds[ i ].fd;
        struct stat stbuf;

        fds[ i ].revents = 0;

        if( fstat( fd, &stbuf ) == -1 ||
            (errno = 0, !S_ISSOCK( stbuf.st_mode )))
        {
            if( fd >= 0 )
            {
                /* If regular files, assume readiness for requested modes */
                fds[ i ].revents = ( !errno && S_ISREG( stbuf.st_mode ))
                                   ? ( fds[ i ].events &
                                       ( POLLIN | POLLOUT | POLLPRI ))
                                   : POLLNVAL;

                non_sockets++;
            }

            continue;
        }

        if( val < fd )
            val = fd;

        if(( unsigned )fd >= FD_SETSIZE )
        {
            errno = EINVAL;
  ...",1,,776,4,,void
158287,BLOCK,-1,,<empty>,5,,788,1,,void
158297,BLOCK,4,,"{
        int fd = fds[ i ].fd;
        struct stat stbuf;

        fds[ i ].revents = 0;

        if( fstat( fd, &stbuf ) == -1 ||
            (errno = 0, !S_ISSOCK( stbuf.st_mode )))
        {
            if( fd >= 0 )
            {
                /* If regular files, assume readiness for requested modes */
                fds[ i ].revents = ( !errno && S_ISREG( stbuf.st_mode ))
                                   ? ( fds[ i ].events &
                                       ( POLLIN | POLLOUT | POLLPRI ))
                                   : POLLNVAL;

                non_sockets++;
            }

            continue;
        }

        if( val < fd )
            val = fd;

        if(( unsigned )fd >= FD_SETSIZE )
        {
            errno = EINVAL;
            return -1;
        }

        if( fds[ i ].events & POLLIN )
            FD_SET( fd, &rdset );
        if( fds[ i ].events & POLLOUT )
            FD_SET( fd, &wrset );
        if( fds[ i ].events & POLLPRI )
          ...",5,,789,4,,void
158333,BLOCK,-1,,"{
            if( fd >= 0 )
            {
                /* If regular files, assume readiness for requested modes */
                fds[ i ].revents = ( !errno && S_ISREG( stbuf.st_mode ))
                                   ? ( fds[ i ].events &
                                       ( POLLIN | POLLOUT | POLLPRI ))
                                   : POLLNVAL;

                non_sockets++;
            }

            continue;
        }",9,,797,2,,void
158338,BLOCK,-1,,"{
                /* If regular files, assume readiness for requested modes */
                fds[ i ].revents = ( !errno && S_ISREG( stbuf.st_mode ))
                                   ? ( fds[ i ].events &
                                       ( POLLIN | POLLOUT | POLLPRI ))
                                   : POLLNVAL;

                non_sockets++;
            }",13,,799,2,,void
158372,BLOCK,-1,,<empty>,13,,813,2,,void
158382,BLOCK,-1,,"{
            errno = EINVAL;
            return -1;
        }",9,,816,2,,void
158397,BLOCK,-1,,<empty>,13,,822,2,,void
158410,BLOCK,-1,,<empty>,13,,824,2,,void
158423,BLOCK,-1,,<empty>,13,,826,2,,void
158432,BLOCK,-1,,<empty>,9,,830,2,,void
158441,BLOCK,-1,,"{
        struct timeval *ptv = NULL;

        if( timeout >= 0 )
        {
            div_t d    = div( timeout, 1000 );
            tv.tv_sec  = d.quot;
            tv.tv_usec = d.rem * 1000;

            ptv = &tv;
        }

        if (vlc_select( val + 1, &rdset, &wrset, &exset, ptv ) == -1)
            return -1;
    }",5,,834,2,,void
158450,BLOCK,-1,,"{
            div_t d    = div( timeout, 1000 );
            tv.tv_sec  = d.quot;
            tv.tv_usec = d.rem * 1000;

            ptv = &tv;
        }",9,,838,2,,void
158492,BLOCK,-1,,<empty>,13,,847,2,,void
158500,BLOCK,-1,,<empty>,5,,851,1,,void
158510,BLOCK,4,,"{
        int fd = fds[ i ].fd;

        if( fd >= 0 && fds[ i ].revents == 0 )
        {
            fds[ i ].revents = ( FD_ISSET( fd, &rdset ) ? POLLIN  : 0 )
                             | ( FD_ISSET( fd, &wrset ) ? POLLOUT : 0 )
                             | ( FD_ISSET( fd, &exset ) ? POLLPRI : 0 );
        }

        if( fds[ i ].revents != 0 )
            val++;
    }",5,,852,4,,void
158531,BLOCK,-1,,"{
            fds[ i ].revents = ( FD_ISSET( fd, &rdset ) ? POLLIN  : 0 )
                             | ( FD_ISSET( fd, &wrset ) ? POLLOUT : 0 )
                             | ( FD_ISSET( fd, &exset ) ? POLLPRI : 0 );
        }",9,,856,2,,void
158569,BLOCK,-1,,<empty>,13,,863,2,,void
158578,BLOCK,-1,,"{
    /* We don't need the real date, just the value of a high precision timer */
    QWORD counter;
    ULONG freq;
    if (DosTmrQueryTime(&counter) || DosTmrQueryFreq(&freq))
        abort();

    /* Convert to from (1/freq) to microsecond resolution */
    /* We need to split the division to avoid 63-bits overflow */
    lldiv_t d = lldiv (Q2LL(counter), freq);

    return (d.quot * 1000000) + ((d.rem * 1000000) / freq);
}",1,,873,2,,void
158589,BLOCK,-1,,<empty>,9,,878,2,,void
158597,BLOCK,1,,<empty>,,,,3,,void
158622,BLOCK,-1,,"{
    mtime_t delay;

    vlc_testcancel();
    while ((delay = (deadline - mdate())) > 0)
    {
        delay /= 1000;
        if (unlikely(delay > 0x7fffffff))
            delay = 0x7fffffff;
        vlc_Sleep (delay);
        vlc_testcancel();
    }
}",1,,889,2,,void
158633,BLOCK,-1,,"{
        delay /= 1000;
        if (unlikely(delay > 0x7fffffff))
            delay = 0x7fffffff;
        vlc_Sleep (delay);
        vlc_testcancel();
    }",5,,894,2,,void
158642,BLOCK,-1,,<empty>,13,,897,2,,void
158653,BLOCK,-1,,"{
    mwait (mdate () + delay);
}",1,,905,2,,void
158668,BLOCK,-1,,<empty>,,,,2,,<empty>
158674,BLOCK,-1,,"{
    struct vlc_timer *timer = arg;

    while (1)
    {
        ULONG count;

        DosWaitEventSem (timer->hev, SEM_INDEFINITE_WAIT);
        DosResetEventSem (timer->hev, &count);

        if (timer->quit)
            break;

        timer->func (timer->data);

        if (timer->interval)
            DosAsyncTimer (timer->interval, (HSEM)timer->hev, &timer->htimer);
    }
}",1,,922,2,,void
158681,BLOCK,-1,,"{
        ULONG count;

        DosWaitEventSem (timer->hev, SEM_INDEFINITE_WAIT);
        DosResetEventSem (timer->hev, &count);

        if (timer->quit)
            break;

        timer->func (timer->data);

        if (timer->interval)
            DosAsyncTimer (timer->interval, (HSEM)timer->hev, &timer->htimer);
    }",5,,926,2,,void
158698,BLOCK,-1,,<empty>,13,,933,2,,void
158711,BLOCK,-1,,<empty>,13,,938,2,,void
158731,BLOCK,-1,,"{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (timer == NULL)
        return ENOMEM;

    timer->func = func;
    timer->data = data;

    DosCreateEventSem (NULL, &timer->hev, DC_SEM_SHARED, FALSE);
    timer->htimer = NULLHANDLE;
    timer->interval = 0;
    timer->quit = false;
    timer->tid  = _beginthread (vlc_timer_do, NULL, 1024 * 1024, timer);

    *id = timer;
    return 0;
}",1,,943,4,,void
158743,BLOCK,-1,,<empty>,9,,947,2,,void
158800,BLOCK,-1,,"{
    if (timer->htimer != NULLHANDLE)
        DosStopTimer (timer->htimer);

    timer->quit = true;
    DosPostEventSem (timer->hev);
    DosWaitThread (&timer->tid, DCWW_WAIT);
    DosCloseEventSem (timer->hev);

    free (timer);
}",1,,963,2,,void
158807,BLOCK,-1,,<empty>,9,,965,2,,void
158840,BLOCK,-1,,"{
    if (timer->htimer != NULLHANDLE)
    {
        DosStopTimer (timer->htimer);
        timer->htimer = NULLHANDLE;
        timer->interval = 0;
    }

    if (value == 0)
        return; /* Disarm */

    if (absolute)
        value -= mdate ();
    value = (value + 999) / 1000;
    interval = (interval + 999) / 1000;

    timer->interval = interval;
    if (DosAsyncTimer (value, (HSEM)timer->hev, &timer->htimer))
        abort ();
}",1,,977,5,,void
158847,BLOCK,-1,,"{
        DosStopTimer (timer->htimer);
        timer->htimer = NULLHANDLE;
        timer->interval = 0;
    }",5,,979,2,,void
158866,BLOCK,-1,,<empty>,9,,986,2,,void
158870,BLOCK,-1,,<empty>,9,,989,2,,void
158905,BLOCK,-1,,<empty>,9,,995,2,,void
158911,BLOCK,-1,,"{
    (void)timer;
    return 0;
}",1,,999,2,,void
158921,BLOCK,-1,,"{
    ULONG numprocs = 1;

    DosQuerySysInfo(QSV_NUMPROCESSORS, QSV_NUMPROCESSORS,
                    &numprocs, sizeof(numprocs));

    return numprocs;
}",1,,1006,2,,void
158955,BLOCK,-1,,<empty>,1,,1,1,,ANY
158958,BLOCK,-1,,"{
    /* NOTE: it is assumed that the input resource exists. In practice,
     * the playlist must have been activated. This is automatic when calling
     * pl_Get(). FIXME: input resources are deleted at deactivation, this can
     * be too early. */
    playlist_private_t *sys = pl_priv(pl);
    return input_resource_HoldAout(sys->p_input_resource);
}",1,,37,2,,void
158964,BLOCK,1,,<empty>,,,,2,,void
158978,BLOCK,-1,,"{
    float volume = -1.f;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        volume = aout_VolumeGet (aout);
        vlc_object_release (aout);
    }
    return volume;
}",1,,47,2,,void
158993,BLOCK,-1,,"{
        volume = aout_VolumeGet (aout);
        vlc_object_release (aout);
    }",5,,52,2,,void
159007,BLOCK,-1,,"{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeSet (aout, vol);
        vlc_object_release (aout);
    }
    return ret;
}",1,,60,3,,void
159022,BLOCK,-1,,"{
        ret = aout_VolumeSet (aout, vol);
        vlc_object_release (aout);
    }",5,,65,2,,void
159038,BLOCK,-1,,"{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeUpdate (aout, value, volp);
        vlc_object_release (aout);
    }
    return ret;
}",1,,78,4,,void
159053,BLOCK,-1,,"{
        ret = aout_VolumeUpdate (aout, value, volp);
        vlc_object_release (aout);
    }",5,,83,2,,void
159068,BLOCK,-1,,"{
    int mute = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        mute = aout_MuteGet (aout);
        vlc_object_release (aout);
    }
    return mute;
}",1,,91,2,,void
159083,BLOCK,-1,,"{
        mute = aout_MuteGet (aout);
        vlc_object_release (aout);
    }",5,,96,2,,void
159097,BLOCK,-1,,"{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_MuteSet (aout, mute);
        vlc_object_release (aout);
    }
    return ret;
}",1,,104,3,,void
159112,BLOCK,-1,,"{
        ret = aout_MuteSet (aout, mute);
        vlc_object_release (aout);
    }",5,,109,2,,void
159128,BLOCK,-1,,"{
    audio_output_t *aout = playlist_GetAout (pl);

    aout_ChangeFilterString (VLC_OBJECT(pl), aout ? VLC_OBJECT(aout) : NULL,
                             ""audio-filter"", name, add);
    if (aout != NULL)
        vlc_object_release (aout);
}",1,,117,4,,void
159149,BLOCK,-1,,<empty>,9,,123,2,,void
159178,BLOCK,-1,,<empty>,1,,1,1,,ANY
159181,BLOCK,-1,,"{
    char newdir[strlen( psz_dir ) + 1];
    strcpy( newdir, psz_dir );
    char * psz_newdir = newdir;
    char * psz = psz_newdir;

    while( *psz )
    {
        while( *psz && *psz != DIR_SEP_CHAR) psz++;
        if( !*psz ) break;
        *psz = 0;
        if( !EMPTY_STR( psz_newdir ) )
            vlc_mkdir( psz_newdir, 0700 );
        *psz = DIR_SEP_CHAR;
        psz++;
    }
    vlc_mkdir( psz_dir, 0700 );
}",1,,42,2,,void
159197,BLOCK,-1,,"{
        while( *psz && *psz != DIR_SEP_CHAR) psz++;
        if( !*psz ) break;
        *psz = 0;
        if( !EMPTY_STR( psz_newdir ) )
            vlc_mkdir( psz_newdir, 0700 );
        *psz = DIR_SEP_CHAR;
        psz++;
    }",5,,49,2,,void
159212,BLOCK,-1,,<empty>,21,,51,2,,void
159222,BLOCK,-1,,<empty>,13,,54,2,,void
159242,BLOCK,-1,,"{
    char *psz_dir;
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);

    if( !EMPTY_STR(psz_artist) && !EMPTY_STR(psz_album) )
    {
        char *psz_album_sanitized = strdup( psz_album );
        filename_sanitize( psz_album_sanitized );
        char *psz_artist_sanitized = strdup( psz_artist );
        filename_sanitize( psz_artist_sanitized );
        if( asprintf( &psz_dir, ""%s"" DIR_SEP ""art"" DIR_SEP ""artistalbum""
                      DIR_SEP ""%s"" DIR_SEP ""%s"", psz_cachedir,
                      psz_artist_sanitized, psz_album_sanitized ) == -1 )
            psz_dir = NULL;
        free( psz_album_sanitized );
        free( psz_artist_sanitized );
    }
    else
    {
        /* If artist or album are missing, cache by art download URL.
         * If the URL is an attachment://, add the title to the cache name.
         * It will be md5 hashed to form a valid cache filename.
         * We assume that psz_arturl is always the download URL and not the
         * alr...",1,,63,5,,void
159257,BLOCK,-1,,"{
        char *psz_album_sanitized = strdup( psz_album );
        filename_sanitize( psz_album_sanitized );
        char *psz_artist_sanitized = strdup( psz_artist );
        filename_sanitize( psz_artist_sanitized );
        if( asprintf( &psz_dir, ""%s"" DIR_SEP ""art"" DIR_SEP ""artistalbum""
                      DIR_SEP ""%s"" DIR_SEP ""%s"", psz_cachedir,
                      psz_artist_sanitized, psz_album_sanitized ) == -1 )
            psz_dir = NULL;
        free( psz_album_sanitized );
        free( psz_artist_sanitized );
    }",5,,68,2,,void
159274,BLOCK,-1,,<empty>,13,,76,2,,void
159283,BLOCK,-1,,"{
        /* If artist or album are missing, cache by art download URL.
         * If the URL is an attachment://, add the title to the cache name.
         * It will be md5 hashed to form a valid cache filename.
         * We assume that psz_arturl is always the download URL and not the
         * already hashed filename.
         * (We should never need to call this function if art has already been
         * downloaded anyway).
         */
        struct md5_s md5;
        InitMD5( &md5 );
        AddMD5( &md5, psz_arturl, strlen( psz_arturl ) );
        if( !strncmp( psz_arturl, ""attachment://"", 13 ) )
            AddMD5( &md5, psz_title, strlen( psz_title ) );
        EndMD5( &md5 );
        char * psz_arturl_sanitized = psz_md5_hash( &md5 );
        if( asprintf( &psz_dir, ""%s"" DIR_SEP ""art"" DIR_SEP ""arturl"" DIR_SEP
                      ""%s"", psz_cachedir, psz_arturl_sanitized ) == -1 )
            psz_dir = NULL;
        free( psz_arturl_sanitized );
    }",5,,81,1,,void
159300,BLOCK,-1,,<empty>,13,,94,2,,void
159318,BLOCK,-1,,<empty>,13,,99,2,,void
159332,BLOCK,-1,,"{
    char* psz_path = NULL;
    const char *psz_artist;
    const char *psz_album;
    const char *psz_arturl;
    const char *psz_title;

    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
        p_item->p_meta = vlc_meta_New();
    if( !p_item->p_meta )
        goto end;

    psz_artist = vlc_meta_Get( p_item->p_meta, vlc_meta_Artist );
    psz_album = vlc_meta_Get( p_item->p_meta, vlc_meta_Album );
    psz_arturl = vlc_meta_Get( p_item->p_meta, vlc_meta_ArtworkURL );
    psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !psz_title )
        psz_title = p_item->psz_name;


    if( (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album) ) && !psz_arturl )
        goto end;

    psz_path = ArtCacheGetDirPath( psz_arturl, psz_artist, psz_album, psz_title );

end:
    vlc_mutex_unlock( &p_item->lock );
    return psz_path;
}",1,,107,2,,void
159351,BLOCK,-1,,<empty>,9,,117,2,,void
159362,BLOCK,-1,,<empty>,9,,119,2,,void
159395,BLOCK,-1,,<empty>,9,,126,2,,void
159410,BLOCK,-1,,<empty>,9,,130,2,,void
159432,BLOCK,-1,,"{
    char *psz_path = ArtCachePath( p_item );
    char *psz_ext = strdup( psz_type ? psz_type : """" );
    char *psz_filename = NULL;

    if( unlikely( !psz_path || !psz_ext ) )
        goto end;

    ArtCacheCreateDir( psz_path );
    filename_sanitize( psz_ext );

    if( asprintf( &psz_filename, ""%s"" DIR_SEP ""art%s"", psz_path, psz_ext ) < 0 )
        psz_filename = NULL;

end:
    free( psz_ext );
    free( psz_path );

    return psz_filename;
}",1,,140,3,,void
159457,BLOCK,-1,,<empty>,9,,146,2,,void
159465,BLOCK,-1,,<empty>,9,,152,2,,void
159480,BLOCK,-1,,"{
    char *psz_path = ArtCachePath( p_item );

    if( !psz_path )
        return VLC_EGENERIC;

    /* Check if file exists */
    DIR *p_dir = vlc_opendir( psz_path );
    if( !p_dir )
    {
        free( psz_path );
        return VLC_EGENERIC;
    }

    bool b_found = false;
    const char *psz_filename;
    while( !b_found && (psz_filename = vlc_readdir( p_dir )) )
    {
        if( !strncmp( psz_filename, ""art"", 3 ) )
        {
            char *psz_file;
            if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"",
                          psz_path, psz_filename ) != -1 )
            {
                char *psz_uri = vlc_path2uri( psz_file, ""file"" );
                if( psz_uri )
                {
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }
                free( psz_file );
            }

            b_found = true;
        }
    }

    /* */
    closedir( p_dir );
    free( psz_path );
    return b_found ? ...",1,,163,2,,void
159489,BLOCK,-1,,<empty>,9,,167,2,,void
159500,BLOCK,-1,,"{
        free( psz_path );
        return VLC_EGENERIC;
    }",5,,172,2,,void
159518,BLOCK,-1,,"{
        if( !strncmp( psz_filename, ""art"", 3 ) )
        {
            char *psz_file;
            if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"",
                          psz_path, psz_filename ) != -1 )
            {
                char *psz_uri = vlc_path2uri( psz_file, ""file"" );
                if( psz_uri )
                {
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }
                free( psz_file );
            }

            b_found = true;
        }
    }",5,,180,2,,void
159525,BLOCK,-1,,"{
            char *psz_file;
            if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"",
                          psz_path, psz_filename ) != -1 )
            {
                char *psz_uri = vlc_path2uri( psz_file, ""file"" );
                if( psz_uri )
                {
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }
                free( psz_file );
            }

            b_found = true;
        }",9,,182,2,,void
159529,BLOCK,-1,,"{
                char *psz_uri = vlc_path2uri( psz_file, ""file"" );
                if( psz_uri )
                {
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }
                free( psz_file );
            }",13,,186,2,,void
159538,BLOCK,-1,,"{
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }",17,,189,2,,void
159562,BLOCK,-1,,"{
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);
    char *psz_dir;
    if( asprintf( &psz_dir, ""%s"" DIR_SEP
                  ""by-iiuid"" DIR_SEP
                  ""%s"",
                  psz_cachedir, psz_uid ) == -1 )
    {
        psz_dir = NULL;
    }
    free( psz_cachedir );
    return psz_dir;
}",1,,207,2,,void
159571,BLOCK,-1,,"{
        psz_dir = NULL;
    }",5,,214,2,,void
159584,BLOCK,-1,,"{
    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"", psz_dir, psz_type ) == -1 )
    {
        psz_file = NULL;
    }
    return psz_file;
}",1,,222,3,,void
159588,BLOCK,-1,,"{
        psz_file = NULL;
    }",5,,225,2,,void
159598,BLOCK,-1,,"{
    char *uid = input_item_GetInfo( p_item, ""uid"", ""md5"" );
    if ( ! *uid )
    {
        free( uid );
        return VLC_EGENERIC;
    }

    /* we have an input item uid set */
    bool b_done = false;
    char *psz_byuiddir = GetDirByItemUIDs( uid );
    char *psz_byuidfile = GetFileByItemUID( psz_byuiddir, ""arturl"" );
    free( psz_byuiddir );
    if( psz_byuidfile )
    {
        FILE *fd = vlc_fopen( psz_byuidfile, ""rb"" );
        if ( fd )
        {
            char sz_cachefile[2049];
            /* read the cache hash url */
            if ( fgets( sz_cachefile, 2048, fd ) != NULL )
            {
                input_item_SetArtURL( p_item, sz_cachefile );
                b_done = true;
            }
            fclose( fd );
        }
        free( psz_byuidfile );
    }
    free( uid );
    if ( b_done ) return VLC_SUCCESS;

    return VLC_EGENERIC;
}",1,,232,2,,void
159610,BLOCK,-1,,"{
        free( uid );
        return VLC_EGENERIC;
    }",5,,235,2,,void
159634,BLOCK,-1,,"{
        FILE *fd = vlc_fopen( psz_byuidfile, ""rb"" );
        if ( fd )
        {
            char sz_cachefile[2049];
            /* read the cache hash url */
            if ( fgets( sz_cachefile, 2048, fd ) != NULL )
            {
                input_item_SetArtURL( p_item, sz_cachefile );
                b_done = true;
            }
            fclose( fd );
        }
        free( psz_byuidfile );
    }",5,,246,2,,void
159643,BLOCK,-1,,"{
            char sz_cachefile[2049];
            /* read the cache hash url */
            if ( fgets( sz_cachefile, 2048, fd ) != NULL )
            {
                input_item_SetArtURL( p_item, sz_cachefile );
                b_done = true;
            }
            fclose( fd );
        }",9,,249,2,,void
159652,BLOCK,-1,,"{
                input_item_SetArtURL( p_item, sz_cachefile );
                b_done = true;
            }",13,,253,2,,void
159667,BLOCK,-1,,<empty>,19,,262,2,,void
159680,BLOCK,-1,,"{
    char *psz_filename = ArtCacheName( p_item, psz_type );

    if( !psz_filename )
        return VLC_EGENERIC;

    char *psz_uri = vlc_path2uri( psz_filename, ""file"" );
    if( !psz_uri )
    {
        free( psz_filename );
        return VLC_EGENERIC;
    }

    /* Check if we already dumped it */
    struct stat s;
    if( !vlc_stat( psz_filename, &s ) )
    {
        input_item_SetArtURL( p_item, psz_uri );
        free( psz_filename );
        free( psz_uri );
        return VLC_SUCCESS;
    }

    /* Dump it otherwise */
    FILE *f = vlc_fopen( psz_filename, ""wb"" );
    if( f )
    {
        if( fwrite( data, 1, length, f ) != length )
        {
            msg_Err( obj, ""%s: %s"", psz_filename, vlc_strerror_c(errno) );
        }
        else
        {
            msg_Dbg( obj, ""album art saved to %s"", psz_filename );
            input_item_SetArtURL( p_item, psz_uri );
        }
        fclose( f );
    }
    free( psz_uri );

    /* save uid info */
    char *uid = input...",1,,270,6,,void
159690,BLOCK,-1,,<empty>,9,,274,2,,void
159702,BLOCK,-1,,"{
        free( psz_filename );
        return VLC_EGENERIC;
    }",5,,278,2,,void
159714,BLOCK,-1,,"{
        input_item_SetArtURL( p_item, psz_uri );
        free( psz_filename );
        free( psz_uri );
        return VLC_SUCCESS;
    }",5,,286,2,,void
159732,BLOCK,-1,,"{
        if( fwrite( data, 1, length, f ) != length )
        {
            msg_Err( obj, ""%s: %s"", psz_filename, vlc_strerror_c(errno) );
        }
        else
        {
            msg_Dbg( obj, ""album art saved to %s"", psz_filename );
            input_item_SetArtURL( p_item, psz_uri );
        }
        fclose( f );
    }",5,,296,2,,void
159741,BLOCK,-1,,"{
            msg_Err( obj, ""%s: %s"", psz_filename, vlc_strerror_c(errno) );
        }",9,,298,2,,void
159749,BLOCK,-1,,"{
            msg_Dbg( obj, ""album art saved to %s"", psz_filename );
            input_item_SetArtURL( p_item, psz_uri );
        }",9,,302,1,,void
159772,BLOCK,-1,,"{
        free( uid );
        goto end;
    }",5,,313,2,,void
159793,BLOCK,-1,,"{
        f = vlc_fopen( psz_byuidfile, ""wb"" );
        if ( f )
        {
            if( fputs( ""file://"", f ) < 0 || fputs( psz_filename, f ) < 0 )
                msg_Err( obj, ""Error writing %s: %s"", psz_byuidfile,
                         vlc_strerror_c(errno) );
            fclose( f );
        }
        free( psz_byuidfile );
    }",5,,324,2,,void
159801,BLOCK,-1,,"{
            if( fputs( ""file://"", f ) < 0 || fputs( psz_filename, f ) < 0 )
                msg_Err( obj, ""Error writing %s: %s"", psz_byuidfile,
                         vlc_strerror_c(errno) );
            fclose( f );
        }",9,,327,2,,void
159814,BLOCK,-1,,<empty>,17,,329,2,,void
159838,BLOCK,-1,,<empty>,1,,1,1,,ANY
159841,BLOCK,-1,,<empty>,,,,2,,<empty>
159846,BLOCK,-1,,<empty>,,,,2,,<empty>
159855,BLOCK,-1,,<empty>,,,,6,,<empty>
159872,BLOCK,-1,,<empty>,1,,1,1,,ANY
159875,BLOCK,-1,,"{
    vlc_mutex_lock( &pl_priv(pl)->lock );
}",1,,38,2,,void
159880,BLOCK,1,,<empty>,,,,2,,void
159891,BLOCK,-1,,"{
    vlc_mutex_unlock( &pl_priv(pl)->lock );
}",1,,43,2,,void
159896,BLOCK,1,,<empty>,,,,2,,void
159907,BLOCK,-1,,"{
    vlc_assert_locked( &pl_priv(pl)->lock );
}",1,,48,2,,void
159912,BLOCK,1,,<empty>,,,,2,,void
159926,BLOCK,-1,,"{
    PL_LOCK_IF( !locked );

    if( pl_priv(p_playlist)->killed )
        ;
    else
    switch( i_query )
    {
    case PLAYLIST_STOP:
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_item = NULL;
        pl_priv(p_playlist)->request.p_node = NULL;
        break;

    // Node can be null, it will keep the same. Use with care ...
    // Item null = take the first child of node
    case PLAYLIST_VIEWPLAY:
    {
        playlist_item_t *p_node = va_arg( args, playlist_item_t * );
        playlist_item_t *p_item = va_arg( args, playlist_item_t * );

        assert( locked || (p_item == NULL && p_node == NULL) );

        if ( p_node == NULL )
        {
            p_node = get_current_status_node( p_playlist );
            assert( p_node );
        }
        pl_priv(p_playlist)->request.i_skip = 0;
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_node = p_node;
        pl_priv(p_playlist)->requ...",1,,54,5,,void
159930,BLOCK,1,,<empty>,,,,2,,void
159938,BLOCK,1,,<empty>,,,,2,,void
159945,BLOCK,-1,,<empty>,9,,58,2,,void
159947,BLOCK,-1,,<empty>,5,,60,1,,void
159950,BLOCK,-1,,"{
    case PLAYLIST_STOP:
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_item = NULL;
        pl_priv(p_playlist)->request.p_node = NULL;
        break;

    // Node can be null, it will keep the same. Use with care ...
    // Item null = take the first child of node
    case PLAYLIST_VIEWPLAY:
    {
        playlist_item_t *p_node = va_arg( args, playlist_item_t * );
        playlist_item_t *p_item = va_arg( args, playlist_item_t * );

        assert( locked || (p_item == NULL && p_node == NULL) );

        if ( p_node == NULL )
        {
            p_node = get_current_status_node( p_playlist );
            assert( p_node );
        }
        pl_priv(p_playlist)->request.i_skip = 0;
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_node = p_node;
        pl_priv(p_playlist)->request.p_item = p_item;
        if( p_item && var_GetBool( p_playlist, ""random"" ) )
            pl_priv(p_playlist)-...",5,,61,2,,void
159956,BLOCK,1,,<empty>,,,,2,,void
159969,BLOCK,1,,<empty>,,,,2,,void
159982,BLOCK,1,,<empty>,,,,2,,void
159995,BLOCK,9,,"{
        playlist_item_t *p_node = va_arg( args, playlist_item_t * );
        playlist_item_t *p_item = va_arg( args, playlist_item_t * );

        assert( locked || (p_item == NULL && p_node == NULL) );

        if ( p_node == NULL )
        {
            p_node = get_current_status_node( p_playlist );
            assert( p_node );
        }
        pl_priv(p_playlist)->request.i_skip = 0;
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_node = p_node;
        pl_priv(p_playlist)->request.p_item = p_item;
        if( p_item && var_GetBool( p_playlist, ""random"" ) )
            pl_priv(p_playlist)->b_reset_currently_playing = true;
        break;
    }",5,,71,9,,void
160012,BLOCK,-1,,"{
            p_node = get_current_status_node( p_playlist );
            assert( p_node );
        }",9,,78,2,,void
160022,BLOCK,1,,<empty>,,,,2,,void
160035,BLOCK,1,,<empty>,,,,2,,void
160048,BLOCK,1,,<empty>,,,,2,,void
160061,BLOCK,1,,<empty>,,,,2,,void
160077,BLOCK,-1,,<empty>,13,,87,2,,void
160081,BLOCK,1,,<empty>,,,,2,,void
160096,BLOCK,1,,<empty>,,,,2,,void
160104,BLOCK,-1,,"{
            pl_priv(p_playlist)->request.b_request = true;
            pl_priv(p_playlist)->request.p_node = get_current_status_node( p_playlist );
            pl_priv(p_playlist)->request.p_item = get_current_status_item( p_playlist );
            pl_priv(p_playlist)->request.i_skip = 0;
        }",9,,93,2,,void
160108,BLOCK,1,,<empty>,,,,2,,void
160121,BLOCK,1,,<empty>,,,,2,,void
160135,BLOCK,1,,<empty>,,,,2,,void
160149,BLOCK,1,,<empty>,,,,2,,void
160160,BLOCK,-1,,<empty>,13,,100,1,,void
160164,BLOCK,1,,<empty>,,,,2,,void
160180,BLOCK,1,,<empty>,,,,2,,void
160188,BLOCK,-1,,"{
            pl_priv(p_playlist)->request.b_request = true;
            pl_priv(p_playlist)->request.p_node = get_current_status_node( p_playlist );
            pl_priv(p_playlist)->request.p_item = get_current_status_item( p_playlist );
            pl_priv(p_playlist)->request.i_skip = 0;
        }",9,,105,2,,void
160192,BLOCK,1,,<empty>,,,,2,,void
160205,BLOCK,1,,<empty>,,,,2,,void
160219,BLOCK,1,,<empty>,,,,2,,void
160233,BLOCK,1,,<empty>,,,,2,,void
160244,BLOCK,-1,,<empty>,9,,112,1,,void
160250,BLOCK,1,,<empty>,,,,2,,void
160259,BLOCK,-1,,<empty>,13,,113,2,,void
160263,BLOCK,1,,<empty>,,,,2,,void
160273,BLOCK,-1,,<empty>,13,,115,1,,void
160277,BLOCK,1,,<empty>,,,,2,,void
160292,BLOCK,1,,<empty>,,,,2,,void
160306,BLOCK,1,,<empty>,,,,2,,void
160318,BLOCK,1,,<empty>,,,,1,,void
160323,BLOCK,1,,<empty>,,,,2,,void
160340,BLOCK,1,,<empty>,,,,2,,void
160348,BLOCK,-1,,<empty>,13,,127,2,,void
160353,BLOCK,1,,<empty>,,,,2,,void
160369,BLOCK,1,,<empty>,,,,2,,void
160377,BLOCK,-1,,<empty>,13,,133,2,,void
160382,BLOCK,1,,<empty>,,,,2,,void
160396,BLOCK,1,,<empty>,,,,2,,void
160406,BLOCK,1,,<empty>,,,,2,,void
160417,BLOCK,-1,,"{
    va_list args;

    va_start( args, locked );
    playlist_vaControl( p_playlist, query, (bool)locked, args );
    va_end( args );
}",1,,142,4,,void
160461,BLOCK,-1,,<empty>,1,,1,1,,ANY
160464,BLOCK,-1,,<empty>,,,,2,,<empty>
160473,BLOCK,-1,,"{
    (void)psz_cmd; (void)oldval; (void)newval; (void)a;
    playlist_t *p_playlist = (playlist_t*)p_this;
    bool random = newval.b_bool;

    PL_LOCK;

    if( !random ) {
        pl_priv(p_playlist)->b_reset_currently_playing = true;
        vlc_cond_signal( &pl_priv(p_playlist)->signal );
    } else {
        /* Shuffle and sync the playlist on activation of random mode.
         * This preserves the current playing item, so that the user
         * can return to it if needed. (See #4472)
         */
        playlist_private_t *p_sys = pl_priv(p_playlist);
        playlist_item_t *p_new = p_sys->status.p_item;
        ResetCurrentlyPlaying( p_playlist, NULL );
        if( p_new )
            ResyncCurrentIndex( p_playlist, p_new );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",1,,48,6,,void
160502,BLOCK,-1,,"{
        pl_priv(p_playlist)->b_reset_currently_playing = true;
        vlc_cond_signal( &pl_priv(p_playlist)->signal );
    }",19,,55,2,,void
160506,BLOCK,1,,<empty>,,,,3,,void
160518,BLOCK,1,,<empty>,,,,3,,void
160526,BLOCK,-1,,"{
        /* Shuffle and sync the playlist on activation of random mode.
         * This preserves the current playing item, so that the user
         * can return to it if needed. (See #4472)
         */
        playlist_private_t *p_sys = pl_priv(p_playlist);
        playlist_item_t *p_new = p_sys->status.p_item;
        ResetCurrentlyPlaying( p_playlist, NULL );
        if( p_new )
            ResyncCurrentIndex( p_playlist, p_new );
    }",12,,58,1,,void
160532,BLOCK,1,,<empty>,,,,3,,void
160550,BLOCK,-1,,<empty>,13,,67,2,,void
160565,BLOCK,-1,,"{
    playlist_t *pl = (playlist_t *)obj;

    msg_Dbg( obj, ""corks count: %""PRId64"" -> %""PRId64, old.i_int, cur.i_int );
    if( !old.i_int == !cur.i_int )
        return VLC_SUCCESS; /* nothing to do */

    if( !var_InheritBool( obj, ""playlist-cork"" ) )
        return VLC_SUCCESS;

    playlist_Lock(pl);

    if( cur.i_int )
    {
        bool effective = playlist_Status(pl) == PLAYLIST_RUNNING;

        msg_Dbg(obj, ""corked (%seffective)"", effective ? """" : ""in"");
        pl_priv(pl)->cork_effective = effective;
        playlist_Control(pl, PLAYLIST_PAUSE, pl_Locked);
    }
    else
    {
        bool effective = pl_priv(pl)->cork_effective;

        msg_Dbg(obj, ""uncorked (%seffective)"", effective ? """" : ""in"");

        if (effective)
            playlist_Control(pl, PLAYLIST_RESUME, pl_Locked);
    }

    playlist_Unlock(pl);
    (void) var; (void) dummy;
    return VLC_SUCCESS;
}",1,,82,6,,void
160583,BLOCK,-1,,<empty>,9,,87,2,,void
160591,BLOCK,-1,,<empty>,9,,90,2,,void
160600,BLOCK,-1,,"{
        bool effective = playlist_Status(pl) == PLAYLIST_RUNNING;

        msg_Dbg(obj, ""corked (%seffective)"", effective ? """" : ""in"");
        pl_priv(pl)->cork_effective = effective;
        playlist_Control(pl, PLAYLIST_PAUSE, pl_Locked);
    }",5,,95,2,,void
160618,BLOCK,1,,<empty>,,,,3,,void
160631,BLOCK,-1,,"{
        bool effective = pl_priv(pl)->cork_effective;

        msg_Dbg(obj, ""uncorked (%seffective)"", effective ? """" : ""in"");

        if (effective)
            playlist_Control(pl, PLAYLIST_RESUME, pl_Locked);
    }",5,,103,1,,void
160637,BLOCK,1,,<empty>,,,,3,,void
160653,BLOCK,-1,,<empty>,13,,109,2,,void
160676,BLOCK,-1,,"{
    (void)psz_cmd; (void)oldval;(void)p;
    playlist_t *p_playlist = (playlist_t*)p_this;

    PL_LOCK;

    if( pl_priv(p_playlist)->p_input )
        var_SetFloat( pl_priv( p_playlist )->p_input, ""rate"", newval.f_float );

    PL_UNLOCK;
    return VLC_SUCCESS;
}",1,,119,6,,void
160696,BLOCK,1,,<empty>,,,,3,,void
160703,BLOCK,-1,,<empty>,9,,126,2,,void
160707,BLOCK,1,,<empty>,,,,3,,void
160729,BLOCK,-1,,"{
    playlist_t *p_playlist = (playlist_t *)obj;
    VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(newval);

    static const float rates[] = {
        1.0/64, 1.0/32, 1.0/16, 1.0/8, 1.0/4, 1.0/3, 1.0/2, 2.0/3,
        1.0/1,
        3.0/2, 2.0/1, 3.0/1, 4.0/1, 8.0/1, 16.0/1, 32.0/1, 64.0/1,
    };

    PL_LOCK;
    input_thread_t *input = pl_priv( p_playlist )->p_input;
    float current_rate = var_GetFloat( input ? VLC_OBJECT( input ) : obj, ""rate"" );
    PL_UNLOCK;

    const bool faster = !strcmp( psz_cmd, ""rate-faster"" );
    float rate = current_rate * ( faster ? 1.1f : 0.9f );

    /* find closest rate (if any) in the desired direction */
    for( size_t i = 0; i < ARRAY_SIZE( rates ); ++i )
    {
        if( ( faster && rates[i] > rate ) ||
            (!faster && rates[i] >= rate && i ) )
        {
            rate = faster ? rates[i] : rates[i-1];
            break;
        }
    }

    msg_Dbg( p_playlist, ""adjusting rate from %f to %f (%s)"",
        current_rate, r...",1,,134,6,,void
160803,BLOCK,1,,<empty>,,,,3,,void
160838,BLOCK,-1,,<empty>,5,,153,1,,void
160849,BLOCK,4,,"{
        if( ( faster && rates[i] > rate ) ||
            (!faster && rates[i] >= rate && i ) )
        {
            rate = faster ? rates[i] : rates[i-1];
            break;
        }
    }",5,,154,4,,void
160869,BLOCK,-1,,"{
            rate = faster ? rates[i] : rates[i-1];
            break;
        }",9,,157,2,,void
160905,BLOCK,-1,,"{
    playlist_t *p_playlist = (playlist_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(newval);

    PL_LOCK;

    /* Force the input to restart the video ES to force a vout recreation */
    input_thread_t *p_input = pl_priv( p_playlist )->p_input;
    if( p_input )
    {
        const double f_position = var_GetFloat( p_input, ""position"" );
        input_Control( p_input, INPUT_RESTART_ES, -VIDEO_ES );
        var_SetFloat( p_input, ""position"", f_position );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",1,,171,6,,void
160926,BLOCK,1,,<empty>,,,,3,,void
160935,BLOCK,-1,,"{
        const double f_position = var_GetFloat( p_input, ""position"" );
        input_Control( p_input, INPUT_RESTART_ES, -VIDEO_ES );
        var_SetFloat( p_input, ""position"", f_position );
    }",5,,180,2,,void
160958,BLOCK,-1,,"{
    playlist_t *p_playlist;
    playlist_private_t *p;

    /* Allocate structure */
    p = vlc_custom_create( p_parent, sizeof( *p ), ""playlist"" );
    if( !p )
        return NULL;

    p_playlist = &p->public_data;

    p->input_tree = NULL;
    p->id_tree = NULL;

    TAB_INIT( pl_priv(p_playlist)->i_sds, pl_priv(p_playlist)->pp_sds );

    VariablesInit( p_playlist );
    vlc_mutex_init( &p->lock );
    vlc_cond_init( &p->signal );
    p->killed = false;

    /* Initialise data structures */
    pl_priv(p_playlist)->i_last_playlist_id = 0;
    pl_priv(p_playlist)->p_input = NULL;

    ARRAY_INIT( p_playlist->items );
    ARRAY_INIT( p_playlist->current );

    p_playlist->i_current_index = 0;
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    pl_priv(p_playlist)->b_tree = var_InheritBool( p_parent, ""playlist-tree"" );
    pl_priv(p_playlist)->b_preparse = var_InheritBool( p_parent, ""auto-preparse"" );

    p_playlist->root.p_input = NULL;
    p_playlist->root.pp_c...",1,,198,2,,void
160972,BLOCK,-1,,<empty>,9,,205,2,,void
160994,BLOCK,1,,<empty>,,,,3,,void
161003,BLOCK,1,,<empty>,,,,3,,void
161030,BLOCK,1,,<empty>,,,,3,,void
161041,BLOCK,1,,<empty>,,,,3,,void
161065,BLOCK,1,,<empty>,,,,3,,void
161076,BLOCK,1,,<empty>,,,,3,,void
161089,BLOCK,1,,<empty>,,,,3,,void
161162,BLOCK,-1,,<empty>,9,,247,2,,void
161178,BLOCK,-1,,<empty>,9,,251,1,,void
161188,BLOCK,-1,,<empty>,9,,255,2,,void
161203,BLOCK,1,,<empty>,,,,3,,void
161216,BLOCK,1,,<empty>,,,,3,,void
161231,BLOCK,1,,<empty>,,,,3,,void
161244,BLOCK,1,,<empty>,,,,3,,void
161263,BLOCK,-1,,<empty>,9,,268,2,,void
161280,BLOCK,-1,,<empty>,9,,273,2,,void
161293,BLOCK,-1,,<empty>,9,,278,2,,void
161310,BLOCK,-1,,"{
        var_Create( p_playlist, ""http-cookies"", VLC_VAR_ADDRESS );
        var_SetChecked( p_playlist, ""http-cookies"", VLC_VAR_ADDRESS, cookies );
    }",5,,284,2,,void
161332,BLOCK,-1,,"{
        char *s = mods, *m;
        while( (m = strsep( &s, "" :,"" )) != NULL )
            playlist_ServicesDiscoveryAdd( p_playlist, m );
        free( mods );
    }",5,,295,2,,void
161358,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    /* Remove all services discovery */
    playlist_ServicesDiscoveryKillAll( p_playlist );

    msg_Dbg( p_playlist, ""destroying"" );

    playlist_Deactivate( p_playlist );

    /* Release input resources */
    assert( p_sys->p_input == NULL );
    input_resource_Release( p_sys->p_input_resource );
    if( p_sys->p_renderer )
        vlc_renderer_item_release( p_sys->p_renderer );

    if( p_playlist->p_media_library != NULL )
        playlist_MLDump( p_playlist );

    PL_LOCK;
    /* Release the current node */
    set_current_status_node( p_playlist, NULL );
    /* Release the current item */
    set_current_status_item( p_playlist, NULL );

    /* Destroy arrays completely - faster than one item at a time */
    ARRAY_RESET( p_playlist->items );
    ARRAY_RESET( p_playlist->current );

    /* Remove all remaining items */
    if( p_playlist->p_media_library != NULL )
    {
        playlist_NodeDeleteExplicit( p_playlist,...",1,,313,2,,void
161364,BLOCK,1,,<empty>,,,,2,,void
161390,BLOCK,-1,,<empty>,9,,327,2,,void
161401,BLOCK,-1,,<empty>,9,,330,2,,void
161425,BLOCK,-1,,"{
        playlist_NodeDeleteExplicit( p_playlist, p_playlist->p_media_library,
            PLAYLIST_DELETE_FORCE );
    }",5,,344,2,,void
161432,BLOCK,1,,<empty>,,,,1,,void
161440,BLOCK,1,,<empty>,,,,1,,void
161469,BLOCK,-1,,"{
        var_Destroy( p_playlist, ""http-cookies"" );
        vlc_http_cookies_destroy( cookies );
    }",5,,360,2,,void
161481,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    input_thread_t *p_input = pl_priv(p_playlist)->p_input;
    if( p_input != NULL )
        vlc_object_hold( p_input );
    return p_input;
}",1,,371,2,,void
161488,BLOCK,1,,<empty>,,,,2,,void
161499,BLOCK,-1,,<empty>,9,,376,2,,void
161508,BLOCK,-1,,"{
    input_thread_t * p_input;
    PL_LOCK;
    p_input = playlist_CurrentInputLocked( p_playlist );
    PL_UNLOCK;
    return p_input;
}",1,,384,2,,void
161522,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_item;
}",1,,399,2,,void
161527,BLOCK,1,,<empty>,,,,2,,void
161540,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_node;
}",1,,406,2,,void
161545,BLOCK,1,,<empty>,,,,2,,void
161559,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_item = p_item;
}",1,,414,3,,void
161564,BLOCK,1,,<empty>,,,,2,,void
161579,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_node = p_node;
}",1,,422,3,,void
161584,BLOCK,1,,<empty>,,,,2,,void
161598,BLOCK,-1,,"{
    /* These variables control updates */
    var_Create( p_playlist, ""item-change"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""leaf-to-parent"", VLC_VAR_INTEGER );

    var_Create( p_playlist, ""playlist-item-append"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""playlist-item-deleted"", VLC_VAR_ADDRESS );

    var_Create( p_playlist, ""input-current"", VLC_VAR_ADDRESS );

    /* Variables to control playback */
    var_Create( p_playlist, ""playlist-autostart"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""random"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_AddCallback( p_playlist, ""random"", RandomCallback, NULL );
    var_Create( p_playlist, ""repeat"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""loop"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""corks"", VLC_VAR_INTEGER );
    var_AddCallback( p_playlist, ""corks"", CorksCallback, NULL );

    var_Create( p_playlist, ""rate"", VLC_VAR_FLOAT | VLC_VAR_DOINHERIT );
    var_...",1,,429,2,,void
161786,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_item;
}",1,,486,2,,void
161791,BLOCK,1,,<empty>,,,,2,,void
161804,BLOCK,-1,,"{
    input_thread_t *p_input = pl_priv(p_playlist)->p_input;

    PL_ASSERT_LOCKED;

    if( p_input == NULL )
        return PLAYLIST_STOPPED;
    if( var_GetInteger( p_input, ""state"" ) == PAUSE_S )
        return PLAYLIST_PAUSED;
    return PLAYLIST_RUNNING;
}",1,,493,2,,void
161810,BLOCK,1,,<empty>,,,,2,,void
161822,BLOCK,-1,,<empty>,9,,499,2,,void
161831,BLOCK,-1,,<empty>,9,,501,2,,void
161874,BLOCK,-1,,<empty>,1,,1,1,,ANY
161894,BLOCK,-1,,<empty>,,,,3,,<empty>
161907,BLOCK,-1,,"{
    vlc_mutex_lock( &item->lock );

    if( !item->p_meta )
    {
        vlc_mutex_unlock( &item->lock );
        return NULL;
    }

    char const* artist = vlc_meta_Get( item->p_meta, vlc_meta_Artist );
    char const* album = vlc_meta_Get( item->p_meta, vlc_meta_Album );
    char* key;

    /**
     * Simple concatenation of artist and album can lead to the same key
     * for entities that should not have such. Imagine { dogs, tick } and
     * { dog, stick } */
    if( !artist || !album || asprintf( &key, ""%s:%zu:%s:%zu"",
          artist, strlen( artist ), album, strlen( album ) ) < 0 )
    {
        key = NULL;
    }
    vlc_mutex_unlock( &item->lock );

    return key;
}",1,,73,2,,void
161918,BLOCK,-1,,"{
        vlc_mutex_unlock( &item->lock );
        return NULL;
    }",5,,77,2,,void
161962,BLOCK,-1,,"{
        key = NULL;
    }",5,,92,2,,void
161978,BLOCK,-1,,"{
    free( data );
    VLC_UNUSED( obj );
}",1,,101,3,,void
161988,BLOCK,-1,,"{
    char* key = CreateCacheKey( item );

    if( key == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &fetcher->lock );
    char const* art = vlc_dictionary_value_for_key( &fetcher->album_cache,
                                                    key );
    if( art )
        input_item_SetArtURL( item, art );
    vlc_mutex_unlock( &fetcher->lock );

    free( key );
    return art ? VLC_SUCCESS : VLC_EGENERIC;
}",1,,107,3,,void
161998,BLOCK,-1,,<empty>,9,,111,2,,void
162017,BLOCK,-1,,<empty>,9,,117,2,,void
162039,BLOCK,-1,,"{
    char* art = input_item_GetArtURL( item );
    char* key = CreateCacheKey( item );

    if( key && art && strncasecmp( art, ""attachment://"", 13 ) )
    {
        vlc_mutex_lock( &fetcher->lock );
        if( overwrite || !vlc_dictionary_has_key( &fetcher->album_cache, key ) )
        {
            vlc_dictionary_insert( &fetcher->album_cache, key, art );
            art = NULL;
        }
        vlc_mutex_unlock( &fetcher->lock );
    }

    free( art );
    free( key );
}",1,,126,4,,void
162059,BLOCK,-1,,"{
        vlc_mutex_lock( &fetcher->lock );
        if( overwrite || !vlc_dictionary_has_key( &fetcher->album_cache, key ) )
        {
            vlc_dictionary_insert( &fetcher->album_cache, key, art );
            art = NULL;
        }
        vlc_mutex_unlock( &fetcher->lock );
    }",5,,131,2,,void
162075,BLOCK,-1,,"{
            vlc_dictionary_insert( &fetcher->album_cache, key, art );
            art = NULL;
        }",9,,134,2,,void
162102,BLOCK,-1,,"{
    meta_fetcher_t* mf = vlc_custom_create( fetcher->owner,
                                            sizeof( *mf ), type );
    if( unlikely( !mf ) )
        return VLC_ENOMEM;

    mf->e_scope = scope;
    mf->p_item = item;

    module_t* mf_module = module_need( mf, type, NULL, false );

    if( mf_module )
        module_unneed( mf, mf_module );

    vlc_object_release( mf );

    return VLC_SUCCESS;
}",1,,147,5,,void
162111,BLOCK,1,,<empty>,,,,4,,void
162125,BLOCK,-1,,<empty>,9,,151,2,,void
162148,BLOCK,-1,,<empty>,9,,159,2,,void
162160,BLOCK,-1,,"{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Title ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Artist ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Album );
    vlc_mutex_unlock( &item->lock );
    return error;
}",1,,167,2,,void
162205,BLOCK,-1,,"{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_ArtworkURL );
    vlc_mutex_unlock( &item->lock );
    return error;
}",1,,178,2,,void
162238,BLOCK,-1,,"{
    InvokeModule( fetcher, item, scope, ""art finder"" );
    return CheckArt( item );
}",1,,187,4,,void
162253,BLOCK,-1,,"{
    input_item_t* item = req->item;

    if( CheckMeta( item ) &&
        InvokeModule( fetcher, req->item, scope, ""meta fetcher"" ) )
    {
        return VLC_EGENERIC;
    }

    if( ! CheckArt( item )                            ||
        ! ReadAlbumCache( fetcher, item )             ||
        ! playlist_FindArtInCacheUsingItemUID( item ) ||
        ! playlist_FindArtInCache( item )             ||
        ! SearchArt( fetcher, item, scope ) )
    {
        AddAlbumCache( fetcher, req->item, false );
        if( !background_worker_Push( fetcher->downloader, req, NULL, 0 ) )
            return VLC_SUCCESS;
    }

    return VLC_EGENERIC;
}",1,,194,4,,void
162271,BLOCK,-1,,"{
        return VLC_EGENERIC;
    }",5,,199,2,,void
162297,BLOCK,-1,,"{
        AddAlbumCache( fetcher, req->item, false );
        if( !background_worker_Push( fetcher->downloader, req, NULL, 0 ) )
            return VLC_SUCCESS;
    }",5,,208,2,,void
162313,BLOCK,-1,,<empty>,13,,211,2,,void
162322,BLOCK,-1,,"{
    if( req->preparse_status != -1 )
    {
        input_item_SetPreparsed( req->item, true );
        input_item_SignalPreparseEnded( req->item, req->preparse_status );
    }
}",1,,218,2,,void
162330,BLOCK,-1,,"{
        input_item_SetPreparsed( req->item, true );
        input_item_SignalPreparseEnded( req->item, req->preparse_status );
    }",5,,220,2,,void
162348,BLOCK,-1,,"{
    ReadAlbumCache( fetcher, req->item );

    char *psz_arturl = input_item_GetArtURL( req->item );
    if( !psz_arturl )
        goto error;

    if( !strncasecmp( psz_arturl, ""file://"", 7 ) ||
        !strncasecmp( psz_arturl, ""attachment://"", 13 ) )
        goto out; /* no fetch required */

    stream_t* source = vlc_stream_NewURL( fetcher->owner, psz_arturl );

    if( !source )
        goto error;

    struct vlc_memstream output_stream;
    vlc_memstream_open( &output_stream );

    for( ;; )
    {
        char buffer[2048];

        int read = vlc_stream_Read( source, buffer, sizeof( buffer ) );
        if( read <= 0 )
            break;

        if( (int)vlc_memstream_write( &output_stream, buffer, read ) < read )
            break;
    }

    vlc_stream_Delete( source );

    if( vlc_memstream_close( &output_stream ) )
        goto error;

    if( vlc_killed() )
    {
        free( output_stream.ptr );
        goto error;
    }

    playlist_SaveArt( fetcher->owner, req...",1,,228,3,,void
162364,BLOCK,-1,,<empty>,9,,233,2,,void
162378,BLOCK,-1,,<empty>,9,,237,2,,void
162391,BLOCK,-1,,<empty>,9,,242,2,,void
162398,BLOCK,-1,,<empty>,5,,247,1,,void
162399,BLOCK,4,,"{
        char buffer[2048];

        int read = vlc_stream_Read( source, buffer, sizeof( buffer ) );
        if( read <= 0 )
            break;

        if( (int)vlc_memstream_write( &output_stream, buffer, read ) < read )
            break;
    }",5,,248,4,,void
162413,BLOCK,-1,,<empty>,13,,253,2,,void
162425,BLOCK,-1,,<empty>,13,,256,2,,void
162433,BLOCK,-1,,<empty>,9,,262,2,,void
162437,BLOCK,-1,,"{
        free( output_stream.ptr );
        goto error;
    }",5,,265,2,,void
162470,BLOCK,-1,,"{
        var_SetAddress( fetcher->owner, ""item-change"", req->item );
        input_item_SetArtFetched( req->item, true );
    }",5,,278,2,,void
162498,BLOCK,-1,,"{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_LOCAL ) == VLC_SUCCESS )
        return; /* done */

    if( var_InheritBool( fetcher->owner, ""metadata-network-access"" ) ||
        req->options & META_REQUEST_OPTION_SCOPE_NETWORK )
    {
        if( background_worker_Push( fetcher->network, req, NULL, 0 ) )
            SetPreparsed( req );
    }
    else
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",1,,293,3,,void
162506,BLOCK,-1,,<empty>,9,,295,2,,void
162520,BLOCK,-1,,"{
        if( background_worker_Push( fetcher->network, req, NULL, 0 ) )
            SetPreparsed( req );
    }",5,,299,2,,void
162529,BLOCK,-1,,<empty>,13,,301,2,,void
162533,BLOCK,-1,,"{
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }",5,,304,1,,void
162546,BLOCK,-1,,"{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_NETWORK ) )
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",1,,311,3,,void
162552,BLOCK,-1,,"{
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }",5,,313,2,,void
162564,BLOCK,-1,,"{
    struct fetcher_request* req = req_;

    if( atomic_fetch_sub( &req->refs, 1 ) != 1 )
        return;

    input_item_Release( req->item );
    free( req );
}",1,,320,2,,void
162578,BLOCK,-1,,<empty>,9,,324,2,,void
162590,BLOCK,-1,,"{
    struct fetcher_request* req = req_;
    atomic_fetch_add_explicit( &req->refs, 1, memory_order_relaxed );
}",1,,331,2,,void
162606,BLOCK,-1,,"{
    struct fetcher_thread* th = handle;
    vlc_interrupt_set( &th->interrupt );

    th->pf_worker( th->fetcher, th->req );

    atomic_store( &th->active, false );
    background_worker_RequestProbe( th->worker );
    return NULL;
}",1,,337,2,,void
162646,BLOCK,-1,,"{
    struct fetcher_thread* th = malloc( sizeof *th );

    if( unlikely( !th ) )
        return VLC_ENOMEM;

    th->req = req;
    th->worker = bg;
    th->fetcher = fetcher;
    th->pf_worker = pf_worker;

    vlc_interrupt_init( &th->interrupt );
    atomic_init( &th->active, true );

    if( !vlc_clone( &th->thread, FetcherThread, th, VLC_THREAD_PRIORITY_LOW ) )
    {
        *handle = th;
        return VLC_SUCCESS;
    }

    vlc_interrupt_deinit( &th->interrupt );
    free( th );
    return VLC_EGENERIC;
}",1,,351,6,,void
162658,BLOCK,-1,,<empty>,9,,355,2,,void
162702,BLOCK,-1,,"{
        *handle = th;
        return VLC_SUCCESS;
    }",5,,366,2,,void
162723,BLOCK,-1,,"{
    return !atomic_load( &((struct fetcher_thread*)th_)->active );
    VLC_UNUSED( fetcher_ );
}",1,,377,3,,void
162740,BLOCK,-1,,"{
    struct fetcher_thread* th = th_;
    VLC_UNUSED( fetcher_ );

    vlc_interrupt_kill( &th->interrupt );
    vlc_join( th->thread, NULL );
    vlc_interrupt_deinit( &th->interrupt );
    free( th );
}",1,,383,3,,void
162770,BLOCK,-1,,"DEF_STARTER(  SearchLocal, fetcher->local )",1,,398,4,,void
162790,BLOCK,-1,,"DEF_STARTER(SearchNetwork, fetcher->network )",1,,399,4,,void
162810,BLOCK,-1,,"DEF_STARTER(   Downloader, fetcher->downloader )",1,,400,4,,void
162830,BLOCK,-1,,"{
    struct background_worker_config conf = {
        .default_timeout = 0,
        .pf_start = starter,
        .pf_probe = ProbeWorker,
        .pf_stop = CloseWorker,
        .pf_release = RequestRelease,
        .pf_hold = RequestHold };

    *worker = background_worker_New( fetcher, &conf );
}",1,,404,4,,void
162835,BLOCK,1,,<empty>,9,,406,1,,void
162839,BLOCK,2,,<empty>,9,,407,2,,void
162843,BLOCK,3,,<empty>,9,,408,3,,void
162847,BLOCK,4,,<empty>,9,,409,4,,void
162851,BLOCK,5,,<empty>,9,,410,5,,void
162855,BLOCK,6,,<empty>,9,,411,6,,void
162870,BLOCK,-1,,"{
    playlist_fetcher_t* fetcher = malloc( sizeof( *fetcher ) );

    if( unlikely( !fetcher ) )
        return NULL;

    fetcher->owner = owner;

    WorkerInit( fetcher, &fetcher->local, StartSearchLocal );
    WorkerInit( fetcher, &fetcher->network, StartSearchNetwork );
    WorkerInit( fetcher, &fetcher->downloader, StartDownloader );

    if( unlikely( !fetcher->local || !fetcher->network || !fetcher->downloader ) )
    {
        if( fetcher->local )
            background_worker_Delete( fetcher->local );

        if( fetcher->network )
            background_worker_Delete( fetcher->network );

        if( fetcher->downloader )
            background_worker_Delete( fetcher->downloader );

        free( fetcher );
        return NULL;
    }

    vlc_mutex_init( &fetcher->lock );
    vlc_dictionary_init( &fetcher->album_cache, 0 );

    return fetcher;
}",1,,417,2,,void
162882,BLOCK,-1,,<empty>,9,,421,2,,void
162927,BLOCK,-1,,"{
        if( fetcher->local )
            background_worker_Delete( fetcher->local );

        if( fetcher->network )
            background_worker_Delete( fetcher->network );

        if( fetcher->downloader )
            background_worker_Delete( fetcher->downloader );

        free( fetcher );
        return NULL;
    }",5,,430,2,,void
162932,BLOCK,-1,,<empty>,13,,432,2,,void
162941,BLOCK,-1,,<empty>,13,,435,2,,void
162950,BLOCK,-1,,<empty>,13,,438,2,,void
162979,BLOCK,-1,,"{
    struct fetcher_request* req = malloc( sizeof *req );

    if( unlikely( !req ) )
        return VLC_ENOMEM;

    req->item = item;
    req->options = options;
    req->preparse_status = preparse_status;

    atomic_init( &req->refs, 1 );
    input_item_Hold( item );

    if( background_worker_Push( fetcher->local, req, NULL, 0 ) )
        SetPreparsed( req );

    RequestRelease( req );
    return VLC_SUCCESS;
}",1,,452,5,,void
162991,BLOCK,-1,,<empty>,9,,456,2,,void
163025,BLOCK,-1,,<empty>,9,,466,2,,void
163036,BLOCK,-1,,"{
    background_worker_Delete( fetcher->local );
    background_worker_Delete( fetcher->network );
    background_worker_Delete( fetcher->downloader );

    vlc_dictionary_clear( &fetcher->album_cache, FreeCacheEntry, NULL );
    vlc_mutex_destroy( &fetcher->lock );

    free( fetcher );
}",1,,473,2,,void
163071,BLOCK,-1,,<empty>,1,,1,1,,ANY
163076,BLOCK,-1,,<empty>,,,,2,,<empty>
163084,BLOCK,-1,,<empty>,,,,5,,<empty>
163089,BLOCK,-1,,<empty>,,,,2,,<empty>
163114,BLOCK,-1,,<empty>,1,,1,1,,ANY
163118,BLOCK,-1,,<empty>,,,,3,,<empty>
163128,BLOCK,-1,,<empty>,,,,7,,<empty>
163137,BLOCK,-1,,<empty>,,,,6,,<empty>
163143,BLOCK,-1,,"{
    input_item_t *p_input = p_event->p_obj;
    playlist_t *p_playlist = user_data;
    playlist_private_t *p_sys = pl_priv( p_playlist );
    input_item_node_t *p_new_root = p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;

    playlist_item_t *p_item =
        playlist_ItemGetByInput( p_playlist, p_input );

    assert( p_item != NULL );

    bool b_current = get_current_status_item( p_playlist ) == p_item;
    bool b_autostart = var_GetBool( p_playlist, ""playlist-autostart"" );
    bool b_stop = p_item->i_flags & PLAYLIST_SUBITEM_STOP_FLAG;
    bool b_flat = false;

    p_item->i_flags &= ~PLAYLIST_SUBITEM_STOP_FLAG;

    /* We will have to flatten the tree out if we are in ""the playlist"" node and
    the user setting demands flat playlist */

    if( !pl_priv(p_playlist)->b_tree ) {
        playlist_item_t *p_up = p_item;
        while( p_up->p_parent )
        {
            if( p_up->p_parent == p_playlist->p_playing )
            {
                b_flat = true;...",1,,56,3,,void
163159,BLOCK,1,,<empty>,,,,3,,void
163220,BLOCK,1,,<empty>,,,,3,,void
163227,BLOCK,-1,,"{
        playlist_item_t *p_up = p_item;
        while( p_up->p_parent )
        {
            if( p_up->p_parent == p_playlist->p_playing )
            {
                b_flat = true;
                break;
            }
            p_up = p_up->p_parent;
        }
    }",40,,79,2,,void
163236,BLOCK,-1,,"{
            if( p_up->p_parent == p_playlist->p_playing )
            {
                b_flat = true;
                break;
            }
            p_up = p_up->p_parent;
        }",9,,82,2,,void
163245,BLOCK,-1,,"{
                b_flat = true;
                break;
            }",13,,84,2,,void
163265,BLOCK,-1,,"{
        playlist_item_t *p_parent = p_item->p_parent;
        assert( p_parent != NULL );

        int i;
        for( i = 0; i < p_parent->i_children; i++ )
        {
            if( p_parent->pp_children[i] == p_item )
            {
                pos = i;
                break;
            }
        }
        assert( i < p_parent->i_children );

        playlist_NodeDeleteExplicit( p_playlist, p_item, 0 );

        /* If there is a pending request referring to the item we just deleted
         * it needs to be updated so that we do not try to play an entity that
         * is no longer part of the playlist. */

        if( p_sys->request.b_request &&
            ( p_sys->request.p_item == p_item ||
              p_sys->request.p_node == p_item ) )
        {
            b_redirect_request = true;
        }

        p_item = p_parent;
    }",5,,100,2,,void
163278,BLOCK,-1,,<empty>,9,,105,1,,void
163289,BLOCK,4,,"{
            if( p_parent->pp_children[i] == p_item )
            {
                pos = i;
                break;
            }
        }",9,,106,4,,void
163298,BLOCK,-1,,"{
                pos = i;
                break;
            }",13,,108,2,,void
163335,BLOCK,-1,,"{
            b_redirect_request = true;
        }",9,,124,2,,void
163343,BLOCK,-1,,"{
        pos = p_item->i_children >= 0 ? p_item->i_children : 0;
    }",5,,131,1,,void
163367,BLOCK,-1,,"{
        /* a redirect of the pending request is required, as such we update the
         * request to refer to the item that would have been the next in line
         * (if any). */

        assert( b_flat );

        playlist_item_t* p_redirect = NULL;

        if( p_item->i_children > pos )
            p_redirect = p_item->pp_children[pos];

        p_sys->request.p_item = p_redirect;
        p_sys->request.p_node = NULL;
    }",5,,145,2,,void
163380,BLOCK,-1,,<empty>,13,,155,2,,void
163405,BLOCK,-1,,<empty>,19,,161,2,,void
163414,BLOCK,-1,,"{
        if( ( b_stop && !b_flat ) || !b_autostart )
        {
            playlist_Control( p_playlist, PLAYLIST_STOP, pl_Locked );
        }
        else if( last_pos != pos ) /* any children? */
        {
            /* Continue to play, either random or the first new item */
            playlist_item_t *p_play_item;

            if( var_GetBool( p_playlist, ""random"" ) )
            {
                p_play_item = NULL;
            }
            else
            {
                p_play_item = p_item->pp_children[pos];
                /* NOTE: this is a work around the general bug:
                if node-to-be-played contains sub-nodes, then second instead
                of first leaf starts playing (only in case the leafs have just
                been instered and playlist has not yet been rebuilt.)
                */
                while( p_play_item->i_children > 0 )
                    p_play_item = p_play_item->pp_children[0];
            }

            playlist_ViewPla...",5,,165,2,,void
163423,BLOCK,-1,,"{
            playlist_Control( p_playlist, PLAYLIST_STOP, pl_Locked );
        }",9,,167,2,,void
163429,BLOCK,-1,,<empty>,14,,170,1,,void
163434,BLOCK,-1,,"{
            /* Continue to play, either random or the first new item */
            playlist_item_t *p_play_item;

            if( var_GetBool( p_playlist, ""random"" ) )
            {
                p_play_item = NULL;
            }
            else
            {
                p_play_item = p_item->pp_children[pos];
                /* NOTE: this is a work around the general bug:
                if node-to-be-played contains sub-nodes, then second instead
                of first leaf starts playing (only in case the leafs have just
                been instered and playlist has not yet been rebuilt.)
                */
                while( p_play_item->i_children > 0 )
                    p_play_item = p_play_item->pp_children[0];
            }

            playlist_ViewPlay( p_playlist, NULL, p_play_item );
        }",9,,171,2,,void
163440,BLOCK,-1,,"{
                p_play_item = NULL;
            }",13,,176,2,,void
163445,BLOCK,-1,,"{
                p_play_item = p_item->pp_children[pos];
                /* NOTE: this is a work around the general bug:
                if node-to-be-played contains sub-nodes, then second instead
                of first leaf starts playing (only in case the leafs have just
                been instered and playlist has not yet been rebuilt.)
                */
                while( p_play_item->i_children > 0 )
                    p_play_item = p_play_item->pp_children[0];
            }",13,,180,1,,void
163471,BLOCK,-1,,<empty>,14,,193,1,,void
163482,BLOCK,-1,,"{
            /* If the playlist is flat, empty nodes are automatically deleted;
             * meaning that moving from the current index (the index of a now
             * removed node) to the next would result in a skip of one entry
             * (as the empty node is deleted, the logical next item would be
             * the one that now resides in its place).
             *
             * Imagine [ A, B, C, D ], where B (at index 1) is currently being
             * played and deleted. C is the logically next item, but since the
             * list now looks like [ A, C, D ], advancing to index 2 would mean
             * D is played - and not C.
             *
             * By positioning the playlist-head at index 0 (A), when the
             * playlist advance to the next item, C will correctly be played.
             *
             * Note: Of course, if the deleted item is at index 0, we should
             * play whatever item is at position 0 since we cannot advance to
...",9,,194,2,,void
163485,BLOCK,-1,,<empty>,17,,215,2,,void
163496,BLOCK,-1,,<empty>,17,,218,1,,void
163511,BLOCK,-1,,"{
    playlist_t *p_playlist = user_data;

    var_SetAddress( p_playlist, ""item-change"", p_event->p_obj );
}",1,,230,3,,void
163527,BLOCK,-1,,"{
    const playlist_item_t *pa = a, *pb = b;

    /* ID are between 1 and INT_MAX, this cannot overflow. */
    return pa->i_id - pb->i_id;
}",1,,237,3,,void
163549,BLOCK,-1,,"{
    const playlist_item_t *pa = a, *pb = b;

    if( pa->p_input == pb->p_input )
        return 0;
    return (((uintptr_t)pa->p_input) > ((uintptr_t)pb->p_input))
        ? +1 : -1;
}",1,,245,3,,void
163566,BLOCK,-1,,<empty>,9,,249,2,,void
163591,BLOCK,-1,,"{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t **pp, *p_item;

    p_item = malloc( sizeof( playlist_item_t ) );
    if( unlikely(p_item == NULL) )
        return NULL;

    assert( p_input );

    p_item->p_input = p_input;
    p_item->i_id = p->i_last_playlist_id;
    p_item->p_parent = NULL;
    p_item->i_children = (p_input->i_type == ITEM_TYPE_NODE) ? 0 : -1;
    p_item->pp_children = NULL;
    p_item->i_nb_played = 0;
    p_item->i_flags = 0;

    PL_ASSERT_LOCKED;

    do  /* Find an unused ID for the item */
    {
        if( unlikely(p_item->i_id == INT_MAX) )
            p_item->i_id = 0;

        p_item->i_id++;

        if( unlikely(p_item->i_id == p->i_last_playlist_id) )
            goto error; /* All IDs taken */

        pp = tsearch( p_item, &p->id_tree, playlist_ItemCmpId );
        if( unlikely(pp == NULL) )
            goto error;

        assert( (*pp)->i_id == p_item->i_id );
        assert( (*pp) == p_item || (*pp)->p_input != p_input )...",1,,259,3,,void
163597,BLOCK,1,,<empty>,,,,2,,void
163614,BLOCK,-1,,<empty>,9,,265,2,,void
163666,BLOCK,-1,,"{
        if( unlikely(p_item->i_id == INT_MAX) )
            p_item->i_id = 0;

        p_item->i_id++;

        if( unlikely(p_item->i_id == p->i_last_playlist_id) )
            goto error; /* All IDs taken */

        pp = tsearch( p_item, &p->id_tree, playlist_ItemCmpId );
        if( unlikely(pp == NULL) )
            goto error;

        assert( (*pp)->i_id == p_item->i_id );
        assert( (*pp) == p_item || (*pp)->p_input != p_input );
    }",5,,280,1,,void
163674,BLOCK,-1,,<empty>,13,,282,2,,void
163693,BLOCK,-1,,<empty>,13,,287,2,,void
163709,BLOCK,-1,,<empty>,13,,291,2,,void
163750,BLOCK,-1,,"{
        tdelete( p_item, &p->id_tree, playlist_ItemCmpId );
        goto error;
    }",5,,300,2,,void
163826,BLOCK,-1,,"{
    playlist_private_t *p = pl_priv(p_playlist);

    PL_ASSERT_LOCKED;

    vlc_event_manager_t *p_em = &p_item->p_input->event_manager;

    vlc_event_detach( p_em, vlc_InputItemSubItemTreeAdded,
                      input_item_add_subitem_tree, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemMetaChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemDurationChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemNameChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemInfoChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemErrorWhenReadingChanged,
                      input_item_changed, p_playlist );

    input_item_Release( p_item->p_input );

    tdelete( p_item, &p->input_tree, playlist_ItemCmpInput );
    tdelete( p_item, &p->id_tree, playlist_ItemCmpId );
   ...",1,,342,3,,void
163832,BLOCK,1,,<empty>,,,,2,,void
163906,BLOCK,-1,,"{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.i_id = id;
    pp = tfind( &key, &p->id_tree, playlist_ItemCmpId );
    return (pp != NULL) ? *pp : NULL;
}",1,,389,3,,void
163912,BLOCK,1,,<empty>,,,,2,,void
163948,BLOCK,-1,,"{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.p_input = (input_item_t *)item;
    pp = tfind( &key, &p->input_tree, playlist_ItemCmpInput );
    return (pp != NULL) ? *pp : NULL;
}",1,,413,3,,void
163954,BLOCK,1,,<empty>,,,,2,,void
163992,BLOCK,-1,,"{
    playlist_item_t *p_root = p_playlist->p_playing;

    PL_LOCK_IF( !b_locked );

    for( int i = p_root->i_children - 1; i >= 0 ;i-- )
        playlist_NodeDelete( p_playlist, p_root->pp_children[i] );

    PL_UNLOCK_IF( !b_locked );
}",1,,431,3,,void
164002,BLOCK,1,,<empty>,,,,2,,void
164008,BLOCK,-1,,<empty>,5,,436,1,,void
164032,BLOCK,1,,<empty>,,,,2,,void
164043,BLOCK,-1,,"{
    return playlist_AddExt( p_playlist, psz_uri, NULL, play_now,
                            0, NULL, 0, true );
}",1,,455,4,,void
164065,BLOCK,-1,,"{
    input_item_t *p_input = input_item_New( psz_uri, psz_name );
    if( !p_input )
        return VLC_ENOMEM;
    input_item_AddOptions( p_input, i_options, ppsz_options, i_option_flags );
    int i_ret = playlist_AddInput( p_playlist, p_input, play_now, b_playlist );
    input_item_Release( p_input );
    return i_ret;
}",1,,478,9,,void
164075,BLOCK,-1,,<empty>,9,,481,2,,void
164102,BLOCK,-1,,"{
    PL_LOCK;
    playlist_item_t *item = b_playlist ? p_playlist->p_playing
                                       : p_playlist->p_media_library;

    item = playlist_NodeAddInput( p_playlist, p_input, item, PLAYLIST_END );

    if( likely(item != NULL) && play_now )
        playlist_ViewPlay( p_playlist, NULL, item );
    PL_UNLOCK;
    return (item != NULL) ? VLC_SUCCESS : VLC_ENOMEM;
}",1,,499,5,,void
164129,BLOCK,-1,,<empty>,9,,507,2,,void
164149,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    assert( p_input );
    assert( p_parent && p_parent->i_children != -1 );

    playlist_item_t *p_item = playlist_ItemNewFromInput( p_playlist, p_input );
    if( unlikely(p_item == NULL) )
        return NULL;

    if( p_input->i_type != ITEM_TYPE_NODE )
        ARRAY_APPEND(p_playlist->items, p_item);

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );
    playlist_Preparse( p_playlist, p_item );

    return p_item;
}",1,,526,5,,void
164173,BLOCK,-1,,<empty>,9,,534,2,,void
164182,BLOCK,-1,,<empty>,9,,537,2,,void
164207,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );
    assert( p_parent->i_children > -1 );

    if( i_pos == PLAYLIST_END )
        i_pos = p_parent->i_children;

    bool b_flat = false;

    for( playlist_item_t* p_up = p_parent; p_up; p_up = p_up->p_parent )
    {
        if( p_up == p_playlist->p_playing && !pl_priv(p_playlist)->b_tree )
            b_flat = true;

        if( p_up == p_item )
            /* TODO: We don't support copying a node into itself (yet),
            because we insert items as we copy. Instead, we should copy
            all items first and then insert. */
            return i_pos;
    }

    return RecursiveInsertCopy( p_playlist, p_item, p_parent, i_pos, b_flat );
}",1,,559,5,,void
164228,BLOCK,-1,,<empty>,9,,565,2,,void
164239,BLOCK,-1,,<empty>,5,,569,1,,void
164250,BLOCK,4,,"{
        if( p_up == p_playlist->p_playing && !pl_priv(p_playlist)->b_tree )
            b_flat = true;

        if( p_up == p_item )
            /* TODO: We don't support copying a node into itself (yet),
            because we insert items as we copy. Instead, we should copy
            all items first and then insert. */
            return i_pos;
    }",5,,570,4,,void
164261,BLOCK,1,,<empty>,,,,2,,void
164268,BLOCK,-1,,<empty>,13,,572,2,,void
164276,BLOCK,-1,,<empty>,13,,578,2,,void
164294,BLOCK,-1,,"{
    return RecursiveAddIntoParent( p_playlist, p_parent, p_node, i_pos, b_flat,
                                   &(playlist_item_t*){ NULL } );
}",1,,600,6,,void
164311,BLOCK,-1,,"{
    int idx;

    TAB_FIND( p_item->p_parent->i_children,
              p_item->p_parent->pp_children,
              p_item,
              idx );

    return idx;
}",1,,611,2,,void
164335,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    if( p_node->i_children == -1 ) return VLC_EGENERIC;

    playlist_item_t *p_detach = p_item->p_parent;
    int i_index = ItemIndex( p_item );

    TAB_ERASE(p_detach->i_children, p_detach->pp_children, i_index);

    if( p_detach == p_node && i_index < i_newpos )
        i_newpos--;

    TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
    p_item->p_parent = p_node;

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",1,,635,5,,void
164344,BLOCK,-1,,<empty>,36,,638,2,,void
164374,BLOCK,-1,,<empty>,9,,646,2,,void
164394,BLOCK,1,,<empty>,,,,2,,void
164406,BLOCK,1,,<empty>,,,,2,,void
164423,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    if ( p_node->i_children == -1 ) return VLC_EGENERIC;

    for( int i = 0; i < i_items; i++ )
    {
        playlist_item_t *p_item = pp_items[i];
        int i_index = ItemIndex( p_item );
        playlist_item_t *p_parent = p_item->p_parent;
        TAB_ERASE(p_parent->i_children, p_parent->pp_children, i_index);
        if ( p_parent == p_node && i_index < i_newpos ) i_newpos--;
    }
    for( int i = i_items - 1; i >= 0; i-- )
    {
        playlist_item_t *p_item = pp_items[i];
        TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
        p_item->p_parent = p_node;
    }

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",1,,671,6,,void
164432,BLOCK,-1,,<empty>,37,,674,2,,void
164436,BLOCK,-1,,<empty>,5,,676,1,,void
164446,BLOCK,4,,"{
        playlist_item_t *p_item = pp_items[i];
        int i_index = ItemIndex( p_item );
        playlist_item_t *p_parent = p_item->p_parent;
        TAB_ERASE(p_parent->i_children, p_parent->pp_children, i_index);
        if ( p_parent == p_node && i_index < i_newpos ) i_newpos--;
    }",5,,677,4,,void
164480,BLOCK,-1,,<empty>,57,,682,2,,void
164484,BLOCK,-1,,<empty>,5,,684,1,,void
164496,BLOCK,4,,"{
        playlist_item_t *p_item = pp_items[i];
        TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
        p_item->p_parent = p_node;
    }",5,,685,4,,void
164520,BLOCK,1,,<empty>,,,,2,,void
164532,BLOCK,1,,<empty>,,,,2,,void
164546,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    PL_ASSERT_LOCKED;

    p_sys->b_reset_currently_playing = true;
    vlc_cond_signal( &p_sys->signal );

    var_SetAddress( p_playlist, ""playlist-item-append"", item );
}",1,,705,3,,void
164552,BLOCK,1,,<empty>,,,,2,,void
164576,BLOCK,-1,,"{
    mtime_t duration = input_item_GetDuration( node->p_input );
    if( duration == -1 )
        duration = 0;

    for( int i = 0; i < node->i_children; i++ )
        duration += playlist_GetNodeDuration( node->pp_children[i] );

    return duration;
}",1,,719,2,,void
164589,BLOCK,-1,,<empty>,9,,722,2,,void
164594,BLOCK,-1,,<empty>,5,,724,1,,void
164621,BLOCK,-1,,"{
    playlist_private_t *sys = pl_priv(p_playlist);
    input_item_t *input = p_item->p_input;

    PL_ASSERT_LOCKED;
    /* Preparse if no artist/album info, and hasn't been preparsed already
       and if user has some preparsing option (auto-preparse variable)
       enabled*/
    char *psz_artist = input_item_GetArtist( input );
    char *psz_album = input_item_GetAlbum( input );

    if( sys->b_preparse && !input_item_IsPreparsed( input )
     && (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album)) )
        vlc_MetadataRequest( p_playlist->obj.libvlc, input, 0, -1, p_item );
    free( psz_artist );
    free( psz_album );
}",1,,737,3,,void
164627,BLOCK,1,,<empty>,,,,2,,void
164663,BLOCK,-1,,<empty>,9,,750,2,,void
164684,BLOCK,-1,,"{
    int i;
    if( p_item->i_children != -1 ) return;

    p_item->i_children = 0;

    input_item_t *p_input = p_item->p_input;
    vlc_mutex_lock( &p_input->lock );
    p_input->i_type = ITEM_TYPE_NODE;
    vlc_mutex_unlock( &p_input->lock );

    var_SetAddress( p_playlist, ""item-change"", p_item->p_input );

    /* Remove it from the array of available items */
    ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_item->i_id, i );
    if( i != -1 )
        ARRAY_REMOVE( p_playlist->items, i );
}",1,,757,3,,void
164693,BLOCK,-1,,<empty>,36,,759,2,,void
164733,BLOCK,-1,,<empty>,9,,773,2,,void
164748,BLOCK,-1,,"{
    *pp_first_leaf = NULL;

    if( p_parent->i_children == -1 ) ChangeToNode( p_playlist, p_parent );

    if( i_pos == PLAYLIST_END ) i_pos = p_parent->i_children;

    for( int i = 0; i < p_node->i_children; i++ )
    {
        input_item_node_t *p_child_node = p_node->pp_children[i];

        playlist_item_t *p_new_item = NULL;
        bool b_children = p_child_node->i_children > 0;

        //Create the playlist item represented by input node, if allowed.
        if( !(b_flat && b_children) )
        {
            p_new_item = playlist_NodeAddInput( p_playlist,
                                                p_child_node->p_item,
                                                p_parent, i_pos );
            if( !p_new_item ) return i_pos;

            i_pos++;
        }
        //Recurse if any children
        if( b_children )
        {
            //Substitute p_new_item for first child leaf
            //(If flat, continue counting from current position)
            int i_...",1,,780,7,,void
164760,BLOCK,-1,,<empty>,38,,783,2,,void
164768,BLOCK,-1,,<empty>,33,,785,2,,void
164775,BLOCK,-1,,<empty>,5,,787,1,,void
164787,BLOCK,4,,"{
        input_item_node_t *p_child_node = p_node->pp_children[i];

        playlist_item_t *p_new_item = NULL;
        bool b_children = p_child_node->i_children > 0;

        //Create the playlist item represented by input node, if allowed.
        if( !(b_flat && b_children) )
        {
            p_new_item = playlist_NodeAddInput( p_playlist,
                                                p_child_node->p_item,
                                                p_parent, i_pos );
            if( !p_new_item ) return i_pos;

            i_pos++;
        }
        //Recurse if any children
        if( b_children )
        {
            //Substitute p_new_item for first child leaf
            //(If flat, continue counting from current position)
            int i_last_pos = RecursiveAddIntoParent(
                    p_playlist,
                    p_new_item ? p_new_item : p_parent,
                    p_child_node,
                    ( b_flat ? i_pos : 0 ),
                    b_...",5,,788,4,,void
164813,BLOCK,-1,,"{
            p_new_item = playlist_NodeAddInput( p_playlist,
                                                p_child_node->p_item,
                                                p_parent, i_pos );
            if( !p_new_item ) return i_pos;

            i_pos++;
        }",9,,796,2,,void
164826,BLOCK,-1,,<empty>,31,,800,2,,void
164833,BLOCK,-1,,"{
            //Substitute p_new_item for first child leaf
            //(If flat, continue counting from current position)
            int i_last_pos = RecursiveAddIntoParent(
                    p_playlist,
                    p_new_item ? p_new_item : p_parent,
                    p_child_node,
                    ( b_flat ? i_pos : 0 ),
                    b_flat,
                    &p_new_item );
            //If flat, take position after recursion as current position
            if( b_flat ) i_pos = i_last_pos;
        }",9,,806,2,,void
164853,BLOCK,-1,,<empty>,26,,817,2,,void
164865,BLOCK,-1,,<empty>,22,,821,2,,void
164880,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );

    if( p_item == p_parent ) return i_pos;

    input_item_t *p_input = p_item->p_input;

    if( p_item->i_children == -1 || !b_flat )
    {
        playlist_item_t *p_new_item = NULL;

        if( p_item->i_children == -1 )
        {
            input_item_t *p_new_input = input_item_Copy( p_input );

            if( likely(p_new_input != NULL) )
            {
                p_new_item = playlist_NodeAddInput( p_playlist, p_new_input,
                                                    p_parent, i_pos );
                input_item_Release( p_new_input );
            }
        }
        else
        {
            vlc_mutex_lock( &p_input->lock );
            p_new_item = playlist_NodeCreate( p_playlist, p_input->psz_name,
                                              p_parent, i_pos, 0 );
            vlc_mutex_unlock( &p_input->lock );
        }
        if( unlikely(p_new_item == NULL) )
            return ...",1,,829,6,,void
164894,BLOCK,-1,,<empty>,30,,833,2,,void
164913,BLOCK,-1,,"{
        playlist_item_t *p_new_item = NULL;

        if( p_item->i_children == -1 )
        {
            input_item_t *p_new_input = input_item_Copy( p_input );

            if( likely(p_new_input != NULL) )
            {
                p_new_item = playlist_NodeAddInput( p_playlist, p_new_input,
                                                    p_parent, i_pos );
                input_item_Release( p_new_input );
            }
        }
        else
        {
            vlc_mutex_lock( &p_input->lock );
            p_new_item = playlist_NodeCreate( p_playlist, p_input->psz_name,
                                              p_parent, i_pos, 0 );
            vlc_mutex_unlock( &p_input->lock );
        }
        if( unlikely(p_new_item == NULL) )
            return i_pos;

        i_pos++;

        if( p_new_item->i_children != -1 )
            p_parent = p_new_item;
    }",5,,838,2,,void
164925,BLOCK,-1,,"{
            input_item_t *p_new_input = input_item_Copy( p_input );

            if( likely(p_new_input != NULL) )
            {
                p_new_item = playlist_NodeAddInput( p_playlist, p_new_input,
                                                    p_parent, i_pos );
                input_item_Release( p_new_input );
            }
        }",9,,842,2,,void
164936,BLOCK,-1,,"{
                p_new_item = playlist_NodeAddInput( p_playlist, p_new_input,
                                                    p_parent, i_pos );
                input_item_Release( p_new_input );
            }",13,,846,2,,void
164947,BLOCK,-1,,"{
            vlc_mutex_lock( &p_input->lock );
            p_new_item = playlist_NodeCreate( p_playlist, p_input->psz_name,
                                              p_parent, i_pos, 0 );
            vlc_mutex_unlock( &p_input->lock );
        }",9,,853,1,,void
164973,BLOCK,-1,,<empty>,13,,860,2,,void
164985,BLOCK,-1,,<empty>,13,,865,2,,void
164990,BLOCK,-1,,<empty>,5,,868,1,,void
165002,BLOCK,4,,"{
        if( b_flat )
            i_pos = RecursiveInsertCopy( p_playlist, p_item->pp_children[i],
                                         p_parent, i_pos, true );
        else
            RecursiveInsertCopy( p_playlist, p_item->pp_children[i],
                                 p_parent, p_parent->i_children, false );
    }",5,,869,4,,void
165005,BLOCK,-1,,<empty>,13,,871,2,,void
165019,BLOCK,-1,,<empty>,13,,874,1,,void
165066,BLOCK,-1,,<empty>,1,,1,1,,ANY
165072,BLOCK,-1,,"{
    playlist_export_t *p_export =
        vlc_custom_create( p_playlist, sizeof( *p_export ), ""playlist export"" );
    if( unlikely(p_export == NULL) )
        return VLC_ENOMEM;

    msg_Dbg( p_export, ""saving %s to file %s"",
             b_playlist ? ""playlist"" : ""media library"", psz_filename );

    int ret = VLC_EGENERIC;

    /* Prepare the playlist_export_t structure */
    p_export->base_url = vlc_path2uri( psz_filename, NULL );
    p_export->p_file = vlc_fopen( psz_filename, ""wt"" );
    if( p_export->p_file == NULL )
    {
        msg_Err( p_export, ""could not create playlist file %s: %s"",
                 psz_filename, vlc_strerror_c(errno) );
        goto out;
    }

    module_t *p_module;

    /* And call the module ! All work is done now */
    playlist_Lock( p_playlist );
    p_export->p_root = b_playlist ? p_playlist->p_playing
                                  : p_playlist->p_media_library;

    p_module = module_need( p_export, ""playlist export"", psz_type, true );...",1,,43,5,,void
165087,BLOCK,-1,,<empty>,9,,47,2,,void
165122,BLOCK,-1,,"{
        msg_Err( p_export, ""could not create playlist file %s: %s"",
                 psz_filename, vlc_strerror_c(errno) );
        goto out;
    }",5,,58,2,,void
165158,BLOCK,-1,,"{
        module_unneed( p_export, p_module );
        if( !ferror( p_export->p_file ) )
            ret = VLC_SUCCESS;
        else
            msg_Err( p_playlist, ""could not write playlist file: %s"",
                     vlc_strerror_c(errno) );
    }",5,,75,2,,void
165168,BLOCK,-1,,<empty>,13,,78,2,,void
165173,BLOCK,-1,,<empty>,13,,80,1,,void
165180,BLOCK,-1,,<empty>,9,,84,1,,void
165202,BLOCK,-1,,"{
    input_item_t *p_input;
    char *psz_uri = vlc_path2uri( psz_file, NULL );

    if( psz_uri == NULL )
        return VLC_EGENERIC;

    p_input = input_item_New( psz_uri, psz_file );
    free( psz_uri );

    playlist_AddInput( p_playlist, p_input, false, true );

    vlc_object_t *dummy = vlc_object_create( p_playlist, sizeof (*dummy) );
    var_Create( dummy, ""meta-file"", VLC_VAR_VOID );

    int ret = input_Read( dummy, p_input );

    vlc_object_release( dummy );
    return ret;
}",1,,93,3,,void
165214,BLOCK,-1,,<empty>,9,,98,2,,void
165256,BLOCK,-1,,"{
    playlist_t *p_playlist = user_data;
    input_item_node_t *p_root =
        p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;
    playlist_InsertInputItemTree ( p_playlist, p_playlist->p_media_library,
                                   p_root, 0, false );
    PL_UNLOCK;
}",1,,119,3,,void
165285,BLOCK,-1,,"{
    char *psz_datadir = config_GetUserDir( VLC_DATA_DIR );
    if( !psz_datadir ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot load media library"") ;
        return VLC_EGENERIC;
    }

    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""ml.xspf"", psz_datadir ) == -1 )
        psz_file = NULL;
    free( psz_datadir );
    if( psz_file == NULL )
        return VLC_ENOMEM;

    /* lousy check for media library file */
    struct stat st;
    if( vlc_stat( psz_file, &st ) )
    {
        free( psz_file );
        return VLC_EGENERIC;
    }

    char *psz_uri = vlc_path2uri( psz_file, ""file/directory"" );
    free( psz_file );
    if( psz_uri == NULL )
        return VLC_ENOMEM;

    input_item_t *p_input = input_item_New( psz_uri, _(""Media Library"") );
    free( psz_uri );
    if( p_input == NULL )
        return VLC_EGENERIC;

    vlc_event_attach( &p_input->event_manager, vlc_InputItemSubItemTreeAdded,
                 ...",1,,131,2,,void
165294,BLOCK,-1,,"{
        msg_Err( p_playlist, ""no data directory, cannot load media library"") ;
        return VLC_EGENERIC;
    }",5,,134,2,,void
165303,BLOCK,-1,,<empty>,9,,141,2,,void
165313,BLOCK,-1,,<empty>,9,,144,2,,void
165322,BLOCK,-1,,"{
        free( psz_file );
        return VLC_EGENERIC;
    }",5,,149,2,,void
165339,BLOCK,-1,,<empty>,9,,157,2,,void
165355,BLOCK,-1,,<empty>,9,,162,2,,void
165399,BLOCK,-1,,"{
    char *psz_temp;

    psz_temp = config_GetUserDir( VLC_DATA_DIR );

    if( !psz_temp ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot save media library"") ;
        return VLC_EGENERIC;
    }

    char psz_dirname[ strlen( psz_temp ) + sizeof( DIR_SEP ""ml.xspf"")];
    strcpy( psz_dirname, psz_temp );
    free( psz_temp );
    if( config_CreateDir( (vlc_object_t *)p_playlist, psz_dirname ) )
    {
        return VLC_EGENERIC;
    }

    strcat( psz_dirname, DIR_SEP ""ml.xspf"" );

    if ( asprintf( &psz_temp, ""%s.tmp%""PRIu32, psz_dirname, (uint32_t)getpid() ) < 1 )
        return VLC_EGENERIC;

    int i_ret = playlist_Export( p_playlist, psz_temp, false, ""export-xspf"" );
    if ( i_ret != VLC_SUCCESS )
    {
        vlc_unlink( psz_temp );
        free( psz_temp );
        return i_ret;
    }

    i_ret = vlc_rename( psz_temp, psz_dirname );
    free( psz_temp );
    if( i_ret == -1 )
    {
        msg_Err( p_playlist, ""could ...",1,,180,2,,void
165408,BLOCK,-1,,"{
        msg_Err( p_playlist, ""no data directory, cannot save media library"") ;
        return VLC_EGENERIC;
    }",5,,186,2,,void
165426,BLOCK,-1,,"{
        return VLC_EGENERIC;
    }",5,,195,2,,void
165432,BLOCK,-1,,<empty>,9,,202,2,,void
165447,BLOCK,-1,,"{
        vlc_unlink( psz_temp );
        free( psz_temp );
        return i_ret;
    }",5,,206,2,,void
165466,BLOCK,-1,,"{
        msg_Err( p_playlist, ""could not rename %s.tmp: %s"",
                 psz_dirname, vlc_strerror_c(errno) );
        return VLC_EGENERIC;
    }",5,,215,2,,void
165491,BLOCK,-1,,<empty>,1,,1,1,,ANY
165496,BLOCK,-1,,<empty>,,,,2,,<empty>
165534,BLOCK,-1,,<empty>,,,,2,,<empty>
165539,BLOCK,-1,,<empty>,,,,2,,<empty>
165544,BLOCK,-1,,<empty>,,,,2,,<empty>
165550,BLOCK,-1,,<empty>,,,,3,,<empty>
165555,BLOCK,-1,,<empty>,,,,2,,<empty>
165560,BLOCK,-1,,<empty>,,,,2,,<empty>
165566,BLOCK,-1,,<empty>,,,,3,,<empty>
165572,BLOCK,-1,,<empty>,,,,3,,<empty>
165577,BLOCK,-1,,<empty>,,,,2,,<empty>
165582,BLOCK,-1,,<empty>,,,,2,,<empty>
165588,BLOCK,-1,,<empty>,,,,3,,<empty>
165597,BLOCK,-1,,<empty>,,,,6,,<empty>
165604,BLOCK,-1,,<empty>,,,,4,,<empty>
165611,BLOCK,-1,,<empty>,,,,4,,<empty>
165617,BLOCK,-1,,<empty>,,,,3,,<empty>
165623,BLOCK,-1,,<empty>,,,,3,,<empty>
165629,BLOCK,-1,,<empty>,,,,3,,<empty>
165638,BLOCK,-1,,<empty>,,,,6,,<empty>
165646,BLOCK,-1,,"{
    if( cond ) PL_LOCK; else PL_ASSERT_LOCKED;
}",1,,184,3,,void
165649,BLOCK,-1,,<empty>,16,,185,2,,void
165652,BLOCK,-1,,<empty>,30,,185,1,,void
165659,BLOCK,-1,,"{
    if( cond ) PL_UNLOCK;
}",1,,190,3,,void
165662,BLOCK,-1,,<empty>,16,,191,2,,void
165684,BLOCK,-1,,<empty>,1,,1,1,,ANY
165697,BLOCK,-1,,"{
    VLC_UNUSED( obj ); VLC_UNUSED( varname ); VLC_UNUSED( old );

    if( cur.i_int == INPUT_EVENT_DEAD )
        background_worker_RequestProbe( worker );

    return VLC_SUCCESS;
}",1,,44,6,,void
165710,BLOCK,-1,,<empty>,9,,48,2,,void
165721,BLOCK,-1,,"{
    playlist_preparser_t* preparser = preparser_;

    input_thread_t* input = input_CreatePreparser( preparser->owner, item_ );
    if( !input )
    {
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    var_AddCallback( input, ""intf-event"", InputEvent, preparser->worker );
    if( input_Start( input ) )
    {
        var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );
        input_Close( input );
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    *out = input;
    return VLC_SUCCESS;
}",1,,54,4,,void
165737,BLOCK,-1,,"{
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }",5,,59,2,,void
165753,BLOCK,-1,,"{
        var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );
        input_Close( input );
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }",5,,66,2,,void
165779,BLOCK,-1,,"{
    int state = input_GetState( input_ );
    return state == END_S || state == ERROR_S;
    VLC_UNUSED( preparser_ );
}",1,,78,3,,void
165800,BLOCK,-1,,"{
    playlist_preparser_t* preparser = preparser_;
    input_thread_t* input = input_;
    input_item_t* item = input_priv(input)->p_item;

    var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );

    int status;
    switch( input_GetState( input ) )
    {
        case END_S:
            status = ITEM_PREPARSE_DONE;
            break;
        case ERROR_S:
            status = ITEM_PREPARSE_FAILED;
            break;
        default:
            status = ITEM_PREPARSE_TIMEOUT;
    }

    input_Stop( input );
    input_Close( input );

    if( preparser->fetcher )
    {
        if( !playlist_fetcher_Push( preparser->fetcher, item, 0, status ) )
            return;
    }

    input_item_SetPreparsed( item, true );
    input_item_SignalPreparseEnded( item, status );
}",1,,85,3,,void
165827,BLOCK,-1,,"{
        case END_S:
            status = ITEM_PREPARSE_DONE;
            break;
        case ERROR_S:
            status = ITEM_PREPARSE_FAILED;
            break;
        default:
            status = ITEM_PREPARSE_TIMEOUT;
    }",5,,94,2,,void
165852,BLOCK,-1,,"{
        if( !playlist_fetcher_Push( preparser->fetcher, item, 0, status ) )
            return;
    }",5,,109,2,,void
165862,BLOCK,-1,,<empty>,13,,111,2,,void
165874,BLOCK,-1,,{ input_item_Release( item ); },44,,118,2,,void
165881,BLOCK,-1,,{ input_item_Hold( item ); },41,,119,2,,void
165888,BLOCK,-1,,"{
    playlist_preparser_t* preparser = malloc( sizeof *preparser );

    struct background_worker_config conf = {
        .default_timeout = var_InheritInteger( parent, ""preparse-timeout"" ),
        .pf_start = PreparserOpenInput,
        .pf_probe = PreparserProbeInput,
        .pf_stop = PreparserCloseInput,
        .pf_release = InputItemRelease,
        .pf_hold = InputItemHold };


    if( likely( preparser ) )
        preparser->worker = background_worker_New( preparser, &conf );

    if( unlikely( !preparser || !preparser->worker ) )
    {
        free( preparser );
        return NULL;
    }

    preparser->owner = parent;
    preparser->fetcher = playlist_fetcher_New( parent );
    atomic_init( &preparser->deactivated, false );

    if( unlikely( !preparser->fetcher ) )
        msg_Warn( parent, ""unable to create art fetcher"" );

    return preparser;
}",1,,122,2,,void
165900,BLOCK,1,,<empty>,9,,126,1,,void
165906,BLOCK,2,,<empty>,9,,127,2,,void
165910,BLOCK,3,,<empty>,9,,128,3,,void
165914,BLOCK,4,,<empty>,9,,129,4,,void
165918,BLOCK,5,,<empty>,9,,130,5,,void
165922,BLOCK,6,,<empty>,9,,131,6,,void
165929,BLOCK,-1,,<empty>,9,,135,2,,void
165947,BLOCK,-1,,"{
        free( preparser );
        return NULL;
    }",5,,138,2,,void
165975,BLOCK,-1,,<empty>,9,,148,2,,void
165989,BLOCK,-1,,"{
    if( atomic_load( &preparser->deactivated ) )
        return;

    vlc_mutex_lock( &item->lock );
    int i_type = item->i_type;
    int b_net = item->b_net;
    vlc_mutex_unlock( &item->lock );

    switch( i_type )
    {
        case ITEM_TYPE_NODE:
        case ITEM_TYPE_FILE:
        case ITEM_TYPE_DIRECTORY:
        case ITEM_TYPE_PLAYLIST:
            if( !b_net || i_options & META_REQUEST_OPTION_SCOPE_NETWORK )
                break;
        default:
            input_item_SignalPreparseEnded( item, ITEM_PREPARSE_SKIPPED );
            return;
    }

    if( background_worker_Push( preparser->worker, item, id, timeout ) )
        input_item_SignalPreparseEnded( item, ITEM_PREPARSE_FAILED );
}",1,,156,6,,void
165996,BLOCK,-1,,<empty>,9,,158,2,,void
166022,BLOCK,-1,,"{
        case ITEM_TYPE_NODE:
        case ITEM_TYPE_FILE:
        case ITEM_TYPE_DIRECTORY:
        case ITEM_TYPE_PLAYLIST:
            if( !b_net || i_options & META_REQUEST_OPTION_SCOPE_NETWORK )
                break;
        default:
            input_item_SignalPreparseEnded( item, ITEM_PREPARSE_SKIPPED );
            return;
    }",5,,166,2,,void
166038,BLOCK,-1,,<empty>,17,,172,2,,void
166053,BLOCK,-1,,<empty>,9,,179,2,,void
166063,BLOCK,-1,,"{
    if( preparser->fetcher )
        playlist_fetcher_Push( preparser->fetcher, item, options, -1 );
}",1,,184,4,,void
166068,BLOCK,-1,,<empty>,9,,186,2,,void
166082,BLOCK,-1,,"{
    background_worker_Cancel( preparser->worker, id );
}",1,,190,3,,void
166092,BLOCK,-1,,"{
    atomic_store( &preparser->deactivated, true );
    background_worker_Cancel( preparser->worker, NULL );
}",1,,195,2,,void
166108,BLOCK,-1,,"{
    background_worker_Delete( preparser->worker );

    if( preparser->fetcher )
        playlist_fetcher_Delete( preparser->fetcher );

    free( preparser );
}",1,,201,2,,void
166117,BLOCK,-1,,<empty>,9,,205,2,,void
166132,BLOCK,-1,,<empty>,1,,1,1,,ANY
166137,BLOCK,-1,,<empty>,,,,2,,<empty>
166146,BLOCK,-1,,<empty>,,,,6,,<empty>
166153,BLOCK,-1,,<empty>,,,,4,,<empty>
166159,BLOCK,-1,,<empty>,,,,3,,<empty>
166164,BLOCK,-1,,<empty>,,,,2,,<empty>
166169,BLOCK,-1,,<empty>,,,,2,,<empty>
166186,BLOCK,-1,,<empty>,1,,1,1,,ANY
166190,BLOCK,-1,,"{
    if( p_item )
        vlc_renderer_item_hold( p_item );

    PL_LOCK;

    playlist_private_t *p_priv = pl_priv( p_playlist );
    vlc_renderer_item_t *p_prev_renderer = p_priv->p_renderer;
    p_priv->p_renderer = p_item;
    if( p_priv->p_input )
        input_Control( p_priv->p_input, INPUT_SET_RENDERER, p_item );

    PL_UNLOCK;

    if( p_prev_renderer )
        vlc_renderer_item_release( p_prev_renderer );
    return VLC_SUCCESS;
}",1,,34,3,,void
166193,BLOCK,-1,,<empty>,9,,36,2,,void
166202,BLOCK,1,,<empty>,,,,2,,void
166222,BLOCK,-1,,<empty>,9,,44,2,,void
166232,BLOCK,-1,,<empty>,9,,49,2,,void
166255,BLOCK,-1,,<empty>,1,,1,1,,ANY
166258,BLOCK,-1,,"{
    for( int i = 0; i < p_root->i_children; i++ )
    {
        playlist_item_t *p_item = p_root->pp_children[i];
        if( p_item->i_children >= 0 )
            playlist_LiveSearchClean( p_item );
        p_item->i_flags &= ~PLAYLIST_DBL_FLAG;
    }
}",1,,46,2,,void
166260,BLOCK,-1,,<empty>,5,,47,1,,void
166272,BLOCK,4,,"{
        playlist_item_t *p_item = p_root->pp_children[i];
        if( p_item->i_children >= 0 )
            playlist_LiveSearchClean( p_item );
        p_item->i_flags &= ~PLAYLIST_DBL_FLAG;
    }",5,,48,4,,void
166287,BLOCK,-1,,<empty>,13,,51,2,,void
166302,BLOCK,-1,,"{
    int i;
    bool b_match = false;
    for( i = 0 ; i < p_root->i_children ; i ++ )
    {
        bool b_enable = false;
        playlist_item_t *p_item = p_root->pp_children[i];
        // Go recurssively if their is some children
        if( b_recursive && p_item->i_children >= 0 &&
            playlist_LiveSearchUpdateInternal( p_item, psz_string, true ) )
        {
            b_enable = true;
        }

        if( !b_enable )
        {
            vlc_mutex_lock( &p_item->p_input->lock );
            // Do we have some meta ?
            if( p_item->p_input->p_meta )
            {
                // Use Title or fall back to psz_name
                const char *psz_title = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Title );
                if( !psz_title )
                    psz_title = p_item->p_input->psz_name;
                const char *psz_album = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Album );
                const char *psz_artist = vlc_meta_Get( p_it...",1,,65,4,,void
166309,BLOCK,-1,,<empty>,5,,68,1,,void
166320,BLOCK,4,,"{
        bool b_enable = false;
        playlist_item_t *p_item = p_root->pp_children[i];
        // Go recurssively if their is some children
        if( b_recursive && p_item->i_children >= 0 &&
            playlist_LiveSearchUpdateInternal( p_item, psz_string, true ) )
        {
            b_enable = true;
        }

        if( !b_enable )
        {
            vlc_mutex_lock( &p_item->p_input->lock );
            // Do we have some meta ?
            if( p_item->p_input->p_meta )
            {
                // Use Title or fall back to psz_name
                const char *psz_title = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Title );
                if( !psz_title )
                    psz_title = p_item->p_input->psz_name;
                const char *psz_album = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Album );
                const char *psz_artist = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Artist );
                b_enable = ( psz_title && vlc_strcas...",5,,69,4,,void
166346,BLOCK,-1,,"{
            b_enable = true;
        }",9,,75,2,,void
166353,BLOCK,-1,,"{
            vlc_mutex_lock( &p_item->p_input->lock );
            // Do we have some meta ?
            if( p_item->p_input->p_meta )
            {
                // Use Title or fall back to psz_name
                const char *psz_title = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Title );
                if( !psz_title )
                    psz_title = p_item->p_input->psz_name;
                const char *psz_album = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Album );
                const char *psz_artist = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Artist );
                b_enable = ( psz_title && vlc_strcasestr( psz_title, psz_string ) ) ||
                           ( psz_album && vlc_strcasestr( psz_album, psz_string ) ) ||
                           ( psz_artist && vlc_strcasestr( psz_artist, psz_string ) );
            }
            else
                b_enable = p_item->p_input->psz_name && vlc_strcasestr( p_item->p_input->psz_name, psz_string );
   ...",9,,80,2,,void
166367,BLOCK,-1,,"{
                // Use Title or fall back to psz_name
                const char *psz_title = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Title );
                if( !psz_title )
                    psz_title = p_item->p_input->psz_name;
                const char *psz_album = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Album );
                const char *psz_artist = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Artist );
                b_enable = ( psz_title && vlc_strcasestr( psz_title, psz_string ) ) ||
                           ( psz_album && vlc_strcasestr( psz_album, psz_string ) ) ||
                           ( psz_artist && vlc_strcasestr( psz_artist, psz_string ) );
            }",13,,84,2,,void
166381,BLOCK,-1,,<empty>,21,,88,2,,void
166429,BLOCK,-1,,<empty>,17,,96,1,,void
166454,BLOCK,-1,,<empty>,13,,101,2,,void
166462,BLOCK,-1,,<empty>,13,,103,1,,void
166480,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;
    pl_priv(p_playlist)->b_reset_currently_playing = true;
    if( *psz_string )
        playlist_LiveSearchUpdateInternal( p_root, psz_string, b_recursive );
    else
        playlist_LiveSearchClean( p_root );
    vlc_cond_signal( &pl_priv(p_playlist)->signal );
    return VLC_SUCCESS;
}",1,,121,5,,void
166485,BLOCK,1,,<empty>,,,,2,,void
166496,BLOCK,-1,,<empty>,9,,125,2,,void
166502,BLOCK,-1,,<empty>,9,,127,1,,void
166509,BLOCK,1,,<empty>,,,,2,,void
166536,BLOCK,-1,,<empty>,1,,1,1,,ANY
166542,BLOCK,-1,,<empty>,,,,1,,<empty>
166551,BLOCK,-1,,"{
    assert(parent == NULL || psz_cat == NULL);

    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node;
    const char *longname = (sd->description != NULL) ? sd->description : ""?"";

    msg_Dbg(sd, ""adding: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    if (sds->node == NULL)
        sds->node = playlist_NodeCreate(playlist, longname, &playlist->root,
                                        PLAYLIST_END, PLAYLIST_RO_FLAG);

    if (parent != NULL)
        node = playlist_ItemGetByInput(playlist, parent);
    else
    if (psz_cat == NULL)
        node = sds->node;
    else
    {   /* Parent is NULL (root) and category is specified.
         * This is clearly a hack. TODO: remove this. */
        node = playlist_ChildSearchName(sds->node, psz_cat);
        if (node == NULL)
            node = playlist_NodeCreate(playlist, psz_cat, sds->node,
                           ...",1,,45,5,,void
166611,BLOCK,-1,,<empty>,9,,57,2,,void
166629,BLOCK,-1,,<empty>,9,,61,2,,void
166636,BLOCK,-1,,<empty>,5,,63,1,,void
166641,BLOCK,-1,,<empty>,9,,64,2,,void
166648,BLOCK,-1,,"{   /* Parent is NULL (root) and category is specified.
         * This is clearly a hack. TODO: remove this. */
        node = playlist_ChildSearchName(sds->node, psz_cat);
        if (node == NULL)
            node = playlist_NodeCreate(playlist, psz_cat, sds->node,
                                       PLAYLIST_END, PLAYLIST_RO_FLAG);
    }",5,,66,1,,void
166660,BLOCK,-1,,<empty>,13,,70,2,,void
166683,BLOCK,-1,,"{
    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node, *item;

    msg_Dbg(sd, ""removing: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    item = playlist_ItemGetByInput(playlist, p_input);
    if (unlikely(item == NULL))
    {
        msg_Err(sd, ""removing item not added""); /* SD plugin bug */
        playlist_Unlock(playlist);
        return;
    }

#ifndef NDEBUG
    /* Check that the item belonged to the SD */
    for (playlist_item_t *i = item->p_parent; i != sds->node; i = i->p_parent)
        assert(i != NULL);
#endif

    node = item->p_parent;
    /* if the item was added under a category and the category node
       becomes empty, delete that node as well */
    if (node != sds->node && node->i_children == 1)
        item = node;
    playlist_NodeDeleteExplicit(playlist, item,
        PLAYLIST_DELETE_FORCE | PLAYLIST_DELETE_STOP_IF_CURRENT );
    playlist_Unl...",1,,81,3,,void
166727,BLOCK,-1,,"{
        msg_Err(sd, ""removing item not added""); /* SD plugin bug */
        playlist_Unlock(playlist);
        return;
    }",5,,91,2,,void
166735,BLOCK,-1,,<empty>,5,,99,1,,void
166773,BLOCK,-1,,<empty>,9,,107,2,,void
166782,BLOCK,1,,<empty>,,,,1,,void
166785,BLOCK,1,,<empty>,,,,1,,void
166794,BLOCK,-1,,"{
    vlc_sd_internal_t *sds = malloc(sizeof (*sds) + strlen(chain) + 1);
    if (unlikely(sds == NULL))
        return VLC_ENOMEM;

    sds->node = NULL;

    struct services_discovery_owner_t owner = {
        sds,
        playlist_sd_item_added,
        playlist_sd_item_removed,
    };

    /* Perform the addition */
    sds->sd = vlc_sd_Create(VLC_OBJECT(playlist), chain, &owner);
    if (unlikely(sds->sd == NULL))
    {
        free(sds);
        return VLC_ENOMEM;
    }

    strcpy(sds->name, chain);

    playlist_Lock(playlist);
    /* Backward compatibility with Qt UI: create the node even if the SD
     * has not discovered any item. */
    if (sds->node == NULL && sds->sd->description != NULL)
        sds->node = playlist_NodeCreate(playlist, sds->sd->description,
                                        &playlist->root, PLAYLIST_END,
                                        PLAYLIST_RO_FLAG);

    TAB_APPEND(pl_priv(playlist)->i_sds, pl_priv(playlist)->pp_sds, sds);
    pla...",1,,114,3,,void
166812,BLOCK,-1,,<empty>,9,,117,2,,void
166844,BLOCK,-1,,"{
        free(sds);
        return VLC_ENOMEM;
    }",5,,130,2,,void
166870,BLOCK,-1,,<empty>,9,,141,2,,void
166891,BLOCK,1,,<empty>,,,,2,,void
166900,BLOCK,1,,<empty>,,,,2,,void
166917,BLOCK,-1,,"{
    assert(sds->sd != NULL);

    playlist_Unlock(playlist);

    vlc_sd_Destroy(sds->sd);
    /* Remove the sd playlist node if it exists */
    playlist_Lock(playlist);

    if (sds->node != NULL)
        playlist_NodeDeleteExplicit(playlist, sds->node,
            PLAYLIST_DELETE_FORCE | PLAYLIST_DELETE_STOP_IF_CURRENT );

    free(sds);
}",1,,152,3,,void
166938,BLOCK,-1,,<empty>,9,,162,2,,void
166946,BLOCK,1,,<empty>,,,,1,,void
166949,BLOCK,1,,<empty>,,,,1,,void
166958,BLOCK,-1,,"{
    playlist_private_t *priv = pl_priv(playlist);
    vlc_sd_internal_t *sds = NULL;

    playlist_Lock(playlist);
    for (int i = 0; i < priv->i_sds; i++)
    {
        vlc_sd_internal_t *entry = priv->pp_sds[i];

        if (!strcmp(name, entry->name))
        {
            TAB_ERASE(priv->i_sds, priv->pp_sds, i);
            sds = entry;
            break;
        }
    }

    if (sds == NULL)
    {
        msg_Warn(playlist, ""discovery %s is not loaded"", name);
        playlist_Unlock(playlist);
        return VLC_EGENERIC;
    }

    playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);

    playlist_Unlock(playlist);

    return VLC_SUCCESS;
}",1,,169,3,,void
166964,BLOCK,1,,<empty>,,,,2,,void
166976,BLOCK,-1,,<empty>,5,,174,1,,void
166988,BLOCK,4,,"{
        vlc_sd_internal_t *entry = priv->pp_sds[i];

        if (!strcmp(name, entry->name))
        {
            TAB_ERASE(priv->i_sds, priv->pp_sds, i);
            sds = entry;
            break;
        }
    }",5,,175,4,,void
167004,BLOCK,-1,,"{
            TAB_ERASE(priv->i_sds, priv->pp_sds, i);
            sds = entry;
            break;
        }",9,,179,2,,void
167021,BLOCK,-1,,"{
        msg_Warn(playlist, ""discovery %s is not loaded"", name);
        playlist_Unlock(playlist);
        return VLC_EGENERIC;
    }",5,,187,2,,void
167042,BLOCK,-1,,"{
    playlist_private_t *priv = pl_priv( playlist );
    bool found = false;
    playlist_Lock(playlist);

    for( int i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];

        if (!strcmp(psz_name, sds->name))
        {
            found = true;
            break;
        }
    }
    playlist_Unlock(playlist);
    return found;
}",1,,202,3,,void
167048,BLOCK,1,,<empty>,,,,2,,void
167060,BLOCK,-1,,<empty>,5,,207,1,,void
167072,BLOCK,4,,"{
        vlc_sd_internal_t *sds = priv->pp_sds[i];

        if (!strcmp(psz_name, sds->name))
        {
            found = true;
            break;
        }
    }",5,,208,4,,void
167088,BLOCK,-1,,"{
            found = true;
            break;
        }",9,,212,2,,void
167103,BLOCK,-1,,"{
    playlist_private_t *priv = pl_priv( playlist );
    int i_ret = VLC_EGENERIC;
    int i;

    playlist_Lock(playlist);
    for( i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];
        if (!strcmp(psz_name, sds->name))
        {
            va_list args;
            va_start( args, i_control );
            i_ret = vlc_sd_control(sds->sd, i_control, args );
            va_end( args );
            break;
        }
    }

    assert( i != priv->i_sds );
    playlist_Unlock(playlist);

    return i_ret;
}",1,,222,4,,void
167109,BLOCK,1,,<empty>,,,,2,,void
167122,BLOCK,-1,,<empty>,5,,228,1,,void
167133,BLOCK,4,,"{
        vlc_sd_internal_t *sds = priv->pp_sds[i];
        if (!strcmp(psz_name, sds->name))
        {
            va_list args;
            va_start( args, i_control );
            i_ret = vlc_sd_control(sds->sd, i_control, args );
            va_end( args );
            break;
        }
    }",5,,229,4,,void
167149,BLOCK,-1,,"{
            va_list args;
            va_start( args, i_control );
            i_ret = vlc_sd_control(sds->sd, i_control, args );
            va_end( args );
            break;
        }",9,,232,2,,void
167179,BLOCK,-1,,"{
    playlist_private_t *priv = pl_priv(playlist);

    playlist_Lock(playlist);
    while (priv->i_sds > 0)
    {
        vlc_sd_internal_t *sds = priv->pp_sds[priv->i_sds - 1];
        TAB_ERASE(priv->i_sds, priv->pp_sds, priv->i_sds - 1);

        playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);
    }

    playlist_Unlock(playlist);
}",1,,248,2,,void
167185,BLOCK,1,,<empty>,,,,2,,void
167198,BLOCK,-1,,"{
        vlc_sd_internal_t *sds = priv->pp_sds[priv->i_sds - 1];
        TAB_ERASE(priv->i_sds, priv->pp_sds, priv->i_sds - 1);

        playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);
    }",5,,253,2,,void
167244,BLOCK,-1,,<empty>,1,,1,1,,ANY
167248,BLOCK,-1,,"{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;
    free( psz_first );
    free( psz_second );

    return i_ret;
}",1,,45,3,,void
167268,BLOCK,-1,,<empty>,9,,51,2,,void
167275,BLOCK,-1,,<empty>,10,,52,1,,void
167281,BLOCK,-1,,<empty>,9,,53,2,,void
167286,BLOCK,-1,,<empty>,10,,54,1,,void
167292,BLOCK,-1,,<empty>,9,,55,2,,void
167298,BLOCK,-1,,<empty>,9,,57,1,,void
167315,BLOCK,-1,,"{
    int i_ret;
    char *psz_first = input_item_GetMeta( first->p_input, meta );
    char *psz_second = input_item_GetMeta( second->p_input, meta );

    /* Nodes go first */
    if( first->i_children == -1 && second->i_children >= 0 )
        i_ret = 1;
    else if( first->i_children >= 0 && second->i_children == -1 )
       i_ret = -1;
    /* Both are nodes, sort by name */
    else if( first->i_children >= 0 && second->i_children >= 0 )
        i_ret = meta_strcasecmp_title( first, second );
    /* Both are items */
    else if( !psz_first && !psz_second )
        i_ret = 0;
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
    {
        if( b_integer )
            i_ret = atoi( psz_first ) - atoi( psz_second );
        else
            i_ret = strcasecmp( psz_first, psz_second );
    }

    free( psz_first );
    free( psz_second );
    return i_ret;
}",1,,75,5,,void
167346,BLOCK,-1,,<empty>,9,,82,2,,void
167351,BLOCK,-1,,<empty>,10,,83,1,,void
167365,BLOCK,-1,,<empty>,8,,84,2,,void
167371,BLOCK,-1,,<empty>,10,,86,1,,void
167384,BLOCK,-1,,<empty>,9,,87,2,,void
167391,BLOCK,-1,,<empty>,10,,89,1,,void
167398,BLOCK,-1,,<empty>,9,,90,2,,void
167403,BLOCK,-1,,<empty>,10,,91,1,,void
167409,BLOCK,-1,,<empty>,9,,92,2,,void
167414,BLOCK,-1,,<empty>,10,,93,1,,void
167420,BLOCK,-1,,<empty>,9,,94,2,,void
167426,BLOCK,-1,,"{
        if( b_integer )
            i_ret = atoi( psz_first ) - atoi( psz_second );
        else
            i_ret = strcasecmp( psz_first, psz_second );
    }",5,,96,1,,void
167429,BLOCK,-1,,<empty>,13,,98,2,,void
167438,BLOCK,-1,,<empty>,13,,100,1,,void
167455,BLOCK,-1,,<empty>,,,,3,,<empty>
167465,BLOCK,-1,,"{
    if( i_mode>=NUM_SORT_FNS || i_type>1 )
        return 0;
    return sorting_fns[i_mode][i_type];
}",1,,120,3,,void
167474,BLOCK,-1,,<empty>,9,,122,2,,void
167489,BLOCK,-1,,"{
    if( p_sortfn )
    {
        qsort( pp_items, i_items, sizeof( pp_items[0] ), p_sortfn );
    }
    else /* Randomise */
    {
        unsigned i_position;
        unsigned i_new;
        playlist_item_t *p_temp;

        for( i_position = i_items - 1; i_position > 0; i_position-- )
        {
            i_new = ((unsigned)vlc_mrand48()) % (i_position+1);
            p_temp = pp_items[i_position];
            pp_items[i_position] = pp_items[i_new];
            pp_items[i_new] = p_temp;
        }
    }
}",1,,136,4,,void
167492,BLOCK,-1,,"{
        qsort( pp_items, i_items, sizeof( pp_items[0] ), p_sortfn );
    }",5,,138,2,,void
167502,BLOCK,-1,,"{
        unsigned i_position;
        unsigned i_new;
        playlist_item_t *p_temp;

        for( i_position = i_items - 1; i_position > 0; i_position-- )
        {
            i_new = ((unsigned)vlc_mrand48()) % (i_position+1);
            p_temp = pp_items[i_position];
            pp_items[i_position] = pp_items[i_new];
            pp_items[i_new] = p_temp;
        }
    }",5,,142,1,,void
167507,BLOCK,-1,,<empty>,9,,147,1,,void
167518,BLOCK,4,,"{
            i_new = ((unsigned)vlc_mrand48()) % (i_position+1);
            p_temp = pp_items[i_position];
            pp_items[i_position] = pp_items[i_new];
            pp_items[i_new] = p_temp;
        }",9,,148,4,,void
167551,BLOCK,-1,,"{
    int i;
    playlist_ItemArraySort(p_node->i_children,p_node->pp_children,p_sortfn);
    for( i = 0 ; i< p_node->i_children; i++ )
    {
        if( p_node->pp_children[i]->i_children != -1 )
        {
            recursiveNodeSort( p_playlist, p_node->pp_children[i], p_sortfn );
        }
    }
    return VLC_SUCCESS;
}",1,,168,4,,void
167562,BLOCK,-1,,<empty>,5,,171,1,,void
167573,BLOCK,4,,"{
        if( p_node->pp_children[i]->i_children != -1 )
        {
            recursiveNodeSort( p_playlist, p_node->pp_children[i], p_sortfn );
        }
    }",5,,172,4,,void
167585,BLOCK,-1,,"{
            recursiveNodeSort( p_playlist, p_node->pp_children[i], p_sortfn );
        }",9,,174,2,,void
167603,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    /* Ask the playlist to reset as we are changing the order */
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    /* Do the real job recursively */
    return recursiveNodeSort(p_playlist,p_node,find_sorting_fn(i_mode,i_type));
}",1,,194,5,,void
167608,BLOCK,1,,<empty>,,,,2,,void
167628,BLOCK,-1,,"{
    return meta_sort( first, second, vlc_meta_TrackNumber, true );
}",1,,219,3,,void
167640,BLOCK,-1,,"{
    int i_ret = meta_sort( first, second, vlc_meta_DiscNumber, true );
    /* Items came from the same disc: compare the track numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_TRACK_NUMBER( first, second );

    return i_ret;
}",1,,224,3,,void
167653,BLOCK,-1,,<empty>,9,,228,2,,void
167666,BLOCK,-1,,"{
    int i_ret = meta_sort( first, second, vlc_meta_Album, false );
    /* Items came from the same album: compare the disc numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_DISC_NUMBER( first, second );

    return i_ret;
}",1,,234,3,,void
167679,BLOCK,-1,,<empty>,9,,238,2,,void
167692,BLOCK,-1,,"{
    int i_ret = meta_sort( first, second, vlc_meta_Date, true );
    /* Items came from the same date: compare the albums */
    if( i_ret == 0 )
        i_ret = proto_SORT_ALBUM( first, second );

    return i_ret;
}",1,,244,3,,void
167705,BLOCK,-1,,<empty>,9,,248,2,,void
167718,BLOCK,-1,,"{
    int i_ret = meta_sort( first, second, vlc_meta_Artist, false );
    /* Items came from the same artist: compare the dates */
    if( i_ret == 0 )
        i_ret = proto_SORT_DATE( first, second );

    return i_ret;
}",1,,254,3,,void
167731,BLOCK,-1,,<empty>,9,,258,2,,void
167744,BLOCK,-1,,"{
    return meta_sort( first, second, vlc_meta_Description, false );
}",1,,264,3,,void
167756,BLOCK,-1,,"{
    mtime_t time1 = input_item_GetDuration( first->p_input );
    mtime_t time2 = input_item_GetDuration( second->p_input );
    int i_ret = time1 > time2 ? 1 :
                    ( time1 == time2 ? 0 : -1 );
    return i_ret;
}",1,,269,3,,void
167793,BLOCK,-1,,"{
    return meta_sort( first, second, vlc_meta_Genre, false );
}",1,,278,3,,void
167805,BLOCK,-1,,"{
    return first->i_id - second->i_id;
}",1,,283,3,,void
167819,BLOCK,-1,,"{
    return meta_sort( first, second, vlc_meta_Rating, true );
}",1,,288,3,,void
167831,BLOCK,-1,,"{
    return meta_strcasecmp_title( first, second );
}",1,,293,3,,void
167841,BLOCK,-1,,"{
    /* If first is a node but not second */
    if( first->i_children == -1 && second->i_children >= 0 )
        return -1;
    /* If second is a node but not first */
    else if( first->i_children >= 0 && second->i_children == -1 )
        return 1;
    /* Both are nodes or both are not nodes */
    else
        return meta_strcasecmp_title( first, second );
}",1,,298,3,,void
167855,BLOCK,-1,,<empty>,9,,301,2,,void
167860,BLOCK,-1,,<empty>,10,,303,1,,void
167874,BLOCK,-1,,<empty>,9,,304,2,,void
167878,BLOCK,-1,,<empty>,9,,307,1,,void
167888,BLOCK,-1,,"{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = atoi( psz_first ) - atoi( psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",1,,311,3,,void
167908,BLOCK,-1,,<empty>,9,,317,2,,void
167917,BLOCK,-1,,<empty>,10,,318,1,,void
167923,BLOCK,-1,,<empty>,9,,319,2,,void
167928,BLOCK,-1,,<empty>,10,,320,1,,void
167934,BLOCK,-1,,<empty>,9,,321,2,,void
167940,BLOCK,-1,,<empty>,9,,323,1,,void
167955,BLOCK,-1,,"{
    int i_ret;
    char *psz_first = input_item_GetURI( first->p_input );
    char *psz_second = input_item_GetURI( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",1,,331,3,,void
167975,BLOCK,-1,,<empty>,9,,337,2,,void
167982,BLOCK,-1,,<empty>,10,,338,1,,void
167988,BLOCK,-1,,<empty>,9,,339,2,,void
167993,BLOCK,-1,,<empty>,10,,340,1,,void
167999,BLOCK,-1,,<empty>,9,,341,2,,void
168005,BLOCK,-1,,<empty>,9,,343,1,,void
168047,BLOCK,-1,,<empty>,1,,1,1,,ANY
168050,BLOCK,-1,,<empty>,,,,2,,<empty>
168055,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    if( vlc_clone( &p_sys->thread, Thread, p_playlist,
                   VLC_THREAD_PRIORITY_LOW ) )
    {
        msg_Err( p_playlist, ""cannot spawn playlist thread"" );
        abort();
    }
}",1,,52,2,,void
168061,BLOCK,1,,<empty>,,,,2,,void
168075,BLOCK,-1,,"{
        msg_Err( p_playlist, ""cannot spawn playlist thread"" );
        abort();
    }",5,,57,2,,void
168084,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_LOCK;
    /* WARNING: There is a latent bug. It is assumed that only one thread will
     * be waiting for playlist deactivation at a time. So far, that works
     * as playlist_Deactivate() is only ever called while closing an
     * interface and interfaces are shut down serially by intf_DestroyAll(). */
    if( p_sys->killed )
    {
        PL_UNLOCK;
        return;
    }

    msg_Dbg( p_playlist, ""deactivating the playlist"" );
    p_sys->killed = true;
    vlc_cond_signal( &p_sys->signal );
    PL_UNLOCK;

    vlc_join( p_sys->thread, NULL );
}",1,,69,2,,void
168090,BLOCK,1,,<empty>,,,,2,,void
168100,BLOCK,-1,,"{
        PL_UNLOCK;
        return;
    }",5,,78,2,,void
168130,BLOCK,-1,,"{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    playlist_t *p_playlist = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD )
    {
        playlist_private_t *sys = pl_priv(p_playlist);

        PL_LOCK;
        sys->request.input_dead = true;
        vlc_cond_signal( &sys->signal );
        PL_UNLOCK;
    }
    return VLC_SUCCESS;
}",1,,96,6,,void
168147,BLOCK,-1,,"{
        playlist_private_t *sys = pl_priv(p_playlist);

        PL_LOCK;
        sys->request.input_dead = true;
        vlc_cond_signal( &sys->signal );
        PL_UNLOCK;
    }",5,,101,2,,void
168153,BLOCK,1,,<empty>,,,,3,,void
168179,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    PL_DEBUG( ""resyncing on %s"", PLI_NAME( p_cur ) );
    /* Simply resync index */
    int i;
    p_playlist->i_current_index = -1;
    for( i = 0 ; i< p_playlist->current.i_size; i++ )
    {
        if( ARRAY_VAL( p_playlist->current, i ) == p_cur )
        {
            p_playlist->i_current_index = i;
            break;
        }
    }
    PL_DEBUG( ""%s is at %i"", PLI_NAME( p_cur ), p_playlist->i_current_index );
}",1,,121,3,,void
168182,BLOCK,1,,<empty>,,,,1,,void
168206,BLOCK,-1,,<empty>,5,,128,1,,void
168219,BLOCK,4,,"{
        if( ARRAY_VAL( p_playlist->current, i ) == p_cur )
        {
            p_playlist->i_current_index = i;
            break;
        }
    }",5,,129,4,,void
168228,BLOCK,-1,,"{
            p_playlist->i_current_index = i;
            break;
        }",9,,131,2,,void
168236,BLOCK,1,,<empty>,,,,1,,void
168260,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_DEBUG( ""rebuilding array of current - root %s"",
              PLI_NAME( p_sys->status.p_node ) );
    ARRAY_RESET( p_playlist->current );
    p_playlist->i_current_index = -1;
    for( playlist_item_t *p_next = NULL; ; )
    {
        /** FIXME: this is *slow* */
        p_next = playlist_GetNextLeaf( p_playlist,
                                       p_sys->status.p_node,
                                       p_next, true, false );
        if( !p_next )
            break;

        if( p_next == p_cur )
            p_playlist->i_current_index = p_playlist->current.i_size;
        ARRAY_APPEND( p_playlist->current, p_next);
    }
    PL_DEBUG(""rebuild done - %i items, index %i"", p_playlist->current.i_size,
                                                  p_playlist->i_current_index);

    if( var_GetBool( p_playlist, ""random"" ) && ( p_playlist->current.i_size > 0 ) )
    {
        /* Shuffle the array */
        for( un...",1,,148,3,,void
168266,BLOCK,1,,<empty>,,,,2,,void
168272,BLOCK,1,,<empty>,,,,4,,void
168311,BLOCK,-1,,<empty>,5,,155,1,,void
168316,BLOCK,4,,"{
        /** FIXME: this is *slow* */
        p_next = playlist_GetNextLeaf( p_playlist,
                                       p_sys->status.p_node,
                                       p_next, true, false );
        if( !p_next )
            break;

        if( p_next == p_cur )
            p_playlist->i_current_index = p_playlist->current.i_size;
        ARRAY_APPEND( p_playlist->current, p_next);
    }",5,,156,4,,void
168332,BLOCK,-1,,<empty>,13,,162,2,,void
168338,BLOCK,-1,,<empty>,13,,165,2,,void
168354,BLOCK,1,,<empty>,,,,1,,void
168378,BLOCK,-1,,"{
        /* Shuffle the array */
        for( unsigned j = p_playlist->current.i_size - 1; j > 0; j-- )
        {
            unsigned i = vlc_lrand48() % (j+1); /* between 0 and j */
            playlist_item_t *p_tmp;
            /* swap the two items */
            p_tmp = ARRAY_VAL(p_playlist->current, i);
            ARRAY_VAL(p_playlist->current,i) = ARRAY_VAL(p_playlist->current,j);
            ARRAY_VAL(p_playlist->current,j) = p_tmp;
        }
    }",5,,172,2,,void
168380,BLOCK,-1,,<empty>,9,,174,1,,void
168396,BLOCK,4,,"{
            unsigned i = vlc_lrand48() % (j+1); /* between 0 and j */
            playlist_item_t *p_tmp;
            /* swap the two items */
            p_tmp = ARRAY_VAL(p_playlist->current, i);
            ARRAY_VAL(p_playlist->current,i) = ARRAY_VAL(p_playlist->current,j);
            ARRAY_VAL(p_playlist->current,j) = p_tmp;
        }",9,,175,4,,void
168441,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_item_t *p_input = p_item->p_input;
    vlc_renderer_item_t *p_renderer;

    PL_ASSERT_LOCKED;

    msg_Dbg( p_playlist, ""creating new input thread"" );

    p_item->i_nb_played++;
    set_current_status_item( p_playlist, p_item );
    p_renderer = p_sys->p_renderer;
    /* Retain the renderer now to avoid it to be released by
     * playlist_SetRenderer when we exit the locked scope. If the last reference
     * was to be released, we would use a dangling pointer */
    if( p_renderer )
        vlc_renderer_item_hold( p_renderer );
    assert( p_sys->p_input == NULL );
    PL_UNLOCK;

    libvlc_MetadataCancel( p_playlist->obj.libvlc, p_item );

    input_thread_t *p_input_thread = input_Create( p_playlist, p_input, NULL,
                                                   p_sys->p_input_resource,
                                                   p_renderer );
    if( p_renderer )
        vlc_renderer_item_release( p_r...",1,,195,3,,void
168447,BLOCK,1,,<empty>,,,,2,,void
168477,BLOCK,-1,,<empty>,9,,211,2,,void
168507,BLOCK,-1,,<empty>,9,,221,2,,void
168515,BLOCK,-1,,"{
        var_AddCallback( p_input_thread, ""intf-event"",
                         InputEvent, p_playlist );

        if( input_Start( p_input_thread ) )
        {
            var_DelCallback( p_input_thread, ""intf-event"",
                             InputEvent, p_playlist );
            vlc_object_release( p_input_thread );
            p_input_thread = NULL;
        }
    }",5,,223,2,,void
168524,BLOCK,-1,,"{
            var_DelCallback( p_input_thread, ""intf-event"",
                             InputEvent, p_playlist );
            vlc_object_release( p_input_thread );
            p_input_thread = NULL;
        }",9,,228,2,,void
168554,BLOCK,-1,,"{
        PL_DEBUG( ""requesting art for new input thread"" );
        libvlc_ArtRequest( p_playlist->obj.libvlc, p_input, META_REQUEST_OPTION_NONE );
    }",5,,242,2,,void
168556,BLOCK,1,,<empty>,,,,1,,void
168590,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    playlist_item_t *p_new = NULL;
    bool requested = p_sys->request.b_request;

    /* Clear the request */
    p_sys->request.b_request = false;

    /* Handle quickly a few special cases */
    /* No items to play */
    if( p_playlist->items.i_size == 0 )
    {
        msg_Info( p_playlist, ""playlist is empty"" );
        return NULL;
    }

    /* Start the real work */
    if( requested )
    {
        p_new = p_sys->request.p_item;

        if( p_new == NULL && p_sys->request.p_node == NULL )
            return NULL; /* Stop request! */

        int i_skip = p_sys->request.i_skip;
        PL_DEBUG( ""processing request item: %s, node: %s, skip: %i"",
                        PLI_NAME( p_sys->request.p_item ),
                        PLI_NAME( p_sys->request.p_node ), i_skip );

        if( p_sys->request.p_node &&
            p_sys->request.p_node != get_current_status_node( p_playlist ) )
        {

            set_current...",1,,266,2,,void
168596,BLOCK,1,,<empty>,,,,2,,void
168628,BLOCK,-1,,"{
        msg_Info( p_playlist, ""playlist is empty"" );
        return NULL;
    }",5,,277,2,,void
168636,BLOCK,-1,,"{
        p_new = p_sys->request.p_item;

        if( p_new == NULL && p_sys->request.p_node == NULL )
            return NULL; /* Stop request! */

        int i_skip = p_sys->request.i_skip;
        PL_DEBUG( ""processing request item: %s, node: %s, skip: %i"",
                        PLI_NAME( p_sys->request.p_item ),
                        PLI_NAME( p_sys->request.p_node ), i_skip );

        if( p_sys->request.p_node &&
            p_sys->request.p_node != get_current_status_node( p_playlist ) )
        {

            set_current_status_node( p_playlist, p_sys->request.p_node );
            p_sys->request.p_node = NULL;
            p_sys->b_reset_currently_playing = true;
        }

        /* If we are asked for a node, go to it's first child */
        if( i_skip == 0 && ( p_new == NULL || p_new->i_children != -1 ) )
        {
            i_skip++;
            if( p_new != NULL )
            {
                p_new = playlist_GetNextLeaf( p_playlist, p_new, NULL, true, false )...",5,,284,2,,void
168656,BLOCK,-1,,<empty>,13,,288,2,,void
168668,BLOCK,1,,<empty>,,,,8,,void
168736,BLOCK,-1,,"{

            set_current_status_node( p_playlist, p_sys->request.p_node );
            p_sys->request.p_node = NULL;
            p_sys->b_reset_currently_playing = true;
        }",9,,297,2,,void
168771,BLOCK,-1,,"{
            i_skip++;
            if( p_new != NULL )
            {
                p_new = playlist_GetNextLeaf( p_playlist, p_new, NULL, true, false );
                for( int i = 0; i < p_playlist->current.i_size; i++ )
                {
                    if( p_new == ARRAY_VAL( p_playlist->current, i ) )
                    {
                        p_playlist->i_current_index = i;
                        i_skip = 0;
                    }
                }
            }
        }",9,,306,2,,void
168778,BLOCK,-1,,"{
                p_new = playlist_GetNextLeaf( p_playlist, p_new, NULL, true, false );
                for( int i = 0; i < p_playlist->current.i_size; i++ )
                {
                    if( p_new == ARRAY_VAL( p_playlist->current, i ) )
                    {
                        p_playlist->i_current_index = i;
                        i_skip = 0;
                    }
                }
            }",13,,309,2,,void
168788,BLOCK,-1,,<empty>,17,,311,1,,void
168802,BLOCK,4,,"{
                    if( p_new == ARRAY_VAL( p_playlist->current, i ) )
                    {
                        p_playlist->i_current_index = i;
                        i_skip = 0;
                    }
                }",17,,312,4,,void
168811,BLOCK,-1,,"{
                        p_playlist->i_current_index = i;
                        i_skip = 0;
                    }",21,,314,2,,void
168824,BLOCK,-1,,<empty>,13,,324,2,,void
168829,BLOCK,-1,,<empty>,14,,325,1,,void
168832,BLOCK,-1,,<empty>,13,,326,2,,void
168837,BLOCK,-1,,<empty>,13,,328,1,,void
168854,BLOCK,-1,,"{
            if( p_playlist->i_current_index < -1 )
                p_playlist->i_current_index = -1;
            for( int i = i_skip; i > 0 ; i-- )
            {
                p_playlist->i_current_index++;
                if( p_playlist->i_current_index >= p_playlist->current.i_size )
                {
                    PL_DEBUG( ""looping - restarting at beginning of node"" );
                    /* reshuffle playlist when end is reached */
                    if( var_GetBool( p_playlist, ""random"" ) ) {
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }
                    p_playlist->i_current_index = 0;
                }
            }
            p_new = ARRAY_VAL( p_playlist->current,
                               p_playlist->i_current_index );
        }",9,,331,2,,void
168862,BLOCK,-1,,<empty>,17,,333,2,,void
168870,BLOCK,-1,,<empty>,13,,334,1,,void
168880,BLOCK,4,,"{
                p_playlist->i_current_index++;
                if( p_playlist->i_current_index >= p_playlist->current.i_size )
                {
                    PL_DEBUG( ""looping - restarting at beginning of node"" );
                    /* reshuffle playlist when end is reached */
                    if( var_GetBool( p_playlist, ""random"" ) ) {
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }
                    p_playlist->i_current_index = 0;
                }
            }",13,,335,4,,void
168895,BLOCK,-1,,"{
                    PL_DEBUG( ""looping - restarting at beginning of node"" );
                    /* reshuffle playlist when end is reached */
                    if( var_GetBool( p_playlist, ""random"" ) ) {
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }
                    p_playlist->i_current_index = 0;
                }",17,,338,2,,void
168897,BLOCK,1,,<empty>,,,,1,,void
168905,BLOCK,-1,,"{
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }",63,,341,2,,void
168907,BLOCK,1,,<empty>,,,,1,,void
168930,BLOCK,-1,,<empty>,14,,352,1,,void
168941,BLOCK,-1,,"{
            for( int i = i_skip; i < 0 ; i++ )
            {
                p_playlist->i_current_index--;
                if( p_playlist->i_current_index <= -1 )
                {
                    PL_DEBUG( ""looping - restarting at end of node"" );
                    /* reshuffle playlist when beginning is reached */
                    if( var_GetBool( p_playlist, ""random"" ) ) {
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }
                    p_playlist->i_current_index = p_playlist->current.i_size-1;
                }
            }
            p_new = ARRAY_VAL( p_playlist->current,
                               p_playlist->i_current_index );
        }",9,,353,2,,void
168943,BLOCK,-1,,<empty>,13,,354,1,,void
168953,BLOCK,4,,"{
                p_playlist->i_current_index--;
                if( p_playlist->i_current_index <= -1 )
                {
                    PL_DEBUG( ""looping - restarting at end of node"" );
                    /* reshuffle playlist when beginning is reached */
                    if( var_GetBool( p_playlist, ""random"" ) ) {
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }
                    p_playlist->i_current_index = p_playlist->current.i_size-1;
                }
            }",13,,355,4,,void
168965,BLOCK,-1,,"{
                    PL_DEBUG( ""looping - restarting at end of node"" );
                    /* reshuffle playlist when beginning is reached */
                    if( var_GetBool( p_playlist, ""random"" ) ) {
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }
                    p_playlist->i_current_index = p_playlist->current.i_size-1;
                }",17,,358,2,,void
168967,BLOCK,1,,<empty>,,,,1,,void
168975,BLOCK,-1,,"{
                        PL_DEBUG( ""reshuffle playlist"" );
                        ResetCurrentlyPlaying( p_playlist,
                                get_current_status_item( p_playlist ) );
                    }",63,,361,2,,void
168977,BLOCK,1,,<empty>,,,,1,,void
169006,BLOCK,-1,,"{
        bool b_loop = var_GetBool( p_playlist, ""loop"" );
        bool b_repeat = var_GetBool( p_playlist, ""repeat"" );
        bool b_playstop = var_InheritBool( p_playlist, ""play-and-stop"" );

        /* Repeat and play/stop */
        if( b_repeat && get_current_status_item( p_playlist ) )
        {
            msg_Dbg( p_playlist,""repeating item"" );
            return get_current_status_item( p_playlist );
        }
        if( b_playstop && get_current_status_item( p_playlist ) )
        {
            msg_Dbg( p_playlist,""stopping (play and stop)"" );
            return NULL;
        }

        /* */

        PL_DEBUG( ""changing item without a request (current %i/%i)"",
                  p_playlist->i_current_index, p_playlist->current.i_size );
        /* Can't go to next from current item */
        if( p_sys->b_reset_currently_playing )
            ResetCurrentlyPlaying( p_playlist,
                                   get_current_status_item( p_playlist ) );

        p_playlist...",5,,375,1,,void
169030,BLOCK,-1,,"{
            msg_Dbg( p_playlist,""repeating item"" );
            return get_current_status_item( p_playlist );
        }",9,,382,2,,void
169042,BLOCK,-1,,"{
            msg_Dbg( p_playlist,""stopping (play and stop)"" );
            return NULL;
        }",9,,387,2,,void
169049,BLOCK,1,,<empty>,,,,1,,void
169065,BLOCK,-1,,<empty>,13,,398,2,,void
169094,BLOCK,-1,,"{
            if( !b_loop || p_playlist->current.i_size == 0 )
                return NULL;
            /* reshuffle after last item has been played */
            if( var_GetBool( p_playlist, ""random"" ) ) {
                PL_DEBUG( ""reshuffle playlist"" );
                ResetCurrentlyPlaying( p_playlist,
                                       get_current_status_item( p_playlist ) );
            }
            p_playlist->i_current_index = 0;
        }",9,,404,2,,void
169106,BLOCK,-1,,<empty>,17,,406,2,,void
169113,BLOCK,-1,,"{
                PL_DEBUG( ""reshuffle playlist"" );
                ResetCurrentlyPlaying( p_playlist,
                                       get_current_status_item( p_playlist ) );
            }",55,,408,2,,void
169115,BLOCK,1,,<empty>,,,,1,,void
169129,BLOCK,1,,<empty>,,,,1,,void
169144,BLOCK,-1,,<empty>,13,,417,2,,void
169162,BLOCK,-1,,"{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_thread_t *p_input = p_sys->p_input;

    assert( p_input != NULL );

    /* Wait for input to end or be stopped */
    while( !p_sys->request.input_dead )
    {
        if( p_sys->request.b_request || p_sys->killed )
        {
            PL_DEBUG( ""incoming request - stopping current input"" );
            input_Stop( p_input );
        }
        vlc_cond_wait( &p_sys->signal, &p_sys->lock );
    }

    input_item_t *item = input_GetItem(p_input);
    assert(item);
    bool ok = !input_item_HasErrorWhenReading(item);

    /* This input is dead. Remove it ! */
    PL_DEBUG( ""dead input"" );
    p_sys->p_input = NULL;
    p_sys->request.input_dead = false;
    PL_UNLOCK;

    var_SetAddress( p_playlist, ""input-current"", NULL );

    /* WARNING: Input resource manipulation and callback deletion are
     * incompatible with the playlist lock. */
    if( !var_InheritBool( p_input, ""sout-keep"" ) )
        input_resource_Termi...",1,,425,2,,void
169168,BLOCK,1,,<empty>,,,,2,,void
169190,BLOCK,-1,,"{
        if( p_sys->request.b_request || p_sys->killed )
        {
            PL_DEBUG( ""incoming request - stopping current input"" );
            input_Stop( p_input );
        }
        vlc_cond_wait( &p_sys->signal, &p_sys->lock );
    }",5,,433,2,,void
169201,BLOCK,-1,,"{
            PL_DEBUG( ""incoming request - stopping current input"" );
            input_Stop( p_input );
        }",9,,435,2,,void
169203,BLOCK,1,,<empty>,,,,1,,void
169232,BLOCK,1,,<empty>,,,,1,,void
169258,BLOCK,-1,,<empty>,9,,457,2,,void
169277,BLOCK,-1,,"{
    playlist_item_t *p_item = NextItem( p_playlist );
    if( p_item == NULL )
        return false;

    msg_Dbg( p_playlist, ""starting playback of new item"" );
    ResyncCurrentIndex( p_playlist, p_item );
    return PlayItem( p_playlist, p_item );
}",1,,467,2,,void
169287,BLOCK,-1,,<empty>,9,,470,2,,void
169304,BLOCK,-1,,"{
    playlist_t *p_playlist = data;
    playlist_private_t *p_sys = pl_priv(p_playlist);
    bool played = false;

    PL_LOCK;
    while( !p_sys->killed )
    {
        /* Playlist in stopped state */
        assert(p_sys->p_input == NULL);

        if( !p_sys->request.b_request )
        {
            vlc_cond_wait( &p_sys->signal, &p_sys->lock );
            continue;
        }

        /* Playlist in running state */
        while( !p_sys->killed && Next( p_playlist ) )
        {
            bool ok = LoopInput( p_playlist );
            if (ok)
                p_sys->i_consecutive_errors = 0;
            else
            {
                if (p_sys->i_consecutive_errors < 6)
                    p_sys->i_consecutive_errors++;

                int slowdown = 1 << (p_sys->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */
                vlc_cond_timedwait(&p_sys->sig...",1,,481,2,,void
169314,BLOCK,1,,<empty>,,,,3,,void
169329,BLOCK,-1,,"{
        /* Playlist in stopped state */
        assert(p_sys->p_input == NULL);

        if( !p_sys->request.b_request )
        {
            vlc_cond_wait( &p_sys->signal, &p_sys->lock );
            continue;
        }

        /* Playlist in running state */
        while( !p_sys->killed && Next( p_playlist ) )
        {
            bool ok = LoopInput( p_playlist );
            if (ok)
                p_sys->i_consecutive_errors = 0;
            else
            {
                if (p_sys->i_consecutive_errors < 6)
                    p_sys->i_consecutive_errors++;

                int slowdown = 1 << (p_sys->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */
                vlc_cond_timedwait(&p_sys->signal, &p_sys->lock, deadline);
            }
            played = true;
        }

        /* Playlist stopping */
        msg_Dbg( p_playlist, ""nothing to play"" ...",5,,488,2,,void
169343,BLOCK,-1,,"{
            vlc_cond_wait( &p_sys->signal, &p_sys->lock );
            continue;
        }",9,,493,2,,void
169362,BLOCK,-1,,"{
            bool ok = LoopInput( p_playlist );
            if (ok)
                p_sys->i_consecutive_errors = 0;
            else
            {
                if (p_sys->i_consecutive_errors < 6)
                    p_sys->i_consecutive_errors++;

                int slowdown = 1 << (p_sys->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */
                vlc_cond_timedwait(&p_sys->signal, &p_sys->lock, deadline);
            }
            played = true;
        }",9,,500,2,,void
169370,BLOCK,-1,,<empty>,17,,503,2,,void
169377,BLOCK,-1,,"{
                if (p_sys->i_consecutive_errors < 6)
                    p_sys->i_consecutive_errors++;

                int slowdown = 1 << (p_sys->i_consecutive_errors - 1);
                /* 100ms, 200ms, 400ms, 800ms, 1.6s, 3.2s */
                mtime_t deadline = mdate() + slowdown * 100000L; /* usecs */
                vlc_cond_timedwait(&p_sys->signal, &p_sys->lock, deadline);
            }",13,,505,1,,void
169384,BLOCK,-1,,<empty>,21,,507,2,,void
169429,BLOCK,-1,,"{
            msg_Info( p_playlist, ""end of playlist, exiting"" );
            libvlc_Quit( p_playlist->obj.libvlc );
        }",9,,520,2,,void
169444,BLOCK,-1,,"{
            PL_UNLOCK; /* Mind: NO LOCKS while manipulating input resources! */
            input_resource_TerminateVout( p_sys->p_input_resource );
            PL_LOCK;
        }",9,,527,2,,void
169474,BLOCK,-1,,<empty>,1,,1,1,,ANY
169479,BLOCK,-1,,<empty>,,,,4,,<empty>
169486,BLOCK,-1,,<empty>,,,,4,,<empty>
169493,BLOCK,-1,,<empty>,,,,4,,<empty>
169500,BLOCK,-1,,<empty>,,,,4,,<empty>
169509,BLOCK,-1,,"{
    input_item_t *p_new_input;
    playlist_item_t *p_item;

    PL_ASSERT_LOCKED;
    if( !psz_name ) psz_name = _(""Undefined"");

    p_new_input = input_item_NewExt( NULL, psz_name, -1, ITEM_TYPE_NODE,
                                     ITEM_NET_UNKNOWN );
    if( !p_new_input )
        return NULL;
    p_item = playlist_ItemNewFromInput( p_playlist, p_new_input );
    input_item_Release( p_new_input );

    if( p_item == NULL )  return NULL;

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );

    p_item->i_flags |= i_flags;

    return p_item;
}",1,,62,6,,void
169516,BLOCK,-1,,<empty>,21,,67,2,,void
169533,BLOCK,-1,,<empty>,9,,72,2,,void
169547,BLOCK,-1,,<empty>,27,,76,2,,void
169569,BLOCK,-1,,"{
    playlist_NodeDeleteExplicit( p_playlist, p_root,
        PLAYLIST_DELETE_STOP_IF_CURRENT );
}",1,,93,3,,void
169574,BLOCK,1,,<empty>,,,,1,,void
169582,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;

    /* Delete the node */
    if( p_root->i_flags & PLAYLIST_RO_FLAG &&
        !( flags & PLAYLIST_DELETE_FORCE ) )
        return;

    /* Delete the children */
    for( int i = p_root->i_children - 1 ; i >= 0; i-- )
        playlist_NodeDeleteExplicit( p_playlist,
            p_root->pp_children[i], flags | PLAYLIST_DELETE_FORCE );

    pl_priv(p_playlist)->b_reset_currently_playing = true;

    int i;
    var_SetAddress( p_playlist, ""playlist-item-deleted"", p_root );

    if( p_root->i_children == -1 ) {
        ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_root->i_id, i );
        if( i != -1 )
            ARRAY_REMOVE( p_playlist->items, i );
    }

    if( get_current_status_item( p_playlist ) == p_root )
    {
        /* a deleted item cannot be currently playing */
        set_current_status_item( p_playlist, NULL );

        if( flags & PLAYLIST_DELETE_STOP_IF_CURRENT )
            playlist_Control( p_playlist, PLAYLIST_STOP, pl_Locked );
    }
...",1,,100,4,,void
169595,BLOCK,1,,<empty>,,,,1,,void
169597,BLOCK,-1,,<empty>,9,,106,2,,void
169600,BLOCK,-1,,<empty>,5,,109,1,,void
169624,BLOCK,1,,<empty>,,,,1,,void
169629,BLOCK,1,,<empty>,,,,2,,void
169649,BLOCK,-1,,"{
        ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_root->i_id, i );
        if( i != -1 )
            ARRAY_REMOVE( p_playlist->items, i );
    }",36,,118,2,,void
169656,BLOCK,-1,,<empty>,13,,121,2,,void
169667,BLOCK,-1,,"{
        /* a deleted item cannot be currently playing */
        set_current_status_item( p_playlist, NULL );

        if( flags & PLAYLIST_DELETE_STOP_IF_CURRENT )
            playlist_Control( p_playlist, PLAYLIST_STOP, pl_Locked );
    }",5,,125,2,,void
169675,BLOCK,1,,<empty>,,,,1,,void
169677,BLOCK,-1,,<empty>,13,,130,2,,void
169683,BLOCK,-1,,<empty>,5,,133,1,,void
169706,BLOCK,-1,,<empty>,13,,135,2,,void
169713,BLOCK,-1,,<empty>,5,,136,1,,void
169737,BLOCK,1,,<empty>,,,,1,,void
169756,BLOCK,-1,,<empty>,9,,144,2,,void
169774,BLOCK,-1,,"{
    assert( p_parent && p_parent->i_children != -1 );
    if( i_position == -1 ) i_position = p_parent->i_children ;
    assert( i_position <= p_parent->i_children);

    TAB_INSERT(p_parent->i_children, p_parent->pp_children,
               p_item, i_position);
    p_item->p_parent = p_parent;

    /* Inherit special flags from parent (sd cases) */
    if( ( p_parent->i_flags & PLAYLIST_NO_INHERIT_FLAG ) == 0 )
        p_item->i_flags |= (p_parent->i_flags & PLAYLIST_RO_FLAG);

    return VLC_SUCCESS;
}",1,,151,4,,void
169789,BLOCK,-1,,<empty>,28,,153,2,,void
169823,BLOCK,-1,,<empty>,9,,162,2,,void
169840,BLOCK,-1,,"{
    int i;

    if( p_node->i_children < 0 )
    {
         return NULL;
    }
    for( i = 0 ; i< p_node->i_children; i++ )
    {
        if( !strcmp( p_node->pp_children[i]->p_input->psz_name, psz_search ) )
        {
            return p_node->pp_children[i];
        }
    }
    return NULL;
}",1,,179,3,,void
169848,BLOCK,-1,,"{
         return NULL;
    }",5,,183,2,,void
169852,BLOCK,-1,,<empty>,5,,186,1,,void
169863,BLOCK,4,,"{
        if( !strcmp( p_node->pp_children[i]->p_input->psz_name, psz_search ) )
        {
            return p_node->pp_children[i];
        }
    }",5,,187,4,,void
169877,BLOCK,-1,,"{
            return p_node->pp_children[i];
        }",9,,189,2,,void
169894,BLOCK,-1,,"{
    PL_ASSERT_LOCKED;
    playlist_item_t *p_next;

    assert( p_root && p_root->i_children != -1 );

    PL_DEBUG2( ""finding next of %s within %s"",
               PLI_NAME( p_item ), PLI_NAME( p_root ) );

    /* Now, walk the tree until we find a suitable next item */
    p_next = p_item;
    while( 1 )
    {
        bool b_ena_ok = true, b_unplayed_ok = true;
        p_next = GetNextItem( p_playlist, p_root, p_next );
        if( !p_next || p_next == p_root )
            break;
        if( p_next->i_children == -1 )
        {
            if( b_ena && p_next->i_flags & PLAYLIST_DBL_FLAG )
                b_ena_ok = false;
            if( b_unplayed && p_next->i_nb_played != 0 )
                b_unplayed_ok = false;
            if( b_ena_ok && b_unplayed_ok ) break;
        }
    }
    if( p_next == NULL ) PL_DEBUG2( ""at end of node"" );
    return p_next;
}",1,,211,6,,void
169907,BLOCK,1,,"PL_DEBUG2( ""finding next of %s within %s"",
               PLI_NAME( p_item ), PLI_NAME( p_root ) )",5,,217,4,,void
169913,BLOCK,-1,,"{
        bool b_ena_ok = true, b_unplayed_ok = true;
        p_next = GetNextItem( p_playlist, p_root, p_next );
        if( !p_next || p_next == p_root )
            break;
        if( p_next->i_children == -1 )
        {
            if( b_ena && p_next->i_flags & PLAYLIST_DBL_FLAG )
                b_ena_ok = false;
            if( b_unplayed && p_next->i_nb_played != 0 )
                b_unplayed_ok = false;
            if( b_ena_ok && b_unplayed_ok ) break;
        }
    }",5,,223,2,,void
169935,BLOCK,-1,,<empty>,13,,227,2,,void
169944,BLOCK,-1,,"{
            if( b_ena && p_next->i_flags & PLAYLIST_DBL_FLAG )
                b_ena_ok = false;
            if( b_unplayed && p_next->i_nb_played != 0 )
                b_unplayed_ok = false;
            if( b_ena_ok && b_unplayed_ok ) break;
        }",9,,229,2,,void
169953,BLOCK,-1,,<empty>,17,,231,2,,void
169965,BLOCK,-1,,<empty>,17,,233,2,,void
169973,BLOCK,-1,,<empty>,45,,234,2,,void
169979,BLOCK,-1,,"PL_DEBUG2( ""at end of node"" )",26,,237,2,,void
169988,BLOCK,-1,,"{
    /* If the item is NULL, return the firt child of root */
    if( p_item == NULL )
    {
        if( p_root->i_children > 0 )
            return p_root->pp_children[0];
        else
            return NULL;
    }

    /* Node with children, get the first one */
    if( p_item->i_children > 0 )
        return p_item->pp_children[0];

    playlist_item_t* p_parent = p_item->p_parent;
    for( int i = 0 ; i < p_parent->i_children ; i++ )
    {
        if( p_parent->pp_children[i] == p_item )
        {
            // Return the next children
            if( i + 1 < p_parent->i_children )
                return p_parent->pp_children[i+1];
            // We are the least one, so try to have uncles
            else
            {
                PL_DEBUG2( ""Current item is the last of the node,""
                           ""looking for uncle from %s"",
                            p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                   ...",1,,252,4,,void
169993,BLOCK,-1,,"{
        if( p_root->i_children > 0 )
            return p_root->pp_children[0];
        else
            return NULL;
    }",5,,255,2,,void
170000,BLOCK,-1,,<empty>,13,,257,2,,void
170008,BLOCK,-1,,<empty>,13,,259,1,,void
170017,BLOCK,-1,,<empty>,9,,264,2,,void
170031,BLOCK,-1,,<empty>,5,,267,1,,void
170043,BLOCK,4,,"{
        if( p_parent->pp_children[i] == p_item )
        {
            // Return the next children
            if( i + 1 < p_parent->i_children )
                return p_parent->pp_children[i+1];
            // We are the least one, so try to have uncles
            else
            {
                PL_DEBUG2( ""Current item is the last of the node,""
                           ""looking for uncle from %s"",
                            p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }
                else
                    return GetNextUncle( p_playlist, p_item, p_root );
            }
        }
    }",5,,268,4,,void
170052,BLOCK,-1,,"{
            // Return the next children
            if( i + 1 < p_parent->i_children )
                return p_parent->pp_children[i+1];
            // We are the least one, so try to have uncles
            else
            {
                PL_DEBUG2( ""Current item is the last of the node,""
                           ""looking for uncle from %s"",
                            p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }
                else
                    return GetNextUncle( p_playlist, p_item, p_root );
            }
        }",9,,270,2,,void
170061,BLOCK,-1,,<empty>,17,,273,2,,void
170071,BLOCK,-1,,"{
                PL_DEBUG2( ""Current item is the last of the node,""
                           ""looking for uncle from %s"",
                            p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }
                else
                    return GetNextUncle( p_playlist, p_item, p_root );
            }",13,,276,1,,void
170073,BLOCK,1,,"PL_DEBUG2( ""Current item is the last of the node,""
                           ""looking for uncle from %s"",
                            p_parent->p_input->psz_name )",17,,277,1,,void
170078,BLOCK,-1,,"{
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }",17,,281,2,,void
170080,BLOCK,1,,"PL_DEBUG2( ""already at root"" )",21,,282,1,,void
170084,BLOCK,-1,,<empty>,21,,286,1,,void
170098,BLOCK,-1,,"{
    playlist_item_t *p_parent = p_item->p_parent;
    playlist_item_t *p_grandparent;
    bool b_found = false;

    (void)p_playlist;

    if( p_parent != NULL )
    {
        p_grandparent = p_parent->p_parent;
        while( p_grandparent )
        {
            int i;
            for( i = 0 ; i< p_grandparent->i_children ; i++ )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name );
                    b_found = true;
                    break;
                }
            }
            if( b_found && i + 1 < p_grandparent->i_children )
            {
                    return p_grandparent->pp_children[i+1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                ...",1,,295,4,,void
170117,BLOCK,-1,,"{
        p_grandparent = p_parent->p_parent;
        while( p_grandparent )
        {
            int i;
            for( i = 0 ; i< p_grandparent->i_children ; i++ )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name );
                    b_found = true;
                    break;
                }
            }
            if( b_found && i + 1 < p_grandparent->i_children )
            {
                    return p_grandparent->pp_children[i+1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                return NULL;
            }
            else
            {
                p_parent = p_grandparent;
                p_grandparent = p_parent->p_parent;
            }
   ...",5,,303,2,,void
170125,BLOCK,-1,,"{
            int i;
            for( i = 0 ; i< p_grandparent->i_children ; i++ )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name );
                    b_found = true;
                    break;
                }
            }
            if( b_found && i + 1 < p_grandparent->i_children )
            {
                    return p_grandparent->pp_children[i+1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                return NULL;
            }
            else
            {
                p_parent = p_grandparent;
                p_grandparent = p_parent->p_parent;
            }
        }",9,,306,2,,void
170128,BLOCK,-1,,<empty>,13,,308,1,,void
170139,BLOCK,4,,"{
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name );
                    b_found = true;
                    break;
                }
            }",13,,309,4,,void
170148,BLOCK,-1,,"{
                    PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name );
                    b_found = true;
                    break;
                }",17,,311,2,,void
170150,BLOCK,1,,"PL_DEBUG2( ""parent %s found as child %i of grandparent %s"",
                               p_parent->p_input->psz_name, i,
                               p_grandparent->p_input->psz_name )",21,,312,1,,void
170165,BLOCK,-1,,"{
                    return p_grandparent->pp_children[i+1];
            }",13,,320,2,,void
170178,BLOCK,-1,,"{
                return NULL;
            }",13,,325,2,,void
170182,BLOCK,-1,,"{
                p_parent = p_grandparent;
                p_grandparent = p_parent->p_parent;
            }",13,,329,1,,void
170199,BLOCK,-1,,"{
    playlist_item_t *p_parent = p_item->p_parent;
    playlist_item_t *p_grandparent;
    bool b_found = false;

    (void)p_playlist;

    if( p_parent != NULL )
    {
        p_grandparent = p_parent->p_parent;
        while( 1 )
        {
            int i;
            for( i = p_grandparent->i_children -1 ; i >= 0; i-- )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    b_found = true;
                    break;
                }
            }
            if( b_found && i - 1 > 0 )
            {
                return p_grandparent->pp_children[i-1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                return NULL;
            }
            else
            {
                p_parent = p_grandparent;
                p_grandparent = p_parent->p_parent;
            }
        }
    }
    /* We reached root */
    return NULL;
}",1,,341,4,,void
170218,BLOCK,-1,,"{
        p_grandparent = p_parent->p_parent;
        while( 1 )
        {
            int i;
            for( i = p_grandparent->i_children -1 ; i >= 0; i-- )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    b_found = true;
                    break;
                }
            }
            if( b_found && i - 1 > 0 )
            {
                return p_grandparent->pp_children[i-1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                return NULL;
            }
            else
            {
                p_parent = p_grandparent;
                p_grandparent = p_parent->p_parent;
            }
        }
    }",5,,349,2,,void
170226,BLOCK,-1,,"{
            int i;
            for( i = p_grandparent->i_children -1 ; i >= 0; i-- )
            {
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    b_found = true;
                    break;
                }
            }
            if( b_found && i - 1 > 0 )
            {
                return p_grandparent->pp_children[i-1];
            }
            /* Not found at root */
            if( p_grandparent == p_root )
            {
                return NULL;
            }
            else
            {
                p_parent = p_grandparent;
                p_grandparent = p_parent->p_parent;
            }
        }",9,,352,2,,void
170229,BLOCK,-1,,<empty>,13,,354,1,,void
170242,BLOCK,4,,"{
                if( p_parent == p_grandparent->pp_children[i] )
                {
                    b_found = true;
                    break;
                }
            }",13,,355,4,,void
170251,BLOCK,-1,,"{
                    b_found = true;
                    break;
                }",17,,357,2,,void
170264,BLOCK,-1,,"{
                return p_grandparent->pp_children[i-1];
            }",13,,363,2,,void
170277,BLOCK,-1,,"{
                return NULL;
            }",13,,368,2,,void
170281,BLOCK,-1,,"{
                p_parent = p_grandparent;
                p_grandparent = p_parent->p_parent;
            }",13,,372,1,,void
170298,BLOCK,-1,,"{
    playlist_item_t *p_parent;
    int i;

    /* Node with children, get the last one */
    if( p_item && p_item->i_children > 0 )
        return p_item->pp_children[p_item->i_children - 1];

    /* Last child of its parent ? */
    if( p_item != NULL )
        p_parent = p_item->p_parent;
    else
    {
        msg_Err( p_playlist, ""Get the last one"" );
        abort();
    };

    for( i = p_parent->i_children -1 ; i >= 0 ;  i-- )
    {
        if( p_parent->pp_children[i] == p_item )
        {
            if( i-1 < 0 )
            {
               /* Was already the first sibling. Look for uncles */
                PL_DEBUG2( ""current item is the first of its node,""
                           ""looking for uncle from %s"",
                           p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }
                return GetPrevUncle( p_...",1,,387,4,,void
170309,BLOCK,-1,,<empty>,9,,393,2,,void
170324,BLOCK,-1,,<empty>,9,,397,2,,void
170331,BLOCK,-1,,"{
        msg_Err( p_playlist, ""Get the last one"" );
        abort();
    }",5,,399,1,,void
170337,BLOCK,-1,,<empty>,5,,404,1,,void
170350,BLOCK,4,,"{
        if( p_parent->pp_children[i] == p_item )
        {
            if( i-1 < 0 )
            {
               /* Was already the first sibling. Look for uncles */
                PL_DEBUG2( ""current item is the first of its node,""
                           ""looking for uncle from %s"",
                           p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }
                return GetPrevUncle( p_playlist, p_item, p_root );
            }
            else
            {
                return p_parent->pp_children[i-1];
            }
        }
    }",5,,405,4,,void
170359,BLOCK,-1,,"{
            if( i-1 < 0 )
            {
               /* Was already the first sibling. Look for uncles */
                PL_DEBUG2( ""current item is the first of its node,""
                           ""looking for uncle from %s"",
                           p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }
                return GetPrevUncle( p_playlist, p_item, p_root );
            }
            else
            {
                return p_parent->pp_children[i-1];
            }
        }",9,,407,2,,void
170366,BLOCK,-1,,"{
               /* Was already the first sibling. Look for uncles */
                PL_DEBUG2( ""current item is the first of its node,""
                           ""looking for uncle from %s"",
                           p_parent->p_input->psz_name );
                if( p_parent == p_root )
                {
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }
                return GetPrevUncle( p_playlist, p_item, p_root );
            }",13,,409,2,,void
170368,BLOCK,1,,"PL_DEBUG2( ""current item is the first of its node,""
                           ""looking for uncle from %s"",
                           p_parent->p_input->psz_name )",17,,411,1,,void
170373,BLOCK,-1,,"{
                    PL_DEBUG2( ""already at root"" );
                    return NULL;
                }",17,,415,2,,void
170375,BLOCK,1,,"PL_DEBUG2( ""already at root"" )",21,,416,1,,void
170384,BLOCK,-1,,"{
                return p_parent->pp_children[i-1];
            }",13,,422,1,,void
170417,BLOCK,-1,,<empty>,1,,1,1,,ANY
170420,BLOCK,-1,,"{
    const char *path = getenv (""VLC_DATA_PATH"");
    return strdup ((path != NULL) ? path : PKGDATADIR);
}",1,,45,2,,void
170438,BLOCK,-1,,"{
    return strdup (PKGLIBDIR);
}",1,,56,2,,void
170446,BLOCK,-1,,"{
    /* 1/ Try $HOME  */
    const char *home = getenv (""HOME"");
    if (home != NULL)
        return strdup (home);
#if defined(HAVE_GETPWUID_R)
    /* 2/ Try /etc/passwd */
    long max = sysconf (_SC_GETPW_R_SIZE_MAX);
    if (max != -1)
    {
        char buf[max];
        struct passwd pwbuf, *pw;

        if (getpwuid_r (getuid (), &pwbuf, buf, sizeof (buf), &pw) == 0
          && pw != NULL)
            return strdup (pw->pw_dir);
    }
#endif
    return NULL;
}",1,,62,2,,void
170456,BLOCK,-1,,<empty>,9,,66,2,,void
170467,BLOCK,-1,,"{
    char *psz_dir;
    char var[sizeof (""XDG__HOME"") + strlen (xdg_name)];

    /* XDG Base Directory Specification - Version 0.6 */
    snprintf (var, sizeof (var), ""XDG_%s_HOME"", xdg_name);

    const char *home = getenv (var);
    if (home != NULL)
    {
        if (asprintf (&psz_dir, ""%s/vlc"", home) == -1)
            psz_dir = NULL;
        return psz_dir;
    }

    char *psz_home = config_GetHomeDir ();
    if( psz_home == NULL
     || asprintf( &psz_dir, ""%s/%s/vlc"", psz_home, xdg_default ) == -1 )
        psz_dir = NULL;
    free (psz_home);
    return psz_dir;
}",1,,84,3,,void
170485,BLOCK,-1,,"{
        if (asprintf (&psz_dir, ""%s/vlc"", home) == -1)
            psz_dir = NULL;
        return psz_dir;
    }",5,,93,2,,void
170495,BLOCK,-1,,<empty>,13,,95,2,,void
170519,BLOCK,-1,,<empty>,9,,102,2,,void
170531,BLOCK,-1,,"{
    const size_t namelen = strlen (xdg_name);
    const char *home = getenv (""HOME"");
    const char *dir = getenv (""XDG_CONFIG_HOME"");
    const char *file = ""user-dirs.dirs"";

    if (home == NULL)
        return NULL;
    if (dir == NULL)
    {
        dir = home;
        file = "".config/user-dirs.dirs"";
    }

    char *path;
    if (asprintf (&path, ""%s/%s"", dir, file) == -1)
        return NULL;

    FILE *stream = fopen (path, ""rte"");
    free (path);
    path = NULL;
    if (stream != NULL)
    {
        char *linebuf = NULL;
        size_t linelen = 0;

        while (getline (&linebuf, &linelen, stream) != -1)
        {
            char *ptr = linebuf;
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (strncmp (ptr, ""XDG_"", 4))
                continue;
            ptr += 4; /* Skip XDG_ */
            if (strncmp (ptr, xdg_name, namelen))
                continue;
            ptr += namelen; /* Skip XDG type name */
            if (strncmp (ptr, ""...",1,,108,2,,void
170555,BLOCK,-1,,<empty>,9,,115,2,,void
170562,BLOCK,-1,,"{
        dir = home;
        file = "".config/user-dirs.dirs"";
    }",5,,117,2,,void
170580,BLOCK,-1,,<empty>,9,,124,2,,void
170598,BLOCK,-1,,"{
        char *linebuf = NULL;
        size_t linelen = 0;

        while (getline (&linebuf, &linelen, stream) != -1)
        {
            char *ptr = linebuf;
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (strncmp (ptr, ""XDG_"", 4))
                continue;
            ptr += 4; /* Skip XDG_ */
            if (strncmp (ptr, xdg_name, namelen))
                continue;
            ptr += namelen; /* Skip XDG type name */
            if (strncmp (ptr, ""_DIR"", 4))
                continue;
            ptr += 4; /* Skip _DIR */
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (*ptr != '=')
                continue;
            ptr++; /* Skip equality sign */
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (*ptr != '""')
                continue;
            ptr++; /* Skip quote */
            linelen -= ptr - linebuf;

            char *out;
            if (strncmp (ptr, ""$HOME"", 5))
            {
          ...",5,,130,2,,void
170617,BLOCK,-1,,"{
            char *ptr = linebuf;
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (strncmp (ptr, ""XDG_"", 4))
                continue;
            ptr += 4; /* Skip XDG_ */
            if (strncmp (ptr, xdg_name, namelen))
                continue;
            ptr += namelen; /* Skip XDG type name */
            if (strncmp (ptr, ""_DIR"", 4))
                continue;
            ptr += 4; /* Skip _DIR */
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (*ptr != '=')
                continue;
            ptr++; /* Skip equality sign */
            ptr += strspn (ptr, "" \t""); /* Skip whites */
            if (*ptr != '""')
                continue;
            ptr++; /* Skip quote */
            linelen -= ptr - linebuf;

            char *out;
            if (strncmp (ptr, ""$HOME"", 5))
            {
                path = malloc (linelen);
                if (path == NULL)
                    continue;
                out = path;
     ...",9,,135,2,,void
170632,BLOCK,-1,,<empty>,17,,139,2,,void
170642,BLOCK,-1,,<empty>,17,,142,2,,void
170652,BLOCK,-1,,<empty>,17,,145,2,,void
170667,BLOCK,-1,,<empty>,17,,149,2,,void
170681,BLOCK,-1,,<empty>,17,,153,2,,void
170696,BLOCK,-1,,"{
                path = malloc (linelen);
                if (path == NULL)
                    continue;
                out = path;
            }",13,,159,2,,void
170705,BLOCK,-1,,<empty>,21,,162,2,,void
170711,BLOCK,-1,,"{   /* Prefix with $HOME */
                const size_t homelen = strlen (home);
                ptr += 5;
                path = malloc (homelen + linelen - 5);
                if (path == NULL)
                    continue;
                memcpy (path, home, homelen);
                out = path + homelen;
            }",13,,166,1,,void
170732,BLOCK,-1,,<empty>,21,,171,2,,void
170748,BLOCK,-1,,"{
                if (*ptr == '\\')
                    ptr++;
                if (*ptr == '\0')
                {
                    free (path);
                    path = NULL;
                    break;
                }
                *(out++) = *(ptr++);
            }",13,,177,2,,void
170754,BLOCK,-1,,<empty>,21,,179,2,,void
170762,BLOCK,-1,,"{
                    free (path);
                    path = NULL;
                    break;
                }",17,,181,2,,void
170780,BLOCK,-1,,<empty>,17,,189,2,,void
170794,BLOCK,-1,,"{
        if (strcmp (xdg_name, ""DESKTOP"") == 0)
        {
            if (asprintf (&path, ""%s/Desktop"", home) == -1)
                return NULL;
        }
        else
            path = strdup (home);
    }",5,,198,2,,void
170801,BLOCK,-1,,"{
            if (asprintf (&path, ""%s/Desktop"", home) == -1)
                return NULL;
        }",9,,200,2,,void
170811,BLOCK,-1,,<empty>,17,,202,2,,void
170815,BLOCK,-1,,<empty>,13,,205,1,,void
170826,BLOCK,-1,,"{
    switch (type)
    {
        case VLC_HOME_DIR:
            break;
        case VLC_CONFIG_DIR:
            return config_GetAppDir (""CONFIG"", "".config"");
        case VLC_DATA_DIR:
            return config_GetAppDir (""DATA"", "".local/share"");
        case VLC_CACHE_DIR:
            return config_GetAppDir (""CACHE"", "".cache"");

        case VLC_DESKTOP_DIR:
            return config_GetTypeDir (""DESKTOP"");
        case VLC_DOWNLOAD_DIR:
            return config_GetTypeDir (""DOWNLOAD"");
        case VLC_TEMPLATES_DIR:
            return config_GetTypeDir (""TEMPLATES"");
        case VLC_PUBLICSHARE_DIR:
            return config_GetTypeDir (""PUBLICSHARE"");
        case VLC_DOCUMENTS_DIR:
            return config_GetTypeDir (""DOCUMENTS"");
        case VLC_MUSIC_DIR:
            return config_GetTypeDir (""MUSIC"");
        case VLC_PICTURES_DIR:
            return config_GetTypeDir (""PICTURES"");
        case VLC_VIDEOS_DIR:
            return config_GetTypeDir (""VIDEOS"");
    }
  ...",1,,213,2,,void
170829,BLOCK,-1,,"{
        case VLC_HOME_DIR:
            break;
        case VLC_CONFIG_DIR:
            return config_GetAppDir (""CONFIG"", "".config"");
        case VLC_DATA_DIR:
            return config_GetAppDir (""DATA"", "".local/share"");
        case VLC_CACHE_DIR:
            return config_GetAppDir (""CACHE"", "".cache"");

        case VLC_DESKTOP_DIR:
            return config_GetTypeDir (""DESKTOP"");
        case VLC_DOWNLOAD_DIR:
            return config_GetTypeDir (""DOWNLOAD"");
        case VLC_TEMPLATES_DIR:
            return config_GetTypeDir (""TEMPLATES"");
        case VLC_PUBLICSHARE_DIR:
            return config_GetTypeDir (""PUBLICSHARE"");
        case VLC_DOCUMENTS_DIR:
            return config_GetTypeDir (""DOCUMENTS"");
        case VLC_MUSIC_DIR:
            return config_GetTypeDir (""MUSIC"");
        case VLC_PICTURES_DIR:
            return config_GetTypeDir (""PICTURES"");
        case VLC_VIDEOS_DIR:
            return config_GetTypeDir (""VIDEOS"");
    }",5,,215,2,,void
170911,BLOCK,-1,,<empty>,1,,1,1,,ANY
170915,BLOCK,-1,,"{
    int saved_errno = errno;
    locale_t loc = newlocale(LC_MESSAGES_MASK, lname, (locale_t)0);

    if (unlikely(loc == (locale_t)0))
    {
        if (errno == ENOENT) /* fallback to POSIX locale */
            loc = newlocale(LC_MESSAGES_MASK, ""C"", (locale_t)0);

        if (unlikely(loc == (locale_t)0))
        {
            assert(errno != EINVAL && errno != ENOENT);
            errno = saved_errno;
            return ""Error message unavailable"";
        }
        errno = saved_errno;
    }

    const char *buf = strerror_l(errnum, loc);

    freelocale(loc);
    return buf;
}",1,,33,3,,void
170936,BLOCK,-1,,"{
        if (errno == ENOENT) /* fallback to POSIX locale */
            loc = newlocale(LC_MESSAGES_MASK, ""C"", (locale_t)0);

        if (unlikely(loc == (locale_t)0))
        {
            assert(errno != EINVAL && errno != ENOENT);
            errno = saved_errno;
            return ""Error message unavailable"";
        }
        errno = saved_errno;
    }",5,,38,2,,void
170941,BLOCK,-1,,<empty>,13,,40,2,,void
170957,BLOCK,-1,,"{
            assert(errno != EINVAL && errno != ENOENT);
            errno = saved_errno;
            return ""Error message unavailable"";
        }",9,,43,2,,void
170988,BLOCK,-1,,"{
    /* We cannot simply use strerror() here, since it is not thread-safe. */
    return vlc_strerror_l(errnum, """");
}",1,,64,2,,void
170997,BLOCK,-1,,"{
    return vlc_strerror_l(errnum, ""C"");
}",1,,76,2,,void
171040,BLOCK,-1,,<empty>,1,,1,1,,ANY
171043,BLOCK,-1,,"{
    fcntl(fd, F_SETFD, FD_CLOEXEC | fcntl(fd, F_GETFD));
}",1,,54,2,,void
171057,BLOCK,-1,,"{
    unsigned int mode = 0;
    va_list ap;

    va_start (ap, flags);
    if (flags & (O_CREAT|O_TMPFILE))
        mode = va_arg (ap, unsigned int);
    va_end (ap);

#ifdef O_CLOEXEC
    return open(filename, flags | O_CLOEXEC, mode);
#else
    int fd = open(filename, flags, mode);
    if (fd != -1)
        vlc_cloexec(fd);
    return -1;
#endif
}",1,,60,3,,void
171081,BLOCK,-1,,<empty>,9,,74,2,,void
171093,BLOCK,-1,,"{
    unsigned int mode = 0;
    va_list ap;

    va_start (ap, flags);
    if (flags & (O_CREAT|O_TMPFILE))
        mode = va_arg (ap, unsigned int);
    va_end (ap);

#ifdef HAVE_OPENAT
    return openat(dir, filename, flags | O_CLOEXEC, mode);
#else
    VLC_UNUSED (dir);
    VLC_UNUSED (filename);
    VLC_UNUSED (mode);
    errno = ENOSYS;
    return -1;
#endif
}",1,,80,4,,void
171121,BLOCK,-1,,"{
#if defined (HAVE_MKOSTEMP) && defined (O_CLOEXEC)
    return mkostemp(template, O_CLOEXEC);
#else
    int fd = mkstemp(template);
    if (fd != -1)
        vlc_cloexec(fd);
    return fd;
#endif
}",1,,101,2,,void
171132,BLOCK,-1,,<empty>,9,,107,2,,void
171141,BLOCK,-1,,"{
    int fd;
#if O_TMPFILE
    fd = vlc_open (""/tmp"", O_RDWR|O_TMPFILE, S_IRUSR|S_IWUSR);
    if (fd != -1)
        return fd;
    /* ENOENT means either /tmp is missing (!) or the kernel does not support
     * O_TMPFILE. EISDIR means /tmp exists but the kernel does not support
     * O_TMPFILE. EOPNOTSUPP means the kernel supports O_TMPFILE but the /tmp
     * filesystem does not. Do not fallback on other errors. */
    if (errno != ENOENT && errno != EISDIR && errno != EOPNOTSUPP)
        return -1;
#endif

    char bufpath[] = ""/tmp/""PACKAGE_NAME""XXXXXX"";

    fd = vlc_mkstemp (bufpath);
    if (fd != -1)
        unlink (bufpath);
    return fd;
}",1,,113,2,,void
171160,BLOCK,-1,,<empty>,9,,131,2,,void
171169,BLOCK,-1,,"{
    int ret;
#ifdef POSIX_CLOSE_RESTART
    ret = posix_close(fd, 0);
#else
    ret = close(fd);
    /* POSIX.2008 (and earlier) does not specify if the file descriptor is
     * closed on failure. Assume it is as on Linux and most other common OSes.
     * Also emulate the correct error code as per newer POSIX versions. */
    if (unlikely(ret != 0) && unlikely(errno == EINTR))
        errno = EINPROGRESS;
#endif
    assert(ret == 0 || errno != EBADF); /* something is corrupt? */
    return ret;
}",1,,136,2,,void
171185,BLOCK,-1,,<empty>,9,,146,2,,void
171204,BLOCK,-1,,"{
    return mkdir (dirname, mode);
}",1,,153,3,,void
171213,BLOCK,-1,,"{
    return opendir (dirname);
}",1,,158,2,,void
171221,BLOCK,-1,,"{
    struct dirent *ent = readdir (dir);
    return (ent != NULL) ? ent->d_name : NULL;
}",1,,163,2,,void
171241,BLOCK,-1,,"{
    return stat (filename, buf);
}",1,,169,3,,void
171251,BLOCK,-1,,"{
    return lstat (filename, buf);
}",1,,174,3,,void
171256,BLOCK,1,,<empty>,,,,3,,void
171264,BLOCK,-1,,"{
    return unlink (filename);
}",1,,179,2,,void
171273,BLOCK,-1,,"{
    return rename (oldpath, newpath);
}",1,,184,3,,void
171282,BLOCK,-1,,"{
    long path_max = pathconf (""."", _PC_PATH_MAX);
    size_t size = (path_max == -1 || path_max > 4096) ? 4096 : path_max;

    for (;; size *= 2)
    {
        char *buf = malloc (size);
        if (unlikely(buf == NULL))
            break;

        if (getcwd (buf, size) != NULL)
            return buf;
        free (buf);

        if (errno != ERANGE)
            break;
    }
    return NULL;
}",1,,189,2,,void
171304,BLOCK,-1,,<empty>,5,,193,1,,void
171308,BLOCK,4,,"{
        char *buf = malloc (size);
        if (unlikely(buf == NULL))
            break;

        if (getcwd (buf, size) != NULL)
            return buf;
        free (buf);

        if (errno != ERANGE)
            break;
    }",5,,194,4,,void
171319,BLOCK,-1,,<empty>,13,,197,2,,void
171327,BLOCK,-1,,<empty>,13,,200,2,,void
171336,BLOCK,-1,,<empty>,13,,204,2,,void
171344,BLOCK,-1,,"{
#ifdef F_DUPFD_CLOEXEC
    return fcntl (oldfd, F_DUPFD_CLOEXEC, 0);
#else
    int newfd = dup (oldfd);
    if (newfd != -1)
        vlc_cloexec(oldfd);
    return newfd;
#endif
}",1,,210,2,,void
171355,BLOCK,-1,,<empty>,9,,216,2,,void
171364,BLOCK,-1,,"{
#ifdef HAVE_PIPE2
    return pipe2(fds, O_CLOEXEC);
#else
    int ret = pipe(fds);
    if (ret == 0)
    {
        vlc_cloexec(fds[0]);
        vlc_cloexec(fds[1]);
    }
    return ret;
#endif
}",1,,222,2,,void
171374,BLOCK,-1,,"{
        vlc_cloexec(fds[0]);
        vlc_cloexec(fds[1]);
    }",5,,228,2,,void
171391,BLOCK,-1,,"{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };

    return vlc_writev(fd, &iov, 1);
}",1,,237,4,,void
171396,BLOCK,1,,<empty>,26,,238,1,,void
171402,BLOCK,2,,<empty>,51,,238,2,,void
171418,BLOCK,-1,,"{
    sigset_t set, oset;

    sigemptyset(&set);
    sigaddset(&set, SIGPIPE);
    pthread_sigmask(SIG_BLOCK, &set, &oset);

    ssize_t val = writev(fd, iov, count);
    if (val < 0 && errno == EPIPE)
    {
#if (_POSIX_REALTIME_SIGNALS > 0)
        siginfo_t info;
        struct timespec ts = { 0, 0 };

        while (sigtimedwait(&set, &info, &ts) >= 0 || errno != EAGAIN);
#else
        for (;;)
        {
            sigset_t s;
            int num;

            sigpending(&s);
            if (!sigismember(&s, SIGPIPE))
                break;

            sigwait(&set, &num);
            assert(num == SIGPIPE);
        }
#endif
    }

    if (!sigismember(&oset, SIGPIPE)) /* Restore the signal mask if changed */
        pthread_sigmask(SIG_SETMASK, &oset, NULL);
    return val;
}",1,,244,4,,void
171449,BLOCK,-1,,"{
#if (_POSIX_REALTIME_SIGNALS > 0)
        siginfo_t info;
        struct timespec ts = { 0, 0 };

        while (sigtimedwait(&set, &info, &ts) >= 0 || errno != EAGAIN);
#else
        for (;;)
        {
            sigset_t s;
            int num;

            sigpending(&s);
            if (!sigismember(&s, SIGPIPE))
                break;

            sigwait(&set, &num);
            assert(num == SIGPIPE);
        }
#endif
    }",5,,253,2,,void
171451,BLOCK,-1,,<empty>,9,,260,1,,void
171452,BLOCK,4,,"{
            sigset_t s;
            int num;

            sigpending(&s);
            if (!sigismember(&s, SIGPIPE))
                break;

            sigwait(&set, &num);
            assert(num == SIGPIPE);
        }",9,,261,4,,void
171464,BLOCK,-1,,<empty>,17,,267,2,,void
171481,BLOCK,-1,,<empty>,9,,276,2,,void
171494,BLOCK,-1,,"{
    vlc_cloexec(fd);

    if (nonblock)
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);

#ifdef SO_NOSIGPIPE
    setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
#endif
}",1,,284,3,,void
171499,BLOCK,-1,,<empty>,9,,288,2,,void
171516,BLOCK,-1,,"{
#ifdef SOCK_CLOEXEC
    if (nonblock)
        type |= SOCK_NONBLOCK;

    int fd = socket(pf, type | SOCK_CLOEXEC, proto);
# ifdef SO_NOSIGPIPE
    if (fd != -1)
        setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
# endif
#else
    int fd = socket (pf, type, proto);
    if (fd != -1)
        vlc_socket_setup(fd, nonblock);
#endif
    return fd;
}",1,,297,5,,void
171529,BLOCK,-1,,<empty>,9,,310,2,,void
171543,BLOCK,-1,,"{
#ifdef SOCK_CLOEXEC
    if (nonblock)
        type |= SOCK_NONBLOCK;

    int ret = socketpair(pf, type | SOCK_CLOEXEC, proto, fds);
# ifdef SO_NOSIGPIPE
    if (ret == 0)
    {
        const int val = 1;

        setsockopt(fds[0], SOL_SOCKET, SO_NOSIGPIPE, &val, sizeof (val));
        setsockopt(fds[1], SOL_SOCKET, SO_NOSIGPIPE, &val, sizeof (val));
    }
# endif
#else
    int ret = socketpair(pf, type, proto, fds);
    if (ret == 0)
    {
        vlc_socket_setup(fds[0], nonblock);
        vlc_socket_setup(fds[1], nonblock);
    }
#endif
    return ret;
}",1,,316,6,,void
171556,BLOCK,-1,,"{
        vlc_socket_setup(fds[0], nonblock);
        vlc_socket_setup(fds[1], nonblock);
    }",5,,334,2,,void
171576,BLOCK,-1,,"{
#ifdef HAVE_ACCEPT4
    int flags = SOCK_CLOEXEC;
    if (nonblock)
        flags |= SOCK_NONBLOCK;

    int fd = accept4(lfd, addr, alen, flags);
# ifdef SO_NOSIGPIPE
    if (fd != -1)
        setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
# endif
#else
    int fd = accept(lfd, addr, alen);
    if (fd != -1)
        vlc_socket_setup(fd, nonblock);
#endif
    return fd;
}",1,,343,5,,void
171589,BLOCK,-1,,<empty>,9,,357,2,,void
171615,BLOCK,-1,,<empty>,1,,1,1,,ANY
171627,BLOCK,-1,,"{
    struct vlc_gai_req *req = data;

    req->error = EAI_SYSTEM;
    req->error = getaddrinfo(req->name, req->service, req->hints,
                             &req->result);
    vlc_sem_post(&req->done);
    return NULL;
}",1,,44,2,,void
171669,BLOCK,-1,,"{
    struct vlc_gai_req req =
    {
        .name = name,
        .service = NULL,
        .hints = hints,
    };
    char portbuf[6];
    vlc_thread_t th;

    if (port != 0)
    {
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.service = portbuf;
    }

    vlc_sem_init(&req.done, 0);

    if (vlc_clone(&th, vlc_gai_thread, &req, VLC_THREAD_PRIORITY_LOW))
    {
        vlc_sem_destroy(&req.done);
        return EAI_SYSTEM;
    }

    vlc_sem_wait_i11e(&req.done);

    vlc_cancel(th);
    vlc_join(th, NULL);
    vlc_sem_destroy(&req.done);

    *res = req.result;
    return req.error;
}",1,,57,5,,void
171674,BLOCK,1,,<empty>,9,,60,1,,void
171678,BLOCK,2,,<empty>,9,,61,2,,void
171682,BLOCK,3,,<empty>,9,,62,3,,void
171692,BLOCK,-1,,"{
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.service = portbuf;
    }",5,,68,2,,void
171705,BLOCK,-1,,<empty>,13,,71,2,,void
171727,BLOCK,-1,,"{
        vlc_sem_destroy(&req.done);
        return EAI_SYSTEM;
    }",5,,79,2,,void
171790,BLOCK,-1,,<empty>,1,,1,1,,ANY
171794,BLOCK,-1,,"{
    /* libproxy helper */
    pid_t pid;
    posix_spawn_file_actions_t actions;
    posix_spawnattr_t attr;
    char *argv[3] = { (char *)""proxy"", (char *)url, NULL };
    int fd[2];

    if (vlc_pipe(fd))
        return NULL;

    if (posix_spawn_file_actions_init(&actions))
        return NULL;
    if (posix_spawn_file_actions_addopen(&actions, STDIN_FILENO, ""/dev/null"",
                                         O_RDONLY, 0644) ||
        posix_spawn_file_actions_adddup2(&actions, fd[1], STDOUT_FILENO))
    {
        posix_spawn_file_actions_destroy(&actions);
        return NULL;
    }

    posix_spawnattr_init(&attr);
    {
        sigset_t set;

        sigemptyset(&set);
        posix_spawnattr_setsigmask(&attr, &set);
        sigaddset (&set, SIGPIPE);
        posix_spawnattr_setsigdefault(&attr, &set);
        posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGDEF
                                      | POSIX_SPAWN_SETSIGMASK);
    }

    if (posix_spawnp(&pid, ""proxy"", &ac...",1,,47,2,,void
171813,BLOCK,-1,,<empty>,9,,56,2,,void
171820,BLOCK,-1,,<empty>,9,,59,2,,void
171839,BLOCK,-1,,"{
        posix_spawn_file_actions_destroy(&actions);
        return NULL;
    }",5,,63,2,,void
171848,BLOCK,11,,"{
        sigset_t set;

        sigemptyset(&set);
        posix_spawnattr_setsigmask(&attr, &set);
        sigaddset (&set, SIGPIPE);
        posix_spawnattr_setsigdefault(&attr, &set);
        posix_spawnattr_setflags(&attr, POSIX_SPAWN_SETSIGDEF
                                      | POSIX_SPAWN_SETSIGMASK);
    }",5,,69,11,,void
171884,BLOCK,-1,,<empty>,9,,81,2,,void
171904,BLOCK,-1,,"{
        char buf[1024];
        size_t len = 0;

        do
        {
             ssize_t val = read(fd[0], buf + len, sizeof (buf) - len);
             if (val <= 0)
                 break;
             len += val;
        }
        while (len < sizeof (buf));

        vlc_close(fd[0]);
        while (waitpid(pid, &(int){ 0 }, 0) == -1);

        if (len >= 9 && !strncasecmp(buf, ""direct://"", 9))
            return NULL;

        char *end = memchr(buf, '\n', len);
        if (end != NULL)
        {
            *end = '\0';
            return strdup(buf);
        }
        /* Parse error: fallback (may be due to missing executable) */
    }",5,,88,2,,void
171911,BLOCK,-1,,"{
             ssize_t val = read(fd[0], buf + len, sizeof (buf) - len);
             if (val <= 0)
                 break;
             len += val;
        }",9,,93,1,,void
171930,BLOCK,-1,,<empty>,18,,96,2,,void
171965,BLOCK,-1,,<empty>,13,,105,2,,void
171979,BLOCK,-1,,"{
            *end = '\0';
            return strdup(buf);
        }",9,,109,2,,void
171988,BLOCK,-1,,<empty>,9,,116,1,,void
172002,BLOCK,-1,,<empty>,9,,121,2,,void
172027,BLOCK,-1,,<empty>,1,,1,1,,ANY
172033,BLOCK,-1,,"{
#if defined (RTLD_NOW)
    const int flags = lazy ? RTLD_LAZY : RTLD_NOW;
#elif defined (DL_LAZY)
    const int flags = DL_LAZY;
#else
    const int flags = 0;
#endif

    module_handle_t handle = dlopen (path, flags);
    if( handle == NULL )
    {
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", path, dlerror() );
        return -1;
    }
    *p_handle = handle;
    return 0;
}",1,,51,5,,void
172048,BLOCK,-1,,"{
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", path, dlerror() );
        return -1;
    }",5,,62,2,,void
172067,BLOCK,-1,,"{
#if !defined(__SANITIZE_ADDRESS__)
#ifdef HAVE_VALGRIND_VALGRIND_H
    if( RUNNING_ON_VALGRIND > 0 )
        return; /* do not dlclose() so that we get proper stack traces */
#endif
    dlclose( handle );
#else
    (void) handle;
#endif
}",1,,80,2,,void
172075,BLOCK,-1,,"{
    return dlsym( handle, psz_function );
}",1,,104,3,,void
172110,BLOCK,-1,,<empty>,1,,1,1,,ANY
172115,BLOCK,1,,<empty>,,,,1,,void
172119,BLOCK,1,,<empty>,,,,1,,void
172123,BLOCK,-1,,"{
    uint8_t key[BLOCK_SIZE];

    /* Get non-predictible value as key for HMAC */
    int fd = vlc_open (""/dev/urandom"", O_RDONLY);
    if (fd == -1)
        return; /* Uho! */

    for (size_t i = 0; i < sizeof (key);)
    {
         ssize_t val = read (fd, key + i, sizeof (key) - i);
         if (val > 0)
             i += val;
    }

    /* Precompute outer and inner keys for HMAC */
    for (size_t i = 0; i < sizeof (key); i++)
    {
        okey[i] = key[i] ^ 0x5c;
        ikey[i] = key[i] ^ 0x36;
    }

    vlc_close (fd);
}",1,,51,2,,void
172136,BLOCK,-1,,<empty>,9,,57,2,,void
172139,BLOCK,-1,,<empty>,5,,59,1,,void
172148,BLOCK,4,,"{
         ssize_t val = read (fd, key + i, sizeof (key) - i);
         if (val > 0)
             i += val;
    }",5,,60,4,,void
172165,BLOCK,-1,,<empty>,14,,63,2,,void
172170,BLOCK,-1,,<empty>,5,,67,1,,void
172181,BLOCK,4,,"{
        okey[i] = key[i] ^ 0x5c;
        ikey[i] = key[i] ^ 0x36;
    }",5,,68,4,,void
172207,BLOCK,-1,,"{
    static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
    static uint64_t counter = 0;

    uint64_t stamp = NTPtime64 ();

    while (len > 0)
    {
        uint64_t val;
        struct md5_s mdi, mdo;

        InitMD5 (&mdi);
        InitMD5 (&mdo);

        pthread_mutex_lock (&lock);
        if (counter == 0)
            vlc_rand_init ();
        val = counter++;

        AddMD5 (&mdi, ikey, sizeof (ikey));
        AddMD5 (&mdo, okey, sizeof (okey));
        pthread_mutex_unlock (&lock);

        AddMD5 (&mdi, &stamp, sizeof (stamp));
        AddMD5 (&mdi, &val, sizeof (val));
        EndMD5 (&mdi);
        AddMD5 (&mdo, mdi.buf, 16);
        EndMD5 (&mdo);

        if (len < 16)
        {
            memcpy (buf, mdo.buf, len);
            break;
        }

        memcpy (buf, mdo.buf, 16);
        len -= 16;
        buf = ((uint8_t *)buf) + 16;
    }
}",1,,78,3,,void
172224,BLOCK,-1,,"{
        uint64_t val;
        struct md5_s mdi, mdo;

        InitMD5 (&mdi);
        InitMD5 (&mdo);

        pthread_mutex_lock (&lock);
        if (counter == 0)
            vlc_rand_init ();
        val = counter++;

        AddMD5 (&mdi, ikey, sizeof (ikey));
        AddMD5 (&mdo, okey, sizeof (okey));
        pthread_mutex_unlock (&lock);

        AddMD5 (&mdi, &stamp, sizeof (stamp));
        AddMD5 (&mdi, &val, sizeof (val));
        EndMD5 (&mdi);
        AddMD5 (&mdo, mdi.buf, 16);
        EndMD5 (&mdo);

        if (len < 16)
        {
            memcpy (buf, mdo.buf, len);
            break;
        }

        memcpy (buf, mdo.buf, 16);
        len -= 16;
        buf = ((uint8_t *)buf) + 16;
    }",5,,85,2,,void
172241,BLOCK,-1,,<empty>,13,,94,2,,void
172293,BLOCK,-1,,"{
            memcpy (buf, mdo.buf, len);
            break;
        }",9,,108,2,,void
172335,BLOCK,-1,,<empty>,1,,1,1,,ANY
172338,BLOCK,-1,,"{
}",1,,36,2,,void
172345,BLOCK,-1,,"{
/* FIXME: could be replaced by using Unix sockets */
#ifdef HAVE_DBUS
# define MPRIS_APPEND ""/org/mpris/MediaPlayer2/TrackList/Append""
# define MPRIS_BUS_NAME ""org.mpris.MediaPlayer2.vlc""
# define MPRIS_OBJECT_PATH ""/org/mpris/MediaPlayer2""
# define MPRIS_TRACKLIST_INTERFACE ""org.mpris.MediaPlayer2.TrackList""

    dbus_threads_init_default();

    if (var_InheritBool(vlc, ""dbus""))
        libvlc_InternalAddIntf(vlc, ""dbus,none"");

    if (!var_InheritBool(vlc, ""one-instance"")
     && !(var_InheritBool(vlc, ""one-instance-when-started-from-file"")
       && var_InheritBool(vlc, ""started-from-file"")))
         return;

    for (int i = 0; i < argc; i++)
        if (argv[i][0] == ':')
        {
            msg_Err(vlc, ""item option %s incompatible with single instance"",
                    argv[i]);
            return;
        }

    char *name = var_GetString(vlc, ""dbus-mpris-name"");
    if (name != NULL)
    {
        bool singleton = !strcmp(name, MPRIS_BUS_NAME);
        free(name)...",1,,41,4,,void
172361,BLOCK,-1,,"{
    system_ConfigureDbus(libvlc, argc, argv);
}",1,,159,4,,void
172408,BLOCK,-1,,<empty>,1,,1,1,,ANY
172411,BLOCK,-1,,"{
    lldiv_t d = lldiv (date, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return ts;
}",1,,111,2,,void
172440,BLOCK,-1,,"{
     fprintf (stderr, ""at %s:%u in %s\n"", file, line, fn);
     fflush (stderr); /* needed before switch to low-level I/O */
#ifdef HAVE_BACKTRACE
     void *stack[20];
     int len = backtrace (stack, sizeof (stack) / sizeof (stack[0]));
     backtrace_symbols_fd (stack, len, 2);
#endif
     fsync (2);
}",1,,122,4,,void
172459,BLOCK,-1,,"{
    int canc = vlc_savecancel ();
    fprintf (stderr, ""LibVLC fatal error %s (%d) in thread %lu "",
             action, error, vlc_thread_id ());
    vlc_trace (function, file, line);
    perror (""Thread error"");
    fflush (stderr);

    vlc_restorecancel (canc);
    abort ();
}",1,,140,6,,void
172485,BLOCK,-1,,"{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
#ifdef NDEBUG
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);
#else
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_ERRORCHECK);
#endif
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,,160,2,,void
172492,BLOCK,-1,,<empty>,9,,164,2,,void
172504,BLOCK,-1,,<empty>,9,,171,2,,void
172513,BLOCK,-1,,"{
    pthread_mutexattr_t attr;

    if (unlikely(pthread_mutexattr_init (&attr)))
        abort();
    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
    if (unlikely(pthread_mutex_init (p_mutex, &attr)))
        abort();
    pthread_mutexattr_destroy( &attr );
}",1,,176,2,,void
172520,BLOCK,-1,,<empty>,9,,180,2,,void
172532,BLOCK,-1,,<empty>,9,,183,2,,void
172541,BLOCK,-1,,"{
    int val = pthread_mutex_destroy( p_mutex );
    VLC_THREAD_ASSERT (""destroying mutex"");
}",1,,188,2,,void
172548,BLOCK,1,,<empty>,,,,3,,void
172552,BLOCK,-1,,<empty>,5,,190,2,,void
172564,BLOCK,-1,,"{
    int val = pthread_mutex_lock( p_mutex );
    VLC_THREAD_ASSERT (""locking mutex"");
}",1,,212,2,,void
172571,BLOCK,1,,<empty>,,,,3,,void
172575,BLOCK,-1,,<empty>,5,,214,2,,void
172586,BLOCK,-1,,"{
    int val = pthread_mutex_trylock( p_mutex );

    if (val != EBUSY)
        VLC_THREAD_ASSERT (""locking mutex"");
    return val;
}",1,,218,2,,void
172596,BLOCK,-1,,<empty>,9,,222,2,,void
172598,BLOCK,1,,<empty>,,,,3,,void
172602,BLOCK,-1,,<empty>,9,,222,2,,void
172615,BLOCK,-1,,"{
    int val = pthread_mutex_unlock( p_mutex );
    VLC_THREAD_ASSERT (""unlocking mutex"");
}",1,,227,2,,void
172622,BLOCK,1,,<empty>,,,,3,,void
172626,BLOCK,-1,,<empty>,5,,229,2,,void
172637,BLOCK,-1,,"{
    pthread_condattr_t attr;

    if (unlikely(pthread_condattr_init (&attr)))
        abort ();
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    pthread_condattr_setclock (&attr, vlc_clock_id);
#endif
    if (unlikely(pthread_cond_init (p_condvar, &attr)))
        abort ();
    pthread_condattr_destroy (&attr);
}",1,,233,2,,void
172644,BLOCK,-1,,<empty>,9,,237,2,,void
172652,BLOCK,-1,,<empty>,9,,243,2,,void
172661,BLOCK,-1,,"{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",1,,248,2,,void
172667,BLOCK,-1,,<empty>,9,,250,2,,void
172673,BLOCK,-1,,"{
    int val = pthread_cond_destroy( p_condvar );
    VLC_THREAD_ASSERT (""destroying condition"");
}",1,,254,2,,void
172680,BLOCK,1,,<empty>,,,,3,,void
172684,BLOCK,-1,,<empty>,5,,256,2,,void
172695,BLOCK,-1,,"{
    int val = pthread_cond_signal( p_condvar );
    VLC_THREAD_ASSERT (""signaling condition variable"");
}",1,,260,2,,void
172702,BLOCK,1,,<empty>,,,,3,,void
172706,BLOCK,-1,,<empty>,5,,262,2,,void
172717,BLOCK,-1,,"{
    pthread_cond_broadcast (p_condvar);
}",1,,266,2,,void
172725,BLOCK,-1,,"{
    int val = pthread_cond_wait( p_condvar, p_mutex );
    VLC_THREAD_ASSERT (""waiting on condition"");
}",1,,271,3,,void
172733,BLOCK,1,,<empty>,,,,3,,void
172737,BLOCK,-1,,<empty>,5,,273,2,,void
172750,BLOCK,-1,,"{
    struct timespec ts = mtime_to_ts (deadline);
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,,278,4,,void
172768,BLOCK,-1,,<empty>,9,,282,2,,void
172770,BLOCK,1,,<empty>,,,,3,,void
172774,BLOCK,-1,,<empty>,9,,282,2,,void
172789,BLOCK,-1,,"{
    struct timespec ts = { deadline, 0 };
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",1,,288,4,,void
172808,BLOCK,-1,,<empty>,9,,292,2,,void
172810,BLOCK,1,,<empty>,,,,3,,void
172814,BLOCK,-1,,<empty>,9,,292,2,,void
172828,BLOCK,-1,,"{
    if (unlikely(sem_init (sem, 0, value)))
        abort ();
}",1,,297,3,,void
172835,BLOCK,-1,,<empty>,9,,299,2,,void
172841,BLOCK,-1,,"{
    int val;

    if (likely(sem_destroy (sem) == 0))
        return;

    val = errno;

    VLC_THREAD_ASSERT (""destroying semaphore"");
}",1,,303,2,,void
172849,BLOCK,-1,,<empty>,9,,307,2,,void
172855,BLOCK,1,,<empty>,,,,3,,void
172859,BLOCK,-1,,<empty>,5,,311,2,,void
172870,BLOCK,-1,,"{
    int val;

    if (likely(sem_post (sem) == 0))
        return 0;

    val = errno;

    if (unlikely(val != EOVERFLOW))
        VLC_THREAD_ASSERT (""unlocking semaphore"");
    return val;
}",1,,315,2,,void
172878,BLOCK,-1,,<empty>,9,,319,2,,void
172889,BLOCK,-1,,<empty>,9,,324,2,,void
172891,BLOCK,1,,<empty>,,,,3,,void
172895,BLOCK,-1,,<empty>,9,,324,2,,void
172908,BLOCK,-1,,"{
    int val;

    do
        if (likely(sem_wait (sem) == 0))
            return;
    while ((val = errno) == EINTR);

    VLC_THREAD_ASSERT (""locking semaphore"");
}",1,,329,2,,void
172917,BLOCK,-1,,<empty>,13,,334,2,,void
172925,BLOCK,1,,<empty>,,,,3,,void
172929,BLOCK,-1,,<empty>,5,,337,2,,void
172940,BLOCK,-1,,"{
    if (unlikely(pthread_rwlock_init (lock, NULL)))
        abort ();
}",1,,341,2,,void
172946,BLOCK,-1,,<empty>,9,,343,2,,void
172952,BLOCK,-1,,"{
    int val = pthread_rwlock_destroy (lock);
    VLC_THREAD_ASSERT (""destroying R/W lock"");
}",1,,347,2,,void
172959,BLOCK,1,,<empty>,,,,3,,void
172963,BLOCK,-1,,<empty>,5,,349,2,,void
172974,BLOCK,-1,,"{
    int val = pthread_rwlock_rdlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for reading"");
}",1,,353,2,,void
172981,BLOCK,1,,<empty>,,,,3,,void
172985,BLOCK,-1,,<empty>,5,,355,2,,void
172996,BLOCK,-1,,"{
    int val = pthread_rwlock_wrlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for writing"");
}",1,,359,2,,void
173003,BLOCK,1,,<empty>,,,,3,,void
173007,BLOCK,-1,,<empty>,5,,361,2,,void
173018,BLOCK,-1,,"{
    int val = pthread_rwlock_unlock (lock);
    VLC_THREAD_ASSERT (""releasing R/W lock"");
}",1,,365,2,,void
173025,BLOCK,1,,<empty>,,,,3,,void
173029,BLOCK,-1,,<empty>,5,,367,2,,void
173041,BLOCK,-1,,"{
    return pthread_key_create (key, destr);
}",1,,371,3,,void
173050,BLOCK,-1,,"{
    pthread_key_delete (*p_tls);
}",1,,376,2,,void
173059,BLOCK,-1,,"{
    return pthread_setspecific (key, value);
}",1,,381,3,,void
173068,BLOCK,-1,,"{
    return pthread_getspecific (key);
}",1,,386,2,,void
173081,BLOCK,-1,,"{
    static vlc_mutex_t lock = VLC_STATIC_MUTEX;
    static bool initialized = false;

    vlc_mutex_lock (&lock);
    /* Initializes real-time priorities before any thread is created,
     * just once per process. */
    if (!initialized)
    {
        if (var_InheritBool (p_libvlc, ""rt-priority""))
        {
            rt_offset = var_InheritInteger (p_libvlc, ""rt-offset"");
            rt_priorities = true;
        }
        initialized = true;
    }
    vlc_mutex_unlock (&lock);
}",1,,394,2,,void
173096,BLOCK,-1,,"{
        if (var_InheritBool (p_libvlc, ""rt-priority""))
        {
            rt_offset = var_InheritInteger (p_libvlc, ""rt-offset"");
            rt_priorities = true;
        }
        initialized = true;
    }",5,,402,2,,void
173101,BLOCK,-1,,"{
            rt_offset = var_InheritInteger (p_libvlc, ""rt-offset"");
            rt_priorities = true;
        }",9,,404,2,,void
173124,BLOCK,-1,,"{
    int ret;

    /* Block the signals that signals interface plugin handles.
     * If the LibVLC caller wants to handle some signals by itself, it should
     * block these before whenever invoking LibVLC. And it must obviously not
     * start the VLC signals interface plugin.
     *
     * LibVLC will normally ignore any interruption caused by an asynchronous
     * signal during a system call. But there may well be some buggy cases
     * where it fails to handle EINTR (bug reports welcome). Some underlying
     * libraries might also not handle EINTR properly.
     */
    sigset_t oldset;
    {
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }

#if defined (_POSIX_PRIORITY_SCHEDULING) && (_POSIX_PRIORITY_SCHED...",1,,416,6,,void
173127,BLOCK,3,,"{
        sigset_t set;
        sigemptyset (&set);
        sigdelset (&set, SIGHUP);
        sigaddset (&set, SIGINT);
        sigaddset (&set, SIGQUIT);
        sigaddset (&set, SIGTERM);

        sigaddset (&set, SIGPIPE); /* We don't want this one, really! */
        pthread_sigmask (SIG_BLOCK, &set, &oldset);
    }",5,,430,3,,void
173166,BLOCK,1,,<empty>,,,,1,,void
173203,BLOCK,-1,,"{
    pthread_attr_t attr;

    pthread_attr_init (&attr);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,,490,5,,void
173221,BLOCK,-1,,"{
    int val = pthread_join(th.handle, result);
    VLC_THREAD_ASSERT (""joining thread"");
}",1,,498,3,,void
173231,BLOCK,1,,<empty>,,,,3,,void
173235,BLOCK,-1,,<empty>,5,,500,2,,void
173249,BLOCK,-1,,"{
    vlc_thread_t dummy;
    pthread_attr_t attr;

    if (th == NULL)
        th = &dummy;

    pthread_attr_init (&attr);
    pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
    return vlc_clone_attr (th, &attr, entry, data, priority);
}",1,,535,5,,void
173256,BLOCK,-1,,<empty>,9,,540,2,,void
173280,BLOCK,-1,,"{
    vlc_thread_t thread = { pthread_self() };
    return thread;
}",1,,548,2,,void
173292,BLOCK,-1,,"{
     return -1;
}",1,,555,2,,void
173301,BLOCK,-1,,"{
#if defined (_POSIX_PRIORITY_SCHEDULING) && (_POSIX_PRIORITY_SCHEDULING >= 0) \
 && defined (_POSIX_THREAD_PRIORITY_SCHEDULING) \
 && (_POSIX_THREAD_PRIORITY_SCHEDULING >= 0)
    if (rt_priorities)
    {
        struct sched_param sp = { .sched_priority = priority + rt_offset, };
        int policy;

        if (sp.sched_priority <= 0)
            sp.sched_priority += sched_get_priority_max (policy = SCHED_OTHER);
        else
            sp.sched_priority += sched_get_priority_min (policy = SCHED_RR);

        if (pthread_setschedparam(th.handle, policy, &sp))
            return VLC_EGENERIC;
    }
#else
    (void) th; (void) priority;
#endif
    return VLC_SUCCESS;
}",1,,561,3,,void
173314,BLOCK,-1,,"{
    pthread_cancel(th.handle);
}",1,,585,2,,void
173323,BLOCK,-1,,"{
    int state;
    int val = pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);

    VLC_THREAD_ASSERT (""saving cancellation"");
    return state;
}",1,,590,2,,void
173333,BLOCK,1,,<empty>,,,,3,,void
173337,BLOCK,-1,,<empty>,5,,594,2,,void
173350,BLOCK,-1,,"{
#ifndef NDEBUG
    int oldstate, val;

    val = pthread_setcancelstate (state, &oldstate);
    /* This should fail if an invalid value for given for state */
    VLC_THREAD_ASSERT (""restoring cancellation"");

    if (unlikely(oldstate != PTHREAD_CANCEL_DISABLE))
         vlc_thread_fatal (""restoring cancellation while not disabled"", EINVAL,
                           __func__, __FILE__, __LINE__);
#else
    pthread_setcancelstate (state, NULL);
#endif
}",1,,599,2,,void
173360,BLOCK,1,,<empty>,,,,3,,void
173364,BLOCK,-1,,<empty>,5,,605,2,,void
173376,BLOCK,-1,,<empty>,10,,608,2,,void
173382,BLOCK,1,,<empty>,,,,1,,void
173385,BLOCK,1,,<empty>,,,,1,,void
173391,BLOCK,-1,,"{
    pthread_testcancel ();
}",1,,616,2,,void
173397,BLOCK,-1,,"{
    (void) cmd;
    vlc_assert_unreachable ();
}",1,,621,2,,void
173406,BLOCK,-1,,"{
#if (_POSIX_TIMERS > 0)
    struct timespec ts;

    vlc_clock_setup ();
    if (unlikely(clock_gettime (vlc_clock_id, &ts) != 0))
        abort ();

    return (INT64_C(1000000) * ts.tv_sec) + (ts.tv_nsec / 1000);

#else
    struct timeval tv;

    if (unlikely(gettimeofday (&tv, NULL) != 0))
        abort ();
    return (INT64_C(1000000) * tv.tv_sec) + tv.tv_usec;

#endif
}",1,,627,2,,void
173416,BLOCK,-1,,<empty>,9,,641,2,,void
173433,BLOCK,-1,,"{
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    /* If the deadline is already elapsed, or within the clock precision,
     * do not even bother the system timer. */
    deadline -= vlc_clock_prec;

    struct timespec ts = mtime_to_ts (deadline);

    while (clock_nanosleep (vlc_clock_id, TIMER_ABSTIME, &ts, NULL) == EINTR);

#else
    deadline -= mdate ();
    if (deadline > 0)
        msleep (deadline);

#endif
}",1,,649,2,,void
173441,BLOCK,-1,,<empty>,9,,663,2,,void
173448,BLOCK,-1,,"{
    struct timespec ts = mtime_to_ts (delay);

#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    while (clock_nanosleep (vlc_clock_id, 0, &ts, &ts) == EINTR);

#else
    while (nanosleep (&ts, &ts) == -1)
        assert (errno == EINTR);

#endif
}",1,,670,2,,void
173471,BLOCK,-1,,"{
#if defined(HAVE_SCHED_GETAFFINITY)
    cpu_set_t cpu;

    CPU_ZERO(&cpu);
    if (sched_getaffinity (0, sizeof (cpu), &cpu) < 0)
        return 1;

    return CPU_COUNT (&cpu);

#elif defined(__SunOS)
    unsigned count = 0;
    int type;
    u_int numcpus;
    processor_info_t cpuinfo;

    processorid_t *cpulist = vlc_alloc (sysconf(_SC_NPROCESSORS_MAX), sizeof (*cpulist));
    if (unlikely(cpulist == NULL))
        return 1;

    if (pset_info(PS_MYID, &type, &numcpus, cpulist) == 0)
    {
        for (u_int i = 0; i < numcpus; i++)
            if (processor_info (cpulist[i], &cpuinfo) == 0)
                count += (cpuinfo.pi_state == P_ONLINE);
    }
    else
        count = sysconf (_SC_NPROCESSORS_ONLN);
    free (cpulist);
    return count ? count : 1;
#elif defined(_SC_NPROCESSORS_ONLN)
    return sysconf(_SC_NPROCESSORS_ONLN);
#elif defined(_SC_NPROCESSORS_CONF)
    return sysconf(_SC_NPROCESSORS_CONF);
#else
#   warning ""vlc_GetCPUCount is not implemented for your pl...",1,,685,2,,void
173494,BLOCK,-1,,<empty>,1,,1,1,,ANY
173501,BLOCK,-1,,<empty>,,,,2,,<empty>
173511,BLOCK,-1,,"{
    struct vlc_timer *timer = data;

    vlc_mutex_lock (&timer->lock);
    mutex_cleanup_push (&timer->lock);

    for (;;)
    {
        while (timer->value == 0)
        {
            assert(timer->interval == 0);
            vlc_cond_wait (&timer->reschedule, &timer->lock);
        }

        if (timer->interval != 0)
        {
            mtime_t now = mdate();

            if (now > timer->value)
            {   /* Update overrun counter */
                unsigned misses = (now - timer->value) / timer->interval;

                timer->value += misses * timer->interval;
                assert(timer->value <= now);
                atomic_fetch_add_explicit(&timer->overruns, misses,
                                          memory_order_relaxed);
            }
        }

        mtime_t value = timer->value;

        if (vlc_cond_timedwait(&timer->reschedule, &timer->lock, value) == 0)
            continue;

        if (likely(timer->value <= value))
        {
            tim...",1,,54,2,,void
173527,BLOCK,-1,,<empty>,5,,60,1,,void
173528,BLOCK,4,,"{
        while (timer->value == 0)
        {
            assert(timer->interval == 0);
            vlc_cond_wait (&timer->reschedule, &timer->lock);
        }

        if (timer->interval != 0)
        {
            mtime_t now = mdate();

            if (now > timer->value)
            {   /* Update overrun counter */
                unsigned misses = (now - timer->value) / timer->interval;

                timer->value += misses * timer->interval;
                assert(timer->value <= now);
                atomic_fetch_add_explicit(&timer->overruns, misses,
                                          memory_order_relaxed);
            }
        }

        mtime_t value = timer->value;

        if (vlc_cond_timedwait(&timer->reschedule, &timer->lock, value) == 0)
            continue;

        if (likely(timer->value <= value))
        {
            timer->value += timer->interval; /* rearm */

            if (timer->interval == 0)
                timer->value = 0; /* disarm */
   ...",5,,61,4,,void
173535,BLOCK,-1,,"{
            assert(timer->interval == 0);
            vlc_cond_wait (&timer->reschedule, &timer->lock);
        }",9,,63,2,,void
173557,BLOCK,-1,,"{
            mtime_t now = mdate();

            if (now > timer->value)
            {   /* Update overrun counter */
                unsigned misses = (now - timer->value) / timer->interval;

                timer->value += misses * timer->interval;
                assert(timer->value <= now);
                atomic_fetch_add_explicit(&timer->overruns, misses,
                                          memory_order_relaxed);
            }
        }",9,,69,2,,void
173568,BLOCK,-1,,"{   /* Update overrun counter */
                unsigned misses = (now - timer->value) / timer->interval;

                timer->value += misses * timer->interval;
                assert(timer->value <= now);
                atomic_fetch_add_explicit(&timer->overruns, misses,
                                          memory_order_relaxed);
            }",13,,73,2,,void
173622,BLOCK,-1,,<empty>,13,,86,2,,void
173631,BLOCK,-1,,"{
            timer->value += timer->interval; /* rearm */

            if (timer->interval == 0)
                timer->value = 0; /* disarm */
        }",9,,89,2,,void
173645,BLOCK,-1,,<empty>,17,,93,2,,void
173682,BLOCK,-1,,"{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (unlikely(timer == NULL))
        return ENOMEM;
    vlc_mutex_init (&timer->lock);
    vlc_cond_init (&timer->reschedule);
    assert (func);
    timer->func = func;
    timer->data = data;
    timer->value = 0;
    timer->interval = 0;
    atomic_init(&timer->overruns, 0);

    if (vlc_clone (&timer->thread, vlc_timer_thread, timer,
                   VLC_THREAD_PRIORITY_INPUT))
    {
        vlc_cond_destroy (&timer->reschedule);
        vlc_mutex_destroy (&timer->lock);
        free (timer);
        return ENOMEM;
    }

    *id = timer;
    return 0;
}",1,,110,4,,void
173695,BLOCK,-1,,<empty>,9,,114,2,,void
173745,BLOCK,-1,,"{
        vlc_cond_destroy (&timer->reschedule);
        vlc_mutex_destroy (&timer->lock);
        free (timer);
        return ENOMEM;
    }",5,,126,2,,void
173770,BLOCK,-1,,"{
    vlc_cancel (timer->thread);
    vlc_join (timer->thread, NULL);
    vlc_cond_destroy (&timer->reschedule);
    vlc_mutex_destroy (&timer->lock);
    free (timer);
}",1,,138,2,,void
173799,BLOCK,-1,,"{
    if (value == 0)
        interval = 0;
    else
    if (!absolute)
        value += mdate();

    vlc_mutex_lock (&timer->lock);
    timer->value = value;
    timer->interval = interval;
    vlc_cond_signal (&timer->reschedule);
    vlc_mutex_unlock (&timer->lock);
}",1,,148,5,,void
173804,BLOCK,-1,,<empty>,9,,150,2,,void
173809,BLOCK,-1,,<empty>,5,,152,1,,void
173813,BLOCK,-1,,<empty>,9,,153,2,,void
173846,BLOCK,-1,,"{
    return atomic_exchange_explicit (&timer->overruns, 0,
                                     memory_order_relaxed);
}",1,,163,2,,void
173885,BLOCK,-1,,<empty>,1,,1,1,,ANY
173906,BLOCK,-1,,<empty>,,,,1,,<empty>
173923,BLOCK,-1,,<empty>,,,,2,,<empty>
173929,BLOCK,-1,,"{
    int fd = net_ConnectUDP (obj, group, IPPORT_SAP, 255);
    if (fd == -1)
        return NULL;

    sap_address_t *addr = malloc (sizeof (*addr));
    if (addr == NULL)
    {
        net_Close (fd);
        return NULL;
    }

    strlcpy (addr->group, group, sizeof (addr->group));
    addr->fd = fd;
    addr->origlen = sizeof (addr->orig);
    getsockname (fd, (struct sockaddr *)&addr->orig, &addr->origlen);

    addr->interval = var_CreateGetInteger (obj, ""sap-interval"");
    vlc_mutex_init (&addr->lock);
    vlc_cond_init (&addr->wait);
    addr->session_count = 0;
    addr->first = NULL;

    if (vlc_clone (&addr->thread, RunThread, addr, VLC_THREAD_PRIORITY_LOW))
    {
        msg_Err (obj, ""unable to spawn SAP announce thread"");
        net_Close (fd);
        free (addr);
        return NULL;
    }
    return addr;
}",1,,85,3,,void
173937,BLOCK,1,,<empty>,,,,1,,void
173945,BLOCK,-1,,<empty>,9,,88,2,,void
173959,BLOCK,-1,,"{
        net_Close (fd);
        return NULL;
    }",5,,92,2,,void
174034,BLOCK,-1,,"{
        msg_Err (obj, ""unable to spawn SAP announce thread"");
        net_Close (fd);
        free (addr);
        return NULL;
    }",5,,109,2,,void
174050,BLOCK,-1,,"{
    assert (addr->first == NULL);

    vlc_cancel (addr->thread);
    vlc_join (addr->thread, NULL);
    vlc_cond_destroy (&addr->wait);
    vlc_mutex_destroy (&addr->lock);
    net_Close (addr->fd);
    free (addr);
}",1,,119,2,,void
174087,BLOCK,-1,,"{
    sap_address_t *addr = self;

    vlc_mutex_lock (&addr->lock);
    mutex_cleanup_push (&addr->lock);

    for (;;)
    {
        session_descriptor_t *p_session;
        mtime_t deadline;

        while (addr->first == NULL)
            vlc_cond_wait (&addr->wait, &addr->lock);

        assert (addr->session_count > 0);

        deadline = mdate ();
        for (p_session = addr->first; p_session; p_session = p_session->next)
        {
            send (addr->fd, p_session->data, p_session->length, 0);
            deadline += addr->interval * CLOCK_FREQ / addr->session_count;

            if (vlc_cond_timedwait (&addr->wait, &addr->lock, deadline) == 0)
                break; /* list may have changed! */
        }
    }

    vlc_cleanup_pop ();
    vlc_assert_unreachable ();
}",1,,136,2,,void
174103,BLOCK,-1,,<empty>,5,,142,1,,void
174104,BLOCK,4,,"{
        session_descriptor_t *p_session;
        mtime_t deadline;

        while (addr->first == NULL)
            vlc_cond_wait (&addr->wait, &addr->lock);

        assert (addr->session_count > 0);

        deadline = mdate ();
        for (p_session = addr->first; p_session; p_session = p_session->next)
        {
            send (addr->fd, p_session->data, p_session->length, 0);
            deadline += addr->interval * CLOCK_FREQ / addr->session_count;

            if (vlc_cond_timedwait (&addr->wait, &addr->lock, deadline) == 0)
                break; /* list may have changed! */
        }
    }",5,,143,4,,void
174132,BLOCK,-1,,<empty>,9,,153,1,,void
174144,BLOCK,4,,"{
            send (addr->fd, p_session->data, p_session->length, 0);
            deadline += addr->interval * CLOCK_FREQ / addr->session_count;

            if (vlc_cond_timedwait (&addr->wait, &addr->lock, deadline) == 0)
                break; /* list may have changed! */
        }",9,,154,4,,void
174180,BLOCK,-1,,<empty>,17,,159,2,,void
174190,BLOCK,-1,,"{
    int i;
    char psz_addr[NI_MAXNUMERICHOST];
    union
    {
        struct sockaddr     a;
        struct sockaddr_in  in;
        struct sockaddr_in6 in6;
    } addr;
    socklen_t addrlen = 0;
    struct addrinfo *res;

    msg_Dbg (obj, ""adding SAP session"");

    if (vlc_getaddrinfo (dst, 0, NULL, &res) == 0)
    {
        if (res->ai_addrlen <= sizeof (addr))
            memcpy (&addr, res->ai_addr, res->ai_addrlen);
        addrlen = res->ai_addrlen;
        freeaddrinfo (res);
    }

    if (addrlen == 0 || addrlen > sizeof (addr))
    {
        msg_Err (obj, ""No/invalid address specified for SAP announce"" );
        return NULL;
    }

    /* Determine SAP multicast address automatically */
    switch (addr.a.sa_family)
    {
#if defined (HAVE_INET_PTON) || defined (_WIN32)
        case AF_INET6:
        {
            /* See RFC3513 for list of valid IPv6 scopes */
            struct in6_addr *a6 = &addr.in6.sin6_addr;

            memcpy( a6->s6_addr + 2, ""\x00\x00\x...",1,,179,4,,void
174211,BLOCK,-1,,"{
        if (res->ai_addrlen <= sizeof (addr))
            memcpy (&addr, res->ai_addr, res->ai_addrlen);
        addrlen = res->ai_addrlen;
        freeaddrinfo (res);
    }",5,,194,2,,void
174219,BLOCK,-1,,<empty>,13,,196,2,,void
174245,BLOCK,-1,,"{
        msg_Err (obj, ""No/invalid address specified for SAP announce"" );
        return NULL;
    }",5,,202,2,,void
174257,BLOCK,-1,,"{
#if defined (HAVE_INET_PTON) || defined (_WIN32)
        case AF_INET6:
        {
            /* See RFC3513 for list of valid IPv6 scopes */
            struct in6_addr *a6 = &addr.in6.sin6_addr;

            memcpy( a6->s6_addr + 2, ""\x00\x00\x00\x00\x00\x00""
                   ""\x00\x00\x00\x00\x00\x02\x7f\xfe"", 14 );
            if( IN6_IS_ADDR_MULTICAST( a6 ) )
                /* force flags to zero, preserve scope */
                a6->s6_addr[1] &= 0xf;
            else
                /* Unicast IPv6 - assume global scope */
                memcpy( a6->s6_addr, ""\xff\x0e"", 2 );
            break;
        }
#endif

        case AF_INET:
        {
            /* See RFC2365 for IPv4 scopes */
            uint32_t ipv4 = addr.in.sin_addr.s_addr;

            /* 224.0.0.0/24 => 224.0.0.255 */
            if ((ipv4 & htonl (0xffffff00)) == htonl (0xe0000000))
                ipv4 =  htonl (0xe00000ff);
            else
            /* 239.255.0.0/16 => 239.255.255.255 */
      ...",5,,209,2,,void
174260,BLOCK,3,,"{
            /* See RFC2365 for IPv4 scopes */
            uint32_t ipv4 = addr.in.sin_addr.s_addr;

            /* 224.0.0.0/24 => 224.0.0.255 */
            if ((ipv4 & htonl (0xffffff00)) == htonl (0xe0000000))
                ipv4 =  htonl (0xe00000ff);
            else
            /* 239.255.0.0/16 => 239.255.255.255 */
            if ((ipv4 & htonl (0xffff0000)) == htonl (0xefff0000))
                ipv4 =  htonl (0xefffffff);
            else
            /* 239.192.0.0/14 => 239.195.255.255 */
            if ((ipv4 & htonl (0xfffc0000)) == htonl (0xefc00000))
                ipv4 =  htonl (0xefc3ffff);
            else
            if ((ipv4 & htonl (0xff000000)) == htonl (0xef000000))
                ipv4 = 0;
            else
            /* other addresses => 224.2.127.254 */
                ipv4 = htonl (0xe0027ffe);

            if( ipv4 == 0 )
            {
                msg_Err (obj, ""Out-of-scope multicast address ""
                         ""not supported by SAP"");
...",9,,229,3,,void
174279,BLOCK,-1,,<empty>,17,,235,2,,void
174285,BLOCK,-1,,<empty>,13,,238,1,,void
174294,BLOCK,-1,,<empty>,17,,239,2,,void
174300,BLOCK,-1,,<empty>,13,,242,1,,void
174309,BLOCK,-1,,<empty>,17,,243,2,,void
174315,BLOCK,-1,,<empty>,13,,245,1,,void
174324,BLOCK,-1,,<empty>,17,,246,2,,void
174329,BLOCK,-1,,<empty>,17,,249,1,,void
174338,BLOCK,-1,,"{
                msg_Err (obj, ""Out-of-scope multicast address ""
                         ""not supported by SAP"");
                return NULL;
            }",13,,252,2,,void
174380,BLOCK,-1,,"{
        msg_Err (obj, ""%s"", gai_strerror (i));
        return NULL;
    }",5,,272,2,,void
174397,BLOCK,-1,,<empty>,5,,282,1,,void
174414,BLOCK,-1,,<empty>,13,,284,2,,void
174420,BLOCK,-1,,"{
        sap_addr = AddressCreate (obj, psz_addr);
        if (sap_addr == NULL)
        {
            vlc_mutex_unlock (&sap_mutex);
            return NULL;
        }
        sap_addr->next = sap_addrs;
        sap_addrs = sap_addr;
    }",5,,287,2,,void
174430,BLOCK,-1,,"{
            vlc_mutex_unlock (&sap_mutex);
            return NULL;
        }",9,,290,2,,void
174464,BLOCK,-1,,<empty>,9,,304,2,,void
174504,BLOCK,-1,,"{
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct in6_addr *a6 =
                &((const struct sockaddr_in6 *)&sap_addr->orig)->sin6_addr;
            vlc_memstream_write(&stream, &a6, 16);
            break;
        }
#endif
        case AF_INET:
        {
            const struct in_addr *a4 =
                &((const struct sockaddr_in *)&sap_addr->orig)->sin_addr;
            vlc_memstream_write(&stream, &a4, 4);
            break;
        }
        default:
            vlc_assert_unreachable ();
    }",5,,323,2,,void
174507,BLOCK,3,,"{
            const struct in_addr *a4 =
                &((const struct sockaddr_in *)&sap_addr->orig)->sin_addr;
            vlc_memstream_write(&stream, &a4, 4);
            break;
        }",9,,334,3,,void
174545,BLOCK,-1,,"{
        free(session);
        session = NULL;
        goto out;
    }",5,,351,2,,void
174593,BLOCK,-1,,"{
    sap_address_t *addr, **paddr;
    session_descriptor_t **psession;

    msg_Dbg (obj, ""removing SAP session"");
    vlc_mutex_lock (&sap_mutex);
    paddr = &sap_addrs;
    for (;;)
    {
        addr = *paddr;
        assert (addr != NULL);

        psession = &addr->first;
        vlc_mutex_lock (&addr->lock);
        while (*psession != NULL)
        {
            if (*psession == session)
                goto found;
            psession = &(*psession)->next;
        }
        vlc_mutex_unlock (&addr->lock);
        paddr = &addr->next;
    }

found:
    *psession = session->next;

    if (addr->first == NULL)
        /* Last session for this address -> unlink the address */
        *paddr = addr->next;
    vlc_mutex_unlock (&sap_mutex);

    if (addr->first == NULL)
    {
        /* Last session for this address -> unlink the address */
        vlc_mutex_unlock (&addr->lock);
        AddressDestroy (addr);
    }
    else
    {
        addr->session_count--;
        vlc_cond...",1,,375,3,,void
174608,BLOCK,-1,,<empty>,5,,382,1,,void
174609,BLOCK,4,,"{
        addr = *paddr;
        assert (addr != NULL);

        psession = &addr->first;
        vlc_mutex_lock (&addr->lock);
        while (*psession != NULL)
        {
            if (*psession == session)
                goto found;
            psession = &(*psession)->next;
        }
        vlc_mutex_unlock (&addr->lock);
        paddr = &addr->next;
    }",5,,383,4,,void
174634,BLOCK,-1,,"{
            if (*psession == session)
                goto found;
            psession = &(*psession)->next;
        }",9,,390,2,,void
174640,BLOCK,-1,,<empty>,17,,392,2,,void
174673,BLOCK,-1,,<empty>,9,,404,2,,void
174689,BLOCK,-1,,"{
        /* Last session for this address -> unlink the address */
        vlc_mutex_unlock (&addr->lock);
        AddressDestroy (addr);
    }",5,,408,2,,void
174698,BLOCK,-1,,"{
        addr->session_count--;
        vlc_cond_signal (&addr->wait);
        vlc_mutex_unlock (&addr->lock);
    }",5,,414,1,,void
174747,BLOCK,-1,,<empty>,1,,1,1,,ANY
174752,BLOCK,-1,,"{
    if (addrlen < offsetof (struct sockaddr, sa_family)
                 + sizeof (addr->sa_family))
        return NULL;

    strcpy (buf, ""IN IP* "");

    if (vlc_getnameinfo (addr, addrlen, buf + 7, MAXSDPADDRESS - 7, NULL,
                         NI_NUMERICHOST))
        return NULL;

    switch (addr->sa_family)
    {
        case AF_INET:
        {
            if (net_SockAddrIsMulticast (addr, addrlen))
                strcat (buf, ""/255""); // obsolete in RFC4566, dummy value
            buf[5] = '4';
            break;
        }

#ifdef AF_INET6
        case AF_INET6:
        {
            char *ptr = strchr (buf, '%');
            if (ptr != NULL)
                *ptr = '\0'; // remove scope ID
            buf[5] = '6';
            break;
        }
#endif

        default:
            return NULL;
    }

    return buf;
}",1,,43,4,,void
174755,BLOCK,-1,,<empty>,9,,46,2,,void
174770,BLOCK,1,,<empty>,,,,1,,void
174775,BLOCK,-1,,<empty>,9,,52,2,,void
174782,BLOCK,-1,,"{
        case AF_INET:
        {
            if (net_SockAddrIsMulticast (addr, addrlen))
                strcat (buf, ""/255""); // obsolete in RFC4566, dummy value
            buf[5] = '4';
            break;
        }

#ifdef AF_INET6
        case AF_INET6:
        {
            char *ptr = strchr (buf, '%');
            if (ptr != NULL)
                *ptr = '\0'; // remove scope ID
            buf[5] = '6';
            break;
        }
#endif

        default:
            return NULL;
    }",5,,55,2,,void
174785,BLOCK,3,,"{
            if (net_SockAddrIsMulticast (addr, addrlen))
                strcat (buf, ""/255""); // obsolete in RFC4566, dummy value
            buf[5] = '4';
            break;
        }",9,,57,3,,void
174790,BLOCK,-1,,<empty>,17,,59,2,,void
174809,BLOCK,-1,,"{
    if (strchr (str, '\r') != NULL)
        return false;
    if (strchr (str, '\n') != NULL)
        return false;
    if (!IsUTF8 (str))
        return false;
    return true;
}",1,,84,2,,void
174816,BLOCK,-1,,<empty>,9,,86,2,,void
174825,BLOCK,-1,,<empty>,9,,88,2,,void
174832,BLOCK,-1,,<empty>,9,,90,2,,void
174844,BLOCK,-1,,"{
    vlc_memstream_printf(stream, ""a=%s:"", name);
    vlc_memstream_vprintf(stream, fmt, ap);
    vlc_memstream_puts(stream, ""\r\n"");
}",1,,96,5,,void
174862,BLOCK,-1,,"{
    va_list ap;

    va_start(ap, fmt);
    vsdp_AddAttribute(stream, name, fmt, ap);
    va_end(ap);
}",1,,104,4,,void
174888,BLOCK,-1,,"{
    /* Some default values */
    if (type == NULL)
        type = ""video"";
    if (proto == NULL)
        proto = ""RTP/AVP"";
    assert (pt < 128u);

    vlc_memstream_printf(stream, ""m=%s %u %s %u\r\n"", type, dport, proto, pt);

    if (bw > 0)
        vlc_memstream_printf(stream, ""b=%s:%u\r\n"",
                             bw_indep ? ""TIAS"" : ""AS"", bw);
    vlc_memstream_printf(stream, ""b=%s:%u\r\n"", ""RR"", 0);

    /* RTP payload type map */
    if (ptname != NULL)
    {
        vlc_memstream_printf(stream, ""a=rtpmap:%u %s/%u"", pt, ptname, clock);
        if ((strcmp(type, ""audio"") == 0) && (chans != 1))
            vlc_memstream_printf(stream, ""/%u"", chans);
        vlc_memstream_puts(stream, ""\r\n"");
    }

    /* Format parameters */
    if (fmtp != NULL)
        vlc_memstream_printf(stream, ""a=fmtp:%u %s\r\n"", pt, fmtp);
}",1,,117,12,,void
174893,BLOCK,-1,,<empty>,9,,120,2,,void
174901,BLOCK,-1,,<empty>,9,,122,2,,void
174920,BLOCK,-1,,<empty>,9,,128,2,,void
174938,BLOCK,-1,,"{
        vlc_memstream_printf(stream, ""a=rtpmap:%u %s/%u"", pt, ptname, clock);
        if ((strcmp(type, ""audio"") == 0) && (chans != 1))
            vlc_memstream_printf(stream, ""/%u"", chans);
        vlc_memstream_puts(stream, ""\r\n"");
    }",5,,134,2,,void
174955,BLOCK,-1,,<empty>,13,,137,2,,void
174967,BLOCK,-1,,<empty>,9,,143,2,,void
174983,BLOCK,-1,,"{
    char connection[MAXSDPADDRESS];
    char *str = NULL;

    size_t cfglen = strlen(cfgpref);
    if (cfglen >= 128)
        return -1;

    char varname[cfglen + sizeof (""description"")];
    char *subvar = varname + cfglen;

    strcpy(varname, cfgpref);

    vlc_memstream_open(stream);
    vlc_memstream_puts(stream, ""v=0\r\n"");

    if (AddressToSDP(addr, addrlen, connection) == NULL)
        goto error;
    {
        const uint_fast64_t now = NTPtime64();
        char hostname[256];

        gethostname(hostname, sizeof (hostname));

        vlc_memstream_printf(stream, ""o=- %""PRIu64"" %""PRIu64"" IN IP%c %s\r\n"",
                             now, now, connection[5], hostname);
    }

    strcpy(subvar, ""name"");
    str = var_GetNonEmptyString(obj, varname);
    if (str != NULL)
    {
        if (!IsSDPString(str))
            goto error;

        vlc_memstream_printf(stream, ""s=%s\r\n"", str);
        free(str);
    }
    else
        vlc_memstream_printf(stream, ""s=%s\r\n"", ""Un...",1,,150,8,,void
174998,BLOCK,-1,,<empty>,9,,156,2,,void
175024,BLOCK,-1,,<empty>,9,,167,2,,void
175026,BLOCK,14,,"{
        const uint_fast64_t now = NTPtime64();
        char hostname[256];

        gethostname(hostname, sizeof (hostname));

        vlc_memstream_printf(stream, ""o=- %""PRIu64"" %""PRIu64"" IN IP%c %s\r\n"",
                             now, now, connection[5], hostname);
    }",5,,168,14,,void
175049,BLOCK,-1,,"{
        if (!IsSDPString(str))
            goto error;

        vlc_memstream_printf(stream, ""s=%s\r\n"", str);
        free(str);
    }",5,,181,2,,void
175054,BLOCK,-1,,<empty>,13,,183,2,,void
175063,BLOCK,-1,,<empty>,9,,189,1,,void
175080,BLOCK,-1,,"{
        if (!IsSDPString(str))
            goto error;

        vlc_memstream_printf(stream, ""i=%s\r\n"", str);
        free(str);
    }",5,,194,2,,void
175085,BLOCK,-1,,<empty>,13,,196,2,,void
175094,BLOCK,-1,,<empty>,9,,202,1,,void
175111,BLOCK,-1,,"{
        if (!IsSDPString(str))
            goto error;

        vlc_memstream_printf(stream, ""u=%s\r\n"", str);
        free(str);
    }",5,,207,2,,void
175116,BLOCK,-1,,<empty>,13,,209,2,,void
175136,BLOCK,-1,,"{
        if (!IsSDPString(str))
            goto error;

        vlc_memstream_printf(stream, ""e=%s\r\n"", str);
        free(str);
    }",5,,218,2,,void
175141,BLOCK,-1,,<empty>,13,,220,2,,void
175173,BLOCK,-1,,"{
        char machine[MAXSDPADDRESS];

        if (AddressToSDP(src, srclen, machine) != NULL)
            vlc_memstream_printf(stream,
                                 ""a=source-filter: incl IN IP%c * %s\r\n"",
                                 machine[5], machine + 7);
    }",5,,241,2,,void
175182,BLOCK,-1,,<empty>,13,,245,2,,void
175204,BLOCK,-1,,"{
        if (IsSDPString(str))
            goto error;

        vlc_memstream_printf(stream, ""a=cat:%s\r\n"", str);
        vlc_memstream_printf(stream, ""a=x-plgroup:%s\r\n"", str);
        free(str);
    }",5,,253,2,,void
175208,BLOCK,-1,,<empty>,13,,255,2,,void
175230,BLOCK,-1,,<empty>,9,,265,2,,void
175270,BLOCK,-1,,<empty>,1,,1,1,,ANY
175274,BLOCK,-1,,<empty>,,,,3,,<empty>
175285,BLOCK,-1,,<empty>,,,,3,,<empty>
175290,BLOCK,-1,,<empty>,,,,2,,<empty>
175296,BLOCK,-1,,"{
    sout_instance_t *p_sout;
    char *psz_chain;

    assert( psz_dest != NULL );

    if( psz_dest[0] == '#' )
    {
        psz_chain = strdup( &psz_dest[1] );
    }
    else
    {
        psz_chain = sout_stream_url_to_chain(
            var_InheritBool(p_parent, ""sout-display""), psz_dest );
    }
    if(!psz_chain)
        return NULL;

    /* *** Allocate descriptor *** */
    p_sout = vlc_custom_create( p_parent, sizeof( *p_sout ), ""stream output"" );
    if( p_sout == NULL )
    {
        free( psz_chain );
        return NULL;
    }

    msg_Dbg( p_sout, ""using sout chain=`%s'"", psz_chain );

    /* *** init descriptor *** */
    p_sout->psz_sout    = strdup( psz_dest );
    p_sout->i_out_pace_nocontrol = 0;

    vlc_mutex_init( &p_sout->lock );
    p_sout->p_stream = NULL;

    var_Create( p_sout, ""sout-mux-caching"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    p_sout->p_stream = sout_StreamChainNew( p_sout, psz_chain, NULL, NULL );
    if( p_sout->p_stream )
    {
       ...",1,,82,3,,void
175309,BLOCK,-1,,"{
        psz_chain = strdup( &psz_dest[1] );
    }",5,,89,2,,void
175318,BLOCK,-1,,"{
        psz_chain = sout_stream_url_to_chain(
            var_InheritBool(p_parent, ""sout-display""), psz_dest );
    }",5,,93,1,,void
175329,BLOCK,-1,,<empty>,9,,98,2,,void
175344,BLOCK,-1,,"{
        free( psz_chain );
        return NULL;
    }",5,,103,2,,void
175393,BLOCK,-1,,"{
        free( psz_chain );
        return p_sout;
    }",5,,121,2,,void
175421,BLOCK,-1,,"{
    /* remove the stream out chain */
    sout_StreamChainDelete( p_sout->p_stream, NULL );

    /* *** free all string *** */
    FREENULL( p_sout->psz_sout );

    vlc_mutex_destroy( &p_sout->lock );

    /* *** free structure *** */
    vlc_object_release( p_sout );
}",1,,140,2,,void
175443,BLOCK,-1,,"{
    sout_packetizer_input_t *p_input;

    /* *** create a packetizer input *** */
    if( !p_fmt->i_codec || !(p_input = malloc(sizeof(sout_packetizer_input_t))) )
        return NULL;

    p_input->p_sout = p_sout;

    msg_Dbg( p_sout, ""adding a new sout input for `%4.4s` (sout_input: %p)"",
             (char*) &p_fmt->i_codec, (void *)p_input );

    /* *** add it to the stream chain */
    vlc_mutex_lock( &p_sout->lock );
    p_input->id = p_sout->p_stream->pf_add( p_sout->p_stream, p_fmt );
    vlc_mutex_unlock( &p_sout->lock );

    if( p_input->id == NULL )
    {
        msg_Warn( p_sout, ""new sout input failed (sout_input: %p)"",
                 (void *)p_input );
        free( p_input );
        p_input = NULL;
    }

    return( p_input );
}",1,,158,3,,void
175457,BLOCK,-1,,<empty>,9,,163,2,,void
175507,BLOCK,-1,,"{
        msg_Warn( p_sout, ""new sout input failed (sout_input: %p)"",
                 (void *)p_input );
        free( p_input );
        p_input = NULL;
    }",5,,176,2,,void
175525,BLOCK,-1,,"{
    sout_instance_t     *p_sout = p_input->p_sout;

    msg_Dbg( p_sout, ""removing a sout input (sout_input: %p)"",
             (void *)p_input );

    vlc_mutex_lock( &p_sout->lock );
    p_sout->p_stream->pf_del( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );

    free( p_input );

    return( VLC_SUCCESS);
}",1,,190,2,,void
175568,BLOCK,-1,,"{
    sout_instance_t *p_sout = p_input->p_sout;
    bool b;

    vlc_mutex_lock( &p_sout->lock );
    if( sout_StreamControl( p_sout->p_stream, SOUT_STREAM_EMPTY, &b ) != VLC_SUCCESS )
        b = true;
    vlc_mutex_unlock( &p_sout->lock );
    return b;
}",1,,206,2,,void
175591,BLOCK,-1,,<empty>,9,,212,2,,void
175606,BLOCK,-1,,"{
    sout_instance_t     *p_sout = p_input->p_sout;

    vlc_mutex_lock( &p_sout->lock );
    sout_StreamFlush( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );
}",1,,218,2,,void
175635,BLOCK,-1,,"{
    sout_instance_t     *p_sout = p_input->p_sout;
    int                 i_ret;

    vlc_mutex_lock( &p_sout->lock );
    i_ret = p_sout->p_stream->pf_send( p_sout->p_stream,
                                       p_input->id, p_buffer );
    vlc_mutex_unlock( &p_sout->lock );

    return i_ret;
}",1,,231,3,,void
175676,BLOCK,-1,,"{
    sout_access_out_t *p_access;
    char              *psz_next;

    p_access = vlc_custom_create( p_sout, sizeof( *p_access ), ""access out"" );
    if( !p_access )
        return NULL;

    psz_next = config_ChainCreate( &p_access->psz_access, &p_access->p_cfg,
                                   psz_access );
    free( psz_next );
    p_access->psz_path   = strdup( psz_name ? psz_name : """" );
    p_access->p_sys      = NULL;
    p_access->pf_seek    = NULL;
    p_access->pf_read    = NULL;
    p_access->pf_write   = NULL;
    p_access->pf_control = NULL;
    p_access->p_module   = NULL;

    p_access->p_module   =
        module_need( p_access, ""sout access"", p_access->psz_access, true );

    if( !p_access->p_module )
    {
        free( p_access->psz_access );
        free( p_access->psz_path );
        vlc_object_release( p_access );
        return( NULL );
    }

    return p_access;
}",1,,249,4,,void
175690,BLOCK,-1,,<empty>,9,,255,2,,void
175762,BLOCK,-1,,"{
        free( p_access->psz_access );
        free( p_access->psz_path );
        vlc_object_release( p_access );
        return( NULL );
    }",5,,272,2,,void
175781,BLOCK,-1,,"{
    if( p_access->p_module )
    {
        module_unneed( p_access, p_access->p_module );
    }
    free( p_access->psz_access );

    config_ChainDestroy( p_access->p_cfg );

    free( p_access->psz_path );

    vlc_object_release( p_access );
}",1,,285,2,,void
175786,BLOCK,-1,,"{
        module_unneed( p_access, p_access->p_module );
    }",5,,287,2,,void
175811,BLOCK,-1,,"{
    if (p_access->pf_seek == NULL)
        return VLC_EGENERIC;
    return p_access->pf_seek( p_access, i_pos );
}",1,,303,3,,void
175818,BLOCK,-1,,<empty>,9,,305,2,,void
175833,BLOCK,-1,,"{
    return( p_access->pf_read ?
            p_access->pf_read( p_access, p_buffer ) : VLC_EGENERIC );
}",1,,313,3,,void
175851,BLOCK,-1,,"{
    return p_access->pf_write( p_access, p_buffer );
}",1,,322,3,,void
175864,BLOCK,-1,,"{
    va_list ap;
    int ret;

    va_start (ap, query);
    if (access->pf_control)
        ret = access->pf_control (access, query, ap);
    else
        ret = VLC_EGENERIC;
    va_end (ap);
    return ret;
}",1,,330,3,,void
175874,BLOCK,-1,,<empty>,9,,336,2,,void
175885,BLOCK,-1,,<empty>,9,,338,1,,void
175899,BLOCK,-1,,"{
    sout_mux_t *p_mux;
    char       *psz_next;

    p_mux = vlc_custom_create( p_sout, sizeof( *p_mux ), ""mux"" );
    if( p_mux == NULL )
        return NULL;

    p_mux->p_sout = p_sout;
    psz_next = config_ChainCreate( &p_mux->psz_mux, &p_mux->p_cfg, psz_mux );
    free( psz_next );

    p_mux->p_access     = p_access;
    p_mux->pf_control   = NULL;
    p_mux->pf_addstream = NULL;
    p_mux->pf_delstream = NULL;
    p_mux->pf_mux       = NULL;
    p_mux->i_nb_inputs  = 0;
    p_mux->pp_inputs    = NULL;

    p_mux->p_sys        = NULL;
    p_mux->p_module     = NULL;

    p_mux->b_add_stream_any_time = false;
    p_mux->b_waiting_stream = true;
    p_mux->i_add_stream_start = -1;

    p_mux->p_module =
        module_need( p_mux, ""sout mux"", p_mux->psz_mux, true );

    if( p_mux->p_module == NULL )
    {
        FREENULL( p_mux->psz_mux );

        vlc_object_release( p_mux );
        return NULL;
    }

    /* *** probe mux capacity *** */
    if( p_mux->pf_control )
    ...",1,,348,4,,void
175914,BLOCK,-1,,<empty>,9,,354,2,,void
176014,BLOCK,-1,,"{
        FREENULL( p_mux->psz_mux );

        vlc_object_release( p_mux );
        return NULL;
    }",5,,379,2,,void
176027,BLOCK,-1,,"{
        int b_answer = false;

        if( sout_MuxControl( p_mux, MUX_CAN_ADD_STREAM_WHILE_MUXING,
                             &b_answer ) )
        {
            b_answer = false;
        }

        if( b_answer )
        {
            msg_Dbg( p_sout, ""muxer support adding stream at any time"" );
            p_mux->b_add_stream_any_time = true;
            p_mux->b_waiting_stream = false;

            /* If we control the output pace then it's better to wait before
             * starting muxing (generates better streams/files). */
            if( !p_sout->i_out_pace_nocontrol )
            {
                b_answer = true;
            }
            else if( sout_MuxControl( p_mux, MUX_GET_ADD_STREAM_WAIT,
                                      &b_answer ) )
            {
                b_answer = false;
            }

            if( b_answer )
            {
                msg_Dbg( p_sout, ""muxer prefers to wait for all ES before ""
                         ""starting to mux"" ...",5,,388,2,,void
176038,BLOCK,-1,,"{
            b_answer = false;
        }",9,,393,2,,void
176044,BLOCK,-1,,"{
            msg_Dbg( p_sout, ""muxer support adding stream at any time"" );
            p_mux->b_add_stream_any_time = true;
            p_mux->b_waiting_stream = false;

            /* If we control the output pace then it's better to wait before
             * starting muxing (generates better streams/files). */
            if( !p_sout->i_out_pace_nocontrol )
            {
                b_answer = true;
            }
            else if( sout_MuxControl( p_mux, MUX_GET_ADD_STREAM_WAIT,
                                      &b_answer ) )
            {
                b_answer = false;
            }

            if( b_answer )
            {
                msg_Dbg( p_sout, ""muxer prefers to wait for all ES before ""
                         ""starting to mux"" );
                p_mux->b_waiting_stream = true;
            }
        }",9,,398,2,,void
176063,BLOCK,-1,,"{
                b_answer = true;
            }",13,,406,2,,void
176068,BLOCK,-1,,<empty>,18,,409,1,,void
176075,BLOCK,-1,,"{
                b_answer = false;
            }",13,,411,2,,void
176081,BLOCK,-1,,"{
                msg_Dbg( p_sout, ""muxer prefers to wait for all ES before ""
                         ""starting to mux"" );
                p_mux->b_waiting_stream = true;
            }",13,,416,2,,void
176096,BLOCK,-1,,"{
    if( p_mux->p_module )
    {
        module_unneed( p_mux, p_mux->p_module );
    }
    free( p_mux->psz_mux );

    config_ChainDestroy( p_mux->p_cfg );

    vlc_object_release( p_mux );
}",1,,431,2,,void
176101,BLOCK,-1,,"{
        module_unneed( p_mux, p_mux->p_module );
    }",5,,433,2,,void
176122,BLOCK,-1,,"{
    sout_input_t *p_input;

    if( !p_mux->b_add_stream_any_time && !p_mux->b_waiting_stream )
    {
        msg_Err( p_mux, ""cannot add a new stream (unsupported while muxing ""
                        ""to this format). You can try increasing sout-mux-caching value"" );
        return NULL;
    }

    msg_Dbg( p_mux, ""adding a new input"" );

    /* create a new sout input */
    p_input = malloc( sizeof( sout_input_t ) );
    if( !p_input )
        return NULL;

    // FIXME: remove either fmt or p_fmt...
    es_format_Copy( &p_input->fmt, p_fmt );
    p_input->p_fmt = &p_input->fmt;

    p_input->p_fifo = block_FifoNew();
    p_input->p_sys  = NULL;

    TAB_APPEND( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );
    if( p_mux->pf_addstream( p_mux, p_input ) < 0 )
    {
        msg_Err( p_mux, ""cannot add this stream"" );
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );
        block_FifoRelease( p_input->p_fifo );
        es_format_Clean( &p_input->fmt );
   ...",1,,447,3,,void
176134,BLOCK,-1,,"{
        msg_Err( p_mux, ""cannot add a new stream (unsupported while muxing ""
                        ""to this format). You can try increasing sout-mux-caching value"" );
        return NULL;
    }",5,,451,2,,void
176151,BLOCK,-1,,<empty>,9,,462,2,,void
176195,BLOCK,-1,,"{
        msg_Err( p_mux, ""cannot add this stream"" );
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );
        block_FifoRelease( p_input->p_fifo );
        es_format_Clean( &p_input->fmt );
        free( p_input );
        return NULL;
    }",5,,473,2,,void
176227,BLOCK,-1,,"{
    int i_index;

    if( p_mux->b_waiting_stream
     && block_FifoCount( p_input->p_fifo ) > 0 )
    {
        /* We stop waiting, and call the muxer for taking care of the data
         * before we remove this es */
        p_mux->b_waiting_stream = false;
        p_mux->pf_mux( p_mux );
    }

    TAB_FIND( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input, i_index );
    if( i_index >= 0 )
    {
        p_mux->pf_delstream( p_mux, p_input );

        /* remove the entry */
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );

        if( p_mux->i_nb_inputs == 0 )
        {
            msg_Warn( p_mux, ""no more input streams for this mux"" );
        }

        block_FifoRelease( p_input->p_fifo );
        es_format_Clean( &p_input->fmt );
        free( p_input );
    }
}",1,,489,3,,void
176240,BLOCK,-1,,"{
        /* We stop waiting, and call the muxer for taking care of the data
         * before we remove this es */
        p_mux->b_waiting_stream = false;
        p_mux->pf_mux( p_mux );
    }",5,,494,2,,void
176264,BLOCK,-1,,"{
        p_mux->pf_delstream( p_mux, p_input );

        /* remove the entry */
        TAB_REMOVE( p_mux->i_nb_inputs, p_mux->pp_inputs, p_input );

        if( p_mux->i_nb_inputs == 0 )
        {
            msg_Warn( p_mux, ""no more input streams for this mux"" );
        }

        block_FifoRelease( p_input->p_fifo );
        es_format_Clean( &p_input->fmt );
        free( p_input );
    }",5,,503,2,,void
176285,BLOCK,-1,,"{
            msg_Warn( p_mux, ""no more input streams for this mux"" );
        }",9,,510,2,,void
176306,BLOCK,-1,,"{
    mtime_t i_dts = p_buffer->i_dts;
    block_FifoPut( p_input->p_fifo, p_buffer );

    if( p_mux->p_sout->i_out_pace_nocontrol )
    {
        mtime_t current_date = mdate();
        if ( current_date > i_dts )
            msg_Warn( p_mux, ""late buffer for mux input (%""PRId64"")"",
                      current_date - i_dts );
    }

    if( p_mux->b_waiting_stream )
    {
        const int64_t i_caching = var_GetInteger( p_mux->p_sout, ""sout-mux-caching"" ) * INT64_C(1000);

        if( p_mux->i_add_stream_start < 0 )
            p_mux->i_add_stream_start = i_dts;

        /* Wait until we have enough data before muxing */
        if( p_mux->i_add_stream_start < 0 ||
            i_dts < p_mux->i_add_stream_start + i_caching )
            return VLC_SUCCESS;
        p_mux->b_waiting_stream = false;
    }
    return p_mux->pf_mux( p_mux );
}",1,,525,4,,void
176324,BLOCK,-1,,"{
        mtime_t current_date = mdate();
        if ( current_date > i_dts )
            msg_Warn( p_mux, ""late buffer for mux input (%""PRId64"")"",
                      current_date - i_dts );
    }",5,,530,2,,void
176334,BLOCK,-1,,"{
        const int64_t i_caching = var_GetInteger( p_mux->p_sout, ""sout-mux-caching"" ) * INT64_C(1000);

        if( p_mux->i_add_stream_start < 0 )
            p_mux->i_add_stream_start = i_dts;

        /* Wait until we have enough data before muxing */
        if( p_mux->i_add_stream_start < 0 ||
            i_dts < p_mux->i_add_stream_start + i_caching )
            return VLC_SUCCESS;
        p_mux->b_waiting_stream = false;
    }",5,,538,2,,void
176352,BLOCK,-1,,<empty>,13,,542,2,,void
176372,BLOCK,-1,,<empty>,13,,547,2,,void
176391,BLOCK,-1,,"{
    VLC_UNUSED(p_mux);
    block_FifoEmpty( p_input->p_fifo );
}",1,,554,3,,void
176404,BLOCK,-1,,"{
    mtime_t i_dts = 0;
    int     i_stream = -1;

    assert( i_blocks > 0 );

    for( int i = 0; i < p_mux->i_nb_inputs; i++ )
    {
        sout_input_t *p_input = p_mux->pp_inputs[i];
        block_t *p_data;

        if( block_FifoCount( p_input->p_fifo ) < i_blocks )
        {
            if( (!p_mux->b_add_stream_any_time) &&
                (p_input->p_fmt->i_cat != SPU_ES ) )
            {
                return -1;
            }
            /* FIXME: SPU muxing */
            continue;
        }

        p_data = block_FifoShow( p_input->p_fifo );
        if( i_stream < 0 || p_data->i_dts < i_dts )
        {
            i_stream = i;
            i_dts    = p_data->i_dts;
        }
    }

    if( pi_dts ) *pi_dts = i_dts;

    return i_stream;
}",1,,563,4,,void
176419,BLOCK,-1,,<empty>,5,,569,1,,void
176431,BLOCK,4,,"{
        sout_input_t *p_input = p_mux->pp_inputs[i];
        block_t *p_data;

        if( block_FifoCount( p_input->p_fifo ) < i_blocks )
        {
            if( (!p_mux->b_add_stream_any_time) &&
                (p_input->p_fmt->i_cat != SPU_ES ) )
            {
                return -1;
            }
            /* FIXME: SPU muxing */
            continue;
        }

        p_data = block_FifoShow( p_input->p_fifo );
        if( i_stream < 0 || p_data->i_dts < i_dts )
        {
            i_stream = i;
            i_dts    = p_data->i_dts;
        }
    }",5,,570,4,,void
176448,BLOCK,-1,,"{
            if( (!p_mux->b_add_stream_any_time) &&
                (p_input->p_fmt->i_cat != SPU_ES ) )
            {
                return -1;
            }
            /* FIXME: SPU muxing */
            continue;
        }",9,,575,2,,void
176462,BLOCK,-1,,"{
                return -1;
            }",13,,578,2,,void
176483,BLOCK,-1,,"{
            i_stream = i;
            i_dts    = p_data->i_dts;
        }",9,,587,2,,void
176494,BLOCK,-1,,<empty>,18,,593,2,,void
176506,BLOCK,-1,,"{
    char * psz_dup = strdup( psz_mrl );
    char * psz_parser = psz_dup;
    const char * psz_access;
    const char * psz_way;
    char * psz_name;

    /* *** first parse psz_dest */
    while( *psz_parser && *psz_parser != ':' )
    {
        if( *psz_parser == '{' )
        {
            while( *psz_parser && *psz_parser != '}' )
            {
                psz_parser++;
            }
            if( *psz_parser )
            {
                psz_parser++;
            }
        }
        else
        {
            psz_parser++;
        }
    }
#if defined( _WIN32 ) || defined( __OS2__ )
    if( psz_parser - psz_dup == 1 )
    {
        /* msg_Warn( p_sout, ""drive letter %c: found in source string"",
                          *psz_dup ) ; */
        *psz_parser = '\0';
    }
#endif

    if( !*psz_parser )
    {
        psz_access = psz_way = """";
        psz_name = psz_dup;
    }
    else
    {
        *psz_parser++ = '\0';

        /* let's skip '//' */
        if( psz_parser...",1,,603,3,,void
176527,BLOCK,-1,,"{
        if( *psz_parser == '{' )
        {
            while( *psz_parser && *psz_parser != '}' )
            {
                psz_parser++;
            }
            if( *psz_parser )
            {
                psz_parser++;
            }
        }
        else
        {
            psz_parser++;
        }
    }",5,,612,2,,void
176533,BLOCK,-1,,"{
            while( *psz_parser && *psz_parser != '}' )
            {
                psz_parser++;
            }
            if( *psz_parser )
            {
                psz_parser++;
            }
        }",9,,614,2,,void
176542,BLOCK,-1,,"{
                psz_parser++;
            }",13,,616,2,,void
176548,BLOCK,-1,,"{
                psz_parser++;
            }",13,,620,2,,void
176552,BLOCK,-1,,"{
            psz_parser++;
        }",9,,625,1,,void
176559,BLOCK,-1,,"{
        psz_access = psz_way = """";
        psz_name = psz_dup;
    }",5,,639,2,,void
176569,BLOCK,-1,,"{
        *psz_parser++ = '\0';

        /* let's skip '//' */
        if( psz_parser[0] == '/' && psz_parser[1] == '/' )
        {
            psz_parser += 2 ;
        }

        psz_name = psz_parser ;

        /* Come back to parse the access and mux plug-ins */
        psz_parser = psz_dup;

        if( !*psz_parser )
        {
            /* No access */
            psz_access = """";
        }
        else if( *psz_parser == '/' )
        {
            /* No access */
            psz_access = """";
            psz_parser++;
        }
        else
        {
            psz_access = psz_parser;

            while( *psz_parser && *psz_parser != '/' )
            {
                if( *psz_parser == '{' )
                {
                    while( *psz_parser && *psz_parser != '}' )
                    {
                        psz_parser++;
                    }
                    if( *psz_parser )
                    {
                        psz_parser++;
                    }
...",5,,644,1,,void
176587,BLOCK,-1,,"{
            psz_parser += 2 ;
        }",9,,649,2,,void
176601,BLOCK,-1,,"{
            /* No access */
            psz_access = """";
        }",9,,659,2,,void
176606,BLOCK,-1,,<empty>,14,,663,1,,void
176612,BLOCK,-1,,"{
            /* No access */
            psz_access = """";
            psz_parser++;
        }",9,,664,2,,void
176619,BLOCK,-1,,"{
            psz_access = psz_parser;

            while( *psz_parser && *psz_parser != '/' )
            {
                if( *psz_parser == '{' )
                {
                    while( *psz_parser && *psz_parser != '}' )
                    {
                        psz_parser++;
                    }
                    if( *psz_parser )
                    {
                        psz_parser++;
                    }
                }
                else
                {
                    psz_parser++;
                }
            }

            if( *psz_parser == '/' )
            {
                *psz_parser++ = '\0';
            }
        }",9,,670,1,,void
176631,BLOCK,-1,,"{
                if( *psz_parser == '{' )
                {
                    while( *psz_parser && *psz_parser != '}' )
                    {
                        psz_parser++;
                    }
                    if( *psz_parser )
                    {
                        psz_parser++;
                    }
                }
                else
                {
                    psz_parser++;
                }
            }",13,,674,2,,void
176637,BLOCK,-1,,"{
                    while( *psz_parser && *psz_parser != '}' )
                    {
                        psz_parser++;
                    }
                    if( *psz_parser )
                    {
                        psz_parser++;
                    }
                }",17,,676,2,,void
176646,BLOCK,-1,,"{
                        psz_parser++;
                    }",21,,678,2,,void
176652,BLOCK,-1,,"{
                        psz_parser++;
                    }",21,,682,2,,void
176656,BLOCK,-1,,"{
                    psz_parser++;
                }",17,,687,1,,void
176664,BLOCK,-1,,"{
                *psz_parser++ = '\0';
            }",13,,693,2,,void
176674,BLOCK,-1,,"{
            /* No mux */
            psz_way = """";
        }",9,,699,2,,void
176679,BLOCK,-1,,"{
            psz_way = psz_parser;
        }",9,,704,1,,void
176709,BLOCK,-1,,"{
    FREENULL( p_mrl->psz_access );
    FREENULL( p_mrl->psz_way );
    FREENULL( p_mrl->psz_name );
}",1,,720,2,,void
176726,BLOCK,-1,,"{
    sout_instance_t *p_sout = (sout_instance_t *)(p_stream->obj.parent);

    msg_Dbg( p_stream, ""destroying chain... (name=%s)"", p_stream->psz_name );

    p_sout->i_out_pace_nocontrol -= p_stream->pace_nocontrol;

    if( p_stream->p_module != NULL )
        module_unneed( p_stream, p_stream->p_module );

    FREENULL( p_stream->psz_name );

    config_ChainDestroy( p_stream->p_cfg );

    msg_Dbg( p_stream, ""destroying chain done"" );
    vlc_object_release( p_stream );
}",1,,737,2,,void
176756,BLOCK,-1,,<empty>,9,,745,2,,void
176780,BLOCK,-1,,"{
    while(p_first != NULL)
    {
        sout_stream_t *p_next = p_first->p_next;

        sout_StreamDelete(p_first);
        if(p_first == p_last)
           break;
        p_first = p_next;
    }
}",1,,763,3,,void
176785,BLOCK,-1,,"{
        sout_stream_t *p_next = p_first->p_next;

        sout_StreamDelete(p_first);
        if(p_first == p_last)
           break;
        p_first = p_next;
    }",5,,765,2,,void
176798,BLOCK,-1,,<empty>,12,,770,2,,void
176810,BLOCK,-1,,"{
    sout_stream_t *p_stream;

    assert(psz_name);

    p_stream = vlc_custom_create( p_sout, sizeof( *p_stream ), ""stream out"" );
    if( !p_stream )
        return NULL;

    p_stream->p_sout   = p_sout;
    p_stream->psz_name = psz_name;
    p_stream->p_cfg    = p_cfg;
    p_stream->p_next   = p_next;
    p_stream->pf_flush = NULL;
    p_stream->pf_control = NULL;
    p_stream->pace_nocontrol = false;
    p_stream->p_sys = NULL;

    msg_Dbg( p_sout, ""stream=`%s'"", p_stream->psz_name );

    p_stream->p_module =
        module_need( p_stream, ""sout stream"", p_stream->psz_name, true );

    if( !p_stream->p_module )
    {
        /* those must be freed by the caller if creation failed */
        p_stream->psz_name = NULL;
        p_stream->p_cfg = NULL;

        sout_StreamDelete( p_stream );
        return NULL;
    }

    p_sout->i_out_pace_nocontrol += p_stream->pace_nocontrol;
    return p_stream;
}",1,,781,5,,void
176825,BLOCK,-1,,<empty>,9,,788,2,,void
176890,BLOCK,-1,,"{
        /* those must be freed by the caller if creation failed */
        p_stream->psz_name = NULL;
        p_stream->p_cfg = NULL;

        sout_StreamDelete( p_stream );
        return NULL;
    }",5,,805,2,,void
176921,BLOCK,-1,,"{
    if(!psz_chain || !*psz_chain)
    {
        if(pp_last) *pp_last = NULL;
        return p_next;
    }

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    vlc_array_t cfg, name;
    vlc_array_init(&cfg);
    vlc_array_init(&name);

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        vlc_array_append_or_abort(&cfg, p_cfg);
        vlc_array_append_or_abort(&name, psz_name);
    }

    size_t i = vlc_array_count(&name);
    vlc_array_t module;
    vlc_array_init(&module);
    while(i--)
    {
        p_next = sout_StreamNew( p_sout, vlc_array_item_at_index(&name, i),
            vlc_array_item_at_index(&cfg, i), p_next);

        if(!p_next)
            goto error;

        if(i == vlc_array_count(&name) - 1 && pp_last)
            *pp_...",1,,831,5,,void
176929,BLOCK,-1,,"{
        if(pp_last) *pp_last = NULL;
        return p_next;
    }",5,,833,2,,void
176932,BLOCK,-1,,<empty>,21,,834,2,,void
176947,BLOCK,-1,,<empty>,9,,840,2,,void
176960,BLOCK,-1,,"{
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        vlc_array_append_or_abort(&cfg, p_cfg);
        vlc_array_append_or_abort(&name, psz_name);
    }",5,,848,2,,void
176998,BLOCK,-1,,"{
        p_next = sout_StreamNew( p_sout, vlc_array_item_at_index(&name, i),
            vlc_array_item_at_index(&cfg, i), p_next);

        if(!p_next)
            goto error;

        if(i == vlc_array_count(&name) - 1 && pp_last)
            *pp_last = p_next;   /* last module created in the chain */

        vlc_array_append_or_abort(&module, p_next);
    }",5,,863,2,,void
177015,BLOCK,-1,,<empty>,13,,868,2,,void
177027,BLOCK,-1,,<empty>,13,,871,2,,void
177070,BLOCK,-1,,"{
        free(vlc_array_item_at_index(&name, i));
        config_ChainDestroy(vlc_array_item_at_index(&cfg, i));
    }",5,,895,2,,void
177094,BLOCK,-1,,"{
    mrl_t       mrl;
    char        *psz_chain;

    mrl_Parse( &mrl, psz_url );

    /* Check if the URLs goes to #rtp - otherwise we'll use #standard */
    static const char rtplist[] = ""dccp\0sctp\0tcp\0udplite\0"";
    for (const char *a = rtplist; *a; a += strlen (a) + 1)
        if (strcmp (a, mrl.psz_access) == 0)
            goto rtp;

    if (strcmp (mrl.psz_access, ""rtp"") == 0)
    {
        char *port;
        /* For historical reasons, rtp:// means RTP over UDP */
        strcpy (mrl.psz_access, ""udp"");
rtp:
        if (mrl.psz_name[0] == '[')
        {
            port = strstr (mrl.psz_name, ""]:"");
            if (port != NULL)
                port++;
        }
        else
            port = strchr (mrl.psz_name, ':');
        if (port != NULL)
            *port++ = '\0'; /* erase ':' */

        if (asprintf (&psz_chain,
                      ""rtp{mux=\""%s\"",proto=\""%s\"",dst=\""%s%s%s\""}"",
                      mrl.psz_way, mrl.psz_access, mrl.psz_name,
           ...",1,,907,3,,void
177106,BLOCK,-1,,<empty>,5,,915,1,,void
177127,BLOCK,-1,,<empty>,13,,917,2,,void
177137,BLOCK,-1,,"{
        char *port;
        /* For historical reasons, rtp:// means RTP over UDP */
        strcpy (mrl.psz_access, ""udp"");
rtp:
        if (mrl.psz_name[0] == '[')
        {
            port = strstr (mrl.psz_name, ""]:"");
            if (port != NULL)
                port++;
        }
        else
            port = strchr (mrl.psz_name, ':');
        if (port != NULL)
            *port++ = '\0'; /* erase ':' */

        if (asprintf (&psz_chain,
                      ""rtp{mux=\""%s\"",proto=\""%s\"",dst=\""%s%s%s\""}"",
                      mrl.psz_way, mrl.psz_access, mrl.psz_name,
                      port ? ""\"",port=\"""" : """", port ? port : """") == -1)
            psz_chain = NULL;
    }",5,,920,2,,void
177153,BLOCK,-1,,"{
            port = strstr (mrl.psz_name, ""]:"");
            if (port != NULL)
                port++;
        }",9,,926,2,,void
177165,BLOCK,-1,,<empty>,17,,929,2,,void
177169,BLOCK,-1,,<empty>,13,,932,1,,void
177181,BLOCK,-1,,<empty>,13,,934,2,,void
177212,BLOCK,-1,,<empty>,13,,940,2,,void
177217,BLOCK,-1,,"{
        /* Convert the URL to a basic standard sout chain */
        if (asprintf (&psz_chain,
                      ""standard{mux=\""%s\"",access=\""%s\"",dst=\""%s\""}"",
                      mrl.psz_way, mrl.psz_access, mrl.psz_name) == -1)
            psz_chain = NULL;
    }",5,,943,1,,void
177235,BLOCK,-1,,<empty>,13,,948,2,,void
177243,BLOCK,-1,,"{
        char *tmp;
        if (asprintf (&tmp, ""duplicate{dst=display,dst=%s}"", psz_chain) == -1)
            tmp = NULL;
        free (psz_chain);
        psz_chain = tmp;
    }",5,,953,2,,void
177254,BLOCK,-1,,<empty>,13,,956,2,,void
177272,BLOCK,-1,,"{
    return vlc_custom_create( p_this, sizeof( encoder_t ), ""encoder"" );
}",1,,967,2,,void
177289,BLOCK,-1,,<empty>,1,,1,1,,ANY
177296,BLOCK,-1,,<empty>,,,,3,,<empty>
177301,BLOCK,-1,,<empty>,,,,2,,<empty>
177307,BLOCK,-1,,<empty>,,,,3,,<empty>
177312,BLOCK,-1,,<empty>,,,,2,,<empty>
177318,BLOCK,-1,,<empty>,,,,3,,<empty>
177323,BLOCK,-1,,<empty>,,,,2,,<empty>
177328,BLOCK,-1,,<empty>,,,,2,,<empty>
177351,BLOCK,-1,,<empty>,1,,1,1,,ANY
177355,BLOCK,-1,,"{
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t oldloc = uselocale (loc);
    double res = strtod (str, end);

    if (loc != (locale_t)0)
    {
        uselocale (oldloc);
        freelocale (loc);
    }
    return res;
}",1,,51,3,,void
177380,BLOCK,-1,,"{
        uselocale (oldloc);
        freelocale (loc);
    }",5,,57,2,,void
177392,BLOCK,-1,,"{
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t oldloc = uselocale (loc);
    float res = strtof (str, end);

    if (loc != (locale_t)0)
    {
        uselocale (oldloc);
        freelocale (loc);
    }
    return res;
}",1,,70,3,,void
177417,BLOCK,-1,,"{
        uselocale (oldloc);
        freelocale (loc);
    }",5,,76,2,,void
177428,BLOCK,-1,,"{
    return us_strtod( str, NULL );
}",1,,89,2,,void
177439,BLOCK,-1,,"{
    locale_t loc = newlocale( LC_NUMERIC_MASK, ""C"", NULL );
    locale_t oldloc = uselocale( loc );

    int i_rc = vasprintf( ret, format, ap );

    if ( loc != (locale_t)0 )
    {
        uselocale( oldloc );
        freelocale( loc );
    }

    return i_rc;
}",1,,99,4,,void
177465,BLOCK,-1,,"{
        uselocale( oldloc );
        freelocale( loc );
    }",5,,106,2,,void
177477,BLOCK,-1,,"{
    va_list ap;
    int i_rc;

    va_start( ap, format );
    i_rc = us_vasprintf( ret, format, ap );
    va_end( ap );

    return i_rc;
}",1,,120,3,,void
177519,BLOCK,-1,,<empty>,1,,1,1,,ANY
177523,BLOCK,-1,,"{
    int rwflags = 0, oflags = 0;

    for (const char *ptr = mode; *ptr; ptr++)
    {
        switch (*ptr)
        {
            case 'r':
                rwflags = O_RDONLY;
                break;

            case 'a':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_APPEND;
                break;

            case 'w':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_TRUNC;
                break;

            case 'x':
                oflags |= O_EXCL;
                break;

            case '+':
                rwflags = O_RDWR;
                break;

#ifdef O_BINARY
            case 'b':
                oflags = (oflags & ~O_TEXT) | O_BINARY;
                break;

            case 't':
                oflags = (oflags & ~O_BINARY) | O_TEXT;
                break;
#endif
        }
    }

    int fd = vlc_open (filename, rwflags | oflags, 0666);
    if (fd == -1)
        return NULL;

    FILE *stream = fdopen (fd, mode);
 ...",1,,49,3,,void
177533,BLOCK,-1,,<empty>,5,,52,1,,void
177542,BLOCK,4,,"{
        switch (*ptr)
        {
            case 'r':
                rwflags = O_RDONLY;
                break;

            case 'a':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_APPEND;
                break;

            case 'w':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_TRUNC;
                break;

            case 'x':
                oflags |= O_EXCL;
                break;

            case '+':
                rwflags = O_RDWR;
                break;

#ifdef O_BINARY
            case 'b':
                oflags = (oflags & ~O_TEXT) | O_BINARY;
                break;

            case 't':
                oflags = (oflags & ~O_BINARY) | O_TEXT;
                break;
#endif
        }
    }",5,,53,4,,void
177546,BLOCK,-1,,"{
            case 'r':
                rwflags = O_RDONLY;
                break;

            case 'a':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_APPEND;
                break;

            case 'w':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_TRUNC;
                break;

            case 'x':
                oflags |= O_EXCL;
                break;

            case '+':
                rwflags = O_RDWR;
                break;

#ifdef O_BINARY
            case 'b':
                oflags = (oflags & ~O_TEXT) | O_BINARY;
                break;

            case 't':
                oflags = (oflags & ~O_BINARY) | O_TEXT;
                break;
#endif
        }",9,,55,2,,void
177601,BLOCK,-1,,<empty>,9,,92,2,,void
177614,BLOCK,-1,,<empty>,9,,96,2,,void
177623,BLOCK,-1,,"{
    (void)str;
    return 1;
}",1,,103,2,,void
177636,BLOCK,-1,,"{
    assert (dir);

    if (select == NULL)
        select = dummy_select;

    char **tab = NULL;
    unsigned num = 0;

    rewinddir (dir);

    for (unsigned size = 0;;)
    {
        errno = 0;
        const char *entry = vlc_readdir (dir);
        if (entry == NULL)
        {
            if (errno)
                goto error;
            break;
        }

        if (!select (entry))
            continue;

        if (num >= size)
        {
            size = size ? (2 * size) : 16;
            char **newtab = realloc (tab, sizeof (*tab) * (size));

            if (unlikely(newtab == NULL))
                goto error;
            tab = newtab;
        }

        tab[num] = strdup(entry);
        if (likely(tab[num] != NULL))
            num++;
    }

    if (compar != NULL && num > 0)
        qsort (tab, num, sizeof (*tab),
               (int (*)( const void *, const void *))compar);
    *namelist = tab;
    return num;

error:
    for (unsigned i = 0; i < num; i++)
        ...",1,,115,5,,void
177643,BLOCK,-1,,<empty>,9,,119,2,,void
177658,BLOCK,-1,,<empty>,5,,126,1,,void
177663,BLOCK,4,,"{
        errno = 0;
        const char *entry = vlc_readdir (dir);
        if (entry == NULL)
        {
            if (errno)
                goto error;
            break;
        }

        if (!select (entry))
            continue;

        if (num >= size)
        {
            size = size ? (2 * size) : 16;
            char **newtab = realloc (tab, sizeof (*tab) * (size));

            if (unlikely(newtab == NULL))
                goto error;
            tab = newtab;
        }

        tab[num] = strdup(entry);
        if (likely(tab[num] != NULL))
            num++;
    }",5,,127,4,,void
177676,BLOCK,-1,,"{
            if (errno)
                goto error;
            break;
        }",9,,131,2,,void
177679,BLOCK,-1,,<empty>,17,,133,2,,void
177686,BLOCK,-1,,<empty>,13,,138,2,,void
177692,BLOCK,-1,,"{
            size = size ? (2 * size) : 16;
            char **newtab = realloc (tab, sizeof (*tab) * (size));

            if (unlikely(newtab == NULL))
                goto error;
            tab = newtab;
        }",9,,141,2,,void
177716,BLOCK,-1,,<empty>,17,,146,2,,void
177734,BLOCK,-1,,<empty>,13,,152,2,,void
177745,BLOCK,-1,,<empty>,9,,156,2,,void
177763,BLOCK,-1,,<empty>,5,,162,1,,void
177789,BLOCK,-1,,"{
    DIR *dir = vlc_opendir (dirname);
    int val = -1;

    if (dir != NULL)
    {
        val = vlc_loaddir (dir, namelist, select, compar);
        closedir (dir);
    }
    return val;
}",1,,182,5,,void
177804,BLOCK,-1,,"{
        val = vlc_loaddir (dir, namelist, select, compar);
        closedir (dir);
    }",5,,187,2,,void
177822,BLOCK,-1,,<empty>,1,,1,1,,ANY
178848,BLOCK,-1,,<empty>,1,,1,1,,ANY
178859,BLOCK,-1,,"{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_1, psz_code, 2 ) )
            return p_lang;

    return &unknown_language;
}",1,,48,2,,void
178862,BLOCK,-1,,<empty>,5,,51,1,,void
178879,BLOCK,-1,,<empty>,13,,53,2,,void
178889,BLOCK,-1,,"{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2T, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",1,,59,2,,void
178892,BLOCK,-1,,<empty>,5,,62,1,,void
178909,BLOCK,-1,,<empty>,13,,64,2,,void
178919,BLOCK,-1,,"{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2B, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",1,,70,2,,void
178922,BLOCK,-1,,<empty>,5,,73,1,,void
178939,BLOCK,-1,,<empty>,13,,75,2,,void
178959,BLOCK,-1,,<empty>,1,,1,1,,ANY
178962,BLOCK,-1,,"{
    ms->error = 0;
    ms->ptr = calloc(1, 1);
    if (unlikely(ms->ptr == NULL))
        ms->error = EOF;
    ms->length = 0;
    return ms->error;
}",1,,106,2,,void
178982,BLOCK,-1,,<empty>,9,,110,2,,void
179001,BLOCK,-1,,"{
    return ms->error;
}",1,,116,2,,void
179010,BLOCK,-1,,"{
    if (ms->error)
        free(ms->ptr);
    return ms->error;
}",1,,121,2,,void
179015,BLOCK,-1,,<empty>,9,,123,2,,void
179030,BLOCK,-1,,"{
    char *base = realloc(ms->ptr, ms->length + len + 1u);
    if (unlikely(base == NULL))
        goto error;

    memcpy(base + ms->length, ptr, len);
    ms->ptr = base;
    ms->length += len;
    base[ms->length] = '\0';
    return len;

error:
    ms->error = EOF;
    return 0;
}",1,,129,4,,void
179050,BLOCK,-1,,<empty>,9,,132,2,,void
179092,BLOCK,-1,,"{
    return (vlc_memstream_write(ms, &(unsigned char){ c }, 1u) == 1) ? c : EOF;
}",1,,146,3,,void
179112,BLOCK,-1,,"{
    size_t len = strlen(str);
    return (vlc_memstream_write(ms, str, len) == len) ? 0 : EOF;
}",1,,151,3,,void
179134,BLOCK,-1,,"{
    va_list ap;
    char *ptr;
    int len;

    va_copy(ap, args);
    len = vsnprintf(NULL, 0, fmt, ap);
    va_end(ap);

    if (len < 0)
        goto error;

    ptr = realloc(ms->ptr, ms->length + len + 1);
    if (ptr == NULL)
        goto error;

    vsnprintf(ptr + ms->length, len + 1, fmt, args);
    ms->ptr = ptr;
    ms->length += len;
    return len;

error:
    ms->error = EOF;
    return EOF;
}",1,,158,4,,void
179154,BLOCK,-1,,<empty>,9,,168,2,,void
179173,BLOCK,-1,,<empty>,9,,172,2,,void
179211,BLOCK,-1,,"{
    va_list ap;
    int ret;

    va_start(ap, fmt);
    ret = vlc_memstream_vprintf(ms, fmt, ap);
    va_end(ap);
    return ret;
}",1,,186,3,,void
179265,BLOCK,-1,,<empty>,1,,1,1,,ANY
179270,BLOCK,-1,,<empty>,,,,1,,<empty>
179656,BLOCK,-1,,"{
    const struct xml_entity_s *ent = elem;
    const char *name = key;

    return strncmp (name, ent->psz_entity, strlen (ent->psz_entity));
}",1,,191,3,,void
179679,BLOCK,-1,,"{
    char *p_pos = psz_value;

    while ( *psz_value )
    {
        if( *psz_value == '&' )
        {
            if( psz_value[1] == '#' )
            {   /* &#DDD; or &#xHHHH; Unicode code point */
                char *psz_end;
                unsigned long cp;

                if( psz_value[2] == 'x' ) /* The x must be lower-case. */
                    cp = strtoul( psz_value + 3, &psz_end, 16 );
                else
                    cp = strtoul( psz_value + 2, &psz_end, 10 );

                if( *psz_end == ';' )
                {
                    psz_value = psz_end + 1;
                    if( cp == 0 )
                        (void)0; /* skip nulls */
                    else
                    if( cp <= 0x7F )
                    {
                        *p_pos =            cp;
                    }
                    else
                    /* Unicode code point outside ASCII.
                     * &#xxx; representation is longer than UTF-8 :) */
         ...",1,,199,2,,void
179687,BLOCK,-1,,"{
        if( *psz_value == '&' )
        {
            if( psz_value[1] == '#' )
            {   /* &#DDD; or &#xHHHH; Unicode code point */
                char *psz_end;
                unsigned long cp;

                if( psz_value[2] == 'x' ) /* The x must be lower-case. */
                    cp = strtoul( psz_value + 3, &psz_end, 16 );
                else
                    cp = strtoul( psz_value + 2, &psz_end, 10 );

                if( *psz_end == ';' )
                {
                    psz_value = psz_end + 1;
                    if( cp == 0 )
                        (void)0; /* skip nulls */
                    else
                    if( cp <= 0x7F )
                    {
                        *p_pos =            cp;
                    }
                    else
                    /* Unicode code point outside ASCII.
                     * &#xxx; representation is longer than UTF-8 :) */
                    if( cp <= 0x7FF )
                    {
          ...",5,,203,2,,void
179693,BLOCK,-1,,"{
            if( psz_value[1] == '#' )
            {   /* &#DDD; or &#xHHHH; Unicode code point */
                char *psz_end;
                unsigned long cp;

                if( psz_value[2] == 'x' ) /* The x must be lower-case. */
                    cp = strtoul( psz_value + 3, &psz_end, 16 );
                else
                    cp = strtoul( psz_value + 2, &psz_end, 10 );

                if( *psz_end == ';' )
                {
                    psz_value = psz_end + 1;
                    if( cp == 0 )
                        (void)0; /* skip nulls */
                    else
                    if( cp <= 0x7F )
                    {
                        *p_pos =            cp;
                    }
                    else
                    /* Unicode code point outside ASCII.
                     * &#xxx; representation is longer than UTF-8 :) */
                    if( cp <= 0x7FF )
                    {
                        *p_pos++ = 0xC0 |  (cp >>  6...",9,,205,2,,void
179700,BLOCK,-1,,"{   /* &#DDD; or &#xHHHH; Unicode code point */
                char *psz_end;
                unsigned long cp;

                if( psz_value[2] == 'x' ) /* The x must be lower-case. */
                    cp = strtoul( psz_value + 3, &psz_end, 16 );
                else
                    cp = strtoul( psz_value + 2, &psz_end, 10 );

                if( *psz_end == ';' )
                {
                    psz_value = psz_end + 1;
                    if( cp == 0 )
                        (void)0; /* skip nulls */
                    else
                    if( cp <= 0x7F )
                    {
                        *p_pos =            cp;
                    }
                    else
                    /* Unicode code point outside ASCII.
                     * &#xxx; representation is longer than UTF-8 :) */
                    if( cp <= 0x7FF )
                    {
                        *p_pos++ = 0xC0 |  (cp >>  6);
                        *p_pos   = 0x80 |  (cp   ...",13,,207,2,,void
179709,BLOCK,-1,,<empty>,21,,212,2,,void
179720,BLOCK,-1,,<empty>,21,,214,1,,void
179735,BLOCK,-1,,"{
                    psz_value = psz_end + 1;
                    if( cp == 0 )
                        (void)0; /* skip nulls */
                    else
                    if( cp <= 0x7F )
                    {
                        *p_pos =            cp;
                    }
                    else
                    /* Unicode code point outside ASCII.
                     * &#xxx; representation is longer than UTF-8 :) */
                    if( cp <= 0x7FF )
                    {
                        *p_pos++ = 0xC0 |  (cp >>  6);
                        *p_pos   = 0x80 |  (cp        & 0x3F);
                    }
                    else
                    if( cp <= 0xFFFF )
                    {
                        *p_pos++ = 0xE0 |  (cp >> 12);
                        *p_pos++ = 0x80 | ((cp >>  6) & 0x3F);
                        *p_pos   = 0x80 |  (cp        & 0x3F);
                    }
                    else
                    if( cp <= 0x1FFFFF ) /* ...",17,,217,2,,void
179745,BLOCK,-1,,<empty>,25,,220,2,,void
179750,BLOCK,-1,,<empty>,21,,222,1,,void
179755,BLOCK,-1,,"{
                        *p_pos =            cp;
                    }",21,,223,2,,void
179761,BLOCK,-1,,<empty>,21,,229,1,,void
179766,BLOCK,-1,,"{
                        *p_pos++ = 0xC0 |  (cp >>  6);
                        *p_pos   = 0x80 |  (cp        & 0x3F);
                    }",21,,230,2,,void
179785,BLOCK,-1,,<empty>,21,,235,1,,void
179790,BLOCK,-1,,"{
                        *p_pos++ = 0xE0 |  (cp >> 12);
                        *p_pos++ = 0x80 | ((cp >>  6) & 0x3F);
                        *p_pos   = 0x80 |  (cp        & 0x3F);
                    }",21,,236,2,,void
179820,BLOCK,-1,,<empty>,21,,242,1,,void
179825,BLOCK,-1,,"{   /* Unicode stops at 10FFFF, but who cares? */
                        *p_pos++ = 0xF0 |  (cp >> 18);
                        *p_pos++ = 0x80 | ((cp >> 12) & 0x3F);
                        *p_pos++ = 0x80 | ((cp >>  6) & 0x3F);
                        *p_pos   = 0x80 |  (cp        & 0x3F);
                    }",21,,243,2,,void
179866,BLOCK,-1,,"{
                    /* Invalid entity number */
                    *p_pos = *psz_value;
                    psz_value++;
                }",17,,251,1,,void
179875,BLOCK,-1,,"{   /* Well-known XML entity */
                const struct xml_entity_s *ent;

                ent = bsearch (psz_value + 1, xml_entities,
                               ARRAY_SIZE (xml_entities),
                               sizeof (*ent), cmp_entity);
                if (ent != NULL)
                {
                    size_t olen = strlen (ent->psz_char);
                    memcpy (p_pos, ent->psz_char, olen);
                    p_pos += olen - 1;
                    psz_value += strlen (ent->psz_entity) + 1;
                }
                else
                {   /* No match */
                    *p_pos = *psz_value;
                    psz_value++;
                }
            }",13,,258,1,,void
179894,BLOCK,-1,,"{
                    size_t olen = strlen (ent->psz_char);
                    memcpy (p_pos, ent->psz_char, olen);
                    p_pos += olen - 1;
                    psz_value += strlen (ent->psz_entity) + 1;
                }",17,,265,2,,void
179922,BLOCK,-1,,"{   /* No match */
                    *p_pos = *psz_value;
                    psz_value++;
                }",17,,272,1,,void
179931,BLOCK,-1,,"{
            *p_pos = *psz_value;
            psz_value++;
        }",9,,279,1,,void
179949,BLOCK,-1,,"{
    struct vlc_memstream stream;
    size_t n;
    uint32_t cp;

    assert(str != NULL);
    vlc_memstream_open(&stream);

    while ((n = vlc_towc (str, &cp)) != 0)
    {
        if (unlikely(n == (size_t)-1))
        {
            if (vlc_memstream_close(&stream) == 0)
                free(stream.ptr);
            errno = EILSEQ;
            return NULL;
        }

        switch (cp)
        {
            case '\""':
                vlc_memstream_puts(&stream, ""&quot;"");
                break;
            case '&':
                vlc_memstream_puts(&stream, ""&amp;"");
                break;
            case '\'':
                vlc_memstream_puts(&stream, ""&#39;"");
                break;
            case '<':
                vlc_memstream_puts(&stream, ""&lt;"");
                break;
            case '>':
                vlc_memstream_puts(&stream, ""&gt;"");
                break;
            default:
                if (cp < 32) /* C0 code not allowed (except 9, 10 and 13) */
...",1,,291,2,,void
179969,BLOCK,-1,,"{
        if (unlikely(n == (size_t)-1))
        {
            if (vlc_memstream_close(&stream) == 0)
                free(stream.ptr);
            errno = EILSEQ;
            return NULL;
        }

        switch (cp)
        {
            case '\""':
                vlc_memstream_puts(&stream, ""&quot;"");
                break;
            case '&':
                vlc_memstream_puts(&stream, ""&amp;"");
                break;
            case '\'':
                vlc_memstream_puts(&stream, ""&#39;"");
                break;
            case '<':
                vlc_memstream_puts(&stream, ""&lt;"");
                break;
            case '>':
                vlc_memstream_puts(&stream, ""&gt;"");
                break;
            default:
                if (cp < 32) /* C0 code not allowed (except 9, 10 and 13) */
                    break;
                if (cp >= 128 && cp < 160) /* C1 code encoded (except 133) */
                {
                    vlc_memstream_printf(&stream, ...",5,,300,2,,void
179977,BLOCK,-1,,"{
            if (vlc_memstream_close(&stream) == 0)
                free(stream.ptr);
            errno = EILSEQ;
            return NULL;
        }",9,,302,2,,void
179984,BLOCK,-1,,<empty>,17,,304,2,,void
179996,BLOCK,-1,,"{
            case '\""':
                vlc_memstream_puts(&stream, ""&quot;"");
                break;
            case '&':
                vlc_memstream_puts(&stream, ""&amp;"");
                break;
            case '\'':
                vlc_memstream_puts(&stream, ""&#39;"");
                break;
            case '<':
                vlc_memstream_puts(&stream, ""&lt;"");
                break;
            case '>':
                vlc_memstream_puts(&stream, ""&gt;"");
                break;
            default:
                if (cp < 32) /* C0 code not allowed (except 9, 10 and 13) */
                    break;
                if (cp >= 128 && cp < 160) /* C1 code encoded (except 133) */
                {
                    vlc_memstream_printf(&stream, ""&#%""PRIu32"";"", cp);
                    break;
                }
                /* fall through */
            case 9:
            case 10:
            case 13:
            case 133:
                vlc_memstream_write(&stream...",9,,310,2,,void
180037,BLOCK,-1,,<empty>,21,,328,2,,void
180047,BLOCK,-1,,"{
                    vlc_memstream_printf(&stream, ""&#%""PRIu32"";"", cp);
                    break;
                }",17,,330,2,,void
180071,BLOCK,-1,,<empty>,9,,346,2,,void
180083,BLOCK,-1,,"{
    static const char b64[] =
           ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";

    char *ret = malloc( ( i_src + 4 ) * 4 / 3 );
    char *dst = ret;

    if( dst == NULL )
        return NULL;

    while( i_src > 0 )
    {
        /* pops (up to) 3 bytes of input, push 4 bytes */
        uint32_t v;

        /* 1/3 -> 1/4 */
        v = ((unsigned)*src++) << 24;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 2/3 -> 2/4 */
        if( i_src >= 2 )
            v |= *src++ << 22;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 3/3 -> 3/4 */
        if( i_src >= 3 )
            v |= *src++ << 20; // 3/3
        *dst++ = ( i_src >= 2 ) ? b64[v >> 26] : '='; // 3/4
        v = v << 6;

        /* -> 4/4 */
        *dst++ = ( i_src >= 3 ) ? b64[v >> 26] : '='; // 4/4

        if( i_src <= 3 )
            break;
        i_src -= 3;
    }

    *dst = '\0';

    return ret;
}",1,,352,3,,void
180107,BLOCK,-1,,<empty>,9,,360,2,,void
180114,BLOCK,-1,,"{
        /* pops (up to) 3 bytes of input, push 4 bytes */
        uint32_t v;

        /* 1/3 -> 1/4 */
        v = ((unsigned)*src++) << 24;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 2/3 -> 2/4 */
        if( i_src >= 2 )
            v |= *src++ << 22;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 3/3 -> 3/4 */
        if( i_src >= 3 )
            v |= *src++ << 20; // 3/3
        *dst++ = ( i_src >= 2 ) ? b64[v >> 26] : '='; // 3/4
        v = v << 6;

        /* -> 4/4 */
        *dst++ = ( i_src >= 3 ) ? b64[v >> 26] : '='; // 4/4

        if( i_src <= 3 )
            break;
        i_src -= 3;
    }",5,,363,2,,void
180143,BLOCK,-1,,<empty>,13,,374,2,,void
180169,BLOCK,-1,,<empty>,13,,380,2,,void
180214,BLOCK,-1,,<empty>,13,,388,2,,void
180229,BLOCK,-1,,"{
    if( src )
        return vlc_b64_encode_binary( (const uint8_t*)src, strlen(src) );
    else
        return vlc_b64_encode_binary( (const uint8_t*)"""", 0 );
}",1,,398,2,,void
180232,BLOCK,-1,,<empty>,9,,400,2,,void
180241,BLOCK,-1,,<empty>,9,,402,1,,void
180254,BLOCK,-1,,"{
    static const int b64[256] = {
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */
        52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */
        15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */
        -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */
        41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* C0-CF */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-...",1,,407,4,,void
180720,BLOCK,-1,,<empty>,5,,432,1,,void
180741,BLOCK,4,,"{
        const int c = b64[(unsigned int)*p];
        if( c == -1 )
            break;

        switch( i_level )
        {
            case 0:
                i_level++;
                break;
            case 1:
                *p_dst++ = ( i_last << 2 ) | ( ( c >> 4)&0x03 );
                i_level++;
                break;
            case 2:
                *p_dst++ = ( ( i_last << 4 )&0xf0 ) | ( ( c >> 2 )&0x0f );
                i_level++;
                break;
            case 3:
                *p_dst++ = ( ( i_last &0x03 ) << 6 ) | c;
                i_level = 0;
        }
        i_last = c;
    }",5,,433,4,,void
180756,BLOCK,-1,,<empty>,13,,436,2,,void
180760,BLOCK,-1,,"{
            case 0:
                i_level++;
                break;
            case 1:
                *p_dst++ = ( i_last << 2 ) | ( ( c >> 4)&0x03 );
                i_level++;
                break;
            case 2:
                *p_dst++ = ( ( i_last << 4 )&0xf0 ) | ( ( c >> 2 )&0x0f );
                i_level++;
                break;
            case 3:
                *p_dst++ = ( ( i_last &0x03 ) << 6 ) | c;
                i_level = 0;
        }",9,,439,2,,void
180832,BLOCK,-1,,"{
    const int i_src = strlen( psz_src );
    uint8_t   *p_dst;

    *pp_dst = p_dst = malloc( i_src );
    if( !p_dst )
        return 0;
    return  vlc_b64_decode_binary_to_buffer( p_dst, i_src, psz_src );
}",1,,461,3,,void
180849,BLOCK,-1,,<empty>,9,,467,2,,void
180861,BLOCK,-1,,"{
    const int i_src = strlen( psz_src );
    char *p_dst = malloc( i_src + 1 );
    size_t i_dst;
    if( !p_dst )
        return NULL;

    i_dst = vlc_b64_decode_binary_to_buffer( (uint8_t*)p_dst, i_src, psz_src );
    p_dst[i_dst] = '\0';

    return p_dst;
}",1,,471,2,,void
180878,BLOCK,-1,,<empty>,9,,476,2,,void
180900,BLOCK,-1,,"{
    time_t curtime;
    struct tm loctime;

    if (strcmp (tformat, """") == 0)
        return strdup (""""); /* corner case w.r.t. strftime() return value */

    /* Get the current time.  */
    time( &curtime );

    /* Convert it to local time representation.  */
    localtime_r( &curtime, &loctime );
    for (size_t buflen = strlen (tformat) + 32;; buflen += 32)
    {
        char *str = malloc (buflen);
        if (str == NULL)
            return NULL;

        size_t len = strftime (str, buflen, tformat, &loctime);
        if (len > 0)
        {
            char *ret = realloc (str, len + 1);
            return ret ? ret : str; /* <- this cannot fail */
        }
        free (str);
    }
    vlc_assert_unreachable ();
}",1,,485,2,,void
180909,BLOCK,-1,,<empty>,9,,490,2,,void
180922,BLOCK,-1,,<empty>,5,,497,1,,void
180933,BLOCK,4,,"{
        char *str = malloc (buflen);
        if (str == NULL)
            return NULL;

        size_t len = strftime (str, buflen, tformat, &loctime);
        if (len > 0)
        {
            char *ret = realloc (str, len + 1);
            return ret ? ret : str; /* <- this cannot fail */
        }
        free (str);
    }",5,,498,4,,void
180943,BLOCK,-1,,<empty>,13,,501,2,,void
180959,BLOCK,-1,,"{
            char *ret = realloc (str, len + 1);
            return ret ? ret : str; /* <- this cannot fail */
        }",9,,505,2,,void
180981,BLOCK,-1,,"{
    lldiv_t d;
    long long sec;

    duration /= CLOCK_FREQ;
    d = lldiv(duration, 60);
    sec = d.rem;
    d = lldiv(d.quot, 60);
    vlc_memstream_printf(stream, ""%02lld:%02lld:%02lld"", d.quot, d.rem, sec);
}",1,,515,3,,void
181020,BLOCK,-1,,"{
    if (item == NULL)
        return EOF;

    char *value = input_item_GetMeta(item, type);
    if (value == NULL)
        return EOF;

    vlc_memstream_puts(stream, value);
    free(value);
    return 0;
}",1,,528,4,,void
181025,BLOCK,-1,,<empty>,9,,530,2,,void
181038,BLOCK,-1,,<empty>,9,,534,2,,void
181053,BLOCK,-1,,"{
    struct vlc_memstream stream[1];

    input_item_t *item = (input != NULL) ? input_GetItem(input) : NULL;

    char c;
    bool b_is_format = false;
    bool b_empty_if_na = false;

    assert(s != NULL);

    vlc_memstream_open(stream);

    while ((c = *s) != '\0')
    {
        s++;

        if (!b_is_format)
        {
            if (c == '$')
            {
                b_is_format = true;
                b_empty_if_na = false;
                continue;
            }

            vlc_memstream_putc(stream, c);
            continue;
        }

        b_is_format = false;

        switch (c)
        {
            case 'a':
                write_meta(stream, item, vlc_meta_Artist);
                break;
            case 'b':
                write_meta(stream, item, vlc_meta_Album);
                break;
            case 'c':
                write_meta(stream, item, vlc_meta_Copyright);
                break;
            case 'd':
                write_meta(stream, item, ...",1,,542,3,,void
181087,BLOCK,-1,,"{
        s++;

        if (!b_is_format)
        {
            if (c == '$')
            {
                b_is_format = true;
                b_empty_if_na = false;
                continue;
            }

            vlc_memstream_putc(stream, c);
            continue;
        }

        b_is_format = false;

        switch (c)
        {
            case 'a':
                write_meta(stream, item, vlc_meta_Artist);
                break;
            case 'b':
                write_meta(stream, item, vlc_meta_Album);
                break;
            case 'c':
                write_meta(stream, item, vlc_meta_Copyright);
                break;
            case 'd':
                write_meta(stream, item, vlc_meta_Description);
                break;
            case 'e':
                write_meta(stream, item, vlc_meta_EncodedBy);
                break;
            case 'f':
                if (item != NULL)
                {
                    vlc_mutex_lock(&item->lock);
 ...",5,,556,2,,void
181093,BLOCK,-1,,"{
            if (c == '$')
            {
                b_is_format = true;
                b_empty_if_na = false;
                continue;
            }

            vlc_memstream_putc(stream, c);
            continue;
        }",9,,560,2,,void
181098,BLOCK,-1,,"{
                b_is_format = true;
                b_empty_if_na = false;
                continue;
            }",13,,562,2,,void
181115,BLOCK,-1,,"{
            case 'a':
                write_meta(stream, item, vlc_meta_Artist);
                break;
            case 'b':
                write_meta(stream, item, vlc_meta_Album);
                break;
            case 'c':
                write_meta(stream, item, vlc_meta_Copyright);
                break;
            case 'd':
                write_meta(stream, item, vlc_meta_Description);
                break;
            case 'e':
                write_meta(stream, item, vlc_meta_EncodedBy);
                break;
            case 'f':
                if (item != NULL)
                {
                    vlc_mutex_lock(&item->lock);
                    if (item->p_stats != NULL)
                    {
                        vlc_mutex_lock(&item->p_stats->lock);
                        vlc_memstream_printf(stream, ""%""PRIi64,
                            item->p_stats->i_displayed_pictures);
                        vlc_mutex_unlock(&item->p_stats->lock);
                 ...",9,,575,2,,void
181157,BLOCK,-1,,"{
                    vlc_mutex_lock(&item->lock);
                    if (item->p_stats != NULL)
                    {
                        vlc_mutex_lock(&item->p_stats->lock);
                        vlc_memstream_printf(stream, ""%""PRIi64,
                            item->p_stats->i_displayed_pictures);
                        vlc_mutex_unlock(&item->p_stats->lock);
                    }
                    else if (!b_empty_if_na)
                        vlc_memstream_putc(stream, '-');
                    vlc_mutex_unlock(&item->lock);
                }",17,,593,2,,void
181169,BLOCK,-1,,"{
                        vlc_mutex_lock(&item->p_stats->lock);
                        vlc_memstream_printf(stream, ""%""PRIi64,
                            item->p_stats->i_displayed_pictures);
                        vlc_mutex_unlock(&item->p_stats->lock);
                    }",21,,596,2,,void
181186,BLOCK,-1,,<empty>,26,,602,1,,void
181190,BLOCK,-1,,<empty>,25,,603,2,,void
181200,BLOCK,-1,,<empty>,22,,606,1,,void
181204,BLOCK,-1,,<empty>,21,,607,2,,void
181243,BLOCK,-1,,<empty>,21,,623,2,,void
181245,BLOCK,44,,"{
                    char *value = input_item_GetNowPlayingFb(item);
                    if (value == NULL)
                        break;

                    vlc_memstream_puts(stream, value);
                    free(value);
                }",17,,624,44,,void
181255,BLOCK,-1,,<empty>,25,,627,2,,void
181272,BLOCK,52,,"{
                char *lang = NULL;

                if (input != NULL)
                    lang = var_GetNonEmptyString(input, ""sub-language"");
                if (lang != NULL)
                {
                    vlc_memstream_puts(stream, lang);
                    free(lang);
                }
                else if (!b_empty_if_na)
                    vlc_memstream_putc(stream, '-');
                break;
            }",13,,637,52,,void
181281,BLOCK,-1,,<empty>,21,,641,2,,void
181291,BLOCK,-1,,"{
                    vlc_memstream_puts(stream, lang);
                    free(lang);
                }",17,,643,2,,void
181298,BLOCK,-1,,<empty>,22,,647,1,,void
181302,BLOCK,-1,,<empty>,21,,648,2,,void
181344,BLOCK,-1,,<empty>,21,,676,2,,void
181350,BLOCK,-1,,<empty>,22,,677,1,,void
181354,BLOCK,-1,,<empty>,21,,678,2,,void
181365,BLOCK,-1,,"{
                    char *uri = input_item_GetURI(item);
                    if (uri != NULL)
                    {
                        vlc_memstream_puts(stream, uri);
                        free(uri);
                    }
                }",17,,682,2,,void
181375,BLOCK,-1,,"{
                        vlc_memstream_puts(stream, uri);
                        free(uri);
                    }",21,,685,2,,void
181393,BLOCK,-1,,"{
                    assert(input != NULL);
                    write_duration(stream, input_item_GetDuration(item)
                                   - var_GetInteger(input, ""time""));
                }",17,,700,2,,void
181407,BLOCK,-1,,<empty>,22,,705,1,,void
181411,BLOCK,-1,,<empty>,21,,706,2,,void
181422,BLOCK,-1,,"{
                    char *name = input_item_GetName(item);
                    if (name != NULL)
                    {
                        vlc_memstream_puts(stream, name);
                        free(name);
                    }
                }",17,,710,2,,void
181432,BLOCK,-1,,"{
                        vlc_memstream_puts(stream, name);
                        free(name);
                    }",21,,713,2,,void
181441,BLOCK,98,,"{
                char *lang = NULL;

                if (input != NULL)
                    lang = var_GetNonEmptyString(input, ""audio-language"");
                if (lang != NULL)
                {
                    vlc_memstream_puts(stream, lang);
                    free(lang);
                }
                else if (!b_empty_if_na)
                    vlc_memstream_putc(stream, '-');
                break;
            }",13,,720,98,,void
181450,BLOCK,-1,,<empty>,21,,724,2,,void
181460,BLOCK,-1,,"{
                    vlc_memstream_puts(stream, lang);
                    free(lang);
                }",17,,726,2,,void
181467,BLOCK,-1,,<empty>,22,,730,1,,void
181471,BLOCK,-1,,<empty>,21,,731,2,,void
181482,BLOCK,-1,,<empty>,21,,736,2,,void
181492,BLOCK,-1,,<empty>,22,,738,1,,void
181496,BLOCK,-1,,<empty>,21,,739,2,,void
181507,BLOCK,-1,,<empty>,21,,743,2,,void
181515,BLOCK,-1,,<empty>,22,,745,1,,void
181519,BLOCK,-1,,<empty>,21,,746,2,,void
181530,BLOCK,-1,,"{
                    int rate = var_GetInteger(input, ""sample-rate"");
                    div_t dr = div((rate + 50) / 100, 10);

                    vlc_memstream_printf(stream, ""%d.%01d"", dr.quot, dr.rem);
                }",17,,750,2,,void
181557,BLOCK,-1,,<empty>,22,,756,1,,void
181561,BLOCK,-1,,<empty>,21,,757,2,,void
181572,BLOCK,-1,,<empty>,21,,761,2,,void
181579,BLOCK,-1,,<empty>,22,,762,1,,void
181583,BLOCK,-1,,<empty>,21,,763,2,,void
181597,BLOCK,121,,"{
                float vol = 0.f;

                if (input != NULL)
                {
                    audio_output_t *aout = input_GetAout(input);
                    if (aout != NULL)
                    {
                        vol = aout_VolumeGet(aout);
                        vlc_object_release(aout);
                    }
                }
                if (vol >= 0.f)
                    vlc_memstream_printf(stream, ""%ld"", lroundf(vol * 256.f));
                else if (!b_empty_if_na)
                    vlc_memstream_puts(stream, ""---"");
                break;
            }",13,,769,121,,void
181606,BLOCK,-1,,"{
                    audio_output_t *aout = input_GetAout(input);
                    if (aout != NULL)
                    {
                        vol = aout_VolumeGet(aout);
                        vlc_object_release(aout);
                    }
                }",17,,773,2,,void
181616,BLOCK,-1,,"{
                        vol = aout_VolumeGet(aout);
                        vlc_object_release(aout);
                    }",21,,776,2,,void
181627,BLOCK,-1,,<empty>,21,,782,2,,void
181636,BLOCK,-1,,<empty>,22,,783,1,,void
181640,BLOCK,-1,,<empty>,21,,784,2,,void
181657,BLOCK,-1,,<empty>,21,,792,2,,void
181659,BLOCK,129,,"{
                    char *value = input_item_GetNowPlayingFb(item);
                    if (value != NULL)
                    {
                        vlc_memstream_puts(stream, value);
                        free(value);
                    }
                    else
                    {
                        char *title = input_item_GetTitleFbName(item);

                        if (write_meta(stream, item, vlc_meta_Artist) >= 0
                            && title != NULL)
                            vlc_memstream_puts(stream, "" - "");

                        if (title != NULL)
                        {
                            vlc_memstream_puts(stream, title);
                            free(title);
                        }
                    }
                }",17,,793,129,,void
181669,BLOCK,-1,,"{
                        vlc_memstream_puts(stream, value);
                        free(value);
                    }",21,,796,2,,void
181676,BLOCK,-1,,"{
                        char *title = input_item_GetTitleFbName(item);

                        if (write_meta(stream, item, vlc_meta_Artist) >= 0
                            && title != NULL)
                            vlc_memstream_puts(stream, "" - "");

                        if (title != NULL)
                        {
                            vlc_memstream_puts(stream, title);
                            free(title);
                        }
                    }",21,,801,1,,void
181693,BLOCK,-1,,<empty>,29,,806,2,,void
181701,BLOCK,-1,,"{
                            vlc_memstream_puts(stream, title);
                            free(title);
                        }",25,,809,2,,void
181725,BLOCK,-1,,<empty>,9,,827,2,,void
181737,BLOCK,-1,,"{
    size_t i;
    char ca, cb;

    /* Attempt to guess if the sorting algorithm should be alphabetic
     * (i.e. collation) or numeric:
     * - If the first mismatching characters are not both digits,
     *   then collation is the only option.
     * - If one of the first mismatching characters is 0 and the other is also
     *   a digit, the comparands are probably left-padded numerical values.
     *   It does not matter which algorithm is used: the zero will be smaller
     *   than non-zero either way.
     * - Otherwise, the comparands are numerical values, and might not be
     *   aligned (i.e. not same order of magnitude). If so, collation would
     *   fail. So numerical comparison is performed. */
    for (i = 0; (ca = a[i]) == (cb = b[i]); i++)
        if (ca == '\0')
            return 0; /* strings are exactly identical */

    if ((unsigned)(ca - '0') > 9 || (unsigned)(cb - '0') > 9)
        return strcoll(a, b);

    unsigned long long ua = strtoull(a + i, NULL...",1,,832,3,,void
181742,BLOCK,-1,,<empty>,5,,847,1,,void
181763,BLOCK,-1,,<empty>,13,,849,2,,void
181782,BLOCK,-1,,<empty>,9,,852,2,,void
181785,BLOCK,1,,<empty>,,,,1,,void
181811,BLOCK,-1,,<empty>,9,,861,2,,void
181814,BLOCK,1,,<empty>,,,,1,,void
181831,BLOCK,-1,,"{
    unsigned char c;

    /* Special file names, not allowed */
    if( !strcmp( str, ""."" ) || !strcmp( str, "".."" ) )
    {
        while( *str )
            *(str++) = '_';
        return;
    }

    /* On platforms not using UTF-8, VLC cannot access non-Unicode paths.
     * Also, some file systems require Unicode file names.
     * NOTE: This may inserts '?' thus is done replacing '?' with '_'. */
    EnsureUTF8( str );

    /* Avoid leading spaces to please Windows. */
    while( (c = *str) != '\0' )
    {
        if( c != ' ' )
            break;
        *(str++) = '_';
    }

    char *start = str;

    while( (c = *str) != '\0' )
    {
        /* Non-printable characters are not a good idea */
        if( c < 32 )
            *str = '_';
        /* This is the list of characters not allowed by Microsoft.
         * We also black-list them on Unix as they may be confusing, and are
         * not supported by some file system types (notably CIFS). */
        else if( strchr( ...",1,,878,2,,void
181843,BLOCK,-1,,"{
        while( *str )
            *(str++) = '_';
        return;
    }",5,,883,2,,void
181862,BLOCK,-1,,"{
        if( c != ' ' )
            break;
        *(str++) = '_';
    }",5,,896,2,,void
181867,BLOCK,-1,,<empty>,13,,898,2,,void
181885,BLOCK,-1,,"{
        /* Non-printable characters are not a good idea */
        if( c < 32 )
            *str = '_';
        /* This is the list of characters not allowed by Microsoft.
         * We also black-list them on Unix as they may be confusing, and are
         * not supported by some file system types (notably CIFS). */
        else if( strchr( ""/:\\*\""?|<>"", c ) != NULL )
            *str = '_';
        str++;
    }",5,,905,2,,void
181890,BLOCK,-1,,<empty>,13,,908,2,,void
181896,BLOCK,-1,,<empty>,14,,912,1,,void
181903,BLOCK,-1,,<empty>,13,,913,2,,void
181914,BLOCK,-1,,"{
        if( *(--str) != ' ' )
            break;
        *str = '_';
    }",5,,919,2,,void
181921,BLOCK,-1,,<empty>,13,,921,2,,void
181957,BLOCK,-1,,<empty>,1,,1,1,,ANY
181962,BLOCK,-1,,"{
#ifndef _WIN32
    return vfprintf (stream, fmt, ap);
#else
    char *str;
    int res = vasprintf (&str, fmt, ap);
    if (unlikely(res == -1))
        return -1;

#if !VLC_WINSTORE_APP
    /* Writing to the console is a lot of fun on Microsoft Windows.
     * If you use the standard I/O functions, you must use the OEM code page,
     * which is different from the usual ANSI code page. Or maybe not, if the
     * user called ""chcp"". Anyway, we prefer Unicode. */
    int fd = _fileno (stream);
    if (likely(fd != -1) && _isatty (fd))
    {
        wchar_t *wide = ToWide (str);
        if (likely(wide != NULL))
        {
            HANDLE h = (HANDLE)((uintptr_t)_get_osfhandle (fd));
            DWORD out;
            /* XXX: It is not clear whether WriteConsole() wants the number of
             * Unicode characters or the size of the wchar_t array. */
            BOOL ok = WriteConsoleW (h, wide, wcslen (wide), &out, NULL);
            free (wide);
            if (ok)
         ...",1,,53,4,,void
181973,BLOCK,-1,,"{
    va_list ap;
    int res;

    va_start( ap, fmt );
    res = utf8_vfprintf( stream, fmt, ap );
    va_end( ap );
    return res;
}",1,,103,3,,void
181994,BLOCK,-1,,"{
    uint8_t *ptr = (uint8_t *)str, c;
    uint32_t cp;

    assert (str != NULL);

    c = *ptr;
    if (unlikely(c > 0xF4))
        return -1;

    int charlen = clz8 (c ^ 0xFF);
    switch (charlen)
    {
        case 0: // 7-bit ASCII character -> short cut
            *pwc = c;
            return c != '\0';

        case 1: // continuation byte -> error
            return -1;

        case 2:
            if (unlikely(c < 0xC2)) // ASCII overlong
                return -1;
            cp = (c & 0x1F) << 6;
            break;

        case 3:
            cp = (c & 0x0F) << 12;
            break;

        case 4:
            cp = (c & 0x07) << 18;
            break;

        default:
            vlc_assert_unreachable ();
    }

    /* Unrolled continuation bytes decoding */
    switch (charlen)
    {
        case 4:
            c = *++ptr;
            if (unlikely((c & 0xC0) != 0x80)) // not a continuation byte
                return -1;
            cp |= (c & 0x3F) << 12;

    ...",1,,114,3,,void
182016,BLOCK,-1,,<empty>,9,,122,2,,void
182029,BLOCK,-1,,"{
        case 0: // 7-bit ASCII character -> short cut
            *pwc = c;
            return c != '\0';

        case 1: // continuation byte -> error
            return -1;

        case 2:
            if (unlikely(c < 0xC2)) // ASCII overlong
                return -1;
            cp = (c & 0x1F) << 6;
            break;

        case 3:
            cp = (c & 0x0F) << 12;
            break;

        case 4:
            cp = (c & 0x07) << 18;
            break;

        default:
            vlc_assert_unreachable ();
    }",5,,126,2,,void
182052,BLOCK,-1,,<empty>,17,,136,2,,void
182088,BLOCK,-1,,"{
        case 4:
            c = *++ptr;
            if (unlikely((c & 0xC0) != 0x80)) // not a continuation byte
                return -1;
            cp |= (c & 0x3F) << 12;

            if (unlikely(cp >= 0x110000)) // beyond Unicode range
                return -1;
            /* fall through */
        case 3:
            c = *++ptr;
            if (unlikely((c & 0xC0) != 0x80)) // not a continuation byte
                return -1;
            cp |= (c & 0x3F) << 6;

            if (unlikely(cp >= 0xD800 && cp < 0xE000)) // UTF-16 surrogate
                return -1;
            if (unlikely(cp < (1u << (5 * charlen - 4)))) // non-ASCII overlong
                return -1;
            /* fall through */
        case 2:
            c = *++ptr;
            if (unlikely((c & 0xC0) != 0x80)) // not a continuation byte
                return -1;
            cp |= (c & 0x3F);
            break;
    }",5,,154,2,,void
182103,BLOCK,-1,,<empty>,17,,158,2,,void
182119,BLOCK,-1,,<empty>,17,,162,2,,void
182137,BLOCK,-1,,<empty>,17,,167,2,,void
182157,BLOCK,-1,,<empty>,17,,171,2,,void
182172,BLOCK,-1,,<empty>,17,,173,2,,void
182190,BLOCK,-1,,<empty>,17,,178,2,,void
182211,BLOCK,-1,,"{
    ssize_t s;

    do
    {
        const char *h = haystack, *n = needle;

        for (;;)
        {
            uint32_t cph, cpn;

            s = vlc_towc (n, &cpn);
            if (s == 0)
                return (char *)haystack;
            if (unlikely(s < 0))
                return NULL;
            n += s;

            s = vlc_towc (h, &cph);
            if (s <= 0 || towlower (cph) != towlower (cpn))
                break;
            h += s;
        }

        s = vlc_towc (haystack, &(uint32_t) { 0 });
        haystack += s;
    }
    while (s > 0);

    return NULL;
}",1,,199,3,,void
182214,BLOCK,-1,,"{
        const char *h = haystack, *n = needle;

        for (;;)
        {
            uint32_t cph, cpn;

            s = vlc_towc (n, &cpn);
            if (s == 0)
                return (char *)haystack;
            if (unlikely(s < 0))
                return NULL;
            n += s;

            s = vlc_towc (h, &cph);
            if (s <= 0 || towlower (cph) != towlower (cpn))
                break;
            h += s;
        }

        s = vlc_towc (haystack, &(uint32_t) { 0 });
        haystack += s;
    }",5,,203,1,,void
182224,BLOCK,-1,,<empty>,9,,206,1,,void
182225,BLOCK,4,,"{
            uint32_t cph, cpn;

            s = vlc_towc (n, &cpn);
            if (s == 0)
                return (char *)haystack;
            if (unlikely(s < 0))
                return NULL;
            n += s;

            s = vlc_towc (h, &cph);
            if (s <= 0 || towlower (cph) != towlower (cpn))
                break;
            h += s;
        }",9,,207,4,,void
182238,BLOCK,-1,,<empty>,17,,212,2,,void
182248,BLOCK,-1,,<empty>,17,,214,2,,void
182270,BLOCK,-1,,<empty>,17,,219,2,,void
182298,BLOCK,-1,,"{
    vlc_iconv_t handle = vlc_iconv_open (""UTF-8"", charset);
    if (handle == (vlc_iconv_t)(-1))
        return NULL;

    char *out = NULL;
    for(unsigned mul = 4; mul < 8; mul++ )
    {
        size_t in_size = data_size;
        const char *in = data;
        size_t out_max = mul * data_size;
        char *tmp = out = malloc (1 + out_max);
        if (!out)
            break;

        if (vlc_iconv (handle, &in, &in_size, &tmp, &out_max) != (size_t)(-1)) {
            *tmp = '\0';
            break;
        }
        free(out);
        out = NULL;

        if (errno != E2BIG)
            break;
    }
    vlc_iconv_close(handle);
    return out;
}",1,,238,4,,void
182311,BLOCK,-1,,<empty>,9,,241,2,,void
182319,BLOCK,-1,,<empty>,5,,244,1,,void
182329,BLOCK,4,,"{
        size_t in_size = data_size;
        const char *in = data;
        size_t out_max = mul * data_size;
        char *tmp = out = malloc (1 + out_max);
        if (!out)
            break;

        if (vlc_iconv (handle, &in, &in_size, &tmp, &out_max) != (size_t)(-1)) {
            *tmp = '\0';
            break;
        }
        free(out);
        out = NULL;

        if (errno != E2BIG)
            break;
    }",5,,245,4,,void
182356,BLOCK,-1,,<empty>,13,,251,2,,void
182373,BLOCK,-1,,"{
            *tmp = '\0';
            break;
        }",80,,253,2,,void
182388,BLOCK,-1,,<empty>,13,,261,2,,void
182400,BLOCK,-1,,"{
    vlc_iconv_t hd = vlc_iconv_open (charset, ""UTF-8"");
    if (hd == (vlc_iconv_t)(-1))
        return NULL;

    const size_t inlen = strlen (in);
    void *res;

    for (unsigned mul = 4; mul < 16; mul++)
    {
        size_t outlen = mul * (inlen + 1);
        res = malloc (outlen);
        if (unlikely(res == NULL))
            break;

        const char *inp = in;
        char *outp = res;
        size_t inb = inlen;
        size_t outb = outlen - mul;

        if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
        {
            *outsize = outlen - mul - outb;
            outb += mul;
            inb = 1; /* append nul terminator if possible */
            if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
                break;
            if (errno == EILSEQ) /* cannot translate nul terminator!? */
                break;
        }

        free (res);
        res = NULL;
        if (errno != E2BIG) /* conversion failure */
            break;
    ...",1,,280,4,,void
182413,BLOCK,-1,,<empty>,9,,283,2,,void
182423,BLOCK,-1,,<empty>,5,,288,1,,void
182433,BLOCK,4,,"{
        size_t outlen = mul * (inlen + 1);
        res = malloc (outlen);
        if (unlikely(res == NULL))
            break;

        const char *inp = in;
        char *outp = res;
        size_t inb = inlen;
        size_t outb = outlen - mul;

        if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
        {
            *outsize = outlen - mul - outb;
            outb += mul;
            inb = 1; /* append nul terminator if possible */
            if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
                break;
            if (errno == EILSEQ) /* cannot translate nul terminator!? */
                break;
        }

        free (res);
        res = NULL;
        if (errno != E2BIG) /* conversion failure */
            break;
    }",5,,289,4,,void
182451,BLOCK,-1,,<empty>,13,,293,2,,void
182486,BLOCK,-1,,"{
            *outsize = outlen - mul - outb;
            outb += mul;
            inb = 1; /* append nul terminator if possible */
            if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
                break;
            if (errno == EILSEQ) /* cannot translate nul terminator!? */
                break;
        }",9,,301,2,,void
182516,BLOCK,-1,,<empty>,17,,306,2,,void
182522,BLOCK,-1,,<empty>,17,,308,2,,void
182533,BLOCK,-1,,<empty>,13,,314,2,,void
182579,BLOCK,-1,,<empty>,1,,1,1,,ANY
182582,BLOCK,-1,,"{
    char *buf = strdup (str);
    if (vlc_uri_decode (buf) == NULL)
    {
        free (buf);
        buf = NULL;
    }
    return buf;
}",1,,44,2,,void
182593,BLOCK,-1,,"{
        free (buf);
        buf = NULL;
    }",5,,47,2,,void
182605,BLOCK,-1,,"{
    char *in = str, *out = str;
    if (in == NULL)
        return NULL;

    char c;
    while ((c = *(in++)) != '\0')
    {
        if (c == '%')
        {
            char hex[3];

            if (!(hex[0] = *(in++)) || !(hex[1] = *(in++)))
                return NULL;
            hex[2] = '\0';
            *(out++) = strtoul (hex, NULL, 0x10);
        }
        else
            *(out++) = c;
    }
    *out = '\0';
    return str;
}",1,,55,2,,void
182618,BLOCK,-1,,<empty>,9,,58,2,,void
182630,BLOCK,-1,,"{
        if (c == '%')
        {
            char hex[3];

            if (!(hex[0] = *(in++)) || !(hex[1] = *(in++)))
                return NULL;
            hex[2] = '\0';
            *(out++) = strtoul (hex, NULL, 0x10);
        }
        else
            *(out++) = c;
    }",5,,62,2,,void
182635,BLOCK,-1,,"{
            char hex[3];

            if (!(hex[0] = *(in++)) || !(hex[1] = *(in++)))
                return NULL;
            hex[2] = '\0';
            *(out++) = strtoul (hex, NULL, 0x10);
        }",9,,64,2,,void
182655,BLOCK,-1,,<empty>,17,,68,2,,void
182672,BLOCK,-1,,<empty>,13,,73,1,,void
182688,BLOCK,-1,,"{
    /* These are the _unreserved_ URI characters (RFC3986 §2.3) */
    return ((unsigned char)(c - 'a') < 26)
        || ((unsigned char)(c - 'A') < 26)
        || ((unsigned char)(c - '0') < 10)
        || (strchr (""-._~"", c) != NULL);
}",1,,80,2,,void
182723,BLOCK,-1,,"{
    return strchr(""!$&'()*+,;="", c) != NULL;
}",1,,89,2,,void
182734,BLOCK,-1,,"{   /* Same as isxdigit() but does not depend on locale and unsignedness */
    return ((unsigned char)(c - '0') < 10)
        || ((unsigned char)(c - 'A') < 6)
        || ((unsigned char)(c - 'a') < 6);
}",1,,94,2,,void
182768,BLOCK,-1,,"{
    char *buf = malloc (3 * *lenp + 1);
    if (unlikely(buf == NULL))
        return NULL;

    char *out = buf;
    for (size_t i = 0; i < *lenp; i++)
    {
        unsigned char c = str[i];

        if (isurisafe (c))
            *(out++) = c;
        /* This is URI encoding, not HTTP forms:
         * Space is encoded as '%20', not '+'. */
        else
        {
            *(out++) = '%';
            *(out++) = urihex[c >> 4];
            *(out++) = urihex[c & 0xf];
        }
    }

    *lenp = out - buf;
    out = realloc (buf, *lenp + 1);
    return likely(out != NULL) ? out : buf;
}",1,,103,3,,void
182784,BLOCK,-1,,<empty>,9,,106,2,,void
182792,BLOCK,-1,,<empty>,5,,109,1,,void
182803,BLOCK,4,,"{
        unsigned char c = str[i];

        if (isurisafe (c))
            *(out++) = c;
        /* This is URI encoding, not HTTP forms:
         * Space is encoded as '%20', not '+'. */
        else
        {
            *(out++) = '%';
            *(out++) = urihex[c >> 4];
            *(out++) = urihex[c & 0xf];
        }
    }",5,,110,4,,void
182813,BLOCK,-1,,<empty>,13,,114,2,,void
182820,BLOCK,-1,,"{
            *(out++) = '%';
            *(out++) = urihex[c >> 4];
            *(out++) = urihex[c & 0xf];
        }",9,,118,1,,void
182870,BLOCK,-1,,"{
    size_t len = strlen (str);
    char *ret = encode_URI_bytes (str, &len);
    if (likely(ret != NULL))
        ret[len] = '\0';
    return ret;
}",1,,131,2,,void
182888,BLOCK,-1,,<empty>,9,,135,2,,void
182901,BLOCK,-1,,"{
    if (path == NULL)
    {
        errno = EINVAL;
        return NULL;
    }
    if (scheme == NULL && !strcmp (path, ""-""))
        return strdup (""fd://0""); // standard input
    /* Note: VLC cannot handle URI schemes without double slash after the
     * scheme name (such as mailto: or news:). */

    char *buf;

#ifdef __OS2__
    char p[strlen (path) + 1];

    for (buf = p; *path; buf++, path++)
        *buf = (*path == '/') ? DIR_SEP_CHAR : *path;
    *buf = '\0';

    path = p;
#endif

#if defined (_WIN32) || defined (__OS2__)
    /* Drive letter */
    if (isalpha ((unsigned char)path[0]) && (path[1] == ':'))
    {
        if (asprintf (&buf, ""%s:///%c:"", scheme ? scheme : ""file"",
                      path[0]) == -1)
            buf = NULL;
        path += 2;
# warning Drive letter-relative path not implemented!
        if (path[0] != DIR_SEP_CHAR)
        {
            errno = ENOTSUP;
            return NULL;
        }
    }
    else
    if (!strncmp (path, ""\\\\"", 2)...",1,,140,3,,void
182906,BLOCK,-1,,"{
        errno = EINVAL;
        return NULL;
    }",5,,142,2,,void
182921,BLOCK,-1,,<empty>,9,,147,2,,void
182932,BLOCK,-1,,"{   /* Relative path: prepend the current working directory */
        char *cwd, *ret;

        if ((cwd = vlc_getcwd ()) == NULL)
            return NULL;
        if (asprintf (&buf, ""%s""DIR_SEP""%s"", cwd, path) == -1)
            buf = NULL;

        free (cwd);
        ret = (buf != NULL) ? vlc_path2uri (buf, scheme) : NULL;
        free (buf);
        return ret;
    }",5,,194,2,,void
182941,BLOCK,-1,,<empty>,13,,198,2,,void
182946,BLOCK,-1,,<empty>,13,,200,2,,void
182967,BLOCK,-1,,<empty>,5,,208,1,,void
182980,BLOCK,-1,,<empty>,9,,209,2,,void
182988,BLOCK,-1,,<empty>,9,,211,2,,void
182998,BLOCK,-1,,"{
        size_t len = strcspn (++path, DIR_SEP);
        path += len;

        char *component = encode_URI_bytes (path - len, &len);
        if (unlikely(component == NULL))
        {
            free (buf);
            return NULL;
        }
        component[len] = '\0';

        char *uri;
        int val = asprintf (&uri, ""%s/%s"", buf, component);
        free (component);
        free (buf);
        if (unlikely(val == -1))
            return NULL;
        buf = uri;
    }",5,,216,1,,void
183023,BLOCK,-1,,"{
            free (buf);
            return NULL;
        }",9,,222,2,,void
183053,BLOCK,-1,,<empty>,13,,233,2,,void
183067,BLOCK,-1,,"{
    char *ret = NULL;
    char *end;

    char *path = strstr (url, ""://"");
    if (path == NULL)
        return NULL; /* unsupported scheme or invalid syntax */

    end = memchr (url, '/', path - url);
    size_t schemelen = ((end != NULL) ? end : path) - url;
    path += 3; /* skip ""://"" */

    /* Remove request parameters and/or HTML anchor if present */
    end = path + strcspn (path, ""?#"");
    path = strndup (path, end - path);
    if (unlikely(path == NULL))
        return NULL; /* boom! */

    /* Decode path */
    vlc_uri_decode (path);

    if (schemelen == 4 && !strncasecmp (url, ""file"", 4))
    {
#if !defined (_WIN32) && !defined (__OS2__)
        /* Leading slash => local path */
        if (*path == '/')
            return path;
        /* Local path disguised as a remote one */
        if (!strncasecmp (path, ""localhost/"", 10))
            return memmove (path, path + 9, strlen (path + 9) + 1);
#else
        /* cannot start with a space */
        if (*path == ' ...",1,,242,2,,void
183083,BLOCK,-1,,<empty>,9,,248,2,,void
183127,BLOCK,-1,,<empty>,9,,258,2,,void
183142,BLOCK,-1,,"{
#if !defined (_WIN32) && !defined (__OS2__)
        /* Leading slash => local path */
        if (*path == '/')
            return path;
        /* Local path disguised as a remote one */
        if (!strncasecmp (path, ""localhost/"", 10))
            return memmove (path, path + 9, strlen (path + 9) + 1);
#else
        /* cannot start with a space */
        if (*path == ' ')
            goto out;
        for (char *p = strchr (path, '/'); p; p = strchr (p + 1, '/'))
            *p = '\\';

        /* Leading backslash => local path */
        if (*path == '\\')
            return memmove (path, path + 1, strlen (path + 1) + 1);
        /* Local path disguised as a remote one */
        if (!strncasecmp (path, ""localhost\\"", 10))
            return memmove (path, path + 10, strlen (path + 10) + 1);
        /* UNC path */
        if (*path && asprintf (&ret, ""\\\\%s"", path) == -1)
            ret = NULL;
#endif
        /* non-local path :-( */
    }",5,,264,2,,void
183148,BLOCK,-1,,<empty>,13,,268,2,,void
183157,BLOCK,-1,,<empty>,13,,271,2,,void
183171,BLOCK,-1,,<empty>,5,,292,1,,void
183182,BLOCK,-1,,"{
        int fd = strtol (path, &end, 0);

        if (*end)
            goto out;

#if !defined( _WIN32 ) && !defined( __OS2__ )
        switch (fd)
        {
            case 0:
                ret = strdup (""/dev/stdin"");
                break;
            case 1:
                ret = strdup (""/dev/stdout"");
                break;
            case 2:
                ret = strdup (""/dev/stderr"");
                break;
            default:
                if (asprintf (&ret, ""/dev/fd/%d"", fd) == -1)
                    ret = NULL;
        }
#else
        /* XXX: Does this work on WinCE? */
        if (fd < 2)
            ret = strdup (""CON"");
#endif
    }",5,,293,2,,void
183194,BLOCK,-1,,<empty>,13,,297,2,,void
183198,BLOCK,-1,,"{
            case 0:
                ret = strdup (""/dev/stdin"");
                break;
            case 1:
                ret = strdup (""/dev/stdout"");
                break;
            case 2:
                ret = strdup (""/dev/stderr"");
                break;
            default:
                if (asprintf (&ret, ""/dev/fd/%d"", fd) == -1)
                    ret = NULL;
        }",9,,301,2,,void
183230,BLOCK,-1,,<empty>,21,,313,2,,void
183243,BLOCK,-1,,<empty>,,,,2,,<empty>
183248,BLOCK,-1,,"{
    size_t a = 0, u = 0;

    for (size_t i = 0; iri[i] != '\0'; i++)
    {
        unsigned char c = iri[i];

        if (c < 128)
            a++;
        else
            u++;
    }

    if (unlikely((a + u) > (SIZE_MAX / 4)))
    {
        errno = ENOMEM;
        return NULL;
    }

    char *uri = malloc(a + 3 * u + 1), *p;
    if (unlikely(uri == NULL))
        return NULL;

    for (p = uri; *iri != '\0'; iri++)
    {
        unsigned char c = *iri;

        if (c < 128)
            *(p++) = c;
        else
        {
            *(p++) = '%';
            *(p++) = urihex[c >> 4];
            *(p++) = urihex[c & 0xf];
        }
    }

    *p = '\0';
    return uri;
}",1,,331,2,,void
183258,BLOCK,-1,,<empty>,5,,334,1,,void
183270,BLOCK,4,,"{
        unsigned char c = iri[i];

        if (c < 128)
            a++;
        else
            u++;
    }",5,,335,4,,void
183281,BLOCK,-1,,<empty>,13,,339,2,,void
183285,BLOCK,-1,,<empty>,13,,341,1,,void
183297,BLOCK,-1,,"{
        errno = ENOMEM;
        return NULL;
    }",5,,345,2,,void
183320,BLOCK,-1,,<empty>,9,,352,2,,void
183324,BLOCK,-1,,<empty>,5,,354,1,,void
183334,BLOCK,4,,"{
        unsigned char c = *iri;

        if (c < 128)
            *(p++) = c;
        else
        {
            *(p++) = '%';
            *(p++) = urihex[c >> 4];
            *(p++) = urihex[c & 0xf];
        }
    }",5,,355,4,,void
183344,BLOCK,-1,,<empty>,13,,359,2,,void
183351,BLOCK,-1,,"{
            *(p++) = '%';
            *(p++) = urihex[c >> 4];
            *(p++) = urihex[c & 0xf];
        }",9,,361,1,,void
183386,BLOCK,-1,,"{
    assert(str != NULL);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        int c = str[i];

        if (isurisafe(c) || isurisubdelim(c))
            continue;
        if (strchr(extras, c) != NULL)
            continue;
        if (c == '%' && isurihex(str[i + 1]) && isurihex(str[i + 2]))
        {
            i += 2;
            continue;
        }
        return false;
    }
    return true;
}",1,,373,3,,void
183392,BLOCK,-1,,<empty>,5,,376,1,,void
183404,BLOCK,4,,"{
        int c = str[i];

        if (isurisafe(c) || isurisubdelim(c))
            continue;
        if (strchr(extras, c) != NULL)
            continue;
        if (c == '%' && isurihex(str[i + 1]) && isurihex(str[i + 2]))
        {
            i += 2;
            continue;
        }
        return false;
    }",5,,377,4,,void
183417,BLOCK,-1,,<empty>,13,,381,2,,void
183425,BLOCK,-1,,<empty>,13,,383,2,,void
183445,BLOCK,-1,,"{
            i += 2;
            continue;
        }",9,,385,2,,void
183458,BLOCK,-1,,"{
    return vlc_uri_component_validate(str, "":"");
}",1,,395,2,,void
183467,BLOCK,-1,,"{
    return vlc_uri_component_validate(str, ""/@:[]"");
}",1,,400,2,,void
183477,BLOCK,-1,,"{
    url->psz_protocol = NULL;
    url->psz_username = NULL;
    url->psz_password = NULL;
    url->psz_host = NULL;
    url->i_port = 0;
    url->psz_path = NULL;
    url->psz_option = NULL;
    url->psz_buffer = NULL;
    url->psz_pathbuffer = NULL;

    if (str == NULL)
    {
        errno = EINVAL;
        return -1;
    }

    char *buf = vlc_iri2uri(str);
    if (unlikely(buf == NULL))
        return -1;
    url->psz_buffer = buf;

    char *cur = buf, *next;
    int ret = 0;

    /* URI scheme */
    next = buf;
    while ((*next >= 'A' && *next <= 'Z') || (*next >= 'a' && *next <= 'z')
        || (*next >= '0' && *next <= '9') || memchr (""+-."", *next, 3) != NULL)
        next++;

    if (*next == ':')
    {
        *(next++) = '\0';
        url->psz_protocol = cur;
        cur = next;
    }

    /* Fragment */
    next = strchr(cur, '#');
    if (next != NULL)
    {
#if 0  /* TODO */
       *(next++) = '\0';
       url->psz_fragment = next;
#else
       *next = '\0';
#endif...",1,,405,3,,void
183527,BLOCK,-1,,"{
        errno = EINVAL;
        return -1;
    }",5,,417,2,,void
183544,BLOCK,-1,,<empty>,9,,424,2,,void
183610,BLOCK,-1,,"{
        *(next++) = '\0';
        url->psz_protocol = cur;
        cur = next;
    }",5,,437,2,,void
183633,BLOCK,-1,,"{
#if 0  /* TODO */
       *(next++) = '\0';
       url->psz_fragment = next;
#else
       *next = '\0';
#endif
    }",5,,446,2,,void
183647,BLOCK,-1,,"{
        *(next++) = '\0';
        url->psz_option = next;
    }",5,,458,2,,void
183665,BLOCK,-1,,"{
        cur += 2;

        /* Path */
        next = strchr(cur, '/');
        if (next != NULL)
        {
            *next = '\0'; /* temporary nul, reset to slash later */
            url->psz_path = next;
        }
        /*else
            url->psz_path = ""/"";*/

        /* User name */
        next = strrchr(cur, '@');
        if (next != NULL)
        {
            *(next++) = '\0';
            url->psz_username = cur;
            cur = next;

            /* Password (obsolete) */
            next = strchr(url->psz_username, ':');
            if (next != NULL)
            {
                *(next++) = '\0';
                url->psz_password = next;
                vlc_uri_decode(url->psz_password);
            }
            vlc_uri_decode(url->psz_username);
        }

        /* Host name */
        if (*cur == '[' && (next = strrchr(cur, ']')) != NULL)
        {   /* Try IPv6 numeral within brackets */
            *(next++) = '\0';
            url->psz_host = strdup(cur ...",5,,465,2,,void
183678,BLOCK,-1,,"{
            *next = '\0'; /* temporary nul, reset to slash later */
            url->psz_path = next;
        }",9,,471,2,,void
183697,BLOCK,-1,,"{
            *(next++) = '\0';
            url->psz_username = cur;
            cur = next;

            /* Password (obsolete) */
            next = strchr(url->psz_username, ':');
            if (next != NULL)
            {
                *(next++) = '\0';
                url->psz_password = next;
                vlc_uri_decode(url->psz_password);
            }
            vlc_uri_decode(url->psz_username);
        }",9,,481,2,,void
183722,BLOCK,-1,,"{
                *(next++) = '\0';
                url->psz_password = next;
                vlc_uri_decode(url->psz_password);
            }",13,,489,2,,void
183754,BLOCK,-1,,"{   /* Try IPv6 numeral within brackets */
            *(next++) = '\0';
            url->psz_host = strdup(cur + 1);

            if (*next == ':')
                next++;
            else
                next = NULL;
        }",9,,499,2,,void
183773,BLOCK,-1,,<empty>,17,,504,2,,void
183777,BLOCK,-1,,<empty>,17,,506,1,,void
183782,BLOCK,-1,,"{
            next = strchr(cur, ':');
            if (next != NULL)
                *(next++) = '\0';

            const char *host = vlc_uri_decode(cur);
            url->psz_host = (host != NULL) ? vlc_idna_to_ascii(host) : NULL;
        }",9,,509,1,,void
183792,BLOCK,-1,,<empty>,17,,512,2,,void
183820,BLOCK,-1,,<empty>,13,,519,2,,void
183826,BLOCK,-1,,<empty>,9,,521,1,,void
183833,BLOCK,-1,,"{
            free(url->psz_host);
            url->psz_host = NULL;
            errno = EINVAL;
            ret = -1;
        }",9,,522,2,,void
183857,BLOCK,-1,,"{
            char* end;
            unsigned long port = strtoul(next, &end, 10);

            if (strchr(""0123456789"", *next) == NULL || *end || port > UINT_MAX)
            {
                errno = EINVAL;
                ret = -1;
            }

            url->i_port = port;
        }",9,,531,2,,void
183881,BLOCK,-1,,"{
                errno = EINVAL;
                ret = -1;
            }",13,,536,2,,void
183900,BLOCK,-1,,<empty>,13,,545,2,,void
183908,BLOCK,-1,,"{
        url->psz_path = cur;
    }",5,,548,1,,void
183921,BLOCK,-1,,"{
    int ret = vlc_UrlParseInner(url, str);

    if (url->psz_path != NULL && !vlc_uri_path_validate(url->psz_path))
    {
        url->psz_path = NULL;
        errno = EINVAL;
        ret = -1;
    }
    return ret;
}",1,,556,3,,void
183940,BLOCK,-1,,"{
        url->psz_path = NULL;
        errno = EINVAL;
        ret = -1;
    }",5,,560,2,,void
183960,BLOCK,-1,,<empty>,,,,3,,<empty>
183966,BLOCK,-1,,"{
    int ret = vlc_UrlParseInner(url, str);

    static const char pathextras[] = ""/@:"";

    if (url->psz_path != NULL
     && !vlc_uri_component_validate(url->psz_path, pathextras))
    {
        url->psz_pathbuffer = vlc_uri_fixup_inner(url->psz_path, pathextras);
        if (url->psz_pathbuffer == NULL)
        {
            url->psz_path = NULL;
            errno = ENOMEM;
            ret = -1;
        }
        else
        {
            url->psz_path = url->psz_pathbuffer;
            assert(vlc_uri_path_validate(url->psz_path));
        }
    }
    return ret;
}",1,,571,3,,void
183990,BLOCK,-1,,"{
        url->psz_pathbuffer = vlc_uri_fixup_inner(url->psz_path, pathextras);
        if (url->psz_pathbuffer == NULL)
        {
            url->psz_path = NULL;
            errno = ENOMEM;
            ret = -1;
        }
        else
        {
            url->psz_path = url->psz_pathbuffer;
            assert(vlc_uri_path_validate(url->psz_path));
        }
    }",5,,578,2,,void
184006,BLOCK,-1,,"{
            url->psz_path = NULL;
            errno = ENOMEM;
            ret = -1;
        }",9,,581,2,,void
184020,BLOCK,-1,,"{
            url->psz_path = url->psz_pathbuffer;
            assert(vlc_uri_path_validate(url->psz_path));
        }",9,,587,1,,void
184039,BLOCK,-1,,"{
    free (url->psz_host);
    free (url->psz_buffer);
    free (url->psz_pathbuffer);
}",1,,596,2,,void
184057,BLOCK,-1,,"{
    char *str;
    int len;

    if (base == NULL)
        len = asprintf(&str, ""/%s"", ref);
    else
    {
        const char *end = strrchr(base, '/');

        if (end != NULL)
            end++;
        else
            end = base;

        len = asprintf(&str, ""%.*s%s"", (int)(end - base), base, ref);
    }

    if (unlikely(len == -1))
        str = NULL;
    return str;
}",1,,608,3,,void
184064,BLOCK,-1,,<empty>,9,,613,2,,void
184073,BLOCK,-1,,"{
        const char *end = strrchr(base, '/');

        if (end != NULL)
            end++;
        else
            end = base;

        len = asprintf(&str, ""%.*s%s"", (int)(end - base), base, ref);
    }",5,,615,1,,void
184084,BLOCK,-1,,<empty>,13,,619,2,,void
184088,BLOCK,-1,,<empty>,13,,621,1,,void
184111,BLOCK,-1,,<empty>,9,,627,2,,void
184121,BLOCK,-1,,"{
    char *input = str, *output = str;

    while (input[0] != '\0')
    {
        assert(output <= input);

        if (strncmp(input, ""../"", 3) == 0)
        {
            input += 3;
            continue;
        }
        if (strncmp(input, ""./"", 2) == 0)
        {
            input += 2;
            continue;
        }
        if (strncmp(input, ""/./"", 3) == 0)
        {
            input += 2;
            continue;
        }
        if (strcmp(input, ""/."") == 0)
        {
            input[1] = '\0';
            continue;
        }
        if (strncmp(input, ""/../"", 4) == 0)
        {
            input += 3;
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }
        if (strcmp(input, ""/.."") == 0)
        {
            input[1] = '\0';
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }
...",1,,637,2,,void
184136,BLOCK,-1,,"{
        assert(output <= input);

        if (strncmp(input, ""../"", 3) == 0)
        {
            input += 3;
            continue;
        }
        if (strncmp(input, ""./"", 2) == 0)
        {
            input += 2;
            continue;
        }
        if (strncmp(input, ""/./"", 3) == 0)
        {
            input += 2;
            continue;
        }
        if (strcmp(input, ""/."") == 0)
        {
            input[1] = '\0';
            continue;
        }
        if (strncmp(input, ""/../"", 4) == 0)
        {
            input += 3;
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }
        if (strcmp(input, ""/.."") == 0)
        {
            input[1] = '\0';
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }
        if (strcmp(input, ""."") == 0)
        {
            input++;
      ...",5,,641,2,,void
184148,BLOCK,-1,,"{
            input += 3;
            continue;
        }",9,,645,2,,void
184160,BLOCK,-1,,"{
            input += 2;
            continue;
        }",9,,650,2,,void
184172,BLOCK,-1,,"{
            input += 2;
            continue;
        }",9,,655,2,,void
184183,BLOCK,-1,,"{
            input[1] = '\0';
            continue;
        }",9,,660,2,,void
184197,BLOCK,-1,,"{
            input += 3;
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }",9,,665,2,,void
184213,BLOCK,-1,,<empty>,17,,669,2,,void
184224,BLOCK,-1,,"{
            input[1] = '\0';
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }",9,,673,2,,void
184242,BLOCK,-1,,<empty>,17,,677,2,,void
184253,BLOCK,-1,,"{
            input++;
            continue;
        }",9,,681,2,,void
184263,BLOCK,-1,,"{
            input += 2;
            continue;
        }",9,,686,2,,void
184274,BLOCK,-1,,<empty>,13,,692,2,,void
184292,BLOCK,-1,,<empty>,13,,697,2,,void
184314,BLOCK,-1,,"{
    struct vlc_memstream stream;
    char *enc;

    vlc_memstream_open(&stream);

    if (uri->psz_protocol != NULL)
        vlc_memstream_printf(&stream, ""%s:"", uri->psz_protocol);

    if (uri->psz_host != NULL)
    {
        vlc_memstream_write(&stream, ""//"", 2);

        if (uri->psz_username != NULL)
        {
            enc = vlc_uri_encode(uri->psz_username);
            if (enc == NULL)
                goto error;

            vlc_memstream_puts(&stream, enc);
            free(enc);

            if (uri->psz_password != NULL)
            {
                enc = vlc_uri_encode(uri->psz_password);
                if (unlikely(enc == NULL))
                    goto error;

                vlc_memstream_printf(&stream, "":%s"", enc);
                free(enc);
            }
            vlc_memstream_putc(&stream, '@');
        }

        const char *fmt;

        if (strchr(uri->psz_host, ':') != NULL)
            fmt = (uri->i_port != 0) ? ""[%s]:%d"" : ""[%s]"";
        else
   ...",1,,708,2,,void
184326,BLOCK,-1,,<empty>,9,,715,2,,void
184340,BLOCK,-1,,"{
        vlc_memstream_write(&stream, ""//"", 2);

        if (uri->psz_username != NULL)
        {
            enc = vlc_uri_encode(uri->psz_username);
            if (enc == NULL)
                goto error;

            vlc_memstream_puts(&stream, enc);
            free(enc);

            if (uri->psz_password != NULL)
            {
                enc = vlc_uri_encode(uri->psz_password);
                if (unlikely(enc == NULL))
                    goto error;

                vlc_memstream_printf(&stream, "":%s"", enc);
                free(enc);
            }
            vlc_memstream_putc(&stream, '@');
        }

        const char *fmt;

        if (strchr(uri->psz_host, ':') != NULL)
            fmt = (uri->i_port != 0) ? ""[%s]:%d"" : ""[%s]"";
        else
            fmt = (uri->i_port != 0) ? ""%s:%d"" : ""%s"";
        /* No IDNA decoding here. Seems unnecessary, dangerous even. */
        vlc_memstream_printf(&stream, fmt, uri->psz_host, uri->i_port);
    }",5,,718,2,,void
184352,BLOCK,-1,,"{
            enc = vlc_uri_encode(uri->psz_username);
            if (enc == NULL)
                goto error;

            vlc_memstream_puts(&stream, enc);
            free(enc);

            if (uri->psz_password != NULL)
            {
                enc = vlc_uri_encode(uri->psz_password);
                if (unlikely(enc == NULL))
                    goto error;

                vlc_memstream_printf(&stream, "":%s"", enc);
                free(enc);
            }
            vlc_memstream_putc(&stream, '@');
        }",9,,722,2,,void
184363,BLOCK,-1,,<empty>,17,,725,2,,void
184377,BLOCK,-1,,"{
                enc = vlc_uri_encode(uri->psz_password);
                if (unlikely(enc == NULL))
                    goto error;

                vlc_memstream_printf(&stream, "":%s"", enc);
                free(enc);
            }",13,,731,2,,void
184389,BLOCK,-1,,<empty>,21,,734,2,,void
184411,BLOCK,-1,,<empty>,13,,745,2,,void
184423,BLOCK,-1,,<empty>,13,,747,1,,void
184450,BLOCK,-1,,<empty>,9,,753,2,,void
184463,BLOCK,-1,,<empty>,9,,755,2,,void
184475,BLOCK,-1,,<empty>,9,,759,2,,void
184489,BLOCK,-1,,<empty>,9,,764,2,,void
184501,BLOCK,-1,,"{
    vlc_url_t base_uri, rel_uri;
    vlc_url_t tgt_uri;
    char *pathbuf = NULL, *ret = NULL;

    if (vlc_UrlParse(&rel_uri, ref))
    {
        vlc_UrlClean(&rel_uri);
        return NULL;
    }

    if (rel_uri.psz_protocol != NULL)
    {   /* Short circuit in case of absolute URI */
        vlc_UrlClean(&rel_uri);
        return strdup(ref);
    }

    vlc_UrlParse(&base_uri, base);

    /* RFC3986 section 5.2.2 */
    do
    {
        tgt_uri = rel_uri;
        tgt_uri.psz_protocol = base_uri.psz_protocol;

        if (rel_uri.psz_host != NULL)
            break;

        tgt_uri.psz_username = base_uri.psz_username;
        tgt_uri.psz_password = base_uri.psz_password;
        tgt_uri.psz_host = base_uri.psz_host;
        tgt_uri.i_port = base_uri.i_port;

        if (rel_uri.psz_path == NULL || rel_uri.psz_path[0] == '\0')
        {
            tgt_uri.psz_path = base_uri.psz_path;
            if (rel_uri.psz_option == NULL)
                tgt_uri.psz_option = base_uri.ps...",1,,769,3,,void
184518,BLOCK,-1,,"{
        vlc_UrlClean(&rel_uri);
        return NULL;
    }",5,,775,2,,void
184530,BLOCK,-1,,"{   /* Short circuit in case of absolute URI */
        vlc_UrlClean(&rel_uri);
        return strdup(ref);
    }",5,,781,2,,void
184542,BLOCK,-1,,"{
        tgt_uri = rel_uri;
        tgt_uri.psz_protocol = base_uri.psz_protocol;

        if (rel_uri.psz_host != NULL)
            break;

        tgt_uri.psz_username = base_uri.psz_username;
        tgt_uri.psz_password = base_uri.psz_password;
        tgt_uri.psz_host = base_uri.psz_host;
        tgt_uri.i_port = base_uri.i_port;

        if (rel_uri.psz_path == NULL || rel_uri.psz_path[0] == '\0')
        {
            tgt_uri.psz_path = base_uri.psz_path;
            if (rel_uri.psz_option == NULL)
                tgt_uri.psz_option = base_uri.psz_option;
            break;
        }

        if (rel_uri.psz_path[0] == '/')
            break;

        pathbuf = vlc_uri_merge_paths(base_uri.psz_path, rel_uri.psz_path);
        if (unlikely(pathbuf == NULL))
            goto error;

        tgt_uri.psz_path = pathbuf;
    }",5,,790,1,,void
184559,BLOCK,-1,,<empty>,13,,795,2,,void
184603,BLOCK,-1,,"{
            tgt_uri.psz_path = base_uri.psz_path;
            if (rel_uri.psz_option == NULL)
                tgt_uri.psz_option = base_uri.psz_option;
            break;
        }",9,,803,2,,void
184617,BLOCK,-1,,<empty>,17,,806,2,,void
184634,BLOCK,-1,,<empty>,13,,811,2,,void
184650,BLOCK,-1,,<empty>,13,,815,2,,void
184664,BLOCK,-1,,<empty>,9,,822,2,,void
184690,BLOCK,-1,,"{
    assert(str && extras);

    bool encode_percent = false;
    for (size_t i = 0; str[i] != '\0'; i++)
        if (str[i] == '%' && !(isurihex(str[i+1]) && isurihex(str[i+2])))
        {
            encode_percent = true;
            break;
        }

    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        unsigned char c = str[i];

        if (isurisafe(c) || isurisubdelim(c) || (strchr(extras, c) != NULL)
         || (c == '%' && !encode_percent))
            vlc_memstream_putc(&stream, c);
        else
            vlc_memstream_printf(&stream, ""%%%02hhX"", c);
    }

    if (vlc_memstream_close(&stream))
        return NULL;
    return stream.ptr;
}",1,,833,3,,void
184700,BLOCK,-1,,<empty>,5,,837,1,,void
184733,BLOCK,-1,,"{
            encode_percent = true;
            break;
        }",9,,839,2,,void
184743,BLOCK,-1,,<empty>,5,,848,1,,void
184755,BLOCK,4,,"{
        unsigned char c = str[i];

        if (isurisafe(c) || isurisubdelim(c) || (strchr(extras, c) != NULL)
         || (c == '%' && !encode_percent))
            vlc_memstream_putc(&stream, c);
        else
            vlc_memstream_printf(&stream, ""%%%02hhX"", c);
    }",5,,849,4,,void
184781,BLOCK,-1,,<empty>,13,,854,2,,void
184787,BLOCK,-1,,<empty>,13,,856,1,,void
184797,BLOCK,-1,,<empty>,9,,860,2,,void
184808,BLOCK,-1,,"{
    static const char extras[] = "":/?#[]@"";

    /* Rule number one is do not change a (potentially) valid URI */
    if (vlc_uri_component_validate(str, extras))
        return strdup(str);

    return vlc_uri_fixup_inner(str, extras);
}",1,,865,2,,void
184817,BLOCK,-1,,<empty>,9,,870,2,,void
184829,BLOCK,-1,,"{
#if defined (HAVE_IDN)
    char *adn;

    switch (idna_to_ascii_8z(idn, &adn, IDNA_ALLOW_UNASSIGNED))
    {
        case IDNA_SUCCESS:
            return adn;
        case IDNA_MALLOC_ERROR:
            errno = ENOMEM;
            return NULL;
        case IDNA_DLOPEN_ERROR:
            errno = ENOSYS;
            return NULL;
        default:
            errno = EINVAL;
            return NULL;
    }

#elif defined (_WIN32)
    char *ret = NULL;

    if (idn[0] == '\0')
        return strdup("""");

    wchar_t *wide = ToWide (idn);
    if (wide == NULL)
        return NULL;

    int len = IdnToAscii (IDN_ALLOW_UNASSIGNED, wide, -1, NULL, 0);
    if (len == 0)
    {
        errno = EINVAL;
        goto error;
    }

    wchar_t *buf = vlc_alloc (len, sizeof (*buf));
    if (unlikely(buf == NULL))
        goto error;
    if (!IdnToAscii (IDN_ALLOW_UNASSIGNED, wide, -1, buf, len))
    {
        free (buf);
        errno = EINVAL;
        goto error;
    }
    ret = FromWide (buf);
 ...",1,,912,2,,void
184831,BLOCK,-1,,<empty>,5,,965,1,,void
184847,BLOCK,-1,,"{
            errno = ENOSYS;
            return NULL;
        }",9,,967,2,,void
184866,BLOCK,-1,,<empty>,1,,1,1,,ANY
184869,BLOCK,-1,,"DECLARE_VLC_VERSION( CompileBy, COMPILE_BY )",1,,43,2,,void
184876,BLOCK,-1,,"DECLARE_VLC_VERSION( CompileHost, COMPILE_HOST )",1,,44,2,,void
184883,BLOCK,-1,,"DECLARE_VLC_VERSION( Compiler, COMPILER )",1,,45,2,,void
184894,BLOCK,-1,,<empty>,1,,1,1,,ANY
184907,BLOCK,-1,,"{
    chrono->shift       = shift;
    chrono->avg_initial =
    chrono->avg         = avg_initial;

    chrono->shift_var   = shift+1;
    chrono->var         = avg_initial / 2;

    chrono->start = VLC_TS_INVALID;
}",1,,41,4,,void
184945,BLOCK,-1,,"{
    VLC_UNUSED(chrono);
}",1,,52,2,,void
184952,BLOCK,-1,,"{
    chrono->start = mdate();
}",1,,56,2,,void
184962,BLOCK,-1,,"{
    return chrono->avg + 2 * chrono->var;
}",1,,60,2,,void
184977,BLOCK,-1,,"{
    return __MAX(chrono->avg - 2 * chrono->var, 0);
}",1,,64,2,,void
184994,BLOCK,-1,,"{
    assert(chrono->start != VLC_TS_INVALID);

    /* */
    const mtime_t duration = mdate() - chrono->start;
    const mtime_t var = llabs( duration - chrono->avg );

    /* Update average only if the current point is 'valid' */
    if( duration < vout_chrono_GetHigh( chrono ) )
        chrono->avg = (((1 << chrono->shift) - 1) * chrono->avg + duration) >> chrono->shift;
    /* Always update the variance */
    chrono->var = (((1 << chrono->shift_var) - 1) * chrono->var + var) >> chrono->shift_var;

    /* For assert */
    chrono->start = VLC_TS_INVALID;
}",1,,69,2,,void
185023,BLOCK,-1,,<empty>,9,,78,2,,void
185075,BLOCK,-1,,"{
    vout_chrono_t ch = *chrono;
    vout_chrono_Clean(chrono);
    vout_chrono_Init(chrono, ch.shift, ch.avg_initial);
}",1,,86,2,,void
185105,BLOCK,-1,,<empty>,1,,1,1,,ANY
185109,BLOCK,-1,,"{
    memset(cmd, 0, sizeof(*cmd));
    cmd->type = type;
}",1,,34,3,,void
185125,BLOCK,-1,,"{
    switch (cmd->type) {
    case VOUT_CONTROL_SUBPICTURE:
        if (cmd->u.subpicture)
            subpicture_Delete(cmd->u.subpicture);
        break;
    case VOUT_CONTROL_OSD_TITLE:
    case VOUT_CONTROL_CHANGE_FILTERS:
    case VOUT_CONTROL_CHANGE_SUB_SOURCES:
    case VOUT_CONTROL_CHANGE_SUB_FILTERS:
        free(cmd->u.string);
        break;
    default:
        break;
    }
}",1,,40,2,,void
185130,BLOCK,-1,,"{
    case VOUT_CONTROL_SUBPICTURE:
        if (cmd->u.subpicture)
            subpicture_Delete(cmd->u.subpicture);
        break;
    case VOUT_CONTROL_OSD_TITLE:
    case VOUT_CONTROL_CHANGE_FILTERS:
    case VOUT_CONTROL_CHANGE_SUB_SOURCES:
    case VOUT_CONTROL_CHANGE_SUB_FILTERS:
        free(cmd->u.string);
        break;
    default:
        break;
    }",24,,41,2,,void
185139,BLOCK,-1,,<empty>,13,,44,2,,void
185168,BLOCK,-1,,"{
    vlc_mutex_init(&ctrl->lock);
    vlc_cond_init(&ctrl->wait_request);
    vlc_cond_init(&ctrl->wait_acknowledge);

    ctrl->is_dead = false;
    ctrl->can_sleep = true;
    ctrl->is_processing = false;
    ARRAY_INIT(ctrl->cmd);
}",1,,59,2,,void
185207,BLOCK,-1,,"{
    /* */
    for (int i = 0; i < ctrl->cmd.i_size; i++) {
        vout_control_cmd_t cmd = ARRAY_VAL(ctrl->cmd, i);
        vout_control_cmd_Clean(&cmd);
    }
    ARRAY_RESET(ctrl->cmd);

    vlc_mutex_destroy(&ctrl->lock);
    vlc_cond_destroy(&ctrl->wait_request);
    vlc_cond_destroy(&ctrl->wait_acknowledge);
}",1,,71,2,,void
185209,BLOCK,-1,,<empty>,5,,73,1,,void
185223,BLOCK,4,,"{
        vout_control_cmd_t cmd = ARRAY_VAL(ctrl->cmd, i);
        vout_control_cmd_Clean(&cmd);
    }",48,,73,4,,void
185258,BLOCK,-1,,"{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->is_dead = true;
    vlc_cond_broadcast(&ctrl->wait_acknowledge);
    vlc_mutex_unlock(&ctrl->lock);

}",1,,85,2,,void
185283,BLOCK,-1,,"{
    vlc_mutex_lock(&ctrl->lock);
    while ((ctrl->cmd.i_size > 0 || ctrl->is_processing) && !ctrl->is_dead)
        vlc_cond_wait(&ctrl->wait_acknowledge, &ctrl->lock);
    vlc_mutex_unlock(&ctrl->lock);
}",1,,94,2,,void
185325,BLOCK,-1,,"{
    vlc_mutex_lock(&ctrl->lock);
    if (!ctrl->is_dead) {
        ARRAY_APPEND(ctrl->cmd, *cmd);
        vlc_cond_signal(&ctrl->wait_request);
    } else {
        vout_control_cmd_Clean(cmd);
    }
    vlc_mutex_unlock(&ctrl->lock);
}",1,,102,3,,void
185336,BLOCK,-1,,"{
        ARRAY_APPEND(ctrl->cmd, *cmd);
        vlc_cond_signal(&ctrl->wait_request);
    }",25,,104,2,,void
185349,BLOCK,-1,,"{
        vout_control_cmd_Clean(cmd);
    }",12,,107,1,,void
185361,BLOCK,-1,,"{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->can_sleep = false;
    vlc_cond_signal(&ctrl->wait_request);
    vlc_mutex_unlock(&ctrl->lock);
}",1,,114,2,,void
185387,BLOCK,-1,,"{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    vout_control_Push(ctrl, &cmd);
}",1,,122,3,,void
185403,BLOCK,-1,,"{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.boolean = boolean;
    vout_control_Push(ctrl, &cmd);
}",1,,129,4,,void
185426,BLOCK,-1,,"{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.integer = integer;
    vout_control_Push(ctrl, &cmd);
}",1,,137,4,,void
185449,BLOCK,-1,,"{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.time = time;
    vout_control_Push(ctrl, &cmd);
}",1,,145,4,,void
185473,BLOCK,-1,,"{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.message.channel = channel;
    cmd.u.message.string = strdup(string);
    vout_control_Push(ctrl, &cmd);
}",1,,153,5,,void
185509,BLOCK,-1,,"{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.pair.a = a;
    cmd.u.pair.b = b;
    vout_control_Push(ctrl, &cmd);
}",1,,162,5,,void
185543,BLOCK,-1,,"{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.string = string ? strdup(string) : NULL;
    vout_control_Push(ctrl, &cmd);
}",1,,171,4,,void
185570,BLOCK,-1,,"{
    vlc_mutex_lock(&ctrl->lock);
    if (ctrl->cmd.i_size <= 0) {
        ctrl->is_processing = false;
        vlc_cond_broadcast(&ctrl->wait_acknowledge);

        /* Spurious wakeups are perfectly fine */
        if (deadline > VLC_TS_INVALID && ctrl->can_sleep)
            vlc_cond_timedwait(&ctrl->wait_request, &ctrl->lock, deadline);
    }

    bool has_cmd;
    if (ctrl->cmd.i_size > 0) {
        has_cmd = true;
        *cmd = ARRAY_VAL(ctrl->cmd, 0);
        ARRAY_REMOVE(ctrl->cmd, 0);

        ctrl->is_processing = true;
    } else {
        has_cmd = false;
        ctrl->can_sleep = true;
    }
    vlc_mutex_unlock(&ctrl->lock);

    return has_cmd ? VLC_SUCCESS : VLC_EGENERIC;
}",1,,181,4,,void
185584,BLOCK,-1,,"{
        ctrl->is_processing = false;
        vlc_cond_broadcast(&ctrl->wait_acknowledge);

        /* Spurious wakeups are perfectly fine */
        if (deadline > VLC_TS_INVALID && ctrl->can_sleep)
            vlc_cond_timedwait(&ctrl->wait_request, &ctrl->lock, deadline);
    }",32,,183,2,,void
185603,BLOCK,-1,,<empty>,13,,189,2,,void
185623,BLOCK,-1,,"{
        has_cmd = true;
        *cmd = ARRAY_VAL(ctrl->cmd, 0);
        ARRAY_REMOVE(ctrl->cmd, 0);

        ctrl->is_processing = true;
    }",31,,193,2,,void
185646,BLOCK,-1,,"{
        has_cmd = false;
        ctrl->can_sleep = true;
    }",12,,199,1,,void
185675,BLOCK,-1,,<empty>,1,,1,1,,ANY
185743,BLOCK,-1,,<empty>,,,,3,,<empty>
185748,BLOCK,-1,,<empty>,,,,2,,<empty>
185762,BLOCK,-1,,<empty>,,,,2,,<empty>
185767,BLOCK,-1,,<empty>,,,,2,,<empty>
185772,BLOCK,-1,,<empty>,,,,2,,<empty>
185778,BLOCK,-1,,<empty>,,,,3,,<empty>
185784,BLOCK,-1,,<empty>,,,,3,,<empty>
185791,BLOCK,-1,,<empty>,,,,4,,<empty>
185798,BLOCK,-1,,<empty>,,,,4,,<empty>
185805,BLOCK,-1,,<empty>,,,,4,,<empty>
185813,BLOCK,-1,,<empty>,,,,5,,<empty>
185821,BLOCK,-1,,<empty>,,,,5,,<empty>
185828,BLOCK,-1,,<empty>,,,,4,,<empty>
185833,BLOCK,-1,,<empty>,,,,2,,<empty>
185840,BLOCK,-1,,<empty>,,,,4,,<empty>
185845,BLOCK,-1,,<empty>,,,,2,,<empty>
185882,BLOCK,-1,,<empty>,1,,1,1,,ANY
185885,BLOCK,-1,,<empty>,,,,2,,<empty>
185890,BLOCK,-1,,"{
    vout_display_t *vd = filter->owner.sys;
    const video_format_t *fmt = &filter->fmt_out.video;

    assert(vd->fmt.i_chroma == fmt->i_chroma &&
           vd->fmt.i_width  == fmt->i_width  &&
           vd->fmt.i_height == fmt->i_height);

    picture_pool_t *pool = vout_display_Pool(vd, 3);
    if (!pool)
        return NULL;
    return picture_pool_Get(pool);
}",1,,54,2,,void
185947,BLOCK,-1,,<empty>,9,,64,2,,void
185962,BLOCK,-1,,"{
    /* */
    vout_display_t *vd = vlc_custom_create(obj, sizeof(*vd), ""vout display"" );

    /* */
    video_format_Copy(&vd->source, fmt);

    /* Picture buffer does not have the concept of aspect ratio */
    video_format_Copy(&vd->fmt, fmt);
    vd->fmt.i_sar_num = 0;
    vd->fmt.i_sar_den = 0;

    vd->info.is_slow = false;
    vd->info.has_double_click = false;
    vd->info.needs_hide_mouse = false;
    vd->info.has_pictures_invalid = false;
    vd->info.subpicture_chromas = NULL;

    vd->cfg = cfg;
    vd->pool = NULL;
    vd->prepare = NULL;
    vd->display = NULL;
    vd->control = NULL;
    vd->manage = NULL;
    vd->sys = NULL;

    vd->owner = *owner;

    if (load_module) {
        vd->module = module_need(vd, ""vout display"", module, module && *module != '\0');
        if (!vd->module) {
            vlc_object_release(vd);
            return NULL;
        }
    } else {
        vd->module = NULL;
    }
    return vd;
}",1,,80,7,,void
186076,BLOCK,-1,,"{
        vd->module = module_need(vd, ""vout display"", module, module && *module != '\0');
        if (!vd->module) {
            vlc_object_release(vd);
            return NULL;
        }
    }",22,,108,2,,void
186096,BLOCK,-1,,"{
            vlc_object_release(vd);
            return NULL;
        }",26,,110,2,,void
186102,BLOCK,-1,,"{
        vd->module = NULL;
    }",12,,114,1,,void
186114,BLOCK,-1,,"{
    if (vd->module)
        module_unneed(vd, vd->module);

    video_format_Clean(&vd->source);
    video_format_Clean(&vd->fmt);

    vlc_object_release(vd);
}",1,,124,2,,void
186119,BLOCK,-1,,<empty>,9,,126,2,,void
186142,BLOCK,-1,,"{
    va_list args;
    int result;

    va_start(args, query);
    result = vd->control(vd, query, args);
    va_end(args);

    return result;
}",1,,138,3,,void
186165,BLOCK,-1,,"{
    if (vd->manage)
        vd->manage(vd);
}",1,,150,2,,void
186170,BLOCK,-1,,<empty>,9,,152,2,,void
186183,BLOCK,-1,,"{
    if (cfg->display.width != 0 && cfg->display.height != 0) {
        *width  = cfg->display.width;
        *height = cfg->display.height;
    } else if (cfg->display.width != 0) {
        *width  = cfg->display.width;
        *height = (int64_t)source->i_visible_height * source->i_sar_den * cfg->display.width * cfg->display.sar.num /
            source->i_visible_width / source->i_sar_num / cfg->display.sar.den;
    } else if (cfg->display.height != 0) {
        *width  = (int64_t)source->i_visible_width * source->i_sar_num * cfg->display.height * cfg->display.sar.den /
            source->i_visible_height / source->i_sar_den / cfg->display.sar.num;
        *height = cfg->display.height;
    } else if (source->i_sar_num >= source->i_sar_den) {
        *width  = (int64_t)source->i_visible_width * source->i_sar_num * cfg->display.sar.den / source->i_sar_den / cfg->display.sar.num;
        *height = source->i_visible_height;
    } else {
        *width  = source->i_visible_width;
 ...",1,,159,5,,void
186200,BLOCK,-1,,"{
        *width  = cfg->display.width;
        *height = cfg->display.height;
    }",62,,160,2,,void
186218,BLOCK,-1,,<empty>,12,,163,1,,void
186227,BLOCK,-1,,"{
        *width  = cfg->display.width;
        *height = (int64_t)source->i_visible_height * source->i_sar_den * cfg->display.width * cfg->display.sar.num /
            source->i_visible_width / source->i_sar_num / cfg->display.sar.den;
    }",41,,163,2,,void
186279,BLOCK,-1,,<empty>,12,,167,1,,void
186288,BLOCK,-1,,"{
        *width  = (int64_t)source->i_visible_width * source->i_sar_num * cfg->display.height * cfg->display.sar.den /
            source->i_visible_height / source->i_sar_den / cfg->display.sar.num;
        *height = cfg->display.height;
    }",42,,167,2,,void
186340,BLOCK,-1,,<empty>,12,,171,1,,void
186349,BLOCK,-1,,"{
        *width  = (int64_t)source->i_visible_width * source->i_sar_num * cfg->display.sar.den / source->i_sar_den / cfg->display.sar.num;
        *height = source->i_visible_height;
    }",56,,171,2,,void
186389,BLOCK,-1,,"{
        *width  = source->i_visible_width;
        *height = (int64_t)source->i_visible_height * source->i_sar_den * cfg->display.sar.num / source->i_sar_num / cfg->display.sar.den;
    }",12,,174,1,,void
186467,BLOCK,-1,,"{

        unsigned store = *width;
        *width = *height;
        *height = store;
    }",46,,182,2,,void
186489,BLOCK,-1,,"{
    /* */
    memset(place, 0, sizeof(*place));
    if (cfg->display.width == 0 || cfg->display.height == 0)
        return;

    /* */
    unsigned display_width;
    unsigned display_height;

    video_format_t source_rot;
    video_format_ApplyRotation(&source_rot, source);
    source = &source_rot;

    if (cfg->is_display_filled) {
        display_width  = cfg->display.width;
        display_height = cfg->display.height;
    } else {
        vout_display_cfg_t cfg_tmp = *cfg;

        cfg_tmp.display.width  = 0;
        cfg_tmp.display.height = 0;
        vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                           source, &cfg_tmp);

        if (do_clipping) {
            display_width  = __MIN(display_width,  cfg->display.width);
            display_height = __MIN(display_height, cfg->display.height);
        }
    }

    const unsigned width  = source->i_visible_width;
    const unsigned height = source->i_visible_height;
 ...",1,,195,5,,void
186512,BLOCK,-1,,<empty>,9,,199,2,,void
186529,BLOCK,-1,,"{
        display_width  = cfg->display.width;
        display_height = cfg->display.height;
    }",33,,209,2,,void
186545,BLOCK,-1,,"{
        vout_display_cfg_t cfg_tmp = *cfg;

        cfg_tmp.display.width  = 0;
        cfg_tmp.display.height = 0;
        vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                           source, &cfg_tmp);

        if (do_clipping) {
            display_width  = __MIN(display_width,  cfg->display.width);
            display_height = __MIN(display_height, cfg->display.height);
        }
    }",12,,212,1,,void
186575,BLOCK,-1,,"{
            display_width  = __MIN(display_width,  cfg->display.width);
            display_height = __MIN(display_height, cfg->display.height);
        }",26,,220,2,,void
186680,BLOCK,-1,,"{
        /* We keep the solution that avoid filling outside the display */
        if (scaled_width <= cfg->display.width) {
            place->width  = scaled_width;
            place->height = display_height;
        } else {
            place->width  = display_width;
            place->height = scaled_height;
        }
    }",65,,233,2,,void
186689,BLOCK,-1,,"{
            place->width  = scaled_width;
            place->height = display_height;
        }",49,,235,2,,void
186701,BLOCK,-1,,"{
            place->width  = display_width;
            place->height = scaled_height;
        }",16,,238,1,,void
186713,BLOCK,-1,,"{
        /* No need to preserve an aspect ratio for 360 video.
         * They can fill the display. */
        place->width  = display_width;
        place->height = display_height;
    }",12,,242,1,,void
186730,BLOCK,-1,,"{
    case VOUT_DISPLAY_ALIGN_LEFT:
        place->x = 0;
        break;
    case VOUT_DISPLAY_ALIGN_RIGHT:
        place->x = cfg->display.width - place->width;
        break;
    default:
        place->x = ((int)cfg->display.width - (int)place->width) / 2;
        break;
    }",36,,250,2,,void
186782,BLOCK,-1,,"{
    case VOUT_DISPLAY_ALIGN_TOP:
        place->y = 0;
        break;
    case VOUT_DISPLAY_ALIGN_BOTTOM:
        place->y = cfg->display.height - place->height;
        break;
    default:
        place->y = ((int)cfg->display.height - (int)place->height) / 2;
        break;
    }",34,,262,2,,void
186836,BLOCK,-1,,"{
    video_format_t source_rot = vd->source;
    video_format_TransformTo(&source_rot, orient_display);

    if (place->width > 0 && place->height > 0) {

        int x = (int)(source_rot.i_x_offset +
                            (int64_t)(m_x - place->x) * source_rot.i_visible_width / place->width);
        int y = (int)(source_rot.i_y_offset +
                            (int64_t)(m_y - place->y) * source_rot.i_visible_height/ place->height);

        video_transform_t transform = video_format_GetTransform(vd->source.orientation, orient_display);

        int store;

        switch (transform) {

            case TRANSFORM_R90:
                store = x;
                x = y;
                y = vd->source.i_visible_height - store;
                break;
            case TRANSFORM_R180:
                x = vd->source.i_visible_width - x;
                y = vd->source.i_visible_height - y;
                break;
            case TRANSFORM_R270:
                store = x;
        ...",1,,276,6,,void
186859,BLOCK,-1,,"{

        int x = (int)(source_rot.i_x_offset +
                            (int64_t)(m_x - place->x) * source_rot.i_visible_width / place->width);
        int y = (int)(source_rot.i_y_offset +
                            (int64_t)(m_y - place->y) * source_rot.i_visible_height/ place->height);

        video_transform_t transform = video_format_GetTransform(vd->source.orientation, orient_display);

        int store;

        switch (transform) {

            case TRANSFORM_R90:
                store = x;
                x = y;
                y = vd->source.i_visible_height - store;
                break;
            case TRANSFORM_R180:
                x = vd->source.i_visible_width - x;
                y = vd->source.i_visible_height - y;
                break;
            case TRANSFORM_R270:
                store = x;
                x = vd->source.i_visible_width - y;
                y = store;
                break;
            case TRANSFORM_HFLIP:
                x = vd->s...",48,,280,2,,void
186919,BLOCK,-1,,"{

            case TRANSFORM_R90:
                store = x;
                x = y;
                y = vd->source.i_visible_height - store;
                break;
            case TRANSFORM_R180:
                x = vd->source.i_visible_width - x;
                y = vd->source.i_visible_height - y;
                break;
            case TRANSFORM_R270:
                store = x;
                x = vd->source.i_visible_width - y;
                y = store;
                break;
            case TRANSFORM_HFLIP:
                x = vd->source.i_visible_width - x;
                break;
            case TRANSFORM_VFLIP:
                y = vd->source.i_visible_height - y;
                break;
            case TRANSFORM_TRANSPOSE:
                store = x;
                x = y;
                y = store;
                break;
            case TRANSFORM_ANTI_TRANSPOSE:
                store = x;
                x = vd->source.i_visible_width - y;
                y = vd->source...",28,,291,2,,void
187095,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    filter_owner_t owner = {
        .sys = vd,
        .video = {
            .buffer_new = VideoBufferNew,
        },
    };

    osys->filters = filter_chain_NewVideo(vd, false, &owner);
    if (unlikely(osys->filters == NULL))
        return -1;

    video_format_t v_src = vd->source;
    v_src.i_sar_num = 0;
    v_src.i_sar_den = 0;

    video_format_t v_dst = vd->fmt;
    v_dst.i_sar_num = 0;
    v_dst.i_sar_den = 0;

    video_format_t v_dst_cmp = v_dst;
    if ((v_src.i_chroma == VLC_CODEC_J420 && v_dst.i_chroma == VLC_CODEC_I420) ||
        (v_src.i_chroma == VLC_CODEC_J422 && v_dst.i_chroma == VLC_CODEC_I422) ||
        (v_src.i_chroma == VLC_CODEC_J440 && v_dst.i_chroma == VLC_CODEC_I440) ||
        (v_src.i_chroma == VLC_CODEC_J444 && v_dst.i_chroma == VLC_CODEC_I444))
        v_dst_cmp.i_chroma = v_src.i_chroma;

    const bool convert = memcmp(&v_src, &v_dst_cmp, sizeof(v_src)) != 0;
    if (!convert)
        return...",1,,403,2,,void
187108,BLOCK,1,,<empty>,9,,406,1,,void
187112,BLOCK,2,,<empty>,9,,407,2,,void
187116,BLOCK,1,,<empty>,13,,408,1,,void
187136,BLOCK,-1,,<empty>,9,,414,2,,void
187224,BLOCK,-1,,<empty>,9,,429,2,,void
187247,BLOCK,-1,,<empty>,9,,433,2,,void
187273,BLOCK,-1,,<empty>,5,,445,1,,void
187291,BLOCK,4,,"{
        es_format_t dst;

        es_format_InitFromVideo(&dst, i == 0 ? &v_dst : &v_dst_cmp);

        filter_chain_Reset(osys->filters, &src, &dst);
        ret = filter_chain_AppendConverter(osys->filters, &src, &dst);
        es_format_Clean(&dst);
        if (ret == 0)
            break;
    }",74,,445,4,,void
187329,BLOCK,-1,,<empty>,13,,454,2,,void
187338,BLOCK,-1,,"{
        msg_Err(vd, ""Failed to adapt decoder format to display"");
        filter_chain_Delete(osys->filters);
        osys->filters = NULL;
    }",19,,458,2,,void
187357,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters)
        filter_chain_Delete(osys->filters);
}",1,,467,2,,void
187370,BLOCK,-1,,<empty>,9,,471,2,,void
187379,BLOCK,-1,,"{
    VoutDisplayDestroyRender(vd);
    return VoutDisplayCreateRender(vd);
}",1,,475,2,,void
187391,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);

    /* */
    vlc_mouse_t m = osys->mouse.state;
    bool is_ignored = false;

    switch (event) {
    case VOUT_DISPLAY_EVENT_MOUSE_STATE: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);
        const int button_mask = (int)va_arg(args, int);

        vlc_mouse_Init(&m);
        m.i_x = x;
        m.i_y = y;
        m.i_pressed = button_mask;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);

        //msg_Dbg(vd, ""VoutDisplayEvent 'mouse' @%d,%d"", x, y);

        m.i_x = x;
        m.i_y = y;
        m.b_double_click = false;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED: {
        const int button = (int)va_arg(args, int);
        const int button_mask = 1 << button;

        /* Ign...",1,,481,4,,void
187419,BLOCK,-1,,"{
    case VOUT_DISPLAY_EVENT_MOUSE_STATE: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);
        const int button_mask = (int)va_arg(args, int);

        vlc_mouse_Init(&m);
        m.i_x = x;
        m.i_y = y;
        m.i_pressed = button_mask;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);

        //msg_Dbg(vd, ""VoutDisplayEvent 'mouse' @%d,%d"", x, y);

        m.i_x = x;
        m.i_y = y;
        m.b_double_click = false;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED: {
        const int button = (int)va_arg(args, int);
        const int button_mask = 1 << button;

        /* Ignore inconsistent event */
        if ((event == VOUT_DISPLAY_EVENT_MOUSE_PRESSED  &&  (osys->mouse.state.i_pressed & button_mask)) ||
            (event == VOUT_DISPLAY_EVENT_MOUSE_RELEAS...",20,,490,2,,void
187422,BLOCK,3,,"{
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);
        const int button_mask = (int)va_arg(args, int);

        vlc_mouse_Init(&m);
        m.i_x = x;
        m.i_y = y;
        m.i_pressed = button_mask;
        break;
    }",42,,491,3,,void
187447,BLOCK,6,,"{
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);

        //msg_Dbg(vd, ""VoutDisplayEvent 'mouse' @%d,%d"", x, y);

        m.i_x = x;
        m.i_y = y;
        m.b_double_click = false;
        break;
    }",42,,502,6,,void
187470,BLOCK,11,,"{
        const int button = (int)va_arg(args, int);
        const int button_mask = 1 << button;

        /* Ignore inconsistent event */
        if ((event == VOUT_DISPLAY_EVENT_MOUSE_PRESSED  &&  (osys->mouse.state.i_pressed & button_mask)) ||
            (event == VOUT_DISPLAY_EVENT_MOUSE_RELEASED && !(osys->mouse.state.i_pressed & button_mask))) {
            is_ignored = true;
            break;
        }

        /* */
        msg_Dbg(vd, ""VoutDisplayEvent 'mouse button' %d t=%d"", button, event);

        m.b_double_click = false;
        if (event == VOUT_DISPLAY_EVENT_MOUSE_PRESSED)
            m.i_pressed |= button_mask;
        else
            m.i_pressed &= ~button_mask;
        break;
    }",45,,514,11,,void
187507,BLOCK,-1,,"{
            is_ignored = true;
            break;
        }",107,,520,2,,void
187526,BLOCK,-1,,<empty>,13,,530,2,,void
187533,BLOCK,-1,,<empty>,13,,532,1,,void
187556,BLOCK,-1,,"{
        vlc_mutex_unlock(&osys->lock);
        return;
    }",21,,544,2,,void
187581,BLOCK,-1,,"{
        const mtime_t i_date = mdate();

        if (i_date - osys->mouse.last_pressed < osys->mouse.double_click_timeout ) {
            m.b_double_click = true;
            osys->mouse.last_pressed = 0;
        } else {
            osys->mouse.last_pressed = mdate();
        }
    }",74,,551,2,,void
187600,BLOCK,-1,,"{
            m.b_double_click = true;
            osys->mouse.last_pressed = 0;
        }",84,,554,2,,void
187614,BLOCK,-1,,"{
            osys->mouse.last_pressed = mdate();
        }",16,,557,1,,void
187660,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
    case VOUT_DISPLAY_EVENT_CLOSE: {
        msg_Dbg(vd, ""VoutDisplayEvent 'close'"");
        vout_SendEventClose(osys->vout);
        break;
    }
    case VOUT_DISPLAY_EVENT_KEY: {
        const int key = (int)va_arg(args, int);
        msg_Dbg(vd, ""VoutDisplayEvent 'key' 0x%2.2x"", key);
        vout_SendEventKey(osys->vout, key);
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
        VoutDisplayEventMouse(vd, event, args);
        break;

    case VOUT_DISPLAY_EVENT_VIEWPOINT_MOVED:
        vout_SendEventViewpointMoved(osys->vout,
                                     va_arg(args, const vlc_viewpoint_t *));
        break;

#if defined(_WIN32) || defined(__OS2__)
    case VOUT_DISPLAY_EVENT_FULLSCREEN: {
        const i...",1,,575,4,,void
187671,BLOCK,-1,,"{
    case VOUT_DISPLAY_EVENT_CLOSE: {
        msg_Dbg(vd, ""VoutDisplayEvent 'close'"");
        vout_SendEventClose(osys->vout);
        break;
    }
    case VOUT_DISPLAY_EVENT_KEY: {
        const int key = (int)va_arg(args, int);
        msg_Dbg(vd, ""VoutDisplayEvent 'key' 0x%2.2x"", key);
        vout_SendEventKey(osys->vout, key);
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
        VoutDisplayEventMouse(vd, event, args);
        break;

    case VOUT_DISPLAY_EVENT_VIEWPOINT_MOVED:
        vout_SendEventViewpointMoved(osys->vout,
                                     va_arg(args, const vlc_viewpoint_t *));
        break;

#if defined(_WIN32) || defined(__OS2__)
    case VOUT_DISPLAY_EVENT_FULLSCREEN: {
        const int is_fullscreen = (int)va_arg(args, int);
        const bool window_fulls...",20,,578,2,,void
187674,BLOCK,3,,"{
        msg_Dbg(vd, ""VoutDisplayEvent 'close'"");
        vout_SendEventClose(osys->vout);
        break;
    }",36,,579,3,,void
187685,BLOCK,6,,"{
        const int key = (int)va_arg(args, int);
        msg_Dbg(vd, ""VoutDisplayEvent 'key' 0x%2.2x"", key);
        vout_SendEventKey(osys->vout, key);
        break;
    }",34,,584,6,,void
187718,BLOCK,25,,"{
        const int width  = (int)va_arg(args, int);
        const int height = (int)va_arg(args, int);
        msg_Dbg(vd, ""VoutDisplayEvent 'resize' %dx%d"", width, height);

        /* */
        vlc_mutex_lock(&osys->lock);

        osys->ch_display_size   = true;
        osys->display_width     = width;
        osys->display_height    = height;

        vlc_mutex_unlock(&osys->lock);
        break;
    }",43,,634,25,,void
187754,BLOCK,28,,"{
        msg_Warn(vd, ""VoutDisplayEvent 'pictures invalid'"");

        /* */
        assert(vd->info.has_pictures_invalid);

        vlc_mutex_lock(&osys->lock);
        osys->reset_pictures = true;
        vlc_mutex_unlock(&osys->lock);
        break;
    }",47,,650,28,,void
187791,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window = vout_NewDisplayWindow(osys->vout, type);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",1,,669,3,,void
187812,BLOCK,-1,,<empty>,9,,673,2,,void
187823,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (window != NULL)
        vout_display_window_Detach(window);
    vout_DeleteDisplayWindow(osys->vout, window);
}",1,,678,3,,void
187836,BLOCK,-1,,<empty>,9,,682,2,,void
187849,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_display_cfg_t cfg = osys->cfg;

    if (!cfg.is_display_filled)
        return;

    cfg.display.width = 0;
    if (default_size) {
        cfg.display.height = 0;
    } else {
        cfg.zoom.num = 1;
        cfg.zoom.den = 1;
    }

    unsigned display_width;
    unsigned display_height;
    vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                       &vd->source, &cfg);
    vout_SetDisplayWindowSize(osys->vout, display_width, display_height);
}",1,,687,3,,void
187869,BLOCK,-1,,<empty>,9,,692,2,,void
187880,BLOCK,-1,,"{
        cfg.display.height = 0;
    }",23,,695,2,,void
187889,BLOCK,-1,,"{
        cfg.zoom.num = 1;
        cfg.zoom.den = 1;
    }",12,,697,1,,void
187933,BLOCK,-1,,"{
    unsigned scaled_width  = (uint64_t)source->i_visible_height * num * source->i_sar_den / den / source->i_sar_num;
    unsigned scaled_height = (uint64_t)source->i_visible_width  * den * source->i_sar_num / num / source->i_sar_den;

    if (scaled_width < source->i_visible_width) {
        *left   = (source->i_visible_width - scaled_width) / 2;
        *top    = 0;
        *right  = *left + scaled_width;
        *bottom = *top  + source->i_visible_height;
    } else {
        *left   = 0;
        *top    = (source->i_visible_height - scaled_height) / 2;
        *right  = *left + source->i_visible_width;
        *bottom = *top  + scaled_height;
    }
}",1,,712,8,,void
187980,BLOCK,-1,,"{
        *left   = (source->i_visible_width - scaled_width) / 2;
        *top    = 0;
        *right  = *left + scaled_width;
        *bottom = *top  + source->i_visible_height;
    }",49,,716,2,,void
188012,BLOCK,-1,,"{
        *left   = 0;
        *top    = (source->i_visible_height - scaled_height) / 2;
        *right  = *left + source->i_visible_width;
        *bottom = *top  + scaled_height;
    }",12,,721,1,,void
188048,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vout_display_Manage(vd);

    /* Handle mouse timeout */
    const mtime_t date = mdate();
    bool  hide_mouse = false;

    vlc_mutex_lock(&osys->lock);

    if (!osys->mouse.is_hidden &&
        osys->mouse.last_moved + osys->mouse.hide_timeout < date) {
        osys->mouse.is_hidden = hide_mouse = true;
    } else if (osys->mouse.ch_activity) {
        if (osys->mouse.is_hidden)
            vout_HideWindowMouse(osys->vout, false);
        osys->mouse.is_hidden = false;
    }
    osys->mouse.ch_activity = false;
    vlc_mutex_unlock(&osys->lock);

    if (hide_mouse) {
        msg_Dbg(vd, ""auto hiding mouse cursor"");
        if (vout_HideWindowMouse(osys->vout, true) != VLC_SUCCESS
         && vd->info.needs_hide_mouse)
            vout_display_Control(vd, VOUT_DISPLAY_HIDE_MOUSE);
    }

    bool reset_render = false;
    for (;;) {

        vlc_mutex_lock(&osys->lock);
#if defined(_WIN32) || defined(__OS2__)
        boo...",1,,730,3,,void
188093,BLOCK,-1,,"{
        osys->mouse.is_hidden = hide_mouse = true;
    }",67,,742,2,,void
188104,BLOCK,-1,,<empty>,12,,744,1,,void
188111,BLOCK,-1,,"{
        if (osys->mouse.is_hidden)
            vout_HideWindowMouse(osys->vout, false);
        osys->mouse.is_hidden = false;
    }",41,,744,2,,void
188118,BLOCK,-1,,<empty>,13,,746,2,,void
188145,BLOCK,-1,,"{
        msg_Dbg(vd, ""auto hiding mouse cursor"");
        if (vout_HideWindowMouse(osys->vout, true) != VLC_SUCCESS
         && vd->info.needs_hide_mouse)
            vout_display_Control(vd, VOUT_DISPLAY_HIDE_MOUSE);
    }",21,,752,2,,void
188163,BLOCK,-1,,<empty>,13,,756,2,,void
188172,BLOCK,-1,,<empty>,5,,760,1,,void
188173,BLOCK,4,,"{

        vlc_mutex_lock(&osys->lock);
#if defined(_WIN32) || defined(__OS2__)
        bool ch_fullscreen  = osys->ch_fullscreen;
        bool is_fullscreen  = osys->is_fullscreen;
        osys->ch_fullscreen = false;

        bool ch_wm_state  = osys->ch_wm_state;
        unsigned wm_state  = osys->wm_state;
        osys->ch_wm_state = false;
#endif

        bool ch_display_size       = osys->ch_display_size;
        int  display_width         = osys->display_width;
        int  display_height        = osys->display_height;
        osys->ch_display_size = false;

        bool reset_pictures;
        if (allow_reset_pictures) {
            reset_pictures = osys->reset_pictures;
            osys->reset_pictures = false;
        } else {
            reset_pictures = false;
        }

        vlc_mutex_unlock(&osys->lock);

        if (!ch_display_size &&
            !reset_pictures &&
            osys->is_display_filled == osys->cfg.is_display_filled &&
            !osys->ch_zoom &&
...",14,,760,4,,void
188205,BLOCK,-1,,"{
            reset_pictures = osys->reset_pictures;
            osys->reset_pictures = false;
        }",35,,779,2,,void
188217,BLOCK,-1,,"{
            reset_pictures = false;
        }",16,,782,1,,void
188262,BLOCK,-1,,"{

            if (osys->fit_window != 0) {
                VoutDisplayFitWindow(vd, osys->fit_window == -1);
                osys->fit_window = 0;
                continue;
            }
            break;
        }",34,,798,2,,void
188269,BLOCK,-1,,"{
                VoutDisplayFitWindow(vd, osys->fit_window == -1);
                osys->fit_window = 0;
                continue;
            }",40,,800,2,,void
188287,BLOCK,-1,,"{
#if defined(_WIN32) || defined(__OS2__)
            osys->width_saved  = osys->cfg.display.width;
            osys->height_saved = osys->cfg.display.height;
#endif
            osys->cfg.display.width  = display_width;
            osys->cfg.display.height = display_height;

            vout_display_Control(vd, VOUT_DISPLAY_CHANGE_DISPLAY_SIZE,
                                 &osys->cfg);
        }",30,,828,2,,void
188323,BLOCK,-1,,"{
            osys->cfg.is_display_filled = osys->is_display_filled;

            vout_display_Control(vd, VOUT_DISPLAY_CHANGE_DISPLAY_FILLED,
                                 &osys->cfg);
        }",69,,840,2,,void
188344,BLOCK,-1,,"{
            osys->fit_window = -1;
            osys->cfg.zoom.num = osys->zoom.num;
            osys->cfg.zoom.den = osys->zoom.den;
            osys->ch_zoom = false;

            vout_display_Control(vd, VOUT_DISPLAY_CHANGE_ZOOM, &osys->cfg);
        }",28,,847,2,,void
188393,BLOCK,-1,,"{
            if (osys->sar.num > 0 && osys->sar.den > 0) {
                vd->source.i_sar_num = osys->sar.num;
                vd->source.i_sar_den = osys->sar.den;
            } else {
                vd->source.i_sar_num = osys->source.i_sar_num;
                vd->source.i_sar_den = osys->source.i_sar_den;
            }

            vout_display_Control(vd, VOUT_DISPLAY_CHANGE_SOURCE_ASPECT);
            if (!osys->fit_window)
                osys->fit_window = 1;
            osys->sar.num = vd->source.i_sar_num;
            osys->sar.den = vd->source.i_sar_den;
            osys->ch_sar  = false;

            /* If a crop ratio is requested, recompute the parameters */
            if (osys->crop.num != 0 && osys->crop.den != 0)
                osys->ch_crop = true;
        }",27,,866,2,,void
188410,BLOCK,-1,,"{
                vd->source.i_sar_num = osys->sar.num;
                vd->source.i_sar_den = osys->sar.den;
            }",57,,867,2,,void
188434,BLOCK,-1,,"{
                vd->source.i_sar_num = osys->source.i_sar_num;
                vd->source.i_sar_den = osys->source.i_sar_den;
            }",20,,870,1,,void
188465,BLOCK,-1,,<empty>,17,,877,2,,void
188514,BLOCK,-1,,<empty>,17,,884,2,,void
188524,BLOCK,-1,,"{
            unsigned crop_num = osys->crop.num;
            unsigned crop_den = osys->crop.den;
            if (crop_num != 0 && crop_den != 0) {
                video_format_t fmt = osys->source;
                fmt.i_sar_num = vd->source.i_sar_num;
                fmt.i_sar_den = vd->source.i_sar_den;
                VoutDisplayCropRatio(&osys->crop.left,  &osys->crop.top,
                                     &osys->crop.right, &osys->crop.bottom,
                                     &fmt, crop_num, crop_den);
            }
            const int right_max  = osys->source.i_x_offset + osys->source.i_visible_width;
            const int bottom_max = osys->source.i_y_offset + osys->source.i_visible_height;
            int left   = VLC_CLIP((int)osys->source.i_x_offset + osys->crop.left,
                                0, right_max - 1);
            int top    = VLC_CLIP((int)osys->source.i_y_offset + osys->crop.top,
                                0, bottom_max - 1);
            in...",28,,887,2,,void
188549,BLOCK,-1,,"{
                video_format_t fmt = osys->source;
                fmt.i_sar_num = vd->source.i_sar_num;
                fmt.i_sar_den = vd->source.i_sar_den;
                VoutDisplayCropRatio(&osys->crop.left,  &osys->crop.top,
                                     &osys->crop.right, &osys->crop.bottom,
                                     &fmt, crop_num, crop_den);
            }",49,,890,2,,void
188683,BLOCK,-1,,<empty>,17,,906,2,,void
188706,BLOCK,-1,,<empty>,17,,908,1,,void
188738,BLOCK,-1,,<empty>,17,,911,2,,void
188761,BLOCK,-1,,<empty>,17,,913,1,,void
188841,BLOCK,-1,,<empty>,17,,925,2,,void
188962,BLOCK,-1,,"{
            vout_display_cfg_t cfg = osys->cfg;

            cfg.viewpoint = osys->viewpoint;

            if (vout_display_Control(vd, VOUT_DISPLAY_CHANGE_VIEWPOINT, &cfg)) {
                msg_Err(vd, ""Failed to change Viewpoint"");
                osys->viewpoint = osys->cfg.viewpoint;
            }
            osys->cfg.viewpoint = osys->viewpoint;
            osys->ch_viewpoint  = false;
        }",33,,937,2,,void
188982,BLOCK,-1,,"{
                msg_Err(vd, ""Failed to change Viewpoint"");
                osys->viewpoint = osys->cfg.viewpoint;
            }",80,,942,2,,void
189011,BLOCK,-1,,"{
            if (vout_display_Control(vd, VOUT_DISPLAY_RESET_PICTURES)) {
                /* FIXME what to do here ? */
                msg_Err(vd, ""Failed to reset pictures (probably fatal)"");
            }
            reset_render = true;
        }",29,,951,2,,void
189016,BLOCK,-1,,"{
                /* FIXME what to do here ? */
                msg_Err(vd, ""Failed to reset pictures (probably fatal)"");
            }",72,,952,2,,void
189025,BLOCK,-1,,<empty>,9,,960,2,,void
189034,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);
    const bool reset_pictures = osys->reset_pictures;
    vlc_mutex_unlock(&osys->lock);

    return reset_pictures;
}",1,,966,2,,void
189065,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    return osys->filters == NULL || !filter_chain_IsEmpty(osys->filters);
}",1,,977,2,,void
189091,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters == NULL) {
        picture_Release(picture);
        return NULL;
    }

    return filter_chain_VideoFilter(osys->filters, picture);
}",1,,984,3,,void
189106,BLOCK,-1,,"{
        picture_Release(picture);
        return NULL;
    }",32,,987,2,,void
189121,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters != NULL)
        filter_chain_VideoFlush(osys->filters);
}",1,,996,2,,void
189136,BLOCK,-1,,<empty>,9,,1000,2,,void
189146,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (source->i_sar_num * osys->source.i_sar_den !=
        source->i_sar_den * osys->source.i_sar_num) {

        osys->source.i_sar_num = source->i_sar_num;
        osys->source.i_sar_den = source->i_sar_den;
        vlc_ureduce(&osys->source.i_sar_num, &osys->source.i_sar_den,
                    osys->source.i_sar_num, osys->source.i_sar_den, 0);

        /* FIXME it will override any AR that the user would have forced */
        osys->ch_sar = true;
        osys->sar.num = osys->source.i_sar_num;
        osys->sar.den = osys->source.i_sar_den;
    }
    if (source->i_x_offset       != osys->source.i_x_offset ||
        source->i_y_offset       != osys->source.i_y_offset ||
        source->i_visible_width  != osys->source.i_visible_width ||
        source->i_visible_height != osys->source.i_visible_height) {

        video_format_CopyCrop(&osys->source, source);

        /* Force the vout to reapply the current user crop s...",1,,1004,3,,void
189175,BLOCK,-1,,"{

        osys->source.i_sar_num = source->i_sar_num;
        osys->source.i_sar_den = source->i_sar_den;
        vlc_ureduce(&osys->source.i_sar_num, &osys->source.i_sar_den,
                    osys->source.i_sar_num, osys->source.i_sar_den, 0);

        /* FIXME it will override any AR that the user would have forced */
        osys->ch_sar = true;
        osys->sar.num = osys->source.i_sar_num;
        osys->sar.den = osys->source.i_sar_den;
    }",53,,1008,2,,void
189285,BLOCK,-1,,"{

        video_format_CopyCrop(&osys->source, source);

        /* Force the vout to reapply the current user crop settings over the new decoder
         * crop settings. */
        osys->ch_crop = true;
    }",68,,1023,2,,void
189302,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    osys->is_display_filled = is_filled;
}",1,,1034,3,,void
189322,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (num != 0 && den != 0) {
        vlc_ureduce(&num, &den, num, den, 0);
    } else {
        num = 1;
        den = 1;
    }

    if (10 * num <= den) {
        num = 1;
        den = 10;
    } else if (num >= 10 * den) {
        num = 10;
        den = 1;
    }

    if (osys->is_display_filled ||
        osys->zoom.num != num || osys->zoom.den != den) {
        osys->ch_zoom = true;
        osys->zoom.num = num;
        osys->zoom.den = den;
    }
}",1,,1041,4,,void
189339,BLOCK,-1,,"{
        vlc_ureduce(&num, &den, num, den, 0);
    }",31,,1044,2,,void
189349,BLOCK,-1,,"{
        num = 1;
        den = 1;
    }",12,,1046,1,,void
189362,BLOCK,-1,,"{
        num = 1;
        den = 10;
    }",26,,1051,2,,void
189370,BLOCK,-1,,<empty>,12,,1054,1,,void
189377,BLOCK,-1,,"{
        num = 10;
        den = 1;
    }",33,,1054,2,,void
189404,BLOCK,-1,,"{
        osys->ch_zoom = true;
        osys->zoom.num = num;
        osys->zoom.den = den;
    }",57,,1060,2,,void
189430,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    unsigned sar_num, sar_den;
    if (dar_num > 0 && dar_den > 0) {
        sar_num = dar_num * osys->source.i_visible_height;
        sar_den = dar_den * osys->source.i_visible_width;
        vlc_ureduce(&sar_num, &sar_den, sar_num, sar_den, 0);
    } else {
        sar_num = 0;
        sar_den = 0;
    }

    if (osys->sar.num != sar_num || osys->sar.den != sar_den) {
        osys->ch_sar = true;
        osys->sar.num = sar_num;
        osys->sar.den = sar_den;
    }
}",1,,1068,4,,void
189449,BLOCK,-1,,"{
        sar_num = dar_num * osys->source.i_visible_height;
        sar_den = dar_den * osys->source.i_visible_width;
        vlc_ureduce(&sar_num, &sar_den, sar_num, sar_den, 0);
    }",37,,1072,2,,void
189477,BLOCK,-1,,"{
        sar_num = 0;
        sar_den = 0;
    }",12,,1076,1,,void
189500,BLOCK,-1,,"{
        osys->ch_sar = true;
        osys->sar.num = sar_num;
        osys->sar.den = sar_den;
    }",63,,1081,2,,void
189530,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->crop.left  != (int)left  || osys->crop.top != (int)top ||
        osys->crop.right != right || osys->crop.bottom != bottom ||
        (crop_num != 0 && crop_den != 0 &&
         (crop_num != osys->crop.num || crop_den != osys->crop.den))) {

        osys->crop.left   = left;
        osys->crop.top    = top;
        osys->crop.right  = right;
        osys->crop.bottom = bottom;
        osys->crop.num    = crop_num;
        osys->crop.den    = crop_den;

        osys->ch_crop = true;
    }
}",1,,1090,8,,void
189599,BLOCK,-1,,"{

        osys->crop.left   = left;
        osys->crop.top    = top;
        osys->crop.right  = right;
        osys->crop.bottom = bottom;
        osys->crop.num    = crop_num;
        osys->crop.den    = crop_den;

        osys->ch_crop = true;
    }",71,,1096,2,,void
189652,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->viewpoint.yaw   != p_viewpoint->yaw ||
        osys->viewpoint.pitch != p_viewpoint->pitch ||
        osys->viewpoint.roll  != p_viewpoint->roll ||
        osys->viewpoint.fov   != p_viewpoint->fov) {
        osys->viewpoint = *p_viewpoint;

        osys->ch_viewpoint = true;
    }
}",1,,1111,3,,void
189701,BLOCK,-1,,"{
        osys->viewpoint = *p_viewpoint;

        osys->ch_viewpoint = true;
    }",52,,1117,2,,void
189724,BLOCK,-1,,"{
    /* */
    vout_display_owner_sys_t *osys = calloc(1, sizeof(*osys));
    vout_display_cfg_t *cfg = &osys->cfg;

    *cfg = state->cfg;
    osys->sar_initial = state->sar;
    vout_display_GetDefaultDisplaySize(&cfg->display.width, &cfg->display.height,
                                       source, cfg);

    osys->vout = vout;
    osys->is_splitter = is_splitter;

    vlc_mutex_init(&osys->lock);

    vlc_mouse_Init(&osys->mouse.state);
    osys->mouse.last_moved = mdate();
    osys->mouse.double_click_timeout = double_click_timeout;
    osys->mouse.hide_timeout = hide_timeout;
    osys->display_width  = cfg->display.width;
    osys->display_height = cfg->display.height;
    osys->is_display_filled = cfg->is_display_filled;
    osys->viewpoint      = cfg->viewpoint;

    osys->zoom.num = cfg->zoom.num;
    osys->zoom.den = cfg->zoom.den;
#if defined(_WIN32) || defined(__OS2__)
    osys->is_fullscreen  = cfg->is_fullscreen;
    osys->width_saved    = cfg->display.width;
    os...",1,,1131,9,,void
189961,BLOCK,-1,,"{
        owner = *owner_ptr;
    }",20,,1189,2,,void
189967,BLOCK,-1,,"{
        owner.event      = VoutDisplayEvent;
        owner.window_new = VoutDisplayNewWindow;
        owner.window_del = VoutDisplayDelWindow;
    }",12,,1191,1,,void
190004,BLOCK,-1,,<empty>,9,,1202,2,,void
190009,BLOCK,-1,,"{
        vout_display_Delete(p_display);
        goto error;
    }",45,,1204,2,,void
190033,BLOCK,-1,,<empty>,9,,1212,2,,void
190067,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (state) {
        if (!osys->is_splitter)
            state->cfg = osys->cfg;
#if defined(_WIN32) || defined(__OS2__)
        state->wm_state = osys->wm_state;
#endif
        state->sar = osys->sar_initial;
    }

    VoutDisplayDestroyRender(vd);
    if (osys->is_splitter)
        SplitterClose(vd);
    vout_display_Delete(vd);
    vlc_mutex_destroy(&osys->lock);
    free(osys);
}",1,,1225,3,,void
190078,BLOCK,-1,,"{
        if (!osys->is_splitter)
            state->cfg = osys->cfg;
#if defined(_WIN32) || defined(__OS2__)
        state->wm_state = osys->wm_state;
#endif
        state->sar = osys->sar_initial;
    }",16,,1228,2,,void
190084,BLOCK,-1,,<empty>,13,,1230,2,,void
190105,BLOCK,-1,,<empty>,9,,1239,2,,void
190126,BLOCK,-1,,"{
    return DisplayNew(vout, source, state, module, false,
                      double_click_timeout, hide_timeout, NULL);
}",1,,1254,7,,void
190150,BLOCK,-1,,"{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window;
    vout_window_cfg_t cfg = {
        .type = type,
        .width = vd->cfg->display.width,
        .height = vd->cfg->display.height,
        .is_standalone = true,
    };

    window = vout_display_window_New(osys->vout, &cfg);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",1,,1276,3,,void
190164,BLOCK,1,,<empty>,9,,1280,1,,void
190168,BLOCK,2,,<empty>,9,,1281,2,,void
190178,BLOCK,3,,<empty>,9,,1282,3,,void
190188,BLOCK,4,,<empty>,9,,1283,4,,void
190204,BLOCK,-1,,<empty>,9,,1288,2,,void
190215,BLOCK,-1,,"{
    if (window != NULL) {
        vout_display_window_Detach(window);
        vout_display_window_Delete(window);
    }
    (void) vd;
}",1,,1293,3,,void
190220,BLOCK,-1,,"{
        vout_display_window_Detach(window);
        vout_display_window_Delete(window);
    }",25,,1294,2,,void
190234,BLOCK,-1,,"{
    //vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
#if 0
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
        /* TODO */
        break;
#endif
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
    case VOUT_DISPLAY_EVENT_KEY:
    case VOUT_DISPLAY_EVENT_CLOSE:
    case VOUT_DISPLAY_EVENT_DISPLAY_SIZE:
    case VOUT_DISPLAY_EVENT_PICTURES_INVALID:
        VoutDisplayEvent(vd, event, args);
        break;

    default:
        msg_Err(vd, ""splitter event not implemented: %d"", event);
        break;
    }
}",1,,1302,4,,void
190237,BLOCK,-1,,"{
#if 0
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
        /* TODO */
        break;
#endif
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
    case VOUT_DISPLAY_EVENT_KEY:
    case VOUT_DISPLAY_EVENT_CLOSE:
    case VOUT_DISPLAY_EVENT_DISPLAY_SIZE:
    case VOUT_DISPLAY_EVENT_PICTURES_INVALID:
        VoutDisplayEvent(vd, event, args);
        break;

    default:
        msg_Err(vd, ""splitter event not implemented: %d"", event);
        break;
    }",20,,1305,2,,void
190264,BLOCK,-1,,"{
    vout_display_sys_t *sys = vd->sys;
    if (!sys->pool)
        sys->pool = picture_pool_NewFromFormat(&vd->fmt, count);
    return sys->pool;
}",1,,1329,3,,void
190276,BLOCK,-1,,<empty>,9,,1332,2,,void
190297,BLOCK,-1,,"{
    vout_display_sys_t *sys = vd->sys;

    picture_Hold(picture);
    assert(!subpicture);

    if (video_splitter_Filter(sys->splitter, sys->picture, picture)) {
        for (int i = 0; i < sys->count; i++)
            sys->picture[i] = NULL;
        return;
    }

    for (int i = 0; i < sys->count; i++) {
        sys->picture[i] = vout_FilterDisplay(sys->display[i], sys->picture[i]);
        if (sys->picture[i])
            vout_display_Prepare(sys->display[i], sys->picture[i], NULL);
    }
}",1,,1338,4,,void
190318,BLOCK,-1,,"{
        for (int i = 0; i < sys->count; i++)
            sys->picture[i] = NULL;
        return;
    }",70,,1344,2,,void
190320,BLOCK,-1,,<empty>,9,,1345,1,,void
190341,BLOCK,-1,,<empty>,5,,1350,1,,void
190353,BLOCK,4,,"{
        sys->picture[i] = vout_FilterDisplay(sys->display[i], sys->picture[i]);
        if (sys->picture[i])
            vout_display_Prepare(sys->display[i], sys->picture[i], NULL);
    }",42,,1350,4,,void
190377,BLOCK,-1,,<empty>,13,,1353,2,,void
190396,BLOCK,-1,,"{
    vout_display_sys_t *sys = vd->sys;

    assert(!subpicture);
    for (int i = 0; i < sys->count; i++) {
        if (sys->picture[i])
            vout_display_Display(sys->display[i], sys->picture[i], NULL);
    }
    picture_Release(picture);
}",1,,1359,4,,void
190407,BLOCK,-1,,<empty>,5,,1363,1,,void
190419,BLOCK,4,,"{
        if (sys->picture[i])
            vout_display_Display(sys->display[i], sys->picture[i], NULL);
    }",42,,1363,4,,void
190426,BLOCK,-1,,<empty>,13,,1365,2,,void
190447,BLOCK,-1,,"{
    (void)vd; (void)query; (void)args;
    return VLC_EGENERIC;
}",1,,1370,4,,void
190463,BLOCK,-1,,"{
    vout_display_sys_t *sys = vd->sys;

    for (int i = 0; i < sys->count; i++)
        vout_ManageDisplay(sys->display[i], true);
}",1,,1375,2,,void
190471,BLOCK,-1,,<empty>,5,,1378,1,,void
190495,BLOCK,-1,,"{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++) {
        if (vout_IsDisplayFiltered(wsys->display[i])) {
            /* TODO use a pool ? */
            picture[i] = picture_NewFromFormat(&wsys->display[i]->source);
        } else {
            picture_pool_t *pool = vout_display_Pool(wsys->display[i], 3);
            picture[i] = pool ? picture_pool_Get(pool) : NULL;
        }
        if (!picture[i]) {
            for (int j = 0; j < i; j++)
                picture_Release(picture[j]);
            return VLC_EGENERIC;
        }
    }
    return VLC_SUCCESS;
}",1,,1383,3,,void
190507,BLOCK,-1,,<empty>,5,,1386,1,,void
190519,BLOCK,4,,"{
        if (vout_IsDisplayFiltered(wsys->display[i])) {
            /* TODO use a pool ? */
            picture[i] = picture_NewFromFormat(&wsys->display[i]->source);
        } else {
            picture_pool_t *pool = vout_display_Pool(wsys->display[i], 3);
            picture[i] = pool ? picture_pool_Get(pool) : NULL;
        }
        if (!picture[i]) {
            for (int j = 0; j < i; j++)
                picture_Release(picture[j]);
            return VLC_EGENERIC;
        }
    }",43,,1386,4,,void
190527,BLOCK,-1,,"{
            /* TODO use a pool ? */
            picture[i] = picture_NewFromFormat(&wsys->display[i]->source);
        }",55,,1387,2,,void
190542,BLOCK,-1,,"{
            picture_pool_t *pool = vout_display_Pool(wsys->display[i], 3);
            picture[i] = pool ? picture_pool_Get(pool) : NULL;
        }",16,,1390,1,,void
190567,BLOCK,-1,,"{
            for (int j = 0; j < i; j++)
                picture_Release(picture[j]);
            return VLC_EGENERIC;
        }",26,,1394,2,,void
190569,BLOCK,-1,,<empty>,13,,1395,1,,void
190592,BLOCK,-1,,"{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++)
        picture_Release(picture[i]);
}",1,,1403,3,,void
190604,BLOCK,-1,,<empty>,5,,1406,1,,void
190624,BLOCK,-1,,"{
    vout_display_sys_t *sys = vd->sys;

    /* */
    video_splitter_t *splitter = sys->splitter;
    free(splitter->p_owner);
    video_splitter_Delete(splitter);

    if (sys->pool)
        picture_pool_Release(sys->pool);

    /* */
    for (int i = 0; i < sys->count; i++)
        vout_DeleteDisplay(sys->display[i], NULL);
    TAB_CLEAN(sys->count, sys->display);
    free(sys->picture);

    free(sys);
}",1,,1410,2,,void
190647,BLOCK,-1,,<empty>,9,,1419,2,,void
190653,BLOCK,-1,,<empty>,5,,1422,1,,void
190695,BLOCK,-1,,"{
    video_splitter_t *splitter =
        video_splitter_New(VLC_OBJECT(vout), splitter_module, source);
    if (!splitter)
        return NULL;

    /* */
    vout_display_t *wrapper =
        DisplayNew(vout, source, state, module, true,
                    double_click_timeout, hide_timeout, NULL);
    if (!wrapper) {
        video_splitter_Delete(splitter);
        return NULL;
    }
    vout_display_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        abort();
    sys->picture = calloc(splitter->i_output, sizeof(*sys->picture));
    if (!sys->picture )
        abort();
    sys->splitter = splitter;
    sys->pool     = NULL;

    wrapper->pool    = SplitterPool;
    wrapper->prepare = SplitterPrepare;
    wrapper->display = SplitterDisplay;
    wrapper->control = SplitterControl;
    wrapper->manage  = SplitterManage;
    wrapper->sys     = sys;

    /* */
    video_splitter_owner_t *vso = xmalloc(sizeof(*vso));
    vso->wrapper = wrapper;
    splitter->p_owner = vso;
    s...",1,,1437,8,,void
190707,BLOCK,-1,,<empty>,9,,1441,2,,void
190725,BLOCK,-1,,"{
        video_splitter_Delete(splitter);
        return NULL;
    }",19,,1447,2,,void
190740,BLOCK,-1,,<empty>,9,,1453,2,,void
190760,BLOCK,-1,,<empty>,9,,1456,2,,void
190837,BLOCK,-1,,<empty>,5,,1476,1,,void
190849,BLOCK,4,,"{
        vout_display_owner_t vdo = {
            .event      = SplitterEvent,
            .window_new = SplitterNewWindow,
            .window_del = SplitterDelWindow,
        };
        const video_splitter_output_t *output = &splitter->p_output[i];
        vout_display_state_t ostate;

        memset(&ostate, 0, sizeof(ostate));
        ostate.cfg.display = state->cfg.display;
        ostate.cfg.align.horizontal = 0; /* TODO */
        ostate.cfg.align.vertical = 0; /* TODO */
        ostate.cfg.is_display_filled = true;
        ostate.cfg.zoom.num = 1;
        ostate.cfg.zoom.den = 1;

        vout_display_t *vd = DisplayNew(vout, &output->fmt, &ostate,
                                        output->psz_module ? output->psz_module : module,
                                        false,
                                        double_click_timeout, hide_timeout, &vdo);
        if (!vd) {
            vout_DeleteDisplay(wrapper, NULL);
            return NULL;
        }
        T...",50,,1476,4,,void
190854,BLOCK,1,,<empty>,13,,1478,1,,void
190858,BLOCK,2,,<empty>,13,,1479,2,,void
190862,BLOCK,3,,<empty>,13,,1480,3,,void
190963,BLOCK,-1,,"{
            vout_DeleteDisplay(wrapper, NULL);
            return NULL;
        }",18,,1497,2,,void
190984,BLOCK,-1,,"{
    vlc_mouse_t tmp1, tmp2;

    /* The check on spu is needed as long as ALLOW_DUMMY_VOUT is defined */
    if (vout->p->spu && spu_ProcessMouse( vout->p->spu, m, &vout->p->display.vd->source))
        return;

    vlc_mutex_lock( &vout->p->filter.lock );
    if (vout->p->filter.chain_static && vout->p->filter.chain_interactive) {
        if (!filter_chain_MouseFilter(vout->p->filter.chain_interactive, &tmp1, m))
            m = &tmp1;
        if (!filter_chain_MouseFilter(vout->p->filter.chain_static,      &tmp2, m))
            m = &tmp2;
    }
    vlc_mutex_unlock( &vout->p->filter.lock );

    if (vlc_mouse_HasMoved(&vout->p->mouse, m)) {
        vout_SendEventMouseMoved(vout, m->i_x, m->i_y);
    }
    if (vlc_mouse_HasButton(&vout->p->mouse, m)) {
        for (unsigned button = 0; button < MOUSE_BUTTON_MAX; button++) {
            if (vlc_mouse_HasPressed(&vout->p->mouse, m, button))
                vout_SendEventMousePressed(vout, button);
            else if (vlc_mouse_Ha...",1,,1512,3,,void
191011,BLOCK,-1,,<empty>,9,,1517,2,,void
191038,BLOCK,-1,,"{
        if (!filter_chain_MouseFilter(vout->p->filter.chain_interactive, &tmp1, m))
            m = &tmp1;
        if (!filter_chain_MouseFilter(vout->p->filter.chain_static,      &tmp2, m))
            m = &tmp2;
    }",76,,1520,2,,void
191052,BLOCK,-1,,<empty>,13,,1522,2,,void
191070,BLOCK,-1,,<empty>,13,,1524,2,,void
191093,BLOCK,-1,,"{
        vout_SendEventMouseMoved(vout, m->i_x, m->i_y);
    }",49,,1528,2,,void
191111,BLOCK,-1,,"{
        for (unsigned button = 0; button < MOUSE_BUTTON_MAX; button++) {
            if (vlc_mouse_HasPressed(&vout->p->mouse, m, button))
                vout_SendEventMousePressed(vout, button);
            else if (vlc_mouse_HasReleased(&vout->p->mouse, m, button))
                vout_SendEventMouseReleased(vout, button);
        }
    }",50,,1531,2,,void
191113,BLOCK,-1,,<empty>,9,,1532,1,,void
191123,BLOCK,4,,"{
            if (vlc_mouse_HasPressed(&vout->p->mouse, m, button))
                vout_SendEventMousePressed(vout, button);
            else if (vlc_mouse_HasReleased(&vout->p->mouse, m, button))
                vout_SendEventMouseReleased(vout, button);
        }",72,,1532,4,,void
191134,BLOCK,-1,,<empty>,17,,1534,2,,void
191139,BLOCK,-1,,<empty>,18,,1535,1,,void
191150,BLOCK,-1,,<empty>,17,,1536,2,,void
191158,BLOCK,-1,,<empty>,9,,1540,2,,void
191177,BLOCK,-1,,<empty>,1,,1,1,,ANY
191186,BLOCK,-1,,<empty>,,,,8,,<empty>
191192,BLOCK,-1,,<empty>,,,,3,,<empty>
191198,BLOCK,-1,,<empty>,,,,3,,<empty>
191204,BLOCK,-1,,<empty>,,,,3,,<empty>
191211,BLOCK,-1,,<empty>,,,,4,,<empty>
191217,BLOCK,-1,,<empty>,,,,3,,<empty>
191223,BLOCK,-1,,<empty>,,,,3,,<empty>
191236,BLOCK,-1,,<empty>,1,,1,1,,ANY
191239,BLOCK,-1,,"{
#warning FIXME: implement video close event
    /* FIXME: this code is disabled as it breaks the non-playlist cases */
    //playlist_Stop(pl_Get(vout));
    (void) vout;
}",1,,41,2,,void
191248,BLOCK,-1,,"{
    var_SetInteger(vout->obj.libvlc, ""key-pressed"", key);
}",1,,48,3,,void
191263,BLOCK,-1,,"{
    var_SetCoords(vout, ""mouse-moved"", x, y);
}",1,,52,4,,void
191274,BLOCK,-1,,"{
    var_SetAddress(vout, ""viewpoint-moved"", (void *) p_viewpoint);
    /* This variable can only be read from callbacks */
    var_Change(vout, ""viewpoint-moved"", VLC_VAR_SETVALUE,
               &(vlc_value_t) { .p_address = NULL }, NULL);
}",1,,57,3,,void
191289,BLOCK,1,,<empty>,33,,61,1,,void
191299,BLOCK,-1,,"{
    int key = KEY_UNSET;
    var_OrInteger(vout, ""mouse-button-down"", 1 << button);

    switch (button)
    {
    case MOUSE_BUTTON_LEFT:
    {
        /* FIXME? */
        int x, y;
        var_GetCoords(vout, ""mouse-moved"", &x, &y);
        var_SetCoords(vout, ""mouse-clicked"", x, y);
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", false);
        return;
    }
    case MOUSE_BUTTON_CENTER:
        var_ToggleBool(vout->obj.libvlc, ""intf-toggle-fscontrol"");
        return;
    case MOUSE_BUTTON_RIGHT:
#if !defined(_WIN32)
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
#endif
        return;
    case MOUSE_BUTTON_WHEEL_UP:    key = KEY_MOUSEWHEELUP;    break;
    case MOUSE_BUTTON_WHEEL_DOWN:  key = KEY_MOUSEWHEELDOWN;  break;
    case MOUSE_BUTTON_WHEEL_LEFT:  key = KEY_MOUSEWHEELLEFT;  break;
    case MOUSE_BUTTON_WHEEL_RIGHT: key = KEY_MOUSEWHEELRIGHT; break;
    }
    vout_SendEventKey(vout, key);
}",1,,64,3,,void
191312,BLOCK,-1,,"{
    case MOUSE_BUTTON_LEFT:
    {
        /* FIXME? */
        int x, y;
        var_GetCoords(vout, ""mouse-moved"", &x, &y);
        var_SetCoords(vout, ""mouse-clicked"", x, y);
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", false);
        return;
    }
    case MOUSE_BUTTON_CENTER:
        var_ToggleBool(vout->obj.libvlc, ""intf-toggle-fscontrol"");
        return;
    case MOUSE_BUTTON_RIGHT:
#if !defined(_WIN32)
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
#endif
        return;
    case MOUSE_BUTTON_WHEEL_UP:    key = KEY_MOUSEWHEELUP;    break;
    case MOUSE_BUTTON_WHEEL_DOWN:  key = KEY_MOUSEWHEELDOWN;  break;
    case MOUSE_BUTTON_WHEEL_LEFT:  key = KEY_MOUSEWHEELLEFT;  break;
    case MOUSE_BUTTON_WHEEL_RIGHT: key = KEY_MOUSEWHEELRIGHT; break;
    }",5,,69,2,,void
191315,BLOCK,3,,"{
        /* FIXME? */
        int x, y;
        var_GetCoords(vout, ""mouse-moved"", &x, &y);
        var_SetCoords(vout, ""mouse-clicked"", x, y);
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", false);
        return;
    }",5,,71,3,,void
191392,BLOCK,-1,,"{
    var_NAndInteger(vout, ""mouse-button-down"", 1 << button);
#if defined(_WIN32)
    switch (button)
    {
    case MOUSE_BUTTON_RIGHT:
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
        return;
    }
#endif
}",1,,95,3,,void
191403,BLOCK,-1,,"{
    //vout_ControlSetFullscreen(vout, !var_GetBool(vout, ""fullscreen""));
    var_ToggleBool(vout, ""fullscreen"");
}",1,,107,2,,void
191412,BLOCK,-1,,"{
    var_SetBool(vout, ""viewpoint-changeable"", b_can_change);
}",1,,113,3,,void
191435,BLOCK,-1,,<empty>,1,,1,1,,ANY
191442,BLOCK,-1,,"{
    inhibit_t *priv = vlc_custom_create (parent, sizeof (*priv), ""inhibit"" );
    if (priv == NULL)
        return NULL;

    vlc_inhibit_t *ih = &priv->ih;
    ih->p_sys = NULL;
    ih->inhibit = NULL;

    priv->module = module_need (ih, ""inhibit"", NULL, false);
    if (priv->module == NULL)
    {
        vlc_object_release (ih);
        ih = NULL;
    }
    return ih;
}",1,,38,2,,void
191456,BLOCK,-1,,<empty>,9,,41,2,,void
191491,BLOCK,-1,,"{
        vlc_object_release (ih);
        ih = NULL;
    }",5,,49,2,,void
191503,BLOCK,-1,,"{
    assert (ih != NULL);

    module_unneed (ih, ((inhibit_t *)ih)->module);
    vlc_object_release (ih);
}",1,,57,2,,void
191525,BLOCK,-1,,<empty>,1,,1,1,,ANY
191528,BLOCK,-1,,<empty>,,,,2,,<empty>
191533,BLOCK,-1,,<empty>,,,,2,,<empty>
191552,BLOCK,-1,,<empty>,1,,1,1,,ANY
191570,BLOCK,-1,,"{
    for (unsigned i = 0; i < ARRAY_SIZE(deinterlace_modes); i++) {
        if (!strcmp(deinterlace_modes[i], mode))
            return true;
    }
    return false;
}",1,,57,2,,void
191572,BLOCK,-1,,<empty>,5,,58,1,,void
191583,BLOCK,4,,"{
        if (!strcmp(deinterlace_modes[i], mode))
            return true;
    }",66,,58,4,,void
191591,BLOCK,-1,,<empty>,13,,60,2,,void
191604,BLOCK,-1,,"{
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(newval); VLC_UNUSED(data);
    vout_thread_t *vout = (vout_thread_t *)object;

    /* */
    const int  deinterlace_state = var_GetInteger(vout, ""deinterlace"");
    char       *mode             = var_GetString(vout,  ""deinterlace-mode"");
    const bool is_needed         = var_GetBool(vout,    ""deinterlace-needed"");
    if (!mode || !DeinterlaceIsModeValid(mode))
    {
        free(mode);
        return VLC_EGENERIC;
    }

    /* */
    char *old = var_CreateGetString(vout, ""sout-deinterlace-mode"");
    var_SetString(vout, ""sout-deinterlace-mode"", mode);

    msg_Dbg(vout, ""deinterlace %d, mode %s, is_needed %d"", deinterlace_state, mode, is_needed);
    if (deinterlace_state == 0 || (deinterlace_state < 0 && !is_needed))
        vout_control_PushBool(&vout->p->control,
                              VOUT_CONTROL_CHANGE_INTERLACE, false);
    else
        vout_control_PushBool(&vout->p->control,
                              VOUT_C...",1,,67,6,,void
191644,BLOCK,-1,,"{
        free(mode);
        return VLC_EGENERIC;
    }",5,,76,2,,void
191676,BLOCK,-1,,<empty>,9,,87,2,,void
191687,BLOCK,-1,,<empty>,9,,90,1,,void
191708,BLOCK,-1,,"{
    vlc_value_t val, text;

    msg_Dbg(vout, ""Deinterlacing available"");

    vout->p->filter.has_deint = false;

    /* Create the configuration variables */
    /* */
    var_Create(vout, ""deinterlace"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    int deinterlace_state = var_GetInteger(vout, ""deinterlace"");

    text.psz_string = _(""Deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_SETTEXT, &text, NULL);

    const module_config_t *optd = config_FindConfig(""deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    if (likely(optd != NULL))
        for (unsigned i = 0; i < optd->list_count; i++) {
            val.i_int = optd->list.i[i];
            text.psz_string = vlc_gettext(optd->list_text[i]);
            var_Change(vout, ""deinterlace"", VLC_VAR_ADDCHOICE, &val, &text);
        }
    var_AddCallback(vout, ""deinterlace"", DeinterlaceCallback, NULL);
    /* */
    var_Create(vout, ""deinterlace-mode"", VLC_VAR_STRING | VLC_VAR_DOINHERIT );
...",1,,100,3,,void
191764,BLOCK,-1,,<empty>,9,,118,2,,void
191766,BLOCK,-1,,<empty>,9,,118,1,,void
191778,BLOCK,4,,"{
            val.i_int = optd->list.i[i];
            text.psz_string = vlc_gettext(optd->list_text[i]);
            var_Change(vout, ""deinterlace"", VLC_VAR_ADDCHOICE, &val, &text);
        }",57,,118,4,,void
191854,BLOCK,-1,,<empty>,9,,134,2,,void
191856,BLOCK,-1,,<empty>,9,,134,1,,void
191868,BLOCK,4,,"{
             if (!DeinterlaceIsModeValid(optm->list.psz[i]))
                 continue;

             val.psz_string  = (char *)optm->list.psz[i];
             text.psz_string = vlc_gettext(optm->list_text[i]);
             var_Change(vout, ""deinterlace-mode"", VLC_VAR_ADDCHOICE,
                        &val, &text);
         }",57,,134,4,,void
191879,BLOCK,-1,,<empty>,18,,136,2,,void
191938,BLOCK,-1,,<empty>,9,,151,2,,void
191946,BLOCK,-1,,"{
        deinterlace_state = 1;
        free(deinterlace_mode);
        deinterlace_mode = filter_mode;
    }",22,,152,2,,void
192003,BLOCK,-1,,<empty>,9,,169,2,,void
192017,BLOCK,-1,,"{
    vout->p->interlacing.is_interlaced = false;
    var_SetBool(vout, ""deinterlace-needed"", false);
}",1,,173,2,,void
192036,BLOCK,-1,,"{
     /* Wait 30s before quiting interlacing mode */
    const int interlacing_change = (!!is_interlaced)
                                 - (!!vout->p->interlacing.is_interlaced);
    if (interlacing_change == 1 ||
        (interlacing_change == -1 &&
        vout->p->interlacing.date + 30000000 < mdate()))
    {
        msg_Dbg(vout, ""Detected %s video"",
                 is_interlaced ? ""interlaced"" : ""progressive"");
        var_SetBool(vout, ""deinterlace-needed"", is_interlaced);
        vout->p->interlacing.is_interlaced = is_interlaced;
    }
    if (is_interlaced)
        vout->p->interlacing.date = mdate();
}",1,,179,3,,void
192074,BLOCK,-1,,"{
        msg_Dbg(vout, ""Detected %s video"",
                 is_interlaced ? ""interlaced"" : ""progressive"");
        var_SetBool(vout, ""deinterlace-needed"", is_interlaced);
        vout->p->interlacing.is_interlaced = is_interlaced;
    }",5,,186,2,,void
192097,BLOCK,-1,,<empty>,9,,193,2,,void
192113,BLOCK,-1,,<empty>,1,,1,1,,ANY
192117,BLOCK,-1,,<empty>,,,,3,,<empty>
192122,BLOCK,-1,,<empty>,,,,2,,<empty>
192128,BLOCK,-1,,<empty>,,,,3,,<empty>
192153,BLOCK,-1,,<empty>,1,,1,1,,ANY
192161,BLOCK,-1,,"{
    vlc_object_t *parent = (vlc_object_t *)wnd;
    struct vlc_gl_priv_t *glpriv;
    const char *type;

    switch (flags /*& VLC_OPENGL_API_MASK*/)
    {
        case VLC_OPENGL:
            type = ""opengl"";
            break;
        case VLC_OPENGL_ES2:
            type = ""opengl es2"";
            break;
        default:
            return NULL;
    }

    glpriv = vlc_custom_create(parent, sizeof (*glpriv), ""gl"");
    if (unlikely(glpriv == NULL))
        return NULL;

    glpriv->gl.surface = wnd;
    glpriv->gl.module = module_need(&glpriv->gl, type, name, true);
    if (glpriv->gl.module == NULL)
    {
        vlc_object_release(&glpriv->gl);
        return NULL;
    }
    atomic_init(&glpriv->ref_count, 1);

    return &glpriv->gl;
}",1,,52,4,,void
192172,BLOCK,-1,,"{
        case VLC_OPENGL:
            type = ""opengl"";
            break;
        case VLC_OPENGL_ES2:
            type = ""opengl es2"";
            break;
        default:
            return NULL;
    }",5,,58,2,,void
192193,BLOCK,1,,<empty>,,,,5,,void
192206,BLOCK,-1,,<empty>,9,,71,2,,void
192238,BLOCK,-1,,"{
        vlc_object_release(&glpriv->gl);
        return NULL;
    }",5,,76,2,,void
192261,BLOCK,-1,,"{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    atomic_fetch_add(&glpriv->ref_count, 1);
}",1,,86,2,,void
192278,BLOCK,-1,,"{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    if (atomic_fetch_sub(&glpriv->ref_count, 1) != 1)
        return;
    module_unneed(gl, gl->module);
    vlc_object_release(gl);
}",1,,92,2,,void
192294,BLOCK,-1,,<empty>,9,,95,2,,void
192314,BLOCK,-1,,"{
    vlc_gl_surface_t *sys = surface->owner.sys;

    msg_Dbg(surface, ""resized to %ux%u"", width, height);

    vlc_mutex_lock(&sys->lock);
    sys->width = width;
    sys->height = height;
    vlc_mutex_unlock(&sys->lock);
}",1,,111,4,,void
192354,BLOCK,-1,,"{
    vlc_gl_surface_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->width = cfg->width;
    sys->height = cfg->height;
    vlc_mutex_init(&sys->lock);

    vout_window_owner_t owner = {
        .sys = sys,
        .resized = vlc_gl_surface_ResizeNotify,
    };

    vout_window_t *surface = vout_window_New(obj, ""$window"", cfg, &owner);
    if (surface == NULL)
        goto error;
    if (wp != NULL)
        *wp = surface;

    /* TODO: support ES? */
    vlc_gl_t *gl = vlc_gl_Create(surface, VLC_OPENGL, NULL);
    if (gl == NULL) {
        vout_window_Delete(surface);
        return NULL;
    }

    vlc_gl_Resize(gl, cfg->width, cfg->height);
    return gl;

error:
    vlc_mutex_destroy(&sys->lock);
    free(sys);
    return NULL;
}",1,,125,4,,void
192367,BLOCK,-1,,<empty>,9,,128,2,,void
192393,BLOCK,1,,<empty>,9,,135,1,,void
192397,BLOCK,2,,<empty>,9,,136,2,,void
192414,BLOCK,-1,,<empty>,9,,141,2,,void
192420,BLOCK,-1,,<empty>,9,,143,2,,void
192436,BLOCK,-1,,"{
        vout_window_Delete(surface);
        return NULL;
    }",21,,147,2,,void
192467,BLOCK,-1,,"{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;
    bool ret = false;

    vlc_mutex_lock(&sys->lock);
    if (sys->width >= 0 && sys->height >= 0)
    {
        *width = sys->width;
        *height = sys->height;
        sys->width = -1;
        sys->height = -1;

        vlc_gl_Resize(gl, *width, *height);
        ret = true;
    }
    vlc_mutex_unlock(&sys->lock);
    return ret;
}",1,,171,4,,void
192503,BLOCK,-1,,"{
        *width = sys->width;
        *height = sys->height;
        sys->width = -1;
        sys->height = -1;

        vlc_gl_Resize(gl, *width, *height);
        ret = true;
    }",5,,178,2,,void
192548,BLOCK,-1,,"{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;

    vlc_gl_Release(gl);
    vout_window_Delete(surface);
    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",1,,192,2,,void
192606,BLOCK,-1,,<empty>,1,,1,1,,ANY
192609,BLOCK,-1,,"{
    vlc_mutex_init(&snap->lock);
    vlc_cond_init(&snap->wait);

    snap->is_available = true;
    snap->request_count = 0;
    snap->picture = NULL;
}",1,,46,2,,void
192639,BLOCK,-1,,"{
    picture_t *picture = snap->picture;
    while (picture) {
        picture_t *next = picture->p_next;
        picture_Release(picture);
        picture = next;
    }

    vlc_cond_destroy(&snap->wait);
    vlc_mutex_destroy(&snap->lock);
}",1,,55,2,,void
192648,BLOCK,-1,,"{
        picture_t *next = picture->p_next;
        picture_Release(picture);
        picture = next;
    }",21,,57,2,,void
192674,BLOCK,-1,,"{
    vlc_mutex_lock(&snap->lock);

    snap->is_available = false;

    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",1,,68,2,,void
192700,BLOCK,-1,,"{
    const mtime_t deadline = mdate() + timeout;

    vlc_mutex_lock(&snap->lock);

    /* */
    snap->request_count++;

    /* */
    while (snap->is_available && !snap->picture &&
        vlc_cond_timedwait(&snap->wait, &snap->lock, deadline) == 0);

    /* */
    picture_t *picture = snap->picture;
    if (picture)
        snap->picture = picture->p_next;
    else if (snap->request_count > 0)
        snap->request_count--;

    vlc_mutex_unlock(&snap->lock);

    return picture;
}",1,,79,3,,void
192746,BLOCK,-1,,<empty>,9,,94,2,,void
192755,BLOCK,-1,,<empty>,10,,95,1,,void
192762,BLOCK,-1,,<empty>,9,,96,2,,void
192778,BLOCK,-1,,"{
    bool has_request = false;
    if (!vlc_mutex_trylock(&snap->lock)) {
        has_request = snap->request_count > 0;
        vlc_mutex_unlock(&snap->lock);
    }
    return has_request;
}",1,,105,2,,void
192790,BLOCK,-1,,"{
        has_request = snap->request_count > 0;
        vlc_mutex_unlock(&snap->lock);
    }",42,,107,2,,void
192811,BLOCK,-1,,"{
    if (!fmt)
        fmt = &picture->format;

    vlc_mutex_lock(&snap->lock);
    while (snap->request_count > 0) {
        picture_t *dup = picture_Clone(picture);
        if (!dup)
            break;

        video_format_CopyCrop( &dup->format, fmt );

        dup->p_next = snap->picture;
        snap->picture = dup;
        snap->request_count--;
    }
    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",1,,116,4,,void
192815,BLOCK,-1,,<empty>,9,,118,2,,void
192833,BLOCK,-1,,"{
        picture_t *dup = picture_Clone(picture);
        if (!dup)
            break;

        video_format_CopyCrop( &dup->format, fmt );

        dup->p_next = snap->picture;
        snap->picture = dup;
        snap->request_count--;
    }",37,,121,2,,void
192842,BLOCK,-1,,<empty>,13,,124,2,,void
192880,BLOCK,-1,,"{
    return config_GetUserDir(VLC_PICTURES_DIR);
}",1,,137,2,,void
192892,BLOCK,-1,,"{
    /* */
    char *filename;
    input_thread_t *input = (input_thread_t*)p_vout->p->input;

    /* */
    char *prefix = NULL;
    if (cfg->prefix_fmt)
        prefix = str_format(input, cfg->prefix_fmt);
    if (prefix)
        filename_sanitize(prefix);
    else {
        prefix = strdup(""vlcsnap-"");
        if (prefix == NULL)
            goto error;
    }

    struct stat st;
    bool b_is_folder = false;

    if ( vlc_stat( cfg->path, &st ) == 0 )
        b_is_folder = S_ISDIR( st.st_mode );
    if ( b_is_folder ) {
        if (cfg->is_sequential) {
            for (int num = cfg->sequence; ; num++) {
                if (asprintf(&filename, ""%s"" DIR_SEP ""%s%05d.%s"",
                             cfg->path, prefix, num, cfg->format) < 0) {
                    free(prefix);
                    goto error;
                }
                if (vlc_stat(filename, &st)) {
                    *sequential = num;
                    break;
                }
                free(file...",1,,145,6,,void
192912,BLOCK,-1,,<empty>,9,,153,2,,void
192922,BLOCK,-1,,<empty>,9,,155,2,,void
192926,BLOCK,-1,,"{
        prefix = strdup(""vlcsnap-"");
        if (prefix == NULL)
            goto error;
    }",10,,156,1,,void
192935,BLOCK,-1,,<empty>,13,,159,2,,void
192951,BLOCK,-1,,<empty>,9,,166,2,,void
192960,BLOCK,-1,,"{
        if (cfg->is_sequential) {
            for (int num = cfg->sequence; ; num++) {
                if (asprintf(&filename, ""%s"" DIR_SEP ""%s%05d.%s"",
                             cfg->path, prefix, num, cfg->format) < 0) {
                    free(prefix);
                    goto error;
                }
                if (vlc_stat(filename, &st)) {
                    *sequential = num;
                    break;
                }
                free(filename);
            }
        } else {
            struct timespec ts;
            struct tm curtime;
            char buffer[128];

            timespec_get(&ts, TIME_UTC);
            if (localtime_r(&ts.tv_sec, &curtime) == NULL)
                gmtime_r(&ts.tv_sec, &curtime);
            if (strftime(buffer, sizeof(buffer), ""%Y-%m-%d-%Hh%Mm%Ss"",
                         &curtime) == 0)
                strcpy(buffer, ""error"");

            if (asprintf(&filename, ""%s"" DIR_SEP ""%s%s%03lu.%s"",
                         cfg->...",24,,167,2,,void
192965,BLOCK,-1,,"{
            for (int num = cfg->sequence; ; num++) {
                if (asprintf(&filename, ""%s"" DIR_SEP ""%s%05d.%s"",
                             cfg->path, prefix, num, cfg->format) < 0) {
                    free(prefix);
                    goto error;
                }
                if (vlc_stat(filename, &st)) {
                    *sequential = num;
                    break;
                }
                free(filename);
            }
        }",33,,168,2,,void
192967,BLOCK,-1,,<empty>,13,,169,1,,void
192976,BLOCK,4,,"{
                if (asprintf(&filename, ""%s"" DIR_SEP ""%s%05d.%s"",
                             cfg->path, prefix, num, cfg->format) < 0) {
                    free(prefix);
                    goto error;
                }
                if (vlc_stat(filename, &st)) {
                    *sequential = num;
                    break;
                }
                free(filename);
            }",52,,169,4,,void
192979,BLOCK,-1,,"{
                    free(prefix);
                    goto error;
                }",72,,171,2,,void
192988,BLOCK,-1,,"{
                    *sequential = num;
                    break;
                }",46,,175,2,,void
192997,BLOCK,-1,,"{
            struct timespec ts;
            struct tm curtime;
            char buffer[128];

            timespec_get(&ts, TIME_UTC);
            if (localtime_r(&ts.tv_sec, &curtime) == NULL)
                gmtime_r(&ts.tv_sec, &curtime);
            if (strftime(buffer, sizeof(buffer), ""%Y-%m-%d-%Hh%Mm%Ss"",
                         &curtime) == 0)
                strcpy(buffer, ""error"");

            if (asprintf(&filename, ""%s"" DIR_SEP ""%s%s%03lu.%s"",
                         cfg->path, prefix, buffer, ts.tv_nsec / 1000000,
                         cfg->format) < 0)
                filename = NULL;
        }",16,,181,1,,void
193015,BLOCK,-1,,<empty>,17,,188,2,,void
193033,BLOCK,-1,,<empty>,17,,191,2,,void
193039,BLOCK,-1,,<empty>,17,,196,2,,void
193044,BLOCK,-1,,"{
        filename = strdup( cfg->path );
    }",12,,198,1,,void
193056,BLOCK,-1,,<empty>,9,,204,2,,void
193067,BLOCK,-1,,"{
        msg_Err(p_vout, ""Failed to open '%s'"", filename);
        free(filename);
        goto error;
    }",16,,208,2,,void
193087,BLOCK,-1,,"{
        msg_Err(p_vout, ""Failed to write to '%s'"", filename);
        fclose(file);
        free(filename);
        goto error;
    }",65,,213,2,,void
193101,BLOCK,-1,,<empty>,9,,223,2,,void
193107,BLOCK,-1,,<empty>,9,,225,1,,void
193126,BLOCK,-1,,<empty>,1,,1,1,,ANY
193136,BLOCK,-1,,<empty>,,,,2,,<empty>
193141,BLOCK,-1,,<empty>,,,,2,,<empty>
193146,BLOCK,-1,,<empty>,,,,2,,<empty>
193152,BLOCK,-1,,<empty>,,,,3,,<empty>
193157,BLOCK,-1,,<empty>,,,,2,,<empty>
193164,BLOCK,-1,,<empty>,,,,4,,<empty>
193169,BLOCK,-1,,<empty>,,,,2,,<empty>
193185,BLOCK,-1,,<empty>,,,,6,,<empty>
193194,BLOCK,-1,,<empty>,1,,1,1,,ANY
193201,BLOCK,-1,,"{
    atomic_init(&stat->displayed, 0);
    atomic_init(&stat->lost, 0);
}",1,,37,2,,void
193218,BLOCK,-1,,"{
    (void) stat;
}",1,,43,2,,void
193228,BLOCK,-1,,"{
    *displayed = atomic_exchange(&stat->displayed, 0);
    *lost      = atomic_exchange(&stat->lost, 0);
}",1,,50,4,,void
193252,BLOCK,-1,,"{
    atomic_fetch_add(&stat->displayed, displayed);
}",1,,57,3,,void
193264,BLOCK,-1,,"{
    atomic_fetch_add(&stat->lost, lost);
}",1,,62,3,,void
193297,BLOCK,-1,,<empty>,1,,1,1,,ANY
193305,BLOCK,-1,,"{
    char *psz_uri = NULL;
    char *psz_path;
    char *psz_datadir = config_GetDataDir();
    if( asprintf( &psz_path, ""%s/icons/128x128/vlc.png"", psz_datadir ) >= 0 )
    {
        psz_uri = vlc_path2uri( psz_path, NULL );
        free( psz_path );
    }
    free( psz_datadir );
    return psz_uri;
}",1,,78,2,,void
193323,BLOCK,-1,,"{
        psz_uri = vlc_path2uri( psz_path, NULL );
        free( psz_path );
    }",5,,83,2,,void
193343,BLOCK,-1,,"{
    /* Create a new subpicture region */
    video_palette_t palette;
    spuregion_CreateVGradientPalette( &palette, GRADIENT_COLORS, i_argb, 0xFF000000 );

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x = x;
    region->i_y = y;

    spuregion_CreateVGradientFill( region->p_picture->p, palette.i_entries );

    return region;
}",1,,96,6,,void
193349,BLOCK,1,,<empty>,,,,1,,void
193401,BLOCK,-1,,<empty>,9,,111,2,,void
193440,BLOCK,-1,,"{
    /* Create a new subpicture region */
    video_palette_t palette = {
        .i_entries = 4,
        .palette = {
            [0] = { HEX2YUV(RGB_COLOR1), 0x20 }, /* Bar fill remain/background */
            [1] = { HEX2YUV(0x00ff00), 0xff },
            [2] = { HEX2YUV(RGB_COLOR1), 0xC0 }, /* Bar fill */
            [3] = { HEX2YUV(0xffffff), 0xff }, /* Bar outline */
        },
    };

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x = x;
    region->i_y = y;

    picture_t *picture = region->p_picture;

    ratio = VLC_CLIP(ratio, 0, 1);
    int filled_part_width = ratio * width;

    for (int j = 0...",1,,125,6,,void
193445,BLOCK,1,,<empty>,9,,128,1,,void
193449,BLOCK,2,,<empty>,9,,129,2,,void
193453,BLOCK,1,,<empty>,13,,130,1,,void
193458,BLOCK,1,,<empty>,,,,1,,void
193524,BLOCK,2,,<empty>,13,,131,2,,void
193530,BLOCK,1,,<empty>,,,,2,,void
193596,BLOCK,3,,<empty>,13,,132,3,,void
193601,BLOCK,1,,<empty>,,,,1,,void
193667,BLOCK,4,,<empty>,13,,133,4,,void
193673,BLOCK,1,,<empty>,,,,2,,void
193787,BLOCK,-1,,<empty>,9,,147,2,,void
193826,BLOCK,-1,,<empty>,5,,158,1,,void
193836,BLOCK,4,,"{
        for (int i = 0; i < width; ) {
            /* Slider border. */
            bool is_outline = j == 0 || j == height - 1 ||
                              i == 0 || i == width  - 1;
            /* We can see the video through the part of the slider
               which corresponds to the leaving time. */
            bool is_border = j < 3 || j > height - 4 ||
                             i < 3 || i > width  - 4 ||
                             i < filled_part_width;

            uint8_t color = 2 * is_border + is_outline;
            if(i >= 3 && i < width - 4)
            {
                if(filled_part_width > 4)
                    memset(&picture->p->p_pixels[picture->p->i_pitch * j + i],
                           color, filled_part_width - 4);
                if(width > filled_part_width + 4)
                    memset(&picture->p->p_pixels[picture->p->i_pitch * j + filled_part_width],
                           color, width - filled_part_width - 4);
                i ...",38,,158,4,,void
193838,BLOCK,-1,,<empty>,9,,159,1,,void
193846,BLOCK,4,,"{
            /* Slider border. */
            bool is_outline = j == 0 || j == height - 1 ||
                              i == 0 || i == width  - 1;
            /* We can see the video through the part of the slider
               which corresponds to the leaving time. */
            bool is_border = j < 3 || j > height - 4 ||
                             i < 3 || i > width  - 4 ||
                             i < filled_part_width;

            uint8_t color = 2 * is_border + is_outline;
            if(i >= 3 && i < width - 4)
            {
                if(filled_part_width > 4)
                    memset(&picture->p->p_pixels[picture->p->i_pitch * j + i],
                           color, filled_part_width - 4);
                if(width > filled_part_width + 4)
                    memset(&picture->p->p_pixels[picture->p->i_pitch * j + filled_part_width],
                           color, width - filled_part_width - 4);
                i = __MAX(i+1, filled_part_width - 1);
  ...",38,,159,4,,void
193913,BLOCK,-1,,"{
                if(filled_part_width > 4)
                    memset(&picture->p->p_pixels[picture->p->i_pitch * j + i],
                           color, filled_part_width - 4);
                if(width > filled_part_width + 4)
                    memset(&picture->p->p_pixels[picture->p->i_pitch * j + filled_part_width],
                           color, width - filled_part_width - 4);
                i = __MAX(i+1, filled_part_width - 1);
            }",13,,171,2,,void
193918,BLOCK,-1,,<empty>,21,,173,2,,void
193946,BLOCK,-1,,<empty>,21,,176,2,,void
193980,BLOCK,-1,,"{
                picture->p->p_pixels[picture->p->i_pitch * j + i] = color;
                i++;
            }",13,,181,1,,void
194006,BLOCK,-1,,"{
    for( ; p_segment; p_segment = p_segment->p_next )
    {
        p_segment->style->e_wrapinfo = STYLE_WRAP_NONE;
        p_segment->style->i_features |= STYLE_HAS_WRAP_INFO;
    }
}",1,,192,2,,void
194008,BLOCK,-1,,<empty>,5,,193,1,,void
194015,BLOCK,4,,"{
        p_segment->style->e_wrapinfo = STYLE_WRAP_NONE;
        p_segment->style->i_features |= STYLE_HAS_WRAP_INFO;
    }",5,,194,4,,void
194036,BLOCK,-1,,"{
    text_segment_t *p_segment = text_segment_New(psz_text);
    if(unlikely(!p_segment))
        return NULL;

    /* Set text style */
    p_segment->style = text_style_Create(STYLE_NO_DEFAULTS);
    if (unlikely(!p_segment->style))
    {
        text_segment_Delete(p_segment);
        return NULL;
    }

    p_segment->style->i_font_size  = __MAX(size ,1 );
    p_segment->style->i_font_color = color;
    p_segment->style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_segment->style->i_outline_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_shadow_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_features |= STYLE_HAS_FONT_ALPHA | STYLE_HAS_FONT_COLOR |
                                    STYLE_HAS_OUTLINE_ALPHA | STYLE_HAS_SHADOW_ALPHA;

    return p_segment;
}",1,,201,4,,void
194046,BLOCK,-1,,<empty>,9,,204,2,,void
194061,BLOCK,-1,,"{
        text_segment_Delete(p_segment);
        return NULL;
    }",5,,209,2,,void
194127,BLOCK,-1,,"{
    video_format_t fmt_out;
    video_format_Init( &fmt_out, VLC_CODEC_YUVA );
    fmt_out.i_width = fmt_out.i_visible_width = w;
    fmt_out.i_height = fmt_out.i_visible_height = h;

    subpicture_region_t *image =
            spuregion_CreateFromPicture( p_obj, &fmt_out, psz_uri );
    if( image )
    {
        image->i_x = x;
        image->i_y = y;
        image->i_align = SUBPICTURE_ALIGN_LEFT|SUBPICTURE_ALIGN_TOP;
    }
    return image;
}",1,,228,7,,void
194161,BLOCK,-1,,"{
        image->i_x = x;
        image->i_y = y;
        image->i_align = SUBPICTURE_ALIGN_LEFT|SUBPICTURE_ALIGN_TOP;
    }",5,,237,2,,void
194187,BLOCK,-1,,"{
    if( p_region )
    {
        p_region->i_max_width = w;
        p_region->i_max_height = h;
    }
}",1,,246,4,,void
194190,BLOCK,-1,,"{
        p_region->i_max_width = w;
        p_region->i_max_height = h;
    }",5,,248,2,,void
194207,BLOCK,-1,,"{
    video_format_t fmt;
    subpicture_region_t *region;

    if (!p_segment)
        return NULL;

    /* Create a new subpicture region */
    video_format_Init(&fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->p_text   = p_segment;
    region->i_align  = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_text_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x      = x;
    region->i_y      = y;
    region->b_balanced_text = false;

    return region;
}",1,,256,4,,void
194213,BLOCK,-1,,<empty>,9,,261,2,,void
194238,BLOCK,-1,,<empty>,9,,270,2,,void
194285,BLOCK,-1,,"{
    return vout_OSDTextRegion(vout_OSDSegment(text, size, color), x, y);
}",1,,285,6,,void
194298,BLOCK,-1,,"{
    char *psz;
    struct tm tms;
    localtime_r(&t, &tms);
    if(asprintf(&psz, ""%2.2d:%2.2d"", tms.tm_hour, tms.tm_min) < 0)
       psz = NULL;
    return psz;
}",1,,290,2,,void
194319,BLOCK,-1,,<empty>,8,,295,2,,void
194332,BLOCK,-1,,"{
    text_segment_t *p_segment = NULL;
    char *psz_start = vout_OSDPrintTime(p_evt->i_start);
    char *psz_end = vout_OSDPrintTime(p_evt->i_start + p_evt->i_duration);
    char *psz_text;
    if( -1 < asprintf(&psz_text, ""%s-%s "", psz_start, psz_end))
    {
        p_segment = vout_OSDSegment(psz_text, size, RGB_COLOR1);
        if( p_segment )
            p_segment->p_next = vout_OSDSegment(p_evt->psz_name, size, 0xffffff);
        vout_OSDSegmentSetNoWrap( p_segment );
    }
    free( psz_start );
    free( psz_end );
    if(!p_segment)
        return NULL;
    return vout_OSDTextRegion(p_segment, x, y);
}",1,,301,5,,void
194366,BLOCK,-1,,"{
        p_segment = vout_OSDSegment(psz_text, size, RGB_COLOR1);
        if( p_segment )
            p_segment->p_next = vout_OSDSegment(p_evt->psz_name, size, 0xffffff);
        vout_OSDSegmentSetNoWrap( p_segment );
    }",5,,307,2,,void
194373,BLOCK,1,,<empty>,,,,1,,void
194377,BLOCK,-1,,<empty>,13,,310,2,,void
194397,BLOCK,-1,,<empty>,9,,316,2,,void
194416,BLOCK,-1,,"{
    float f_progress = 0;
    VLC_UNUSED(ry);

    /* Display the name of the channel. */
    *last_ptr = vout_OSDEpgText(p_sys->epg->psz_name,
                                x,
                                y,
                                height * EPGOSD_TEXTSIZE_NAME,
                                0x00ffffff);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    const vlc_epg_event_t *p_current = p_sys->epg->p_current;
    vlc_epg_event_t *p_next = NULL;
    if(!p_sys->epg->p_current && p_sys->epg->i_event)
        p_current = p_sys->epg->pp_event[0];

    for(size_t i=0; i<p_sys->epg->i_event; i++)
    {
        if( p_sys->epg->pp_event[i]->i_id != p_current->i_id )
        {
            p_next = p_sys->epg->pp_event[i];
            break;
        }
    }

    /* Display the name of the current program. */
    if(p_current)
    {
        *last_ptr = vout_OSDEpgEvent(p_current,
                                     x,
                                     y + he...",1,,325,9,,void
194437,BLOCK,1,,<empty>,,,,1,,void
194447,BLOCK,-1,,<empty>,9,,336,2,,void
194480,BLOCK,-1,,<empty>,9,,341,2,,void
194491,BLOCK,-1,,<empty>,5,,343,1,,void
194505,BLOCK,4,,"{
        if( p_sys->epg->pp_event[i]->i_id != p_current->i_id )
        {
            p_next = p_sys->epg->pp_event[i];
            break;
        }
    }",5,,344,4,,void
194520,BLOCK,-1,,"{
            p_next = p_sys->epg->pp_event[i];
            break;
        }",9,,346,2,,void
194533,BLOCK,-1,,"{
        *last_ptr = vout_OSDEpgEvent(p_current,
                                     x,
                                     y + height * OSDEPG_ROW(2),
                                     height * EPGOSD_TEXTSIZE_PROG);
        /* region rendering limits */
        vout_OSDRegionConstrain(*last_ptr, width, 0);
        if(*last_ptr)
            last_ptr = &(*last_ptr)->p_next;
    }",5,,354,2,,void
194546,BLOCK,1,,<empty>,,,,2,,void
194555,BLOCK,1,,<empty>,,,,1,,void
194569,BLOCK,-1,,<empty>,13,,362,2,,void
194579,BLOCK,-1,,"{
        *last_ptr = vout_OSDEpgEvent(p_next,
                                     x,
                                     y + height * OSDEPG_ROW(5),
                                     height * EPGOSD_TEXTSIZE_PROG);
        /* region rendering limits */
        vout_OSDRegionConstrain(*last_ptr, width, 0);
        if(*last_ptr)
            last_ptr = &(*last_ptr)->p_next;
    }",5,,367,2,,void
194592,BLOCK,1,,<empty>,,,,2,,void
194601,BLOCK,1,,<empty>,,,,1,,void
194615,BLOCK,-1,,<empty>,13,,375,2,,void
194627,BLOCK,-1,,"{
        f_progress = (p_sys->time - p_sys->epg->p_current->i_start) /
                     (float)p_sys->epg->p_current->i_duration;
    }",5,,379,2,,void
194666,BLOCK,1,,<empty>,,,,2,,void
194679,BLOCK,1,,<empty>,,,,2,,void
194689,BLOCK,-1,,<empty>,9,,391,2,,void
194701,BLOCK,-1,,"{
        char *psz_network = vout_OSDPrintTime(p_sys->time);
        if(psz_network)
        {
            *last_ptr = vout_OSDEpgText(psz_network,
                                        rx,
                                        y + height * OSDEPG_ROW(0),
                                        height * EPGOSD_TEXTSIZE_NTWK,
                                        RGB_COLOR1);
            free(psz_network);
            if(*last_ptr)
            {
                (*last_ptr)->i_align = SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT;
                last_ptr = &(*last_ptr)->p_next;
            }
        }
    }",5,,395,2,,void
194711,BLOCK,-1,,"{
            *last_ptr = vout_OSDEpgText(psz_network,
                                        rx,
                                        y + height * OSDEPG_ROW(0),
                                        height * EPGOSD_TEXTSIZE_NTWK,
                                        RGB_COLOR1);
            free(psz_network);
            if(*last_ptr)
            {
                (*last_ptr)->i_align = SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT;
                last_ptr = &(*last_ptr)->p_next;
            }
        }",9,,398,2,,void
194724,BLOCK,1,,<empty>,,,,2,,void
194733,BLOCK,1,,<empty>,,,,1,,void
194740,BLOCK,1,,<empty>,,,,1,,void
194747,BLOCK,-1,,"{
                (*last_ptr)->i_align = SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT;
                last_ptr = &(*last_ptr)->p_next;
            }",13,,406,2,,void
194771,BLOCK,-1,,"{
    subpicture_region_t *head;
    subpicture_region_t **last_ptr = &head;

    const int i_padding = visible_height * (OSDEPG_HEIGHT * OSDEPG_PADDING);

    *last_ptr = vout_OSDBackground(x + visible_width * OSDEPG_LEFT,
                                   y + visible_height * OSDEPG_TOP,
                                   visible_width  * OSDEPG_WIDTH,
                                   visible_height * OSDEPG_HEIGHT,
                                   ARGB_BGCOLOR);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    struct
    {
        int x;
        int y;
        int w;
        int h;
        int rx;
        int ry;
    } panel = {
        x + visible_width  * OSDEPG_LEFT + i_padding,
        y + visible_height * OSDEPG_TOP + i_padding,
        visible_width  * OSDEPG_WIDTH - 2 * i_padding,
        visible_height * OSDEPG_HEIGHT - 2 * i_padding,
        visible_width * OSDEPG_LEFT + i_padding,
        visible_height * (1.0 - OSDEPG_TOP - OSDEPG_HEIGHT) + i_paddin...",1,,418,6,,void
194785,BLOCK,1,,<empty>,,,,1,,void
194788,BLOCK,1,,<empty>,,,,1,,void
194799,BLOCK,1,,<empty>,,,,1,,void
194806,BLOCK,1,,<empty>,,,,1,,void
194819,BLOCK,1,,<empty>,,,,1,,void
194828,BLOCK,1,,<empty>,,,,1,,void
194831,BLOCK,1,,<empty>,,,,1,,void
194836,BLOCK,-1,,<empty>,9,,430,2,,void
194854,BLOCK,1,,<empty>,,,,1,,void
194863,BLOCK,1,,<empty>,,,,1,,void
194878,BLOCK,1,,<empty>,,,,1,,void
194891,BLOCK,1,,<empty>,,,,1,,void
194900,BLOCK,1,,<empty>,,,,1,,void
194910,BLOCK,1,,<empty>,,,,1,,void
194921,BLOCK,1,,<empty>,,,,1,,void
194928,BLOCK,-1,,"{
        struct
        {
            int x;
            int y;
            int w;
            int h;
        } logo = {
            panel.x,
            panel.y,
            panel.h,
            panel.h,
        };

        *last_ptr = vout_OSDBackground(logo.x,
                                       logo.y,
                                       logo.w,
                                       logo.h,
                                       0xFF000000 | RGB_COLOR1);
        if(*last_ptr)
            last_ptr = &(*last_ptr)->p_next;

        int logo_padding = visible_height * (OSDEPG_LOGO_SIZE * OSDEPG_PADDING);
        *last_ptr = vout_OSDImage( p_sys->obj,
                                   logo.x + logo_padding,
                                   logo.y + logo_padding,
                                   logo.w - 2 * logo_padding,
                                   logo.h - 2 * logo_padding,
                                   p_sys->art );
        if(*last_ptr)
            last_pt...",5,,451,2,,void
194964,BLOCK,1,,<empty>,,,,1,,void
194969,BLOCK,-1,,<empty>,13,,471,2,,void
194984,BLOCK,1,,<empty>,,,,1,,void
194987,BLOCK,1,,<empty>,,,,1,,void
195026,BLOCK,-1,,<empty>,13,,481,2,,void
195084,BLOCK,-1,,"{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if (!has_dst_changed)
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",1,,504,7,,void
195098,BLOCK,-1,,<empty>,9,,510,2,,void
195110,BLOCK,-1,,"{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;

    subpic->p_region = vout_BuildOSDEpg(sys,
                                        fmt.i_x_offset,
                                        fmt.i_y_offset,
                                        fmt.i_visible_width,
                                        fmt.i_visible_height);
}",1,,518,5,,void
195209,BLOCK,-1,,"{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    if( sys->epg )
        vlc_epg_Delete(sys->epg);
    free( sys->art );
    free(sys);
}",1,,538,2,,void
195222,BLOCK,-1,,<empty>,9,,541,2,,void
195238,BLOCK,-1,,"{
    vlc_epg_t *epg = NULL;
    int64_t epg_time;

    /* Look for the current program EPG event */
    vlc_mutex_lock(&input->lock);

    const vlc_epg_t *tmp = input->p_epg_table;
    if ( tmp )
    {
        /* Pick table designated event, or first/next one */
        const vlc_epg_event_t *p_current_event = tmp->p_current;
        epg = vlc_epg_New(tmp->i_id, tmp->i_source_id);
        if(epg)
        {
            if( p_current_event )
            {
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_current_event);
                if(p_event)
                {
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }
            }

            /* Add next event if any */
            vlc_epg_event_t *p_next = NULL;
            for(size_t i=0; i<tmp->i_event; i++)
            {
                vlc_epg...",1,,553,3,,void
195257,BLOCK,-1,,"{
        /* Pick table designated event, or first/next one */
        const vlc_epg_event_t *p_current_event = tmp->p_current;
        epg = vlc_epg_New(tmp->i_id, tmp->i_source_id);
        if(epg)
        {
            if( p_current_event )
            {
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_current_event);
                if(p_event)
                {
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }
            }

            /* Add next event if any */
            vlc_epg_event_t *p_next = NULL;
            for(size_t i=0; i<tmp->i_event; i++)
            {
                vlc_epg_event_t *p_evt = tmp->pp_event[i];
                if((!p_next || p_next->i_start > p_evt->i_start) &&
                   (!p_current_event || (p_evt->i_id != p_current_event->i_id &&
                 ...",5,,562,2,,void
195275,BLOCK,-1,,"{
            if( p_current_event )
            {
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_current_event);
                if(p_event)
                {
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }
            }

            /* Add next event if any */
            vlc_epg_event_t *p_next = NULL;
            for(size_t i=0; i<tmp->i_event; i++)
            {
                vlc_epg_event_t *p_evt = tmp->pp_event[i];
                if((!p_next || p_next->i_start > p_evt->i_start) &&
                   (!p_current_event || (p_evt->i_id != p_current_event->i_id &&
                                         p_evt->i_start >= p_current_event->i_start +
                                                           p_current_event->i_duration )))
                {
                    p_next = t...",9,,567,2,,void
195278,BLOCK,-1,,"{
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_current_event);
                if(p_event)
                {
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }
            }",13,,569,2,,void
195286,BLOCK,-1,,"{
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }",17,,572,2,,void
195292,BLOCK,-1,,<empty>,25,,574,2,,void
195296,BLOCK,-1,,<empty>,25,,576,1,,void
195307,BLOCK,-1,,<empty>,13,,582,1,,void
195319,BLOCK,4,,"{
                vlc_epg_event_t *p_evt = tmp->pp_event[i];
                if((!p_next || p_next->i_start > p_evt->i_start) &&
                   (!p_current_event || (p_evt->i_id != p_current_event->i_id &&
                                         p_evt->i_start >= p_current_event->i_start +
                                                           p_current_event->i_duration )))
                {
                    p_next = tmp->pp_event[i];
                }
            }",13,,583,4,,void
195362,BLOCK,-1,,"{
                    p_next = tmp->pp_event[i];
                }",17,,589,2,,void
195372,BLOCK,-1,,"{
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_next);
                if(!vlc_epg_AddEvent(epg, p_event))
                    vlc_epg_event_Delete(p_event);
            }",13,,594,2,,void
195383,BLOCK,-1,,<empty>,21,,597,2,,void
195392,BLOCK,-1,,"{
                epg->psz_name = strdup(tmp->psz_name);
            }",13,,601,2,,void
195402,BLOCK,-1,,"{
                vlc_epg_Delete(epg);
                epg = NULL;
            }",13,,605,1,,void
195422,BLOCK,-1,,<empty>,9,,616,2,,void
195431,BLOCK,-1,,<empty>,9,,619,2,,void
195449,BLOCK,-1,,"{
        vlc_epg_Delete(epg);
        return VLC_EGENERIC;
    }",15,,622,2,,void
195482,BLOCK,-1,,<empty>,9,,631,2,,void
195492,BLOCK,1,,<empty>,9,,634,1,,void
195496,BLOCK,2,,<empty>,9,,635,2,,void
195500,BLOCK,3,,<empty>,9,,636,3,,void
195504,BLOCK,4,,<empty>,9,,637,4,,void
195521,BLOCK,-1,,"{
        vlc_epg_Delete(sys->epg);
        free(sys);
        return VLC_EGENERIC;
    }",18,,642,2,,void
195615,BLOCK,-1,,<empty>,1,,1,1,,ANY
195618,BLOCK,-1,,<empty>,,,,2,,<empty>
195623,BLOCK,-1,,<empty>,,,,2,,<empty>
195629,BLOCK,-1,,"{
    if (src->i_width == 0  || src->i_width  > 8192 ||
        src->i_height == 0 || src->i_height > 8192)
        return VLC_EGENERIC;
    if (src->i_sar_num <= 0 || src->i_sar_den <= 0)
        return VLC_EGENERIC;

    /* */
    video_format_Copy(dst, src);
    dst->i_chroma = vlc_fourcc_GetCodec(VIDEO_ES, src->i_chroma);
    vlc_ureduce( &dst->i_sar_num, &dst->i_sar_den,
                 src->i_sar_num,  src->i_sar_den, 50000 );
    if (dst->i_sar_num <= 0 || dst->i_sar_den <= 0) {
        dst->i_sar_num = 1;
        dst->i_sar_den = 1;
    }
    video_format_FixRgb(dst);
    return VLC_SUCCESS;
}",1,,80,3,,void
195654,BLOCK,-1,,<empty>,9,,83,2,,void
195669,BLOCK,-1,,<empty>,9,,85,2,,void
195712,BLOCK,-1,,"{
        dst->i_sar_num = 1;
        dst->i_sar_den = 1;
    }",53,,92,2,,void
195732,BLOCK,-1,,"{
    video_format_CopyCrop(dst, src);
    dst->i_sar_num = src->i_sar_num;
    dst->i_sar_den = src->i_sar_den;
}",1,,101,3,,void
195755,BLOCK,-1,,"{
    return dst->i_sar_num * src->i_sar_den == dst->i_sar_den * src->i_sar_num &&
           dst->i_x_offset       == src->i_x_offset &&
           dst->i_y_offset       == src->i_y_offset &&
           dst->i_visible_width  == src->i_visible_width &&
           dst->i_visible_height == src->i_visible_height;
}",1,,108,3,,void
195809,BLOCK,-1,,"{
    video_format_t original;
    if (VoutValidateFormat(&original, cfg->fmt))
        return NULL;

    /* Allocate descriptor */
    vout_thread_t *vout = vlc_custom_create(object,
                                            sizeof(*vout) + sizeof(*vout->p),
                                            ""video output"");
    if (!vout) {
        video_format_Clean(&original);
        return NULL;
    }

    /* */
    vout->p = (vout_thread_sys_t*)&vout[1];

    vout->p->original = original;
    vout->p->dpb_size = cfg->dpb_size;

    vout_control_Init(&vout->p->control);
    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_INIT);

    vout_statistic_Init(&vout->p->statistic);

    vout_snapshot_Init(&vout->p->snapshot);

    /* Initialize locks */
    vlc_mutex_init(&vout->p->filter.lock);
    vlc_mutex_init(&vout->p->spu_lock);

    /* Take care of some ""interface/control"" related initialisations */
    vout_IntfInit(vout);

    /* Initialize subpicture unit */
    vout->p->sp...",1,,118,3,,void
195818,BLOCK,-1,,<empty>,9,,121,2,,void
195839,BLOCK,-1,,"{
        video_format_Clean(&original);
        return NULL;
    }",16,,127,2,,void
195986,BLOCK,-1,,"{
        vout_window_cfg_t wcfg = {
            .is_standalone = !var_InheritBool(vout, ""embedded-video""),
            .is_fullscreen = var_GetBool(vout, ""fullscreen""),
            .type = VOUT_WINDOW_TYPE_INVALID,
            // TODO: take pixel A/R, crop and zoom into account
#ifdef __APPLE__
            .x = var_InheritInteger(vout, ""video-x""),
            .y = var_InheritInteger(vout, ""video-y""),
#endif
            .width = cfg->fmt->i_visible_width,
            .height = cfg->fmt->i_visible_height,
        };

        vout_window_t *window = vout_display_window_New(vout, &wcfg);
        if (window != NULL)
        {
            if (var_InheritBool(vout, ""video-wallpaper""))
                vout_window_SetState(window, VOUT_WINDOW_STATE_BELOW);
            else if (var_InheritBool(vout, ""video-on-top""))
                vout_window_SetState(window, VOUT_WINDOW_STATE_ABOVE);
        }
        vout->p->window = window;
    }",41,,166,2,,void
195991,BLOCK,1,,<empty>,13,,168,1,,void
195998,BLOCK,2,,<empty>,13,,169,2,,void
196004,BLOCK,3,,<empty>,13,,170,3,,void
196008,BLOCK,4,,<empty>,13,,176,4,,void
196016,BLOCK,5,,<empty>,13,,177,5,,void
196035,BLOCK,-1,,"{
            if (var_InheritBool(vout, ""video-wallpaper""))
                vout_window_SetState(window, VOUT_WINDOW_STATE_BELOW);
            else if (var_InheritBool(vout, ""video-on-top""))
                vout_window_SetState(window, VOUT_WINDOW_STATE_ABOVE);
        }",9,,182,2,,void
196040,BLOCK,-1,,<empty>,17,,184,2,,void
196045,BLOCK,-1,,<empty>,18,,185,1,,void
196050,BLOCK,-1,,<empty>,17,,186,2,,void
196062,BLOCK,-1,,<empty>,9,,190,1,,void
196084,BLOCK,-1,,"{
        if (vout->p->window != NULL)
            vout_display_window_Delete(vout->p->window);
        spu_Destroy(vout->p->spu);
        vlc_object_release(vout);
        return NULL;
    }",48,,197,2,,void
196093,BLOCK,-1,,<empty>,13,,199,2,,void
196123,BLOCK,-1,,"{
        msg_Err(vout, ""video output creation failed"");
        vout_CloseAndRelease(vout);
        return NULL;
    }",24,,207,2,,void
196146,BLOCK,-1,,<empty>,9,,215,2,,void
196166,BLOCK,-1,,"{
    vout_thread_t *vout = cfg->vout;
    if (cfg->change_fmt && !cfg->fmt) {
        if (vout)
            vout_CloseAndRelease(vout);
        return NULL;
    }

    /* If a vout is provided, try reusing it */
    if (vout) {
        if (vout->p->input != cfg->input) {
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, false);
            vout->p->input = cfg->input;
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, true);
        }

        if (cfg->change_fmt) {
            vout_control_cmd_t cmd;
            vout_control_cmd_Init(&cmd, VOUT_CONTROL_REINIT);
            cmd.u.cfg = cfg;

            vout_control_Push(&vout->p->control, &cmd);
            vout_control_WaitEmpty(&vout->p->control);
            vout_IntfReinit(vout);
        }

        if (!vout->p->dead) {
            msg_Dbg(object, ""reusing provided vout"");
            return vout;
        }
        vout_CloseAndRelease(vout);

       ...",1,,223,3,,void
196182,BLOCK,-1,,"{
        if (vout)
            vout_CloseAndRelease(vout);
        return NULL;
    }",39,,225,2,,void
196185,BLOCK,-1,,<empty>,13,,227,2,,void
196192,BLOCK,-1,,"{
        if (vout->p->input != cfg->input) {
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, false);
            vout->p->input = cfg->input;
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, true);
        }

        if (cfg->change_fmt) {
            vout_control_cmd_t cmd;
            vout_control_cmd_Init(&cmd, VOUT_CONTROL_REINIT);
            cmd.u.cfg = cfg;

            vout_control_Push(&vout->p->control, &cmd);
            vout_control_WaitEmpty(&vout->p->control);
            vout_IntfReinit(vout);
        }

        if (!vout->p->dead) {
            msg_Dbg(object, ""reusing provided vout"");
            return vout;
        }
        vout_CloseAndRelease(vout);

        msg_Warn(object, ""cannot reuse provided vout"");
    }",15,,232,2,,void
196203,BLOCK,-1,,"{
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, false);
            vout->p->input = cfg->input;
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, true);
        }",43,,233,2,,void
196210,BLOCK,-1,,<empty>,17,,235,2,,void
196238,BLOCK,-1,,<empty>,17,,238,2,,void
196255,BLOCK,-1,,"{
            vout_control_cmd_t cmd;
            vout_control_cmd_Init(&cmd, VOUT_CONTROL_REINIT);
            cmd.u.cfg = cfg;

            vout_control_Push(&vout->p->control, &cmd);
            vout_control_WaitEmpty(&vout->p->control);
            vout_IntfReinit(vout);
        }",30,,241,2,,void
196293,BLOCK,-1,,"{
            msg_Dbg(object, ""reusing provided vout"");
            return vout;
        }",29,,251,2,,void
196312,BLOCK,-1,,"{
    assert(vout);

    if (vout->p->input)
        spu_Attach(vout->p->spu, vout->p->input, false);

    vout_snapshot_End(&vout->p->snapshot);

    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_CLEAN);
    vlc_join(vout->p->thread, NULL);

    if (vout->p->window != NULL)
        vout_display_window_Delete(vout->p->window);

    vlc_mutex_lock(&vout->p->spu_lock);
    spu_Destroy(vout->p->spu);
    vout->p->spu = NULL;
    vlc_mutex_unlock(&vout->p->spu_lock);
}",1,,263,2,,void
196321,BLOCK,-1,,<empty>,9,,267,2,,void
196364,BLOCK,-1,,<empty>,9,,275,2,,void
196402,BLOCK,-1,,"{
    vout_thread_t *vout = (vout_thread_t *)object;

    /* Make sure the vout was stopped first */
    //assert(!vout->p_module);

    free(vout->p->splitter_name);

    /* Destroy the locks */
    vlc_mutex_destroy(&vout->p->spu_lock);
    vlc_mutex_destroy(&vout->p->filter.lock);
    vout_control_Clean(&vout->p->control);

    /* */
    vout_statistic_Clean(&vout->p->statistic);

    /* */
    vout_snapshot_Clean(&vout->p->snapshot);

    video_format_Clean(&vout->p->original);
}",1,,285,2,,void
196464,BLOCK,-1,,"{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_CANCEL, canceled);
    vout_control_WaitEmpty(&vout->p->control);
}",1,,309,3,,void
196487,BLOCK,-1,,"{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_PAUSE);
    cmd.u.pause.is_on = is_paused;
    cmd.u.pause.date  = date;
    vout_control_Push(&vout->p->control, &cmd);

    vout_control_WaitEmpty(&vout->p->control);
}",1,,315,4,,void
196533,BLOCK,-1,,"{
    vout_statistic_GetReset( &vout->p->statistic, displayed, lost );
}",1,,327,4,,void
196548,BLOCK,-1,,"{
    vout_control_PushTime(&vout->p->control, VOUT_CONTROL_FLUSH, date);
    vout_control_WaitEmpty(&vout->p->control);
}",1,,332,3,,void
196569,BLOCK,-1,,"{
    picture_t *picture = picture_fifo_Peek(vout->p->decoder_fifo);
    if (picture)
        picture_Release(picture);

    return !picture;
}",1,,338,2,,void
196581,BLOCK,-1,,<empty>,9,,341,2,,void
196592,BLOCK,-1,,"{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_STEP);
    cmd.u.time_ptr = duration;

    vout_control_Push(&vout->p->control, &cmd);
    vout_control_WaitEmpty(&vout->p->control);
}",1,,347,3,,void
196626,BLOCK,-1,,"{
    assert(title);
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_OSD_TITLE, title);
}",1,,357,3,,void
196643,BLOCK,-1,,"{
    assert(mouse);
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_WINDOW_MOUSE);
    cmd.u.window_mouse = *mouse;

    vout_control_Push(&vout->p->control, &cmd);
}",1,,364,3,,void
196673,BLOCK,-1,,"{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_SUBPICTURE);
    cmd.u.subpicture = subpic;

    vout_control_Push(&vout->p->control, &cmd);
}",1,,374,3,,void
196699,BLOCK,-1,,"{
    int channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    vlc_mutex_lock(&vout->p->spu_lock);
    if (vout->p->spu)
        channel = spu_RegisterChannel(vout->p->spu);
    vlc_mutex_unlock(&vout->p->spu_lock);

    return channel;
}",1,,382,2,,void
196717,BLOCK,-1,,<empty>,9,,387,2,,void
196740,BLOCK,-1,,"{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_FLUSH_SUBPICTURE,
                             channel);
}",1,,393,3,,void
196754,BLOCK,-1,,"{
    picture_t *picture = picture_pool_Wait(vout->p->decoder_pool);
    if (likely(picture != NULL)) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &vout->p->original);
    }
    return picture;
}",1,,408,2,,void
196769,BLOCK,-1,,"{
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &vout->p->original);
    }",34,,410,2,,void
196790,BLOCK,-1,,"{
    picture->p_next = NULL;
    if (picture_pool_OwnsPic(vout->p->decoder_pool, picture))
    {
        picture_fifo_Push(vout->p->decoder_fifo, picture);

        vout_control_Wake(&vout->p->control);
    }
    else
    {
        /* FIXME: HACK: Drop this picture because the vout changed. The old
         * picture pool need to be kept by the new vout. This requires a major
         * ""vout display"" API change. */
        picture_Release(picture);
    }
}",1,,426,3,,void
196804,BLOCK,-1,,"{
        picture_fifo_Push(vout->p->decoder_fifo, picture);

        vout_control_Wake(&vout->p->control);
    }",5,,429,2,,void
196820,BLOCK,-1,,"{
        /* FIXME: HACK: Drop this picture because the vout changed. The old
         * picture pool need to be kept by the new vout. This requires a major
         * ""vout display"" API change. */
        picture_Release(picture);
    }",5,,435,1,,void
196832,BLOCK,-1,,"{
    picture_t *picture = vout_snapshot_Get(&vout->p->snapshot, timeout);
    if (!picture) {
        msg_Err(vout, ""Failed to grab a snapshot"");
        return VLC_EGENERIC;
    }

    if (image_dst) {
        vlc_fourcc_t codec = VLC_CODEC_PNG;
        if (type && image_Type2Fourcc(type))
            codec = image_Type2Fourcc(type);

        const int override_width  = var_InheritInteger(vout, ""snapshot-width"");
        const int override_height = var_InheritInteger(vout, ""snapshot-height"");

        if (picture_Export(VLC_OBJECT(vout), image_dst, fmt,
                           picture, codec, override_width, override_height)) {
            msg_Err(vout, ""Failed to convert image for snapshot"");
            picture_Release(picture);
            return VLC_EGENERIC;
        }
    }
    if (picture_dst)
        *picture_dst = picture;
    else
        picture_Release(picture);
    return VLC_SUCCESS;
}",1,,448,7,,void
196847,BLOCK,-1,,"{
        msg_Err(vout, ""Failed to grab a snapshot"");
        return VLC_EGENERIC;
    }",19,,450,2,,void
196855,BLOCK,-1,,"{
        vlc_fourcc_t codec = VLC_CODEC_PNG;
        if (type && image_Type2Fourcc(type))
            codec = image_Type2Fourcc(type);

        const int override_width  = var_InheritInteger(vout, ""snapshot-width"");
        const int override_height = var_InheritInteger(vout, ""snapshot-height"");

        if (picture_Export(VLC_OBJECT(vout), image_dst, fmt,
                           picture, codec, override_width, override_height)) {
            msg_Err(vout, ""Failed to convert image for snapshot"");
            picture_Release(picture);
            return VLC_EGENERIC;
        }
    }",20,,455,2,,void
196865,BLOCK,-1,,<empty>,13,,458,2,,void
196892,BLOCK,-1,,"{
            msg_Err(vout, ""Failed to convert image for snapshot"");
            picture_Release(picture);
            return VLC_EGENERIC;
        }",78,,464,2,,void
196902,BLOCK,-1,,<empty>,9,,471,2,,void
196908,BLOCK,-1,,<empty>,9,,473,1,,void
196919,BLOCK,-1,,"{
    vout_ControlChangeSampleAspectRatio( p_vout, i_num, i_den );
}",1,,479,4,,void
196929,BLOCK,-1,,"{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_FULLSCREEN,
                          fullscreen);
}",1,,485,3,,void
196944,BLOCK,-1,,"{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_WINDOW_STATE, st);
}",1,,490,3,,void
196959,BLOCK,-1,,"{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_DISPLAY_FILLED,
                          is_filled);
}",1,,494,3,,void
196975,BLOCK,-1,,"{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ZOOM,
                          num, den);
}",1,,499,4,,void
196992,BLOCK,-1,,"{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ASPECT_RATIO,
                          num, den);
}",1,,505,4,,void
197009,BLOCK,-1,,"{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_CROP_RATIO,
                          num, den);
}",1,,511,4,,void
197028,BLOCK,-1,,"{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_WINDOW);
    cmd.u.window.x      = __MAX(x, 0);
    cmd.u.window.y      = __MAX(y, 0);
    cmd.u.window.width  = __MAX(width, 0);
    cmd.u.window.height = __MAX(height, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",1,,517,6,,void
197095,BLOCK,-1,,"{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_BORDER);
    cmd.u.border.left   = __MAX(left, 0);
    cmd.u.border.top    = __MAX(top, 0);
    cmd.u.border.right  = __MAX(right, 0);
    cmd.u.border.bottom = __MAX(bottom, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",1,,529,6,,void
197159,BLOCK,-1,,"{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_FILTERS,
                            filters);
}",1,,540,3,,void
197174,BLOCK,-1,,"{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_SOURCES,
                            filters);
}",1,,545,3,,void
197189,BLOCK,-1,,"{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_FILTERS,
                            filters);
}",1,,550,3,,void
197204,BLOCK,-1,,"{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_MARGIN,
                             margin);
}",1,,555,3,,void
197219,BLOCK,-1,,"{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_VIEWPOINT);
    cmd.u.viewpoint = *p_viewpoint;
    vout_control_Push(&vout->p->control, &cmd);
}",1,,562,3,,void
197248,BLOCK,-1,,"{
    /* Load configuration */
#if defined(_WIN32) || defined(__OS2__)
    cfg->is_fullscreen = var_GetBool(vout, ""fullscreen"")
                         || var_GetBool(vout, ""video-wallpaper"");
#endif
    cfg->viewpoint = vout->p->original.pose;

    cfg->display.title = title;
    const int display_width = var_GetInteger(vout, ""width"");
    const int display_height = var_GetInteger(vout, ""height"");
    cfg->display.width   = display_width > 0  ? display_width  : 0;
    cfg->display.height  = display_height > 0 ? display_height : 0;
    cfg->is_display_filled  = var_GetBool(vout, ""autoscale"");
    unsigned msar_num, msar_den;
    if (var_InheritURational(vout, &msar_num, &msar_den, ""monitor-par"") ||
        msar_num <= 0 || msar_den <= 0) {
        msar_num = 1;
        msar_den = 1;
    }
    cfg->display.sar.num = msar_num;
    cfg->display.sar.den = msar_den;
    unsigned zoom_den = 1000;
    unsigned zoom_num = zoom_den * var_GetFloat(vout, ""zoom"");
    vlc_ureduce(&zoom_num, &z...",1,,571,4,,void
197328,BLOCK,-1,,"{
        msar_num = 1;
        msar_den = 1;
    }",41,,587,2,,void
197411,BLOCK,-1,,<empty>,9,,602,2,,void
197420,BLOCK,-1,,<empty>,10,,603,1,,void
197425,BLOCK,-1,,<empty>,9,,604,2,,void
197437,BLOCK,-1,,<empty>,9,,606,2,,void
197446,BLOCK,-1,,<empty>,10,,607,1,,void
197451,BLOCK,-1,,<empty>,9,,608,2,,void
197464,BLOCK,-1,,"{
    vout_window_t *window = vout->p->window;

    assert(vout->p->splitter_name == NULL);

    if (window == NULL)
        return NULL;
    if (type != VOUT_WINDOW_TYPE_INVALID && type != window->type)
        return NULL;
    return window;
}",1,,612,3,,void
197485,BLOCK,-1,,<empty>,9,,618,2,,void
197498,BLOCK,-1,,<empty>,9,,620,2,,void
197508,BLOCK,-1,,"{
    if (window == NULL && vout->p->window != NULL) {
        vout_display_window_Delete(vout->p->window);
        vout->p->window = NULL;
    }
    assert(vout->p->window == window);
}",1,,625,3,,void
197521,BLOCK,-1,,"{
        vout_display_window_Delete(vout->p->window);
        vout->p->window = NULL;
    }",52,,626,2,,void
197549,BLOCK,-1,,"{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
    /* Request a resize of the window. If it fails, there is nothing to do.
     * If it succeeds, the window will emit a resize event later. */
        vout_window_SetSize(window, width, height);
    else
    if (vout->p->display.vd != NULL)
    /* Force a resize of window-less display. This is not allowed to fail,
     * although the display is allowed to ignore the size anyway. */
        /* FIXME: remove this, fix MSW and OS/2 window providers */
        vout_display_SendEventDisplaySize(vout->p->display.vd, width, height);
}",1,,635,4,,void
197562,BLOCK,-1,,<empty>,9,,641,2,,void
197568,BLOCK,-1,,<empty>,5,,643,1,,void
197579,BLOCK,-1,,<empty>,9,,647,2,,void
197595,BLOCK,-1,,"{
    vout_window_t *window = vout->p->window;

    return window != NULL ? vout_window_HideMouse(window, hide) : VLC_EGENERIC;
}",1,,651,3,,void
197621,BLOCK,-1,,"{
    (void) p_this; (void) psz_var; (void) oldval; (void) newval;
    vout_ControlChangeFilters((vout_thread_t *)p_data, NULL);
    return 0;
}",1,,661,6,,void
197646,BLOCK,-1,,"{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             FilterRestartCallback);
    return VLC_SUCCESS;
}",1,,668,3,,void
197659,BLOCK,-1,,"{
    assert(vout->p->filter.chain_interactive != NULL);
    filter_chain_ForEach(vout->p->filter.chain_interactive,
                         ThreadDelFilterCallbacks, vout);
}",1,,675,2,,void
197684,BLOCK,-1,,"{
    vout_thread_t *vout = filter->owner.sys;

    picture_t *picture = picture_pool_Get(vout->p->private_pool);
    if (picture) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &filter->fmt_out.video);
    }
    return picture;
}",1,,682,2,,void
197704,BLOCK,-1,,"{
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &filter->fmt_out.video);
    }",18,,686,2,,void
197724,BLOCK,-1,,"{
    vout_thread_t *vout = filter->owner.sys;

    vlc_assert_locked(&vout->p->filter.lock);
    if (filter_chain_IsEmpty(vout->p->filter.chain_interactive))
        return VoutVideoFilterInteractiveNewPicture(filter);

    return picture_NewFromFormat(&filter->fmt_out.video);
}",1,,694,2,,void
197751,BLOCK,-1,,<empty>,9,,699,2,,void
197768,BLOCK,-1,,"{
    if (vout->p->displayed.current)
        picture_Release( vout->p->displayed.current );
    vout->p->displayed.current = NULL;

    if (vout->p->displayed.next)
        picture_Release( vout->p->displayed.next );
    vout->p->displayed.next = NULL;

    if (!is_locked)
        vlc_mutex_lock(&vout->p->filter.lock);
    filter_chain_VideoFlush(vout->p->filter.chain_static);
    filter_chain_VideoFlush(vout->p->filter.chain_interactive);
    if (!is_locked)
        vlc_mutex_unlock(&vout->p->filter.lock);
}",1,,705,3,,void
197777,BLOCK,-1,,<empty>,9,,707,2,,void
197803,BLOCK,-1,,<empty>,9,,711,2,,void
197824,BLOCK,-1,,<empty>,9,,715,2,,void
197853,BLOCK,-1,,<empty>,9,,719,2,,void
197875,BLOCK,-1,,"{
    ThreadFilterFlush(vout, is_locked);
    ThreadDelAllFilterCallbacks(vout);

    vlc_array_t array_static;
    vlc_array_t array_interactive;

    vlc_array_init(&array_static);
    vlc_array_init(&array_interactive);

    if ((vout->p->filter.has_deint =
         deinterlace == 1 || (deinterlace == -1 && vout->p->filter.has_deint)))
    {
        vout_filter_t *e = malloc(sizeof(*e));

        if (likely(e))
        {
            free(config_ChainCreate(&e->name, &e->cfg, ""deinterlace""));
            vlc_array_append_or_abort(&array_static, e);
        }
    }

    char *current = filters ? strdup(filters) : NULL;
    while (current) {
        config_chain_t *cfg;
        char *name;
        char *next = config_ChainCreate(&name, &cfg, current);

        if (name && *name) {
            vout_filter_t *e = malloc(sizeof(*e));

            if (likely(e)) {
                e->name = name;
                e->cfg  = cfg;
                if (!strcmp(e->name, ""postproc""))
           ...",1,,732,6,,void
197914,BLOCK,-1,,"{
        vout_filter_t *e = malloc(sizeof(*e));

        if (likely(e))
        {
            free(config_ChainCreate(&e->name, &e->cfg, ""deinterlace""));
            vlc_array_append_or_abort(&array_static, e);
        }
    }",5,,744,2,,void
197925,BLOCK,-1,,"{
            free(config_ChainCreate(&e->name, &e->cfg, ""deinterlace""));
            vlc_array_append_or_abort(&array_static, e);
        }",9,,748,2,,void
197951,BLOCK,-1,,"{
        config_chain_t *cfg;
        char *name;
        char *next = config_ChainCreate(&name, &cfg, current);

        if (name && *name) {
            vout_filter_t *e = malloc(sizeof(*e));

            if (likely(e)) {
                e->name = name;
                e->cfg  = cfg;
                if (!strcmp(e->name, ""postproc""))
                    vlc_array_append_or_abort(&array_static, e);
                else
                    vlc_array_append_or_abort(&array_interactive, e);
            }
            else {
                if (cfg)
                    config_ChainDestroy(cfg);
                free(name);
            }
        } else {
            if (cfg)
                config_ChainDestroy(cfg);
            free(name);
        }
        free(current);
        current = next;
    }",21,,755,2,,void
197968,BLOCK,-1,,"{
            vout_filter_t *e = malloc(sizeof(*e));

            if (likely(e)) {
                e->name = name;
                e->cfg  = cfg;
                if (!strcmp(e->name, ""postproc""))
                    vlc_array_append_or_abort(&array_static, e);
                else
                    vlc_array_append_or_abort(&array_interactive, e);
            }
            else {
                if (cfg)
                    config_ChainDestroy(cfg);
                free(name);
            }
        }",28,,760,2,,void
197979,BLOCK,-1,,"{
                e->name = name;
                e->cfg  = cfg;
                if (!strcmp(e->name, ""postproc""))
                    vlc_array_append_or_abort(&array_static, e);
                else
                    vlc_array_append_or_abort(&array_interactive, e);
            }",28,,763,2,,void
197997,BLOCK,-1,,<empty>,21,,767,2,,void
198003,BLOCK,-1,,<empty>,21,,769,1,,void
198009,BLOCK,-1,,"{
                if (cfg)
                    config_ChainDestroy(cfg);
                free(name);
            }",18,,771,1,,void
198012,BLOCK,-1,,<empty>,21,,773,2,,void
198018,BLOCK,-1,,"{
            if (cfg)
                config_ChainDestroy(cfg);
            free(name);
        }",16,,776,1,,void
198021,BLOCK,-1,,<empty>,17,,778,2,,void
198034,BLOCK,-1,,<empty>,9,,786,2,,void
198065,BLOCK,-1,,<empty>,5,,793,1,,void
198075,BLOCK,4,,"{
        vlc_array_t    *array = a == 0 ? &array_static :
                                         &array_interactive;
        filter_chain_t *chain = a == 0 ? vout->p->filter.chain_static :
                                         vout->p->filter.chain_interactive;

        filter_chain_Reset(chain, p_fmt_current, p_fmt_current);
        for (size_t i = 0; i < vlc_array_count(array); i++) {
            vout_filter_t *e = vlc_array_item_at_index(array, i);
            msg_Dbg(vout, ""Adding '%s' as %s"", e->name, a == 0 ? ""static"" : ""interactive"");
            filter_t *filter = filter_chain_AppendFilter(chain, e->name, e->cfg,
                               NULL, NULL);
            if (!filter)
            {
                msg_Err(vout, ""Failed to add filter '%s'"", e->name);
                config_ChainDestroy(e->cfg);
            }
            else if (a == 1) /* Add callbacks for interactive filters */
                filter_AddProxyCallbacks(vout, filter, FilterRestartCallback);...",33,,793,4,,void
198113,BLOCK,-1,,<empty>,9,,800,1,,void
198124,BLOCK,4,,"{
            vout_filter_t *e = vlc_array_item_at_index(array, i);
            msg_Dbg(vout, ""Adding '%s' as %s"", e->name, a == 0 ? ""static"" : ""interactive"");
            filter_t *filter = filter_chain_AppendFilter(chain, e->name, e->cfg,
                               NULL, NULL);
            if (!filter)
            {
                msg_Err(vout, ""Failed to add filter '%s'"", e->name);
                config_ChainDestroy(e->cfg);
            }
            else if (a == 1) /* Add callbacks for interactive filters */
                filter_AddProxyCallbacks(vout, filter, FilterRestartCallback);

            free(e->name);
            free(e);
        }",61,,800,4,,void
198159,BLOCK,-1,,"{
                msg_Err(vout, ""Failed to add filter '%s'"", e->name);
                config_ChainDestroy(e->cfg);
            }",13,,806,2,,void
198171,BLOCK,-1,,<empty>,18,,810,1,,void
198176,BLOCK,-1,,<empty>,17,,811,2,,void
198199,BLOCK,-1,,"{
        msg_Dbg(vout, ""Adding a filter to compensate for format changes"");
        if (filter_chain_AppendConverter(vout->p->filter.chain_interactive,
                                         p_fmt_current, &fmt_target) != 0) {
            msg_Err(vout, ""Failed to compensate for the format changes, removing all filters"");
            ThreadDelAllFilterCallbacks(vout);
            filter_chain_Reset(vout->p->filter.chain_static,      &fmt_target, &fmt_target);
            filter_chain_Reset(vout->p->filter.chain_interactive, &fmt_target, &fmt_target);
        }
    }",59,,820,2,,void
198217,BLOCK,-1,,"{
            msg_Err(vout, ""Failed to compensate for the format changes, removing all filters"");
            ThreadDelAllFilterCallbacks(vout);
            filter_chain_Reset(vout->p->filter.chain_static,      &fmt_target, &fmt_target);
            filter_chain_Reset(vout->p->filter.chain_interactive, &fmt_target, &fmt_target);
        }",76,,823,2,,void
198260,BLOCK,-1,,"{
        free(vout->p->filter.configuration);
        vout->p->filter.configuration = filters ? strdup(filters) : NULL;
    }",51,,833,2,,void
198284,BLOCK,-1,,"{
        video_format_Clean(&vout->p->filter.format);
        video_format_Copy(&vout->p->filter.format, source);
    }",17,,837,2,,void
198307,BLOCK,-1,,<empty>,9,,843,2,,void
198323,BLOCK,-1,,"{
    bool is_late_dropped = vout->p->is_late_dropped && !vout->p->pause.is_on && !frame_by_frame;

    vlc_mutex_lock(&vout->p->filter.lock);

    picture_t *picture = filter_chain_VideoFilter(vout->p->filter.chain_static, NULL);
    assert(!reuse || !picture);

    while (!picture) {
        picture_t *decoded;
        if (reuse && vout->p->displayed.decoded) {
            decoded = picture_Hold(vout->p->displayed.decoded);
        } else {
            decoded = picture_fifo_Pop(vout->p->decoder_fifo);
            if (decoded) {
                if (is_late_dropped && !decoded->b_force) {
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                        late_threshold = VOUT_DISPLAY_LATE_THRESHOLD;
                    const mtime_t predicted ...",1,,849,4,,void
198374,BLOCK,-1,,"{
        picture_t *decoded;
        if (reuse && vout->p->displayed.decoded) {
            decoded = picture_Hold(vout->p->displayed.decoded);
        } else {
            decoded = picture_fifo_Pop(vout->p->decoder_fifo);
            if (decoded) {
                if (is_late_dropped && !decoded->b_force) {
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                        late_threshold = VOUT_DISPLAY_LATE_THRESHOLD;
                    const mtime_t predicted = mdate() + 0; /* TODO improve */
                    const mtime_t late = predicted - decoded->date;
                    if (late > late_threshold) {
                        msg_Warn(vout, ""picture is too late to be displayed (missing %""PRId64"" ms)"", late/1000);
                     ...",22,,857,2,,void
198386,BLOCK,-1,,"{
            decoded = picture_Hold(vout->p->displayed.decoded);
        }",50,,859,2,,void
198398,BLOCK,-1,,"{
            decoded = picture_fifo_Pop(vout->p->decoder_fifo);
            if (decoded) {
                if (is_late_dropped && !decoded->b_force) {
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                        late_threshold = VOUT_DISPLAY_LATE_THRESHOLD;
                    const mtime_t predicted = mdate() + 0; /* TODO improve */
                    const mtime_t late = predicted - decoded->date;
                    if (late > late_threshold) {
                        msg_Warn(vout, ""picture is too late to be displayed (missing %""PRId64"" ms)"", late/1000);
                        picture_Release(decoded);
                        vout_statistic_AddLost(&vout->p->statistic, 1);
                        continue;
                    } els...",16,,861,1,,void
198409,BLOCK,-1,,"{
                if (is_late_dropped && !decoded->b_force) {
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                        late_threshold = VOUT_DISPLAY_LATE_THRESHOLD;
                    const mtime_t predicted = mdate() + 0; /* TODO improve */
                    const mtime_t late = predicted - decoded->date;
                    if (late > late_threshold) {
                        msg_Warn(vout, ""picture is too late to be displayed (missing %""PRId64"" ms)"", late/1000);
                        picture_Release(decoded);
                        vout_statistic_AddLost(&vout->p->statistic, 1);
                        continue;
                    } else if (late > 0) {
                        msg_Dbg(vout, ""picture might be displayed late (...",26,,863,2,,void
198417,BLOCK,-1,,"{
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                        late_threshold = VOUT_DISPLAY_LATE_THRESHOLD;
                    const mtime_t predicted = mdate() + 0; /* TODO improve */
                    const mtime_t late = predicted - decoded->date;
                    if (late > late_threshold) {
                        msg_Warn(vout, ""picture is too late to be displayed (missing %""PRId64"" ms)"", late/1000);
                        picture_Release(decoded);
                        vout_statistic_AddLost(&vout->p->statistic, 1);
                        continue;
                    } else if (late > 0) {
                        msg_Dbg(vout, ""picture might be displayed late (missing %""PRId64"" ms)"", late/1000);
                    }
  ...",59,,864,2,,void
198431,BLOCK,-1,,<empty>,25,,867,2,,void
198450,BLOCK,-1,,<empty>,25,,869,1,,void
198454,BLOCK,1,,<empty>,,,,1,,void
198475,BLOCK,-1,,"{
                        msg_Warn(vout, ""picture is too late to be displayed (missing %""PRId64"" ms)"", late/1000);
                        picture_Release(decoded);
                        vout_statistic_AddLost(&vout->p->statistic, 1);
                        continue;
                    }",48,,872,2,,void
198489,BLOCK,-1,,<empty>,28,,877,1,,void
198494,BLOCK,-1,,"{
                        msg_Dbg(vout, ""picture might be displayed late (missing %""PRId64"" ms)"", late/1000);
                    }",42,,877,2,,void
198511,BLOCK,-1,,<empty>,21,,882,2,,void
198531,BLOCK,-1,,<empty>,13,,887,2,,void
198544,BLOCK,-1,,<empty>,13,,891,2,,void
198609,BLOCK,-1,,<empty>,9,,903,2,,void
198630,BLOCK,-1,,<empty>,9,,907,2,,void
198641,BLOCK,-1,,<empty>,9,,909,1,,void
198657,BLOCK,-1,,"{
    return picture_NewFromFormat(&filter->fmt_out.video);
}",1,,914,2,,void
198672,BLOCK,-1,,"{
    /* This function will convert the pic to RGB32 and blend the subpic to it.
     * The returned pic can't be used to display since the chroma will be
     * different than the ""vout display"" one, but it can be used for snapshots.
     * */

    assert(vout->p->spu_blend);

    filter_owner_t owner = {
        .video = {
            .buffer_new = ConvertRGB32AndBlendBufferNew,
        },
    };
    filter_chain_t *filterc = filter_chain_NewVideo(vout, false, &owner);
    if (!filterc)
        return NULL;

    es_format_t src = vout->p->spu_blend->fmt_out;
    es_format_t dst = src;
    dst.video.i_chroma = VLC_CODEC_RGB32;
    video_format_FixRgb(&dst.video);

    if (filter_chain_AppendConverter(filterc, &src, &dst) != 0)
    {
        filter_chain_Delete(filterc);
        return NULL;
    }

    picture_Hold(pic);
    pic = filter_chain_VideoFilter(filterc, pic);
    filter_chain_Delete(filterc);

    if (pic)
    {
        filter_t *swblend = filter_NewBlend(VLC_OBJECT(vout)...",1,,920,4,,void
198683,BLOCK,1,,<empty>,9,,929,1,,void
198687,BLOCK,1,,<empty>,13,,930,1,,void
198702,BLOCK,-1,,<empty>,9,,935,2,,void
198740,BLOCK,-1,,"{
        filter_chain_Delete(filterc);
        return NULL;
    }",5,,943,2,,void
198756,BLOCK,-1,,"{
        filter_t *swblend = filter_NewBlend(VLC_OBJECT(vout), &dst.video);
        if (swblend)
        {
            bool success = picture_BlendSubpicture(pic, swblend, subpic) > 0;
            filter_DeleteBlend(swblend);
            if (success)
                return pic;
        }
        picture_Release(pic);
    }",5,,953,2,,void
198769,BLOCK,-1,,"{
            bool success = picture_BlendSubpicture(pic, swblend, subpic) > 0;
            filter_DeleteBlend(swblend);
            if (success)
                return pic;
        }",9,,956,2,,void
198783,BLOCK,-1,,<empty>,17,,960,2,,void
198795,BLOCK,-1,,"{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = vout->p->display.vd;

    picture_t *torender = picture_Hold(vout->p->displayed.current);

    vout_chrono_Start(&vout->p->render);

    vlc_mutex_lock(&vout->p->filter.lock);
    picture_t *filtered = filter_chain_VideoFilter(vout->p->filter.chain_interactive, torender);
    vlc_mutex_unlock(&vout->p->filter.lock);

    if (!filtered)
        return VLC_EGENERIC;

    if (filtered->date != vout->p->displayed.current->date)
        msg_Warn(vout, ""Unsupported timestamp modifications done by chain_interactive"");

    /*
     * Get the subpicture to be displayed
     */
    const bool do_snapshot = vout_snapshot_IsRequested(&vout->p->snapshot);
    mtime_t render_subtitle_date;
    if (vout->p->pause.is_on)
        render_subtitle_date = vout->p->pause.date;
    else
        render_subtitle_date = filtered->date > 1 ? filtered->date : mdate();
    mtime_t render_osd_date = mdate(); /* FIXME wrong */

    /*
     * Get th...",1,,968,3,,void
198863,BLOCK,-1,,<empty>,9,,981,2,,void
198880,BLOCK,-1,,<empty>,9,,984,2,,void
198903,BLOCK,-1,,<empty>,9,,992,2,,void
198914,BLOCK,-1,,<empty>,9,,994,1,,void
199006,BLOCK,-1,,"{
        vout_display_place_t place;
        vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);

        fmt_spu = vd->source;
        if (fmt_spu.i_width * fmt_spu.i_height < place.width * place.height) {
            fmt_spu.i_sar_num = vd->cfg->display.sar.num;
            fmt_spu.i_sar_den = vd->cfg->display.sar.den;
            fmt_spu.i_width          =
            fmt_spu.i_visible_width  = place.width;
            fmt_spu.i_height         =
            fmt_spu.i_visible_height = place.height;
        }
        subpicture_chromas = vd->info.subpicture_chromas;
    }",20,,1017,2,,void
199040,BLOCK,-1,,"{
            fmt_spu.i_sar_num = vd->cfg->display.sar.num;
            fmt_spu.i_sar_den = vd->cfg->display.sar.den;
            fmt_spu.i_width          =
            fmt_spu.i_visible_width  = place.width;
            fmt_spu.i_height         =
            fmt_spu.i_visible_height = place.height;
        }",78,,1022,2,,void
199097,BLOCK,-1,,"{
        if (do_early_spu) {
            fmt_spu = vd->source;
        } else {
            fmt_spu = vd->fmt;
            fmt_spu.i_sar_num = vd->cfg->display.sar.num;
            fmt_spu.i_sar_den = vd->cfg->display.sar.den;
        }
        subpicture_chromas = NULL;

        if (vout->p->spu_blend &&
            vout->p->spu_blend->fmt_out.video.i_chroma != fmt_spu.i_chroma) {
            filter_DeleteBlend(vout->p->spu_blend);
            vout->p->spu_blend = NULL;
            vout->p->spu_blend_chroma = 0;
        }
        if (!vout->p->spu_blend && vout->p->spu_blend_chroma != fmt_spu.i_chroma) {
            vout->p->spu_blend_chroma = fmt_spu.i_chroma;
            vout->p->spu_blend = filter_NewBlend(VLC_OBJECT(vout), &fmt_spu);
            if (!vout->p->spu_blend)
                msg_Err(vout, ""Failed to create blending filter, OSD/Subtitles will not work"");
        }
    }",12,,1031,1,,void
199100,BLOCK,-1,,"{
            fmt_spu = vd->source;
        }",27,,1032,2,,void
199107,BLOCK,-1,,"{
            fmt_spu = vd->fmt;
            fmt_spu.i_sar_num = vd->cfg->display.sar.num;
            fmt_spu.i_sar_den = vd->cfg->display.sar.den;
        }",16,,1034,1,,void
199164,BLOCK,-1,,"{
            filter_DeleteBlend(vout->p->spu_blend);
            vout->p->spu_blend = NULL;
            vout->p->spu_blend_chroma = 0;
        }",77,,1042,2,,void
199202,BLOCK,-1,,"{
            vout->p->spu_blend_chroma = fmt_spu.i_chroma;
            vout->p->spu_blend = filter_NewBlend(VLC_OBJECT(vout), &fmt_spu);
            if (!vout->p->spu_blend)
                msg_Err(vout, ""Failed to create blending filter, OSD/Subtitles will not work"");
        }",83,,1047,2,,void
199230,BLOCK,-1,,<empty>,17,,1051,2,,void
199285,BLOCK,-1,,"{
        if (vout->p->spu_blend) {
            picture_t *blent = picture_pool_Get(vout->p->private_pool);
            if (blent) {
                VideoFormatCopyCropAr(&blent->format, &filtered->format);
                picture_Copy(blent, filtered);
                if (picture_BlendSubpicture(blent, vout->p->spu_blend, subpic)) {
                    picture_Release(todisplay);
                    snap_pic = todisplay = blent;
                } else
                {
                    /* Blending failed, likely because the picture is opaque or
                     * read-only. Try to convert the opaque picture to a
                     * software RGB32 one before blending it. */
                    if (do_snapshot)
                    {
                        picture_t *copy = ConvertRGB32AndBlend(vout, blent, subpic);
                        if (copy)
                            snap_pic = copy;
                    }
                    picture_Release(blent);
               ...",33,,1072,2,,void
199292,BLOCK,-1,,"{
            picture_t *blent = picture_pool_Get(vout->p->private_pool);
            if (blent) {
                VideoFormatCopyCropAr(&blent->format, &filtered->format);
                picture_Copy(blent, filtered);
                if (picture_BlendSubpicture(blent, vout->p->spu_blend, subpic)) {
                    picture_Release(todisplay);
                    snap_pic = todisplay = blent;
                } else
                {
                    /* Blending failed, likely because the picture is opaque or
                     * read-only. Try to convert the opaque picture to a
                     * software RGB32 one before blending it. */
                    if (do_snapshot)
                    {
                        picture_t *copy = ConvertRGB32AndBlend(vout, blent, subpic);
                        if (copy)
                            snap_pic = copy;
                    }
                    picture_Release(blent);
                }
            }
        }",33,,1073,2,,void
199304,BLOCK,-1,,"{
                VideoFormatCopyCropAr(&blent->format, &filtered->format);
                picture_Copy(blent, filtered);
                if (picture_BlendSubpicture(blent, vout->p->spu_blend, subpic)) {
                    picture_Release(todisplay);
                    snap_pic = todisplay = blent;
                } else
                {
                    /* Blending failed, likely because the picture is opaque or
                     * read-only. Try to convert the opaque picture to a
                     * software RGB32 one before blending it. */
                    if (do_snapshot)
                    {
                        picture_t *copy = ConvertRGB32AndBlend(vout, blent, subpic);
                        if (copy)
                            snap_pic = copy;
                    }
                    picture_Release(blent);
                }
            }",24,,1075,2,,void
199326,BLOCK,-1,,"{
                    picture_Release(todisplay);
                    snap_pic = todisplay = blent;
                }",81,,1078,2,,void
199335,BLOCK,-1,,"{
                    /* Blending failed, likely because the picture is opaque or
                     * read-only. Try to convert the opaque picture to a
                     * software RGB32 one before blending it. */
                    if (do_snapshot)
                    {
                        picture_t *copy = ConvertRGB32AndBlend(vout, blent, subpic);
                        if (copy)
                            snap_pic = copy;
                    }
                    picture_Release(blent);
                }",17,,1082,1,,void
199338,BLOCK,-1,,"{
                        picture_t *copy = ConvertRGB32AndBlend(vout, blent, subpic);
                        if (copy)
                            snap_pic = copy;
                    }",21,,1087,2,,void
199348,BLOCK,-1,,<empty>,29,,1090,2,,void
199378,BLOCK,-1,,"{
        picture_t *direct = NULL;
        if (likely(vout->p->display_pool != NULL))
            direct = picture_pool_Get(vout->p->display_pool);
        if (!direct) {
            picture_Release(todisplay);
            if (subpic)
                subpicture_Delete(subpic);
            return VLC_EGENERIC;
        }

        /* The display uses direct rendering (no conversion), but its pool of
         * pictures is not usable by the decoder (too few, too slow or
         * subject to invalidation...). Since there are no filters, copying
         * pictures from the decoder to the output is unavoidable. */
        VideoFormatCopyCropAr(&direct->format, &todisplay->format);
        picture_Copy(direct, todisplay);
        picture_Release(todisplay);
        snap_pic = todisplay = direct;
    }",44,,1101,2,,void
199392,BLOCK,-1,,<empty>,13,,1104,2,,void
199404,BLOCK,-1,,"{
            picture_Release(todisplay);
            if (subpic)
                subpicture_Delete(subpic);
            return VLC_EGENERIC;
        }",22,,1105,2,,void
199409,BLOCK,-1,,<empty>,17,,1108,2,,void
199435,BLOCK,-1,,"{
        assert(snap_pic);
        vout_snapshot_Set(&vout->p->snapshot, &vd->source, snap_pic);
        if (snap_pic != todisplay)
            picture_Release(snap_pic);
    }",5,,1126,2,,void
199454,BLOCK,-1,,<empty>,13,,1130,2,,void
199472,BLOCK,-1,,"{
        if (subpic != NULL)
            subpicture_Delete(subpic);
        return VLC_EGENERIC;
    }",28,,1137,2,,void
199477,BLOCK,-1,,<empty>,13,,1139,2,,void
199488,BLOCK,-1,,"{
        vout_display_Prepare(vd, todisplay, subpic);
    }",30,,1143,2,,void
199494,BLOCK,-1,,"{
        if (!do_dr_spu && !do_early_spu && vout->p->spu_blend && subpic)
            picture_BlendSubpicture(todisplay, vout->p->spu_blend, subpic);
        vout_display_Prepare(vd, todisplay, do_dr_spu ? subpic : NULL);

        if (!do_dr_spu && subpic)
        {
            subpicture_Delete(subpic);
            subpic = NULL;
        }
    }",12,,1145,1,,void
199509,BLOCK,-1,,<empty>,13,,1147,2,,void
199530,BLOCK,-1,,"{
            subpicture_Delete(subpic);
            subpic = NULL;
        }",9,,1151,2,,void
199546,BLOCK,-1,,<empty>,9,,1174,2,,void
199579,BLOCK,-1,,"{
    bool frame_by_frame = !deadline;
    bool paused = vout->p->pause.is_on;
    bool first = !vout->p->displayed.current;

    if (first)
        if (ThreadDisplayPreparePicture(vout, true, frame_by_frame)) /* FIXME not sure it is ok */
            return VLC_EGENERIC;

    if (!paused || frame_by_frame)
        while (!vout->p->displayed.next && !ThreadDisplayPreparePicture(vout, false, frame_by_frame))
            ;

    const mtime_t date = mdate();
    const mtime_t render_delay = vout_chrono_GetHigh(&vout->p->render) + VOUT_MWAIT_TOLERANCE;

    bool drop_next_frame = frame_by_frame;
    mtime_t date_next = VLC_TS_INVALID;
    if (!paused && vout->p->displayed.next) {
        date_next = vout->p->displayed.next->date - render_delay;
        if (date_next /* + 0 FIXME */ <= date)
            drop_next_frame = true;
    }

    /* FIXME/XXX we must redisplay the last decoded picture (because
     * of potential vout updated, or filters update or SPU update)
     * For now a hig...",1,,1186,3,,void
199608,BLOCK,-1,,<empty>,9,,1192,2,,void
199614,BLOCK,-1,,<empty>,13,,1193,2,,void
199622,BLOCK,-1,,<empty>,9,,1196,2,,void
199654,BLOCK,1,,<empty>,,,,1,,void
199676,BLOCK,-1,,"{
        date_next = vout->p->displayed.next->date - render_delay;
        if (date_next /* + 0 FIXME */ <= date)
            drop_next_frame = true;
    }",45,,1204,2,,void
199694,BLOCK,-1,,<empty>,13,,1207,2,,void
199716,BLOCK,-1,,"{
        date_refresh = vout->p->displayed.date + VOUT_REDISPLAY_DELAY - render_delay;
        refresh = date_refresh <= date;
    }",51,,1222,2,,void
199729,BLOCK,1,,<empty>,,,,1,,void
199748,BLOCK,-1,,"{
        if (date_refresh != VLC_TS_INVALID)
            *deadline = date_refresh;
        if (date_next != VLC_TS_INVALID && date_next < *deadline)
            *deadline = date_next;
    }",26,,1228,2,,void
199753,BLOCK,-1,,<empty>,13,,1230,2,,void
199767,BLOCK,-1,,<empty>,13,,1232,2,,void
199781,BLOCK,-1,,"{
        return VLC_EGENERIC;
    }",49,,1235,2,,void
199786,BLOCK,-1,,"{
        picture_Release(vout->p->displayed.current);
        vout->p->displayed.current = vout->p->displayed.next;
        vout->p->displayed.next    = NULL;
    }",26,,1239,2,,void
199828,BLOCK,-1,,<empty>,9,,1246,2,,void
199863,BLOCK,-1,,"{
    spu_PutSubpicture(vout->p->spu, subpicture);
}",1,,1256,3,,void
199876,BLOCK,-1,,"{
    spu_ClearChannel(vout->p->spu, channel);
}",1,,1261,3,,void
199889,BLOCK,-1,,"{
    if (!vout->p->title.show)
        return;

    vout_OSDText(vout, VOUT_SPU_CHANNEL_OSD,
                 vout->p->title.position, INT64_C(1000) * vout->p->title.timeout,
                 string);
}",1,,1266,3,,void
199899,BLOCK,-1,,<empty>,9,,1268,2,,void
199927,BLOCK,-1,,"{
    spu_ChangeSources(vout->p->spu, filters);
}",1,,1276,3,,void
199940,BLOCK,-1,,"{
    spu_ChangeFilters(vout->p->spu, filters);
}",1,,1281,3,,void
199953,BLOCK,-1,,"{
    spu_ChangeMargin(vout->p->spu, margin);
}",1,,1286,3,,void
199967,BLOCK,-1,,"{
    assert(!vout->p->pause.is_on || !is_paused);

    if (vout->p->pause.is_on) {
        const mtime_t duration = date - vout->p->pause.date;

        if (vout->p->step.timestamp > VLC_TS_INVALID)
            vout->p->step.timestamp += duration;
        if (vout->p->step.last > VLC_TS_INVALID)
            vout->p->step.last += duration;
        picture_fifo_OffsetDate(vout->p->decoder_fifo, duration);
        if (vout->p->displayed.decoded)
            vout->p->displayed.decoded->date += duration;
        spu_OffsetSubtitleDate(vout->p->spu, duration);

        ThreadFilterFlush(vout, false);
    } else {
        vout->p->step.timestamp = VLC_TS_INVALID;
        vout->p->step.last      = VLC_TS_INVALID;
    }
    vout->p->pause.is_on = is_paused;
    vout->p->pause.date  = date;

    vout_window_t *window = vout->p->window;
    if (window != NULL)
        vout_window_SetInhibition(window, !is_paused);
}",1,,1291,4,,void
199988,BLOCK,-1,,"{
        const mtime_t duration = date - vout->p->pause.date;

        if (vout->p->step.timestamp > VLC_TS_INVALID)
            vout->p->step.timestamp += duration;
        if (vout->p->step.last > VLC_TS_INVALID)
            vout->p->step.last += duration;
        picture_fifo_OffsetDate(vout->p->decoder_fifo, duration);
        if (vout->p->displayed.decoded)
            vout->p->displayed.decoded->date += duration;
        spu_OffsetSubtitleDate(vout->p->spu, duration);

        ThreadFilterFlush(vout, false);
    }",31,,1294,2,,void
200011,BLOCK,-1,,<empty>,13,,1298,2,,void
200031,BLOCK,-1,,<empty>,13,,1300,2,,void
200056,BLOCK,-1,,<empty>,13,,1303,2,,void
200079,BLOCK,-1,,"{
        vout->p->step.timestamp = VLC_TS_INVALID;
        vout->p->step.last      = VLC_TS_INVALID;
    }",12,,1307,1,,void
200128,BLOCK,-1,,<empty>,9,,1316,2,,void
200139,BLOCK,-1,,"{
    vout->p->step.timestamp = VLC_TS_INVALID;
    vout->p->step.last      = VLC_TS_INVALID;

    ThreadFilterFlush(vout, false); /* FIXME too much */

    picture_t *last = vout->p->displayed.decoded;
    if (last) {
        if (( below && last->date <= date) ||
            (!below && last->date >= date)) {
            picture_Release(last);

            vout->p->displayed.decoded   = NULL;
            vout->p->displayed.date      = VLC_TS_INVALID;
            vout->p->displayed.timestamp = VLC_TS_INVALID;
        }
    }

    picture_fifo_Flush(vout->p->decoder_fifo, date, below);
    vout_FilterFlush(vout->p->display.vd);
}",1,,1320,4,,void
200173,BLOCK,-1,,"{
        if (( below && last->date <= date) ||
            (!below && last->date >= date)) {
            picture_Release(last);

            vout->p->displayed.decoded   = NULL;
            vout->p->displayed.date      = VLC_TS_INVALID;
            vout->p->displayed.timestamp = VLC_TS_INVALID;
        }
    }",15,,1327,2,,void
200191,BLOCK,-1,,"{
            picture_Release(last);

            vout->p->displayed.decoded   = NULL;
            vout->p->displayed.date      = VLC_TS_INVALID;
            vout->p->displayed.timestamp = VLC_TS_INVALID;
        }",45,,1329,2,,void
200242,BLOCK,-1,,"{
    *duration = 0;

    if (vout->p->step.last <= VLC_TS_INVALID)
        vout->p->step.last = vout->p->displayed.timestamp;

    if (ThreadDisplayPicture(vout, NULL))
        return;

    vout->p->step.timestamp = vout->p->displayed.timestamp;

    if (vout->p->step.last > VLC_TS_INVALID &&
        vout->p->step.timestamp > vout->p->step.last) {
        *duration = vout->p->step.timestamp - vout->p->step.last;
        vout->p->step.last = vout->p->step.timestamp;
        /* TODO advance subpicture by the duration ... */
    }
}",1,,1343,3,,void
200257,BLOCK,-1,,<empty>,9,,1347,2,,void
200277,BLOCK,-1,,<empty>,9,,1350,2,,void
200320,BLOCK,-1,,"{
        *duration = vout->p->step.timestamp - vout->p->step.last;
        vout->p->step.last = vout->p->step.timestamp;
        /* TODO advance subpicture by the duration ... */
    }",55,,1355,2,,void
200359,BLOCK,-1,,"{
    vout_window_t *window = vout->p->window;

#if !defined(_WIN32) && !defined(__OS2__)
    if (window != NULL)
        vout_window_SetFullScreen(window, fullscreen);
#else
    bool window_fullscreen = false;
    if (window != NULL
     && vout_window_SetFullScreen(window, fullscreen) == VLC_SUCCESS)
        window_fullscreen = true;
    /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendEventFullscreen(vout->p->display.vd, fullscreen, window_fullscreen);
#endif
}",1,,1363,3,,void
200372,BLOCK,-1,,<empty>,9,,1368,2,,void
200381,BLOCK,-1,,"{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
        vout_window_SetState(window, state);
#if defined(_WIN32) || defined(__OS2__)
    else /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendWindowState(vout->p->display.vd, state);
#endif
}",1,,1381,3,,void
200394,BLOCK,-1,,<empty>,9,,1385,2,,void
200403,BLOCK,-1,,"{
    vout_display_t *vd = vout->p->display.vd;
    switch (mouse->type)
    {
        case VOUT_WINDOW_MOUSE_STATE:
        case VOUT_WINDOW_MOUSE_MOVED:
        {
            vout_display_place_t place;
            vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);

            if (place.width <= 0 || place.height <= 0)
                return;

            const int x = vd->source.i_x_offset +
                (int64_t)(mouse->x - place.x) *
                vd->source.i_visible_width / place.width;
            const int y = vd->source.i_y_offset +
                (int64_t)(mouse->y - place.y) *
                vd->source.i_visible_height/ place.height;

            if (mouse->type == VOUT_WINDOW_MOUSE_STATE)
                vout_display_SendEventMouseState(vd, x, y, mouse->button_mask);
            else
                vout_display_SendEventMouseMoved(vd, x, y);
            break;
        }
        case VOUT_WINDOW_MOUSE_PRESSED:
            vout_display_SendEventMouse...",1,,1395,3,,void
200418,BLOCK,-1,,"{
        case VOUT_WINDOW_MOUSE_STATE:
        case VOUT_WINDOW_MOUSE_MOVED:
        {
            vout_display_place_t place;
            vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);

            if (place.width <= 0 || place.height <= 0)
                return;

            const int x = vd->source.i_x_offset +
                (int64_t)(mouse->x - place.x) *
                vd->source.i_visible_width / place.width;
            const int y = vd->source.i_y_offset +
                (int64_t)(mouse->y - place.y) *
                vd->source.i_visible_height/ place.height;

            if (mouse->type == VOUT_WINDOW_MOUSE_STATE)
                vout_display_SendEventMouseState(vd, x, y, mouse->button_mask);
            else
                vout_display_SendEventMouseMoved(vd, x, y);
            break;
        }
        case VOUT_WINDOW_MOUSE_PRESSED:
            vout_display_SendEventMousePressed(vd, mouse->button_mask);
            break;
        case VOUT_WINDOW_...",5,,1398,2,,void
200423,BLOCK,5,,"{
            vout_display_place_t place;
            vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);

            if (place.width <= 0 || place.height <= 0)
                return;

            const int x = vd->source.i_x_offset +
                (int64_t)(mouse->x - place.x) *
                vd->source.i_visible_width / place.width;
            const int y = vd->source.i_y_offset +
                (int64_t)(mouse->y - place.y) *
                vd->source.i_visible_height/ place.height;

            if (mouse->type == VOUT_WINDOW_MOUSE_STATE)
                vout_display_SendEventMouseState(vd, x, y, mouse->button_mask);
            else
                vout_display_SendEventMouseMoved(vd, x, y);
            break;
        }",9,,1401,5,,void
200448,BLOCK,-1,,<empty>,17,,1406,2,,void
200510,BLOCK,-1,,<empty>,17,,1416,2,,void
200519,BLOCK,-1,,<empty>,17,,1418,1,,void
200549,BLOCK,-1,,<empty>,17,,1429,2,,void
200561,BLOCK,-1,,"{
    vout_SetDisplayFilled(vout->p->display.vd, is_filled);
}",1,,1437,3,,void
200577,BLOCK,-1,,"{
    if (num * 10 < den) {
        num = den;
        den *= 10;
    } else if (num > den * 10) {
        num = den * 10;
    }

    vout_SetDisplayZoom(vout->p->display.vd, num, den);
}",1,,1442,4,,void
200584,BLOCK,-1,,"{
        num = den;
        den *= 10;
    }",25,,1443,2,,void
200592,BLOCK,-1,,<empty>,12,,1446,1,,void
200599,BLOCK,-1,,"{
        num = den * 10;
    }",32,,1446,2,,void
200621,BLOCK,-1,,"{
    vout_SetDisplayAspect(vout->p->display.vd, num, den);
}",1,,1455,4,,void
200640,BLOCK,-1,,"{
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        x, y, width, height);
}",1,,1463,6,,void
200663,BLOCK,-1,,"{
    msg_Dbg(vout, ""ThreadExecuteCropBorder %d.%d %dx%d"", left, top, right, bottom);
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        left, top, -(int)right, -(int)bottom);
}",1,,1470,6,,void
200697,BLOCK,-1,,"{
    vout_SetDisplayCrop(vout->p->display.vd, num, den,
                        0, 0, 0, 0);
}",1,,1478,4,,void
200717,BLOCK,-1,,"{
    vout_SetDisplayViewpoint(vout->p->display.vd, p_viewpoint);
}",1,,1485,3,,void
200732,BLOCK,-1,,"{
    vlc_mouse_Init(&vout->p->mouse);
    vout->p->decoder_fifo = picture_fifo_New();
    vout->p->decoder_pool = NULL;
    vout->p->display_pool = NULL;
    vout->p->private_pool = NULL;

    vout->p->filter.configuration = NULL;
    video_format_Copy(&vout->p->filter.format, &vout->p->original);

    filter_owner_t owner = {
        .sys = vout,
        .video = {
            .buffer_new = VoutVideoFilterStaticNewPicture,
        },
    };
    vout->p->filter.chain_static =
        filter_chain_NewVideo( vout, true, &owner );

    owner.video.buffer_new = VoutVideoFilterInteractiveNewPicture;
    vout->p->filter.chain_interactive =
        filter_chain_NewVideo( vout, true, &owner );

    vout_display_state_t state_default;
    if (!state) {
        VoutGetDisplayCfg(vout, &state_default.cfg, vout->p->display.title);

#if defined(_WIN32) || defined(__OS2__)
        bool below = var_InheritBool(vout, ""video-wallpaper"");
        bool above = var_InheritBool(vout, ""video-on-top"");

...",1,,1490,3,,void
200796,BLOCK,1,,<empty>,9,,1501,1,,void
200800,BLOCK,2,,<empty>,9,,1502,2,,void
200804,BLOCK,1,,<empty>,13,,1503,1,,void
200845,BLOCK,-1,,"{
        VoutGetDisplayCfg(vout, &state_default.cfg, vout->p->display.title);

#if defined(_WIN32) || defined(__OS2__)
        bool below = var_InheritBool(vout, ""video-wallpaper"");
        bool above = var_InheritBool(vout, ""video-on-top"");

        state_default.wm_state = below ? VOUT_WINDOW_STATE_BELOW
                               : above ? VOUT_WINDOW_STATE_ABOVE
                               : VOUT_WINDOW_STATE_NORMAL;
#endif
        state_default.sar.num = 0;
        state_default.sar.den = 0;

        state = &state_default;
    }",17,,1514,2,,void
200886,BLOCK,-1,,<empty>,9,,1532,2,,void
200891,BLOCK,-1,,"{
        vout_CloseWrapper(vout, state);
        goto error;
    }",5,,1534,2,,void
201017,BLOCK,-1,,"{
        ThreadDelAllFilterCallbacks(vout);
        filter_chain_Delete(vout->p->filter.chain_interactive);
    }",5,,1557,2,,void
201038,BLOCK,-1,,<empty>,9,,1562,2,,void
201064,BLOCK,-1,,<empty>,9,,1565,2,,void
201078,BLOCK,-1,,"{
    if (vout->p->spu_blend)
        filter_DeleteBlend(vout->p->spu_blend);

    /* Destroy translation tables */
    if (vout->p->display.vd) {
        if (vout->p->decoder_pool) {
            ThreadFlush(vout, true, INT64_MAX);
            vout_EndWrapper(vout);
        }
        vout_CloseWrapper(vout, state);
    }

    /* Destroy the video filters */
    ThreadDelAllFilterCallbacks(vout);
    filter_chain_Delete(vout->p->filter.chain_interactive);
    filter_chain_Delete(vout->p->filter.chain_static);
    video_format_Clean(&vout->p->filter.format);
    free(vout->p->filter.configuration);

    if (vout->p->decoder_fifo)
        picture_fifo_Delete(vout->p->decoder_fifo);
    assert(!vout->p->decoder_pool);
}",1,,1570,3,,void
201085,BLOCK,-1,,<empty>,9,,1572,2,,void
201100,BLOCK,-1,,"{
        if (vout->p->decoder_pool) {
            ThreadFlush(vout, true, INT64_MAX);
            vout_EndWrapper(vout);
        }
        vout_CloseWrapper(vout, state);
    }",30,,1575,2,,void
201107,BLOCK,-1,,"{
            ThreadFlush(vout, true, INT64_MAX);
            vout_EndWrapper(vout);
        }",36,,1576,2,,void
201158,BLOCK,-1,,<empty>,9,,1591,2,,void
201176,BLOCK,-1,,"{
    vout->p->dead            = false;
    vout->p->is_late_dropped = var_InheritBool(vout, ""drop-late-frames"");
    vout->p->pause.is_on     = false;
    vout->p->pause.date      = VLC_TS_INVALID;

    vout_chrono_Init(&vout->p->render, 5, 10000); /* Arbitrary initial time */
}",1,,1596,2,,void
201224,BLOCK,-1,,"{
    vout_chrono_Clean(&vout->p->render);
    vout->p->dead = true;
    vout_control_Dead(&vout->p->control);
}",1,,1606,2,,void
201251,BLOCK,-1,,"{
    video_format_t original;

    vout->p->pause.is_on = false;
    vout->p->pause.date  = VLC_TS_INVALID;

    if (VoutValidateFormat(&original, cfg->fmt)) {
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return VLC_EGENERIC;
    }

    /* We ignore ar changes at this point, they are dynamically supported.
     * #19268: don't ignore crop changes (fix vouts using the crop size of the
     * previous format). */
    vout->p->original.i_sar_num = original.i_sar_num;
    vout->p->original.i_sar_den = original.i_sar_den;
    if (video_format_IsSimilar(&original, &vout->p->original)) {
        if (cfg->dpb_size <= vout->p->dpb_size) {
            video_format_Clean(&original);
            return VLC_SUCCESS;
        }
        msg_Warn(vout, ""DPB need to be increased"");
    }

    vout_display_state_t state;
    memset(&state, 0, sizeof(state));

    ThreadStop(vout, &state);

    vout_ReinitInterlacingSupport(vout);

#if defined(_WIN32) || defined(__OS2__)
    if (...",1,,1614,3,,void
201278,BLOCK,-1,,"{
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return VLC_EGENERIC;
    }",50,,1620,2,,void
201318,BLOCK,-1,,"{
        if (cfg->dpb_size <= vout->p->dpb_size) {
            video_format_Clean(&original);
            return VLC_SUCCESS;
        }
        msg_Warn(vout, ""DPB need to be increased"");
    }",64,,1631,2,,void
201329,BLOCK,-1,,"{
            video_format_Clean(&original);
            return VLC_SUCCESS;
        }",49,,1632,2,,void
201351,BLOCK,12,,"{
        state.cfg.display.width  = 0;
        state.cfg.display.height = 0;
    }",5,,1649,12,,void
201408,BLOCK,-1,,"{
        state.cfg.display.sar.num = 1;
        state.cfg.display.sar.den = 1;
    }",75,,1658,2,,void
201451,BLOCK,-1,,"{
        state.cfg.zoom.num = 1;
        state.cfg.zoom.den = 1;
    }",61,,1662,2,,void
201491,BLOCK,-1,,"{
        ThreadClean(vout);
        return VLC_EGENERIC;
    }",36,,1669,2,,void
201503,BLOCK,-1,,"{
    picture_pool_Cancel(vout->p->decoder_pool, canceled);
}",1,,1677,3,,void
201516,BLOCK,-1,,"{
    switch(cmd.type) {
    case VOUT_CONTROL_INIT:
        ThreadInit(vout);
        if (ThreadStart(vout, NULL))
        {
            ThreadClean(vout);
            return 1;
        }
        break;
    case VOUT_CONTROL_CLEAN:
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return 1;
    case VOUT_CONTROL_REINIT:
        if (ThreadReinit(vout, cmd.u.cfg))
            return 1;
        break;
    case VOUT_CONTROL_CANCEL:
        ThreadCancel(vout, cmd.u.boolean);
        break;
    case VOUT_CONTROL_SUBPICTURE:
        ThreadDisplaySubpicture(vout, cmd.u.subpicture);
        cmd.u.subpicture = NULL;
        break;
    case VOUT_CONTROL_FLUSH_SUBPICTURE:
        ThreadFlushSubpicture(vout, cmd.u.integer);
        break;
    case VOUT_CONTROL_OSD_TITLE:
        ThreadDisplayOsdTitle(vout, cmd.u.string);
        break;
    case VOUT_CONTROL_CHANGE_FILTERS:
        ThreadChangeFilters(vout, NULL,
                            cmd.u.string != NULL ?
               ...",1,,1682,3,,void
201521,BLOCK,-1,,"{
    case VOUT_CONTROL_INIT:
        ThreadInit(vout);
        if (ThreadStart(vout, NULL))
        {
            ThreadClean(vout);
            return 1;
        }
        break;
    case VOUT_CONTROL_CLEAN:
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return 1;
    case VOUT_CONTROL_REINIT:
        if (ThreadReinit(vout, cmd.u.cfg))
            return 1;
        break;
    case VOUT_CONTROL_CANCEL:
        ThreadCancel(vout, cmd.u.boolean);
        break;
    case VOUT_CONTROL_SUBPICTURE:
        ThreadDisplaySubpicture(vout, cmd.u.subpicture);
        cmd.u.subpicture = NULL;
        break;
    case VOUT_CONTROL_FLUSH_SUBPICTURE:
        ThreadFlushSubpicture(vout, cmd.u.integer);
        break;
    case VOUT_CONTROL_OSD_TITLE:
        ThreadDisplayOsdTitle(vout, cmd.u.string);
        break;
    case VOUT_CONTROL_CHANGE_FILTERS:
        ThreadChangeFilters(vout, NULL,
                            cmd.u.string != NULL ?
                            cmd.u.stri...",22,,1683,2,,void
201530,BLOCK,-1,,"{
            ThreadClean(vout);
            return 1;
        }",9,,1687,2,,void
201555,BLOCK,-1,,<empty>,13,,1698,2,,void
201913,BLOCK,-1,,"{
    vout_thread_t *vout = object;
    vout_thread_sys_t *sys = vout->p;

    mtime_t deadline = VLC_TS_INVALID;
    bool wait = false;
    for (;;) {
        vout_control_cmd_t cmd;

        if (wait)
        {
            const mtime_t max_deadline = mdate() + 100000;
            deadline = deadline <= VLC_TS_INVALID ? max_deadline : __MIN(deadline, max_deadline);
        } else {
            deadline = VLC_TS_INVALID;
        }
        while (!vout_control_Pop(&sys->control, &cmd, deadline))
            if (ThreadControl(vout, cmd))
                return NULL;

        deadline = VLC_TS_INVALID;
        wait = ThreadDisplayPicture(vout, &deadline) != VLC_SUCCESS;

        const bool picture_interlaced = sys->displayed.is_interlaced;

        vout_SetInterlacingState(vout, picture_interlaced);
        vout_ManageWrapper(vout);
    }
}",1,,1790,2,,void
201933,BLOCK,-1,,<empty>,5,,1796,1,,void
201934,BLOCK,4,,"{
        vout_control_cmd_t cmd;

        if (wait)
        {
            const mtime_t max_deadline = mdate() + 100000;
            deadline = deadline <= VLC_TS_INVALID ? max_deadline : __MIN(deadline, max_deadline);
        } else {
            deadline = VLC_TS_INVALID;
        }
        while (!vout_control_Pop(&sys->control, &cmd, deadline))
            if (ThreadControl(vout, cmd))
                return NULL;

        deadline = VLC_TS_INVALID;
        wait = ThreadDisplayPicture(vout, &deadline) != VLC_SUCCESS;

        const bool picture_interlaced = sys->displayed.is_interlaced;

        vout_SetInterlacingState(vout, picture_interlaced);
        vout_ManageWrapper(vout);
    }",14,,1796,4,,void
201938,BLOCK,-1,,"{
            const mtime_t max_deadline = mdate() + 100000;
            deadline = deadline <= VLC_TS_INVALID ? max_deadline : __MIN(deadline, max_deadline);
        }",9,,1800,2,,void
201956,BLOCK,-1,,"{
            deadline = VLC_TS_INVALID;
        }",16,,1803,1,,void
201974,BLOCK,-1,,<empty>,17,,1808,2,,void
202017,BLOCK,-1,,<empty>,1,,1,1,,ANY
202028,BLOCK,-1,,"{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if( !has_dst_changed )
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",1,,43,7,,void
202042,BLOCK,-1,,<empty>,9,,49,2,,void
202054,BLOCK,-1,,"{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    if( fmt_dst->i_sar_num <= 0 || fmt_dst->i_sar_den <= 0 )
        return;

    subpic->b_absolute = false;
    subpic->i_original_picture_width  = fmt_dst->i_visible_width * fmt_dst->i_sar_num / fmt_dst->i_sar_den;
    subpic->i_original_picture_height = fmt_dst->i_visible_height;

    video_format_t fmt;
    video_format_Init( &fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    subpicture_region_t *r = subpic->p_region = subpicture_region_New(&fmt);
    if (!r)
        return;

    r->p_text = text_segment_New( sys->text );

    const float margin_ratio = 0.04;
    const int   margin_h     = margin_ratio * fmt_dst->i_visible_width;
    const int   margin_v     = margin_ratio * fmt_dst->i_visible_height;

    r->i_text_align = sys->position;
    r->i_align = sys->position;
    r->i_x = 0;
    if (r->i_align & SUBPICTURE_ALIGN_LEFT)
        r->i_x += margin_...",1,,57,5,,void
202079,BLOCK,-1,,<empty>,9,,62,2,,void
202136,BLOCK,-1,,<empty>,9,,75,2,,void
202191,BLOCK,-1,,<empty>,9,,87,2,,void
202202,BLOCK,-1,,<empty>,10,,88,1,,void
202209,BLOCK,-1,,<empty>,9,,89,2,,void
202230,BLOCK,-1,,<empty>,9,,93,2,,void
202241,BLOCK,-1,,<empty>,10,,94,1,,void
202248,BLOCK,-1,,<empty>,9,,95,2,,void
202262,BLOCK,-1,,"{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;

    free(sys->text);
    free(sys);
}",1,,99,2,,void
202285,BLOCK,-1,,"{
    assert( (position & ~SUBPICTURE_ALIGN_MASK) == 0);
    if (!var_InheritBool(vout, ""osd"") || duration <= 0)
        return;

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->position = position;
    sys->text     = strdup(text);

    subpicture_updater_t updater = {
        .pf_validate = OSDTextValidate,
        .pf_update   = OSDTextUpdate,
        .pf_destroy  = OSDTextDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys->text);
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + duration;
    subpic->b_ephemer  = true;
    subpic->b_absolute = false;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",1,,108,6,,void
202302,BLOCK,-1,,<empty>,9,,111,2,,void
202314,BLOCK,-1,,<empty>,9,,115,2,,void
202331,BLOCK,1,,<empty>,9,,120,1,,void
202335,BLOCK,2,,<empty>,9,,121,2,,void
202339,BLOCK,3,,<empty>,9,,122,3,,void
202343,BLOCK,4,,<empty>,9,,123,4,,void
202356,BLOCK,-1,,"{
        free(sys->text);
        free(sys);
        return;
    }",18,,126,2,,void
202407,BLOCK,-1,,"{
    va_list args;
    va_start(args, format);

    char *string;
    if (vasprintf(&string, format, args) != -1) {
        vout_OSDText(vout, channel,
                     SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT, 1000000,
                     string);
        free(string);
    }
    va_end(args);
}",1,,143,4,,void
202422,BLOCK,-1,,"{
        vout_OSDText(vout, channel,
                     SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT, 1000000,
                     string);
        free(string);
    }",49,,148,2,,void
202455,BLOCK,-1,,<empty>,1,,1,1,,ANY
202464,BLOCK,-1,,"{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    if( x1 > x2 || y1 > y2 )
        return;

    if (fill == STYLE_FILLED) {
        if(x1 == 0 && x2 + 1 == r->p_picture->p->i_visible_pitch) {
            memset(&p[pitch * y1], color, pitch * (y2 - y1 + 1));
        } else {
            for (int y = y1; y <= y2; y++)
                memset(&p[x1 + pitch * y], color, x2 - x1 + 1);
        }
    } else {
        DrawRect(r, STYLE_FILLED, color, x1, y1, x1, y2);
        DrawRect(r, STYLE_FILLED, color, x2, y1, x2, y2);
        DrawRect(r, STYLE_FILLED, color, x1, y1, x2, y1);
        DrawRect(r, STYLE_FILLED, color, x1, y2, x2, y2);
    }
}",1,,65,8,,void
202493,BLOCK,-1,,<empty>,9,,69,2,,void
202499,BLOCK,1,,<empty>,,,,1,,void
202501,BLOCK,-1,,"{
        if(x1 == 0 && x2 + 1 == r->p_picture->p->i_visible_pitch) {
            memset(&p[pitch * y1], color, pitch * (y2 - y1 + 1));
        } else {
            for (int y = y1; y <= y2; y++)
                memset(&p[x1 + pitch * y], color, x2 - x1 + 1);
        }
    }",31,,71,2,,void
202518,BLOCK,-1,,"{
            memset(&p[pitch * y1], color, pitch * (y2 - y1 + 1));
        }",67,,72,2,,void
202535,BLOCK,-1,,"{
            for (int y = y1; y <= y2; y++)
                memset(&p[x1 + pitch * y], color, x2 - x1 + 1);
        }",16,,74,1,,void
202537,BLOCK,-1,,<empty>,13,,75,1,,void
202563,BLOCK,-1,,"{
        DrawRect(r, STYLE_FILLED, color, x1, y1, x1, y2);
        DrawRect(r, STYLE_FILLED, color, x2, y1, x2, y2);
        DrawRect(r, STYLE_FILLED, color, x1, y1, x2, y1);
        DrawRect(r, STYLE_FILLED, color, x1, y2, x2, y2);
    }",12,,78,1,,void
202567,BLOCK,1,,<empty>,,,,1,,void
202577,BLOCK,1,,<empty>,,,,1,,void
202587,BLOCK,1,,<empty>,,,,1,,void
202597,BLOCK,1,,<empty>,,,,1,,void
202614,BLOCK,-1,,"{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    const int mid = y1 + (y2 - y1) / 2;
    const bool b_swap = (x1 > x2);

    for (int y = y1; y <= mid; y++) {
        const int h = y - y1;
        if (fill == STYLE_FILLED) {
            const int w = b_swap ? __MAX(x1 - h, x2) : __MIN(x1 + h, x2);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y, (b_swap) ? x1 : w, y);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y2 - h, (b_swap) ? x1 : w, y2 - h);
        } else {
            p[x1 +                     pitch * y       ] = color;
            p[x1 + (b_swap ? -h : h) + pitch * y       ] = color;
            p[x1 +                     pitch * (y2 - h)] = color;
            p[x1 + (b_swap ? -h : h) + pitch * (y2 - h)] = color;
        }
    }
}",1,,92,8,,void
202652,BLOCK,-1,,<empty>,5,,98,1,,void
202662,BLOCK,4,,"{
        const int h = y - y1;
        if (fill == STYLE_FILLED) {
            const int w = b_swap ? __MAX(x1 - h, x2) : __MIN(x1 + h, x2);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y, (b_swap) ? x1 : w, y);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y2 - h, (b_swap) ? x1 : w, y2 - h);
        } else {
            p[x1 +                     pitch * y       ] = color;
            p[x1 + (b_swap ? -h : h) + pitch * y       ] = color;
            p[x1 +                     pitch * (y2 - h)] = color;
            p[x1 + (b_swap ? -h : h) + pitch * (y2 - h)] = color;
        }
    }",37,,98,4,,void
202673,BLOCK,1,,<empty>,,,,1,,void
202675,BLOCK,-1,,"{
            const int w = b_swap ? __MAX(x1 - h, x2) : __MIN(x1 + h, x2);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y, (b_swap) ? x1 : w, y);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y2 - h, (b_swap) ? x1 : w, y2 - h);
        }",35,,100,2,,void
202694,BLOCK,1,,<empty>,,,,1,,void
202710,BLOCK,1,,<empty>,,,,1,,void
202728,BLOCK,-1,,"{
            p[x1 +                     pitch * y       ] = color;
            p[x1 + (b_swap ? -h : h) + pitch * y       ] = color;
            p[x1 +                     pitch * (y2 - h)] = color;
            p[x1 + (b_swap ? -h : h) + pitch * (y2 - h)] = color;
        }",16,,106,1,,void
202788,BLOCK,-1,,"{
    if( width == 0 || height == 0 )
        return NULL;

    video_palette_t palette;
    SET_PALETTE_COLOR(COL_WHITE,       0xffffff, STYLE_ALPHA_OPAQUE)
    SET_PALETTE_COLOR(COL_TRANSPARENT, 0xffffff, STYLE_ALPHA_TRANSPARENT)
    SET_PALETTE_COLOR(COL_FILL,        RGB_FILL, 0xA0)
    SET_PALETTE_COLOR(COL_FILL_SHADE,  RGB_FILL, 0x25)
    palette.i_entries = 4;

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width          =
    fmt.i_visible_width  = width;
    fmt.i_height         =
    fmt.i_visible_height = height;
    fmt.i_sar_num        = 1;
    fmt.i_sar_den        = 1;
    fmt.p_palette        = &palette;

    subpicture_region_t *r = subpicture_region_New(&fmt);
    if (!r)
        return NULL;
    r->i_x = x;
    r->i_y = y;

    return r;
}",1,,119,5,,void
202797,BLOCK,-1,,<empty>,9,,121,2,,void
202805,BLOCK,1,,"SET_PALETTE_COLOR(COL_WHITE,       0xffffff, STYLE_ALPHA_OPAQUE)",5,,124,3,,void
202889,BLOCK,1,,"SET_PALETTE_COLOR(COL_TRANSPARENT, 0xffffff, STYLE_ALPHA_TRANSPARENT)",5,,125,4,,void
202972,BLOCK,1,,"SET_PALETTE_COLOR(COL_FILL,        RGB_FILL, 0xA0)",5,,126,5,,void
203055,BLOCK,1,,"SET_PALETTE_COLOR(COL_FILL_SHADE,  RGB_FILL, 0x25)",5,,127,6,,void
203188,BLOCK,-1,,<empty>,9,,142,2,,void
203209,BLOCK,-1,,"{
    const int size = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int margin = size * SLIDER_MARGIN_BASE;
    const int marginbottom = margin * 0.2;
    const int marginright = margin * 0.5;
    uint8_t i_padding = __MIN(1, size * 0.25); /* small sizes */

    int x, y;
    int width, height;
    if (type == OSD_HOR_SLIDER) {
        width  = __MAX(fmt->i_visible_width - 2 * margin, 1);
        height = __MAX(fmt->i_visible_height * 0.01,      1);
        x      = __MIN(fmt->i_x_offset + margin, fmt->i_visible_width - width);
        y      = __MAX(fmt->i_y_offset + fmt->i_visible_height - marginbottom, 0);
    } else {
        width  = __MAX(fmt->i_visible_width * 0.010,       1);
        height = __MAX(fmt->i_visible_height - 2 * margin, 1);
        x      = __MAX(fmt->i_x_offset + fmt->i_visible_width - marginright, 0);
        y      = __MIN(fmt->i_y_offset + margin, fmt->i_visible_height - height);
    }

    if( (width < 1 + 2 * i_padding) || (height < 1 + 2...",1,,156,4,,void
203226,BLOCK,1,,<empty>,,,,1,,void
203256,BLOCK,-1,,"{
        width  = __MAX(fmt->i_visible_width - 2 * margin, 1);
        height = __MAX(fmt->i_visible_height * 0.01,      1);
        x      = __MIN(fmt->i_x_offset + margin, fmt->i_visible_width - width);
        y      = __MAX(fmt->i_y_offset + fmt->i_visible_height - marginbottom, 0);
    }",33,,165,2,,void
203304,BLOCK,-1,,"{
        width  = __MAX(fmt->i_visible_width * 0.010,       1);
        height = __MAX(fmt->i_visible_height - 2 * margin, 1);
        x      = __MAX(fmt->i_x_offset + fmt->i_visible_width - marginright, 0);
        y      = __MIN(fmt->i_y_offset + margin, fmt->i_visible_height - height);
    }",12,,170,1,,void
203367,BLOCK,-1,,<empty>,9,,178,2,,void
203381,BLOCK,-1,,<empty>,9,,182,2,,void
203402,BLOCK,-1,,"{
        pos_y = i_padding;
        pos_xend = pos_x + (width - 2 * i_padding) * position / 100;
    }",34,,188,2,,void
203420,BLOCK,-1,,"{
        pos_y = height - (height - 2 * i_padding) * position / 100;
        pos_xend = width - 1 - i_padding;
    }",12,,191,1,,void
203444,BLOCK,1,,<empty>,,,,1,,void
203447,BLOCK,1,,<empty>,,,,1,,void
203460,BLOCK,1,,<empty>,,,,1,,void
203463,BLOCK,1,,<empty>,,,,1,,void
203476,BLOCK,-1,,"{
    const float size_ratio   = 0.05;
    const float margin_ratio = 0.07;

    const int size   = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int width  = size * size_ratio;
    const int height = size * size_ratio;
    const int x      = fmt->i_x_offset + fmt->i_visible_width - margin_ratio * size - width;
    const int y      = fmt->i_y_offset                        + margin_ratio * size;

    if( width < 1 || height < 1 )
        return NULL;

    subpicture_region_t *r = OSDRegion(__MAX(x, 0),
                                       __MIN(y, (int)fmt->i_visible_height - height),
                                       width, height);
    if (!r)
        return NULL;

    DrawRect(r, STYLE_FILLED, COL_TRANSPARENT, 0, 0, width - 1, height - 1);

    if (type == OSD_PAUSE_ICON) {
        int bar_width = width / 3;
        DrawRect(r, STYLE_FILLED, COL_WHITE, 0, 0, bar_width - 1, height -1);
        DrawRect(r, STYLE_FILLED, COL_WHITE, width - bar_width, 0, width -...",1,,208,3,,void
203541,BLOCK,-1,,<empty>,9,,219,2,,void
203565,BLOCK,-1,,<empty>,9,,225,2,,void
203571,BLOCK,1,,<empty>,,,,1,,void
203574,BLOCK,1,,<empty>,,,,1,,void
203588,BLOCK,-1,,"{
        int bar_width = width / 3;
        DrawRect(r, STYLE_FILLED, COL_WHITE, 0, 0, bar_width - 1, height -1);
        DrawRect(r, STYLE_FILLED, COL_WHITE, width - bar_width, 0, width - 1, height - 1);
    }",33,,229,2,,void
203598,BLOCK,1,,<empty>,,,,1,,void
203601,BLOCK,1,,<empty>,,,,1,,void
203614,BLOCK,1,,<empty>,,,,1,,void
203617,BLOCK,1,,<empty>,,,,1,,void
203630,BLOCK,-1,,<empty>,12,,233,1,,void
203635,BLOCK,-1,,"{
        int mid   = height >> 1;
        int delta = (width - mid) >> 1;
        int y2    = ((height - 1) >> 1) * 2;
        DrawTriangle(r, STYLE_FILLED, COL_WHITE, delta, 0, width - delta, y2);
    }",39,,233,2,,void
203663,BLOCK,1,,<empty>,,,,1,,void
203666,BLOCK,1,,<empty>,,,,1,,void
203675,BLOCK,-1,,"{
        int mid   = height >> 1;
        int delta = (width - mid) >> 1;
        int y2    = ((height - 1) >> 1) * 2;
        DrawRect(r, STYLE_FILLED, COL_WHITE, delta, mid / 2, width - delta, height - 1 - mid / 2);
        DrawTriangle(r, STYLE_FILLED, COL_WHITE, width - delta, 0, delta, y2);
        if (type == OSD_MUTE_ICON) {
            for(int y1 = 0; y1 <= height -1; y1++)
                DrawRect(r, STYLE_FILLED, COL_FILL, y1, y1, __MIN(y1 + delta, width - 1), y1);
        }
    }",12,,238,1,,void
203703,BLOCK,1,,<empty>,,,,1,,void
203706,BLOCK,1,,<empty>,,,,1,,void
203725,BLOCK,1,,<empty>,,,,1,,void
203728,BLOCK,1,,<empty>,,,,1,,void
203740,BLOCK,-1,,"{
            for(int y1 = 0; y1 <= height -1; y1++)
                DrawRect(r, STYLE_FILLED, COL_FILL, y1, y1, __MIN(y1 + delta, width - 1), y1);
        }",36,,244,2,,void
203742,BLOCK,-1,,<empty>,13,,245,1,,void
203757,BLOCK,1,,<empty>,,,,1,,void
203760,BLOCK,1,,<empty>,,,,1,,void
203786,BLOCK,-1,,"{
    VLC_UNUSED(subpic); VLC_UNUSED(ts);
    VLC_UNUSED(fmt_src); VLC_UNUSED(has_src_changed);
    VLC_UNUSED(fmt_dst);

    if (!has_dst_changed)
        return VLC_SUCCESS;
    return VLC_EGENERIC;
}",1,,261,7,,void
203800,BLOCK,-1,,<empty>,9,,267,2,,void
203812,BLOCK,-1,,"{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_sar_num       = 1;
    fmt.i_sar_den       = 1;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;
    if (sys->type == OSD_HOR_SLIDER || sys->type == OSD_VERT_SLIDER)
        subpic->p_region = OSDSlider(sys->type, sys->position, &fmt);
    else
        subpic->p_region = OSDIcon(sys->type, &fmt);
}",1,,275,5,,void
203911,BLOCK,-1,,<empty>,9,,289,2,,void
203926,BLOCK,-1,,<empty>,9,,291,1,,void
203941,BLOCK,-1,,"{
    free(subpic->updater.p_sys);
}",1,,295,2,,void
203955,BLOCK,-1,,"{
    if (!var_InheritBool(vout, ""osd""))
        return;
    if (type == OSD_HOR_SLIDER || type == OSD_VERT_SLIDER)
        position = VLC_CLIP(position, 0, 100);

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->type     = type;
    sys->position = position;

    subpicture_updater_t updater = {
        .pf_validate = OSDWidgetValidate,
        .pf_update   = OSDWidgetUpdate,
        .pf_destroy  = OSDWidgetDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + 1200000;
    subpic->b_ephemer  = true;
    subpic->b_absolute = true;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",1,,300,5,,void
203961,BLOCK,-1,,<empty>,9,,302,2,,void
203971,BLOCK,-1,,<empty>,9,,304,2,,void
203988,BLOCK,-1,,<empty>,9,,308,2,,void
204004,BLOCK,1,,<empty>,9,,313,1,,void
204008,BLOCK,2,,<empty>,9,,314,2,,void
204012,BLOCK,3,,<empty>,9,,315,3,,void
204016,BLOCK,4,,<empty>,9,,316,4,,void
204029,BLOCK,-1,,"{
        free(sys);
        return;
    }",18,,319,2,,void
204077,BLOCK,-1,,"{
    OSDWidget(vout, channel, type, position);
}",1,,335,5,,void
204089,BLOCK,-1,,"{
    OSDWidget(vout, channel, type, 0);
}",1,,340,4,,void
204101,BLOCK,-1,,<empty>,1,,1,1,,ANY
204108,BLOCK,-1,,<empty>,,,,4,,<empty>
204114,BLOCK,-1,,<empty>,,,,3,,<empty>
204121,BLOCK,-1,,<empty>,,,,4,,<empty>
204127,BLOCK,-1,,<empty>,,,,3,,<empty>
204133,BLOCK,-1,,<empty>,,,,3,,<empty>
204139,BLOCK,-1,,<empty>,,,,3,,<empty>
204145,BLOCK,-1,,<empty>,,,,3,,<empty>
204151,BLOCK,-1,,<empty>,,,,3,,<empty>
204156,BLOCK,-1,,<empty>,,,,2,,<empty>
204181,BLOCK,-1,,<empty>,1,,1,1,,ANY
204247,BLOCK,-1,,<empty>,,,,3,,<empty>
204253,BLOCK,-1,,<empty>,,,,3,,<empty>
204259,BLOCK,-1,,<empty>,,,,3,,<empty>
204266,BLOCK,-1,,<empty>,,,,4,,<empty>
204273,BLOCK,-1,,<empty>,,,,4,,<empty>
204280,BLOCK,-1,,<empty>,,,,4,,<empty>
204289,BLOCK,-1,,<empty>,,,,6,,<empty>
204298,BLOCK,-1,,<empty>,,,,6,,<empty>
204304,BLOCK,-1,,<empty>,,,,3,,<empty>
204310,BLOCK,-1,,<empty>,,,,3,,<empty>
204316,BLOCK,-1,,<empty>,,,,3,,<empty>
204322,BLOCK,-1,,<empty>,,,,3,,<empty>
204328,BLOCK,-1,,<empty>,,,,3,,<empty>
204333,BLOCK,-1,,<empty>,,,,2,,<empty>
204338,BLOCK,-1,,<empty>,,,,2,,<empty>
204345,BLOCK,-1,,<empty>,,,,4,,<empty>
204351,BLOCK,-1,,<empty>,,,,3,,<empty>
204356,BLOCK,-1,,<empty>,,,,2,,<empty>
204361,BLOCK,-1,,<empty>,,,,2,,<empty>
204366,BLOCK,-1,,<empty>,,,,2,,<empty>
204373,BLOCK,-1,,<empty>,,,,4,,<empty>
204380,BLOCK,-1,,<empty>,,,,4,,<empty>
204386,BLOCK,-1,,<empty>,,,,3,,<empty>
204417,BLOCK,-1,,<empty>,1,,1,1,,ANY
204424,BLOCK,-1,,<empty>,,,,6,,<empty>
204433,BLOCK,-1,,<empty>,,,,6,,<empty>
204442,BLOCK,-1,,<empty>,,,,6,,<empty>
204451,BLOCK,-1,,<empty>,,,,6,,<empty>
204460,BLOCK,-1,,<empty>,,,,6,,<empty>
204469,BLOCK,-1,,<empty>,,,,6,,<empty>
204478,BLOCK,-1,,<empty>,,,,6,,<empty>
204487,BLOCK,-1,,<empty>,,,,6,,<empty>
204496,BLOCK,-1,,<empty>,,,,6,,<empty>
204505,BLOCK,-1,,<empty>,,,,6,,<empty>
204514,BLOCK,-1,,<empty>,,,,6,,<empty>
204523,BLOCK,-1,,<empty>,,,,6,,<empty>
204532,BLOCK,-1,,<empty>,,,,6,,<empty>
204541,BLOCK,-1,,<empty>,,,,6,,<empty>
204548,BLOCK,-1,,<empty>,,,,1,,<empty>
204577,BLOCK,-1,,<empty>,,,,1,,<empty>
204626,BLOCK,-1,,<empty>,,,,1,,<empty>
204669,BLOCK,-1,,"{
    assert( psz_list );

    char *psz_cur = psz_list;
    char *psz_next;
    while( psz_cur && *psz_cur )
    {
        vlc_value_t val, text;
        psz_next = strchr( psz_cur, ',' );
        if( psz_next )
        {
            *psz_next = '\0';
            psz_next++;
        }
        val.psz_string = psz_cur;
        text.psz_string = psz_cur;
        var_Change( p_vout, psz_var, VLC_VAR_ADDCHOICE, &val, &text);
        psz_cur = psz_next;
    }
}",1,,129,4,,void
204682,BLOCK,-1,,"{
        vlc_value_t val, text;
        psz_next = strchr( psz_cur, ',' );
        if( psz_next )
        {
            *psz_next = '\0';
            psz_next++;
        }
        val.psz_string = psz_cur;
        text.psz_string = psz_cur;
        var_Change( p_vout, psz_var, VLC_VAR_ADDCHOICE, &val, &text);
        psz_cur = psz_next;
    }",5,,135,2,,void
204692,BLOCK,-1,,"{
            *psz_next = '\0';
            psz_next++;
        }",9,,139,2,,void
204724,BLOCK,-1,,"{
    vlc_value_t val, text;
    char *psz_buf;

    /* Create a few object variables we'll need later on */
    var_Create( p_vout, ""snapshot-num"", VLC_VAR_INTEGER );
    var_SetInteger( p_vout, ""snapshot-num"", 1 );

    var_Create( p_vout, ""width"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""height"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""align"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    var_Create( p_vout, ""mouse-hide-timeout"",
                VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    /* Add variables to manage scaling video */
    var_Create( p_vout, ""autoscale"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT
                | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Autoscale video"");
    var_Change( p_vout, ""autoscale"", VLC_VAR_SETTEXT, &text, NULL );
    var_AddCallback( p_vout, ""autoscale"", AutoScaleCallback, NULL );

    var_Create( p_vout, ""zoom"", VLC_VAR_FLOAT | VLC_VAR_ISCOMMAND |
                VLC_VAR_DOINHERIT );

    text.psz_...",1,,151,2,,void
204808,BLOCK,-1,,<empty>,5,,179,1,,void
204819,BLOCK,4,,"{
        val.f_float = p_zoom_values[i].f_value;
        text.psz_string = vlc_gettext( p_zoom_values[i].psz_label );
        var_Change( p_vout, ""zoom"", VLC_VAR_ADDCHOICE, &val, &text );
    }",5,,180,4,,void
204918,BLOCK,-1,,<empty>,5,,206,1,,void
204929,BLOCK,4,,"{
        val.psz_string = (char*)p_crop_values[i].psz_value;
        text.psz_string = _( p_crop_values[i].psz_label );
        var_Change( p_vout, ""crop"", VLC_VAR_ADDCHOICE, &val, &text );
    }",5,,207,4,,void
204966,BLOCK,-1,,"{
        AddCustomRatios( p_vout, ""crop"", psz_buf );
        free( psz_buf );
    }",5,,216,2,,void
205006,BLOCK,-1,,<empty>,5,,233,1,,void
205017,BLOCK,4,,"{
        val.psz_string = (char*)p_aspect_ratio_values[i].psz_value;
        text.psz_string = _( p_aspect_ratio_values[i].psz_label );
        var_Change( p_vout, ""aspect-ratio"", VLC_VAR_ADDCHOICE, &val, &text );
    }",5,,234,4,,void
205054,BLOCK,-1,,"{
        AddCustomRatios( p_vout, ""aspect-ratio"", psz_buf );
        free( psz_buf );
    }",5,,243,2,,void
205250,BLOCK,-1,,"{
    var_TriggerCallback( p_vout, ""zoom"" );
    var_TriggerCallback( p_vout, ""crop"" );
    var_TriggerCallback( p_vout, ""aspect-ratio"" );

    var_TriggerCallback( p_vout, ""video-on-top"" );
    var_TriggerCallback( p_vout, ""video-wallpaper"" );

    var_TriggerCallback( p_vout, ""video-filter"" );
    var_TriggerCallback( p_vout, ""sub-source"" );
    var_TriggerCallback( p_vout, ""sub-filter"" );
    var_TriggerCallback( p_vout, ""sub-margin"" );
}",1,,315,2,,void
205283,BLOCK,-1,,"{
    subpicture_t *p_subpic = subpicture_NewFromPicture( VLC_OBJECT(p_vout),
                                                        p_pic, VLC_CODEC_YUVA );
    if( !p_subpic )
        return VLC_EGENERIC;

    /* FIXME SPU_DEFAULT_CHANNEL is not good (used by the text) but
     * hardcoded 0 doesn't seem right */
    p_subpic->i_channel = 0;
    p_subpic->i_start = mdate();
    p_subpic->i_stop  = p_subpic->i_start + 4000000;
    p_subpic->b_ephemer = true;
    p_subpic->b_fade = true;

    /* Reduce the picture to 1/4^2 of the screen */
    p_subpic->i_original_picture_width  *= 4;
    p_subpic->i_original_picture_height *= 4;

    vout_PutSubpicture( p_vout, p_subpic );
    return VLC_SUCCESS;
}",1,,337,3,,void
205295,BLOCK,-1,,<empty>,9,,341,2,,void
205348,BLOCK,-1,,"{
    msg_Dbg( p_vout, ""snapshot taken (%s)"", psz_filename );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_filename );

    if( var_InheritBool( p_vout, ""snapshot-preview"" ) )
    {
        if( VoutSnapshotPip( p_vout, p_pic ) )
            msg_Warn( p_vout, ""Failed to display snapshot"" );
    }
}",1,,363,4,,void
205362,BLOCK,-1,,"{
        if( VoutSnapshotPip( p_vout, p_pic ) )
            msg_Warn( p_vout, ""Failed to display snapshot"" );
    }",5,,368,2,,void
205367,BLOCK,-1,,<empty>,13,,370,2,,void
205375,BLOCK,-1,,"{
    char *psz_path = var_InheritString( p_vout, ""snapshot-path"" );
    char *psz_format = var_InheritString( p_vout, ""snapshot-format"" );
    char *psz_prefix = var_InheritString( p_vout, ""snapshot-prefix"" );

    /* */
    picture_t *p_picture;
    block_t *p_image;

    /* 500ms timeout
     * XXX it will cause trouble with low fps video (< 2fps) */
    if( vout_GetSnapshot( p_vout, &p_image, &p_picture, NULL, psz_format, 500*1000 ) )
    {
        p_picture = NULL;
        p_image = NULL;
        goto exit;
    }

    if( !psz_path )
    {
        psz_path = vout_snapshot_GetDirectory();
        if( !psz_path )
        {
            msg_Err( p_vout, ""no path specified for snapshots"" );
            goto exit;
        }
    }

    vout_snapshot_save_cfg_t cfg;
    memset( &cfg, 0, sizeof(cfg) );
    cfg.is_sequential = var_InheritBool( p_vout, ""snapshot-sequential"" );
    cfg.sequence = var_GetInteger( p_vout, ""snapshot-num"" );
    cfg.path = psz_path;
    cfg.format = psz_format...",1,,378,2,,void
205408,BLOCK,-1,,"{
        p_picture = NULL;
        p_image = NULL;
        goto exit;
    }",5,,390,2,,void
205419,BLOCK,-1,,"{
        psz_path = vout_snapshot_GetDirectory();
        if( !psz_path )
        {
            msg_Err( p_vout, ""no path specified for snapshots"" );
            goto exit;
        }
    }",5,,397,2,,void
205426,BLOCK,-1,,"{
            msg_Err( p_vout, ""no path specified for snapshots"" );
            goto exit;
        }",9,,400,2,,void
205479,BLOCK,-1,,<empty>,9,,418,2,,void
205485,BLOCK,-1,,<empty>,9,,420,2,,void
205509,BLOCK,-1,,<empty>,9,,431,2,,void
205514,BLOCK,-1,,<empty>,9,,433,2,,void
205531,BLOCK,-1,,"{
    vout_thread_t *vout = (vout_thread_t *)object;
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data);
    unsigned num, den;
    unsigned y, x;
    unsigned width, height;
    unsigned left, top, right, bottom;

    if (sscanf(newval.psz_string, ""%u:%u"", &num, &den) == 2) {
        vout_ControlChangeCropRatio(vout, num, den);
    } else if (sscanf(newval.psz_string, ""%ux%u+%u+%u"",
                      &width, &height, &x, &y) == 4) {
        vout_ControlChangeCropWindow(vout, x, y, width, height);
    } else if (sscanf(newval.psz_string, ""%u+%u+%u+%u"",
                    &left, &top, &right, &bottom) == 4) {
        vout_ControlChangeCropBorder(vout, left, top, right, bottom);
    } else if (*newval.psz_string == '\0') {
        vout_ControlChangeCropRatio(vout, 0, 0);
    } else {
        msg_Err(object, ""Unknown crop format (%s)"", newval.psz_string);
    }
    return VLC_SUCCESS;
}",1,,444,6,,void
205566,BLOCK,-1,,"{
        vout_ControlChangeCropRatio(vout, num, den);
    }",62,,452,2,,void
205572,BLOCK,-1,,<empty>,12,,454,1,,void
205589,BLOCK,-1,,"{
        vout_ControlChangeCropWindow(vout, x, y, width, height);
    }",54,,455,2,,void
205597,BLOCK,-1,,<empty>,12,,457,1,,void
205614,BLOCK,-1,,"{
        vout_ControlChangeCropBorder(vout, left, top, right, bottom);
    }",57,,458,2,,void
205622,BLOCK,-1,,<empty>,12,,460,1,,void
205630,BLOCK,-1,,"{
        vout_ControlChangeCropRatio(vout, 0, 0);
    }",44,,460,2,,void
205636,BLOCK,-1,,"{
        msg_Err(object, ""Unknown crop format (%s)"", newval.psz_string);
    }",12,,462,1,,void
205653,BLOCK,-1,,"{
    char buf[4 * 21];

    snprintf(buf, sizeof (buf), ""%""PRIu64""+%""PRIu64""+%""PRIu64""+%""PRIu64,
             var_GetInteger(object, ""crop-left""),
             var_GetInteger(object, ""crop-top""),
             var_GetInteger(object, ""crop-right""),
             var_GetInteger(object, ""crop-bottom""));
    var_SetString(object, ""crop"", buf);

    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data); VLC_UNUSED(newval);
    return VLC_SUCCESS;
}",1,,470,6,,void
205678,BLOCK,-1,,"{
    vout_thread_t *vout = (vout_thread_t *)object;
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(data);
    unsigned num, den;

    if (sscanf(newval.psz_string, ""%u:%u"", &num, &den) == 2 &&
        (num != 0) == (den != 0))
        vout_ControlChangeSampleAspectRatio(vout, num, den);
    else if (*newval.psz_string == '\0')
        vout_ControlChangeSampleAspectRatio(vout, 0, 0);
    return VLC_SUCCESS;
}",1,,486,6,,void
205713,BLOCK,-1,,<empty>,9,,493,2,,void
205719,BLOCK,-1,,<empty>,10,,494,1,,void
205727,BLOCK,-1,,<empty>,9,,495,2,,void
205742,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)obj;

    (void) name; (void) prev; (void) data;
    vout_ControlChangeDisplayFilled( p_vout, cur.b_bool );
    return VLC_SUCCESS;
}",1,,501,6,,void
205773,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)obj;

    (void) name; (void) prev; (void) data;
    vout_ControlChangeZoom( p_vout, 1000 * cur.f_float, 1000 );
    return VLC_SUCCESS;
}",1,,511,6,,void
205807,BLOCK,-1,,"{
    vout_ControlChangeWindowState( (vout_thread_t *)obj,
        cur.b_bool ? VOUT_WINDOW_STATE_ABOVE : VOUT_WINDOW_STATE_NORMAL );
    (void) name; (void) prev; (void) data;
    return VLC_SUCCESS;
}",1,,521,6,,void
205837,BLOCK,-1,,"{
    vout_thread_t *vout = (vout_thread_t *)obj;

    if( cur.b_bool )
    {
        vout_ControlChangeWindowState( vout, VOUT_WINDOW_STATE_BELOW );
        vout_ControlChangeFullscreen( vout, true );
    }
    else
    {
        var_TriggerCallback( obj, ""fullscreen"" );
        var_TriggerCallback( obj, ""video-on-top"" );
    }
    (void) name; (void) prev; (void) data;
    return VLC_SUCCESS;
}",1,,530,6,,void
205848,BLOCK,-1,,"{
        vout_ControlChangeWindowState( vout, VOUT_WINDOW_STATE_BELOW );
        vout_ControlChangeFullscreen( vout, true );
    }",5,,534,2,,void
205856,BLOCK,-1,,"{
        var_TriggerCallback( obj, ""fullscreen"" );
        var_TriggerCallback( obj, ""video-on-top"" );
    }",5,,539,1,,void
205882,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    (void)psz_cmd; (void)p_data;

    if( oldval.b_bool != newval.b_bool )
        vout_ControlChangeFullscreen( p_vout, newval.b_bool );
    return VLC_SUCCESS;
}",1,,549,6,,void
205903,BLOCK,-1,,<empty>,9,,554,2,,void
205919,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    VLC_UNUSED(newval); VLC_UNUSED(p_data);

    VoutSaveSnapshot( p_vout );
    return VLC_SUCCESS;
}",1,,560,6,,void
205946,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeFilters( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",1,,571,6,,void
205974,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubSources( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",1,,581,6,,void
206002,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubFilters( p_vout, newval.psz_string );
    return VLC_SUCCESS;
}",1,,591,6,,void
206030,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    vout_ControlChangeSubMargin( p_vout, newval.i_int );
    return VLC_SUCCESS;
}",1,,601,6,,void
206058,BLOCK,-1,,"{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( newval.p_address != NULL )
        vout_ControlChangeViewpoint( p_vout, newval.p_address );
    return VLC_SUCCESS;
}",1,,611,6,,void
206077,BLOCK,-1,,<empty>,9,,616,2,,void
206093,BLOCK,-1,,<empty>,1,,1,1,,ANY
206099,BLOCK,-1,,"{
    for( uint8_t i = 0; i<i_splits; i++ )
    {
        uint32_t rgb1 = argb1 & 0x00FFFFFF;
        uint32_t rgb2 = argb2 & 0x00FFFFFF;

        uint32_t r = ((((rgb1 >> 16) * (i_splits - i)) + (rgb2 >> 16) * i)) / i_splits;
        uint32_t g = (((((rgb1 >> 8) & 0xFF) * (i_splits - i)) + ((rgb2 >> 8) & 0xFF) * i)) / i_splits;
        uint32_t b = ((((rgb1 & 0xFF) * (i_splits - i)) + (rgb2 & 0xFF) * i)) / i_splits;
        uint8_t entry[4] = { RGB2YUV( r,g,b ), argb1 >> 24 };
        memcpy( p_palette->palette[i], entry, 4 );
    }
    p_palette->i_entries = i_splits;
}",1,,33,5,,void
206101,BLOCK,-1,,<empty>,5,,34,1,,void
206111,BLOCK,4,,"{
        uint32_t rgb1 = argb1 & 0x00FFFFFF;
        uint32_t rgb2 = argb2 & 0x00FFFFFF;

        uint32_t r = ((((rgb1 >> 16) * (i_splits - i)) + (rgb2 >> 16) * i)) / i_splits;
        uint32_t g = (((((rgb1 >> 8) & 0xFF) * (i_splits - i)) + ((rgb2 >> 8) & 0xFF) * i)) / i_splits;
        uint32_t b = ((((rgb1 & 0xFF) * (i_splits - i)) + (rgb2 & 0xFF) * i)) / i_splits;
        uint8_t entry[4] = { RGB2YUV( r,g,b ), argb1 >> 24 };
        memcpy( p_palette->palette[i], entry, 4 );
    }",5,,35,4,,void
206190,BLOCK,1,,<empty>,,,,7,,void
206252,BLOCK,-1,,"{
    const int i_split = p->i_visible_lines / i_splits;
    const int i_left = p->i_visible_lines % i_splits + p->i_lines - p->i_visible_lines;
    for( int i = 0; i<i_splits; i++ )
    {
        memset( &p->p_pixels[p->i_pitch * (i * i_split)],
                i,
                p->i_pitch * i_split );
    }
    memset( &p->p_pixels[p->i_pitch * (i_splits - 1) * i_split],
            i_splits - 1,
            p->i_pitch * i_left );
}",1,,50,3,,void
206278,BLOCK,-1,,<empty>,5,,53,1,,void
206288,BLOCK,4,,"{
        memset( &p->p_pixels[p->i_pitch * (i * i_split)],
                i,
                p->i_pitch * i_split );
    }",5,,54,4,,void
206337,BLOCK,-1,,"{
    video_format_t fmt_in;
    video_format_Init( &fmt_in, 0 );

    picture_t *p_pic = NULL;
    int i_flags = p_this->obj.flags;
    p_this->obj.flags |= OBJECT_FLAGS_NOINTERACT|OBJECT_FLAGS_QUIET;
    image_handler_t *p_image = image_HandlerCreate( p_this );
    if( p_image )
    {
        p_pic = image_ReadUrl( p_image, psz_uri, &fmt_in, p_fmt );
        image_HandlerDelete( p_image );
    }
    p_this->obj.flags = i_flags;

    if(!p_pic)
        return NULL;

    subpicture_region_t *region = subpicture_region_New(p_fmt);
    if (!region)
        return NULL;

    picture_Release( region->p_picture );
    region->p_picture = p_pic;

    return region;
}",1,,68,4,,void
206371,BLOCK,-1,,"{
        p_pic = image_ReadUrl( p_image, psz_uri, &fmt_in, p_fmt );
        image_HandlerDelete( p_image );
    }",5,,77,2,,void
206392,BLOCK,-1,,<empty>,9,,84,2,,void
206403,BLOCK,-1,,<empty>,9,,88,2,,void
206447,BLOCK,-1,,<empty>,1,,1,1,,ANY
206455,BLOCK,-1,,<empty>,,,,1,,<empty>
206458,BLOCK,1,,<empty>,,,,1,,void
206496,BLOCK,-1,,<empty>,,,,1,,<empty>
206504,BLOCK,-1,,"{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        e->subpicture = NULL;
        e->reject     = false;
    }
}",1,,105,2,,void
206506,BLOCK,-1,,<empty>,5,,106,1,,void
206514,BLOCK,1,,<empty>,,,,1,,void
206522,BLOCK,4,,"{
        spu_heap_entry_t *e = &heap->entry[i];

        e->subpicture = NULL;
        e->reject     = false;
    }",52,,106,4,,void
206547,BLOCK,-1,,"{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture)
            continue;

        e->subpicture = subpic;
        e->reject     = false;
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",1,,115,3,,void
206549,BLOCK,-1,,<empty>,5,,116,1,,void
206557,BLOCK,1,,<empty>,,,,1,,void
206565,BLOCK,4,,"{
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture)
            continue;

        e->subpicture = subpic;
        e->reject     = false;
        return VLC_SUCCESS;
    }",52,,116,4,,void
206579,BLOCK,-1,,<empty>,13,,120,2,,void
206600,BLOCK,-1,,"{
    spu_heap_entry_t *e = &heap->entry[index];

    if (e->subpicture)
        subpicture_Delete(e->subpicture);

    e->subpicture = NULL;
}",1,,130,3,,void
206614,BLOCK,-1,,<empty>,9,,134,2,,void
206629,BLOCK,-1,,"{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture != subpic)
            continue;

        SpuHeapDeleteAt(heap, i);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",1,,140,3,,void
206631,BLOCK,-1,,<empty>,5,,141,1,,void
206639,BLOCK,1,,<empty>,,,,1,,void
206647,BLOCK,4,,"{
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture != subpic)
            continue;

        SpuHeapDeleteAt(heap, i);
        return VLC_SUCCESS;
    }",52,,141,4,,void
206663,BLOCK,-1,,<empty>,13,,145,2,,void
206676,BLOCK,-1,,"{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];
        if (e->subpicture)
            subpicture_Delete(e->subpicture);
    }
}",1,,154,2,,void
206678,BLOCK,-1,,<empty>,5,,155,1,,void
206686,BLOCK,1,,<empty>,,,,1,,void
206694,BLOCK,4,,"{
        spu_heap_entry_t *e = &heap->entry[i];
        if (e->subpicture)
            subpicture_Delete(e->subpicture);
    }",52,,155,4,,void
206708,BLOCK,-1,,<empty>,13,,158,2,,void
206717,BLOCK,-1,,"{
    if (filter->p_module)
        module_unneed(filter, filter->p_module);
    vlc_object_release(filter);
}",1,,163,2,,void
206722,BLOCK,-1,,<empty>,9,,165,2,,void
206734,BLOCK,-1,,"{
    const video_format_t *fmt = &filter->fmt_out.video;

    return picture_NewFromFormat(fmt);
}",1,,170,2,,void
206753,BLOCK,-1,,"{
    spu_t *spu = filter->owner.sys;

    int ret = VLC_EGENERIC;
    if (spu->p->input)
        ret = input_Control((input_thread_t*)spu->p->input,
                            INPUT_GET_ATTACHMENTS,
                            attachment_ptr, attachment_count);
    return ret;
}",1,,179,4,,void
206772,BLOCK,-1,,<empty>,9,,184,2,,void
206792,BLOCK,-1,,"{
    filter_t *text = vlc_custom_create(spu, sizeof(*text), ""spu text"");
    if (!text)
        return NULL;

    text->owner.sys = spu;

    es_format_Init(&text->fmt_in, VIDEO_ES, 0);

    es_format_Init(&text->fmt_out, VIDEO_ES, 0);
    text->fmt_out.video.i_width          =
    text->fmt_out.video.i_visible_width  = 32;
    text->fmt_out.video.i_height         =
    text->fmt_out.video.i_visible_height = 32;

    text->pf_get_attachments = spu_get_attachments;

    text->p_module = module_need(text, ""text renderer"", ""$text-renderer"", false);

    /* Create a few variables used for enhanced text rendering */
    var_Create(text, ""spu-elapsed"",   VLC_VAR_INTEGER);
    var_Create(text, ""text-rerender"", VLC_VAR_BOOL);

    return text;
}",1,,191,2,,void
206798,BLOCK,1,,<empty>,,,,3,,void
206809,BLOCK,-1,,<empty>,9,,194,2,,void
206898,BLOCK,-1,,"{
    filter_t *scale = vlc_custom_create(object, sizeof(*scale), ""scale"");
    if (!scale)
        return NULL;

    es_format_Init(&scale->fmt_in, VIDEO_ES, 0);
    scale->fmt_in.video.i_chroma = src_chroma;
    scale->fmt_in.video.i_width =
    scale->fmt_in.video.i_visible_width =
    scale->fmt_in.video.i_height =
    scale->fmt_in.video.i_visible_height = 32;

    es_format_Init(&scale->fmt_out, VIDEO_ES, 0);
    scale->fmt_out.video.i_chroma = dst_chroma;
    scale->fmt_out.video.i_width =
    scale->fmt_out.video.i_visible_width =
    scale->fmt_out.video.i_height =
    scale->fmt_out.video.i_visible_height = require_resize ? 16 : 32;

    scale->owner.video.buffer_new = spu_new_video_buffer;

    scale->p_module = module_need(scale, ""video converter"", NULL, false);

    return scale;
}",1,,221,5,,void
206905,BLOCK,1,,<empty>,,,,4,,void
206916,BLOCK,-1,,<empty>,9,,224,2,,void
207048,BLOCK,-1,,"{
    filter_t *text = spu->p->text;

    assert(region->fmt.i_chroma == VLC_CODEC_TEXT);

    if (!text || !text->p_module)
        return;

    /* Setup 3 variables which can be used to render
     * time-dependent text (and effects). The first indicates
     * the total amount of time the text will be on screen,
     * the second the amount of time it has already been on
     * screen (can be a negative value as text is laid out
     * before it is rendered) and the third is a feedback
     * variable from the renderer - if the renderer sets it
     * then this particular text is time-dependent, eg. the
     * visual progress bar inside the text in karaoke and the
     * text needs to be rendered multiple times in order for
     * the effect to work - we therefore need to return the
     * region to its original state at the end of the loop,
     * instead of leaving it in YUVA or YUVP.
     * Any renderer which is unaware of how to render
     * time-dependent text can happily i...",1,,251,6,,void
207073,BLOCK,-1,,<empty>,9,,257,2,,void
207087,BLOCK,-1,,<empty>,9,,282,2,,void
207111,BLOCK,-1,,"{
    spu_scale_t s = { .w = w, .h = h };
    if (s.w <= 0)
        s.w = SCALE_UNIT;
    if (s.h <= 0)
        s.h = SCALE_UNIT;
    return s;
}",1,,297,3,,void
207116,BLOCK,1,,<empty>,23,,298,1,,void
207120,BLOCK,2,,<empty>,31,,298,2,,void
207130,BLOCK,-1,,<empty>,9,,300,2,,void
207136,BLOCK,1,,<empty>,,,,1,,void
207144,BLOCK,-1,,<empty>,9,,302,2,,void
207150,BLOCK,1,,<empty>,,,,1,,void
207158,BLOCK,-1,,"{
    return spu_scale_create(SCALE_UNIT, SCALE_UNIT);
}",1,,306,2,,void
207162,BLOCK,1,,<empty>,,,,1,,void
207165,BLOCK,1,,<empty>,,,,1,,void
207174,BLOCK,-1,,"{
    return spu_scale_create(wn * SCALE_UNIT / wd,
                            hn * SCALE_UNIT / hd);
}",1,,310,5,,void
207181,BLOCK,1,,<empty>,,,,1,,void
207188,BLOCK,1,,<empty>,,,,1,,void
207196,BLOCK,-1,,"{
    return v * s.w / SCALE_UNIT;
}",1,,315,3,,void
207205,BLOCK,1,,<empty>,,,,1,,void
207212,BLOCK,-1,,"{
    return v * s.h / SCALE_UNIT;
}",1,,319,3,,void
207221,BLOCK,1,,<empty>,,,,1,,void
207228,BLOCK,-1,,"{
    return v * SCALE_UNIT / s.w;
}",1,,323,3,,void
207234,BLOCK,1,,<empty>,,,,1,,void
207244,BLOCK,-1,,"{
    return v * SCALE_UNIT / s.h;
}",1,,327,3,,void
207250,BLOCK,1,,<empty>,,,,1,,void
207270,BLOCK,-1,,"{
    spu_area_t a = { .x = x, .y = y, .width = w, .height = h, .scale = s };
    return a;
}",1,,344,6,,void
207275,BLOCK,1,,<empty>,22,,345,1,,void
207279,BLOCK,2,,<empty>,30,,345,2,,void
207283,BLOCK,3,,<empty>,38,,345,3,,void
207287,BLOCK,4,,<empty>,50,,345,4,,void
207291,BLOCK,5,,<empty>,63,,345,5,,void
207301,BLOCK,-1,,"{
    if (a.scale.w == SCALE_UNIT && a.scale.h == SCALE_UNIT)
        return a;

    a.x      = spu_scale_w(a.x,      a.scale);
    a.y      = spu_scale_h(a.y,      a.scale);
    a.width  = spu_scale_w(a.width,  a.scale);
    a.height = spu_scale_h(a.height, a.scale);

    a.scale = spu_scale_unit();
    return a;
}",1,,349,2,,void
207311,BLOCK,1,,<empty>,,,,1,,void
207320,BLOCK,1,,<empty>,,,,1,,void
207322,BLOCK,-1,,<empty>,9,,351,2,,void
207381,BLOCK,-1,,"{
    if (a.scale.w == s.w && a.scale.h == s.h)
        return a;

    a = spu_area_scaled(a);

    a.x      = spu_invscale_w(a.x,      s);
    a.y      = spu_invscale_h(a.y,      s);
    a.width  = spu_invscale_w(a.width,  s);
    a.height = spu_invscale_h(a.height, s);

    a.scale = s;
    return a;
}",1,,362,3,,void
207402,BLOCK,-1,,<empty>,9,,364,2,,void
207457,BLOCK,-1,,"{
    a = spu_area_scaled(a);
    b = spu_area_scaled(b);

    return __MAX(a.x, b.x) < __MIN(a.x + a.width , b.x + b.width ) &&
           __MAX(a.y, b.y) < __MIN(a.y + a.height, b.y + b.height);
}",1,,377,3,,void
207521,BLOCK,-1,,"{
    spu_area_t a = spu_area_scaled(*dst);
    bool is_moved = false;
    bool is_ok;

    /* Check for overlap
     * XXX It is not fast O(n^2) but we should not have a lot of region */
    do {
        is_ok = true;
        for (int i = 0; i < sub_count; i++) {
            spu_area_t sub = spu_area_scaled(sub_array[i]);

            if (!spu_area_overlap(a, sub))
                continue;

            if (align & SUBPICTURE_ALIGN_TOP) {
                /* We go down */
                int i_y = sub.y + sub.height;
                a.y = i_y;
                is_moved = true;
            } else if (align & SUBPICTURE_ALIGN_BOTTOM) {
                /* We go up */
                int i_y = sub.y - a.height;
                a.y = i_y;
                is_moved = true;
            } else {
                /* TODO what to do in this case? */
                //fprintf(stderr, ""Overlap with unsupported alignment\n"");
                break;
            }

            is_ok = false;
        ...",1,,390,5,,void
207534,BLOCK,-1,,"{
        is_ok = true;
        for (int i = 0; i < sub_count; i++) {
            spu_area_t sub = spu_area_scaled(sub_array[i]);

            if (!spu_area_overlap(a, sub))
                continue;

            if (align & SUBPICTURE_ALIGN_TOP) {
                /* We go down */
                int i_y = sub.y + sub.height;
                a.y = i_y;
                is_moved = true;
            } else if (align & SUBPICTURE_ALIGN_BOTTOM) {
                /* We go up */
                int i_y = sub.y - a.height;
                a.y = i_y;
                is_moved = true;
            } else {
                /* TODO what to do in this case? */
                //fprintf(stderr, ""Overlap with unsupported alignment\n"");
                break;
            }

            is_ok = false;
            break;
        }
    }",8,,397,1,,void
207539,BLOCK,-1,,<empty>,9,,399,1,,void
207549,BLOCK,4,,"{
            spu_area_t sub = spu_area_scaled(sub_array[i]);

            if (!spu_area_overlap(a, sub))
                continue;

            if (align & SUBPICTURE_ALIGN_TOP) {
                /* We go down */
                int i_y = sub.y + sub.height;
                a.y = i_y;
                is_moved = true;
            } else if (align & SUBPICTURE_ALIGN_BOTTOM) {
                /* We go up */
                int i_y = sub.y - a.height;
                a.y = i_y;
                is_moved = true;
            } else {
                /* TODO what to do in this case? */
                //fprintf(stderr, ""Overlap with unsupported alignment\n"");
                break;
            }

            is_ok = false;
            break;
        }",45,,399,4,,void
207562,BLOCK,-1,,<empty>,17,,403,2,,void
207568,BLOCK,-1,,"{
                /* We go down */
                int i_y = sub.y + sub.height;
                a.y = i_y;
                is_moved = true;
            }",47,,405,2,,void
207588,BLOCK,-1,,<empty>,20,,410,1,,void
207593,BLOCK,-1,,"{
                /* We go up */
                int i_y = sub.y - a.height;
                a.y = i_y;
                is_moved = true;
            }",57,,410,2,,void
207613,BLOCK,-1,,"{
                /* TODO what to do in this case? */
                //fprintf(stderr, ""Overlap with unsupported alignment\n"");
                break;
            }",20,,415,1,,void
207623,BLOCK,-1,,<empty>,9,,427,2,,void
207637,BLOCK,-1,,"{
    spu_area_t a = spu_area_scaled(*area);

    const int i_error_x = (a.x + a.width) - boundary->width;
    if (i_error_x > 0)
        a.x -= i_error_x;
    if (a.x < 0)
        a.x = 0;

    const int i_error_y = (a.y + a.height) - boundary->height;
    if (i_error_y > 0)
        a.y -= i_error_y;
    if (a.y < 0)
        a.y = 0;

    *area = spu_area_unscaled(a, area->scale);
}",1,,432,3,,void
207662,BLOCK,-1,,<empty>,9,,437,2,,void
207674,BLOCK,-1,,<empty>,9,,439,2,,void
207698,BLOCK,-1,,<empty>,9,,443,2,,void
207710,BLOCK,-1,,<empty>,9,,445,2,,void
207731,BLOCK,-1,,"{
    assert(region->i_x != INT_MAX && region->i_y != INT_MAX);
    if (subpic->b_absolute) {
        *x = region->i_x;
        *y = region->i_y;
    } else {
        if (region->i_align & SUBPICTURE_ALIGN_TOP)
            *y = region->i_y;
        else if (region->i_align & SUBPICTURE_ALIGN_BOTTOM)
            *y = subpic->i_original_picture_height - region->fmt.i_visible_height - region->i_y;
        else
            *y = subpic->i_original_picture_height / 2 - region->fmt.i_visible_height / 2;

        if (region->i_align & SUBPICTURE_ALIGN_LEFT)
            *x = region->i_x;
        else if (region->i_align & SUBPICTURE_ALIGN_RIGHT)
            *x = subpic->i_original_picture_width - region->fmt.i_visible_width - region->i_x;
        else
            *x = subpic->i_original_picture_width / 2 - region->fmt.i_visible_width / 2;
    }
}",1,,456,5,,void
207748,BLOCK,-1,,"{
        *x = region->i_x;
        *y = region->i_y;
    }",29,,458,2,,void
207762,BLOCK,-1,,"{
        if (region->i_align & SUBPICTURE_ALIGN_TOP)
            *y = region->i_y;
        else if (region->i_align & SUBPICTURE_ALIGN_BOTTOM)
            *y = subpic->i_original_picture_height - region->fmt.i_visible_height - region->i_y;
        else
            *y = subpic->i_original_picture_height / 2 - region->fmt.i_visible_height / 2;

        if (region->i_align & SUBPICTURE_ALIGN_LEFT)
            *x = region->i_x;
        else if (region->i_align & SUBPICTURE_ALIGN_RIGHT)
            *x = subpic->i_original_picture_width - region->fmt.i_visible_width - region->i_x;
        else
            *x = subpic->i_original_picture_width / 2 - region->fmt.i_visible_width / 2;
    }",12,,461,1,,void
207769,BLOCK,-1,,<empty>,13,,463,2,,void
207777,BLOCK,-1,,<empty>,14,,464,1,,void
207784,BLOCK,-1,,<empty>,13,,465,2,,void
207802,BLOCK,-1,,<empty>,13,,467,1,,void
207825,BLOCK,-1,,<empty>,13,,470,2,,void
207833,BLOCK,-1,,<empty>,14,,471,1,,void
207840,BLOCK,-1,,<empty>,13,,472,2,,void
207858,BLOCK,-1,,<empty>,13,,474,1,,void
207880,BLOCK,-1,,"{
    return i0 < i1 ? -1 : i0 > i1 ? 1 : 0;
}",1,,483,3,,void
207899,BLOCK,-1,,"{
    subpicture_t *subpic0 = *(subpicture_t**)s0;
    subpicture_t *subpic1 = *(subpicture_t**)s1;
    int r;

    r = IntegerCmp(!subpic0->b_absolute, !subpic1->b_absolute);
    if (!r)
        r = IntegerCmp(subpic0->i_start, subpic1->i_start);
    if (!r)
        r = IntegerCmp(subpic0->i_channel, subpic1->i_channel);
    if (!r)
        r = IntegerCmp(subpic0->i_order, subpic1->i_order);
    return r;
}",1,,498,3,,void
207929,BLOCK,-1,,<empty>,9,,505,2,,void
207942,BLOCK,-1,,<empty>,9,,507,2,,void
207955,BLOCK,-1,,<empty>,9,,509,2,,void
207976,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    /* */
    *subpicture_count = 0;

    /* Create a list of channels */
    int channel[VOUT_MAX_SUBPICTURES];
    int channel_count = 0;

    for (int index = 0; index < VOUT_MAX_SUBPICTURES; index++) {
        spu_heap_entry_t *entry = &sys->heap.entry[index];
        if (!entry->subpicture || entry->reject)
            continue;
        const int i_channel = entry->subpicture->i_channel;
        int i;
        for (i = 0; i < channel_count; i++) {
            if (channel[i] == i_channel)
                break;
        }
        if (channel_count <= i)
            channel[channel_count++] = i_channel;
    }

    /* Ensure a 1 pass garbage collection for rejected subpictures */
    if(channel_count == 0)
        channel[channel_count++] = VOUT_SPU_CHANNEL_INVALID;

    /* Fill up the subpicture_array arrays with relevant pictures */
    for (int i = 0; i < channel_count; i++) {
        subpicture_t *available_subpic[VOUT_MAX_SUBPICTURES];
     ...",1,,529,7,,void
207993,BLOCK,-1,,<empty>,5,,539,1,,void
208001,BLOCK,1,,<empty>,,,,1,,void
208009,BLOCK,4,,"{
        spu_heap_entry_t *entry = &sys->heap.entry[index];
        if (!entry->subpicture || entry->reject)
            continue;
        const int i_channel = entry->subpicture->i_channel;
        int i;
        for (i = 0; i < channel_count; i++) {
            if (channel[i] == i_channel)
                break;
        }
        if (channel_count <= i)
            channel[channel_count++] = i_channel;
    }",64,,539,4,,void
208030,BLOCK,-1,,<empty>,13,,542,2,,void
208042,BLOCK,-1,,<empty>,9,,545,1,,void
208051,BLOCK,4,,"{
            if (channel[i] == i_channel)
                break;
        }",45,,545,4,,void
208058,BLOCK,-1,,<empty>,17,,547,2,,void
208064,BLOCK,-1,,<empty>,13,,550,2,,void
208075,BLOCK,-1,,<empty>,9,,555,2,,void
208083,BLOCK,-1,,<empty>,5,,558,1,,void
208093,BLOCK,4,,"{
        subpicture_t *available_subpic[VOUT_MAX_SUBPICTURES];
        bool         is_available_late[VOUT_MAX_SUBPICTURES];
        int          available_count = 0;

        mtime_t      start_date = render_subtitle_date;
        mtime_t      ephemer_subtitle_date = 0;
        mtime_t      ephemer_osd_date = 0;
        int64_t      ephemer_subtitle_order = INT64_MIN;
        int64_t      ephemer_system_order = INT64_MIN;

        /* Select available pictures */
        for (int index = 0; index < VOUT_MAX_SUBPICTURES; index++) {
            spu_heap_entry_t *entry = &sys->heap.entry[index];
            subpicture_t *current = entry->subpicture;
            bool is_stop_valid;
            bool is_late;

            if (!current || entry->reject) {
                if (entry->reject)
                    SpuHeapDeleteAt(&sys->heap, index);
                continue;
            }

            if (current->i_channel != channel[i] ||
               (ignore_osd && !current->b_subtitle))
...",45,,558,4,,void
208121,BLOCK,-1,,<empty>,9,,570,1,,void
208129,BLOCK,1,,<empty>,,,,1,,void
208137,BLOCK,4,,"{
            spu_heap_entry_t *entry = &sys->heap.entry[index];
            subpicture_t *current = entry->subpicture;
            bool is_stop_valid;
            bool is_late;

            if (!current || entry->reject) {
                if (entry->reject)
                    SpuHeapDeleteAt(&sys->heap, index);
                continue;
            }

            if (current->i_channel != channel[i] ||
               (ignore_osd && !current->b_subtitle))
                continue;

            const mtime_t render_date = current->b_subtitle ? render_subtitle_date : render_osd_date;
            if (render_date &&
                render_date < current->i_start) {
                /* Too early, come back next monday */
                continue;
            }

            mtime_t *ephemer_date_ptr  = current->b_subtitle ? &ephemer_subtitle_date  : &ephemer_osd_date;
            int64_t *ephemer_order_ptr = current->b_subtitle ? &ephemer_subtitle_order : &ephemer_system_order;
          ...",68,,570,4,,void
208164,BLOCK,-1,,"{
                if (entry->reject)
                    SpuHeapDeleteAt(&sys->heap, index);
                continue;
            }",44,,576,2,,void
208169,BLOCK,-1,,<empty>,21,,578,2,,void
208192,BLOCK,-1,,<empty>,17,,584,2,,void
208211,BLOCK,-1,,"{
                /* Too early, come back next monday */
                continue;
            }",49,,588,2,,void
208242,BLOCK,-1,,"{
                *ephemer_date_ptr = current->i_start;
                if (current->i_order > *ephemer_order_ptr)
                    *ephemer_order_ptr = current->i_order;
            }",56,,595,2,,void
208256,BLOCK,-1,,<empty>,21,,598,2,,void
208298,BLOCK,-1,,<empty>,17,,609,2,,void
208322,BLOCK,-1,,<empty>,13,,619,2,,void
208332,BLOCK,-1,,<empty>,13,,621,2,,void
208337,BLOCK,-1,,<empty>,9,,624,1,,void
208347,BLOCK,4,,"{
            subpicture_t *current = available_subpic[index];
            bool is_late = is_available_late[index];

            const mtime_t stop_date = current->b_subtitle ? __MAX(start_date, sys->last_sort_date) : render_osd_date;
            const mtime_t ephemer_date  = current->b_subtitle ? ephemer_subtitle_date  : ephemer_osd_date;
            const int64_t ephemer_order = current->b_subtitle ? ephemer_subtitle_order : ephemer_system_order;

            /* Destroy late and obsolete ephemer subpictures */
            bool is_rejeted = is_late && current->i_stop <= stop_date;
            if (current->b_ephemer) {
                if (current->i_start < ephemer_date)
                    is_rejeted = true;
                else if (current->i_start == ephemer_date &&
                         current->i_order < ephemer_order)
                    is_rejeted = true;
            }

            if (is_rejeted)
                SpuHeapDeleteSubpicture(&sys->heap, current);
            el...",63,,624,4,,void
208405,BLOCK,-1,,"{
                if (current->i_start < ephemer_date)
                    is_rejeted = true;
                else if (current->i_start == ephemer_date &&
                         current->i_order < ephemer_order)
                    is_rejeted = true;
            }",37,,634,2,,void
208412,BLOCK,-1,,<empty>,21,,636,2,,void
208417,BLOCK,-1,,<empty>,22,,637,1,,void
208430,BLOCK,-1,,<empty>,21,,639,2,,void
208436,BLOCK,-1,,<empty>,17,,643,2,,void
208444,BLOCK,-1,,<empty>,17,,645,1,,void
208471,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    video_format_t fmt_original = region->fmt;
    bool restore_text = false;
    int x_offset;
    int y_offset;

    video_format_t region_fmt;
    picture_t *region_picture;

    /* Invalidate area by default */
    *dst_area = spu_area_create(0,0, 0,0, scale_size);
    *dst_ptr  = NULL;

    /* Render text region */
    if (region->fmt.i_chroma == VLC_CODEC_TEXT) {
        // assume rendered text is in sRGB if nothing is set
        if (region->fmt.transfer == TRANSFER_FUNC_UNDEF)
            region->fmt.transfer = TRANSFER_FUNC_SRGB;
        if (region->fmt.primaries == COLOR_PRIMARIES_UNDEF)
            region->fmt.primaries = COLOR_PRIMARIES_SRGB;
        if (region->fmt.space == COLOR_SPACE_UNDEF)
            region->fmt.space = COLOR_SPACE_SRGB;

        SpuRenderText(spu, &restore_text, region,
                      chroma_list,
                      render_date - subpic->i_start);

        /* Check if the rendering has failed ... */
   ...",1,,665,12,,void
208513,BLOCK,-1,,"{
        // assume rendered text is in sRGB if nothing is set
        if (region->fmt.transfer == TRANSFER_FUNC_UNDEF)
            region->fmt.transfer = TRANSFER_FUNC_SRGB;
        if (region->fmt.primaries == COLOR_PRIMARIES_UNDEF)
            region->fmt.primaries = COLOR_PRIMARIES_SRGB;
        if (region->fmt.space == COLOR_SPACE_UNDEF)
            region->fmt.space = COLOR_SPACE_SRGB;

        SpuRenderText(spu, &restore_text, region,
                      chroma_list,
                      render_date - subpic->i_start);

        /* Check if the rendering has failed ... */
        if (region->fmt.i_chroma == VLC_CODEC_TEXT)
            goto exit;
    }",49,,681,2,,void
208522,BLOCK,-1,,<empty>,13,,684,2,,void
208538,BLOCK,-1,,<empty>,13,,686,2,,void
208554,BLOCK,-1,,<empty>,13,,688,2,,void
208581,BLOCK,-1,,<empty>,13,,696,2,,void
208637,BLOCK,-1,,<empty>,9,,716,2,,void
208678,BLOCK,-1,,<empty>,9,,732,2,,void
208695,BLOCK,-1,,<empty>,9,,741,2,,void
208739,BLOCK,-1,,"{
        video_palette_t *old_palette = region->fmt.p_palette;
        video_palette_t new_palette;
        bool b_opaque = false;
        bool b_old_opaque = false;

        /* We suppose DVD palette here */
        new_palette.i_entries = 4;
        for (int i = 0; i < 4; i++)
        {
            for (int j = 0; j < 4; j++)
                new_palette.palette[i][j] = sys->palette[i][j];
            b_opaque |= (new_palette.palette[i][3] > 0x00);
        }

        if (old_palette->i_entries == new_palette.i_entries) {
            for (int i = 0; i < old_palette->i_entries; i++)
            {
                for (int j = 0; j < 4; j++)
                    changed_palette |= old_palette->palette[i][j] != new_palette.palette[i][j];
                b_old_opaque |= (old_palette->palette[i][3] > 0x00);
            }
        } else {
            changed_palette = true;
            b_old_opaque = true;
        }

        /* Reject or patch fully transparent broken palette used for dvd ...",24,,754,2,,void
208763,BLOCK,-1,,<empty>,9,,762,1,,void
208773,BLOCK,4,,"{
            for (int j = 0; j < 4; j++)
                new_palette.palette[i][j] = sys->palette[i][j];
            b_opaque |= (new_palette.palette[i][3] > 0x00);
        }",9,,763,4,,void
208775,BLOCK,-1,,<empty>,13,,764,1,,void
208819,BLOCK,-1,,"{
            for (int i = 0; i < old_palette->i_entries; i++)
            {
                for (int j = 0; j < 4; j++)
                    changed_palette |= old_palette->palette[i][j] != new_palette.palette[i][j];
                b_old_opaque |= (old_palette->palette[i][3] > 0x00);
            }
        }",62,,769,2,,void
208821,BLOCK,-1,,<empty>,13,,770,1,,void
208833,BLOCK,4,,"{
                for (int j = 0; j < 4; j++)
                    changed_palette |= old_palette->palette[i][j] != new_palette.palette[i][j];
                b_old_opaque |= (old_palette->palette[i][3] > 0x00);
            }",13,,771,4,,void
208835,BLOCK,-1,,<empty>,17,,772,1,,void
208874,BLOCK,-1,,"{
            changed_palette = true;
            b_old_opaque = true;
        }",16,,776,1,,void
208884,BLOCK,-1,,"{
            if( !b_old_opaque )
            {
                /* replace with new one and fixed alpha */
                old_palette->palette[1][3] = 0x80;
                old_palette->palette[2][3] = 0x80;
                old_palette->palette[3][3] = 0x80;
            }
            /* keep old visible palette */
            else changed_palette = false;
        }",9,,783,2,,void
208888,BLOCK,-1,,"{
                /* replace with new one and fixed alpha */
                old_palette->palette[1][3] = 0x80;
                old_palette->palette[2][3] = 0x80;
                old_palette->palette[3][3] = 0x80;
            }",13,,785,2,,void
208917,BLOCK,-1,,<empty>,18,,792,1,,void
208923,BLOCK,-1,,<empty>,13,,796,2,,void
208943,BLOCK,-1,,<empty>,5,,804,1,,void
208955,BLOCK,4,,"{
        if (region_fmt.i_chroma == chroma_list[i])
            convert_chroma = false;
    }",60,,804,4,,void
208964,BLOCK,-1,,<empty>,13,,806,2,,void
209000,BLOCK,1,,<empty>,,,,1,,void
209007,BLOCK,1,,<empty>,,,,1,,void
209011,BLOCK,-1,,"{
        const unsigned dst_width  = spu_scale_w(region->fmt.i_visible_width,  scale_size);
        const unsigned dst_height = spu_scale_h(region->fmt.i_visible_height, scale_size);

        /* Destroy the cache if unusable */
        if (region->p_private) {
            subpicture_region_private_t *private = region->p_private;
            bool is_changed = false;

            /* Check resize changes */
            if (dst_width  != private->fmt.i_visible_width ||
                dst_height != private->fmt.i_visible_height)
                is_changed = true;

            /* Check forced palette changes */
            if (changed_palette)
                is_changed = true;

            if (convert_chroma && private->fmt.i_chroma != chroma_list[0])
                is_changed = true;

            if (is_changed) {
                subpicture_region_private_Delete(private);
                region->p_private = NULL;
            }
        }

        /* Scale if needed into cache */
     ...",43,,813,2,,void
209036,BLOCK,-1,,"{
            subpicture_region_private_t *private = region->p_private;
            bool is_changed = false;

            /* Check resize changes */
            if (dst_width  != private->fmt.i_visible_width ||
                dst_height != private->fmt.i_visible_height)
                is_changed = true;

            /* Check forced palette changes */
            if (changed_palette)
                is_changed = true;

            if (convert_chroma && private->fmt.i_chroma != chroma_list[0])
                is_changed = true;

            if (is_changed) {
                subpicture_region_private_Delete(private);
                region->p_private = NULL;
            }
        }",32,,818,2,,void
209063,BLOCK,-1,,<empty>,17,,825,2,,void
209069,BLOCK,-1,,<empty>,17,,829,2,,void
209085,BLOCK,-1,,<empty>,17,,832,2,,void
209091,BLOCK,-1,,"{
                subpicture_region_private_Delete(private);
                region->p_private = NULL;
            }",29,,834,2,,void
209112,BLOCK,-1,,"{
            filter_t *scale = sys->scale;

            picture_t *picture = region->p_picture;
            picture_Hold(picture);

            /* Convert YUVP to YUVA/RGBA first for better scaling quality */
            if (using_palette) {
                filter_t *scale_yuvp = sys->scale_yuvp;

                scale_yuvp->fmt_in.video = region->fmt;

                scale_yuvp->fmt_out.video = region->fmt;
                scale_yuvp->fmt_out.video.i_chroma = chroma_list[0];

                picture = scale_yuvp->pf_video_filter(scale_yuvp, picture);
                if (!picture) {
                    /* Well we will try conversion+scaling */
                    msg_Warn(spu, ""%4.4s to %4.4s conversion failed"",
                             (const char*)&scale_yuvp->fmt_in.video.i_chroma,
                             (const char*)&scale_yuvp->fmt_out.video.i_chroma);
                }
            }

            /* Conversion(except from YUVP)/Scaling */
            if (picture &&
...",68,,841,2,,void
209129,BLOCK,-1,,"{
                filter_t *scale_yuvp = sys->scale_yuvp;

                scale_yuvp->fmt_in.video = region->fmt;

                scale_yuvp->fmt_out.video = region->fmt;
                scale_yuvp->fmt_out.video.i_chroma = chroma_list[0];

                picture = scale_yuvp->pf_video_filter(scale_yuvp, picture);
                if (!picture) {
                    /* Well we will try conversion+scaling */
                    msg_Warn(spu, ""%4.4s to %4.4s conversion failed"",
                             (const char*)&scale_yuvp->fmt_in.video.i_chroma,
                             (const char*)&scale_yuvp->fmt_out.video.i_chroma);
                }
            }",32,,848,2,,void
209176,BLOCK,-1,,"{
                    /* Well we will try conversion+scaling */
                    msg_Warn(spu, ""%4.4s to %4.4s conversion failed"",
                             (const char*)&scale_yuvp->fmt_in.video.i_chroma,
                             (const char*)&scale_yuvp->fmt_out.video.i_chroma);
                }",31,,857,2,,void
209223,BLOCK,-1,,"{
                scale->fmt_in.video  = picture->format;
                scale->fmt_out.video = picture->format;
                if (using_palette)
                    scale->fmt_in.video.i_chroma = chroma_list[0];
                if (convert_chroma)
                    scale->fmt_out.i_codec        =
                    scale->fmt_out.video.i_chroma = chroma_list[0];

                scale->fmt_out.video.i_width  = dst_width;
                scale->fmt_out.video.i_height = dst_height;

                scale->fmt_out.video.i_visible_width =
                    spu_scale_w(region->fmt.i_visible_width, scale_size);
                scale->fmt_out.video.i_visible_height =
                    spu_scale_h(region->fmt.i_visible_height, scale_size);

                picture = scale->pf_video_filter(scale, picture);
                if (!picture)
                    msg_Err(spu, ""scaling failed"");
            }",13,,870,2,,void
209244,BLOCK,-1,,<empty>,21,,874,2,,void
209258,BLOCK,-1,,<empty>,21,,876,2,,void
209335,BLOCK,-1,,<empty>,21,,889,2,,void
209341,BLOCK,-1,,"{
                region->p_private = subpicture_region_private_New(&picture->format);
                if (region->p_private) {
                    region->p_private->p_picture = picture;
                    if (!region->p_private->p_picture) {
                        subpicture_region_private_Delete(region->p_private);
                        region->p_private = NULL;
                    }
                } else {
                    picture_Release(picture);
                }
            }",26,,893,2,,void
209355,BLOCK,-1,,"{
                    region->p_private->p_picture = picture;
                    if (!region->p_private->p_picture) {
                        subpicture_region_private_Delete(region->p_private);
                        region->p_private = NULL;
                    }
                }",40,,895,2,,void
209370,BLOCK,-1,,"{
                        subpicture_region_private_Delete(region->p_private);
                        region->p_private = NULL;
                    }",56,,897,2,,void
209381,BLOCK,-1,,"{
                    picture_Release(picture);
                }",24,,901,1,,void
209388,BLOCK,-1,,"{
            region_fmt     = region->p_private->fmt;
            region_picture = region->p_private->p_picture;
        }",32,,908,2,,void
209405,BLOCK,-1,,"{
        int crop_x, crop_y, crop_width, crop_height;
        if(sys->force_crop){
            crop_x     = spu_scale_w(sys->crop.x, scale_size);
            crop_y     = spu_scale_h(sys->crop.y, scale_size);
            crop_width = spu_scale_w(sys->crop.width,  scale_size);
            crop_height= spu_scale_h(sys->crop.height, scale_size);
        }
        else
        {
            crop_x = x_offset;
            crop_y = y_offset;
            crop_width = region_fmt.i_visible_width;
            crop_height = region_fmt.i_visible_height;
        }

        if(region->i_max_width && spu_scale_w(region->i_max_width, scale_size) < crop_width)
            crop_width = spu_scale_w(region->i_max_width, scale_size);

        if(region->i_max_height && spu_scale_h(region->i_max_height, scale_size) < crop_height)
            crop_height = spu_scale_h(region->i_max_height, scale_size);

        /* Find the intersection */
        if (crop_x + crop_width <= x_offset ||
            x_offse...",25,,915,2,,void
209414,BLOCK,-1,,"{
            crop_x     = spu_scale_w(sys->crop.x, scale_size);
            crop_y     = spu_scale_h(sys->crop.y, scale_size);
            crop_width = spu_scale_w(sys->crop.width,  scale_size);
            crop_height= spu_scale_h(sys->crop.height, scale_size);
        }",28,,917,2,,void
209452,BLOCK,-1,,"{
            crop_x = x_offset;
            crop_y = y_offset;
            crop_width = region_fmt.i_visible_width;
            crop_height = region_fmt.i_visible_height;
        }",9,,924,1,,void
209481,BLOCK,-1,,<empty>,13,,932,2,,void
209501,BLOCK,-1,,<empty>,13,,935,2,,void
209541,BLOCK,-1,,"{
            /* No intersection */
            region_fmt.i_visible_width  =
            region_fmt.i_visible_height = 0;
        }",67,,941,2,,void
209552,BLOCK,-1,,"{
            int x, y, x_end, y_end;
            x = __MAX(crop_x, x_offset);
            y = __MAX(crop_y, y_offset);
            x_end = __MIN(crop_x + crop_width,
                          x_offset + (int)region_fmt.i_visible_width);
            y_end = __MIN(crop_y + crop_height,
                          y_offset + (int)region_fmt.i_visible_height);

            region_fmt.i_x_offset       = x - x_offset;
            region_fmt.i_y_offset       = y - y_offset;
            region_fmt.i_visible_width  = x_end - x;
            region_fmt.i_visible_height = y_end - y;

            x_offset = __MAX(x, 0);
            y_offset = __MAX(y, 0);
        }",16,,945,1,,void
209642,BLOCK,-1,,"{
        dst->i_x       = x_offset;
        dst->i_y       = y_offset;
        dst->i_align   = 0;
        if (dst->p_picture)
            picture_Release(dst->p_picture);
        dst->p_picture = picture_Hold(region_picture);
        int fade_alpha = 255;
        if (subpic->b_fade) {
            mtime_t fade_start = subpic->i_start + 3 * (subpic->i_stop - subpic->i_start) / 4;

            if (fade_start <= render_date && fade_start < subpic->i_stop)
                fade_alpha = 255 * (subpic->i_stop - render_date) /
                                   (subpic->i_stop - fade_start);
        }
        dst->i_alpha   = fade_alpha * subpic->i_alpha * region->i_alpha / 65025;
    }",14,,965,2,,void
209662,BLOCK,-1,,<empty>,13,,970,2,,void
209681,BLOCK,-1,,"{
            mtime_t fade_start = subpic->i_start + 3 * (subpic->i_stop - subpic->i_start) / 4;

            if (fade_start <= render_date && fade_start < subpic->i_stop)
                fade_alpha = 255 * (subpic->i_stop - render_date) /
                                   (subpic->i_stop - fade_start);
        }",29,,973,2,,void
209710,BLOCK,-1,,<empty>,17,,977,2,,void
209744,BLOCK,-1,,"{
        /* Some forms of subtitles need to be re-rendered more than
         * once, eg. karaoke. We therefore restore the region to its
         * pre-rendered state, so the next time through everything is
         * calculated again.
         */
        if (region->p_picture) {
            picture_Release(region->p_picture);
            region->p_picture = NULL;
        }
        if (region->p_private) {
            subpicture_region_private_Delete(region->p_private);
            region->p_private = NULL;
        }
        region->fmt = fmt_original;
    }",23,,984,2,,void
209749,BLOCK,-1,,"{
            picture_Release(region->p_picture);
            region->p_picture = NULL;
        }",32,,990,2,,void
209763,BLOCK,-1,,"{
            subpicture_region_private_Delete(region->p_private);
            region->p_private = NULL;
        }",32,,994,2,,void
209789,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    /* Count the number of regions and subtitle regions */
    unsigned int subtitle_region_count = 0;
    unsigned int region_count          = 0;
    for (unsigned i = 0; i < i_subpicture; i++) {
        const subpicture_t *subpic = pp_subpicture[i];

        unsigned count = 0;
        for (subpicture_region_t *r = subpic->p_region; r != NULL; r = r->p_next)
            count++;

        if (subpic->b_subtitle)
            subtitle_region_count += count;
        region_count += count;
    }
    if (region_count <= 0)
        return NULL;

    /* Create the output subpicture */
    subpicture_t *output = subpicture_New(NULL);
    if (!output)
        return NULL;
    output->i_order = pp_subpicture[i_subpicture - 1]->i_order;
    output->i_original_picture_width  = fmt_dst->i_visible_width;
    output->i_original_picture_height = fmt_dst->i_visible_height;
    subpicture_region_t **output_last_ptr = &output->p_region;

    /* Allocate area array ...",1,,1013,9,,void
209805,BLOCK,-1,,<empty>,5,,1019,1,,void
209815,BLOCK,4,,"{
        const subpicture_t *subpic = pp_subpicture[i];

        unsigned count = 0;
        for (subpicture_region_t *r = subpic->p_region; r != NULL; r = r->p_next)
            count++;

        if (subpic->b_subtitle)
            subtitle_region_count += count;
        region_count += count;
    }",49,,1019,4,,void
209827,BLOCK,-1,,<empty>,9,,1023,1,,void
209848,BLOCK,-1,,<empty>,13,,1027,2,,void
209859,BLOCK,-1,,<empty>,9,,1031,2,,void
209870,BLOCK,-1,,<empty>,9,,1036,2,,void
209923,BLOCK,-1,,<empty>,9,,1050,2,,void
209932,BLOCK,-1,,<empty>,5,,1053,1,,void
209942,BLOCK,4,,"{
        subpicture_t        *subpic = pp_subpicture[index];
        subpicture_region_t *region;

        if (!subpic->p_region)
            continue;

        if (subpic->i_original_picture_width  <= 0 ||
            subpic->i_original_picture_height <= 0) {
            if (subpic->i_original_picture_width  > 0 ||
                subpic->i_original_picture_height > 0)
                msg_Err(spu, ""original picture size %dx%d is unsupported"",
                         subpic->i_original_picture_width,
                         subpic->i_original_picture_height);
            else
                msg_Warn(spu, ""original picture size is undefined"");

            subpic->i_original_picture_width  = fmt_src->i_visible_width;
            subpic->i_original_picture_height = fmt_src->i_visible_height;
        }

        if (sys->text) {
            /* FIXME aspect ratio ? */
            sys->text->fmt_out.video.i_width          =
            sys->text->fmt_out.video.i_visible_width  = subpi...",65,,1053,4,,void
209955,BLOCK,-1,,<empty>,13,,1058,2,,void
209969,BLOCK,-1,,"{
            if (subpic->i_original_picture_width  > 0 ||
                subpic->i_original_picture_height > 0)
                msg_Err(spu, ""original picture size %dx%d is unsupported"",
                         subpic->i_original_picture_width,
                         subpic->i_original_picture_height);
            else
                msg_Warn(spu, ""original picture size is undefined"");

            subpic->i_original_picture_width  = fmt_src->i_visible_width;
            subpic->i_original_picture_height = fmt_src->i_visible_height;
        }",53,,1061,2,,void
209982,BLOCK,-1,,<empty>,17,,1064,2,,void
209993,BLOCK,-1,,<empty>,17,,1068,1,,void
210015,BLOCK,-1,,"{
            /* FIXME aspect ratio ? */
            sys->text->fmt_out.video.i_width          =
            sys->text->fmt_out.video.i_visible_width  = subpic->i_original_picture_width;

            sys->text->fmt_out.video.i_height         =
            sys->text->fmt_out.video.i_visible_height = subpic->i_original_picture_height;
        }",24,,1074,2,,void
210063,BLOCK,-1,,<empty>,9,,1087,1,,void
210077,BLOCK,4,,"{
            spu_area_t area;

            /* Compute region scale AR */
            video_format_t region_fmt = region->fmt;
            if (region_fmt.i_sar_num <= 0 || region_fmt.i_sar_den <= 0) {

                const uint64_t i_sar_num = (uint64_t)fmt_dst->i_visible_width  *
                                           fmt_dst->i_sar_num * subpic->i_original_picture_height;
                const uint64_t i_sar_den = (uint64_t)fmt_dst->i_visible_height *
                                           fmt_dst->i_sar_den * subpic->i_original_picture_width;

                vlc_ureduce(&region_fmt.i_sar_num, &region_fmt.i_sar_den,
                            i_sar_num, i_sar_den, 65536);
            }

            /* Compute scaling from original size to destination size
             * FIXME The current scaling ensure that the heights match, the width being
             * cropped.
             */
            spu_scale_t scale = spu_scale_createq((int64_t)fmt_dst->i_visible_height      ...",82,,1087,4,,void
210097,BLOCK,-1,,"{

                const uint64_t i_sar_num = (uint64_t)fmt_dst->i_visible_width  *
                                           fmt_dst->i_sar_num * subpic->i_original_picture_height;
                const uint64_t i_sar_den = (uint64_t)fmt_dst->i_visible_height *
                                           fmt_dst->i_sar_den * subpic->i_original_picture_width;

                vlc_ureduce(&region_fmt.i_sar_num, &region_fmt.i_sar_den,
                            i_sar_num, i_sar_den, 65536);
            }",73,,1092,2,,void
210190,BLOCK,-1,,<empty>,17,,1114,2,,void
210213,BLOCK,-1,,<empty>,17,,1123,2,,void
210225,BLOCK,-1,,"{
                area = spu_area_unscaled(area, scale);
                if (!subpic->b_absolute && area.width > 0 && area.height > 0) {
                    region->i_x = area.x;
                    region->i_y = area.y;
                }
                if (subtitle_area)
                    subtitle_area[subtitle_area_count++] = area;
            }",37,,1125,2,,void
210248,BLOCK,-1,,"{
                    region->i_x = area.x;
                    region->i_y = area.y;
                }",79,,1127,2,,void
210265,BLOCK,-1,,<empty>,21,,1132,2,,void
210280,BLOCK,-1,,<empty>,13,,1136,2,,void
210290,BLOCK,-1,,<empty>,9,,1141,2,,void
210300,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;
    vlc_value_t val;

    vlc_mutex_lock(&sys->lock);

    sys->force_palette = false;
    sys->force_crop = false;

    if (var_Get(object, ""highlight"", &val) || !val.b_bool) {
        vlc_mutex_unlock(&sys->lock);
        return;
    }

    sys->force_crop = true;
    sys->crop.x      = var_GetInteger(object, ""x-start"");
    sys->crop.y      = var_GetInteger(object, ""y-start"");
    sys->crop.width  = var_GetInteger(object, ""x-end"") - sys->crop.x;
    sys->crop.height = var_GetInteger(object, ""y-end"") - sys->crop.y;

    if (var_Get(object, ""menu-palette"", &val) == VLC_SUCCESS) {
        memcpy(sys->palette, val.p_address, 16);
        sys->force_palette = true;
    }
    vlc_mutex_unlock(&sys->lock);

    msg_Dbg(object, ""crop: %i,%i,%i,%i, palette forced: %i"",
            sys->crop.x, sys->crop.y,
            sys->crop.width, sys->crop.height,
            sys->force_palette);
}",1,,1157,3,,void
210334,BLOCK,-1,,"{
        vlc_mutex_unlock(&sys->lock);
        return;
    }",60,,1166,2,,void
210402,BLOCK,-1,,"{
        memcpy(sys->palette, val.p_address, 16);
        sys->force_palette = true;
    }",63,,1177,2,,void
210455,BLOCK,-1,,"{
    VLC_UNUSED(oldval); VLC_UNUSED(newval); VLC_UNUSED(var);

    UpdateSPU((spu_t *)data, object);
    return VLC_SUCCESS;
}",1,,1196,6,,void
210473,BLOCK,-1,,"{
    int channel = (intptr_t)filter->owner.sys;

    subpicture_t *subpicture = subpicture_New(NULL);
    if (subpicture)
        subpicture->i_channel = channel;
    return subpicture;
}",1,,1208,2,,void
210491,BLOCK,-1,,<empty>,9,,1213,2,,void
210504,BLOCK,-1,,"{
    spu_t *spu = data;
    int channel = spu_RegisterChannel(spu);

    filter->owner.sys = (void *)(intptr_t)channel;
    filter->owner.sub.buffer_new = sub_new_buffer;
    return VLC_SUCCESS;
}",1,,1218,3,,void
210541,BLOCK,-1,,"{
    spu_t *spu = data;
    int channel = (intptr_t)filter->owner.sys;

    spu_ClearChannel(spu, channel);
    return VLC_SUCCESS;
}",1,,1228,3,,void
210569,BLOCK,-1,,"{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubFilters((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1,,1243,6,,void
210590,BLOCK,-1,,"{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1,,1249,3,,void
210604,BLOCK,-1,,"{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1,,1256,3,,void
210621,BLOCK,-1,,"{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubSources((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1,,1265,6,,void
210642,BLOCK,-1,,"{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1,,1271,3,,void
210656,BLOCK,-1,,"{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1,,1278,3,,void
210670,BLOCK,-1,,"{
    spu_t *spu = vlc_custom_create(object,
                                   sizeof(spu_t) + sizeof(spu_private_t),
                                   ""subpicture"");
    if (!spu)
        return NULL;

    /* Initialize spu fields */
    spu_private_t *sys = spu->p = (spu_private_t*)&spu[1];

    /* Initialize private fields */
    vlc_mutex_init(&sys->lock);

    SpuHeapInit(&sys->heap);

    sys->text = NULL;
    sys->scale = NULL;
    sys->scale_yuvp = NULL;

    sys->margin = var_InheritInteger(spu, ""sub-margin"");

    /* Register the default subpicture channel */
    sys->channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    sys->source_chain_update = NULL;
    sys->filter_chain_update = NULL;
    vlc_mutex_init(&sys->source_chain_lock);
    vlc_mutex_init(&sys->filter_chain_lock);
    sys->source_chain = filter_chain_New(spu, ""sub source"", SPU_ES);
    sys->filter_chain = filter_chain_New(spu, ""sub filter"", SPU_ES);

    /* Load text and scale module */
    sys->text = SpuRenderCrea...",1,,1295,3,,void
210677,BLOCK,1,,<empty>,,,,3,,void
210690,BLOCK,-1,,<empty>,9,,1300,2,,void
210822,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    if (sys->text)
        FilterRelease(sys->text);

    if (sys->scale_yuvp)
        FilterRelease(sys->scale_yuvp);

    if (sys->scale)
        FilterRelease(sys->scale);

    filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
    if (sys->vout)
        filter_chain_ForEach(sys->source_chain,
                             SubSourceDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->source_chain);
    free(sys->source_chain_current);
    if (sys->vout)
        filter_chain_ForEach(sys->filter_chain,
                             SubFilterDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->filter_chain);
    free(sys->filter_chain_current);
    vlc_mutex_destroy(&sys->source_chain_lock);
    vlc_mutex_destroy(&sys->filter_chain_lock);
    free(sys->source_chain_update);
    free(sys->filter_chain_update);

    /* Destroy all remaining subpictures */
    SpuHeapClean(&sys->heap);

    vlc_mutex_destroy(&sys->lock);

    v...",1,,1352,2,,void
210833,BLOCK,-1,,<empty>,9,,1356,2,,void
210842,BLOCK,-1,,<empty>,9,,1359,2,,void
210851,BLOCK,-1,,<empty>,9,,1362,2,,void
210866,BLOCK,-1,,<empty>,9,,1366,2,,void
210887,BLOCK,-1,,<empty>,9,,1371,2,,void
210940,BLOCK,-1,,"{
    if (attach) {
        UpdateSPU(spu, input);
        var_Create(input, ""highlight"", VLC_VAR_BOOL);
        var_AddCallback(input, ""highlight"", CropCallback, spu);

        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = input;

        if (spu->p->text)
            FilterRelease(spu->p->text);
        spu->p->text = SpuRenderCreateAndLoadText(spu);

        vlc_mutex_unlock(&spu->p->lock);
    } else {
        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = NULL;
        vlc_mutex_unlock(&spu->p->lock);

        /* Delete callbacks */
        var_DelCallback(input, ""highlight"", CropCallback, spu);
        var_Destroy(input, ""highlight"");
    }
}",1,,1395,4,,void
210943,BLOCK,-1,,"{
        UpdateSPU(spu, input);
        var_Create(input, ""highlight"", VLC_VAR_BOOL);
        var_AddCallback(input, ""highlight"", CropCallback, spu);

        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = input;

        if (spu->p->text)
            FilterRelease(spu->p->text);
        spu->p->text = SpuRenderCreateAndLoadText(spu);

        vlc_mutex_unlock(&spu->p->lock);
    }",17,,1396,2,,void
210976,BLOCK,-1,,<empty>,13,,1405,2,,void
210999,BLOCK,-1,,"{
        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = NULL;
        vlc_mutex_unlock(&spu->p->lock);

        /* Delete callbacks */
        var_DelCallback(input, ""highlight"", CropCallback, spu);
        var_Destroy(input, ""highlight"");
    }",12,,1409,1,,void
211035,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->source_chain_lock);
    filter_chain_MouseEvent(sys->source_chain, mouse, fmt);
    vlc_mutex_unlock(&sys->source_chain_lock);

    return VLC_SUCCESS;
}",1,,1426,4,,void
211065,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    /* Update sub-filter chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->filter_chain_update;
    sys->filter_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    bool is_left_empty = false;

    vlc_mutex_lock(&sys->filter_chain_lock);
    if (chain_update) {
        if (*chain_update) {
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterDelProxyCallbacks,
                                     sys->vout);
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

            filter_chain_AppendFromString(spu->p->filter_chain, chain_update);
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterAddProxyCallbacks,
                                     sys->vout);
        }
        else
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

        /* ""sub-s...",1,,1445,3,,void
211104,BLOCK,-1,,"{
        if (*chain_update) {
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterDelProxyCallbacks,
                                     sys->vout);
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

            filter_chain_AppendFromString(spu->p->filter_chain, chain_update);
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterAddProxyCallbacks,
                                     sys->vout);
        }
        else
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

        /* ""sub-source""  was formerly ""sub-filter"", so now the ""sub-filter""
        configuration may contain sub-filters or sub-sources configurations.
        if the filters chain was left empty it may indicate that it's a sub-source configuration */
        is_left_empty = filter_chain_IsEmpty(spu->p->filter_chain);
    }",23,,1457,2,,void
211108,BLOCK,-1,,"{
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterDelProxyCallbacks,
                                     sys->vout);
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

            filter_chain_AppendFromString(spu->p->filter_chain, chain_update);
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterAddProxyCallbacks,
                                     sys->vout);
        }",28,,1458,2,,void
211113,BLOCK,-1,,<empty>,17,,1460,2,,void
211139,BLOCK,-1,,<empty>,17,,1467,2,,void
211149,BLOCK,-1,,<empty>,13,,1472,1,,void
211171,BLOCK,-1,,"{
        /* try to use the configuration as a sub-source configuration,
           but only if there is no 'source_chain_update' value and
           if only if 'chain_update' has a value */
        if (chain_update && *chain_update) {
            vlc_mutex_lock(&sys->lock);
            if (!sys->source_chain_update || !*sys->source_chain_update) {
                if (sys->source_chain_update)
                    free(sys->source_chain_update);
                sys->source_chain_update = chain_update;
                sys->source_chain_current = strdup(chain_update);
                chain_update = NULL;
            }
            vlc_mutex_unlock(&sys->lock);
        }
    }",24,,1481,2,,void
211177,BLOCK,-1,,"{
            vlc_mutex_lock(&sys->lock);
            if (!sys->source_chain_update || !*sys->source_chain_update) {
                if (sys->source_chain_update)
                    free(sys->source_chain_update);
                sys->source_chain_update = chain_update;
                sys->source_chain_current = strdup(chain_update);
                chain_update = NULL;
            }
            vlc_mutex_unlock(&sys->lock);
        }",44,,1485,2,,void
211194,BLOCK,-1,,"{
                if (sys->source_chain_update)
                    free(sys->source_chain_update);
                sys->source_chain_update = chain_update;
                sys->source_chain_current = strdup(chain_update);
                chain_update = NULL;
            }",74,,1487,2,,void
211199,BLOCK,-1,,<empty>,21,,1489,2,,void
211247,BLOCK,-1,,<empty>,9,,1505,2,,void
211255,BLOCK,-1,,<empty>,9,,1509,2,,void
211260,BLOCK,-1,,<empty>,5,,1512,1,,void
211293,BLOCK,-1,,"{
        vlc_mutex_unlock(&sys->lock);
        msg_Err(spu, ""subpicture heap full"");
        subpicture_Delete(subpic);
        return;
    }",42,,1517,2,,void
211320,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    /* Update sub-source chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->source_chain_update;
    sys->source_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    vlc_mutex_lock(&sys->source_chain_lock);
    if (chain_update) {
        filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
            if (sys->vout)
                filter_chain_ForEach(sys->source_chain,
                                     SubSourceDelProxyCallbacks,
                                     sys->vout);
        filter_chain_Reset(sys->source_chain, NULL, NULL);

        filter_chain_AppendFromString(spu->p->source_chain, chain_update);
        if (sys->vout)
            filter_chain_ForEach(sys->source_chain,
                                 SubSourceAddProxyCallbacks, sys->vout);
        filter_chain_ForEach(sys->source_chain, SubSourceInit, spu);

        free(chain_update);
    }
    /* Run subpicture sources */
    filter_chain...",1,,1533,8,,void
211355,BLOCK,-1,,"{
        filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
            if (sys->vout)
                filter_chain_ForEach(sys->source_chain,
                                     SubSourceDelProxyCallbacks,
                                     sys->vout);
        filter_chain_Reset(sys->source_chain, NULL, NULL);

        filter_chain_AppendFromString(spu->p->source_chain, chain_update);
        if (sys->vout)
            filter_chain_ForEach(sys->source_chain,
                                 SubSourceAddProxyCallbacks, sys->vout);
        filter_chain_ForEach(sys->source_chain, SubSourceInit, spu);

        free(chain_update);
    }",23,,1543,2,,void
211366,BLOCK,-1,,<empty>,17,,1546,2,,void
211392,BLOCK,-1,,<empty>,13,,1553,2,,void
211448,BLOCK,-1,,<empty>,9,,1581,2,,void
211477,BLOCK,-1,,"{
        vlc_mutex_unlock(&sys->lock);
        return NULL;
    }",32,,1592,2,,void
211486,BLOCK,-1,,<empty>,5,,1598,1,,void
211496,BLOCK,4,,"{
        subpicture_t *subpic = subpicture_array[i];
        subpicture_Update(subpic,
                          fmt_src, fmt_dst,
                          subpic->b_subtitle ? render_subtitle_date : render_osd_date);
    }",53,,1598,4,,void
211544,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *current = entry->subpicture;

        if (current && current->b_subtitle) {
            if (current->i_start > 0)
                current->i_start += duration;
            if (current->i_stop > 0)
                current->i_stop  += duration;
        }
    }
    vlc_mutex_unlock(&sys->lock);
}",1,,1623,3,,void
211557,BLOCK,-1,,<empty>,5,,1627,1,,void
211565,BLOCK,1,,<empty>,,,,1,,void
211573,BLOCK,4,,"{
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *current = entry->subpicture;

        if (current && current->b_subtitle) {
            if (current->i_start > 0)
                current->i_start += duration;
            if (current->i_stop > 0)
                current->i_stop  += duration;
        }
    }",52,,1627,4,,void
211597,BLOCK,-1,,"{
            if (current->i_start > 0)
                current->i_start += duration;
            if (current->i_stop > 0)
                current->i_stop  += duration;
        }",45,,1631,2,,void
211604,BLOCK,-1,,<empty>,17,,1633,2,,void
211616,BLOCK,-1,,<empty>,17,,1635,2,,void
211631,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    int channel = sys->channel++;
    vlc_mutex_unlock(&sys->lock);

    return channel;
}",1,,1642,2,,void
211662,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *subpic = entry->subpicture;

        if (!subpic)
            continue;
        if (subpic->i_channel != channel && (channel != -1 || subpic->i_channel == VOUT_SPU_CHANNEL_OSD))
            continue;

        /* You cannot delete subpicture outside of SpuSelectSubpictures */
        entry->reject = true;
    }

    vlc_mutex_unlock(&sys->lock);
}",1,,1653,3,,void
211675,BLOCK,-1,,<empty>,5,,1658,1,,void
211683,BLOCK,1,,<empty>,,,,1,,void
211691,BLOCK,4,,"{
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *subpic = entry->subpicture;

        if (!subpic)
            continue;
        if (subpic->i_channel != channel && (channel != -1 || subpic->i_channel == VOUT_SPU_CHANNEL_OSD))
            continue;

        /* You cannot delete subpicture outside of SpuSelectSubpictures */
        entry->reject = true;
    }",52,,1658,4,,void
211712,BLOCK,-1,,<empty>,13,,1663,2,,void
211731,BLOCK,-1,,<empty>,13,,1665,2,,void
211748,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->source_chain_update);
    if (filters)
    {
        sys->source_chain_update = strdup(filters);
        free(sys->source_chain_current);
        sys->source_chain_current = strdup(filters);
    }
    else if (sys->source_chain_current)
        sys->source_chain_update = strdup(sys->source_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1,,1675,3,,void
211766,BLOCK,-1,,"{
        sys->source_chain_update = strdup(filters);
        free(sys->source_chain_current);
        sys->source_chain_current = strdup(filters);
    }",5,,1682,2,,void
211784,BLOCK,-1,,<empty>,10,,1687,1,,void
211789,BLOCK,-1,,<empty>,9,,1688,2,,void
211808,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->filter_chain_update);
    if (filters)
    {
        sys->filter_chain_update = strdup(filters);
        free(sys->filter_chain_current);
        sys->filter_chain_current = strdup(filters);
    }
    else if (sys->filter_chain_current)
        sys->filter_chain_update = strdup(sys->filter_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1,,1694,3,,void
211826,BLOCK,-1,,"{
        sys->filter_chain_update = strdup(filters);
        free(sys->filter_chain_current);
        sys->filter_chain_current = strdup(filters);
    }",5,,1701,2,,void
211844,BLOCK,-1,,<empty>,10,,1706,1,,void
211849,BLOCK,-1,,<empty>,9,,1707,2,,void
211868,BLOCK,-1,,"{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    sys->margin = margin;
    vlc_mutex_unlock(&sys->lock);
}",1,,1713,3,,void
211912,BLOCK,-1,,<empty>,1,,1,1,,ANY
211917,BLOCK,-1,,"{
    vout_thread_sys_t *sys = vout->p;
    msg_Dbg(vout, ""Opening vout display wrapper"");

    /* */
    sys->display.title = var_InheritString(vout, ""video-title"");

    /* */
    const mtime_t double_click_timeout = 300000;
    const mtime_t hide_timeout = var_CreateGetInteger(vout, ""mouse-hide-timeout"") * 1000;

    if (splitter_name) {
        sys->display.vd = vout_NewSplitter(vout, &vout->p->original, state, ""$vout"", splitter_name,
                                           double_click_timeout, hide_timeout);
    } else {
        sys->display.vd = vout_NewDisplay(vout, &vout->p->original, state, ""$vout"",
                                          double_click_timeout, hide_timeout);
    }
    if (!sys->display.vd) {
        free(sys->display.title);
        return VLC_EGENERIC;
    }

    /* */
#ifdef _WIN32
    var_Create(vout, ""video-wallpaper"", VLC_VAR_BOOL|VLC_VAR_DOINHERIT);
    var_AddCallback(vout, ""video-wallpaper"", Forward, NULL);
#endif

    /* */
    sys->decoder_p...",1,,52,4,,void
211950,BLOCK,-1,,"{
        sys->display.vd = vout_NewSplitter(vout, &vout->p->original, state, ""$vout"", splitter_name,
                                           double_click_timeout, hide_timeout);
    }",24,,63,2,,void
211971,BLOCK,-1,,"{
        sys->display.vd = vout_NewDisplay(vout, &vout->p->original, state, ""$vout"",
                                          double_click_timeout, hide_timeout);
    }",12,,66,1,,void
211997,BLOCK,-1,,"{
        free(sys->display.title);
        return VLC_EGENERIC;
    }",27,,70,2,,void
212018,BLOCK,-1,,"{
    vout_thread_sys_t *sys = vout->p;

#ifdef _WIN32
    var_DelCallback(vout, ""video-wallpaper"", Forward, NULL);
#endif
    sys->decoder_pool = NULL; /* FIXME remove */

    vout_DeleteDisplay(sys->display.vd, state);
    free(sys->display.title);
}",1,,91,3,,void
212047,BLOCK,-1,,"{
    vout_thread_sys_t *sys = vout->p;

    if (sys->display.use_dr)
        sys->display_pool = vout_display_Pool(sys->display.vd, 3);
    else
        sys->display_pool = NULL;
}",1,,110,2,,void
212060,BLOCK,-1,,<empty>,9,,114,2,,void
212073,BLOCK,-1,,<empty>,9,,116,1,,void
212083,BLOCK,-1,,"{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = sys->display.vd;

    sys->display.use_dr = !vout_IsDisplayFiltered(vd);
    const bool allow_dr = !vd->info.has_pictures_invalid && !vd->info.is_slow && sys->display.use_dr;
    const unsigned private_picture  = 4; /* XXX 3 for filter, 1 for SPU */
    const unsigned decoder_picture  = 1 + sys->dpb_size;
    const unsigned kept_picture     = 1; /* last displayed picture */
    const unsigned reserved_picture = DISPLAY_PICTURE_COUNT +
                                      private_picture +
                                      kept_picture;
    const unsigned display_pool_size = allow_dr ? __MAX(VOUT_MAX_PICTURES,
                                                        reserved_picture + decoder_picture) : 3;
    picture_pool_t *display_pool = vout_display_Pool(vd, display_pool_size);
    if (display_pool == NULL)
        return VLC_EGENERIC;

#ifndef NDEBUG
    if ( picture_pool_GetSize(display_pool) < display_pool_si...",1,,120,2,,void
212151,BLOCK,1,,<empty>,,,,1,,void
212162,BLOCK,1,,<empty>,,,,1,,void
212178,BLOCK,-1,,<empty>,9,,136,2,,void
212186,BLOCK,-1,,<empty>,9,,140,2,,void
212202,BLOCK,-1,,"{
        sys->dpb_size     = picture_pool_GetSize(display_pool) - reserved_picture;
        sys->decoder_pool = display_pool;
        sys->display_pool = display_pool;
    }",83,,145,2,,void
212222,BLOCK,-1,,<empty>,12,,149,1,,void
212228,BLOCK,-1,,"{
        sys->decoder_pool =
            picture_pool_NewFromFormat(&vd->source,
                                       __MAX(VOUT_MAX_PICTURES,
                                             reserved_picture + decoder_picture - DISPLAY_PICTURE_COUNT));
        if (!sys->decoder_pool)
            return VLC_EGENERIC;
        if (allow_dr) {
            msg_Warn(vout, ""Not enough direct buffers, using system memory"");
            sys->dpb_size = 0;
        } else {
            sys->dpb_size = picture_pool_GetSize(sys->decoder_pool) - reserved_picture;
        }
        NoDrInit(vout);
    }",36,,149,2,,void
212240,BLOCK,1,,<empty>,,,,1,,void
212247,BLOCK,1,,<empty>,,,,1,,void
212254,BLOCK,-1,,<empty>,13,,155,2,,void
212259,BLOCK,-1,,"{
            msg_Warn(vout, ""Not enough direct buffers, using system memory"");
            sys->dpb_size = 0;
        }",23,,156,2,,void
212269,BLOCK,-1,,"{
            sys->dpb_size = picture_pool_GetSize(sys->decoder_pool) - reserved_picture;
        }",16,,159,1,,void
212296,BLOCK,-1,,"{
        if (sys->decoder_pool != sys->display_pool)
            picture_pool_Release(sys->decoder_pool);
        sys->display_pool = sys->decoder_pool = NULL;
        return VLC_EGENERIC;
    }",5,,166,2,,void
212305,BLOCK,-1,,<empty>,13,,168,2,,void
212327,BLOCK,-1,,"{
    vout_thread_sys_t *sys = vout->p;

    assert(vout->p->decoder_pool && vout->p->private_pool);

    picture_pool_Release(sys->private_pool);

    if (sys->decoder_pool != sys->display_pool)
        picture_pool_Release(sys->decoder_pool);
}",1,,179,2,,void
212358,BLOCK,-1,,<empty>,9,,187,2,,void
212367,BLOCK,-1,,"{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = sys->display.vd;

    bool reset_display_pool = vout_AreDisplayPicturesInvalid(vd);
    reset_display_pool |= vout_ManageDisplay(vd, !sys->display.use_dr || reset_display_pool);

    if (reset_display_pool) {
        sys->display.use_dr = !vout_IsDisplayFiltered(vd);
        NoDrInit(vout);
    }
}",1,,194,2,,void
212401,BLOCK,-1,,"{
        sys->display.use_dr = !vout_IsDisplayFiltered(vd);
        NoDrInit(vout);
    }",29,,201,2,,void
212441,BLOCK,-1,,<empty>,1,,1,1,,ANY
212450,BLOCK,-1,,"{
    int (*activate)(vout_window_t *, const vout_window_cfg_t *) = func;
    vout_window_t *wnd = va_arg(ap, vout_window_t *);
    const vout_window_cfg_t *cfg = va_arg(ap, const vout_window_cfg_t *);

    return activate(wnd, cfg);
}",1,,46,3,,void
212454,BLOCK,-1,,<empty>,,,,3,,<empty>
212472,BLOCK,-1,,"{
    window_t *w = vlc_custom_create(obj, sizeof(*w), ""window"");
    vout_window_t *window = &w->wnd;

    memset(&window->handle, 0, sizeof(window->handle));
    window->info.has_double_click = false;
    window->control = NULL;
    window->sys = NULL;

    if (owner != NULL)
        window->owner = *owner;
    else
        window->owner.resized = NULL;

    w->module = vlc_module_load(window, ""vout window"", module,
                                module && *module,
                                vout_window_start, window, cfg);
    if (!w->module) {
        vlc_object_release(window);
        return NULL;
    }

    /* Hook for screensaver inhibition */
    if (var_InheritBool(obj, ""disable-screensaver"") &&
        (window->type == VOUT_WINDOW_TYPE_XID || window->type == VOUT_WINDOW_TYPE_HWND
      || window->type == VOUT_WINDOW_TYPE_WAYLAND))
    {
        w->inhibit = vlc_inhibit_Create(VLC_OBJECT (window));
        if (w->inhibit != NULL)
            vlc_inhibit_Set(w->inhibi...",1,,57,5,,void
212520,BLOCK,-1,,<empty>,9,,67,2,,void
212528,BLOCK,-1,,<empty>,9,,69,1,,void
212556,BLOCK,-1,,"{
        vlc_object_release(window);
        return NULL;
    }",21,,74,2,,void
212583,BLOCK,-1,,"{
        w->inhibit = vlc_inhibit_Create(VLC_OBJECT (window));
        if (w->inhibit != NULL)
            vlc_inhibit_Set(w->inhibit, VLC_INHIBIT_VIDEO);
    }",5,,83,2,,void
212597,BLOCK,-1,,<empty>,13,,86,2,,void
212604,BLOCK,-1,,<empty>,9,,89,1,,void
212617,BLOCK,-1,,"{
    int (*deactivate)(vout_window_t *) = func;
    vout_window_t *wnd = va_arg(ap, vout_window_t *);

    deactivate(wnd);
}",1,,94,3,,void
212620,BLOCK,-1,,<empty>,,,,2,,<empty>
212630,BLOCK,-1,,"{
    if (!window)
        return;

    window_t *w = (window_t *)window;
    if (w->inhibit)
    {
        vlc_inhibit_Set (w->inhibit, VLC_INHIBIT_NONE);
        vlc_inhibit_Destroy (w->inhibit);
    }

    vlc_module_unload(window, w->module, vout_window_stop, window);
    vlc_object_release(window);
}",1,,102,2,,void
212634,BLOCK,-1,,<empty>,9,,104,2,,void
212646,BLOCK,-1,,"{
        vlc_inhibit_Set (w->inhibit, VLC_INHIBIT_NONE);
        vlc_inhibit_Destroy (w->inhibit);
    }",5,,108,2,,void
212670,BLOCK,-1,,"{
    window_t *w = (window_t *)window;
    unsigned flags = enabled ? VLC_INHIBIT_VIDEO : VLC_INHIBIT_NONE;

    if (w->inhibit != NULL)
        vlc_inhibit_Set(w->inhibit, flags);
}",1,,118,3,,void
212690,BLOCK,-1,,<empty>,9,,123,2,,void
212708,BLOCK,-1,,"{
    vout_display_window_t *state = window->owner.sys;

    msg_Dbg(window, ""resized to %ux%u"", width, height);
    vlc_mutex_lock(&state->lock);
    state->width = width;
    state->height = height;

    if (state->vd != NULL)
        vout_display_SendEventDisplaySize(state->vd, width, height);
    vlc_mutex_unlock(&state->lock);
}",1,,143,4,,void
212743,BLOCK,-1,,<empty>,9,,152,2,,void
212759,BLOCK,-1,,"{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;

    vout_SendEventClose(vout);
}",1,,157,2,,void
212777,BLOCK,-1,,"{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;
    vout_WindowMouseEvent(vout, mouse);
}",1,,165,3,,void
212796,BLOCK,-1,,"{
    vout_display_window_t *state = malloc(sizeof (*state));
    if (state == NULL)
        return NULL;

    state->vd = NULL;
    state->width = cfg->width;
    state->height = cfg->height;
    vlc_mutex_init(&state->lock);

    vout_window_owner_t owner = {
        .sys = state,
        .resized = vout_display_window_ResizeNotify,
        .closed = vout_display_window_CloseNotify,
        .mouse_event = vout_display_window_MouseEvent,
    };
    vout_window_t *window;

    window = vout_window_New((vlc_object_t *)vout, ""$window"", cfg, &owner);
    if (window == NULL) {
        vlc_mutex_destroy(&state->lock);
        free(state);
    }
    return window;
}",1,,175,3,,void
212808,BLOCK,-1,,<empty>,9,,178,2,,void
212839,BLOCK,1,,<empty>,9,,186,1,,void
212843,BLOCK,2,,<empty>,9,,187,2,,void
212847,BLOCK,3,,<empty>,9,,188,3,,void
212851,BLOCK,4,,<empty>,9,,189,4,,void
212870,BLOCK,-1,,"{
        vlc_mutex_destroy(&state->lock);
        free(state);
    }",25,,194,2,,void
212885,BLOCK,-1,,"{
    vout_display_window_t *state = window->owner.sys;

    vout_window_SetSize(window,
                        vd->cfg->display.width, vd->cfg->display.height);

    vlc_mutex_lock(&state->lock);
    state->vd = vd;

    vout_display_SendEventDisplaySize(vd, state->width, state->height);
    vlc_mutex_unlock(&state->lock);
}",1,,206,3,,void
212937,BLOCK,-1,,"{
    vout_display_window_t *state = window->owner.sys;

    vlc_mutex_lock(&state->lock);
    state->vd = NULL;
    vlc_mutex_unlock(&state->lock);
}",1,,224,2,,void
212965,BLOCK,-1,,"{
    vout_display_window_t *state = window->owner.sys;

    vout_window_Delete(window);

    assert(state->vd == NULL);
    vlc_mutex_destroy(&state->lock);
    free(state);
}",1,,237,2,,void
212995,BLOCK,-1,,<empty>,1,,1,1,,ANY
212999,BLOCK,-1,,<empty>,,,,3,,<empty>
213005,BLOCK,-1,,<empty>,,,,3,,<empty>
213010,BLOCK,-1,,<empty>,,,,2,,<empty>
213015,BLOCK,-1,,<empty>,,,,2,,<empty>
213050,BLOCK,-1,,<empty>,1,,1,1,,ANY
213053,BLOCK,-1,,"{
#if VLC_WINSTORE_APP
    return NULL;
#else
    /* Get our full path */
    MEMORY_BASIC_INFORMATION mbi;
    if (!VirtualQuery (config_GetLibDir, &mbi, sizeof(mbi)))
        goto error;

    wchar_t wpath[MAX_PATH];
    if (!GetModuleFileName ((HMODULE) mbi.AllocationBase, wpath, MAX_PATH))
        goto error;

    wchar_t *file = wcsrchr (wpath, L'\\');
    if (file == NULL)
        goto error;
    *file = L'\0';

    return FromWide (wpath);
error:
    abort ();
#endif
}",1,,185,2,,void
213063,BLOCK,-1,,<empty>,9,,192,2,,void
213076,BLOCK,-1,,<empty>,9,,196,2,,void
213088,BLOCK,-1,,<empty>,9,,200,2,,void
213103,BLOCK,-1,,"{
    const char *path = getenv (""VLC_DATA_PATH"");
    return (path != NULL) ? strdup (path) : config_GetLibDir ();
}",1,,210,2,,void
213121,BLOCK,-1,,"{
    wchar_t wdir[MAX_PATH];

    if (SHGetFolderPathW (NULL, csidl | CSIDL_FLAG_CREATE,
                          NULL, SHGFP_TYPE_CURRENT, wdir ) == S_OK)
        return FromWide (wdir);
    return NULL;
}",1,,216,2,,void
213134,BLOCK,-1,,<empty>,9,,221,2,,void
213144,BLOCK,-1,,"{
#if !VLC_WINSTORE_APP
    /* if portable directory exists, use it */
    TCHAR path[MAX_PATH];
    if (GetModuleFileName (NULL, path, MAX_PATH))
    {
        TCHAR *lastDir = _tcsrchr (path, '\\');
        if (lastDir)
        {
            _tcscpy (lastDir + 1, TEXT(""portable""));
            DWORD attrib = GetFileAttributes (path);
            if (attrib != INVALID_FILE_ATTRIBUTES &&
                    (attrib & FILE_ATTRIBUTE_DIRECTORY))
                return FromT (path);
        }
    }
#endif

    char *psz_dir;
    char *psz_parent = config_GetShellDir (CSIDL_APPDATA);

    if (psz_parent == NULL
     ||  asprintf (&psz_dir, ""%s\\vlc"", psz_parent) == -1)
        psz_dir = NULL;
    free (psz_parent);
    return psz_dir;
}",1,,226,2,,void
213151,BLOCK,-1,,"{
        TCHAR *lastDir = _tcsrchr (path, '\\');
        if (lastDir)
        {
            _tcscpy (lastDir + 1, TEXT(""portable""));
            DWORD attrib = GetFileAttributes (path);
            if (attrib != INVALID_FILE_ATTRIBUTES &&
                    (attrib & FILE_ATTRIBUTE_DIRECTORY))
                return FromT (path);
        }
    }",5,,231,2,,void
213160,BLOCK,-1,,"{
            _tcscpy (lastDir + 1, TEXT(""portable""));
            DWORD attrib = GetFileAttributes (path);
            if (attrib != INVALID_FILE_ATTRIBUTES &&
                    (attrib & FILE_ATTRIBUTE_DIRECTORY))
                return FromT (path);
        }",9,,234,2,,void
213180,BLOCK,-1,,<empty>,17,,239,2,,void
213203,BLOCK,-1,,<empty>,9,,249,2,,void
213215,BLOCK,-1,,"{
    switch (type)
    {
        case VLC_HOME_DIR:
            return config_GetShellDir (CSIDL_PERSONAL);
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
            return config_GetAppDir ();
        case VLC_CACHE_DIR:
#if !VLC_WINSTORE_APP
            return config_GetAppDir ();
#else
            return config_GetShellDir (CSIDL_LOCAL_APPDATA);
#endif

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
            return config_GetUserDir(VLC_HOME_DIR);
        case VLC_MUSIC_DIR:
            return config_GetShellDir (CSIDL_MYMUSIC);
        case VLC_PICTURES_DIR:
            return config_GetShellDir (CSIDL_MYPICTURES);
        case VLC_VIDEOS_DIR:
            return config_GetShellDir (CSIDL_MYVIDEO);
    }
    vlc_assert_unreachable ();
}",1,,256,2,,void
213218,BLOCK,-1,,"{
        case VLC_HOME_DIR:
            return config_GetShellDir (CSIDL_PERSONAL);
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
            return config_GetAppDir ();
        case VLC_CACHE_DIR:
#if !VLC_WINSTORE_APP
            return config_GetAppDir ();
#else
            return config_GetShellDir (CSIDL_LOCAL_APPDATA);
#endif

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
            return config_GetUserDir(VLC_HOME_DIR);
        case VLC_MUSIC_DIR:
            return config_GetShellDir (CSIDL_MYMUSIC);
        case VLC_PICTURES_DIR:
            return config_GetShellDir (CSIDL_MYPICTURES);
        case VLC_VIDEOS_DIR:
            return config_GetShellDir (CSIDL_MYVIDEO);
    }",5,,258,2,,void
213279,BLOCK,-1,,<empty>,1,,1,1,,ANY
213533,BLOCK,1,,<empty>,,,,1,,void
213562,BLOCK,-1,,"{
    /* C run-time errors */
    if ((unsigned)errnum < (unsigned)_sys_nerr)
        return _sys_errlist[errnum];

    /* Windows socket errors */
    for (const wsaerrmsg_t *e = wsaerrmsg; e->msg != NULL; e++)
        if (e->code == errnum)
            return e->msg;

    return ""Unknown error"";
}",1,,137,2,,void
213571,BLOCK,-1,,<empty>,9,,140,2,,void
213577,BLOCK,-1,,<empty>,5,,143,1,,void
213595,BLOCK,-1,,<empty>,13,,145,2,,void
213606,BLOCK,-1,,"{
    return /*vlc_gettext*/(vlc_strerror_c(errnum));
}",1,,151,2,,void
213648,BLOCK,-1,,<empty>,1,,1,1,,ANY
213651,BLOCK,-1,,"{
    wchar_t *wpath;

    errno = 0;
    wpath = ToWide (path);
    if (wpath == NULL)
    {
        if (errno == 0)
            errno = ENOENT;
        return NULL;
    }
    return wpath;
}",1,,53,2,,void
213664,BLOCK,-1,,"{
        if (errno == 0)
            errno = ENOENT;
        return NULL;
    }",5,,59,2,,void
213669,BLOCK,-1,,<empty>,13,,61,2,,void
213682,BLOCK,-1,,"{
    int mode = 0;
    va_list ap;

    flags |= O_NOINHERIT; /* O_CLOEXEC */
    /* Defaults to binary mode */
    if ((flags & O_TEXT) == 0)
        flags |= O_BINARY;

    va_start (ap, flags);
    if (flags & O_CREAT)
    {
        int unixmode = va_arg(ap, int);
        if (unixmode & 0444)
            mode |= _S_IREAD;
        if (unixmode & 0222)
            mode |= _S_IWRITE;
    }
    va_end (ap);

    /*
     * open() cannot open files with non-“ANSI” characters on Windows.
     * We use _wopen() instead. Same thing for mkdir() and stat().
     */
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int fd = _wopen (wpath, flags, mode);
    free (wpath);
    return fd;
}",1,,73,3,,void
213697,BLOCK,-1,,<empty>,9,,80,2,,void
213708,BLOCK,-1,,"{
        int unixmode = va_arg(ap, int);
        if (unixmode & 0444)
            mode |= _S_IREAD;
        if (unixmode & 0222)
            mode |= _S_IWRITE;
    }",5,,84,2,,void
213714,BLOCK,-1,,<empty>,13,,87,2,,void
213722,BLOCK,-1,,<empty>,13,,89,2,,void
213737,BLOCK,-1,,<empty>,9,,99,2,,void
213758,BLOCK,-1,,"{
    (void) dir; (void) filename; (void) flags;
    errno = ENOSYS;
    return -1;
}",1,,107,4,,void
213778,BLOCK,-1,,"{
#if 0
    int fd, err;

    FILE *stream = tmpfile();
    if (stream == NULL)
        return -1;

    fd = vlc_dup(fileno(stream));
    err = errno;
    fclose(stream);
    errno = err;
    return fd;
#else /* Not currently used */
    errno = ENOSYS;
    return -1;
#endif
}",1,,114,2,,void
213789,BLOCK,-1,,"{
    return close (fd);
}",1,,134,2,,void
213798,BLOCK,-1,,"{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return -1;

    int ret = _wmkdir (wpath);
    free (wpath);
    (void) mode;
    return ret;
}",1,,139,3,,void
213808,BLOCK,-1,,<empty>,9,,142,2,,void
213828,BLOCK,-1,,"{
#if VLC_WINSTORE_APP
    return NULL;
#else
    wchar_t *wdir = _wgetcwd (NULL, 0);
    if (wdir == NULL)
        return NULL;

    char *dir = FromWide (wdir);
    free (wdir);
    return dir;
#endif
}",1,,151,2,,void
213839,BLOCK,-1,,<empty>,9,,157,2,,void
213855,BLOCK,-1,,"{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return NULL;

    vlc_DIR *p_dir = malloc (sizeof (*p_dir));
    if (unlikely(p_dir == NULL))
    {
        free(wpath);
        return NULL;
    }

#if !VLC_WINSTORE_APP
    /* Special mode to list drive letters */
    if (wpath[0] == L'\0' || (wcscmp (wpath, L""\\"") == 0))
    {
        free (wpath);
        p_dir->wdir = NULL;
        p_dir->u.drives = GetLogicalDrives ();
        p_dir->entry = NULL;
        return (void *)p_dir;
    }
#endif

    assert (wpath[0]); // wpath[1] is defined
    p_dir->u.insert_dot_dot = !wcscmp (wpath + 1, L"":\\"");

    _WDIR *wdir = _wopendir (wpath);
    free (wpath);
    if (wdir == NULL)
    {
        free (p_dir);
        return NULL;
    }
    p_dir->wdir = wdir;
    p_dir->entry = NULL;
    return (void *)p_dir;
}",1,,168,2,,void
213865,BLOCK,-1,,<empty>,9,,171,2,,void
213880,BLOCK,-1,,"{
        free(wpath);
        return NULL;
    }",5,,175,2,,void
213897,BLOCK,-1,,"{
        free (wpath);
        p_dir->wdir = NULL;
        p_dir->u.drives = GetLogicalDrives ();
        p_dir->entry = NULL;
        return (void *)p_dir;
    }",5,,183,2,,void
213948,BLOCK,-1,,"{
        free (p_dir);
        return NULL;
    }",5,,198,2,,void
213971,BLOCK,-1,,"{
    vlc_DIR *p_dir = (vlc_DIR *)dir;

    free(p_dir->entry);

#if !VLC_WINSTORE_APP
    /* Drive letters mode */
    if (p_dir->wdir == NULL)
    {
        DWORD drives = p_dir->u.drives;
        if (drives == 0)
        {
            p_dir->entry = NULL;
            return NULL; /* end */
        }

        unsigned int i;
        for (i = 0; !(drives & 1); i++)
            drives >>= 1;
        p_dir->u.drives &= ~(1UL << i);
        assert (i < 26);

        if (asprintf (&p_dir->entry, ""%c:\\"", 'A' + i) == -1)
            p_dir->entry = NULL;
    }
    else
#endif
    if (p_dir->u.insert_dot_dot)
    {
        /* Adds "".."", gruik! */
        p_dir->u.insert_dot_dot = false;
        p_dir->entry = strdup ("".."");
    }
    else
    {
        struct _wdirent *ent = _wreaddir (p_dir->wdir);
        p_dir->entry = (ent != NULL) ? FromWide (ent->d_name) : NULL;
    }
    return p_dir->entry;
}",1,,208,2,,void
213988,BLOCK,-1,,"{
        DWORD drives = p_dir->u.drives;
        if (drives == 0)
        {
            p_dir->entry = NULL;
            return NULL; /* end */
        }

        unsigned int i;
        for (i = 0; !(drives & 1); i++)
            drives >>= 1;
        p_dir->u.drives &= ~(1UL << i);
        assert (i < 26);

        if (asprintf (&p_dir->entry, ""%c:\\"", 'A' + i) == -1)
            p_dir->entry = NULL;
    }",5,,216,2,,void
214001,BLOCK,-1,,"{
            p_dir->entry = NULL;
            return NULL; /* end */
        }",9,,219,2,,void
214011,BLOCK,-1,,<empty>,9,,225,1,,void
214051,BLOCK,-1,,<empty>,13,,231,2,,void
214058,BLOCK,-1,,<empty>,5,,235,1,,void
214065,BLOCK,-1,,"{
        /* Adds "".."", gruik! */
        p_dir->u.insert_dot_dot = false;
        p_dir->entry = strdup ("".."");
    }",5,,236,2,,void
214080,BLOCK,-1,,"{
        struct _wdirent *ent = _wreaddir (p_dir->wdir);
        p_dir->entry = (ent != NULL) ? FromWide (ent->d_name) : NULL;
    }",5,,242,1,,void
214110,BLOCK,-1,,"{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    static_assert (sizeof (*buf) == sizeof (struct _stati64),
                   ""Mismatched struct stat definition."");

    int ret = _wstati64 (wpath, buf);
    free (wpath);
    return ret;
}",1,,250,3,,void
214120,BLOCK,-1,,<empty>,9,,253,2,,void
214147,BLOCK,-1,,"{
    return vlc_stat (filename, buf);
}",1,,264,3,,void
214156,BLOCK,-1,,"{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int ret = _wunlink (wpath);
    free (wpath);
    return ret;
}",1,,269,2,,void
214166,BLOCK,-1,,<empty>,9,,272,2,,void
214184,BLOCK,-1,,"{
    int ret = -1;

    wchar_t *wold = widen_path (oldpath), *wnew = widen_path (newpath);
    if (wold == NULL || wnew == NULL)
        goto out;

    if (_wrename (wold, wnew) && (errno == EACCES || errno == EEXIST))
    {   /* Windows does not allow atomic file replacement */
        if (_wremove (wnew))
        {
            errno = EACCES; /* restore errno */
            goto out;
        }
        if (_wrename (wold, wnew))
            goto out;
    }
    ret = 0;
out:
    free (wnew);
    free (wold);
    return ret;
}",1,,280,3,,void
214208,BLOCK,-1,,<empty>,9,,285,2,,void
214222,BLOCK,-1,,"{   /* Windows does not allow atomic file replacement */
        if (_wremove (wnew))
        {
            errno = EACCES; /* restore errno */
            goto out;
        }
        if (_wrename (wold, wnew))
            goto out;
    }",5,,288,2,,void
214226,BLOCK,-1,,"{
            errno = EACCES; /* restore errno */
            goto out;
        }",9,,290,2,,void
214235,BLOCK,-1,,<empty>,13,,295,2,,void
214251,BLOCK,-1,,"{
    int fd = dup (oldfd);
    if (fd != -1)
        setmode (fd, O_BINARY);
    return fd;
}",1,,305,2,,void
214262,BLOCK,-1,,<empty>,9,,308,2,,void
214272,BLOCK,-1,,"{
#if VLC_WINSTORE_APP
    _set_errno(EPERM);
    return -1;
#else
    return _pipe (fds, 32768, O_NOINHERIT | O_BINARY);
#endif
}",1,,313,2,,void
214286,BLOCK,-1,,"{
    return write(fd, buf, len);
}",1,,323,4,,void
214298,BLOCK,-1,,"{
    vlc_assert_unreachable();
}",1,,328,4,,void
214307,BLOCK,-1,,"{
    int fd = socket (pf, type, proto);
    if (fd == -1)
        return -1;

    if (nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",1,,335,5,,void
214320,BLOCK,-1,,<empty>,9,,338,2,,void
214326,BLOCK,-1,,<empty>,9,,341,2,,void
214345,BLOCK,-1,,"{
    (void) pf; (void) type; (void) proto; (void) fds; (void) nonblock;
    errno = ENOSYS;
    return -1;
}",1,,346,6,,void
214374,BLOCK,-1,,"{
    int fd = accept (lfd, addr, alen);
    if (fd != -1 && nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",1,,353,5,,void
214389,BLOCK,-1,,<empty>,9,,356,2,,void
214404,BLOCK,-1,,"{
    TCHAR tmp_path[MAX_PATH-14];
    int i_ret = GetTempPath (MAX_PATH-14, tmp_path);
    if (i_ret == 0)
        return NULL;

    TCHAR tmp_name[MAX_PATH];
    i_ret = GetTempFileName(tmp_path, TEXT(""VLC""), 0, tmp_name);
    if (i_ret == 0)
        return NULL;

    HANDLE hFile = CreateFile(tmp_name,
            GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS,
            FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return NULL;

    int fd = _open_osfhandle((intptr_t)hFile, 0);
    if (fd == -1) {
        CloseHandle(hFile);
        return NULL;
    }

    FILE *stream = _fdopen(fd, ""w+b"");
    if (stream == NULL) {
        _close(fd);
        return NULL;
    }
    return stream;
}",1,,362,2,,void
214418,BLOCK,-1,,<empty>,9,,366,2,,void
214434,BLOCK,-1,,<empty>,9,,371,2,,void
214458,BLOCK,-1,,<empty>,9,,377,2,,void
214474,BLOCK,-1,,"{
        CloseHandle(hFile);
        return NULL;
    }",19,,380,2,,void
214489,BLOCK,-1,,"{
        _close(fd);
        return NULL;
    }",25,,386,2,,void
214510,BLOCK,-1,,<empty>,1,,1,1,,ANY
214519,BLOCK,-1,,"{
    vlc_mta_holder* p_mta = (vlc_mta_holder*)opaque;
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    vlc_sem_post( &p_mta->ready_sem );

    vlc_sem_wait( &p_mta->release_sem );

    CoUninitialize();
    return NULL;
}",1,,41,2,,void
214546,BLOCK,-1,,"{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder* p_mta = (vlc_mta_holder*)var_CreateGetAddress( p_parent->obj.libvlc, ""mta-holder"" );
    if ( p_mta == NULL )
    {
        p_mta = (vlc_mta_holder*)malloc( sizeof( *p_mta ) );
        if ( unlikely( p_mta == NULL ) )
        {
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        vlc_sem_init( &p_mta->ready_sem, 0 );
        vlc_sem_init( &p_mta->release_sem, 0 );
        p_mta->i_refcount = 1;
        if ( vlc_clone( &p_mta->thread, MtaMainLoop, p_mta, VLC_THREAD_PRIORITY_LOW ) )
        {
            vlc_sem_destroy( &p_mta->release_sem );
            vlc_sem_destroy( &p_mta->ready_sem );
            free( p_mta );
            p_mta = NULL;
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", p_mta );
        vlc_sem_wait( &p_mta->ready_sem );
    }
    else
        ++p_mta->i_refcount;
    vlc...",1,,63,2,,void
214565,BLOCK,-1,,"{
        p_mta = (vlc_mta_holder*)malloc( sizeof( *p_mta ) );
        if ( unlikely( p_mta == NULL ) )
        {
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        vlc_sem_init( &p_mta->ready_sem, 0 );
        vlc_sem_init( &p_mta->release_sem, 0 );
        p_mta->i_refcount = 1;
        if ( vlc_clone( &p_mta->thread, MtaMainLoop, p_mta, VLC_THREAD_PRIORITY_LOW ) )
        {
            vlc_sem_destroy( &p_mta->release_sem );
            vlc_sem_destroy( &p_mta->ready_sem );
            free( p_mta );
            p_mta = NULL;
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", p_mta );
        vlc_sem_wait( &p_mta->ready_sem );
    }",5,,67,2,,void
214579,BLOCK,-1,,"{
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }",9,,70,2,,void
214610,BLOCK,-1,,"{
            vlc_sem_destroy( &p_mta->release_sem );
            vlc_sem_destroy( &p_mta->ready_sem );
            free( p_mta );
            p_mta = NULL;
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }",9,,78,2,,void
214644,BLOCK,-1,,<empty>,9,,90,1,,void
214657,BLOCK,-1,,"{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder *p_mta = (vlc_mta_holder*)var_InheritAddress( p_parent->obj.libvlc, ""mta-holder"" );
    assert( p_mta != NULL );
    int i_refcount = --p_mta->i_refcount;
    if ( i_refcount == 0 )
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", NULL );
    vlc_global_unlock( VLC_MTA_MUTEX );
    if ( i_refcount == 0 )
    {
        vlc_sem_post( &p_mta->release_sem );

        vlc_join( p_mta->thread, NULL );

        vlc_sem_destroy( &p_mta->release_sem );
        vlc_sem_destroy( &p_mta->ready_sem );
        free( p_mta );
    }
}",1,,101,2,,void
214687,BLOCK,-1,,<empty>,9,,107,2,,void
214702,BLOCK,-1,,"{
        vlc_sem_post( &p_mta->release_sem );

        vlc_join( p_mta->thread, NULL );

        vlc_sem_destroy( &p_mta->release_sem );
        vlc_sem_destroy( &p_mta->ready_sem );
        free( p_mta );
    }",5,,110,2,,void
214743,BLOCK,-1,,<empty>,1,,1,1,,ANY
214746,BLOCK,-1,,"{
    VLC_UNUSED(psz_url);

    char *proxy = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy"" );
    if (proxy == NULL)
        return NULL;

    char *proxy_pwd = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy-pwd"" );
    if (proxy_pwd == NULL)
        return proxy;

    vlc_url_t url;
    if (vlc_UrlParse(&url, proxy) < 0) {
        vlc_UrlClean(&url);
        free (proxy);
        free (proxy_pwd);
        return NULL;
    }

    if (url.psz_password == NULL )
        url.psz_password = proxy_pwd;

    char *proxy_url = vlc_uri_compose (&url);
    vlc_UrlClean (&url);

    free (proxy_pwd);
    free (proxy);

#if 0
    /* Try to get the proxy server address from Windows internet settings. */
    HKEY h_key;

    /* Open the key */
    if( RegOpenKeyEx( HKEY_CURRENT_USER, ""Software\\Microsoft""
                      ""\\Windows\\CurrentVersion\\Internet Settings"",
                      0, KEY_READ, &h_key ) == ERROR_SUCCESS )
        return NULL;

    DWORD len = sizeof( DWO...",1,,33,2,,void
214761,BLOCK,-1,,<empty>,9,,38,2,,void
214776,BLOCK,-1,,<empty>,9,,42,2,,void
214787,BLOCK,-1,,"{
        vlc_UrlClean(&url);
        free (proxy);
        free (proxy_pwd);
        return NULL;
    }",40,,45,2,,void
214803,BLOCK,-1,,<empty>,9,,53,2,,void
214842,BLOCK,-1,,<empty>,1,,1,1,,ANY
214846,BLOCK,-1,,"{
    wchar_t wmsg[256];
    int i = 0, i_error = GetLastError();

    FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL, i_error, MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
                    wmsg, 256, NULL );

    /* Go to the end of the string */
    while( !wmemchr( L""\r\n\0"", wmsg[i], 3 ) )
        i++;

    snwprintf( wmsg + i, 256 - i, L"" (error %i)"", i_error );
    return FromWide( wmsg );
}",1,,78,2,,void
214897,BLOCK,-1,,"{
    wchar_t *wfile = ToWide (psz_file);
    if (wfile == NULL)
        return -1;

    module_handle_t handle = NULL;
#if !VLC_WINSTORE_APP
    DWORD mode;
    if (SetThreadErrorMode (SEM_FAILCRITICALERRORS, &mode) != 0)
    {
        handle = LoadLibraryExW (wfile, NULL, LoadLibraryFlags );
        SetThreadErrorMode (mode, NULL);
    }
#else
    handle = LoadPackagedLibrary( wfile, 0 );
#endif
    free (wfile);

    if( handle == NULL )
    {
        char *psz_err = GetWindowsError();
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", psz_file, psz_err );
        free( psz_err );
        return -1;
    }

    *p_handle = handle;
    (void) lazy;
    return 0;
}",1,,96,5,,void
214907,BLOCK,-1,,<empty>,9,,99,2,,void
214923,BLOCK,-1,,"{
        handle = LoadLibraryExW (wfile, NULL, LoadLibraryFlags );
        SetThreadErrorMode (mode, NULL);
    }",5,,105,2,,void
214939,BLOCK,-1,,"{
        char *psz_err = GetWindowsError();
        msg_Warn( p_this, ""cannot load module `%s' (%s)"", psz_file, psz_err );
        free( psz_err );
        return -1;
    }",5,,115,2,,void
214967,BLOCK,-1,,"{
    FreeLibrary( handle );
}",1,,128,2,,void
214975,BLOCK,-1,,"{
    return (void *)GetProcAddress( handle, (char *)psz_function );
}",1,,133,3,,void
215004,BLOCK,-1,,<empty>,1,,1,1,,ANY
215008,BLOCK,-1,,"{
    size_t count = len;
    uint8_t *p_buf = (uint8_t *)buf;

    /* fill buffer with pseudo-random data */
    while (count > 0)
    {
        unsigned int val;
        val = rand();
        if (count < sizeof (val))
        {
            memcpy (p_buf, &val, count);
            break;
        }

        memcpy (p_buf, &val, sizeof (val));
        count -= sizeof (val);
        p_buf += sizeof (val);
    }

#if VLC_WINSTORE_APP
    static const WCHAR *className = L""Windows.Security.Cryptography.CryptographicBuffer"";
    const UINT32 clen = wcslen(className);

    HSTRING hClassName = NULL;
    HSTRING_HEADER header;
    HRESULT hr = WindowsCreateStringReference(className, clen, &header, &hClassName);
    if (hr) {
        WindowsDeleteString(hClassName);
        return;
    }

    ICryptographicBufferStatics *cryptoStatics = NULL;
    hr = RoGetActivationFactory(hClassName, &IID_ICryptographicBufferStatics, (void**)&cryptoStatics);
    WindowsDeleteString(hClassName);

    if (hr...",1,,40,3,,void
215023,BLOCK,-1,,"{
        unsigned int val;
        val = rand();
        if (count < sizeof (val))
        {
            memcpy (p_buf, &val, count);
            break;
        }

        memcpy (p_buf, &val, sizeof (val));
        count -= sizeof (val);
        p_buf += sizeof (val);
    }",5,,46,2,,void
215033,BLOCK,-1,,"{
            memcpy (p_buf, &val, count);
            break;
        }",9,,50,2,,void
215063,BLOCK,-1,,"{
        /* fill buffer with pseudo-random data, initial buffer content
           is used as auxiliary random seed */
        CryptGenRandom(hProv, len, buf);
        CryptReleaseContext(hProv, 0);
    }",5,,102,2,,void
215091,BLOCK,-1,,<empty>,1,,1,1,,ANY
215099,BLOCK,-1,,"{
    WSADATA data;

    if (WSAStartup(MAKEWORD(hi, lo), &data) == 0)
    {
        if (LOBYTE(data.wVersion) == 2 && HIBYTE(data.wVersion) == 2)
            return 0;
        /* Winsock DLL is not usable */
        WSACleanup( );
    }
    return -1;
}",1,,45,3,,void
215110,BLOCK,-1,,"{
        if (LOBYTE(data.wVersion) == 2 && HIBYTE(data.wVersion) == 2)
            return 0;
        /* Winsock DLL is not usable */
        WSACleanup( );
    }",5,,49,2,,void
215125,BLOCK,-1,,<empty>,13,,51,2,,void
215136,BLOCK,-1,,"{
    if (system_InitWSA(2, 2) && system_InitWSA(1, 1))
        fputs(""Error: cannot initialize Winsocks\n"", stderr);

#if !VLC_WINSTORE_APP
# if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    if (GetProcAddress(GetModuleHandle(TEXT(""kernel32.dll"")),
                                       ""SetDefaultDllDirectories"") != NULL)
# endif /* FIXME: not reentrant */
        LoadLibraryFlags = LOAD_LIBRARY_SEARCH_SYSTEM32;
#endif
}",1,,62,2,,void
215145,BLOCK,-1,,<empty>,9,,64,2,,void
215159,BLOCK,-1,,<empty>,,,,1,,<empty>
215168,BLOCK,-1,,"{
#if !VLC_WINSTORE_APP
    if( var_InheritBool( p_this, ""one-instance"" )
     || ( var_InheritBool( p_this, ""one-instance-when-started-from-file"" )
       && var_InheritBool( p_this, ""started-from-file"" ) ) )
    {
        HANDLE hmutex;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named mutex to check if another instance is already running */
        if( !( hmutex = CreateMutex( 0, TRUE, L""VLC ipc "" TEXT(VERSION) ) ) )
        {
            /* Failed for some reason. Just ignore the option and go on as
             * normal. */
            msg_Err( p_this, ""one instance mode DISABLED ""
                     ""(mutex couldn't be created)"" );
            return;
        }

        if( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            libvlc_InternalAddIntf( p_this, ""win_msg,none"" );
            /* Initialization done.
             * Release the mutex to unblock other instances */
            ReleaseMutex( hmutex );
        }
        else
    ...",1,,88,4,,void
215181,BLOCK,-1,,"{
        HANDLE hmutex;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named mutex to check if another instance is already running */
        if( !( hmutex = CreateMutex( 0, TRUE, L""VLC ipc "" TEXT(VERSION) ) ) )
        {
            /* Failed for some reason. Just ignore the option and go on as
             * normal. */
            msg_Err( p_this, ""one instance mode DISABLED ""
                     ""(mutex couldn't be created)"" );
            return;
        }

        if( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            libvlc_InternalAddIntf( p_this, ""win_msg,none"" );
            /* Initialization done.
             * Release the mutex to unblock other instances */
            ReleaseMutex( hmutex );
        }
        else
        {
            /* Another instance is running */

            HWND ipcwindow;

            /* Wait until the 1st instance is initialized */
            WaitForSingleObject( hmutex, INFINITE );

            /* Lo...",5,,93,2,,void
215188,BLOCK,-1,,"{
            /* Failed for some reason. Just ignore the option and go on as
             * normal. */
            msg_Err( p_this, ""one instance mode DISABLED ""
                     ""(mutex couldn't be created)"" );
            return;
        }",9,,100,2,,void
215197,BLOCK,-1,,"{
            libvlc_InternalAddIntf( p_this, ""win_msg,none"" );
            /* Initialization done.
             * Release the mutex to unblock other instances */
            ReleaseMutex( hmutex );
        }",9,,109,2,,void
215204,BLOCK,-1,,"{
            /* Another instance is running */

            HWND ipcwindow;

            /* Wait until the 1st instance is initialized */
            WaitForSingleObject( hmutex, INFINITE );

            /* Locate the window created by the IPC helper thread of the
             * 1st instance */
            if( !( ipcwindow = FindWindow( 0, L""VLC ipc "" TEXT(VERSION) ) ) )
            {
                msg_Err( p_this, ""one instance mode DISABLED ""
                         ""(couldn't find 1st instance of program)"" );
                ReleaseMutex( hmutex );
                return;
            }

            /* We assume that the remaining parameters are filenames
             * and their input options */
            if( i_argc > 0 )
            {
                COPYDATASTRUCT wm_data;
                int i_opt;
                vlc_ipc_data_t *p_data;
                size_t i_data = sizeof (*p_data);

                for( i_opt = 0; i_opt < i_argc; i_opt++ )
                {
        ...",9,,116,1,,void
215211,BLOCK,-1,,"{
                msg_Err( p_this, ""one instance mode DISABLED ""
                         ""(couldn't find 1st instance of program)"" );
                ReleaseMutex( hmutex );
                return;
            }",13,,127,2,,void
215222,BLOCK,-1,,"{
                COPYDATASTRUCT wm_data;
                int i_opt;
                vlc_ipc_data_t *p_data;
                size_t i_data = sizeof (*p_data);

                for( i_opt = 0; i_opt < i_argc; i_opt++ )
                {
                    i_data += sizeof (size_t);
                    i_data += strlen( ppsz_argv[ i_opt ] ) + 1;
                }

                p_data = malloc( i_data );
                p_data->argc = i_argc;
                p_data->enqueue = var_InheritBool( p_this, ""playlist-enqueue"" );
                i_data = 0;
                for( i_opt = 0; i_opt < i_argc; i_opt++ )
                {
                    size_t i_len = strlen( ppsz_argv[ i_opt ] ) + 1;
                    /* Windows will never switch to an architecture
                     * with stronger alignment requirements, right. */
                    *((size_t *)(p_data->data + i_data)) = i_len;
                    i_data += sizeof (size_t);
                    memcpy( &p_data->data[i...",13,,137,2,,void
215233,BLOCK,-1,,<empty>,17,,143,1,,void
215242,BLOCK,4,,"{
                    i_data += sizeof (size_t);
                    i_data += strlen( ppsz_argv[ i_opt ] ) + 1;
                }",17,,144,4,,void
215275,BLOCK,-1,,<empty>,17,,153,1,,void
215284,BLOCK,4,,"{
                    size_t i_len = strlen( ppsz_argv[ i_opt ] ) + 1;
                    /* Windows will never switch to an architecture
                     * with stronger alignment requirements, right. */
                    *((size_t *)(p_data->data + i_data)) = i_len;
                    i_data += sizeof (size_t);
                    memcpy( &p_data->data[i_data], ppsz_argv[ i_opt ], i_len );
                    i_data += i_len;
                }",17,,154,4,,void
215358,BLOCK,-1,,"{
    /* XXX: In theory, we should not call this if WSAStartup() failed. */
    WSACleanup();
}",1,,188,2,,void
215388,BLOCK,-1,,<empty>,1,,1,1,,ANY
215399,BLOCK,-1,,<empty>,,,,2,,<empty>
215409,BLOCK,-1,,"{
    /* This creates a recursive mutex. This is OK as fast mutexes have
     * no defined behavior in case of recursive locking. */
    InitializeCriticalSection (&p_mutex->mutex);
    p_mutex->dynamic = true;
}",1,,101,2,,void
215424,BLOCK,-1,,"{
    InitializeCriticalSection( &p_mutex->mutex );
    p_mutex->dynamic = true;
}",1,,109,2,,void
215439,BLOCK,-1,,"{
    assert (p_mutex->dynamic);
    DeleteCriticalSection (&p_mutex->mutex);
}",1,,116,2,,void
215453,BLOCK,-1,,"{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            SleepConditionVariableCS(&super_variable, &super_mutex, INFINITE);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        LeaveCriticalSection(&super_mutex);
        return;
    }

    EnterCriticalSection (&p_mutex->mutex);
}",1,,122,2,,void
215459,BLOCK,-1,,"{   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            SleepConditionVariableCS(&super_variable, &super_mutex, INFINITE);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        LeaveCriticalSection(&super_mutex);
        return;
    }",5,,124,2,,void
215467,BLOCK,-1,,"{
            p_mutex->contention++;
            SleepConditionVariableCS(&super_variable, &super_mutex, INFINITE);
            p_mutex->contention--;
        }",9,,127,2,,void
215500,BLOCK,-1,,"{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int ret = EBUSY;

        EnterCriticalSection(&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        LeaveCriticalSection(&super_mutex);
        return ret;
    }

    return TryEnterCriticalSection (&p_mutex->mutex) ? 0 : EBUSY;
}",1,,141,2,,void
215506,BLOCK,-1,,"{   /* static mutexes */
        int ret = EBUSY;

        EnterCriticalSection(&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        LeaveCriticalSection(&super_mutex);
        return ret;
    }",5,,143,2,,void
215519,BLOCK,-1,,"{
            p_mutex->locked = true;
            ret = 0;
        }",9,,148,2,,void
215546,BLOCK,-1,,"{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            WakeAllConditionVariable(&super_variable);
        LeaveCriticalSection(&super_mutex);
        return;
    }

    LeaveCriticalSection (&p_mutex->mutex);
}",1,,160,2,,void
215552,BLOCK,-1,,"{   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            WakeAllConditionVariable(&super_variable);
        LeaveCriticalSection(&super_mutex);
        return;
    }",5,,162,2,,void
215569,BLOCK,-1,,<empty>,13,,167,2,,void
215588,BLOCK,-1,,<empty>,,,,2,,<empty>
215602,BLOCK,-1,,"{
    struct vlc_threadvar *var = malloc (sizeof (*var));
    if (unlikely(var == NULL))
        return errno;

    var->id = TlsAlloc();
    if (var->id == TLS_OUT_OF_INDEXES)
    {
        free (var);
        return EAGAIN;
    }
    var->destroy = destr;
    var->next = NULL;
    *p_tls = var;

    EnterCriticalSection(&super_mutex);
    var->prev = vlc_threadvar_last;
    if (var->prev)
        var->prev->next = var;

    vlc_threadvar_last = var;
    LeaveCriticalSection(&super_mutex);
    return 0;
}",1,,236,3,,void
215615,BLOCK,-1,,<empty>,9,,239,2,,void
215629,BLOCK,-1,,"{
        free (var);
        return EAGAIN;
    }",5,,243,2,,void
215660,BLOCK,-1,,<empty>,9,,254,2,,void
215680,BLOCK,-1,,"{
    struct vlc_threadvar *var = *p_tls;

    EnterCriticalSection(&super_mutex);
    if (var->prev != NULL)
        var->prev->next = var->next;

    if (var->next != NULL)
        var->next->prev = var->prev;
    else
        vlc_threadvar_last = var->prev;

    LeaveCriticalSection(&super_mutex);

    TlsFree (var->id);
    free (var);
}",1,,262,2,,void
215695,BLOCK,-1,,<empty>,9,,267,2,,void
215711,BLOCK,-1,,<empty>,9,,270,2,,void
215722,BLOCK,-1,,<empty>,9,,272,1,,void
215742,BLOCK,-1,,"{
    int saved = GetLastError ();

    if (!TlsSetValue(key->id, value))
        return ENOMEM;

    SetLastError(saved);
    return 0;
}",1,,281,3,,void
215754,BLOCK,-1,,<empty>,9,,285,2,,void
215765,BLOCK,-1,,"{
    int saved = GetLastError ();
    void *value = TlsGetValue (key->id);

    SetLastError(saved);
    return value;
}",1,,292,2,,void
215785,BLOCK,-1,,"{
    vlc_threadvar_t key;
retry:
    /* TODO: use RW lock or something similar */
    EnterCriticalSection(&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get(key);
        if (value != NULL && key->destroy != NULL)
        {
            LeaveCriticalSection(&super_mutex);
            vlc_threadvar_set(key, NULL);
            key->destroy(value);
            goto retry;
        }
    }
    LeaveCriticalSection(&super_mutex);
}",1,,301,2,,void
215792,BLOCK,-1,,<empty>,5,,306,1,,void
215804,BLOCK,4,,"{
        void *value = vlc_threadvar_get(key);
        if (value != NULL && key->destroy != NULL)
        {
            LeaveCriticalSection(&super_mutex);
            vlc_threadvar_set(key, NULL);
            key->destroy(value);
            goto retry;
        }
    }",5,,307,4,,void
215820,BLOCK,-1,,"{
            LeaveCriticalSection(&super_mutex);
            vlc_threadvar_set(key, NULL);
            key->destroy(value);
            goto retry;
        }",9,,310,2,,void
215841,BLOCK,-1,,"{
    WaitOnAddress(addr, &val, sizeof (val), -1);
}",1,,430,3,,void
215856,BLOCK,-1,,"{
    delay = (delay + 999) / 1000;

    if (delay > 0x7fffffff)
    {
        WaitOnAddress(addr, &val, sizeof (val), 0x7fffffff);
        return true; /* woke up early, claim spurious wake-up */
    }

    return WaitOnAddress(addr, &val, sizeof (val), delay);
}",1,,435,4,,void
215868,BLOCK,-1,,"{
        WaitOnAddress(addr, &val, sizeof (val), 0x7fffffff);
        return true; /* woke up early, claim spurious wake-up */
    }",5,,439,2,,void
215890,BLOCK,-1,,"{
    WakeByAddressSingle(addr);
}",1,,448,2,,void
215897,BLOCK,-1,,"{
    WakeByAddressAll(addr);
}",1,,453,2,,void
215904,BLOCK,-1,,"{
    DeleteCriticalSection(&th->wait.lock);
    free(th);
}",1,,459,2,,void
215918,BLOCK,-1,,"{
    struct vlc_thread *th = p;

    TlsSetValue(thread_key, th);
    th->killable = true;
    th->data = th->entry (th->data);
    TlsSetValue(thread_key, NULL);

    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
    return 0;
}",1,,471,2,,void
215951,BLOCK,-1,,<empty>,9,,480,2,,void
215964,BLOCK,-1,,"{
    struct vlc_thread *th = malloc (sizeof (*th));
    if (unlikely(th == NULL))
        return ENOMEM;
    th->entry = entry;
    th->data = data;
    th->killable = false; /* not until vlc_entry() ! */
    atomic_init(&th->killed, false);
    th->cleaners = NULL;
    th->wait.addr = NULL;
    InitializeCriticalSection(&th->wait.lock);

    HANDLE h;
#if VLC_WINSTORE_APP
    h = CreateThread(NULL, 0, vlc_entry, th, 0, NULL);
#else // !VLC_WINSTORE_APP
    /* When using the MSVCRT C library you have to use the _beginthreadex
     * function instead of CreateThread, otherwise you'll end up with
     * memory leaks and the signal functions not working (see Microsoft
     * Knowledge Base, article 104641) */
    h = (HANDLE)(uintptr_t) _beginthreadex (NULL, 0, vlc_entry, th, 0, NULL);
#endif // !VLC_WINSTORE_APP
    if (h == 0)
    {
        int err = errno;
        free (th);
        return err;
    }

    if (detached)
    {
        CloseHandle(h);
        th->id = NULL;
    }
    ...",1,,486,6,,void
215977,BLOCK,-1,,<empty>,9,,489,2,,void
216038,BLOCK,-1,,"{
        int err = errno;
        free (th);
        return err;
    }",5,,509,2,,void
216049,BLOCK,-1,,"{
        CloseHandle(h);
        th->id = NULL;
    }",5,,516,2,,void
216058,BLOCK,-1,,<empty>,9,,521,1,,void
216068,BLOCK,-1,,<empty>,9,,524,2,,void
216075,BLOCK,-1,,<empty>,9,,527,2,,void
216090,BLOCK,-1,,"{
    return vlc_clone_attr (p_handle, false, entry, data, priority);
}",1,,534,5,,void
216103,BLOCK,-1,,"{
    DWORD ret;

    do
    {
        vlc_testcancel ();
        ret = WaitForSingleObjectEx(th->id, INFINITE, TRUE);
        assert(ret != WAIT_ABANDONED_0);
    }
    while (ret == WAIT_IO_COMPLETION || ret == WAIT_FAILED);

    if (result != NULL)
        *result = th->data;
    CloseHandle (th->id);
    vlc_thread_destroy(th);
}",1,,539,3,,void
216106,BLOCK,-1,,"{
        vlc_testcancel ();
        ret = WaitForSingleObjectEx(th->id, INFINITE, TRUE);
        assert(ret != WAIT_ABANDONED_0);
    }",5,,543,1,,void
216131,BLOCK,-1,,<empty>,9,,551,2,,void
216151,BLOCK,-1,,"{
    vlc_thread_t th;
    if (p_handle == NULL)
        p_handle = &th;

    return vlc_clone_attr (p_handle, true, entry, data, priority);
}",1,,558,5,,void
216157,BLOCK,-1,,<empty>,9,,561,2,,void
216173,BLOCK,-1,,"{
    return TlsGetValue(thread_key);
}",1,,567,2,,void
216181,BLOCK,-1,,"{
    return GetCurrentThreadId ();
}",1,,572,2,,void
216189,BLOCK,-1,,"{
    if (!SetThreadPriority (th->id, priority))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",1,,577,3,,void
216197,BLOCK,-1,,<empty>,9,,579,2,,void
216207,BLOCK,-1,,"{
    atomic_store_explicit(&th->killed, true, memory_order_relaxed);

    EnterCriticalSection(&th->wait.lock);
    if (th->wait.addr != NULL)
    {
        atomic_fetch_or_explicit(th->wait.addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(th->wait.addr);
    }
    LeaveCriticalSection(&th->wait.lock);

#if IS_INTERRUPTIBLE
    QueueUserAPC (vlc_cancel_self, th->id, (uintptr_t)th);
#endif
}",1,,594,2,,void
216230,BLOCK,-1,,"{
        atomic_fetch_or_explicit(th->wait.addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(th->wait.addr);
    }",5,,599,2,,void
216264,BLOCK,-1,,"{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return false; /* Main thread - cannot be cancelled anyway */

    int state = th->killable;
    th->killable = false;
    return state;
}",1,,611,2,,void
216273,BLOCK,-1,,<empty>,9,,614,2,,void
216293,BLOCK,-1,,"{
    struct vlc_thread *th = vlc_thread_self();
    assert (state == false || state == true);

    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    assert (!th->killable);
    th->killable = state != 0;
}",1,,622,2,,void
216310,BLOCK,-1,,<empty>,9,,627,2,,void
216328,BLOCK,-1,,"{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */
    if (!th->killable)
        return;
    if (!atomic_load_explicit(&th->killed, memory_order_relaxed))
        return;

    th->killable = true; /* Do not re-enter cancellation cleanup */

    for (vlc_cleanup_t *p = th->cleaners; p != NULL; p = p->next)
        p->proc (p->data);

    th->data = NULL; /* TODO: special value? */
    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
#if VLC_WINSTORE_APP
    ExitThread(0);
#else // !VLC_WINSTORE_APP
    _endthreadex(0);
#endif // !VLC_WINSTORE_APP
}",1,,634,2,,void
216337,BLOCK,-1,,<empty>,9,,637,2,,void
216344,BLOCK,-1,,<empty>,9,,639,2,,void
216354,BLOCK,-1,,<empty>,9,,641,2,,void
216362,BLOCK,-1,,<empty>,5,,645,1,,void
216395,BLOCK,-1,,<empty>,9,,650,2,,void
216404,BLOCK,-1,,"{
    /* NOTE: This function only modifies thread-specific data, so there is no
     * need to lock anything. */
    va_list ap;

    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    va_start (ap, cmd);
    switch (cmd)
    {
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }

        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th->wait.addr == NULL);
            th->wa...",1,,659,2,,void
216414,BLOCK,-1,,<empty>,9,,666,2,,void
216421,BLOCK,-1,,"{
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }

        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th->wait.addr == NULL);
            th->wait.addr = addr;
            LeaveCriticalSection(&th->wait.lock);
            break;
        }

        case VLC_CANCEL_ADDR_CLEAR:
        {
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th->wait.addr == addr);
            th->wait.addr...",5,,670,2,,void
216424,BLOCK,3,,"{
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }",9,,672,3,,void
216441,BLOCK,6,,"{
            th->cleaners = th->cleaners->next;
            break;
        }",9,,682,6,,void
216454,BLOCK,9,,"{
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th->wait.addr == NULL);
            th->wait.addr = addr;
            LeaveCriticalSection(&th->wait.lock);
            break;
        }",9,,688,9,,void
216488,BLOCK,12,,"{
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th->wait.addr == addr);
            th->wait.addr = NULL;
            LeaveCriticalSection(&th->wait.lock);
            break;
        }",9,,699,12,,void
216528,BLOCK,-1,,<empty>,,,,2,,<empty>
216535,BLOCK,-1,,<empty>,,,,2,,<empty>
216545,BLOCK,-1,,<empty>,,,,2,,<empty>
216552,BLOCK,-1,,<empty>,,,,2,,<empty>
216561,BLOCK,-1,,"{
    ULONGLONG ts;
    BOOL ret;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
    ret = QueryUnbiasedInterruptTime (&ts);
#else
    ret = clk.interrupt.query (&ts);
#endif
    if (unlikely(!ret))
        abort ();

    /* hundreds of nanoseconds */
    static_assert ((10000000 % CLOCK_FREQ) == 0, ""Broken frequencies ratio"");
    return ts / (10000000 / CLOCK_FREQ);
}",1,,741,2,,void
216573,BLOCK,-1,,<empty>,9,,751,2,,void
216592,BLOCK,-1,,"{
#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
    ULONGLONG ts = GetTickCount64 ();
#else
    ULONGLONG ts = clk.tick.get ();
#endif

    /* milliseconds */
    static_assert ((CLOCK_FREQ % 1000) == 0, ""Broken frequencies ratio"");
    return ts * (CLOCK_FREQ / 1000);
}",1,,759,2,,void
216614,BLOCK,-1,,"{
    DWORD ts = clk.multimedia.timeGetTime ();

    /* milliseconds */
    static_assert ((CLOCK_FREQ % 1000) == 0, ""Broken frequencies ratio"");
    return ts * (CLOCK_FREQ / 1000);
}",1,,772,2,,void
216641,BLOCK,-1,,"{
    /* We don't need the real date, just the value of a high precision timer */
    LARGE_INTEGER counter;
    if (!QueryPerformanceCounter (&counter))
        abort ();

    /* Convert to from (1/freq) to microsecond resolution */
    /* We need to split the division to avoid 63-bits overflow */
    lldiv_t d = lldiv (counter.QuadPart, clk.perf.freq.QuadPart);

    return (d.quot * 1000000) + ((d.rem * 1000000) / clk.perf.freq.QuadPart);
}",1,,782,2,,void
216648,BLOCK,-1,,<empty>,9,,786,2,,void
216688,BLOCK,-1,,"{
    FILETIME ts;
    ULARGE_INTEGER s;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8) && (!VLC_WINSTORE_APP || _WIN32_WINNT >= 0x0A00)
    GetSystemTimePreciseAsFileTime (&ts);
#else
    GetSystemTimeAsFileTime (&ts);
#endif
    s.LowPart = ts.dwLowDateTime;
    s.HighPart = ts.dwHighDateTime;
    /* hundreds of nanoseconds */
    static_assert ((10000000 % CLOCK_FREQ) == 0, ""Broken frequencies ratio"");
    return s.QuadPart / (10000000 / CLOCK_FREQ);
}",1,,796,2,,void
216727,BLOCK,-1,,"{
    vlc_threads_setup(NULL);
    return mdate_perf();
}",1,,813,2,,void
216736,BLOCK,-1,,<empty>,,,,2,,<empty>
216744,BLOCK,-1,,"{
    return mdate_selected ();
}",1,,821,2,,void
216751,BLOCK,-1,,"{
    vlc_object_t *obj = data;

#if VLC_WINSTORE_APP
    const char *name = ""perf"";
#else
    const char *name = ""multimedia"";
#endif
    char *str = NULL;
    if (obj != NULL)
        str = var_InheritString(obj, ""clock-source"");
    if (str != NULL)
        name = str;
    if (!strcmp (name, ""interrupt""))
    {
        msg_Dbg (obj, ""using interrupt time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
        HANDLE h = GetModuleHandle (_T(""kernel32.dll""));
        if (unlikely(h == NULL))
            return FALSE;
        clk.interrupt.query = (void *)GetProcAddress (h,
                                                      ""QueryUnbiasedInterruptTime"");
        if (unlikely(clk.interrupt.query == NULL))
            abort ();
#endif
        mdate_selected = mdate_interrupt;
    }
    else
    if (!strcmp (name, ""tick""))
    {
        msg_Dbg (obj, ""using Windows time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
        HANDLE h = GetModuleHandle (_T(""kerne...",1,,849,2,,void
216768,BLOCK,-1,,<empty>,9,,859,2,,void
216778,BLOCK,-1,,<empty>,9,,861,2,,void
216787,BLOCK,-1,,"{
        msg_Dbg (obj, ""using interrupt time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
        HANDLE h = GetModuleHandle (_T(""kernel32.dll""));
        if (unlikely(h == NULL))
            return FALSE;
        clk.interrupt.query = (void *)GetProcAddress (h,
                                                      ""QueryUnbiasedInterruptTime"");
        if (unlikely(clk.interrupt.query == NULL))
            abort ();
#endif
        mdate_selected = mdate_interrupt;
    }",5,,863,2,,void
216795,BLOCK,-1,,<empty>,5,,877,1,,void
216801,BLOCK,-1,,"{
        msg_Dbg (obj, ""using Windows time as clock source"");
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
        HANDLE h = GetModuleHandle (_T(""kernel32.dll""));
        if (unlikely(h == NULL))
            return FALSE;
        clk.tick.get = (void *)GetProcAddress (h, ""GetTickCount64"");
        if (unlikely(clk.tick.get == NULL))
            return FALSE;
#endif
        mdate_selected = mdate_tick;
    }",5,,878,2,,void
216809,BLOCK,-1,,<empty>,5,,892,1,,void
216815,BLOCK,-1,,"{
        TIMECAPS caps;
        MMRESULT (WINAPI * timeBeginPeriod)(UINT);

        HMODULE hWinmm = LoadLibrary(TEXT(""winmm.dll""));
        if (!hWinmm)
            goto perf;

        clk.multimedia.timeGetDevCaps = (void*)GetProcAddress(hWinmm, ""timeGetDevCaps"");
        clk.multimedia.timeGetTime = (void*)GetProcAddress(hWinmm, ""timeGetTime"");
        if (!clk.multimedia.timeGetDevCaps || !clk.multimedia.timeGetTime)
            goto perf;

        msg_Dbg (obj, ""using multimedia timers as clock source"");
        if (clk.multimedia.timeGetDevCaps (&caps, sizeof (caps)) != MMSYSERR_NOERROR)
            goto perf;
        msg_Dbg (obj, "" min period: %u ms, max period: %u ms"",
                 caps.wPeriodMin, caps.wPeriodMax);
        mdate_selected = mdate_multimedia;

        timeBeginPeriod = (void*)GetProcAddress(hWinmm, ""timeBeginPeriod"");
        if (timeBeginPeriod != NULL)
            timeBeginPeriod(5);
    }",5,,893,2,,void
216832,BLOCK,-1,,<empty>,13,,899,2,,void
216870,BLOCK,-1,,<empty>,13,,904,2,,void
216888,BLOCK,-1,,<empty>,13,,908,2,,void
216913,BLOCK,-1,,<empty>,13,,915,2,,void
216917,BLOCK,-1,,<empty>,5,,919,1,,void
216923,BLOCK,-1,,"{
    perf:
        msg_Dbg (obj, ""using performance counters as clock source"");
        if (!QueryPerformanceFrequency (&clk.perf.freq))
            abort ();
        msg_Dbg (obj, "" frequency: %llu Hz"", clk.perf.freq.QuadPart);
        mdate_selected = mdate_perf;
    }",5,,920,2,,void
216937,BLOCK,-1,,<empty>,13,,924,2,,void
216953,BLOCK,-1,,<empty>,5,,929,1,,void
216959,BLOCK,-1,,"{
        msg_Dbg (obj, ""using system time as clock source"");
        mdate_selected = mdate_wall;
    }",5,,930,2,,void
216967,BLOCK,-1,,"{
        msg_Err (obj, ""invalid clock source \""%s\"""", name);
        abort ();
    }",5,,935,1,,void
216984,BLOCK,-1,,"{
    const size_t max = 6;
    char **values = xmalloc (sizeof (*values) * max);
    char **names = xmalloc (sizeof (*names) * max);
    size_t n = 0;

#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
    DWORD version = LOWORD(GetVersion());
    version = (LOBYTE(version) << 8) | (HIBYTE(version) << 0);
#endif

    values[n] = xstrdup ("""");
    names[n] = xstrdup (_(""Auto""));
    n++;
#if (_WIN32_WINNT < _WIN32_WINNT_WIN7)
    if (version >= 0x0601)
#endif
    {
        values[n] = xstrdup (""interrupt"");
        names[n] = xstrdup (""Interrupt time"");
        n++;
    }
#if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
    if (version >= 0x0600)
#endif
    {
        values[n] = xstrdup (""tick"");
        names[n] = xstrdup (""Windows time"");
        n++;
    }
#if !VLC_WINSTORE_APP
    values[n] = xstrdup (""multimedia"");
    names[n] = xstrdup (""Multimedia timers"");
    n++;
#endif
    values[n] = xstrdup (""perf"");
    names[n] = xstrdup (""Performance counters"");
    n++;
    values[n] = xstrdup (""wall""...",1,,945,5,,void
217026,BLOCK,12,,"{
        values[n] = xstrdup (""interrupt"");
        names[n] = xstrdup (""Interrupt time"");
        n++;
    }",5,,962,12,,void
217041,BLOCK,13,,"{
        values[n] = xstrdup (""tick"");
        names[n] = xstrdup (""Windows time"");
        n++;
    }",5,,970,13,,void
217118,BLOCK,-1,,"{
    SYSTEM_INFO systemInfo;

    GetNativeSystemInfo(&systemInfo);

    return systemInfo.dwNumberOfProcessors;
}",1,,996,2,,void
217132,BLOCK,-1,,"{
    EnterCriticalSection(&setup_lock);
    if (mdate_selected != mdate_default)
    {
        LeaveCriticalSection(&setup_lock);
        return;
    }

    if (!SelectClockSource((vlc != NULL) ? VLC_OBJECT(vlc) : NULL))
        abort();
    assert(mdate_selected != mdate_default);

#if !VLC_WINSTORE_APP
    /* Raise default priority of the current process */
#ifndef ABOVE_NORMAL_PRIORITY_CLASS
#   define ABOVE_NORMAL_PRIORITY_CLASS 0x00008000
#endif
    if (var_InheritBool(vlc, ""high-priority""))
    {
        if (SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS)
         || SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS))
            msg_Dbg(vlc, ""raised process priority"");
        else
            msg_Dbg(vlc, ""could not raise process priority"");
    }
#endif
    LeaveCriticalSection(&setup_lock);
}",1,,1009,2,,void
217140,BLOCK,-1,,"{
        LeaveCriticalSection(&setup_lock);
        return;
    }",5,,1012,2,,void
217155,BLOCK,-1,,<empty>,9,,1018,2,,void
217165,BLOCK,-1,,"{
        if (SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS)
         || SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS))
            msg_Dbg(vlc, ""raised process priority"");
        else
            msg_Dbg(vlc, ""could not raise process priority"");
    }",5,,1027,2,,void
217171,BLOCK,1,,<empty>,,,,1,,void
217176,BLOCK,-1,,<empty>,13,,1030,2,,void
217181,BLOCK,-1,,<empty>,13,,1032,1,,void
217196,BLOCK,-1,,<empty>,,,,4,,<empty>
217204,BLOCK,-1,,"{
    (void) hinstDll;
    (void) lpvReserved;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
            HANDLE h = GetModuleHandle(TEXT(""kernel32.dll""));
            if (unlikely(h == NULL))
                return FALSE;

            if (!LOOKUP(WaitOnAddress)
             || !LOOKUP(WakeByAddressAll) || !LOOKUP(WakeByAddressSingle))
            {
# if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
                if (!LOOKUP(InitializeConditionVariable)
                 || !LOOKUP(SleepConditionVariableCS)
                 || !LOOKUP(WakeAllConditionVariable))
                {
                    InitializeConditionVariable_ = DummyConditionVariable;
                    SleepConditionVariableCS_ = SleepConditionVariableFallback;
                    WakeAllConditionVariable_ = DummyConditionVariable;
                }
# endif
                vlc_wait_addr_init();
                WaitOnAddress_ = WaitOnAddressFallback;
        ...",1,,1044,4,,void
217213,BLOCK,-1,,"{
        case DLL_PROCESS_ATTACH:
        {
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
            HANDLE h = GetModuleHandle(TEXT(""kernel32.dll""));
            if (unlikely(h == NULL))
                return FALSE;

            if (!LOOKUP(WaitOnAddress)
             || !LOOKUP(WakeByAddressAll) || !LOOKUP(WakeByAddressSingle))
            {
# if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
                if (!LOOKUP(InitializeConditionVariable)
                 || !LOOKUP(SleepConditionVariableCS)
                 || !LOOKUP(WakeAllConditionVariable))
                {
                    InitializeConditionVariable_ = DummyConditionVariable;
                    SleepConditionVariableCS_ = SleepConditionVariableFallback;
                    WakeAllConditionVariable_ = DummyConditionVariable;
                }
# endif
                vlc_wait_addr_init();
                WaitOnAddress_ = WaitOnAddressFallback;
                WakeByAddressAll_ = WakeByAddressFallback;
                WakeByAd...",5,,1049,2,,void
217216,BLOCK,3,,"{
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
            HANDLE h = GetModuleHandle(TEXT(""kernel32.dll""));
            if (unlikely(h == NULL))
                return FALSE;

            if (!LOOKUP(WaitOnAddress)
             || !LOOKUP(WakeByAddressAll) || !LOOKUP(WakeByAddressSingle))
            {
# if (_WIN32_WINNT < _WIN32_WINNT_VISTA)
                if (!LOOKUP(InitializeConditionVariable)
                 || !LOOKUP(SleepConditionVariableCS)
                 || !LOOKUP(WakeAllConditionVariable))
                {
                    InitializeConditionVariable_ = DummyConditionVariable;
                    SleepConditionVariableCS_ = SleepConditionVariableFallback;
                    WakeAllConditionVariable_ = DummyConditionVariable;
                }
# endif
                vlc_wait_addr_init();
                WaitOnAddress_ = WaitOnAddressFallback;
                WakeByAddressAll_ = WakeByAddressFallback;
                WakeByAddressSingle_ = WakeByAddressFallback;
     ...",9,,1051,3,,void
217225,BLOCK,-1,,<empty>,17,,1078,2,,void
217278,BLOCK,-1,,<empty>,1,,1,1,,ANY
217283,BLOCK,-1,,<empty>,,,,2,,<empty>
217292,BLOCK,-1,,"{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (timer == NULL)
        return ENOMEM;
    timer->func = func;
    timer->data = data;
    timer->handle = INVALID_HANDLE_VALUE;
    *id = timer;
    return 0;
}",1,,46,4,,void
217304,BLOCK,-1,,<empty>,9,,50,2,,void
217332,BLOCK,-1,,"{
    if (timer->handle != INVALID_HANDLE_VALUE)
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
    free (timer);
}",1,,59,2,,void
217339,BLOCK,-1,,<empty>,9,,61,2,,void
217355,BLOCK,-1,,"{
    if (timer->handle != INVALID_HANDLE_VALUE)
    {
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
        timer->handle = INVALID_HANDLE_VALUE;
    }
    if (value == 0)
        return; /* Disarm */

    if (absolute)
    {
        value -= mdate ();
        if (value < 0)
            value = 0;
    }
    value = (value + 999) / 1000;
    interval = (interval + 999) / 1000;

    if (!CreateTimerQueueTimer (&timer->handle, NULL, vlc_timer_do, timer,
                                value, interval, WT_EXECUTEDEFAULT))
        abort ();
}",1,,67,5,,void
217362,BLOCK,-1,,"{
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
        timer->handle = INVALID_HANDLE_VALUE;
    }",5,,69,2,,void
217378,BLOCK,-1,,<empty>,9,,74,2,,void
217382,BLOCK,-1,,"{
        value -= mdate ();
        if (value < 0)
            value = 0;
    }",5,,77,2,,void
217390,BLOCK,-1,,<empty>,13,,80,2,,void
217421,BLOCK,-1,,<empty>,9,,87,2,,void
217427,BLOCK,-1,,"{
    (void)timer;
    return 0;
}",1,,91,2,,void
217445,BLOCK,-1,,<empty>,1,,1,1,,ANY
219560,BLOCK,-1,,<empty>,,,,1,,ANY
219789,BLOCK,1,,<empty>,,,,1,,ANY
219794,BLOCK,1,,<empty>,,,,1,,ANY
219797,BLOCK,1,,<empty>,,,,1,,ANY
219805,BLOCK,1,,<empty>,,,,1,,ANY
219810,BLOCK,1,,<empty>,,,,1,,ANY
219814,BLOCK,1,,<empty>,,,,1,,ANY
219819,BLOCK,1,,<empty>,,,,1,,ANY
219824,BLOCK,1,,<empty>,,,,1,,ANY
219831,BLOCK,1,,<empty>,,,,1,,ANY
219838,BLOCK,1,,<empty>,,,,1,,ANY
219843,BLOCK,1,,<empty>,,,,1,,ANY
219847,BLOCK,1,,<empty>,,,,1,,ANY
219854,BLOCK,1,,<empty>,,,,1,,ANY
219860,BLOCK,1,,<empty>,,,,1,,ANY
219865,BLOCK,1,,<empty>,,,,1,,ANY
219870,BLOCK,1,,<empty>,,,,1,,ANY
219873,BLOCK,1,,<empty>,,,,1,,ANY
219878,BLOCK,1,,<empty>,,,,1,,ANY
219883,BLOCK,1,,<empty>,,,,1,,ANY
219887,BLOCK,1,,<empty>,,,,1,,ANY
219891,BLOCK,1,,<empty>,,,,1,,ANY
219896,BLOCK,1,,<empty>,,,,1,,ANY
219901,BLOCK,1,,<empty>,,,,1,,ANY
219908,BLOCK,1,,<empty>,,,,1,,ANY
219912,BLOCK,1,,<empty>,,,,1,,ANY
219917,BLOCK,1,,<empty>,,,,1,,ANY
219923,BLOCK,1,,<empty>,,,,1,,ANY
219927,BLOCK,1,,<empty>,,,,1,,ANY
219933,BLOCK,1,,<empty>,,,,1,,ANY
219939,BLOCK,1,,<empty>,,,,1,,ANY
219947,BLOCK,1,,<empty>,,,,1,,ANY
219955,BLOCK,1,,<empty>,,,,1,,ANY
219959,BLOCK,1,,<empty>,,,,1,,ANY
219965,BLOCK,1,,<empty>,,,,1,,ANY
219969,BLOCK,1,,<empty>,,,,1,,ANY
219975,BLOCK,1,,<empty>,,,,1,,ANY
219980,BLOCK,1,,<empty>,,,,1,,ANY
219986,BLOCK,1,,<empty>,,,,1,,ANY
219993,BLOCK,1,,<empty>,,,,1,,ANY
219998,BLOCK,1,,<empty>,,,,1,,ANY
220004,BLOCK,1,,<empty>,,,,1,,ANY
220012,BLOCK,1,,<empty>,,,,1,,ANY
220019,BLOCK,1,,<empty>,,,,1,,ANY
220024,BLOCK,1,,<empty>,,,,1,,ANY
220029,BLOCK,1,,<empty>,,,,1,,ANY
220033,BLOCK,1,,<empty>,,,,1,,ANY
220038,BLOCK,1,,<empty>,,,,1,,ANY
220042,BLOCK,1,,<empty>,,,,1,,ANY
220050,BLOCK,1,,<empty>,,,,1,,ANY
220054,BLOCK,1,,<empty>,,,,1,,ANY
220058,BLOCK,1,,<empty>,,,,1,,ANY
220063,BLOCK,1,,<empty>,,,,1,,ANY
220068,BLOCK,1,,<empty>,,,,1,,ANY
220072,BLOCK,1,,<empty>,,,,1,,ANY
220076,BLOCK,1,,<empty>,,,,1,,ANY
220079,BLOCK,1,,<empty>,,,,1,,ANY
220083,BLOCK,1,,<empty>,,,,1,,ANY
220087,BLOCK,1,,<empty>,,,,1,,ANY
220091,BLOCK,1,,<empty>,,,,1,,ANY
220095,BLOCK,1,,<empty>,,,,1,,ANY
220099,BLOCK,1,,<empty>,,,,1,,ANY
220104,BLOCK,1,,<empty>,,,,1,,ANY
220109,BLOCK,1,,<empty>,,,,1,,ANY
220112,BLOCK,1,,<empty>,,,,1,,ANY
220116,BLOCK,1,,<empty>,,,,1,,ANY
220120,BLOCK,1,,<empty>,,,,1,,ANY
220125,BLOCK,1,,<empty>,,,,1,,ANY
220130,BLOCK,1,,<empty>,,,,1,,ANY
220136,BLOCK,1,,<empty>,,,,1,,ANY
220141,BLOCK,1,,<empty>,,,,1,,ANY
220145,BLOCK,1,,<empty>,,,,1,,ANY
220150,BLOCK,1,,<empty>,,,,1,,ANY
220157,BLOCK,1,,<empty>,,,,1,,ANY
220161,BLOCK,1,,<empty>,,,,1,,ANY
220166,BLOCK,1,,<empty>,,,,1,,ANY
220172,BLOCK,1,,<empty>,,,,1,,ANY
220176,BLOCK,1,,<empty>,,,,1,,ANY
220180,BLOCK,1,,<empty>,,,,1,,ANY
220185,BLOCK,1,,<empty>,,,,1,,ANY
220188,BLOCK,1,,<empty>,,,,1,,ANY
220192,BLOCK,1,,<empty>,,,,1,,ANY
220197,BLOCK,1,,<empty>,,,,1,,ANY
220201,BLOCK,1,,<empty>,,,,1,,ANY
220206,BLOCK,1,,<empty>,,,,1,,ANY
220210,BLOCK,1,,<empty>,,,,1,,ANY
220215,BLOCK,1,,<empty>,,,,1,,ANY
220218,BLOCK,1,,<empty>,,,,1,,ANY
220223,BLOCK,1,,<empty>,,,,1,,ANY
220227,BLOCK,1,,<empty>,,,,1,,ANY
220232,BLOCK,1,,<empty>,,,,1,,ANY
220236,BLOCK,1,,<empty>,,,,1,,ANY
220241,BLOCK,1,,<empty>,,,,1,,ANY
220245,BLOCK,1,,<empty>,,,,1,,ANY
220250,BLOCK,1,,<empty>,,,,1,,ANY
220255,BLOCK,1,,<empty>,,,,1,,ANY
220260,BLOCK,1,,<empty>,,,,1,,ANY
220265,BLOCK,1,,<empty>,,,,1,,ANY
220270,BLOCK,1,,<empty>,,,,1,,ANY
220274,BLOCK,1,,<empty>,,,,1,,ANY
220278,BLOCK,1,,<empty>,,,,1,,ANY
220282,BLOCK,1,,<empty>,,,,1,,ANY
220288,BLOCK,1,,<empty>,,,,1,,ANY
220293,BLOCK,1,,<empty>,,,,1,,ANY
220296,BLOCK,1,,<empty>,,,,1,,ANY
220301,BLOCK,1,,<empty>,,,,1,,ANY
220304,BLOCK,1,,<empty>,,,,1,,ANY
220308,BLOCK,1,,<empty>,,,,1,,ANY
220313,BLOCK,1,,<empty>,,,,1,,ANY
220318,BLOCK,1,,<empty>,,,,1,,ANY
220323,BLOCK,1,,<empty>,,,,1,,ANY
220328,BLOCK,1,,<empty>,,,,1,,ANY
220333,BLOCK,1,,<empty>,,,,1,,ANY
220337,BLOCK,1,,<empty>,,,,1,,ANY
220343,BLOCK,1,,<empty>,,,,1,,ANY
220348,BLOCK,1,,<empty>,,,,1,,ANY
220354,BLOCK,1,,<empty>,,,,1,,ANY
220360,BLOCK,1,,<empty>,,,,1,,ANY
220365,BLOCK,1,,<empty>,,,,1,,ANY
220369,BLOCK,1,,<empty>,,,,1,,ANY
220374,BLOCK,1,,<empty>,,,,1,,ANY
220377,BLOCK,1,,<empty>,,,,1,,ANY
220382,BLOCK,1,,<empty>,,,,1,,ANY
220385,BLOCK,1,,<empty>,,,,1,,ANY
220388,BLOCK,1,,<empty>,,,,1,,ANY
220393,BLOCK,1,,<empty>,,,,1,,ANY
220399,BLOCK,1,,<empty>,,,,1,,ANY
220403,BLOCK,1,,<empty>,,,,1,,ANY
220407,BLOCK,1,,<empty>,,,,1,,ANY
220412,BLOCK,1,,<empty>,,,,1,,ANY
220415,BLOCK,1,,<empty>,,,,1,,ANY
220420,BLOCK,1,,<empty>,,,,1,,ANY
220424,BLOCK,1,,<empty>,,,,1,,ANY
220429,BLOCK,1,,<empty>,,,,1,,ANY
220434,BLOCK,1,,<empty>,,,,1,,ANY
220441,BLOCK,1,,<empty>,,,,1,,ANY
220445,BLOCK,1,,<empty>,,,,1,,ANY
220449,BLOCK,1,,<empty>,,,,1,,ANY
220455,BLOCK,1,,<empty>,,,,1,,ANY
220459,BLOCK,1,,<empty>,,,,1,,ANY
220464,BLOCK,1,,<empty>,,,,1,,ANY
220468,BLOCK,1,,<empty>,,,,1,,ANY
220472,BLOCK,1,,<empty>,,,,1,,ANY
220477,BLOCK,1,,<empty>,,,,1,,ANY
220480,BLOCK,1,,<empty>,,,,1,,ANY
220485,BLOCK,1,,<empty>,,,,1,,ANY
220493,BLOCK,1,,<empty>,,,,1,,ANY
220500,BLOCK,1,,<empty>,,,,1,,ANY
220505,BLOCK,1,,<empty>,,,,1,,ANY
220510,BLOCK,1,,<empty>,,,,1,,ANY
220515,BLOCK,1,,<empty>,,,,1,,ANY
220519,BLOCK,1,,<empty>,,,,1,,ANY
220525,BLOCK,1,,<empty>,,,,1,,ANY
220531,BLOCK,1,,<empty>,,,,1,,ANY
220537,BLOCK,1,,<empty>,,,,1,,ANY
220542,BLOCK,1,,<empty>,,,,1,,ANY
220546,BLOCK,1,,<empty>,,,,1,,ANY
220551,BLOCK,1,,<empty>,,,,1,,ANY
220556,BLOCK,1,,<empty>,,,,1,,ANY
220560,BLOCK,1,,<empty>,,,,1,,ANY
220565,BLOCK,1,,<empty>,,,,1,,ANY
220570,BLOCK,1,,<empty>,,,,1,,ANY
220575,BLOCK,1,,<empty>,,,,1,,ANY
220581,BLOCK,1,,<empty>,,,,1,,ANY
220586,BLOCK,1,,<empty>,,,,1,,ANY
220592,BLOCK,1,,<empty>,,,,1,,ANY
220598,BLOCK,1,,<empty>,,,,1,,ANY
220605,BLOCK,1,,<empty>,,,,1,,ANY
220611,BLOCK,1,,<empty>,,,,1,,ANY
220617,BLOCK,1,,<empty>,,,,1,,ANY
220623,BLOCK,1,,<empty>,,,,1,,ANY
220629,BLOCK,1,,<empty>,,,,1,,ANY
220634,BLOCK,1,,<empty>,,,,1,,ANY
220639,BLOCK,1,,<empty>,,,,1,,ANY
220643,BLOCK,1,,<empty>,,,,1,,ANY
220648,BLOCK,1,,<empty>,,,,1,,ANY
220652,BLOCK,1,,<empty>,,,,1,,ANY
220659,BLOCK,1,,<empty>,,,,1,,ANY
220664,BLOCK,1,,<empty>,,,,1,,ANY
220669,BLOCK,1,,<empty>,,,,1,,ANY
220674,BLOCK,1,,<empty>,,,,1,,ANY
220678,BLOCK,1,,<empty>,,,,1,,ANY
220683,BLOCK,1,,<empty>,,,,1,,ANY
220688,BLOCK,1,,<empty>,,,,1,,ANY
220693,BLOCK,1,,<empty>,,,,1,,ANY
220698,BLOCK,1,,<empty>,,,,1,,ANY
220704,BLOCK,1,,<empty>,,,,1,,ANY
220708,BLOCK,1,,<empty>,,,,1,,ANY
220715,BLOCK,1,,<empty>,,,,1,,ANY
220719,BLOCK,1,,<empty>,,,,1,,ANY
220723,BLOCK,1,,<empty>,,,,1,,ANY
220729,BLOCK,1,,<empty>,,,,1,,ANY
220735,BLOCK,1,,<empty>,,,,1,,ANY
220738,BLOCK,1,,<empty>,,,,1,,ANY
220742,BLOCK,1,,<empty>,,,,1,,ANY
220748,BLOCK,1,,<empty>,,,,1,,ANY
220753,BLOCK,1,,<empty>,,,,1,,ANY
220757,BLOCK,1,,<empty>,,,,1,,ANY
220761,BLOCK,1,,<empty>,,,,1,,ANY
220765,BLOCK,1,,<empty>,,,,1,,ANY
220773,BLOCK,1,,<empty>,,,,1,,ANY
220777,BLOCK,1,,<empty>,,,,1,,ANY
220781,BLOCK,1,,<empty>,,,,1,,ANY
220785,BLOCK,1,,<empty>,,,,1,,ANY
220793,BLOCK,1,,<empty>,,,,1,,ANY
220800,BLOCK,1,,<empty>,,,,1,,ANY
220808,BLOCK,1,,<empty>,,,,1,,ANY
220813,BLOCK,1,,<empty>,,,,1,,ANY
220818,BLOCK,1,,<empty>,,,,1,,ANY
220822,BLOCK,1,,<empty>,,,,1,,ANY
220826,BLOCK,1,,<empty>,,,,1,,ANY
220833,BLOCK,1,,<empty>,,,,1,,ANY
220839,BLOCK,1,,<empty>,,,,1,,ANY
220843,BLOCK,1,,<empty>,,,,1,,ANY
220849,BLOCK,1,,<empty>,,,,1,,ANY
220853,BLOCK,1,,<empty>,,,,1,,ANY
220859,BLOCK,1,,<empty>,,,,1,,ANY
220863,BLOCK,1,,<empty>,,,,1,,ANY
220867,BLOCK,1,,<empty>,,,,1,,ANY
220871,BLOCK,1,,<empty>,,,,1,,ANY
220875,BLOCK,1,,<empty>,,,,1,,ANY
220880,BLOCK,1,,<empty>,,,,1,,ANY
220886,BLOCK,1,,<empty>,,,,1,,ANY
220889,BLOCK,1,,<empty>,,,,1,,ANY
220894,BLOCK,1,,<empty>,,,,1,,ANY
220899,BLOCK,1,,<empty>,,,,1,,ANY
220903,BLOCK,1,,<empty>,,,,1,,ANY
220907,BLOCK,1,,<empty>,,,,1,,ANY
220910,BLOCK,1,,<empty>,,,,1,,ANY
220914,BLOCK,1,,<empty>,,,,1,,ANY
220918,BLOCK,1,,<empty>,,,,1,,ANY
220921,BLOCK,1,,<empty>,,,,1,,ANY
220926,BLOCK,1,,<empty>,,,,1,,ANY
220929,BLOCK,1,,<empty>,,,,1,,ANY
220932,BLOCK,1,,<empty>,,,,1,,ANY
220935,BLOCK,1,,<empty>,,,,1,,ANY
220938,BLOCK,1,,<empty>,,,,1,,ANY
220942,BLOCK,1,,<empty>,,,,1,,ANY
220946,BLOCK,1,,<empty>,,,,1,,ANY
220953,BLOCK,1,,<empty>,,,,1,,ANY
220956,BLOCK,1,,<empty>,,,,1,,ANY
220959,BLOCK,1,,<empty>,,,,1,,ANY
220962,BLOCK,1,,<empty>,,,,1,,ANY
220967,BLOCK,1,,<empty>,,,,1,,ANY
220970,BLOCK,1,,<empty>,,,,1,,ANY
220973,BLOCK,1,,<empty>,,,,1,,ANY
220976,BLOCK,1,,<empty>,,,,1,,ANY
220981,BLOCK,1,,<empty>,,,,1,,ANY
220985,BLOCK,1,,<empty>,,,,1,,ANY
220988,BLOCK,1,,<empty>,,,,1,,ANY
220991,BLOCK,1,,<empty>,,,,1,,ANY
220995,BLOCK,1,,<empty>,,,,1,,ANY
220999,BLOCK,1,,<empty>,,,,1,,ANY
221004,BLOCK,1,,<empty>,,,,1,,ANY
221007,BLOCK,1,,<empty>,,,,1,,ANY
221011,BLOCK,1,,<empty>,,,,1,,ANY
221015,BLOCK,1,,<empty>,,,,1,,ANY
221020,BLOCK,1,,<empty>,,,,1,,ANY
221027,BLOCK,1,,<empty>,,,,1,,ANY
221030,BLOCK,1,,<empty>,,,,1,,ANY
221035,BLOCK,1,,<empty>,,,,1,,ANY
221041,BLOCK,1,,<empty>,,,,1,,ANY
221045,BLOCK,1,,<empty>,,,,1,,ANY
221049,BLOCK,1,,<empty>,,,,1,,ANY
221054,BLOCK,1,,<empty>,,,,1,,ANY
221059,BLOCK,1,,<empty>,,,,1,,ANY
221065,BLOCK,1,,<empty>,,,,1,,ANY
221069,BLOCK,1,,<empty>,,,,1,,ANY
221072,BLOCK,1,,<empty>,,,,1,,ANY
221077,BLOCK,1,,<empty>,,,,1,,ANY
221081,BLOCK,1,,<empty>,,,,1,,ANY
221085,BLOCK,1,,<empty>,,,,1,,ANY
221089,BLOCK,1,,<empty>,,,,1,,ANY
221094,BLOCK,1,,<empty>,,,,1,,ANY
221097,BLOCK,1,,<empty>,,,,1,,ANY
221103,BLOCK,1,,<empty>,,,,1,,ANY
221109,BLOCK,1,,<empty>,,,,1,,ANY
221116,BLOCK,1,,<empty>,,,,1,,ANY
221119,BLOCK,1,,<empty>,,,,1,,ANY
221124,BLOCK,1,,<empty>,,,,1,,ANY
221128,BLOCK,1,,<empty>,,,,1,,ANY
221132,BLOCK,1,,<empty>,,,,1,,ANY
221137,BLOCK,1,,<empty>,,,,1,,ANY
221141,BLOCK,1,,<empty>,,,,1,,ANY
221145,BLOCK,1,,<empty>,,,,1,,ANY
221149,BLOCK,1,,<empty>,,,,1,,ANY
221153,BLOCK,1,,<empty>,,,,1,,ANY
221158,BLOCK,1,,<empty>,,,,1,,ANY
221161,BLOCK,1,,<empty>,,,,1,,ANY
221164,BLOCK,1,,<empty>,,,,1,,ANY
221168,BLOCK,1,,<empty>,,,,1,,ANY
221173,BLOCK,1,,<empty>,,,,1,,ANY
221176,BLOCK,1,,<empty>,,,,1,,ANY
221179,BLOCK,1,,<empty>,,,,1,,ANY
221182,BLOCK,1,,<empty>,,,,1,,ANY
221187,BLOCK,1,,<empty>,,,,1,,ANY
221190,BLOCK,1,,<empty>,,,,1,,ANY
221195,BLOCK,1,,<empty>,,,,1,,ANY
221199,BLOCK,1,,<empty>,,,,1,,ANY
221204,BLOCK,1,,<empty>,,,,1,,ANY
221209,BLOCK,1,,<empty>,,,,1,,ANY
221213,BLOCK,1,,<empty>,,,,1,,ANY
221218,BLOCK,1,,<empty>,,,,1,,ANY
221223,BLOCK,1,,<empty>,,,,1,,ANY
221228,BLOCK,1,,<empty>,,,,1,,ANY
221231,BLOCK,1,,<empty>,,,,1,,ANY
221237,BLOCK,1,,<empty>,,,,1,,ANY
221240,BLOCK,1,,<empty>,,,,1,,ANY
221243,BLOCK,1,,<empty>,,,,1,,ANY
221248,BLOCK,1,,<empty>,,,,1,,ANY
221251,BLOCK,1,,<empty>,,,,1,,ANY
221254,BLOCK,1,,<empty>,,,,1,,ANY
221257,BLOCK,1,,<empty>,,,,1,,ANY
221262,BLOCK,1,,<empty>,,,,1,,ANY
221267,BLOCK,1,,<empty>,,,,1,,ANY
221272,BLOCK,1,,<empty>,,,,1,,ANY
221278,BLOCK,1,,<empty>,,,,1,,ANY
221282,BLOCK,1,,<empty>,,,,1,,ANY
221288,BLOCK,1,,<empty>,,,,1,,ANY
221292,BLOCK,1,,<empty>,,,,1,,ANY
221298,BLOCK,1,,<empty>,,,,1,,ANY
221303,BLOCK,1,,<empty>,,,,1,,ANY
221307,BLOCK,1,,<empty>,,,,1,,ANY
221311,BLOCK,1,,<empty>,,,,1,,ANY
221315,BLOCK,1,,<empty>,,,,1,,ANY
221320,BLOCK,1,,<empty>,,,,1,,ANY
221326,BLOCK,1,,<empty>,,,,1,,ANY
221332,BLOCK,1,,<empty>,,,,1,,ANY
221338,BLOCK,1,,<empty>,,,,1,,ANY
221343,BLOCK,1,,<empty>,,,,1,,ANY
221346,BLOCK,1,,<empty>,,,,1,,ANY
221350,BLOCK,1,,<empty>,,,,1,,ANY
221354,BLOCK,1,,<empty>,,,,1,,ANY
221359,BLOCK,1,,<empty>,,,,1,,ANY
221364,BLOCK,1,,<empty>,,,,1,,ANY
221369,BLOCK,1,,<empty>,,,,1,,ANY
221372,BLOCK,1,,<empty>,,,,1,,ANY
221378,BLOCK,1,,<empty>,,,,1,,ANY
221384,BLOCK,1,,<empty>,,,,1,,ANY
221391,BLOCK,1,,<empty>,,,,1,,ANY
221397,BLOCK,1,,<empty>,,,,1,,ANY
221402,BLOCK,1,,<empty>,,,,1,,ANY
221406,BLOCK,1,,<empty>,,,,1,,ANY
221412,BLOCK,1,,<empty>,,,,1,,ANY
221415,BLOCK,1,,<empty>,,,,1,,ANY
221419,BLOCK,1,,<empty>,,,,1,,ANY
221426,BLOCK,1,,<empty>,,,,1,,ANY
221432,BLOCK,1,,<empty>,,,,1,,ANY
221435,BLOCK,1,,<empty>,,,,1,,ANY
221440,BLOCK,1,,<empty>,,,,1,,ANY
221446,BLOCK,1,,<empty>,,,,1,,ANY
221450,BLOCK,1,,<empty>,,,,1,,ANY
221455,BLOCK,1,,<empty>,,,,1,,ANY
221459,BLOCK,1,,<empty>,,,,1,,ANY
221463,BLOCK,1,,<empty>,,,,1,,ANY
221468,BLOCK,1,,<empty>,,,,1,,ANY
221479,BLOCK,1,,<empty>,,,,1,,ANY
221483,BLOCK,1,,<empty>,,,,1,,ANY
221487,BLOCK,1,,<empty>,,,,1,,ANY
221494,BLOCK,1,,<empty>,,,,1,,ANY
221499,BLOCK,1,,<empty>,,,,1,,ANY
221503,BLOCK,1,,<empty>,,,,1,,ANY
221506,BLOCK,1,,<empty>,,,,1,,ANY
221512,BLOCK,1,,<empty>,,,,1,,ANY
221519,BLOCK,1,,<empty>,,,,1,,ANY
221523,BLOCK,1,,<empty>,,,,1,,ANY
221528,BLOCK,1,,<empty>,,,,1,,ANY
221533,BLOCK,1,,<empty>,,,,1,,ANY
221538,BLOCK,1,,<empty>,,,,1,,ANY
221543,BLOCK,1,,<empty>,,,,1,,ANY
221548,BLOCK,1,,<empty>,,,,1,,ANY
221553,BLOCK,1,,<empty>,,,,1,,ANY
221557,BLOCK,1,,<empty>,,,,1,,ANY
221562,BLOCK,1,,<empty>,,,,1,,ANY
221568,BLOCK,1,,<empty>,,,,1,,ANY
221572,BLOCK,1,,<empty>,,,,1,,ANY
221576,BLOCK,1,,<empty>,,,,1,,ANY
221579,BLOCK,1,,<empty>,,,,1,,ANY
221582,BLOCK,1,,<empty>,,,,1,,ANY
221589,BLOCK,1,,<empty>,,,,1,,ANY
221594,BLOCK,1,,<empty>,,,,1,,ANY
221599,BLOCK,1,,<empty>,,,,1,,ANY
221605,BLOCK,1,,<empty>,,,,1,,ANY
221609,BLOCK,1,,<empty>,,,,1,,ANY
221614,BLOCK,1,,<empty>,,,,1,,ANY
221618,BLOCK,1,,<empty>,,,,1,,ANY
221624,BLOCK,1,,<empty>,,,,1,,ANY
221629,BLOCK,1,,<empty>,,,,1,,ANY
221635,BLOCK,1,,<empty>,,,,1,,ANY
221640,BLOCK,1,,<empty>,,,,1,,ANY
221646,BLOCK,1,,<empty>,,,,1,,ANY
221650,BLOCK,1,,<empty>,,,,1,,ANY
221655,BLOCK,1,,<empty>,,,,1,,ANY
221658,BLOCK,1,,<empty>,,,,1,,ANY
221663,BLOCK,1,,<empty>,,,,1,,ANY
221666,BLOCK,1,,<empty>,,,,1,,ANY
221670,BLOCK,1,,<empty>,,,,1,,ANY
221675,BLOCK,1,,<empty>,,,,1,,ANY
221679,BLOCK,1,,<empty>,,,,1,,ANY
221682,BLOCK,1,,<empty>,,,,1,,ANY
221685,BLOCK,1,,<empty>,,,,1,,ANY
221688,BLOCK,1,,<empty>,,,,1,,ANY
221696,BLOCK,1,,<empty>,,,,1,,ANY
221700,BLOCK,1,,<empty>,,,,1,,ANY
221705,BLOCK,1,,<empty>,,,,1,,ANY
221708,BLOCK,1,,<empty>,,,,1,,ANY
221711,BLOCK,1,,<empty>,,,,1,,ANY
221714,BLOCK,1,,<empty>,,,,1,,ANY
221718,BLOCK,1,,<empty>,,,,1,,ANY
221722,BLOCK,1,,<empty>,,,,1,,ANY
221728,BLOCK,1,,<empty>,,,,1,,ANY
221731,BLOCK,1,,<empty>,,,,1,,ANY
221735,BLOCK,1,,<empty>,,,,1,,ANY
221739,BLOCK,1,,<empty>,,,,1,,ANY
221743,BLOCK,1,,<empty>,,,,1,,ANY
221749,BLOCK,1,,<empty>,,,,1,,ANY
221752,BLOCK,1,,<empty>,,,,1,,ANY
221757,BLOCK,1,,<empty>,,,,1,,ANY
221763,BLOCK,1,,<empty>,,,,1,,ANY
221768,BLOCK,1,,<empty>,,,,1,,ANY
221772,BLOCK,1,,<empty>,,,,1,,ANY
221776,BLOCK,1,,<empty>,,,,1,,ANY
221781,BLOCK,1,,<empty>,,,,1,,ANY
221787,BLOCK,1,,<empty>,,,,1,,ANY
221791,BLOCK,1,,<empty>,,,,1,,ANY
221797,BLOCK,1,,<empty>,,,,1,,ANY
221802,BLOCK,1,,<empty>,,,,1,,ANY
221808,BLOCK,1,,<empty>,,,,1,,ANY
221812,BLOCK,1,,<empty>,,,,1,,ANY
221817,BLOCK,1,,<empty>,,,,1,,ANY
221824,BLOCK,1,,<empty>,,,,1,,ANY
221830,BLOCK,1,,<empty>,,,,1,,ANY
221834,BLOCK,1,,<empty>,,,,1,,ANY
221838,BLOCK,1,,<empty>,,,,1,,ANY
221841,BLOCK,1,,<empty>,,,,1,,ANY
221845,BLOCK,1,,<empty>,,,,1,,ANY
221850,BLOCK,1,,<empty>,,,,1,,ANY
221854,BLOCK,1,,<empty>,,,,1,,ANY
221859,BLOCK,1,,<empty>,,,,1,,ANY
221863,BLOCK,1,,<empty>,,,,1,,ANY
221867,BLOCK,1,,<empty>,,,,1,,ANY
221871,BLOCK,1,,<empty>,,,,1,,ANY
221875,BLOCK,1,,<empty>,,,,1,,ANY
221879,BLOCK,1,,<empty>,,,,1,,ANY
221885,BLOCK,1,,<empty>,,,,1,,ANY
221892,BLOCK,1,,<empty>,,,,1,,ANY
221897,BLOCK,1,,<empty>,,,,1,,ANY
221900,BLOCK,1,,<empty>,,,,1,,ANY
221904,BLOCK,1,,<empty>,,,,1,,ANY
221909,BLOCK,1,,<empty>,,,,1,,ANY
221912,BLOCK,1,,<empty>,,,,1,,ANY
221918,BLOCK,1,,<empty>,,,,1,,ANY
221924,BLOCK,1,,<empty>,,,,1,,ANY
221930,BLOCK,1,,<empty>,,,,1,,ANY
221934,BLOCK,1,,<empty>,,,,1,,ANY
221940,BLOCK,1,,<empty>,,,,1,,ANY
221944,BLOCK,1,,<empty>,,,,1,,ANY
221949,BLOCK,1,,<empty>,,,,1,,ANY
221953,BLOCK,1,,<empty>,,,,1,,ANY
221959,BLOCK,1,,<empty>,,,,1,,ANY
221964,BLOCK,1,,<empty>,,,,1,,ANY
221971,BLOCK,1,,<empty>,,,,1,,ANY
221975,BLOCK,1,,<empty>,,,,1,,ANY
221980,BLOCK,1,,<empty>,,,,1,,ANY
221984,BLOCK,1,,<empty>,,,,1,,ANY
221987,BLOCK,1,,<empty>,,,,1,,ANY
221993,BLOCK,1,,<empty>,,,,1,,ANY
221998,BLOCK,1,,<empty>,,,,1,,ANY
222003,BLOCK,1,,<empty>,,,,1,,ANY
222010,BLOCK,1,,<empty>,,,,1,,ANY
222017,BLOCK,1,,<empty>,,,,1,,ANY
222027,BLOCK,1,,<empty>,,,,1,,ANY
222039,BLOCK,1,,<empty>,,,,1,,ANY
222050,BLOCK,1,,<empty>,,,,1,,ANY
222058,BLOCK,1,,<empty>,,,,1,,ANY
222064,BLOCK,1,,<empty>,,,,1,,ANY
222068,BLOCK,1,,<empty>,,,,1,,ANY
222075,BLOCK,1,,<empty>,,,,1,,ANY
222079,BLOCK,1,,<empty>,,,,1,,ANY
222083,BLOCK,1,,<empty>,,,,1,,ANY
222087,BLOCK,1,,<empty>,,,,1,,ANY
222091,BLOCK,1,,<empty>,,,,1,,ANY
222096,BLOCK,1,,<empty>,,,,1,,ANY
222103,BLOCK,1,,<empty>,,,,1,,ANY
222110,BLOCK,1,,<empty>,,,,1,,ANY
222114,BLOCK,1,,<empty>,,,,1,,ANY
222120,BLOCK,1,,<empty>,,,,1,,ANY
222124,BLOCK,1,,<empty>,,,,1,,ANY
222134,BLOCK,1,,<empty>,,,,1,,ANY
222137,BLOCK,1,,<empty>,,,,1,,ANY
222140,BLOCK,1,,<empty>,,,,1,,ANY
222143,BLOCK,1,,<empty>,,,,1,,ANY
222147,BLOCK,1,,<empty>,,,,1,,ANY
222150,BLOCK,1,,<empty>,,,,1,,ANY
222156,BLOCK,1,,<empty>,,,,1,,ANY
222162,BLOCK,1,,<empty>,,,,1,,ANY
222165,BLOCK,1,,<empty>,,,,1,,ANY
222170,BLOCK,1,,<empty>,,,,1,,ANY
222174,BLOCK,1,,<empty>,,,,1,,ANY
222179,BLOCK,1,,<empty>,,,,1,,ANY
222182,BLOCK,1,,<empty>,,,,1,,ANY
222186,BLOCK,1,,<empty>,,,,1,,ANY
222189,BLOCK,1,,<empty>,,,,1,,ANY
222192,BLOCK,1,,<empty>,,,,1,,ANY
222197,BLOCK,1,,<empty>,,,,1,,ANY
222203,BLOCK,1,,<empty>,,,,1,,ANY
222210,BLOCK,1,,<empty>,,,,1,,ANY
222215,BLOCK,1,,<empty>,,,,1,,ANY
222220,BLOCK,1,,<empty>,,,,1,,ANY
222227,BLOCK,1,,<empty>,,,,1,,ANY
222233,BLOCK,1,,<empty>,,,,1,,ANY
222239,BLOCK,1,,<empty>,,,,1,,ANY
222245,BLOCK,1,,<empty>,,,,1,,ANY
222248,BLOCK,1,,<empty>,,,,1,,ANY
222251,BLOCK,1,,<empty>,,,,1,,ANY
222256,BLOCK,1,,<empty>,,,,1,,ANY
222260,BLOCK,1,,<empty>,,,,1,,ANY
222263,BLOCK,1,,<empty>,,,,1,,ANY
222267,BLOCK,1,,<empty>,,,,1,,ANY
222274,BLOCK,1,,<empty>,,,,1,,ANY
222278,BLOCK,1,,<empty>,,,,1,,ANY
222282,BLOCK,1,,<empty>,,,,1,,ANY
222287,BLOCK,1,,<empty>,,,,1,,ANY
222291,BLOCK,1,,<empty>,,,,1,,ANY
222296,BLOCK,1,,<empty>,,,,1,,ANY
222301,BLOCK,1,,<empty>,,,,1,,ANY
222305,BLOCK,1,,<empty>,,,,1,,ANY
222311,BLOCK,1,,<empty>,,,,1,,ANY
222321,BLOCK,1,,<empty>,,,,1,,ANY
222326,BLOCK,1,,<empty>,,,,1,,ANY
222330,BLOCK,1,,<empty>,,,,1,,ANY
222338,BLOCK,1,,<empty>,,,,1,,ANY
222344,BLOCK,1,,<empty>,,,,1,,ANY
222350,BLOCK,1,,<empty>,,,,1,,ANY
222356,BLOCK,1,,<empty>,,,,1,,ANY
222364,BLOCK,1,,<empty>,,,,1,,ANY
222372,BLOCK,1,,<empty>,,,,1,,ANY
222375,BLOCK,1,,<empty>,,,,1,,ANY
222378,BLOCK,1,,<empty>,,,,1,,ANY
222381,BLOCK,1,,<empty>,,,,1,,ANY
222384,BLOCK,1,,<empty>,,,,1,,ANY
222387,BLOCK,1,,<empty>,,,,1,,ANY
222390,BLOCK,1,,<empty>,,,,1,,ANY
222393,BLOCK,1,,<empty>,,,,1,,ANY
222396,BLOCK,1,,<empty>,,,,1,,ANY
222399,BLOCK,1,,<empty>,,,,1,,ANY
222402,BLOCK,1,,<empty>,,,,1,,ANY
222405,BLOCK,1,,<empty>,,,,1,,ANY
222408,BLOCK,1,,<empty>,,,,1,,ANY
222411,BLOCK,1,,<empty>,,,,1,,ANY
222414,BLOCK,1,,<empty>,,,,1,,ANY
222417,BLOCK,1,,<empty>,,,,1,,ANY
222420,BLOCK,1,,<empty>,,,,1,,ANY
222423,BLOCK,1,,<empty>,,,,1,,ANY
222426,BLOCK,1,,<empty>,,,,1,,ANY
222429,BLOCK,1,,<empty>,,,,1,,ANY
222432,BLOCK,1,,<empty>,,,,1,,ANY
222435,BLOCK,1,,<empty>,,,,1,,ANY
222438,BLOCK,1,,<empty>,,,,1,,ANY
222443,BLOCK,1,,<empty>,,,,1,,ANY
222447,BLOCK,1,,<empty>,,,,1,,ANY
222452,BLOCK,1,,<empty>,,,,1,,ANY
222458,BLOCK,1,,<empty>,,,,1,,ANY
222463,BLOCK,1,,<empty>,,,,1,,ANY
222469,BLOCK,1,,<empty>,,,,1,,ANY
222473,BLOCK,1,,<empty>,,,,1,,ANY
222478,BLOCK,1,,<empty>,,,,1,,ANY
222483,BLOCK,1,,<empty>,,,,1,,ANY
222489,BLOCK,1,,<empty>,,,,1,,ANY
222495,BLOCK,1,,<empty>,,,,1,,ANY
222501,BLOCK,1,,<empty>,,,,1,,ANY
222508,BLOCK,1,,<empty>,,,,1,,ANY
222514,BLOCK,1,,<empty>,,,,1,,ANY
222520,BLOCK,1,,<empty>,,,,1,,ANY
222526,BLOCK,1,,<empty>,,,,1,,ANY
222532,BLOCK,1,,<empty>,,,,1,,ANY
222541,BLOCK,1,,<empty>,,,,1,,ANY
222545,BLOCK,1,,<empty>,,,,1,,ANY
222554,BLOCK,1,,<empty>,,,,1,,ANY
222564,BLOCK,1,,<empty>,,,,1,,ANY
222569,BLOCK,1,,<empty>,,,,1,,ANY
222572,BLOCK,1,,<empty>,,,,1,,ANY
222581,BLOCK,1,,<empty>,,,,1,,ANY
222586,BLOCK,1,,<empty>,,,,1,,ANY
222590,BLOCK,1,,<empty>,,,,1,,ANY
222595,BLOCK,1,,<empty>,,,,1,,ANY
222600,BLOCK,1,,<empty>,,,,1,,ANY
222604,BLOCK,1,,<empty>,,,,1,,ANY
222608,BLOCK,1,,<empty>,,,,1,,ANY
222612,BLOCK,1,,<empty>,,,,1,,ANY
222617,BLOCK,1,,<empty>,,,,1,,ANY
222623,BLOCK,1,,<empty>,,,,1,,ANY
222629,BLOCK,1,,<empty>,,,,1,,ANY
222634,BLOCK,1,,<empty>,,,,1,,ANY
222639,BLOCK,1,,<empty>,,,,1,,ANY
222645,BLOCK,1,,<empty>,,,,1,,ANY
222648,BLOCK,1,,<empty>,,,,1,,ANY
222653,BLOCK,1,,<empty>,,,,1,,ANY
222658,BLOCK,1,,<empty>,,,,1,,ANY
222662,BLOCK,1,,<empty>,,,,1,,ANY
222667,BLOCK,1,,<empty>,,,,1,,ANY
222672,BLOCK,1,,<empty>,,,,1,,ANY
222679,BLOCK,1,,<empty>,,,,1,,ANY
222682,BLOCK,1,,<empty>,,,,1,,ANY
222687,BLOCK,1,,<empty>,,,,1,,ANY
222691,BLOCK,1,,<empty>,,,,1,,ANY
222696,BLOCK,1,,<empty>,,,,1,,ANY
222700,BLOCK,1,,<empty>,,,,1,,ANY
222704,BLOCK,1,,<empty>,,,,1,,ANY
222708,BLOCK,1,,<empty>,,,,1,,ANY
222713,BLOCK,1,,<empty>,,,,1,,ANY
222720,BLOCK,1,,<empty>,,,,1,,ANY
222730,BLOCK,1,,<empty>,,,,1,,ANY
222738,BLOCK,1,,<empty>,,,,1,,ANY
222742,BLOCK,1,,<empty>,,,,1,,ANY
222745,BLOCK,1,,<empty>,,,,1,,ANY
222749,BLOCK,1,,<empty>,,,,1,,ANY
222752,BLOCK,1,,<empty>,,,,1,,ANY
222755,BLOCK,1,,<empty>,,,,1,,ANY
222761,BLOCK,1,,<empty>,,,,1,,ANY
222766,BLOCK,1,,<empty>,,,,1,,ANY
222771,BLOCK,1,,<empty>,,,,1,,ANY
222775,BLOCK,1,,<empty>,,,,1,,ANY
222778,BLOCK,1,,<empty>,,,,1,,ANY
222783,BLOCK,1,,<empty>,,,,1,,ANY
222786,BLOCK,1,,<empty>,,,,1,,ANY
222790,BLOCK,1,,<empty>,,,,1,,ANY
222797,BLOCK,1,,<empty>,,,,1,,ANY
222805,BLOCK,1,,<empty>,,,,1,,ANY
222812,BLOCK,1,,<empty>,,,,1,,ANY
222818,BLOCK,1,,<empty>,,,,1,,ANY
222822,BLOCK,1,,<empty>,,,,1,,ANY
222826,BLOCK,1,,<empty>,,,,1,,ANY
222830,BLOCK,1,,<empty>,,,,1,,ANY
222834,BLOCK,1,,<empty>,,,,1,,ANY
222837,BLOCK,1,,<empty>,,,,1,,ANY
222840,BLOCK,1,,<empty>,,,,1,,ANY
222843,BLOCK,1,,<empty>,,,,1,,ANY
222849,BLOCK,1,,<empty>,,,,1,,ANY
222854,BLOCK,1,,<empty>,,,,1,,ANY
222858,BLOCK,1,,<empty>,,,,1,,ANY
222863,BLOCK,1,,<empty>,,,,1,,ANY
222867,BLOCK,1,,<empty>,,,,1,,ANY
222873,BLOCK,1,,<empty>,,,,1,,ANY
222878,BLOCK,1,,<empty>,,,,1,,ANY
222883,BLOCK,1,,<empty>,,,,1,,ANY
222892,BLOCK,1,,<empty>,,,,1,,ANY
222901,BLOCK,1,,<empty>,,,,1,,ANY
222907,BLOCK,1,,<empty>,,,,1,,ANY
222912,BLOCK,1,,<empty>,,,,1,,ANY
222915,BLOCK,1,,<empty>,,,,1,,ANY
222920,BLOCK,1,,<empty>,,,,1,,ANY
222925,BLOCK,1,,<empty>,,,,1,,ANY
222930,BLOCK,1,,<empty>,,,,1,,ANY
222934,BLOCK,1,,<empty>,,,,1,,ANY
222949,BLOCK,1,,<empty>,,,,1,,ANY
222954,BLOCK,1,,<empty>,,,,1,,ANY
222957,BLOCK,1,,<empty>,,,,1,,ANY
222963,BLOCK,1,,<empty>,,,,1,,ANY
222969,BLOCK,1,,<empty>,,,,1,,ANY
222973,BLOCK,1,,<empty>,,,,1,,ANY
222979,BLOCK,1,,<empty>,,,,1,,ANY
222983,BLOCK,1,,<empty>,,,,1,,ANY
222987,BLOCK,1,,<empty>,,,,1,,ANY
222992,BLOCK,1,,<empty>,,,,1,,ANY
223000,BLOCK,1,,<empty>,,,,1,,ANY
223004,BLOCK,1,,<empty>,,,,1,,ANY
223010,BLOCK,1,,<empty>,,,,1,,ANY
223014,BLOCK,1,,<empty>,,,,1,,ANY
223019,BLOCK,1,,<empty>,,,,1,,ANY
223024,BLOCK,1,,<empty>,,,,1,,ANY
223028,BLOCK,1,,<empty>,,,,1,,ANY
223035,BLOCK,1,,<empty>,,,,1,,ANY
223042,BLOCK,1,,<empty>,,,,1,,ANY
223049,BLOCK,1,,<empty>,,,,1,,ANY
223056,BLOCK,1,,<empty>,,,,1,,ANY
223060,BLOCK,1,,<empty>,,,,1,,ANY
223065,BLOCK,1,,<empty>,,,,1,,ANY
223068,BLOCK,1,,<empty>,,,,1,,ANY
223072,BLOCK,1,,<empty>,,,,1,,ANY
223079,BLOCK,1,,<empty>,,,,1,,ANY
223082,BLOCK,1,,<empty>,,,,1,,ANY
223088,BLOCK,1,,<empty>,,,,1,,ANY
223096,BLOCK,1,,<empty>,,,,1,,ANY
223103,BLOCK,1,,<empty>,,,,1,,ANY
223108,BLOCK,1,,<empty>,,,,1,,ANY
223114,BLOCK,1,,<empty>,,,,1,,ANY
223118,BLOCK,1,,<empty>,,,,1,,ANY
223127,BLOCK,1,,<empty>,,,,1,,ANY
223132,BLOCK,1,,<empty>,,,,1,,ANY
223135,BLOCK,1,,<empty>,,,,1,,ANY
223139,BLOCK,1,,<empty>,,,,1,,ANY
223145,BLOCK,1,,<empty>,,,,1,,ANY
223148,BLOCK,1,,<empty>,,,,1,,ANY
223157,BLOCK,1,,<empty>,,,,1,,ANY
223163,BLOCK,1,,<empty>,,,,1,,ANY
223167,BLOCK,1,,<empty>,,,,1,,ANY
223171,BLOCK,1,,<empty>,,,,1,,ANY
223177,BLOCK,1,,<empty>,,,,1,,ANY
223182,BLOCK,1,,<empty>,,,,1,,ANY
223186,BLOCK,1,,<empty>,,,,1,,ANY
223192,BLOCK,1,,<empty>,,,,1,,ANY
223197,BLOCK,1,,<empty>,,,,1,,ANY
223202,BLOCK,1,,<empty>,,,,1,,ANY
223207,BLOCK,1,,<empty>,,,,1,,ANY
223212,BLOCK,1,,<empty>,,,,1,,ANY
223216,BLOCK,1,,<empty>,,,,1,,ANY
223221,BLOCK,1,,<empty>,,,,1,,ANY
223227,BLOCK,1,,<empty>,,,,1,,ANY
223232,BLOCK,1,,<empty>,,,,1,,ANY
223238,BLOCK,1,,<empty>,,,,1,,ANY
223245,BLOCK,1,,<empty>,,,,1,,ANY
223251,BLOCK,1,,<empty>,,,,1,,ANY
223254,BLOCK,1,,<empty>,,,,1,,ANY
223258,BLOCK,1,,<empty>,,,,1,,ANY
223262,BLOCK,1,,<empty>,,,,1,,ANY
223265,BLOCK,1,,<empty>,,,,1,,ANY
223269,BLOCK,1,,<empty>,,,,1,,ANY
223273,BLOCK,1,,<empty>,,,,1,,ANY
223277,BLOCK,1,,<empty>,,,,1,,ANY
223281,BLOCK,1,,<empty>,,,,1,,ANY
223286,BLOCK,1,,<empty>,,,,1,,ANY
223289,BLOCK,1,,<empty>,,,,1,,ANY
223293,BLOCK,1,,<empty>,,,,1,,ANY
223298,BLOCK,1,,<empty>,,,,1,,ANY
223302,BLOCK,1,,<empty>,,,,1,,ANY
223306,BLOCK,1,,<empty>,,,,1,,ANY
223309,BLOCK,1,,<empty>,,,,1,,ANY
223313,BLOCK,1,,<empty>,,,,1,,ANY
223320,BLOCK,1,,<empty>,,,,1,,ANY
223323,BLOCK,1,,<empty>,,,,1,,ANY
223327,BLOCK,1,,<empty>,,,,1,,ANY
223330,BLOCK,1,,<empty>,,,,1,,ANY
223334,BLOCK,1,,<empty>,,,,1,,ANY
223338,BLOCK,1,,<empty>,,,,1,,ANY
223345,BLOCK,1,,<empty>,,,,1,,ANY
223348,BLOCK,1,,<empty>,,,,1,,ANY
223355,BLOCK,1,,<empty>,,,,1,,ANY
223358,BLOCK,1,,<empty>,,,,1,,ANY
223365,BLOCK,1,,<empty>,,,,1,,ANY
223370,BLOCK,1,,<empty>,,,,1,,ANY
223375,BLOCK,1,,<empty>,,,,1,,ANY
223379,BLOCK,1,,<empty>,,,,1,,ANY
223387,BLOCK,1,,<empty>,,,,1,,ANY
223393,BLOCK,1,,<empty>,,,,1,,ANY
223397,BLOCK,1,,<empty>,,,,1,,ANY
223404,BLOCK,1,,<empty>,,,,1,,ANY
223408,BLOCK,1,,<empty>,,,,1,,ANY
223413,BLOCK,1,,<empty>,,,,1,,ANY
223417,BLOCK,1,,<empty>,,,,1,,ANY
223424,BLOCK,1,,<empty>,,,,1,,ANY
223428,BLOCK,1,,<empty>,,,,1,,ANY
223434,BLOCK,1,,<empty>,,,,1,,ANY
223439,BLOCK,1,,<empty>,,,,1,,ANY
223443,BLOCK,1,,<empty>,,,,1,,ANY
223448,BLOCK,1,,<empty>,,,,1,,ANY
223452,BLOCK,1,,<empty>,,,,1,,ANY
223456,BLOCK,1,,<empty>,,,,1,,ANY
223461,BLOCK,1,,<empty>,,,,1,,ANY
223466,BLOCK,1,,<empty>,,,,1,,ANY
223470,BLOCK,1,,<empty>,,,,1,,ANY
223474,BLOCK,1,,<empty>,,,,1,,ANY
223478,BLOCK,1,,<empty>,,,,1,,ANY
223482,BLOCK,1,,<empty>,,,,1,,ANY
223486,BLOCK,1,,<empty>,,,,1,,ANY
223491,BLOCK,1,,<empty>,,,,1,,ANY
223494,BLOCK,1,,<empty>,,,,1,,ANY
223499,BLOCK,1,,<empty>,,,,1,,ANY
223504,BLOCK,1,,<empty>,,,,1,,ANY
223508,BLOCK,1,,<empty>,,,,1,,ANY
223512,BLOCK,1,,<empty>,,,,1,,ANY
223516,BLOCK,1,,<empty>,,,,1,,ANY
223520,BLOCK,1,,<empty>,,,,1,,ANY
223525,BLOCK,1,,<empty>,,,,1,,ANY
223529,BLOCK,1,,<empty>,,,,1,,ANY
223533,BLOCK,1,,<empty>,,,,1,,ANY
223539,BLOCK,1,,<empty>,,,,1,,ANY
223543,BLOCK,1,,<empty>,,,,1,,ANY
223550,BLOCK,1,,<empty>,,,,1,,ANY
223556,BLOCK,1,,<empty>,,,,1,,ANY
223560,BLOCK,1,,<empty>,,,,1,,ANY
223564,BLOCK,1,,<empty>,,,,1,,ANY
223567,BLOCK,1,,<empty>,,,,1,,ANY
223572,BLOCK,1,,<empty>,,,,1,,ANY
223577,BLOCK,1,,<empty>,,,,1,,ANY
223583,BLOCK,1,,<empty>,,,,1,,ANY
223589,BLOCK,1,,<empty>,,,,1,,ANY
223594,BLOCK,1,,<empty>,,,,1,,ANY
223601,BLOCK,1,,<empty>,,,,1,,ANY
223605,BLOCK,1,,<empty>,,,,1,,ANY
223609,BLOCK,1,,<empty>,,,,1,,ANY
223612,BLOCK,1,,<empty>,,,,1,,ANY
223618,BLOCK,1,,<empty>,,,,1,,ANY
223621,BLOCK,1,,<empty>,,,,1,,ANY
223624,BLOCK,1,,<empty>,,,,1,,ANY
223629,BLOCK,1,,<empty>,,,,1,,ANY
223633,BLOCK,1,,<empty>,,,,1,,ANY
223637,BLOCK,1,,<empty>,,,,1,,ANY
223642,BLOCK,1,,<empty>,,,,1,,ANY
223646,BLOCK,1,,<empty>,,,,1,,ANY
223650,BLOCK,1,,<empty>,,,,1,,ANY
223655,BLOCK,1,,<empty>,,,,1,,ANY
223659,BLOCK,1,,<empty>,,,,1,,ANY
223667,BLOCK,1,,<empty>,,,,1,,ANY
223673,BLOCK,1,,<empty>,,,,1,,ANY
223677,BLOCK,1,,<empty>,,,,1,,ANY
223681,BLOCK,1,,<empty>,,,,1,,ANY
223686,BLOCK,1,,<empty>,,,,1,,ANY
223691,BLOCK,1,,<empty>,,,,1,,ANY
223696,BLOCK,1,,<empty>,,,,1,,ANY
223705,BLOCK,1,,<empty>,,,,1,,ANY
223709,BLOCK,1,,<empty>,,,,1,,ANY
223715,BLOCK,1,,<empty>,,,,1,,ANY
223718,BLOCK,1,,<empty>,,,,1,,ANY
223722,BLOCK,1,,<empty>,,,,1,,ANY
223725,BLOCK,1,,<empty>,,,,1,,ANY
223729,BLOCK,1,,<empty>,,,,1,,ANY
223733,BLOCK,1,,<empty>,,,,1,,ANY
223739,BLOCK,1,,<empty>,,,,1,,ANY
223743,BLOCK,1,,<empty>,,,,1,,ANY
223747,BLOCK,1,,<empty>,,,,1,,ANY
223751,BLOCK,1,,<empty>,,,,1,,ANY
223754,BLOCK,1,,<empty>,,,,1,,ANY
223757,BLOCK,1,,<empty>,,,,1,,ANY
223760,BLOCK,1,,<empty>,,,,1,,ANY
223766,BLOCK,1,,<empty>,,,,1,,ANY
223773,BLOCK,1,,<empty>,,,,1,,ANY
223776,BLOCK,1,,<empty>,,,,1,,ANY
223779,BLOCK,1,,<empty>,,,,1,,ANY
223784,BLOCK,1,,<empty>,,,,1,,ANY
223790,BLOCK,1,,<empty>,,,,1,,ANY
223796,BLOCK,1,,<empty>,,,,1,,ANY
223802,BLOCK,1,,<empty>,,,,1,,ANY
223807,BLOCK,1,,<empty>,,,,1,,ANY
223814,BLOCK,1,,<empty>,,,,1,,ANY
223820,BLOCK,1,,<empty>,,,,1,,ANY
223826,BLOCK,1,,<empty>,,,,1,,ANY
223832,BLOCK,1,,<empty>,,,,1,,ANY
223837,BLOCK,1,,<empty>,,,,1,,ANY
223843,BLOCK,1,,<empty>,,,,1,,ANY
223848,BLOCK,1,,<empty>,,,,1,,ANY
223853,BLOCK,1,,<empty>,,,,1,,ANY
223858,BLOCK,1,,<empty>,,,,1,,ANY
223862,BLOCK,1,,<empty>,,,,1,,ANY
223869,BLOCK,1,,<empty>,,,,1,,ANY
223874,BLOCK,1,,<empty>,,,,1,,ANY
223881,BLOCK,1,,<empty>,,,,1,,ANY
223885,BLOCK,1,,<empty>,,,,1,,ANY
223888,BLOCK,1,,<empty>,,,,1,,ANY
223894,BLOCK,1,,<empty>,,,,1,,ANY
223898,BLOCK,1,,<empty>,,,,1,,ANY
223902,BLOCK,1,,<empty>,,,,1,,ANY
223908,BLOCK,1,,<empty>,,,,1,,ANY
223913,BLOCK,1,,<empty>,,,,1,,ANY
223920,BLOCK,1,,<empty>,,,,1,,ANY
223925,BLOCK,1,,<empty>,,,,1,,ANY
223929,BLOCK,1,,<empty>,,,,1,,ANY
223935,BLOCK,1,,<empty>,,,,1,,ANY
223941,BLOCK,1,,<empty>,,,,1,,ANY
223947,BLOCK,1,,<empty>,,,,1,,ANY
223953,BLOCK,1,,<empty>,,,,1,,ANY
223959,BLOCK,1,,<empty>,,,,1,,ANY
223964,BLOCK,1,,<empty>,,,,1,,ANY
223969,BLOCK,1,,<empty>,,,,1,,ANY
223975,BLOCK,1,,<empty>,,,,1,,ANY
223982,BLOCK,1,,<empty>,,,,1,,ANY
223988,BLOCK,1,,<empty>,,,,1,,ANY
223995,BLOCK,1,,<empty>,,,,1,,ANY
224000,BLOCK,1,,<empty>,,,,1,,ANY
224006,BLOCK,1,,<empty>,,,,1,,ANY
224012,BLOCK,1,,<empty>,,,,1,,ANY
224017,BLOCK,1,,<empty>,,,,1,,ANY
224020,BLOCK,1,,<empty>,,,,1,,ANY
224024,BLOCK,1,,<empty>,,,,1,,ANY
224027,BLOCK,1,,<empty>,,,,1,,ANY
224030,BLOCK,1,,<empty>,,,,1,,ANY
224034,BLOCK,1,,<empty>,,,,1,,ANY
224037,BLOCK,1,,<empty>,,,,1,,ANY
224041,BLOCK,1,,<empty>,,,,1,,ANY
224044,BLOCK,1,,<empty>,,,,1,,ANY
224047,BLOCK,1,,<empty>,,,,1,,ANY
224050,BLOCK,1,,<empty>,,,,1,,ANY
224053,BLOCK,1,,<empty>,,,,1,,ANY
224056,BLOCK,1,,<empty>,,,,1,,ANY
224059,BLOCK,1,,<empty>,,,,1,,ANY
224062,BLOCK,1,,<empty>,,,,1,,ANY
224065,BLOCK,1,,<empty>,,,,1,,ANY
224070,BLOCK,1,,<empty>,,,,1,,ANY
224077,BLOCK,1,,<empty>,,,,1,,ANY
224083,BLOCK,1,,<empty>,,,,1,,ANY
224089,BLOCK,1,,<empty>,,,,1,,ANY
224094,BLOCK,1,,<empty>,,,,1,,ANY
224097,BLOCK,1,,<empty>,,,,1,,ANY
224100,BLOCK,1,,<empty>,,,,1,,ANY
224103,BLOCK,1,,<empty>,,,,1,,ANY
224108,BLOCK,1,,<empty>,,,,1,,ANY
224115,BLOCK,1,,<empty>,,,,1,,ANY
224120,BLOCK,1,,<empty>,,,,1,,ANY
224125,BLOCK,1,,<empty>,,,,1,,ANY
224129,BLOCK,1,,<empty>,,,,1,,ANY
224132,BLOCK,1,,<empty>,,,,1,,ANY
224136,BLOCK,1,,<empty>,,,,1,,ANY
224139,BLOCK,1,,<empty>,,,,1,,ANY
224142,BLOCK,1,,<empty>,,,,1,,ANY
224145,BLOCK,1,,<empty>,,,,1,,ANY
224148,BLOCK,1,,<empty>,,,,1,,ANY
224151,BLOCK,1,,<empty>,,,,1,,ANY
224157,BLOCK,1,,<empty>,,,,1,,ANY
224164,BLOCK,1,,<empty>,,,,1,,ANY
224167,BLOCK,1,,<empty>,,,,1,,ANY
224175,BLOCK,1,,<empty>,,,,1,,ANY
224178,BLOCK,1,,<empty>,,,,1,,ANY
224181,BLOCK,1,,<empty>,,,,1,,ANY
224184,BLOCK,1,,<empty>,,,,1,,ANY
224189,BLOCK,1,,<empty>,,,,1,,ANY
224195,BLOCK,1,,<empty>,,,,1,,ANY
224201,BLOCK,1,,<empty>,,,,1,,ANY
224206,BLOCK,1,,<empty>,,,,1,,ANY
224210,BLOCK,1,,<empty>,,,,1,,ANY
224218,BLOCK,1,,<empty>,,,,1,,ANY
224223,BLOCK,1,,<empty>,,,,1,,ANY
224228,BLOCK,1,,<empty>,,,,1,,ANY
224232,BLOCK,1,,<empty>,,,,1,,ANY
224236,BLOCK,1,,<empty>,,,,1,,ANY
224240,BLOCK,1,,<empty>,,,,1,,ANY
224243,BLOCK,1,,<empty>,,,,1,,ANY
224247,BLOCK,1,,<empty>,,,,1,,ANY
224253,BLOCK,1,,<empty>,,,,1,,ANY
224257,BLOCK,1,,<empty>,,,,1,,ANY
224262,BLOCK,1,,<empty>,,,,1,,ANY
224267,BLOCK,1,,<empty>,,,,1,,ANY
224270,BLOCK,1,,<empty>,,,,1,,ANY
224274,BLOCK,1,,<empty>,,,,1,,ANY
224278,BLOCK,1,,<empty>,,,,1,,ANY
224283,BLOCK,1,,<empty>,,,,1,,ANY
224287,BLOCK,1,,<empty>,,,,1,,ANY
224292,BLOCK,1,,<empty>,,,,1,,ANY
224296,BLOCK,1,,<empty>,,,,1,,ANY
224302,BLOCK,1,,<empty>,,,,1,,ANY
224308,BLOCK,1,,<empty>,,,,1,,ANY
224313,BLOCK,1,,<empty>,,,,1,,ANY
224320,BLOCK,1,,<empty>,,,,1,,ANY
224330,BLOCK,1,,<empty>,,,,1,,ANY
224335,BLOCK,1,,<empty>,,,,1,,ANY
224339,BLOCK,1,,<empty>,,,,1,,ANY
224344,BLOCK,1,,<empty>,,,,1,,ANY
224348,BLOCK,1,,<empty>,,,,1,,ANY
224353,BLOCK,1,,<empty>,,,,1,,ANY
224356,BLOCK,1,,<empty>,,,,1,,ANY
224360,BLOCK,1,,<empty>,,,,1,,ANY
224365,BLOCK,1,,<empty>,,,,1,,ANY
224369,BLOCK,1,,<empty>,,,,1,,ANY
224372,BLOCK,1,,<empty>,,,,1,,ANY
224382,BLOCK,1,,<empty>,,,,1,,ANY
224387,BLOCK,1,,<empty>,,,,1,,ANY
224393,BLOCK,1,,<empty>,,,,1,,ANY
224400,BLOCK,1,,<empty>,,,,1,,ANY
224405,BLOCK,1,,<empty>,,,,1,,ANY
224411,BLOCK,1,,<empty>,,,,1,,ANY
224415,BLOCK,1,,<empty>,,,,1,,ANY
224420,BLOCK,1,,<empty>,,,,1,,ANY
224428,BLOCK,1,,<empty>,,,,1,,ANY
224434,BLOCK,1,,<empty>,,,,1,,ANY
224439,BLOCK,1,,<empty>,,,,1,,ANY
224444,BLOCK,1,,<empty>,,,,1,,ANY
224449,BLOCK,1,,<empty>,,,,1,,ANY
224452,BLOCK,1,,<empty>,,,,1,,ANY
224456,BLOCK,1,,<empty>,,,,1,,ANY
224461,BLOCK,1,,<empty>,,,,1,,ANY
224468,BLOCK,1,,<empty>,,,,1,,ANY
224472,BLOCK,1,,<empty>,,,,1,,ANY
224476,BLOCK,1,,<empty>,,,,1,,ANY
224480,BLOCK,1,,<empty>,,,,1,,ANY
224486,BLOCK,1,,<empty>,,,,1,,ANY
224490,BLOCK,1,,<empty>,,,,1,,ANY
224494,BLOCK,1,,<empty>,,,,1,,ANY
224498,BLOCK,1,,<empty>,,,,1,,ANY
224501,BLOCK,1,,<empty>,,,,1,,ANY
224505,BLOCK,1,,<empty>,,,,1,,ANY
224510,BLOCK,1,,<empty>,,,,1,,ANY
224514,BLOCK,1,,<empty>,,,,1,,ANY
224518,BLOCK,1,,<empty>,,,,1,,ANY
224525,BLOCK,1,,<empty>,,,,1,,ANY
224529,BLOCK,1,,<empty>,,,,1,,ANY
224533,BLOCK,1,,<empty>,,,,1,,ANY
224542,BLOCK,1,,<empty>,,,,1,,ANY
224547,BLOCK,1,,<empty>,,,,1,,ANY
224553,BLOCK,1,,<empty>,,,,1,,ANY
224556,BLOCK,1,,<empty>,,,,1,,ANY
224562,BLOCK,1,,<empty>,,,,1,,ANY
224568,BLOCK,1,,<empty>,,,,1,,ANY
224573,BLOCK,1,,<empty>,,,,1,,ANY
224577,BLOCK,1,,<empty>,,,,1,,ANY
224581,BLOCK,1,,<empty>,,,,1,,ANY
224584,BLOCK,1,,<empty>,,,,1,,ANY
224588,BLOCK,1,,<empty>,,,,1,,ANY
224592,BLOCK,1,,<empty>,,,,1,,ANY
224596,BLOCK,1,,<empty>,,,,1,,ANY
224601,BLOCK,1,,<empty>,,,,1,,ANY
224605,BLOCK,1,,<empty>,,,,1,,ANY
224609,BLOCK,1,,<empty>,,,,1,,ANY
224615,BLOCK,1,,<empty>,,,,1,,ANY
224619,BLOCK,1,,<empty>,,,,1,,ANY
224623,BLOCK,1,,<empty>,,,,1,,ANY
224627,BLOCK,1,,<empty>,,,,1,,ANY
224632,BLOCK,1,,<empty>,,,,1,,ANY
224635,BLOCK,1,,<empty>,,,,1,,ANY
224638,BLOCK,1,,<empty>,,,,1,,ANY
224642,BLOCK,1,,<empty>,,,,1,,ANY
224648,BLOCK,1,,<empty>,,,,1,,ANY
224658,BLOCK,1,,<empty>,,,,1,,ANY
