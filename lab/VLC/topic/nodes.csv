,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,2134,lock,3,aout_owner_t.lock,,audio_output\aout_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1,2136,filters,3,aout_owner_t.filters,,audio_output\aout_internal.h,*filters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2,2137,volume,3,aout_owner_t.volume,,audio_output\aout_internal.h,*volume,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
3,2161,input_format,3,aout_owner_t.input_format,,audio_output\aout_internal.h,input_format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
4,2162,mixer_format,3,aout_owner_t.mixer_format,,audio_output\aout_internal.h,mixer_format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
5,2163,request_vout,3,aout_owner_t.request_vout,,audio_output\aout_internal.h,request_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
6,2164,filters_cfg,3,aout_owner_t.filters_cfg,,audio_output\aout_internal.h,filters_cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7,2167,restart,3,aout_owner_t.restart,,audio_output\aout_internal.h,restart,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8,19529,name,3,vlc_option.name,,config\vlc_getopt.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
9,19530,has_arg,3,vlc_option.has_arg,,config\vlc_getopt.h,has_arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
10,19531,flag,3,vlc_option.flag,,config\vlc_getopt.h,*flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
11,19532,val,3,vlc_option.val,,config\vlc_getopt.h,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
12,24158,lock,3,input_clock_t.lock,,input\clock.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
13,24159,last,3,input_clock_t.last,,input\clock.c,last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
14,24160,i_ts_max,3,input_clock_t.i_ts_max,,input\clock.c,i_ts_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
15,24161,i_buffering_duration,3,input_clock_t.i_buffering_duration,,input\clock.c,i_buffering_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
16,24162,i_next_drift_update,3,input_clock_t.i_next_drift_update,,input\clock.c,i_next_drift_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
17,24163,drift,3,input_clock_t.drift,,input\clock.c,drift,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
18,24176,ref,3,input_clock_t.ref,,input\clock.c,ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
19,24177,b_has_reference,3,input_clock_t.b_has_reference,,input\clock.c,b_has_reference,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
20,24179,b_has_external_clock,3,input_clock_t.b_has_external_clock,,input\clock.c,b_has_external_clock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
21,24180,b_paused,3,input_clock_t.b_paused,,input\clock.c,b_paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
22,24181,i_rate,3,input_clock_t.i_rate,,input\clock.c,i_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
23,24182,i_pts_delay,3,input_clock_t.i_pts_delay,,input\clock.c,i_pts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
24,24183,i_pause_date,3,input_clock_t.i_pause_date,,input\clock.c,i_pause_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
25,27542,p_input,3,decoder_owner_sys_t.p_input,,input\decoder.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
26,27543,p_resource,3,decoder_owner_sys_t.p_resource,,input\decoder.c,*p_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
27,27544,p_clock,3,decoder_owner_sys_t.p_clock,,input\decoder.c,*p_clock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
28,27545,i_last_rate,3,decoder_owner_sys_t.i_last_rate,,input\decoder.c,i_last_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
29,27546,p_spu_vout,3,decoder_owner_sys_t.p_spu_vout,,input\decoder.c,*p_spu_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
30,27547,i_spu_channel,3,decoder_owner_sys_t.i_spu_channel,,input\decoder.c,i_spu_channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
31,27548,i_spu_order,3,decoder_owner_sys_t.i_spu_order,,input\decoder.c,i_spu_order,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
32,27549,p_sout,3,decoder_owner_sys_t.p_sout,,input\decoder.c,*p_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
33,27550,p_sout_input,3,decoder_owner_sys_t.p_sout_input,,input\decoder.c,*p_sout_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
34,27551,thread,3,decoder_owner_sys_t.thread,,input\decoder.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
35,27559,p_packetizer,3,decoder_owner_sys_t.p_packetizer,,input\decoder.c,*p_packetizer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
36,27561,fmt,3,decoder_owner_sys_t.fmt,,input\decoder.c,fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
37,27562,b_fmt_description,3,decoder_owner_sys_t.b_fmt_description,,input\decoder.c,b_fmt_description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
38,27563,p_description,3,decoder_owner_sys_t.p_description,,input\decoder.c,*p_description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
39,27564,reload,3,decoder_owner_sys_t.reload,,input\decoder.c,reload,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
40,27565,p_fifo,3,decoder_owner_sys_t.p_fifo,,input\decoder.c,*p_fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,47,0,1,1,0,0,,0,0,0,0,0,
41,27566,lock,3,decoder_owner_sys_t.lock,,input\decoder.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,67,0,1,1,0,0,,0,0,0,0,0,
42,27567,wait_request,3,decoder_owner_sys_t.wait_request,,input\decoder.c,wait_request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
43,27568,wait_acknowledge,3,decoder_owner_sys_t.wait_acknowledge,,input\decoder.c,wait_acknowledge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
44,27569,wait_fifo,3,decoder_owner_sys_t.wait_fifo,,input\decoder.c,wait_fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
45,27570,wait_timed,3,decoder_owner_sys_t.wait_timed,,input\decoder.c,wait_timed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
46,27571,p_aout,3,decoder_owner_sys_t.p_aout,,input\decoder.c,*p_aout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
47,27572,p_vout,3,decoder_owner_sys_t.p_vout,,input\decoder.c,*p_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
48,27573,i_preroll_end,3,decoder_owner_sys_t.i_preroll_end,,input\decoder.c,i_preroll_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
49,27574,pause_date,3,decoder_owner_sys_t.pause_date,,input\decoder.c,pause_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
50,27575,frames_countdown,3,decoder_owner_sys_t.frames_countdown,,input\decoder.c,frames_countdown,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
51,27576,paused,3,decoder_owner_sys_t.paused,,input\decoder.c,paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
52,27577,error,3,decoder_owner_sys_t.error,,input\decoder.c,error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
53,27578,b_waiting,3,decoder_owner_sys_t.b_waiting,,input\decoder.c,b_waiting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
54,27579,b_first,3,decoder_owner_sys_t.b_first,,input\decoder.c,b_first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
55,27580,b_has_data,3,decoder_owner_sys_t.b_has_data,,input\decoder.c,b_has_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
56,27581,flushing,3,decoder_owner_sys_t.flushing,,input\decoder.c,flushing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
57,27582,b_draining,3,decoder_owner_sys_t.b_draining,,input\decoder.c,b_draining,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
58,27583,drained,3,decoder_owner_sys_t.drained,,input\decoder.c,drained,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
59,27584,b_idle,3,decoder_owner_sys_t.b_idle,,input\decoder.c,b_idle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
60,27598,i_ts_delay,3,decoder_owner_sys_t.i_ts_delay,,input\decoder.c,i_ts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
61,34094,key,3,demux_mapping.key,,input\demux.c,key[20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
62,34095,name,3,demux_mapping.name,,input\demux.c,name[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
63,34386,demux,3,demux_priv_t.demux,,input\demux.c,demux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
64,35808,fifo,3,vlc_demux_chained_t.fifo,,input\demux_chained.c,*fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
65,35809,thread,3,vlc_demux_chained_t.thread,,input\demux_chained.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
66,35810,lock,3,vlc_demux_chained_t.lock,,input\demux_chained.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
67,35816,out,3,vlc_demux_chained_t.out,,input\demux_chained.c,*out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
68,35817,name,3,vlc_demux_chained_t.name,,input\demux_chained.c,name[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
69,36226,i_id,3,es_out_pgrm_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
70,36227,i_es,3,es_out_pgrm_t.i_es,,input\es_out.c,i_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
71,36228,b_selected,3,es_out_pgrm_t.b_selected,,input\es_out.c,b_selected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
72,36229,b_scrambled,3,es_out_pgrm_t.b_scrambled,,input\es_out.c,b_scrambled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
73,36230,p_clock,3,es_out_pgrm_t.p_clock,,input\es_out.c,*p_clock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
74,36231,i_last_pcr,3,es_out_pgrm_t.i_last_pcr,,input\es_out.c,i_last_pcr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
75,36232,p_meta,3,es_out_pgrm_t.p_meta,,input\es_out.c,*p_meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
76,36235,i_id,3,es_out_id_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
77,36236,p_pgrm,3,es_out_id_t.p_pgrm,,input\es_out.c,*p_pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
78,36237,b_scrambled,3,es_out_id_t.b_scrambled,,input\es_out.c,b_scrambled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
79,36238,i_channel,3,es_out_id_t.i_channel,,input\es_out.c,i_channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
80,36239,fmt,3,es_out_id_t.fmt,,input\es_out.c,fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,44,0,1,1,0,0,,0,0,0,0,0,
81,36240,psz_language,3,es_out_id_t.psz_language,,input\es_out.c,*psz_language,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
82,36241,psz_language_code,3,es_out_id_t.psz_language_code,,input\es_out.c,*psz_language_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
83,36242,p_dec,3,es_out_id_t.p_dec,,input\es_out.c,*p_dec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
84,36243,p_dec_record,3,es_out_id_t.p_dec_record,,input\es_out.c,*p_dec_record,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
85,36244,i_pts_level,3,es_out_id_t.i_pts_level,,input\es_out.c,i_pts_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
86,36256,p_master,3,es_out_id_t.p_master,,input\es_out.c,*p_master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
87,36257,i_meta_id,3,es_out_id_t.i_meta_id,,input\es_out.c,i_meta_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
88,36259,i_count,3,es_out_es_props_t.i_count,,input\es_out.c,i_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
89,36260,p_main_es,3,es_out_es_props_t.p_main_es,,input\es_out.c,*p_main_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
90,36262,e_policy,3,es_out_es_props_t.e_policy,,input\es_out.c,e_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
91,36263,b_autoselect,3,es_out_es_props_t.b_autoselect,,input\es_out.c,b_autoselect,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
92,36264,i_id,3,es_out_es_props_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
93,36265,i_demux_id,3,es_out_es_props_t.i_demux_id,,input\es_out.c,i_demux_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
94,36266,i_channel,3,es_out_es_props_t.i_channel,,input\es_out.c,i_channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
95,36267,ppsz_language,3,es_out_es_props_t.ppsz_language,,input\es_out.c,**ppsz_language,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
96,36272,i_pgrm,3,es_out_sys_t.i_pgrm,,input\es_out.c,i_pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
97,36273,pgrm,3,es_out_sys_t.pgrm,,input\es_out.c,**pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
98,36274,p_pgrm,3,es_out_sys_t.p_pgrm,,input\es_out.c,*p_pgrm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
99,36275,i_id,3,es_out_sys_t.i_id,,input\es_out.c,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
100,36277,es,3,es_out_sys_t.es,,input\es_out.c,**es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
101,36278,b_active,3,es_out_sys_t.b_active,,input\es_out.c,b_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
102,36279,i_mode,3,es_out_sys_t.i_mode,,input\es_out.c,i_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
103,36280,video,3,es_out_sys_t.video,,input\es_out.c,video,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
104,36281,audio,3,es_out_sys_t.audio,,input\es_out.c,audio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
105,36282,sub,3,es_out_sys_t.sub,,input\es_out.c,sub,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
106,36283,i_group_id,3,es_out_sys_t.i_group_id,,input\es_out.c,i_group_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
107,36284,i_audio_delay,3,es_out_sys_t.i_audio_delay,,input\es_out.c,i_audio_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
108,36286,i_pts_delay,3,es_out_sys_t.i_pts_delay,,input\es_out.c,i_pts_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
109,36287,i_pts_jitter,3,es_out_sys_t.i_pts_jitter,,input\es_out.c,i_pts_jitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
110,36288,i_cr_average,3,es_out_sys_t.i_cr_average,,input\es_out.c,i_cr_average,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
111,36289,i_rate,3,es_out_sys_t.i_rate,,input\es_out.c,i_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
112,36290,b_paused,3,es_out_sys_t.b_paused,,input\es_out.c,b_paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
113,36291,i_pause_date,3,es_out_sys_t.i_pause_date,,input\es_out.c,i_pause_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
114,36292,i_preroll_end,3,es_out_sys_t.i_preroll_end,,input\es_out.c,i_preroll_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
115,36293,b_buffering,3,es_out_sys_t.b_buffering,,input\es_out.c,b_buffering,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
116,36294,i_buffering_extra_initial,3,es_out_sys_t.i_buffering_extra_initial,,input\es_out.c,i_buffering_extra_initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
117,36295,i_buffering_extra_stream,3,es_out_sys_t.i_buffering_extra_stream,,input\es_out.c,i_buffering_extra_stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
118,36296,i_buffering_extra_system,3,es_out_sys_t.i_buffering_extra_system,,input\es_out.c,i_buffering_extra_system,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
119,36297,p_sout_record,3,es_out_sys_t.p_sout_record,,input\es_out.c,*p_sout_record,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
120,36298,i_prev_stream_level,3,es_out_sys_t.i_prev_stream_level,,input\es_out.c,i_prev_stream_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
121,47073,lock,3,ts_thread_t.lock,,input\es_out_timeshift.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
122,47074,wait,3,ts_thread_t.wait,,input\es_out_timeshift.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
123,47089,p_input,3,es_out_sys_t.p_input,,input\es_out_timeshift.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,35,0,1,1,0,0,,0,0,0,0,0,
124,47090,p_out,3,es_out_sys_t.p_out,,input\es_out_timeshift.c,*p_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
125,47091,i_tmp_size_max,3,es_out_sys_t.i_tmp_size_max,,input\es_out_timeshift.c,i_tmp_size_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
126,47092,psz_tmp_path,3,es_out_sys_t.psz_tmp_path,,input\es_out_timeshift.c,*psz_tmp_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
127,47093,lock,3,es_out_sys_t.lock,,input\es_out_timeshift.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
128,47094,b_delayed,3,es_out_sys_t.b_delayed,,input\es_out_timeshift.c,b_delayed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
129,47095,p_ts,3,es_out_sys_t.p_ts,,input\es_out_timeshift.c,*p_ts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
130,47096,b_input_paused,3,es_out_sys_t.b_input_paused,,input\es_out_timeshift.c,b_input_paused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
131,47097,b_input_paused_source,3,es_out_sys_t.b_input_paused_source,,input\es_out_timeshift.c,b_input_paused_source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
132,47098,i_input_rate,3,es_out_sys_t.i_input_rate,,input\es_out_timeshift.c,i_input_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
133,47099,i_input_rate_source,3,es_out_sys_t.i_input_rate_source,,input\es_out_timeshift.c,i_input_rate_source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
134,47100,i_es,3,es_out_sys_t.i_es,,input\es_out_timeshift.c,i_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
135,47101,pp_es,3,es_out_sys_t.pp_es,,input\es_out_timeshift.c,**pp_es,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
136,63267,p_demux,3,input_source_t.p_demux,,input\input_internal.h,*p_demux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
137,63269,i_title,3,input_source_t.i_title,,input\input_internal.h,i_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
138,63270,title,3,input_source_t.title,,input\input_internal.h,**title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
139,63271,i_title_offset,3,input_source_t.i_title_offset,,input\input_internal.h,i_title_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
140,63272,i_seekpoint_offset,3,input_source_t.i_seekpoint_offset,,input\input_internal.h,i_seekpoint_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
141,63273,i_title_start,3,input_source_t.i_title_start,,input\input_internal.h,i_title_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
142,63274,i_title_end,3,input_source_t.i_title_end,,input\input_internal.h,i_title_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
143,63275,i_seekpoint_start,3,input_source_t.i_seekpoint_start,,input\input_internal.h,i_seekpoint_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
144,63276,i_seekpoint_end,3,input_source_t.i_seekpoint_end,,input\input_internal.h,i_seekpoint_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
145,63277,b_can_pause,3,input_source_t.b_can_pause,,input\input_internal.h,b_can_pause,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
146,63278,b_can_pace_control,3,input_source_t.b_can_pace_control,,input\input_internal.h,b_can_pace_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
147,63279,b_can_rate_control,3,input_source_t.b_can_rate_control,,input\input_internal.h,b_can_rate_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
148,63287,i_type,3,input_control_t.i_type,,input\input_internal.h,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
149,63288,val,3,input_control_t.val,,input\input_internal.h,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
150,63293,b_preparsing,3,input_thread_private_t.b_preparsing,,input\input_internal.h,b_preparsing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
151,63294,b_can_pause,3,input_thread_private_t.b_can_pause,,input\input_internal.h,b_can_pause,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
152,63295,b_can_rate_control,3,input_thread_private_t.b_can_rate_control,,input\input_internal.h,b_can_rate_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
153,63296,b_can_pace_control,3,input_thread_private_t.b_can_pace_control,,input\input_internal.h,b_can_pace_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
154,63298,is_running,3,input_thread_private_t.is_running,,input\input_internal.h,is_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
155,63299,is_stopped,3,input_thread_private_t.is_stopped,,input\input_internal.h,is_stopped,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
156,63302,i_start,3,input_thread_private_t.i_start,,input\input_internal.h,i_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
157,63303,i_stop,3,input_thread_private_t.i_stop,,input\input_internal.h,i_stop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
158,63304,i_time,3,input_thread_private_t.i_time,,input\input_internal.h,i_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
159,63305,b_fast_seek,3,input_thread_private_t.b_fast_seek,,input\input_internal.h,b_fast_seek,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
160,63308,p_es_out,3,input_thread_private_t.p_es_out,,input\input_internal.h,*p_es_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
161,63309,p_es_out_display,3,input_thread_private_t.p_es_out_display,,input\input_internal.h,*p_es_out_display,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
162,63310,viewpoint,3,input_thread_private_t.viewpoint,,input\input_internal.h,viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
163,63311,viewpoint_changed,3,input_thread_private_t.viewpoint_changed,,input\input_internal.h,viewpoint_changed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
164,63312,p_renderer,3,input_thread_private_t.p_renderer,,input\input_internal.h,*p_renderer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
165,63313,i_title,3,input_thread_private_t.i_title,,input\input_internal.h,i_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
166,63314,title,3,input_thread_private_t.title,,input\input_internal.h,**title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
167,63315,i_title_offset,3,input_thread_private_t.i_title_offset,,input\input_internal.h,i_title_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
168,63316,i_seekpoint_offset,3,input_thread_private_t.i_seekpoint_offset,,input\input_internal.h,i_seekpoint_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
169,63317,bookmark,3,input_thread_private_t.bookmark,,input\input_internal.h,bookmark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
170,63318,i_bookmark,3,input_thread_private_t.i_bookmark,,input\input_internal.h,i_bookmark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
171,63319,pp_bookmark,3,input_thread_private_t.pp_bookmark,,input\input_internal.h,**pp_bookmark,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
172,63320,i_attachment,3,input_thread_private_t.i_attachment,,input\input_internal.h,i_attachment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
173,63321,attachment,3,input_thread_private_t.attachment,,input\input_internal.h,**attachment,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
174,63323,p_item,3,input_thread_private_t.p_item,,input\input_internal.h,*p_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
175,63324,master,3,input_thread_private_t.master,,input\input_internal.h,*master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
176,63325,i_slave,3,input_thread_private_t.i_slave,,input\input_internal.h,i_slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
177,63327,p_resource,3,input_thread_private_t.p_resource,,input\input_internal.h,*p_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
178,63328,p_resource_private,3,input_thread_private_t.p_resource_private,,input\input_internal.h,*p_resource_private,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
179,63349,lock_control,3,input_thread_private_t.lock_control,,input\input_internal.h,lock_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
180,63350,wait_control,3,input_thread_private_t.wait_control,,input\input_internal.h,wait_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
181,63351,i_control,3,input_thread_private_t.i_control,,input\input_internal.h,i_control,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
182,63352,control,3,input_thread_private_t.control,,input\input_internal.h,control[INPUT_CONTROL_FIFO_SIZE],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
183,63353,thread,3,input_thread_private_t.thread,,input\input_internal.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
184,63354,interrupt,3,input_thread_private_t.interrupt,,input\input_internal.h,interrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
185,66805,psz_scheme,3,item_type_entry.psz_scheme,,input\item.c,*psz_scheme,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
186,67712,p_slave,3,rdh_slave.p_slave,,input\item.c,*p_slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
187,67713,psz_filename,3,rdh_slave.psz_filename,,input\item.c,*psz_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
188,67714,p_node,3,rdh_slave.p_node,,input\item.c,*p_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
189,67716,p_node,3,rdh_dir.p_node,,input\item.c,*p_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
190,67717,psz_path,3,rdh_dir.psz_path,,input\item.c,psz_path[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
191,68915,ppsz_meta,3,vlc_meta_t.ppsz_meta,,input\meta.c,* ppsz_meta[VLC_META_TYPE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
192,68916,extra_tags,3,vlc_meta_t.extra_tags,,input\meta.c,extra_tags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
193,68917,i_status,3,vlc_meta_t.i_status,,input\meta.c,i_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
194,69998,refs,3,input_resource_t.refs,,input\resource.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
195,69999,p_parent,3,input_resource_t.p_parent,,input\resource.c,*p_parent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
196,70000,lock,3,input_resource_t.lock,,input\resource.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
197,70001,p_input,3,input_resource_t.p_input,,input\resource.c,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
198,70002,p_sout,3,input_resource_t.p_sout,,input\resource.c,*p_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
199,70003,p_vout_free,3,input_resource_t.p_vout_free,,input\resource.c,*p_vout_free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
200,70004,lock_hold,3,input_resource_t.lock_hold,,input\resource.c,lock_hold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
201,70005,pp_vout,3,input_resource_t.pp_vout,,input\resource.c,**pp_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
202,70006,i_vout,3,input_resource_t.i_vout,,input\resource.c,i_vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
203,70007,b_aout_busy,3,input_resource_t.b_aout_busy,,input\resource.c,b_aout_busy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
204,70008,p_aout,3,input_resource_t.p_aout,,input\resource.c,*p_aout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
205,71142,name,3,vlc_sd_probe_t.name,,input\services_discovery.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
206,71143,longname,3,vlc_sd_probe_t.longname,,input\services_discovery.c,*longname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
207,72151,stream,3,stream_priv_t.stream,,input\stream.c,stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
208,72157,block,3,stream_priv_t.block,,input\stream.c,*block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
209,72158,peek,3,stream_priv_t.peek,,input\stream.c,*peek,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
210,72159,offset,3,stream_priv_t.offset,,input\stream.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
211,72160,eof,3,stream_priv_t.eof,,input\stream.c,eof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
212,74149,extractor,3,stream_extractor_private.anonymous_composite_type_0.extractor,,input\stream_extractor.c,extractor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
213,74150,directory,3,stream_extractor_private.anonymous_composite_type_0.directory,,input\stream_extractor.c,directory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
214,74162,wrapper,3,stream_extractor_private.wrapper,,input\stream_extractor.c,* wrapper,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
215,74163,source,3,stream_extractor_private.source,,input\stream_extractor.c,* source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
216,74164,module,3,stream_extractor_private.module,,input\stream_extractor.c,* module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
217,74165,object,3,stream_extractor_private.object,,input\stream_extractor.c,* object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
218,74922,fifo,3,stream_sys_t.fifo,,input\stream_fifo.c,*fifo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
219,74923,eof,3,stream_sys_t.eof,,input\stream_fifo.c,eof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
220,75526,i_pos,3,stream_sys_t.i_pos,,input\stream_memory.c,i_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
221,75527,i_size,3,stream_sys_t.i_size,,input\stream_memory.c,i_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
222,75528,p_buffer,3,stream_sys_t.p_buffer,,input\stream_memory.c,*p_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
223,79347,p_sem,3,preparse_data_t.p_sem,,input\vlm.c,*p_sem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
224,79348,b_mux,3,preparse_data_t.b_mux,,input\vlm.c,b_mux,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
225,83657,psz_name,3,vlm_media_instance_sys_t.psz_name,,input\vlm_internal.h,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
226,83658,i_index,3,vlm_media_instance_sys_t.i_index,,input\vlm_internal.h,i_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
227,83659,b_sout_keep,3,vlm_media_instance_sys_t.b_sout_keep,,input\vlm_internal.h,b_sout_keep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
228,83660,p_parent,3,vlm_media_instance_sys_t.p_parent,,input\vlm_internal.h,*p_parent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
229,83661,p_item,3,vlm_media_instance_sys_t.p_item,,input\vlm_internal.h,*p_item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
230,83662,p_input,3,vlm_media_instance_sys_t.p_input,,input\vlm_internal.h,*p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
231,83663,p_input_resource,3,vlm_media_instance_sys_t.p_input_resource,,input\vlm_internal.h,*p_input_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
232,83666,cfg,3,vlm_media_sys_t.cfg,,input\vlm_internal.h,cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,
233,83671,i_instance,3,vlm_media_sys_t.i_instance,,input\vlm_internal.h,i_instance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
234,83672,instance,3,vlm_media_sys_t.instance,,input\vlm_internal.h,**instance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
235,83686,lock,3,vlm_t.lock,,input\vlm_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
236,83687,lock_delete,3,vlm_t.lock_delete,,input\vlm_internal.h,lock_delete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
237,83688,wait_delete,3,vlm_t.wait_delete,,input\vlm_internal.h,wait_delete,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
238,83689,thread,3,vlm_t.thread,,input\vlm_internal.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
239,83690,lock_manage,3,vlm_t.lock_manage,,input\vlm_internal.h,lock_manage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
240,83691,wait_manage,3,vlm_t.wait_manage,,input\vlm_internal.h,wait_manage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
241,83692,users,3,vlm_t.users,,input\vlm_internal.h,users,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
242,83693,input_state_changed,3,vlm_t.input_state_changed,,input\vlm_internal.h,input_state_changed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
243,83694,i_id,3,vlm_t.i_id,,input\vlm_internal.h,i_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
244,83695,p_vod,3,vlm_t.p_vod,,input\vlm_internal.h,*p_vod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
245,83696,i_media,3,vlm_t.i_media,,input\vlm_internal.h,i_media,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
246,83697,media,3,vlm_t.media,,input\vlm_internal.h,**media,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
247,83698,i_schedule,3,vlm_t.i_schedule,,input\vlm_internal.h,i_schedule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
248,83699,schedule,3,vlm_t.schedule,,input\vlm_internal.h,**schedule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
249,83700,i_consecutive_errors,3,vlm_t.i_consecutive_errors,,input\vlm_internal.h,i_consecutive_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
250,83787,lock,3,vlc_dialog_provider.lock,,interface\dialog.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
251,83788,dialog_array,3,vlc_dialog_provider.dialog_array,,interface\dialog.c,dialog_array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
252,83789,cbs,3,vlc_dialog_provider.cbs,,interface\dialog.c,cbs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
253,83790,p_cbs_data,3,vlc_dialog_provider.p_cbs_data,,interface\dialog.c,*                      p_cbs_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
254,83791,pf_ext_update,3,vlc_dialog_provider.pf_ext_update,,interface\dialog.c,pf_ext_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
255,83792,p_ext_data,3,vlc_dialog_provider.p_ext_data,,interface\dialog.c,*                      p_ext_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
256,83810,u,3,dialog_answer.u,,interface\dialog.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
257,83834,lock,3,vlc_dialog_id.lock,,interface\dialog.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
258,83835,wait,3,vlc_dialog_id.wait,,interface\dialog.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
259,83837,i_type,3,vlc_dialog_id.i_type,,interface\dialog.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
260,83838,p_context,3,vlc_dialog_id.p_context,,interface\dialog.c,*                  p_context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
261,83839,i_refcount,3,vlc_dialog_id.i_refcount,,interface\dialog.c,i_refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
262,83840,b_cancelled,3,vlc_dialog_id.b_cancelled,,interface\dialog.c,b_cancelled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
263,83841,b_answered,3,vlc_dialog_id.b_answered,,interface\dialog.c,b_answered,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
264,83842,b_progress_indeterminate,3,vlc_dialog_id.b_progress_indeterminate,,interface\dialog.c,b_progress_indeterminate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
265,83843,psz_progress_text,3,vlc_dialog_id.psz_progress_text,,interface\dialog.c,*                  psz_progress_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
266,83845,answer,3,vlc_dialog_id.answer,,interface\dialog.c,answer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
267,83847,p_provider,3,dialog_i11e_context.p_provider,,interface\dialog.c,*   p_provider,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
268,83848,p_id,3,dialog_i11e_context.p_id,,interface\dialog.c,*         p_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
269,87952,b_stats,3,libvlc_priv_t.b_stats,,libvlc.h,b_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
270,87954,p_vlm,3,libvlc_priv_t.p_vlm,,libvlc.h,*p_vlm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
271,87956,p_memory_keystore,3,libvlc_priv_t.p_memory_keystore,,libvlc.h,*p_memory_keystore,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
272,87958,playlist,3,libvlc_priv_t.playlist,,libvlc.h,*playlist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
273,87960,parser,3,libvlc_priv_t.parser,,libvlc.h,*parser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
274,87962,exit,3,libvlc_priv_t.exit,,libvlc.h,exit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
275,88008,value,3,counter_sample_t.value,,libvlc.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
276,88009,date,3,counter_sample_t.date,,libvlc.h,date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
277,88012,i_compute_type,3,counter_t.i_compute_type,,libvlc.h,i_compute_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
278,88013,i_samples,3,counter_t.i_samples,,libvlc.h,i_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
279,88014,pp_samples,3,counter_t.pp_samples,,libvlc.h,** pp_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
280,88015,last_update,3,counter_t.last_update,,libvlc.h,last_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
281,88743,i_code,3,key_descriptor.i_code,,misc\actions.c,i_code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
282,89498,psz,3,name2action.psz,,misc\actions.c,psz[MAXACTION],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
283,89499,id,3,name2action.id,,misc\actions.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
284,89846,key,3,mapping.key,,misc\actions.c,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
285,89847,action,3,mapping.action,,misc\actions.c,action,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
286,89885,map,3,vlc_actions_t.map,,misc\actions.c,*map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
287,89886,global_map,3,vlc_actions_t.global_map,,misc\actions.c,*global_map,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
288,89887,ppsz_keys,3,vlc_actions_t.ppsz_keys,,misc\actions.c,*ppsz_keys[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
289,92620,id,3,bg_queued_item.id,,misc\background_worker.c,* id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
290,92621,entity,3,bg_queued_item.entity,,misc\background_worker.c,* entity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
291,92622,timeout,3,bg_queued_item.timeout,,misc\background_worker.c,timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
292,92624,owner,3,background_worker.owner,,misc\background_worker.c,* owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
293,92626,conf,3,background_worker.conf,,misc\background_worker.c,conf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
294,92627,lock,3,background_worker.lock,,misc\background_worker.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
295,97271,p_user_data,3,vlc_event_listener_t.p_user_data,,misc\events.c,*               p_user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
296,97272,pf_callback,3,vlc_event_listener_t.pf_callback,,misc\events.c,pf_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
297,97668,lock,3,block_fifo_t.lock,,misc\fifo.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
298,97669,wait,3,block_fifo_t.wait,,misc\fifo.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
299,97670,p_first,3,block_fifo_t.p_first,,misc\fifo.c,*p_first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
300,97671,pp_last,3,block_fifo_t.pp_last,,misc\fifo.c,**pp_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
301,97672,i_depth,3,block_fifo_t.i_depth,,misc\fifo.c,i_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
302,97673,i_size,3,block_fifo_t.i_size,,misc\fifo.c,i_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
303,98768,filter,3,chained_filter_t.filter,,misc\filter_chain.c,filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
304,98770,prev,3,chained_filter_t.prev,,misc\filter_chain.c,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
305,98771,next,3,chained_filter_t.next,,misc\filter_chain.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
306,98772,mouse,3,chained_filter_t.mouse,,misc\filter_chain.c,*mouse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
307,98773,pending,3,chained_filter_t.pending,,misc\filter_chain.c,*pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
308,98786,callbacks,3,filter_chain_t.callbacks,,misc\filter_chain.c,callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
309,98787,owner,3,filter_chain_t.owner,,misc\filter_chain.c,owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
310,98788,first,3,filter_chain_t.first,,misc\filter_chain.c,*first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
311,98789,last,3,filter_chain_t.last,,misc\filter_chain.c,*last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
312,98790,fmt_in,3,filter_chain_t.fmt_in,,misc\filter_chain.c,fmt_in,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
313,98791,fmt_out,3,filter_chain_t.fmt_out,,misc\filter_chain.c,fmt_out,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
314,98792,b_allow_fmt_out_change,3,filter_chain_t.b_allow_fmt_out_change,,misc\filter_chain.c,b_allow_fmt_out_change,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
315,98793,filter_cap,3,filter_chain_t.filter_cap,,misc\filter_chain.c,*filter_cap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
316,98794,conv_cap,3,filter_chain_t.conv_cap,,misc\filter_chain.c,*conv_cap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
317,104857,fourcc,3,staticentry_t.fourcc,,misc\fourcc_gen.c,fourcc[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
318,104867,fourcc,3,entry.fourcc,,misc\fourcc_gen.c,fourcc[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
319,104868,alias,3,entry.alias,,misc\fourcc_gen.c,alias[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
320,108245,psz_name,3,http_cookie_t.psz_name,,misc\httpcookies.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
321,108246,psz_value,3,http_cookie_t.psz_value,,misc\httpcookies.c,*psz_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
322,108247,psz_domain,3,http_cookie_t.psz_domain,,misc\httpcookies.c,*psz_domain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
323,108248,psz_path,3,http_cookie_t.psz_path,,misc\httpcookies.c,*psz_path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
324,108249,b_host_only,3,http_cookie_t.b_host_only,,misc\httpcookies.c,b_host_only,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
325,108250,b_secure,3,http_cookie_t.b_secure,,misc\httpcookies.c,b_secure,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
326,108943,cookies,3,vlc_http_cookie_jar_t.cookies,,misc\httpcookies.c,cookies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
327,108944,lock,3,vlc_http_cookie_jar_t.lock,,misc\httpcookies.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
328,118028,lock,3,vlc_logger_t.lock,,misc\messages.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
329,118029,log,3,vlc_logger_t.log,,misc\messages.c,log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
330,118030,sys,3,vlc_logger_t.sys,,misc\messages.c,*sys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
331,118031,module,3,vlc_logger_t.module,,misc\messages.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
332,118306,next,3,vlc_log_early_t.next,,misc\messages.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
333,118307,type,3,vlc_log_early_t.type,,misc\messages.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
334,118308,meta,3,vlc_log_early_t.meta,,misc\messages.c,meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
335,118309,msg,3,vlc_log_early_t.msg,,misc\messages.c,*msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
336,118312,lock,3,vlc_logger_early_t.lock,,misc\messages.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
337,118313,head,3,vlc_logger_early_t.head,,misc\messages.c,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
338,118314,tailp,3,vlc_logger_early_t.tailp,,misc\messages.c,**tailp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
339,121108,prev,3,vlc_res.prev,,misc\objres.c,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
340,121114,payload,3,vlc_res.payload,,misc\objres.c,payload[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
341,123148,picture,3,picture_priv_t.picture,,misc\picture.h,picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
342,123157,gc,3,picture_priv_t.gc,,misc\picture.h,gc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
343,123173,lock,3,picture_fifo_t.lock,,misc\picture_fifo.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
344,123174,first,3,picture_fifo_t.first,,misc\picture_fifo.c,*first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
345,123175,last_ptr,3,picture_fifo_t.last_ptr,,misc\picture_fifo.c,**last_ptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
346,123527,lock,3,picture_pool_t.lock,,misc\picture_pool.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
347,123528,wait,3,picture_pool_t.wait,,misc\picture_pool.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
348,123529,canceled,3,picture_pool_t.canceled,,misc\picture_pool.c,canceled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
349,123530,available,3,picture_pool_t.available,,misc\picture_pool.c,available,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
350,123531,refs,3,picture_pool_t.refs,,misc\picture_pool.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
351,123532,picture_count,3,picture_pool_t.picture_count,,misc\picture_pool.c,picture_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
352,123533,picture,3,picture_pool_t.picture,,misc\picture_pool.c,*picture[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
353,124805,psz_name,3,vlc_renderer_item_t.psz_name,,misc\renderer_discovery.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
354,124806,psz_type,3,vlc_renderer_item_t.psz_type,,misc\renderer_discovery.c,*psz_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
355,124807,psz_sout,3,vlc_renderer_item_t.psz_sout,,misc\renderer_discovery.c,*psz_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
356,124808,psz_icon_uri,3,vlc_renderer_item_t.psz_icon_uri,,misc\renderer_discovery.c,*psz_icon_uri,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
357,124809,psz_demux_filter,3,vlc_renderer_item_t.psz_demux_filter,,misc\renderer_discovery.c,*psz_demux_filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
358,124810,i_flags,3,vlc_renderer_item_t.i_flags,,misc\renderer_discovery.c,i_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
359,124811,refs,3,vlc_renderer_item_t.refs,,misc\renderer_discovery.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
360,125158,psz_name,3,vlc_rd_probe.psz_name,,misc\renderer_discovery.c,*psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
361,125159,psz_longname,3,vlc_rd_probe.psz_longname,,misc\renderer_discovery.c,*psz_longname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
362,125436,src,3,subpicture_private_t.src,,misc\subpicture.c,src,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
363,125437,dst,3,subpicture_private_t.dst,,misc\subpicture.c,dst,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
364,126314,fmt,3,subpicture_region_private_t.fmt,,misc\subpicture.h,fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
365,126315,p_picture,3,subpicture_region_private_t.p_picture,,misc\subpicture.h,*p_picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
366,129324,version,3,public_key_packet_t.version,,misc\update.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
367,129325,timestamp,3,public_key_packet_t.timestamp,,misc\update.h,timestamp[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
368,129326,algo,3,public_key_packet_t.algo,,misc\update.h,algo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
369,129382,sig,3,public_key_packet_t.sig,,misc\update.h,sig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
370,129390,version,3,signature_packet_t.version,,misc\update.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
371,129391,type,3,signature_packet_t.type,,misc\update.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
372,129392,public_key_algo,3,signature_packet_t.public_key_algo,,misc\update.h,public_key_algo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
373,129393,digest_algo,3,signature_packet_t.digest_algo,,misc\update.h,digest_algo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
374,129394,hash_verification,3,signature_packet_t.hash_verification,,misc\update.h,hash_verification[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
375,129395,issuer_longid,3,signature_packet_t.issuer_longid,,misc\update.h,issuer_longid[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
376,129421,specific,3,signature_packet_t.specific,,misc\update.h,specific,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
377,129473,sig,3,public_key_t.sig,,misc\update.h,sig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
378,129485,thread,3,update_download_thread_t.thread,,misc\update.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
379,129486,aborted,3,update_download_thread_t.aborted,,misc\update.h,aborted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
380,129487,p_update,3,update_download_thread_t.p_update,,misc\update.h,*p_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
381,129488,psz_destdir,3,update_download_thread_t.psz_destdir,,misc\update.h,*psz_destdir,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
382,129491,thread,3,update_check_thread_t.thread,,misc\update.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
383,129492,p_update,3,update_check_thread_t.p_update,,misc\update.h,*p_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
384,129499,p_data,3,update_check_thread_t.p_data,,misc\update.h,*p_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
385,129502,p_libvlc,3,update_t.p_libvlc,,misc\update.h,*p_libvlc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
386,129503,lock,3,update_t.lock,,misc\update.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
387,129505,release,3,update_t.release,,misc\update.h,release,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
388,129506,p_pkey,3,update_t.p_pkey,,misc\update.h,*p_pkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
389,129507,p_download,3,update_t.p_download,,misc\update.h,*p_download,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
390,129508,p_check,3,update_t.p_check,,misc\update.h,*p_check,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
391,133440,pf_value_callback,3,callback_entry_t.anonymous_composite_type_0.pf_value_callback,,misc\variables.c,pf_value_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
392,133441,pf_list_callback,3,callback_entry_t.anonymous_composite_type_0.pf_list_callback,,misc\variables.c,pf_list_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
393,133442,p_callback,3,callback_entry_t.anonymous_composite_type_0.p_callback,,misc\variables.c,*               p_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
394,133443,p_data,3,callback_entry_t.p_data,,misc\variables.c,*         p_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
395,133464,i_entries,3,callback_table_t.i_entries,,misc\variables.c,i_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
396,133465,p_entries,3,callback_table_t.p_entries,,misc\variables.c,* p_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
397,133468,psz_name,3,variable_t.psz_name,,misc\variables.c,*       psz_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
398,133469,val,3,variable_t.val,,misc\variables.c,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
399,133470,psz_text,3,variable_t.psz_text,,misc\variables.c,*       psz_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
400,133471,ops,3,variable_t.ops,,misc\variables.c,*ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
401,133472,i_type,3,variable_t.i_type,,misc\variables.c,i_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
402,133473,i_usage,3,variable_t.i_usage,,misc\variables.c,i_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
403,133474,min,3,variable_t.min,,misc\variables.c,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
404,133475,max,3,variable_t.max,,misc\variables.c,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
405,133476,step,3,variable_t.step,,misc\variables.c,step,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
406,133477,choices,3,variable_t.choices,,misc\variables.c,choices,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
407,133478,choices_text,3,variable_t.choices_text,,misc\variables.c,choices_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
408,133479,b_incallback,3,variable_t.b_incallback,,misc\variables.c,b_incallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
409,133480,value_callbacks,3,variable_t.value_callbacks,,misc\variables.c,value_callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
410,133481,list_callbacks,3,variable_t.list_callbacks,,misc\variables.c,list_callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
411,139952,name,3,vlc_plugin_symbol.name,,modules\entry.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
412,139953,addr,3,vlc_plugin_symbol.addr,,modules\entry.c,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
413,141179,next,3,vlc_plugin_t.next,,modules\modules.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
414,141180,module,3,vlc_plugin_t.module,,modules\modules.h,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
415,141181,modules_count,3,vlc_plugin_t.modules_count,,modules\modules.h,modules_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
416,141182,textdomain,3,vlc_plugin_t.textdomain,,modules\modules.h,*textdomain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
417,141188,conf,3,vlc_plugin_t.conf,,modules\modules.h,conf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
418,141212,plugin,3,module_t.plugin,,modules\modules.h,*plugin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
419,141213,next,3,module_t.next,,modules\modules.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
420,141214,i_shortcuts,3,module_t.i_shortcuts,,modules\modules.h,i_shortcuts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
421,141215,pp_shortcuts,3,module_t.pp_shortcuts,,modules\modules.h,**pp_shortcuts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
422,141216,psz_shortname,3,module_t.psz_shortname,,modules\modules.h,*psz_shortname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
423,141217,psz_longname,3,module_t.psz_longname,,modules\modules.h,*psz_longname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
424,141218,psz_help,3,module_t.psz_help,,modules\modules.h,*psz_help,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
425,141219,psz_capability,3,module_t.psz_capability,,modules\modules.h,*psz_capability,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
426,141220,i_score,3,module_t.i_score,,modules\modules.h,i_score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
427,141221,activate_name,3,module_t.activate_name,,modules\modules.h,*activate_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
428,141222,deactivate_name,3,module_t.deactivate_name,,modules\modules.h,*deactivate_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
429,141223,pf_activate,3,module_t.pf_activate,,modules\modules.h,*pf_activate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
430,141224,pf_deactivate,3,module_t.pf_deactivate,,modules\modules.h,*pf_deactivate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
431,142848,i_ref,3,httpd_host_t.i_ref,,network\httpd.c,i_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
432,142849,fds,3,httpd_host_t.fds,,network\httpd.c,*fds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
433,142850,nfd,3,httpd_host_t.nfd,,network\httpd.c,nfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
434,142852,thread,3,httpd_host_t.thread,,network\httpd.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
435,142853,lock,3,httpd_host_t.lock,,network\httpd.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
436,142854,wait,3,httpd_host_t.wait,,network\httpd.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
437,142855,i_url,3,httpd_host_t.i_url,,network\httpd.c,i_url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
438,142856,url,3,httpd_host_t.url,,network\httpd.c,**url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
439,142857,b_no_timeout,3,httpd_host_t.b_no_timeout,,network\httpd.c,b_no_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
440,142858,i_client,3,httpd_host_t.i_client,,network\httpd.c,i_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
441,142859,client,3,httpd_host_t.client,,network\httpd.c,**client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
442,142860,timeout_sec,3,httpd_host_t.timeout_sec,,network\httpd.c,timeout_sec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
443,142861,p_tls,3,httpd_host_t.p_tls,,network\httpd.c,*p_tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
444,142863,host,3,httpd_url_t.host,,network\httpd.c,*host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
445,142864,lock,3,httpd_url_t.lock,,network\httpd.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
446,142865,psz_url,3,httpd_url_t.psz_url,,network\httpd.c,*psz_url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
447,142866,psz_user,3,httpd_url_t.psz_user,,network\httpd.c,*psz_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
448,142867,psz_password,3,httpd_url_t.psz_password,,network\httpd.c,*psz_password,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
449,142888,url,3,httpd_client_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
450,142889,sock,3,httpd_client_t.sock,,network\httpd.c,*sock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
451,142890,i_ref,3,httpd_client_t.i_ref,,network\httpd.c,i_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
452,142891,b_stream_mode,3,httpd_client_t.b_stream_mode,,network\httpd.c,b_stream_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
453,142892,i_state,3,httpd_client_t.i_state,,network\httpd.c,i_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
454,142893,i_timeout_date,3,httpd_client_t.i_timeout_date,,network\httpd.c,i_timeout_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
455,142894,i_buffer_size,3,httpd_client_t.i_buffer_size,,network\httpd.c,i_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
456,142895,i_buffer,3,httpd_client_t.i_buffer,,network\httpd.c,i_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
457,142896,p_buffer,3,httpd_client_t.p_buffer,,network\httpd.c,*p_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
458,142897,i_keyframe_wait_to_pass,3,httpd_client_t.i_keyframe_wait_to_pass,,network\httpd.c,i_keyframe_wait_to_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
459,142898,query,3,httpd_client_t.query,,network\httpd.c,query,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
460,142899,answer,3,httpd_client_t.answer,,network\httpd.c,answer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,
461,143077,url,3,httpd_file_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
462,143078,pf_fill,3,httpd_file_t.pf_fill,,network\httpd.c,pf_fill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
463,143079,p_sys,3,httpd_file_t.p_sys,,network\httpd.c,*p_sys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
464,143080,mime,3,httpd_file_t.mime,,network\httpd.c,mime[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
465,143375,url,3,httpd_handler_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
466,143376,pf_fill,3,httpd_handler_t.pf_fill,,network\httpd.c,pf_fill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
467,143377,p_sys,3,httpd_handler_t.p_sys,,network\httpd.c,*p_sys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
468,143782,url,3,httpd_redirect_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
469,143783,dst,3,httpd_redirect_t.dst,,network\httpd.c,dst[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
470,143991,lock,3,httpd_stream_t.lock,,network\httpd.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
471,143992,url,3,httpd_stream_t.url,,network\httpd.c,*url,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
472,143993,psz_mime,3,httpd_stream_t.psz_mime,,network\httpd.c,*psz_mime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
473,143994,p_header,3,httpd_stream_t.p_header,,network\httpd.c,*p_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
474,143995,i_header,3,httpd_stream_t.i_header,,network\httpd.c,i_header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
475,143996,b_has_keyframes,3,httpd_stream_t.b_has_keyframes,,network\httpd.c,b_has_keyframes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
476,143997,i_last_keyframe_seen_pos,3,httpd_stream_t.i_last_keyframe_seen_pos,,network\httpd.c,i_last_keyframe_seen_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
477,143998,i_buffer_size,3,httpd_stream_t.i_buffer_size,,network\httpd.c,i_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
478,143999,p_buffer,3,httpd_stream_t.p_buffer,,network\httpd.c,*p_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
479,144000,i_buffer_pos,3,httpd_stream_t.i_buffer_pos,,network\httpd.c,i_buffer_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
480,144001,i_buffer_last_pos,3,httpd_stream_t.i_buffer_last_pos,,network\httpd.c,i_buffer_last_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
481,144002,i_http_headers,3,httpd_stream_t.i_http_headers,,network\httpd.c,i_http_headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
482,144003,p_http_headers,3,httpd_stream_t.p_http_headers,,network\httpd.c,* p_http_headers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
483,145006,mutex,3,httpd.mutex,,network\httpd.c,mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
484,145007,host,3,httpd.host,,network\httpd.c,**host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
485,145008,i_host,3,httpd.i_host,,network\httpd.c,i_host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
486,156621,cancel_event,3,vlc_thread.cancel_event,,os2\thread.c,cancel_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
487,156622,done_event,3,vlc_thread.done_event,,os2\thread.c,done_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
488,156623,cancel_sock,3,vlc_thread.cancel_sock,,os2\thread.c,cancel_sock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
489,156624,detached,3,vlc_thread.detached,,os2\thread.c,detached,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
490,157006,condvar,3,vlc_static_cond_t.condvar,,os2\thread.c,condvar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
491,157007,next,3,vlc_static_cond_t.next,,os2\thread.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
492,158661,tid,3,vlc_timer.tid,,os2\thread.c,tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
493,158662,hev,3,vlc_timer.hev,,os2\thread.c,hev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
494,158663,htimer,3,vlc_timer.htimer,,os2\thread.c,htimer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
495,158664,interval,3,vlc_timer.interval,,os2\thread.c,interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
496,158665,quit,3,vlc_timer.quit,,os2\thread.c,quit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
497,161877,local,3,playlist_fetcher_t.local,,playlist\fetcher.c,* local,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
498,161879,network,3,playlist_fetcher_t.network,,playlist\fetcher.c,* network,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
499,161881,downloader,3,playlist_fetcher_t.downloader,,playlist\fetcher.c,* downloader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
500,161882,album_cache,3,playlist_fetcher_t.album_cache,,playlist\fetcher.c,album_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
501,161883,owner,3,playlist_fetcher_t.owner,,playlist\fetcher.c,* owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
502,161884,lock,3,playlist_fetcher_t.lock,,playlist\fetcher.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
503,161886,item,3,fetcher_request.item,,playlist\fetcher.c,* item,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
504,161887,refs,3,fetcher_request.refs,,playlist\fetcher.c,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
505,161888,preparse_status,3,fetcher_request.preparse_status,,playlist\fetcher.c,preparse_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
506,161889,options,3,fetcher_request.options,,playlist\fetcher.c,options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
507,161898,worker,3,fetcher_thread.worker,,playlist\fetcher.c,* worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
508,161900,req,3,fetcher_thread.req,,playlist\fetcher.c,* req,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
509,161901,fetcher,3,fetcher_thread.fetcher,,playlist\fetcher.c,* fetcher,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
510,161902,interrupt,3,fetcher_thread.interrupt,,playlist\fetcher.c,interrupt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
511,161903,thread,3,fetcher_thread.thread,,playlist\fetcher.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
512,161904,active,3,fetcher_thread.active,,playlist\fetcher.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
513,165500,public_data,3,playlist_private_t.public_data,,playlist\playlist_internal.h,public_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
514,165503,input_tree,3,playlist_private_t.input_tree,,playlist\playlist_internal.h,*input_tree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
515,165504,id_tree,3,playlist_private_t.id_tree,,playlist\playlist_internal.h,*id_tree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
516,165505,pp_sds,3,playlist_private_t.pp_sds,,playlist\playlist_internal.h,**pp_sds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
517,165506,i_sds,3,playlist_private_t.i_sds,,playlist\playlist_internal.h,i_sds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
518,165507,p_input,3,playlist_private_t.p_input,,playlist\playlist_internal.h,*      p_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
519,165508,p_input_resource,3,playlist_private_t.p_input_resource,,playlist\playlist_internal.h,*   p_input_resource,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
520,165509,p_renderer,3,playlist_private_t.p_renderer,,playlist\playlist_internal.h,*p_renderer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
521,165521,thread,3,playlist_private_t.thread,,playlist\playlist_internal.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
522,165522,lock,3,playlist_private_t.lock,,playlist\playlist_internal.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
523,165523,signal,3,playlist_private_t.signal,,playlist\playlist_internal.h,signal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
524,165524,killed,3,playlist_private_t.killed,,playlist\playlist_internal.h,killed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
525,165526,i_last_playlist_id,3,playlist_private_t.i_last_playlist_id,,playlist\playlist_internal.h,i_last_playlist_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
526,165527,b_reset_currently_playing,3,playlist_private_t.b_reset_currently_playing,,playlist\playlist_internal.h,b_reset_currently_playing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
527,165686,owner,3,playlist_preparser_t.owner,,playlist\preparser.c,* owner,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
528,165687,fetcher,3,playlist_preparser_t.fetcher,,playlist\preparser.c,* fetcher,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
529,165689,worker,3,playlist_preparser_t.worker,,playlist\preparser.c,* worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
530,165690,deactivated,3,playlist_preparser_t.deactivated,,playlist\preparser.c,deactivated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
531,166538,node,3,vlc_sd_internal_t.node,,playlist\services_discovery.c,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
532,166539,sd,3,vlc_sd_internal_t.sd,,playlist\services_discovery.c,*sd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
533,166540,name,3,vlc_sd_internal_t.name,,playlist\services_discovery.c,name[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
534,171617,name,3,vlc_gai_req.name,,posix\getaddrinfo.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
535,171618,service,3,vlc_gai_req.service,,posix\getaddrinfo.c,*service,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
536,171620,hints,3,vlc_gai_req.hints,,posix\getaddrinfo.c,*hints,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
537,171622,result,3,vlc_gai_req.result,,posix\getaddrinfo.c,*result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
538,171623,error,3,vlc_gai_req.error,,posix\getaddrinfo.c,error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
539,171624,done,3,vlc_gai_req.done,,posix\getaddrinfo.c,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
540,173497,reschedule,3,vlc_timer.reschedule,,posix\timer.c,reschedule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
541,173498,lock,3,vlc_timer.lock,,posix\timer.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
542,173505,value,3,vlc_timer.value,,posix\timer.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
543,173507,overruns,3,vlc_timer.overruns,,posix\timer.c,overruns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
544,173894,thread,3,sap_address_t.thread,,stream_output\sap.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
545,173895,lock,3,sap_address_t.lock,,stream_output\sap.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
546,173896,wait,3,sap_address_t.wait,,stream_output\sap.c,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
547,173897,group,3,sap_address_t.group,,stream_output\sap.c,group[NI_MAXNUMERICHOST],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
548,173899,orig,3,sap_address_t.orig,,stream_output\sap.c,orig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
549,173900,origlen,3,sap_address_t.origlen,,stream_output\sap.c,origlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
550,173901,fd,3,sap_address_t.fd,,stream_output\sap.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
551,173902,interval,3,sap_address_t.interval,,stream_output\sap.c,interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
552,173903,session_count,3,sap_address_t.session_count,,stream_output\sap.c,session_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
553,173904,first,3,sap_address_t.first,,stream_output\sap.c,*first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
554,177291,p_sout,3,sout_packetizer_input_t.p_sout,,stream_output\stream_output.h,*p_sout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
555,177292,id,3,sout_packetizer_input_t.id,,stream_output\stream_output.h,*id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
556,179267,psz_entity,3,xml_entity_s.psz_entity,,text\strings.c,psz_entity[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
557,184896,shift,3,vout_chrono_t.shift,,video_output\chrono.h,shift,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
558,184897,avg,3,vout_chrono_t.avg,,video_output\chrono.h,avg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
559,184898,avg_initial,3,vout_chrono_t.avg_initial,,video_output\chrono.h,avg_initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
560,184899,shift_var,3,vout_chrono_t.shift_var,,video_output\chrono.h,shift_var,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
561,184900,var,3,vout_chrono_t.var,,video_output\chrono.h,var,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
562,184901,start,3,vout_chrono_t.start,,video_output\chrono.h,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
563,185703,type,3,vout_control_cmd_t.type,,video_output\control.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
564,185738,u,3,vout_control_cmd_t.u,,video_output\control.h,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,61,0,1,1,0,0,,0,0,0,0,0,
565,185752,lock,3,vout_control_t.lock,,video_output\control.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
566,185753,wait_request,3,vout_control_t.wait_request,,video_output\control.h,wait_request,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
567,185754,wait_acknowledge,3,vout_control_t.wait_acknowledge,,video_output\control.h,wait_acknowledge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
568,185755,is_dead,3,vout_control_t.is_dead,,video_output\control.h,is_dead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
569,185756,can_sleep,3,vout_control_t.can_sleep,,video_output\control.h,can_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
570,185757,is_processing,3,vout_control_t.is_processing,,video_output\control.h,is_processing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
571,187046,vout,3,vout_display_owner_sys_t.vout,,video_output\display.c,*vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
572,187047,is_splitter,3,vout_display_owner_sys_t.is_splitter,,video_output\display.c,is_splitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
573,187048,cfg,3,vout_display_owner_sys_t.cfg,,video_output\display.c,cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
574,187049,sar_initial,3,vout_display_owner_sys_t.sar_initial,,video_output\display.c,sar_initial,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
575,187050,is_display_filled,3,vout_display_owner_sys_t.is_display_filled,,video_output\display.c,is_display_filled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
576,187051,ch_zoom,3,vout_display_owner_sys_t.ch_zoom,,video_output\display.c,ch_zoom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
577,187052,zoom,3,vout_display_owner_sys_t.zoom,,video_output\display.c,zoom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
578,187061,ch_sar,3,vout_display_owner_sys_t.ch_sar,,video_output\display.c,ch_sar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
579,187062,sar,3,vout_display_owner_sys_t.sar,,video_output\display.c,sar,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
580,187063,ch_crop,3,vout_display_owner_sys_t.ch_crop,,video_output\display.c,ch_crop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
581,187072,ch_viewpoint,3,vout_display_owner_sys_t.ch_viewpoint,,video_output\display.c,ch_viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
582,187073,viewpoint,3,vout_display_owner_sys_t.viewpoint,,video_output\display.c,viewpoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
583,187075,source,3,vout_display_owner_sys_t.source,,video_output\display.c,source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
584,187076,filters,3,vout_display_owner_sys_t.filters,,video_output\display.c,*filters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
585,187077,lock,3,vout_display_owner_sys_t.lock,,video_output\display.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
586,187087,reset_pictures,3,vout_display_owner_sys_t.reset_pictures,,video_output\display.c,reset_pictures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
587,187088,fit_window,3,vout_display_owner_sys_t.fit_window,,video_output\display.c,fit_window,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
588,187089,ch_display_size,3,vout_display_owner_sys_t.ch_display_size,,video_output\display.c,ch_display_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
589,187090,display_width,3,vout_display_owner_sys_t.display_width,,video_output\display.c,display_width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
590,187091,display_height,3,vout_display_owner_sys_t.display_height,,video_output\display.c,display_height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
591,190140,pool,3,vout_display_sys_t.pool,,video_output\display.c,*pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
592,190141,splitter,3,vout_display_sys_t.splitter,,video_output\display.c,*splitter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
593,190142,count,3,vout_display_sys_t.count,,video_output\display.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
594,190143,picture,3,vout_display_sys_t.picture,,video_output\display.c,**picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
595,190144,display,3,vout_display_sys_t.display,,video_output\display.c,**display,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
596,190146,wrapper,3,video_splitter_owner_t.wrapper,,video_output\display.c,*wrapper,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
597,191437,ih,3,inhibit_t.ih,,video_output\inhibit.c,ih,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
598,191438,module,3,inhibit_t.module,,video_output\inhibit.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
599,192155,gl,3,vlc_gl_priv_t.gl,,video_output\opengl.c,gl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
600,192156,ref_count,3,vlc_gl_priv_t.ref_count,,video_output\opengl.c,ref_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
601,193128,lock,3,vout_snapshot_t.lock,,video_output\snapshot.h,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
602,193129,wait,3,vout_snapshot_t.wait,,video_output\snapshot.h,wait,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
603,193130,is_available,3,vout_snapshot_t.is_available,,video_output\snapshot.h,is_available,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
604,193131,request_count,3,vout_snapshot_t.request_count,,video_output\snapshot.h,request_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
605,193132,picture,3,vout_snapshot_t.picture,,video_output\snapshot.h,*picture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
606,193173,is_sequential,3,vout_snapshot_save_cfg_t.is_sequential,,video_output\snapshot.h,is_sequential,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
607,193174,sequence,3,vout_snapshot_save_cfg_t.sequence,,video_output\snapshot.h,sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
608,193175,path,3,vout_snapshot_save_cfg_t.path,,video_output\snapshot.h,*path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
609,193176,format,3,vout_snapshot_save_cfg_t.format,,video_output\snapshot.h,*format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
610,193177,prefix_fmt,3,vout_snapshot_save_cfg_t.prefix_fmt,,video_output\snapshot.h,*prefix_fmt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
611,193196,displayed,3,vout_statistic_t.displayed,,video_output\statistic.h,displayed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
612,193197,lost,3,vout_statistic_t.lost,,video_output\statistic.h,lost,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
613,193299,epg,3,subpicture_updater_sys_t.epg,,video_output\video_epg.c,*epg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
614,193300,time,3,subpicture_updater_sys_t.time,,video_output\video_epg.c,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
615,193301,art,3,subpicture_updater_sys_t.art,,video_output\video_epg.c,*art,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
616,193302,obj,3,subpicture_updater_sys_t.obj,,video_output\video_epg.c,*obj,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
617,197866,name,3,vout_filter_t.name,,video_output\video_output.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
618,197867,cfg,3,vout_filter_t.cfg,,video_output\video_output.c,*cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
619,202020,text,3,subpicture_updater_sys_t.text,,video_output\video_text.c,*text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
620,203777,type,3,subpicture_updater_sys_t.type,,video_output\video_widgets.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
621,203778,position,3,subpicture_updater_sys_t.position,,video_output\video_widgets.c,position,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
622,204240,display_pool,3,vout_thread_sys_t.display_pool,,video_output\vout_internal.h,*display_pool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
623,206449,subpicture,3,spu_heap_entry_t.subpicture,,video_output\vout_subpictures.c,*subpicture,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
624,206450,reject,3,spu_heap_entry_t.reject,,video_output\vout_subpictures.c,reject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
625,206453,entry,3,spu_heap_t.entry,,video_output\vout_subpictures.c,entry[VOUT_MAX_SUBPICTURES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
626,206468,lock,3,spu_private_t.lock,,video_output\vout_subpictures.c,lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
627,206470,heap,3,spu_private_t.heap,,video_output\vout_subpictures.c,heap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
628,206471,channel,3,spu_private_t.channel,,video_output\vout_subpictures.c,channel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
629,206472,text,3,spu_private_t.text,,video_output\vout_subpictures.c,*text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
630,206473,scale_yuvp,3,spu_private_t.scale_yuvp,,video_output\vout_subpictures.c,*scale_yuvp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
631,206474,scale,3,spu_private_t.scale,,video_output\vout_subpictures.c,*scale,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
632,206475,force_crop,3,spu_private_t.force_crop,,video_output\vout_subpictures.c,force_crop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
633,206482,margin,3,spu_private_t.margin,,video_output\vout_subpictures.c,margin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
634,206483,force_palette,3,spu_private_t.force_palette,,video_output\vout_subpictures.c,force_palette,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
635,206484,palette,3,spu_private_t.palette,,video_output\vout_subpictures.c,palette[4][4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
636,206485,source_chain_current,3,spu_private_t.source_chain_current,,video_output\vout_subpictures.c,*source_chain_current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
637,206486,source_chain_update,3,spu_private_t.source_chain_update,,video_output\vout_subpictures.c,*source_chain_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
638,206487,source_chain_lock,3,spu_private_t.source_chain_lock,,video_output\vout_subpictures.c,source_chain_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
639,206488,source_chain,3,spu_private_t.source_chain,,video_output\vout_subpictures.c,*source_chain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
640,206489,filter_chain_current,3,spu_private_t.filter_chain_current,,video_output\vout_subpictures.c,*filter_chain_current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
641,206490,filter_chain_update,3,spu_private_t.filter_chain_update,,video_output\vout_subpictures.c,*filter_chain_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
642,206491,filter_chain_lock,3,spu_private_t.filter_chain_lock,,video_output\vout_subpictures.c,filter_chain_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
643,206492,filter_chain,3,spu_private_t.filter_chain,,video_output\vout_subpictures.c,*filter_chain,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
644,206493,last_sort_date,3,spu_private_t.last_sort_date,,video_output\vout_subpictures.c,last_sort_date,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
645,206494,vout,3,spu_private_t.vout,,video_output\vout_subpictures.c,*vout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
646,207105,w,3,spu_scale_t.w,,video_output\vout_subpictures.c,w,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
647,207106,h,3,spu_scale_t.h,,video_output\vout_subpictures.c,h,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
648,207258,x,3,spu_area_t.x,,video_output\vout_subpictures.c,x,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
649,207259,y,3,spu_area_t.y,,video_output\vout_subpictures.c,y,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
650,207260,width,3,spu_area_t.width,,video_output\vout_subpictures.c,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
651,207261,height,3,spu_area_t.height,,video_output\vout_subpictures.c,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
652,207262,scale,3,spu_area_t.scale,,video_output\vout_subpictures.c,scale,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
653,212443,wnd,3,window_t.wnd,,video_output\window.c,wnd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
654,212444,module,3,window_t.module,,video_output\window.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
655,212445,inhibit,3,window_t.inhibit,,video_output\window.c,*inhibit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
656,214512,thread,3,vlc_mta_holder.thread,,win32\mta_holder.h,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
657,214513,i_refcount,3,vlc_mta_holder.i_refcount,,win32\mta_holder.h,i_refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
658,214514,ready_sem,3,vlc_mta_holder.ready_sem,,win32\mta_holder.h,ready_sem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
659,214515,release_sem,3,vlc_mta_holder.release_sem,,win32\mta_holder.h,release_sem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
660,215394,killable,3,vlc_thread.killable,,win32\thread.c,killable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
661,215402,data,3,vlc_thread.data,,win32\thread.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
662,217286,data,3,vlc_timer.data,,win32\timer.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
663,13,vlc_strerror,1,vlc_strerror,const char* vlc_strerror (int),win32\error.c,"const char *vlc_strerror(int errnum)
{
    return /*vlc_gettext*/(vlc_strerror_c(errnum));
}",150.0,153.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,const char*
664,21,vlc_strerror_c,1,vlc_strerror_c,const char* vlc_strerror_c (int),win32\error.c,"const char *vlc_strerror_c(int errnum)
{
    /* C run-time errors */
    if ((unsigned)errnum < (unsigned)_sys_nerr)
        return _sys_errlist[errnum];

    /* Windows socket errors */
    for (const wsaerrmsg_t *e = wsaerrmsg; e->msg != NULL; e++)
        if (e->code == errnum)
            return e->msg;

    return ""Unknown error"";
}",136.0,148.0,1.0,1.0,13.0,0,0,3,2,33,0,1,1,0,0,,0,0,2,1,1,const char*
665,87,get_java_string,1,get_java_string,"char* get_java_string (JNIEnv*,jclass,char*)",android\specific.c,"static char *
get_java_string(JNIEnv *env, jclass clazz, const char *psz_name)
{
    jfieldID id = (*env)->GetStaticFieldID(env, clazz, psz_name,
                                           ""Ljava/lang/String;"");
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        return NULL;
    }

    jstring jstr = (*env)->GetStaticObjectField(env, clazz, id);

    const char *psz_str = (*env)->GetStringUTFChars(env, jstr, 0);
    if (psz_str == NULL)
        return NULL;

    char *psz_strdup = strdup(psz_str);

    (*env)->ReleaseStringUTFChars(env, jstr, psz_str);
    (*env)->DeleteLocalRef(env, jstr);

    return psz_strdup;
}",53.0,76.0,1.0,1.0,24.0,19,4,32,8,1,0,3,3,0,0,,0,0,6,3,3,char*
666,173,JNI_OnUnload,1,JNI_OnUnload,"void JNI_OnUnload (JavaVM*,void*)",android\specific.c,"void
JNI_OnUnload(JavaVM* vm, void* reserved)
{
    (void) reserved;

    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
        free(ppsz_generic_names[i]);

    JNIEnv* env = NULL;
    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return;

    if (fields.Environment.clazz)
        (*env)->DeleteGlobalRef(env, fields.Environment.clazz);

    if (fields.System.clazz)
        (*env)->DeleteGlobalRef(env, fields.System.clazz);
}",78.0,95.0,1.0,27.0,18.0,23,10,20,10,1,4,5,5,2,0,,0,4,4,2,2,void
667,259,JNI_OnLoad,1,JNI_OnLoad,"jint JNI_OnLoad (JavaVM*,void*)",android\specific.c,"jint
JNI_OnLoad(JavaVM *vm, void *reserved)
{
    s_jvm = vm;
    JNIEnv* env = NULL;

    if ((*vm)->GetEnv(vm, (void**) &env, JNI_VERSION_1_2) != JNI_OK)
        return -1;

    jclass clazz = (*env)->FindClass(env, ""android/os/Environment"");
    if ((*env)->ExceptionCheck(env))
        return -1;

    static const char *ppsz_env_names[GENERIC_DIR_COUNT] = {
        NULL,                   /* VLC_DESKTOP_DIR */
        ""DIRECTORY_DOWNLOADS"",  /* VLC_DOWNLOAD_DIR */
        NULL,                   /* VLC_TEMPLATES_DIR */
        NULL,                   /* VLC_PUBLICSHARE_DIR */
        ""DIRECTORY_DOCUMENTS"",  /* VLC_DOCUMENTS_DIR */
        ""DIRECTORY_MUSIC"",      /* VLC_MUSIC_DIR */
        ""DIRECTORY_PICTURES"",   /* VLC_PICTURES_DIR */
        ""DIRECTORY_MOVIES"",     /* VLC_VIDEOS_DIR */
    };
    for (size_t i = 0; i < GENERIC_DIR_COUNT; ++i)
    {
        if (ppsz_env_names[i] != NULL)
            ppsz_generic_names[i] = get_java_string(env, clazz,
                            ...",100.0,163.0,1.0,38.0,64.0,71,13,79,14,0,9,12,10,0,2,,0,8,4,2,2,jint
668,514,system_Init,1,system_Init,void system_Init (void),win32\specific.c,"void system_Init(void)
{
    if (system_InitWSA(2, 2) && system_InitWSA(1, 1))
        fputs(""Error: cannot initialize Winsocks\n"", stderr);

#if !VLC_WINSTORE_APP
# if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    if (GetProcAddress(GetModuleHandle(TEXT(""kernel32.dll"")),
                                       ""SetDefaultDllDirectories"") != NULL)
# endif /* FIXME: not reentrant */
        LoadLibraryFlags = LOAD_LIBRARY_SEARCH_SYSTEM32;
#endif
}",61.0,73.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
669,519,system_Configure,1,system_Configure,"void system_Configure (libvlc_int_t*,int,char[]*)",win32\specific.c,"void system_Configure( libvlc_int_t *p_this, int i_argc, const char *const ppsz_argv[] )
{
#if !VLC_WINSTORE_APP
    if( var_InheritBool( p_this, ""one-instance"" )
     || ( var_InheritBool( p_this, ""one-instance-when-started-from-file"" )
       && var_InheritBool( p_this, ""started-from-file"" ) ) )
    {
        HANDLE hmutex;

        msg_Info( p_this, ""one instance mode ENABLED"");

        /* Use a named mutex to check if another instance is already running */
        if( !( hmutex = CreateMutex( 0, TRUE, L""VLC ipc "" TEXT(VERSION) ) ) )
        {
            /* Failed for some reason. Just ignore the option and go on as
             * normal. */
            msg_Err( p_this, ""one instance mode DISABLED ""
                     ""(mutex couldn't be created)"" );
            return;
        }

        if( GetLastError() != ERROR_ALREADY_EXISTS )
        {
            libvlc_InternalAddIntf( p_this, ""win_msg,none"" );
            /* Initialization done.
             * Release the mutex to u...",87.0,182.0,1.0,1.0,96.0,3,2,8,6,1,3,1,1,0,1,,0,2,6,3,3,void
670,544,config_GetHomeDir,1,config_GetHomeDir,"char* config_GetHomeDir (char*,char*)",posix\dirs.c,"static char *config_GetHomeDir (void)
{
    /* 1/ Try $HOME  */
    const char *home = getenv (""HOME"");
    if (home != NULL)
        return strdup (home);
#if defined(HAVE_GETPWUID_R)
    /* 2/ Try /etc/passwd */
    long max = sysconf (_SC_GETPW_R_SIZE_MAX);
    if (max != -1)
    {
        char buf[max];
        struct passwd pwbuf, *pw;

        if (getpwuid_r (getuid (), &pwbuf, buf, sizeof (buf), &pw) == 0
          && pw != NULL)
            return strdup (pw->pw_dir);
    }
#endif
    return NULL;
}",61.0,81.0,1.0,1.0,21.0,12,7,18,7,6,1,8,5,1,1,,0,1,2,1,1,char*
671,608,get_env,1,get_env,JNIEnv get_env (bool*),android\specific.c,"static JNIEnv *get_env(bool *p_detach)
{
    JNIEnv *env;
    if ((*s_jvm)->GetEnv(s_jvm, (void **)&env, JNI_VERSION_1_2) != JNI_OK)
    {
        /* attach the thread to the Java VM */
        JavaVMAttachArgs args;

        args.version = JNI_VERSION_1_2;
        args.name = ""config_GetGenericDir"";
        args.group = NULL;

        if ((*s_jvm)->AttachCurrentThread(s_jvm, &env, &args) != JNI_OK)
            return NULL;
        *p_detach = true;
    }
    else
        *p_detach = false;
    return env;
}",202.0,221.0,1.0,1.0,20.0,18,7,19,8,2,4,3,4,4,0,,0,4,2,1,1,JNIEnv
672,673,release_env,1,release_env,void release_env (bool),android\specific.c,"static void release_env(bool b_detach)
{
    if (b_detach)
        (*s_jvm)->DetachCurrentThread(s_jvm);
}",223.0,227.0,1.0,1.0,5.0,2,2,3,2,2,2,2,2,0,0,,0,2,2,1,1,void
673,687,config_GetGenericDir,1,config_GetGenericDir,char* config_GetGenericDir (char*),android\specific.c,"static char *config_GetGenericDir(const char *psz_name)
{
    JNIEnv *env;
    bool b_detach;
    char *psz_ret = NULL;

    env = get_env(&b_detach);
    if (env == NULL)
        return NULL;

    jstring jname= (*env)->NewStringUTF(env, psz_name);
    if ((*env)->ExceptionCheck(env))
    {
        (*env)->ExceptionClear(env);
        jname = NULL;
    }
    if (jname == NULL)
        goto error;

    jobject jfile = (*env)->CallStaticObjectMethod(env,
                        fields.Environment.clazz,
                        fields.Environment.getExternalStoragePublicDirectory,
                        jname);
    (*env)->DeleteLocalRef(env, jname);
    if (jfile == NULL)
        goto error;

    jstring jpath = (*env)->CallObjectMethod(env, jfile,
                                             fields.File.getAbsolutePath);
    (*env)->DeleteLocalRef(env, jfile);

    const char *psz_path = (*env)->GetStringUTFChars(env, jpath, 0);
    if (psz_path == NULL)
        goto error;
    psz...",229.0,270.0,1.0,1.0,42.0,39,6,55,10,1,5,9,6,0,2,,0,4,2,1,1,char*
674,839,config_GetUserDir,1,config_GetUserDir,char* config_GetUserDir (vlc_userdir_t),win32\dirs.c,"char *config_GetUserDir (vlc_userdir_t type)
{
    switch (type)
    {
        case VLC_HOME_DIR:
            return config_GetShellDir (CSIDL_PERSONAL);
        case VLC_CONFIG_DIR:
        case VLC_DATA_DIR:
            return config_GetAppDir ();
        case VLC_CACHE_DIR:
#if !VLC_WINSTORE_APP
            return config_GetAppDir ();
#else
            return config_GetShellDir (CSIDL_LOCAL_APPDATA);
#endif

        case VLC_DESKTOP_DIR:
        case VLC_DOWNLOAD_DIR:
        case VLC_TEMPLATES_DIR:
        case VLC_PUBLICSHARE_DIR:
        case VLC_DOCUMENTS_DIR:
            return config_GetUserDir(VLC_HOME_DIR);
        case VLC_MUSIC_DIR:
            return config_GetShellDir (CSIDL_MYMUSIC);
        case VLC_PICTURES_DIR:
            return config_GetShellDir (CSIDL_MYPICTURES);
        case VLC_VIDEOS_DIR:
            return config_GetShellDir (CSIDL_MYVIDEO);
    }
    vlc_assert_unreachable ();
}",255.0,285.0,1.0,1.0,31.0,7,7,28,16,7,6,3,4,0,5,,0,1,2,1,1,char*
675,914,vlc_getProxyUrl,1,vlc_getProxyUrl,char* vlc_getProxyUrl (char*),win32\netconf.c,"char *vlc_getProxyUrl(const char *psz_url)
{
    VLC_UNUSED(psz_url);

    char *proxy = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy"" );
    if (proxy == NULL)
        return NULL;

    char *proxy_pwd = config_GetPsz( (vlc_object_t *)(NULL), ""http-proxy-pwd"" );
    if (proxy_pwd == NULL)
        return proxy;

    vlc_url_t url;
    if (vlc_UrlParse(&url, proxy) < 0) {
        vlc_UrlClean(&url);
        free (proxy);
        free (proxy_pwd);
        return NULL;
    }

    if (url.psz_password == NULL )
        url.psz_password = proxy_pwd;

    char *proxy_url = vlc_uri_compose (&url);
    vlc_UrlClean (&url);

    free (proxy_pwd);
    free (proxy);

#if 0
    /* Try to get the proxy server address from Windows internet settings. */
    HKEY h_key;

    /* Open the key */
    if( RegOpenKeyEx( HKEY_CURRENT_USER, ""Software\\Microsoft""
                      ""\\Windows\\CurrentVersion\\Internet Settings"",
                      0, KEY_READ, &h_key ) == ERROR_SUCCESS )
      ...",32.0,110.0,1.0,1.0,79.0,86,12,114,11,0,6,19,16,0,2,,0,5,2,1,1,char*
676,1252,vlc_thread_fatal_print,1,vlc_thread_fatal_print,"void vlc_thread_fatal_print (char*,int,char*,char*,unsigned)",android\thread.c,"static void
vlc_thread_fatal_print (const char *action, int error,
                        const char *function, const char *file, unsigned line)
{
    char buf[1000];
    const char *msg;

    switch (strerror_r (error, buf, sizeof (buf)))
    {
        case 0:
            msg = buf;
            break;
        case ERANGE: /* should never happen */
            msg = ""unknown (too big to display)"";
            break;
        default:
            msg = ""unknown (invalid error number)"";
            break;
    }

    fprintf(stderr, ""LibVLC fatal error %s (%d) in thread %lu ""
            ""at %s:%u in %s\n Error message: %s\n"",
            action, error, vlc_thread_id (), file, line, function, msg);
    fflush (stderr);
}",48.0,72.0,1.0,1.0,25.0,4,2,16,9,5,1,5,2,0,1,,0,0,10,5,5,void
677,1299,vlc_mutex_init,1,vlc_mutex_init,void vlc_mutex_init (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_init( vlc_mutex_t *p_mutex )
{
    /* This creates a recursive mutex. This is OK as fast mutexes have
     * no defined behavior in case of recursive locking. */
    InitializeCriticalSection (&p_mutex->mutex);
    p_mutex->dynamic = true;
}",100.0,106.0,1.0,1.0,7.0,4,1,6,3,39,0,1,1,0,0,,0,0,2,1,1,void
678,1319,vlc_mutex_init_recursive,1,vlc_mutex_init_recursive,void vlc_mutex_init_recursive (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_init_recursive( vlc_mutex_t *p_mutex )
{
    InitializeCriticalSection( &p_mutex->mutex );
    p_mutex->dynamic = true;
}",108.0,112.0,1.0,1.0,5.0,4,1,6,3,3,0,1,1,0,0,,0,0,2,1,1,void
679,1339,vlc_mutex_destroy,1,vlc_mutex_destroy,void vlc_mutex_destroy (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_destroy (vlc_mutex_t *p_mutex)
{
    assert (p_mutex->dynamic);
    DeleteCriticalSection (&p_mutex->mutex);
}",115.0,119.0,1.0,1.0,5.0,2,2,5,3,53,1,1,1,0,1,,0,0,2,1,1,void
680,1368,vlc_mutex_lock,1,vlc_mutex_lock,void vlc_mutex_lock (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_lock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        while (p_mutex->locked)
        {
            p_mutex->contention++;
            SleepConditionVariableCS(&super_variable, &super_mutex, INFINITE);
            p_mutex->contention--;
        }
        p_mutex->locked = true;
        LeaveCriticalSection(&super_mutex);
        return;
    }

    EnterCriticalSection (&p_mutex->mutex);
}",121.0,138.0,1.0,1.0,18.0,2,2,5,3,296,1,1,1,0,1,,0,0,2,1,1,void
681,1396,vlc_mutex_trylock,1,vlc_mutex_trylock,int vlc_mutex_trylock (vlc_mutex_t*),win32\thread.c,"int vlc_mutex_trylock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        int ret = EBUSY;

        EnterCriticalSection(&super_mutex);
        if (!p_mutex->locked)
        {
            p_mutex->locked = true;
            ret = 0;
        }
        LeaveCriticalSection(&super_mutex);
        return ret;
    }

    return TryEnterCriticalSection (&p_mutex->mutex) ? 0 : EBUSY;
}",140.0,157.0,1.0,1.0,18.0,3,3,8,4,2,1,2,2,0,1,,0,0,2,1,1,int
682,1431,vlc_mutex_unlock,1,vlc_mutex_unlock,void vlc_mutex_unlock (vlc_mutex_t*),win32\thread.c,"void vlc_mutex_unlock (vlc_mutex_t *p_mutex)
{
    if (!p_mutex->dynamic)
    {   /* static mutexes */
        EnterCriticalSection(&super_mutex);
        assert (p_mutex->locked);
        p_mutex->locked = false;
        if (p_mutex->contention)
            WakeAllConditionVariable(&super_variable);
        LeaveCriticalSection(&super_mutex);
        return;
    }

    LeaveCriticalSection (&p_mutex->mutex);
}",159.0,173.0,1.0,1.0,15.0,2,2,5,3,370,1,1,1,0,1,,0,0,2,1,1,void
683,1462,entry,1,vlc_thread.entry,void* vlc_thread.entry (void*),android\thread.c,void *(*entry)(void*);,149.0,149.0,10.0,25.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void*
684,1475,vlc_thread_self,1,vlc_thread_self,vlc_thread_t vlc_thread_self (void),win32\thread.c,"vlc_thread_t vlc_thread_self (void)
{
    return TlsGetValue(thread_key);
}",566.0,569.0,1.0,1.0,4.0,0,0,1,1,3,0,1,1,0,0,,0,0,2,1,1,vlc_thread_t
685,1482,vlc_threads_setup,1,vlc_threads_setup,void vlc_threads_setup (libvlc_int_t*),win32\thread.c,"void vlc_threads_setup(libvlc_int_t *vlc)
{
    EnterCriticalSection(&setup_lock);
    if (mdate_selected != mdate_default)
    {
        LeaveCriticalSection(&setup_lock);
        return;
    }

    if (!SelectClockSource((vlc != NULL) ? VLC_OBJECT(vlc) : NULL))
        abort();
    assert(mdate_selected != mdate_default);

#if !VLC_WINSTORE_APP
    /* Raise default priority of the current process */
#ifndef ABOVE_NORMAL_PRIORITY_CLASS
#   define ABOVE_NORMAL_PRIORITY_CLASS 0x00008000
#endif
    if (var_InheritBool(vlc, ""high-priority""))
    {
        if (SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS)
         || SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS))
            msg_Dbg(vlc, ""raised process priority"");
        else
            msg_Dbg(vlc, ""could not raise process priority"");
    }
#endif
    LeaveCriticalSection(&setup_lock);
}",1008.0,1036.0,1.0,50.0,29.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
686,1490,clean_detached_thread,1,clean_detached_thread,void clean_detached_thread (void*),android\thread.c,"static void clean_detached_thread(void *data)
{
    struct vlc_thread *th = data;

    /* release thread handle */
    vlc_mutex_destroy(&th->wait.lock);
    free(th);
}",175.0,182.0,1.0,1.0,8.0,4,4,4,2,2,1,1,1,0,1,,0,0,2,1,1,void
687,1508,detached_thread,1,detached_thread,void* detached_thread (void*),android\thread.c,"static void *detached_thread(void *data)
{
    vlc_thread_t th = data;

    thread = th;

    vlc_cleanup_push(clean_detached_thread, th);
    th->entry(th->data);
    vlc_cleanup_pop();
    clean_detached_thread(th);
    return NULL;
}",184.0,195.0,1.0,1.0,12.0,4,2,9,4,0,1,1,1,0,1,,0,0,2,1,1,void*
688,1535,finish_joinable_thread,1,finish_joinable_thread,void finish_joinable_thread (void*),android\thread.c,"static void finish_joinable_thread(void *data)
{
    vlc_thread_t th = data;

    vlc_sem_post(&th->finished);
}",197.0,202.0,1.0,1.0,6.0,3,3,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
689,1549,joinable_thread,1,joinable_thread,void* joinable_thread (void*),android\thread.c,"static void *joinable_thread(void *data)
{
    vlc_thread_t th = data;
    void *ret;

    vlc_cleanup_push(finish_joinable_thread, th);
    thread = th;
    ret = th->entry(th->data);
    vlc_cleanup_pop();
    vlc_sem_post(&th->finished);

    return ret;
}",204.0,216.0,1.0,1.0,13.0,7,3,10,4,0,1,1,1,0,1,,0,0,2,1,1,void*
690,1582,vlc_clone_attr,1,vlc_clone_attr,"int vlc_clone_attr (vlc_thread_t*,void*,void*,bool)",win32\thread.c,"static int vlc_clone_attr (vlc_thread_t *p_handle, bool detached,
                           void *(*entry) (void *), void *data, int priority)
{
    struct vlc_thread *th = malloc (sizeof (*th));
    if (unlikely(th == NULL))
        return ENOMEM;
    th->entry = entry;
    th->data = data;
    th->killable = false; /* not until vlc_entry() ! */
    atomic_init(&th->killed, false);
    th->cleaners = NULL;
    th->wait.addr = NULL;
    InitializeCriticalSection(&th->wait.lock);

    HANDLE h;
#if VLC_WINSTORE_APP
    h = CreateThread(NULL, 0, vlc_entry, th, 0, NULL);
#else // !VLC_WINSTORE_APP
    /* When using the MSVCRT C library you have to use the _beginthreadex
     * function instead of CreateThread, otherwise you'll end up with
     * memory leaks and the signal functions not working (see Microsoft
     * Knowledge Base, article 104641) */
    h = (HANDLE)(uintptr_t) _beginthreadex (NULL, 0, vlc_entry, th, 0, NULL);
#endif // !VLC_WINSTORE_APP
    if (h == 0)
    {
        ...",484.0,530.0,1.0,1.0,47.0,41,9,49,22,2,2,3,3,0,2,,0,0,10,5,5,int
691,1722,vlc_clone,1,vlc_clone,"int vlc_clone (vlc_thread_t*,void*,void*,int)",win32\thread.c,"int vlc_clone (vlc_thread_t *p_handle, void *(*entry) (void *),
                void *data, int priority)
{
    return vlc_clone_attr (p_handle, false, entry, data, priority);
}",532.0,536.0,1.0,1.0,5.0,1,1,5,5,12,1,1,1,0,1,,0,0,8,4,4,int
692,1739,vlc_join,1,vlc_join,"void vlc_join (vlc_thread_t,void**)",win32\thread.c,"void vlc_join (vlc_thread_t th, void **result)
{
    DWORD ret;

    do
    {
        vlc_testcancel ();
        ret = WaitForSingleObjectEx(th->id, INFINITE, TRUE);
        assert(ret != WAIT_ABANDONED_0);
    }
    while (ret == WAIT_IO_COMPLETION || ret == WAIT_FAILED);

    if (result != NULL)
        *result = th->data;
    CloseHandle (th->id);
    vlc_thread_destroy(th);
}",538.0,554.0,1.0,1.0,17.0,7,4,9,4,16,4,1,1,0,4,,0,0,4,2,2,void
693,1783,vlc_clone_detach,1,vlc_clone_detach,"int vlc_clone_detach (vlc_thread_t*,void*,void*,int)",win32\thread.c,"int vlc_clone_detach (vlc_thread_t *p_handle, void *(*entry) (void *),
                      void *data, int priority)
{
    vlc_thread_t th;
    if (p_handle == NULL)
        p_handle = &th;

    return vlc_clone_attr (p_handle, true, entry, data, priority);
}",556.0,564.0,1.0,1.0,9.0,4,4,9,7,1,1,2,2,0,1,,0,0,8,4,4,int
694,1824,vlc_cancel,1,vlc_cancel,void vlc_cancel (vlc_thread_t),win32\thread.c,"void vlc_cancel (vlc_thread_t th)
{
    atomic_store_explicit(&th->killed, true, memory_order_relaxed);

    EnterCriticalSection(&th->wait.lock);
    if (th->wait.addr != NULL)
    {
        atomic_fetch_or_explicit(th->wait.addr, 1, memory_order_relaxed);
        vlc_addr_broadcast(th->wait.addr);
    }
    LeaveCriticalSection(&th->wait.lock);

#if IS_INTERRUPTIBLE
    QueueUserAPC (vlc_cancel_self, th->id, (uintptr_t)th);
#endif
}",593.0,608.0,1.0,4.0,16.0,12,5,11,5,4,3,2,2,0,3,,0,0,2,1,1,void
695,1868,vlc_savecancel,1,vlc_savecancel,int vlc_savecancel (void),win32\thread.c,"int vlc_savecancel (void)
{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return false; /* Main thread - cannot be cancelled anyway */

    int state = th->killable;
    th->killable = false;
    return state;
}",610.0,619.0,1.0,1.0,10.0,5,3,7,4,18,0,2,2,0,0,,0,0,2,1,1,int
696,1892,vlc_restorecancel,1,vlc_restorecancel,void vlc_restorecancel (int),win32\thread.c,"void vlc_restorecancel (int state)
{
    struct vlc_thread *th = vlc_thread_self();
    assert (state == false || state == true);

    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    assert (!th->killable);
    th->killable = state != 0;
}",621.0,631.0,1.0,1.0,11.0,3,3,3,2,18,0,2,2,0,0,,0,0,2,1,1,void
697,1907,vlc_testcancel,1,vlc_testcancel,void vlc_testcancel (void),win32\thread.c,"void vlc_testcancel (void)
{
    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */
    if (!th->killable)
        return;
    if (!atomic_load_explicit(&th->killed, memory_order_relaxed))
        return;

    th->killable = true; /* Do not re-enter cancellation cleanup */

    for (vlc_cleanup_t *p = th->cleaners; p != NULL; p = p->next)
        p->proc (p->data);

    th->data = NULL; /* TODO: special value? */
    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
#if VLC_WINSTORE_APP
    ExitThread(0);
#else // !VLC_WINSTORE_APP
    _endthreadex(0);
#endif // !VLC_WINSTORE_APP
}",633.0,656.0,1.0,1.0,24.0,6,3,4,2,7,0,4,4,0,0,,0,0,2,1,1,void
698,1935,vlc_control_cancel,1,vlc_control_cancel,void vlc_control_cancel (int...),win32\thread.c,"void vlc_control_cancel (int cmd, ...)
{
    /* NOTE: This function only modifies thread-specific data, so there is no
     * need to lock anything. */
    va_list ap;

    struct vlc_thread *th = vlc_thread_self();
    if (th == NULL)
        return; /* Main thread - cannot be cancelled anyway */

    va_start (ap, cmd);
    switch (cmd)
    {
        case VLC_CLEANUP_PUSH:
        {
            /* cleaner is a pointer to the caller stack, no need to allocate
             * and copy anything. As a nice side effect, this cannot fail. */
            vlc_cleanup_t *cleaner = va_arg (ap, vlc_cleanup_t *);
            cleaner->next = th->cleaners;
            th->cleaners = cleaner;
            break;
        }

        case VLC_CLEANUP_POP:
        {
            th->cleaners = th->cleaners->next;
            break;
        }

        case VLC_CANCEL_ADDR_SET:
        {
            void *addr = va_arg(ap, void *);

            EnterCriticalSection(&th->wait.lock);
            assert(th-...",658.0,710.0,1.0,1.0,53.0,27,6,22,7,0,5,5,3,0,5,,0,1,2,1,1,void
699,2050,vlc_threadvar_set,1,vlc_threadvar_set,"int vlc_threadvar_set (vlc_threadvar_t,void*)",win32\thread.c,"int vlc_threadvar_set (vlc_threadvar_t key, void *value)
{
    int saved = GetLastError ();

    if (!TlsSetValue(key->id, value))
        return ENOMEM;

    SetLastError(saved);
    return 0;
}",280.0,289.0,1.0,1.0,10.0,0,0,2,2,3,0,1,1,0,0,,0,0,4,2,2,int
700,2060,vlc_threadvar_get,1,vlc_threadvar_get,void* vlc_threadvar_get (vlc_threadvar_t),win32\thread.c,"void *vlc_threadvar_get (vlc_threadvar_t key)
{
    int saved = GetLastError ();
    void *value = TlsGetValue (key->id);

    SetLastError(saved);
    return value;
}",291.0,298.0,1.0,1.0,8.0,0,0,1,1,2,0,1,1,0,0,,0,0,2,1,1,void*
701,2068,mdate,1,mdate,mtime_t mdate (void),win32\thread.c,"mtime_t mdate (void)
{
    return mdate_selected ();
}",820.0,823.0,1.0,1.0,4.0,7,6,4,2,39,0,2,2,0,0,,0,0,2,1,1,mtime_t
702,2173,aout_owner,1,aout_owner,aout_owner_t aout_owner (audio_output_t*),audio_output\aout_internal.h,"static inline aout_owner_t *aout_owner (audio_output_t *aout)
{
    return &((aout_instance_t *)aout)->owner;
}",105.0,108.0,1.0,1.0,4.0,3,3,1,1,12,0,1,1,0,0,,0,0,2,1,1,aout_owner_t
703,2191,aout_volume_SetFormat,1,aout_volume_SetFormat,"int aout_volume_SetFormat (aout_volume_t*,ANY)",audio_output\volume.c,"int aout_volume_SetFormat(aout_volume_t *vol, vlc_fourcc_t format)
{
    if (unlikely(vol == NULL))
        return -1;

    audio_volume_t *obj = &vol->object;
    if (vol->module != NULL)
    {
        if (obj->format == format)
        {
            msg_Dbg (obj, ""retaining sample format"");
            return 0;
        }
        msg_Dbg (obj, ""changing sample format"");
        module_unneed(obj, vol->module);
    }

    obj->format = format;
    vol->module = module_need(obj, ""audio volume"", NULL, false);
    if (vol->module == NULL)
        return -1;
    return 0;
}",80.0,102.0,1.0,1.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
704,2197,aout_volume_SetVolume,1,aout_volume_SetVolume,"void aout_volume_SetVolume (aout_volume_t*,float)",audio_output\volume.c,"void aout_volume_SetVolume(aout_volume_t *vol, float factor)
{
    if (unlikely(vol == NULL))
        return;

    vol->output_factor = factor;
}",121.0,127.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
705,2214,aout_New,1,aout_New,audio_output_t* aout_New (vlc_object_t*),audio_output\output.c,"audio_output_t *aout_New (vlc_object_t *parent)
{
    vlc_value_t val, text;

    audio_output_t *aout = vlc_custom_create (parent, sizeof (aout_instance_t),
                                              ""audio output"");
    if (unlikely(aout == NULL))
        return NULL;

    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_init (&owner->lock);
    vlc_mutex_init (&owner->req.lock);
    vlc_mutex_init (&owner->dev.lock);
    vlc_mutex_init (&owner->vp.lock);
    vlc_viewpoint_init (&owner->vp.value);
    atomic_init (&owner->vp.update, false);
    owner->req.device = (char *)unset_str;
    owner->req.volume = -1.f;
    owner->req.mute = -1;

    vlc_object_set_destructor (aout, aout_Destructor);

    /* Audio output module callbacks */
    var_Create (aout, ""volume"", VLC_VAR_FLOAT);
    var_AddCallback (aout, ""volume"", var_Copy, parent);
    var_Create (aout, ""mute"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT);
    var_AddCallback (aout, ""mute"", var_Copy, parent);
    var_Create (aou...",197.0,354.0,1.0,27.0,158.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,audio_output_t
706,2219,aout_Destroy,1,aout_Destroy,void aout_Destroy (audio_output_t*),audio_output\output.c,"void aout_Destroy (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    module_unneed (aout, owner->module);
    /* Protect against late call from intf.c */
    aout->volume_set = NULL;
    aout->mute_set = NULL;
    aout->device_select = NULL;
    aout_OutputUnlock (aout);

    var_DelCallback (aout, ""viewpoint"", ViewpointCallback, NULL);
    var_DelCallback (aout, ""audio-filter"", FilterCallback, NULL);
    var_DelCallback (aout, ""device"", var_CopyDevice, aout->obj.parent);
    var_DelCallback (aout, ""mute"", var_Copy, aout->obj.parent);
    var_SetFloat (aout, ""volume"", -1.f);
    var_DelCallback (aout, ""volume"", var_Copy, aout->obj.parent);
    var_DelCallback (aout, ""stereo-mode"", StereoModeCallback, NULL);
    vlc_object_release (aout);
}",359.0,379.0,1.0,1.0,21.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
707,2224,aout_OutputNew,1,aout_OutputNew,"int aout_OutputNew (audio_output_t*,audio_sample_format_t*,aout_filters_cfg_t*)",audio_output\output.c,"int aout_OutputNew (audio_output_t *aout, audio_sample_format_t *restrict fmt,
                    aout_filters_cfg_t *filters_cfg)
{
    aout_OutputAssertLocked (aout);

    audio_channel_type_t input_chan_type = fmt->channel_type;
    int i_forced_stereo_mode = AOUT_VAR_CHAN_UNSET;
    unsigned i_nb_input_channels = fmt->i_channels;

    /* Ideally, the audio filters would be created before the audio output,
     * and the ideal audio format would be the output of the filters chain.
     * But that scheme would not really play well with digital pass-through. */
    if (AOUT_FMT_LINEAR(fmt))
    {
        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_BITMAP
         && aout_FormatNbChannels(fmt) == 0)
        {
            /* The output channel map is unknown, use the WAVE one. */
            assert(fmt->i_channels > 0);
            aout_SetWavePhysicalChannels(fmt);
        }

        if (fmt->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        {
            /* Set the maximum of...",517.0,580.0,1.0,1.0,64.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
708,2231,aout_OutputTimeGet,1,aout_OutputTimeGet,"int aout_OutputTimeGet (audio_output_t*,mtime_t*)",audio_output\output.c,"int aout_OutputTimeGet (audio_output_t *aout, mtime_t *delay)
{
    aout_OutputAssertLocked (aout);

    if (aout->time_get == NULL)
        return -1;
    return aout->time_get (aout, delay);
}",595.0,602.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
709,2237,aout_OutputPlay,1,aout_OutputPlay,"void aout_OutputPlay (audio_output_t*,block_t*)",audio_output\output.c,"void aout_OutputPlay (audio_output_t *aout, block_t *block)
{
    aout_OutputAssertLocked (aout);
#ifndef NDEBUG
    aout_owner_t *owner = aout_owner (aout);
    assert (owner->mixer_format.i_frame_length > 0);
    assert (block->i_buffer == 0 || block->i_buffer / block->i_nb_samples ==
            owner->mixer_format.i_bytes_per_frame /
            owner->mixer_format.i_frame_length);
#endif
    aout->play (aout, block);
}",609.0,620.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
710,2250,aout_OutputFlush,1,aout_OutputFlush,"void aout_OutputFlush (audio_output_t*,ANY)",audio_output\output.c,"void aout_OutputFlush( audio_output_t *aout, bool wait )
{
    aout_OutputAssertLocked( aout );
    aout->flush (aout, wait);
}",650.0,654.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
711,2256,aout_OutputDelete,1,aout_OutputDelete,void aout_OutputDelete (audio_output_t*),audio_output\output.c,"void aout_OutputDelete (audio_output_t *aout)
{
    aout_OutputAssertLocked (aout);

    if (aout->stop != NULL)
        aout->stop (aout);
}",587.0,593.0,1.0,1.0,7.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
712,2266,aout_OutputUnlock,1,aout_OutputUnlock,void aout_OutputUnlock (audio_output_t*),audio_output\output.c,"void aout_OutputUnlock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
    vlc_mutex_lock (&owner->req.lock);

    if (owner->req.device != unset_str)
    {
        aout_OutputDeviceSet (aout, owner->req.device);
        free (owner->req.device);
        owner->req.device = (char *)unset_str;
    }

    if (owner->req.volume >= 0.f)
    {
        aout_OutputVolumeSet (aout, owner->req.volume);
        owner->req.volume = -1.f;
    }

    if (owner->req.mute >= 0)
    {
        aout_OutputMuteSet (aout, owner->req.mute);
        owner->req.mute = -1;
    }

    vlc_mutex_unlock (&owner->lock);
    /* If another thread is blocked waiting for owner->req.lock at this point,
     * this aout_OutputUnlock() call will not see and apply its change request.
     * The other thread will need to apply the change request itself, which
     * implies it is able to (try-)lock owner->lock. Therefore this thread must
     * release owner-...",688.0,721.0,1.0,4.0,34.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
713,2271,aout_FormatsPrint,1,aout_FormatsPrint,"void aout_FormatsPrint (vlc_object_t*,char*,audio_sample_format_t*,audio_sample_format_t*)",audio_output\common.c,"void aout_FormatsPrint( vlc_object_t *obj, const char * psz_text,
                        const audio_sample_format_t * p_format1,
                        const audio_sample_format_t * p_format2 )
{
    msg_Dbg( obj, ""%s '%4.4s'->'%4.4s' %d Hz->%d Hz %s->%s"",
             psz_text,
             (char *)&p_format1->i_format, (char *)&p_format2->i_format,
             p_format1->i_rate, p_format2->i_rate,
             aout_FormatPrintChannels( p_format1 ),
             aout_FormatPrintChannels( p_format2 ) );
}",242.0,252.0,1.0,1.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
714,2279,aout_ChangeFilterString,1,aout_ChangeFilterString,"bool aout_ChangeFilterString (vlc_object_t*,vlc_object_t*,char*,char*,bool)",audio_output\common.c,"bool aout_ChangeFilterString( vlc_object_t *p_obj, vlc_object_t *p_aout,
                              const char *psz_variable,
                              const char *psz_name, bool b_add )
{
    if( *psz_name == '\0' )
        return false;

    char *psz_list;
    if( p_aout )
    {
        psz_list = var_GetString( p_aout, psz_variable );
    }
    else
    {
        psz_list = var_InheritString( p_obj, psz_variable );
    }

    /* Split the string into an array of filters */
    int i_count = 1;
    for( char *p = psz_list; p && *p; p++ )
        i_count += *p == ':';
    i_count += b_add;

    const char **ppsz_filter = calloc( i_count, sizeof(*ppsz_filter) );
    if( !ppsz_filter )
    {
        free( psz_list );
        return false;
    }
    bool b_present = false;
    i_count = 0;
    for( char *p = psz_list; p && *p; )
    {
        char *psz_end = strchr(p, ':');
        if( psz_end )
            *psz_end++ = '\0';
        else
            psz_end = p + strlen(p);
 ...",543.0,648.0,1.0,1.0,106.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,bool
715,2288,aout_DecNew,1,aout_DecNew,"int aout_DecNew (audio_output_t*,audio_sample_format_t*,audio_replay_gain_t*,aout_request_vout_t*)",audio_output\dec.c,"int aout_DecNew( audio_output_t *p_aout,
                 const audio_sample_format_t *p_format,
                 const audio_replay_gain_t *p_replay_gain,
                 const aout_request_vout_t *p_request_vout )
{
    if( p_format->i_bitspersample > 0 )
    {
        /* Sanitize audio format, input need to have a valid physical channels
         * layout or a valid number of channels. */
        int i_map_channels = aout_FormatNbChannels( p_format );
        if( ( i_map_channels == 0 && p_format->i_channels == 0 )
           || i_map_channels > AOUT_CHAN_MAX || p_format->i_channels > INPUT_CHAN_MAX )
        {
            msg_Err( p_aout, ""invalid audio channels count"" );
            return -1;
        }
    }

    if( p_format->i_rate > 384000 )
    {
        msg_Err( p_aout, ""excessive audio sample frequency (%u)"",
                 p_format->i_rate );
        return -1;
    }
    if( p_format->i_rate < 4000 )
    {
        msg_Err( p_aout, ""too low audio sample frequency (%u)...",43.0,119.0,1.0,20.0,77.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
716,2296,aout_DecDelete,1,aout_DecDelete,void aout_DecDelete (audio_output_t*),audio_output\dec.c,"void aout_DecDelete (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->mixer_format.i_format)
    {
        aout_FiltersDelete (aout, owner->filters);
        aout_OutputDelete (aout);
    }
    aout_volume_Delete (owner->volume);
    owner->volume = NULL;
    aout_OutputUnlock (aout);
}",124.0,137.0,1.0,1.0,14.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
717,2301,aout_DecPlay,1,aout_DecPlay,"int aout_DecPlay (audio_output_t*,block_t*,int)",audio_output\dec.c,"int aout_DecPlay (audio_output_t *aout, block_t *block, int input_rate)
{
    aout_owner_t *owner = aout_owner (aout);

    assert (input_rate >= INPUT_RATE_DEFAULT / AOUT_MAX_INPUT_RATE);
    assert (input_rate <= INPUT_RATE_DEFAULT * AOUT_MAX_INPUT_RATE);
    assert (block->i_pts >= VLC_TS_0);

    block->i_length = CLOCK_FREQ * block->i_nb_samples
                                 / owner->input_format.i_rate;

    aout_OutputLock (aout);
    int ret = aout_CheckReady (aout);
    if (unlikely(ret == AOUT_DEC_FAILED))
        goto drop; /* Pipeline is unrecoverably broken :-( */

    const mtime_t now = mdate (), advance = block->i_pts - now;
    if (advance < -AOUT_MAX_PTS_DELAY)
    {   /* Late buffer can be caused by bugs in the decoder, by scheduling
         * latency spikes (excessive load, SIGSTOP, etc.) or if buffering is
         * insufficient. We assume the PTS is wrong and play the buffer anyway:
         * Hopefully video has encountered a similar PTS problem as audio....",357.0,421.0,1.0,47.0,65.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
718,2308,aout_DecGetResetStats,1,aout_DecGetResetStats,"void aout_DecGetResetStats (audio_output_t*,unsigned*,unsigned*)",audio_output\dec.c,"void aout_DecGetResetStats(audio_output_t *aout, unsigned *restrict lost,
                           unsigned *restrict played)
{
    aout_owner_t *owner = aout_owner (aout);

    *lost = atomic_exchange(&owner->buffers_lost, 0);
    *played = atomic_exchange(&owner->buffers_played, 0);
}",423.0,430.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
719,2315,aout_DecChangePause,1,aout_DecChangePause,"void aout_DecChangePause (audio_output_t*,bool,mtime_t)",audio_output\dec.c,"void aout_DecChangePause (audio_output_t *aout, bool paused, mtime_t date)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    if (owner->sync.end != VLC_TS_INVALID)
    {
        if (paused)
            owner->sync.end -= date;
        else
            owner->sync.end += date;
    }
    if (owner->mixer_format.i_format)
        aout_OutputPause (aout, paused, date);
    aout_OutputUnlock (aout);
}",432.0,447.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
720,2322,aout_DecFlush,1,aout_DecFlush,"void aout_DecFlush (audio_output_t*,bool)",audio_output\dec.c,"void aout_DecFlush (audio_output_t *aout, bool wait)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputLock (aout);
    owner->sync.end = VLC_TS_INVALID;
    if (owner->mixer_format.i_format)
    {
        if (wait)
        {
            block_t *block = aout_FiltersDrain (owner->filters);
            if (block)
                aout_OutputPlay (aout, block);
        }
        else
            aout_FiltersFlush (owner->filters);
        aout_OutputFlush (aout, wait);
    }
    aout_OutputUnlock (aout);
}",449.0,468.0,1.0,1.0,20.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,void
721,2328,aout_RequestRestart,1,aout_RequestRestart,"void aout_RequestRestart (audio_output_t*,unsigned)",audio_output\dec.c,"void aout_RequestRestart (audio_output_t *aout, unsigned mode)
{
    aout_owner_t *owner = aout_owner (aout);
    atomic_fetch_or (&owner->restart, mode);
    msg_Dbg (aout, ""restart requested (%u)"", mode);
}",197.0,202.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
722,2334,aout_InputRequestRestart,1,aout_InputRequestRestart,void aout_InputRequestRestart (audio_output_t*),audio_output\aout_internal.h,"static inline void aout_InputRequestRestart(audio_output_t *aout)
{
    aout_RequestRestart(aout, AOUT_RESTART_FILTERS);
}",162.0,165.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,2,1,1,void
723,2342,aout_SetWavePhysicalChannels,1,aout_SetWavePhysicalChannels,void aout_SetWavePhysicalChannels (audio_sample_format_t*),audio_output\aout_internal.h,"static inline void aout_SetWavePhysicalChannels(audio_sample_format_t *fmt)
{
    static const uint32_t wave_channels[] = {
        AOUT_CHAN_LEFT, AOUT_CHAN_RIGHT, AOUT_CHAN_CENTER,
        AOUT_CHAN_LFE, AOUT_CHAN_REARLEFT, AOUT_CHAN_REARRIGHT,
        AOUT_CHAN_MIDDLELEFT, AOUT_CHAN_MIDDLERIGHT, AOUT_CHAN_REARCENTER };

    fmt->i_physical_channels = 0;
    for (int i = 0; i < fmt->i_channels && i < AOUT_CHAN_MAX; ++i)
        fmt->i_physical_channels |= wave_channels[i];
    aout_FormatPrepare(fmt);
}",167.0,178.0,1.0,1.0,12.0,9,5,17,13,1,1,2,2,0,1,,0,0,2,1,1,void
724,2391,aout_FiltersCanResample,1,aout_FiltersCanResample,bool aout_FiltersCanResample (aout_filters_t*),audio_output\filters.c,"bool aout_FiltersCanResample (aout_filters_t *filters)
{
    return (filters->resampler != NULL);
}",682.0,685.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,bool
725,2396,aout_ChangeViewpoint,1,aout_ChangeViewpoint,"void aout_ChangeViewpoint (audio_output_t*,vlc_viewpoint_t*)",audio_output\dec.c,"void aout_ChangeViewpoint(audio_output_t *aout,
                          const vlc_viewpoint_t *p_viewpoint)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->vp.lock);
    owner->vp.value = *p_viewpoint;
    atomic_store(&owner->vp.update, true);
    vlc_mutex_unlock (&owner->vp.lock);
}",470.0,479.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
726,2419,aout_BitsPerSample,1,aout_BitsPerSample,unsigned int aout_BitsPerSample (vlc_fourcc_t),audio_output\common.c,"unsigned int aout_BitsPerSample( vlc_fourcc_t i_format )
{
    switch( vlc_fourcc_GetCodec( AUDIO_ES, i_format ) )
    {
    case VLC_CODEC_U8:
    case VLC_CODEC_S8:
    case VLC_CODEC_ALAW:
    case VLC_CODEC_MULAW:
        return 8;

    case VLC_CODEC_U16L:
    case VLC_CODEC_S16L:
    case VLC_CODEC_U16B:
    case VLC_CODEC_S16B:
        return 16;

    case VLC_CODEC_U24L:
    case VLC_CODEC_S24L:
    case VLC_CODEC_U24B:
    case VLC_CODEC_S24B:
        return 24;

    case VLC_CODEC_S24L32:
    case VLC_CODEC_S24B32:
    case VLC_CODEC_U32L:
    case VLC_CODEC_U32B:
    case VLC_CODEC_S32L:
    case VLC_CODEC_S32B:
    case VLC_CODEC_F32L:
    case VLC_CODEC_F32B:
        return 32;

    case VLC_CODEC_F64L:
    case VLC_CODEC_F64B:
        return 64;

    default:
        /* For these formats the caller has to indicate the parameters
         * by hand. */
        return 0;
    }
}",42.0,83.0,1.0,1.0,42.0,0,0,24,24,2,1,2,2,1,1,,0,1,2,1,1,unsigned int
727,2486,aout_FormatPrepare,1,aout_FormatPrepare,void aout_FormatPrepare (audio_sample_format_t*),audio_output\common.c,"void aout_FormatPrepare( audio_sample_format_t * p_format )
{

    unsigned i_channels = aout_FormatNbChannels( p_format );
    if( i_channels > 0 )
        p_format->i_channels = i_channels;
    p_format->i_bitspersample = aout_BitsPerSample( p_format->i_format );
    if( p_format->i_bitspersample > 0 )
    {
        p_format->i_bytes_per_frame = ( p_format->i_bitspersample / 8 )
                                    * p_format->i_channels;
        p_format->i_frame_length = 1;
    }
}",88.0,101.0,1.0,1.0,14.0,17,5,12,2,6,1,3,3,0,1,,0,1,2,1,1,void
728,2539,aout_FormatPrintChannels,1,aout_FormatPrintChannels,const char* aout_FormatPrintChannels (audio_sample_format_t*),audio_output\common.c,"const char * aout_FormatPrintChannels( const audio_sample_format_t * p_format )
{
    if (p_format->channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS)
        return ""Ambisonics"";

    /* AUDIO_CHANNEL_TYPE_BITMAP */
    switch ( p_format->i_physical_channels )
    {
    case AOUT_CHAN_LEFT:
    case AOUT_CHAN_RIGHT:
    case AOUT_CHAN_CENTER:
        if ( (p_format->i_physical_channels & AOUT_CHAN_CENTER)
              || (p_format->i_physical_channels
                   & (AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT)) )
            return ""Mono"";
        else if ( p_format->i_physical_channels & AOUT_CHAN_LEFT )
            return ""Left"";
        return ""Right"";
    case AOUT_CHAN_LEFT | AOUT_CHAN_RIGHT:
        if ( p_format->i_chan_mode & AOUT_CHANMODE_DOLBYSTEREO )
            return ""Dolby"";
        else if ( p_format->i_chan_mode & AOUT_CHANMODE_DUALMONO )
            return ""Dual-mono"";
        else if ( p_format->i_physical_channels == AOUT_CHAN_CENTER )
            return ""Stereo/Mono"";
...",106.0,223.0,1.0,1.0,118.0,110,5,134,12,1,0,7,11,0,0,,0,0,2,1,1,const char*
729,3008,aout_FormatPrint,1,aout_FormatPrint,"void aout_FormatPrint (vlc_object_t*,char*,audio_sample_format_t*)",audio_output\common.c,"void aout_FormatPrint( vlc_object_t *obj, const char *psz_text,
                       const audio_sample_format_t *p_format )
{
    msg_Dbg( obj, ""%s '%4.4s' %d Hz %s frame=%d samples/%d bytes"", psz_text,
             (char *)&p_format->i_format, p_format->i_rate,
             aout_FormatPrintChannels( p_format ),
             p_format->i_frame_length, p_format->i_bytes_per_frame );
}",229.0,236.0,1.0,1.0,8.0,6,3,7,3,1,1,1,1,0,1,,0,0,6,3,3,void
730,3185,aout_ChannelReorder,1,aout_ChannelReorder,"void aout_ChannelReorder (void*,size_t,uint8_t,uint8_t*,vlc_fourcc_t)",audio_output\common.c,"void aout_ChannelReorder( void *ptr, size_t bytes, uint8_t channels,
                          const uint8_t *restrict chans_table, vlc_fourcc_t fourcc )
{
    if( unlikely(bytes == 0) )
        return;

    assert( channels != 0 );

    /* The audio formats supported in audio output are inlined. For other
     * formats (used in demuxers and muxers), memcpy() is used to avoid
     * breaking type punning. */
#define REORDER_TYPE(type) \
do { \
    const size_t frames = (bytes / sizeof (type)) / channels; \
    type *buf = ptr; \
\
    for( size_t i = 0; i < frames; i++ ) \
    { \
        type tmp[AOUT_CHAN_MAX]; \
\
        for( size_t j = 0; j < channels; j++ ) \
            tmp[chans_table[j]] = buf[j]; \
        memcpy( buf, tmp, sizeof (type) * channels ); \
        buf += channels; \
    } \
} while(0)

    if( likely(channels <= AOUT_CHAN_MAX) )
    {
        switch( fourcc )
        {
            case VLC_CODEC_U8:   REORDER_TYPE(uint8_t); return;
            case VLC_CODEC...",301.0,355.0,1.0,33.0,55.0,109,12,163,27,0,1,6,8,0,1,,0,1,10,5,5,void
731,4248,ExtractChannel,1,ExtractChannel,"void ExtractChannel (uint8_t*,int,uint8_t*,int,int,int*,int)",audio_output\common.c,"static inline void ExtractChannel( uint8_t *pi_dst, int i_dst_channels,
                                   const uint8_t *pi_src, int i_src_channels,
                                   int i_sample_count,
                                   const int *pi_selection, int i_bytes )
{
    for( int i = 0; i < i_sample_count; i++ )
    {
        for( int j = 0; j < i_dst_channels; j++ )
            memcpy( &pi_dst[j * i_bytes], &pi_src[pi_selection[j] * i_bytes], i_bytes );
        pi_dst += i_dst_channels * i_bytes;
        pi_src += i_src_channels * i_bytes;
    }
}",432.0,444.0,1.0,1.0,13.0,8,4,12,8,1,0,3,4,0,0,,0,0,14,7,7,void
732,4308,aout_ChannelExtract,1,aout_ChannelExtract,"void aout_ChannelExtract (void*,int,void*,int,int,int*,int)",audio_output\common.c,"void aout_ChannelExtract( void *p_dst, int i_dst_channels,
                          const void *p_src, int i_src_channels,
                          int i_sample_count, const int *pi_selection, int i_bits_per_sample )
{
    /* It does not work in place */
    assert( p_dst != p_src );

    /* Force the compiler to inline for the specific cases so it can optimize */
    if( i_bits_per_sample == 8 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 1 );
    else  if( i_bits_per_sample == 16 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 2 );
    else  if( i_bits_per_sample == 32 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 4 );
    else  if( i_bits_per_sample == 64 )
        ExtractChannel( p_dst, i_dst_channels, p_src, i_src_channels, i_sample_count, pi_selection, 8 );
}",446.0,462.0,1.0,1.0,17.0,2,2,9,7,0,1,2,2,0,1,,0,0,14,7,7,void
733,5238,aout_CheckReady,1,aout_CheckReady,int aout_CheckReady (audio_output_t*),audio_output\dec.c,"static int aout_CheckReady (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    int status = AOUT_DEC_SUCCESS;
    int restart = atomic_exchange (&owner->restart, 0);
    if (unlikely(restart))
    {
        if (owner->mixer_format.i_format)
            aout_FiltersDelete (aout, owner->filters);

        if (restart & AOUT_RESTART_OUTPUT)
        {   /* Reinitializes the output */
            msg_Dbg (aout, ""restarting output..."");
            if (owner->mixer_format.i_format)
                aout_OutputDelete (aout);
            owner->mixer_format = owner->input_format;
            owner->filters_cfg = AOUT_FILTERS_CFG_INIT;
            if (aout_OutputNew (aout, &owner->mixer_format, &owner->filters_cfg))
                owner->mixer_format.i_format = 0;
            aout_volume_SetFormat (owner->volume,
                                   owner->mixer_format.i_format);

            /* Notify the decoder that the aout changed in order to try a new
             ...",139.0,191.0,1.0,17.0,53.0,54,7,46,10,0,28,9,20,7,7,,0,24,2,1,1,int
734,5440,aout_StopResampling,1,aout_StopResampling,void aout_StopResampling (audio_output_t*),audio_output\dec.c,"static void aout_StopResampling (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    owner->sync.resamp_type = AOUT_RESAMPLING_NONE;
    aout_FiltersAdjustResampling (owner->filters, 0);
}",208.0,214.0,1.0,1.0,7.0,5,3,5,3,3,3,1,1,0,2,,0,2,2,1,1,void
735,5462,aout_DecSilence,1,aout_DecSilence,"void aout_DecSilence (audio_output_t*,mtime_t,mtime_t)",audio_output\dec.c,"static void aout_DecSilence (audio_output_t *aout, mtime_t length, mtime_t pts)
{
    aout_owner_t *owner = aout_owner (aout);
    const audio_sample_format_t *fmt = &owner->mixer_format;
    size_t frames = (fmt->i_rate * length) / CLOCK_FREQ;

    block_t *block = block_Alloc (frames * fmt->i_bytes_per_frame
                                  / fmt->i_frame_length);
    if (unlikely(block == NULL))
        return; /* uho! */

    msg_Dbg (aout, ""inserting %zu zeroes"", frames);
    memset (block->p_buffer, 0, block->i_buffer);
    block->i_nb_samples = frames;
    block->i_pts = pts;
    block->i_dts = pts;
    block->i_length = length;
    aout_OutputPlay (aout, block);
}",216.0,234.0,1.0,1.0,19.0,24,6,28,9,1,4,2,2,0,3,,0,3,6,3,3,void
736,5546,aout_DecSynchronize,1,aout_DecSynchronize,"void aout_DecSynchronize (audio_output_t*,mtime_t,int)",audio_output\dec.c,"static void aout_DecSynchronize (audio_output_t *aout, mtime_t dec_pts,
                                 int input_rate)
{
    aout_owner_t *owner = aout_owner (aout);
    mtime_t drift;

    /**
     * Depending on the drift between the actual and intended playback times,
     * the audio core may ignore the drift, trigger upsampling or downsampling,
     * insert silence or even discard samples.
     * Future VLC versions may instead adjust the input rate.
     *
     * The audio output plugin is responsible for estimating its actual
     * playback time, or rather the estimated time when the next sample will
     * be played. (The actual playback time is always the current time, that is
     * to say mdate(). It is not an useful statistic.)
     *
     * Most audio output plugins can estimate the delay until playback of
     * the next sample to be written to the buffer, or equally the time until
     * all samples in the buffer will have been played. Then:
     *    pts = mdate(...",236.0,352.0,1.0,1.0,117.0,89,19,66,15,0,14,12,13,6,12,,0,7,6,3,3,void
737,6233,CreateFilter,1,CreateFilter,"filter_t CreateFilter (vlc_object_t*,char*,char*,filter_owner_sys_t*,audio_sample_format_t*,audio_sample_format_t*,config_chain_t*,bool)",misc\image.c,"static filter_t *CreateFilter( vlc_object_t *p_this, const es_format_t *p_fmt_in,
                               const video_format_t *p_fmt_out )
{
    filter_t *p_filter;

    p_filter = vlc_custom_create( p_this, sizeof(filter_t), ""filter"" );
    p_filter->owner.video.buffer_new = filter_new_picture;

    es_format_Copy( &p_filter->fmt_in, p_fmt_in );
    es_format_Copy( &p_filter->fmt_out, p_fmt_in );
    video_format_Copy( &p_filter->fmt_out.video, p_fmt_out );

    /* whatever the input offset, write at offset 0 in the target image */
    p_filter->fmt_out.video.i_x_offset = 0;
    p_filter->fmt_out.video.i_y_offset = 0;

    p_filter->fmt_out.i_codec = p_fmt_out->i_chroma;
    p_filter->p_module = module_need( p_filter, ""video converter"", NULL, false );

    if( !p_filter->p_module )
    {
        msg_Dbg( p_filter, ""no video converter found"" );
        DeleteFilter( p_filter );
        return NULL;
    }

    return p_filter;
}",801.0,828.0,1.0,1.0,28.0,47,9,43,11,4,3,6,6,0,3,,0,2,6,3,3,filter_t
738,6394,FindConverter,1,FindConverter,"filter_t FindConverter (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*)",audio_output\filters.c,"static filter_t *FindConverter (vlc_object_t *obj,
                                const audio_sample_format_t *infmt,
                                const audio_sample_format_t *outfmt)
{
    return CreateFilter (obj, ""audio converter"", NULL, NULL, infmt, outfmt,
                         NULL, true);
}",92.0,98.0,1.0,1.0,7.0,0,0,7,5,4,1,1,1,0,1,,0,0,6,3,3,filter_t
739,6411,FindResampler,1,FindResampler,"filter_t FindResampler (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*)",audio_output\filters.c,"static filter_t *FindResampler (vlc_object_t *obj,
                                const audio_sample_format_t *infmt,
                                const audio_sample_format_t *outfmt)
{
    return CreateFilter (obj, ""audio resampler"", ""$audio-resampler"", NULL,
                         infmt, outfmt, NULL, true);
}",100.0,106.0,1.0,1.0,7.0,0,0,6,5,1,1,1,1,0,1,,0,0,6,3,3,filter_t
740,6428,aout_FiltersPipelineDestroy,1,aout_FiltersPipelineDestroy,"void aout_FiltersPipelineDestroy (filter_t**,unsigned)",audio_output\filters.c,"static void aout_FiltersPipelineDestroy(filter_t *const *filters, unsigned n)
{
    for( unsigned i = 0; i < n; i++ )
    {
        filter_t *p_filter = filters[i];

        module_unneed( p_filter, p_filter->p_module );
        vlc_object_release( p_filter );
    }
}",111.0,120.0,1.0,1.0,10.0,5,4,9,4,4,2,2,2,0,2,,0,0,4,2,2,void
741,6459,TryFormat,1,TryFormat,"filter_t TryFormat (vlc_object_t*,vlc_fourcc_t,audio_sample_format_t*)",audio_output\filters.c,"static filter_t *TryFormat (vlc_object_t *obj, vlc_fourcc_t codec,
                            audio_sample_format_t *restrict fmt)
{
    audio_sample_format_t output = *fmt;

    assert (codec != fmt->i_format);
    output.i_format = codec;
    aout_FormatPrepare (&output);

    filter_t *filter = FindConverter (obj, fmt, &output);
    if (filter != NULL)
        *fmt = output;
    return filter;
}",122.0,135.0,1.0,1.0,14.0,12,6,16,6,2,2,2,2,0,2,,0,1,6,3,3,filter_t
742,6504,aout_FiltersPipelineCreate,1,aout_FiltersPipelineCreate,"int aout_FiltersPipelineCreate (vlc_object_t*,filter_t**,unsigned*,unsigned,audio_sample_format_t*,audio_sample_format_t*,bool)",audio_output\filters.c,"static int aout_FiltersPipelineCreate(vlc_object_t *obj, filter_t **filters,
                                      unsigned *count, unsigned max,
                                 const audio_sample_format_t *restrict infmt,
                                 const audio_sample_format_t *restrict outfmt,
                                 bool headphones)
{
    aout_FormatsPrint (obj, ""conversion:"", infmt, outfmt);
    max -= *count;
    filters += *count;

    /* There is a lot of second guessing on what the conversion plugins can
     * and cannot do. This seems hardly avoidable, the conversion problem need
     * to be reduced somehow. */
    audio_sample_format_t input = *infmt;
    unsigned n = 0;

    if (!AOUT_FMT_LINEAR(&input))
    {
        msg_Err(obj, ""Can't convert non linear input"");
        return -1;
    }

    /* Remix channels */
    if (infmt->i_physical_channels != outfmt->i_physical_channels
     || infmt->i_chan_mode != outfmt->i_chan_mode
     || infmt->channel_typ...",147.0,272.0,1.0,4.0,126.0,92,15,116,16,3,10,24,29,0,10,,0,4,14,7,7,int
743,6848,aout_FiltersPipelinePlay,1,aout_FiltersPipelinePlay,"block_t aout_FiltersPipelinePlay (filter_t**,unsigned,block_t*)",audio_output\filters.c,"static block_t *aout_FiltersPipelinePlay(filter_t *const *filters,
                                         unsigned count, block_t *block)
{
    /* TODO: use filter chain */
    for (unsigned i = 0; (i < count) && (block != NULL); i++)
    {
        filter_t *filter = filters[i];

        /* Please note that p_block->i_nb_samples & i_buffer
         * shall be set by the filter plug-in. */
        block = filter->pf_audio_filter (filter, block);
    }
    return block;
}",277.0,290.0,1.0,1.0,14.0,8,6,13,6,4,0,2,2,0,0,,0,0,6,3,3,block_t
744,6887,aout_FiltersPipelineDrain,1,aout_FiltersPipelineDrain,"block_t aout_FiltersPipelineDrain (filter_t**,unsigned)",audio_output\filters.c,"static block_t *aout_FiltersPipelineDrain(filter_t *const *filters,
                                          unsigned count)
{
    block_t *chain = NULL;

    for (unsigned i = 0; i < count; i++)
    {
        filter_t *filter = filters[i];

        block_t *block = filter_DrainAudio (filter);
        if (block)
        {
            /* If there is a drained block, filter it through the following
             * chain of filters  */
            if (i + 1 < count)
                block = aout_FiltersPipelinePlay (&filters[i + 1],
                                                  count - i - 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }
    }

    if (chain)
        return block_ChainGather(chain);
    else
        return NULL;
}",296.0,322.0,1.0,1.0,27.0,15,6,24,7,2,1,6,11,0,1,,0,1,4,2,2,block_t
745,6962,aout_FiltersPipelineFlush,1,aout_FiltersPipelineFlush,"void aout_FiltersPipelineFlush (filter_t**,unsigned)",audio_output\filters.c,"static void aout_FiltersPipelineFlush(filter_t *const *filters,
                                      unsigned count)
{
    for (unsigned i = 0; i < count; i++)
        filter_Flush (filters[i]);
}",327.0,332.0,1.0,1.0,6.0,2,2,3,2,2,0,2,2,0,0,,0,0,4,2,2,void
746,6983,aout_FiltersPipelineChangeViewpoint,1,aout_FiltersPipelineChangeViewpoint,"void aout_FiltersPipelineChangeViewpoint (filter_t**,unsigned,vlc_viewpoint_t*)",audio_output\filters.c,"static void aout_FiltersPipelineChangeViewpoint(filter_t *const *filters,
                                                unsigned count,
                                                const vlc_viewpoint_t *vp)
{
    for (unsigned i = 0; i < count; i++)
        filter_ChangeViewpoint (filters[i], vp);
}",334.0,340.0,1.0,1.0,7.0,2,2,3,2,1,0,2,2,0,0,,0,0,6,3,3,void
747,7020,VisualizationCallback,1,VisualizationCallback,"int VisualizationCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\filters.c,"static int VisualizationCallback (vlc_object_t *obj, const char *var,
                                  vlc_value_t oldval, vlc_value_t newval,
                                  void *data)
{
    const char *mode = newval.psz_string;

    if (!*mode)
        mode = ""none"";
    /* FIXME: This ugly hack enforced by visual effect-list, as is the need for
     * separate ""visual"" (external) and ""audio-visual"" (internal) variables...
     * The visual plugin should have one submodule per effect instead. */
    if (strcasecmp (mode, ""none"") && strcasecmp (mode, ""goom"")
     && strcasecmp (mode, ""projectm"") && strcasecmp (mode, ""vsxu"")
     && strcasecmp (mode, ""glspectrum""))
    {
        var_Create (obj, ""effect-list"", VLC_VAR_STRING);
        var_SetString (obj, ""effect-list"", mode);
        mode = ""visual"";
    }

    var_SetString (obj, ""audio-visual"", mode);
    aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) oldval; (void) data;
    return VLC_SUCCESS;
}",357.0,381.0,1.0,1.0,25.0,14,6,21,8,0,2,3,3,0,2,,0,0,10,5,5,int
748,7136,AppendFilter,1,AppendFilter,"int AppendFilter (vlc_object_t*,char*,char*,aout_filters_t*,void*,audio_sample_format_t*,audio_sample_format_t*,config_chain_t*)",audio_output\filters.c,"static int AppendFilter(vlc_object_t *obj, const char *type, const char *name,
                        aout_filters_t *restrict filters, const void *owner,
                        audio_sample_format_t *restrict infmt,
                        const audio_sample_format_t *restrict outfmt,
                        config_chain_t *cfg)
{
    const unsigned max = sizeof (filters->tab) / sizeof (filters->tab[0]);
    if (filters->count >= max)
    {
        msg_Err (obj, ""maximum of %u filters reached"", max);
        return -1;
    }

    filter_t *filter = CreateFilter (obj, type, name,
                                     (void *)owner, infmt, outfmt, cfg, false);
    if (filter == NULL)
    {
        msg_Err (obj, ""cannot add user %s \""%s\"" (skipped)"", type, name);
        return -1;
    }

    /* convert to the filter input format if necessary */
    if (aout_FiltersPipelineCreate (obj, filters->tab, &filters->count,
                                    max - 1, infmt, &filter->fmt_in....",400.0,436.0,1.0,1.0,37.0,35,15,42,12,5,4,4,4,1,4,,0,2,16,8,8,int
749,7269,AppendRemapFilter,1,AppendRemapFilter,"int AppendRemapFilter (vlc_object_t*,aout_filters_t*,audio_sample_format_t*,audio_sample_format_t*,int*)",audio_output\filters.c,"static int AppendRemapFilter(vlc_object_t *obj, aout_filters_t *restrict filters,
                             audio_sample_format_t *restrict infmt,
                             const audio_sample_format_t *restrict outfmt,
                             const int *wg4_remap)
{
    char *name;
    config_chain_t *cfg;

    /* The remap audio filter use a different order than wg4 */
    static const uint8_t wg4_to_remap[] = { 0, 2, 6, 7, 3, 5, 4, 1, 8 };
    int remap[AOUT_CHAN_MAX];
    bool needed = false;
    for (int i = 0; i < AOUT_CHAN_MAX; ++i)
    {
        if (wg4_remap[i] != i)
            needed = true;
        remap[i] = wg4_remap[i] >= 0 ? wg4_to_remap[wg4_remap[i]] : -1;
    }
    if (!needed)
        return 0;

    char *str;
    int ret = asprintf(&str, ""remap{channel-left=%d,channel-right=%d,""
                       ""channel-middleleft=%d,channel-middleright=%d,""
                       ""channel-rearleft=%d,channel-rearright=%d,""
                       ""channel-rearcen...",438.0,482.0,1.0,1.0,45.0,37,12,51,17,1,3,7,8,0,3,,0,1,10,5,5,int
750,7431,aout_FiltersNew,1,aout_FiltersNew,"aout_filters_t aout_FiltersNew (vlc_object_t*,audio_sample_format_t*,audio_sample_format_t*,aout_request_vout_t*,aout_filters_cfg_t*)",audio_output\filters.c,"aout_filters_t *aout_FiltersNew (vlc_object_t *obj,
                                 const audio_sample_format_t *restrict infmt,
                                 const audio_sample_format_t *restrict outfmt,
                                 const aout_request_vout_t *request_vout,
                                 const aout_filters_cfg_t *cfg)
{
    aout_filters_t *filters = malloc (sizeof (*filters));
    if (unlikely(filters == NULL))
        return NULL;

    filters->rate_filter = NULL;
    filters->resampler = NULL;
    filters->resampling = 0;
    filters->count = 0;

    /* Prepare format structure */
    aout_FormatPrint (obj, ""input"", infmt);
    audio_sample_format_t input_format = *infmt;
    audio_sample_format_t output_format = *outfmt;

    /* Callbacks (before reading values and also before return statement) */
    if (request_vout != NULL)
        var_AddCallback (obj, ""visual"", VisualizationCallback, NULL);

    if (!AOUT_FMT_LINEAR(outfmt))
    {   /* Non-linear o...",500.0,661.0,1.0,12.0,162.0,127,14,171,17,1,17,28,32,3,17,,0,6,10,5,5,aout_filters_t
751,7934,aout_FiltersDelete,1,aout_FiltersDelete,"void aout_FiltersDelete (vlc_object_t*,aout_filters_t*)",audio_output\filters.c,"void aout_FiltersDelete (vlc_object_t *obj, aout_filters_t *filters)
{
    if (filters->resampler != NULL)
        aout_FiltersPipelineDestroy (&filters->resampler, 1);
    aout_FiltersPipelineDestroy (filters->tab, filters->count);
    if (obj != NULL)
        var_DelCallback (obj, ""visual"", VisualizationCallback, NULL);
    free (filters);
}",672.0,680.0,1.0,1.0,9.0,7,3,10,3,1,3,3,3,0,3,,0,0,4,2,2,void
752,7983,aout_FiltersAdjustResampling,1,aout_FiltersAdjustResampling,"bool aout_FiltersAdjustResampling (aout_filters_t*,int)",audio_output\filters.c,"bool aout_FiltersAdjustResampling (aout_filters_t *filters, int adjust)
{
    if (filters->resampler == NULL)
        return false;

    if (adjust)
        filters->resampling += adjust;
    else
        filters->resampling = 0;
    return filters->resampling != 0;
}",687.0,697.0,1.0,1.0,11.0,6,4,7,4,2,0,3,3,0,0,,0,0,4,2,2,bool
753,8019,aout_FiltersPlay,1,aout_FiltersPlay,"block_t aout_FiltersPlay (aout_filters_t*,block_t*,int)",audio_output\filters.c,"block_t *aout_FiltersPlay (aout_filters_t *filters, block_t *block, int rate)
{
    int nominal_rate = 0;

    if (rate != INPUT_RATE_DEFAULT)
    {
        filter_t *rate_filter = filters->rate_filter;

        if (rate_filter == NULL)
            goto drop; /* Without linear, non-nominal rate is impossible. */

        /* Override input rate */
        nominal_rate = rate_filter->fmt_in.audio.i_rate;
        rate_filter->fmt_in.audio.i_rate =
            (nominal_rate * INPUT_RATE_DEFAULT) / rate;
    }

    block = aout_FiltersPipelinePlay (filters->tab, filters->count, block);
    if (filters->resampler != NULL)
    {   /* NOTE: the resampler needs to run even if resampling is 0.
         * The decoder and output rates can still be different. */
        filters->resampler->fmt_in.audio.i_rate += filters->resampling;
        block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;
    }

    if (nomi...",699.0,735.0,1.0,1.0,37.0,43,10,34,7,0,2,6,6,0,2,,0,2,6,3,3,block_t
754,8150,aout_FiltersDrain,1,aout_FiltersDrain,block_t aout_FiltersDrain (aout_filters_t*),audio_output\filters.c,"block_t *aout_FiltersDrain (aout_filters_t *filters)
{
    /* Drain the filters pipeline */
    block_t *block = aout_FiltersPipelineDrain (filters->tab, filters->count);

    if (filters->resampler != NULL)
    {
        block_t *chain = NULL;

        filters->resampler->fmt_in.audio.i_rate += filters->resampling;

        if (block)
        {
            /* Resample the drained block from the filters pipeline */
            block = aout_FiltersPipelinePlay (&filters->resampler, 1, block);
            if (block)
                block_ChainAppend (&chain, block);
        }

        /* Drain the resampler filter */
        block = aout_FiltersPipelineDrain (&filters->resampler, 1);
        if (block)
            block_ChainAppend (&chain, block);

        filters->resampler->fmt_in.audio.i_rate -= filters->resampling;

        return chain ? block_ChainGather (chain) : NULL;
    }
    else
        return block;
}",737.0,767.0,1.0,1.0,31.0,27,8,26,4,0,3,5,9,0,3,,0,3,2,1,1,block_t
755,8246,aout_FiltersFlush,1,aout_FiltersFlush,void aout_FiltersFlush (aout_filters_t*),audio_output\filters.c,"void aout_FiltersFlush (aout_filters_t *filters)
{
    aout_FiltersPipelineFlush (filters->tab, filters->count);

    if (filters->resampler != NULL)
        aout_FiltersPipelineFlush (&filters->resampler, 1);
}",769.0,775.0,1.0,1.0,7.0,6,3,5,2,0,2,2,2,0,2,,0,0,2,1,1,void
756,8271,aout_FiltersChangeViewpoint,1,aout_FiltersChangeViewpoint,"void aout_FiltersChangeViewpoint (aout_filters_t*,vlc_viewpoint_t*)",audio_output\filters.c,"void aout_FiltersChangeViewpoint (aout_filters_t *filters,
                                  const vlc_viewpoint_t *vp)
{
    aout_FiltersPipelineChangeViewpoint (filters->tab, filters->count, vp);
}",777.0,781.0,1.0,1.0,5.0,2,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void
757,8320,aout_OutputAssertLocked,1,aout_OutputAssertLocked,void aout_OutputAssertLocked (audio_output_t*),audio_output\output.c,"static void aout_OutputAssertLocked (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_assert_locked (&owner->lock);
}",49.0,54.0,1.0,4.0,6.0,6,4,4,2,4,3,1,1,0,1,,0,3,2,1,1,void
758,8347,var_Copy,1,var_Copy,"int var_Copy (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\output.c,"static int var_Copy (vlc_object_t *src, const char *name, vlc_value_t prev,
                     vlc_value_t value, void *data)
{
    vlc_object_t *dst = data;

    (void) src; (void) prev;
    return var_Set (dst, name, value);
}",58.0,65.0,1.0,1.0,8.0,3,2,7,6,0,1,1,1,0,1,,0,0,10,5,5,int
759,8371,var_CopyDevice,1,var_CopyDevice,"int var_CopyDevice (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\output.c,"static int var_CopyDevice (vlc_object_t *src, const char *name,
                           vlc_value_t prev, vlc_value_t value, void *data)
{
    vlc_object_t *dst = data;

    (void) src; (void) name; (void) prev;
    return var_Set (dst, ""audio-device"", value);
}",67.0,74.0,1.0,1.0,8.0,4,2,7,6,0,1,1,1,0,1,,0,0,10,5,5,int
760,8450,aout_HotplugNotify,1,aout_HotplugNotify,"void aout_HotplugNotify (audio_output_t*,char*,char*)",audio_output\output.c,"static void aout_HotplugNotify (audio_output_t *aout,
                                const char *id, const char *name)
{
    aout_owner_t *owner = aout_owner (aout);
    aout_dev_t *dev, **pp = &owner->dev.list;

    vlc_mutex_lock (&owner->dev.lock);
    while ((dev = *pp) != NULL)
    {
        if (!strcmp (id, dev->id))
            break;
        pp = &dev->next;
    }

    if (name != NULL)
    {
        if (dev == NULL) /* Added device */
        {
            dev = malloc (sizeof (*dev) + strlen (id));
            if (unlikely(dev == NULL))
                goto out;
            dev->next = NULL;
            strcpy (dev->id, id);
            *pp = dev;
            owner->dev.count++;
        }
        else /* Modified device */
            free (dev->name);
        dev->name = strdup (name);
    }
    else
    {
        if (dev != NULL) /* Removed device */
        {
            owner->dev.count--;
            *pp = dev->next;
            free (dev->name);
            free (de...",106.0,148.0,1.0,1.0,43.0,36,11,31,7,0,3,8,10,0,3,,0,1,6,3,3,void
761,8593,aout_RestartNotify,1,aout_RestartNotify,"void aout_RestartNotify (audio_output_t*,unsigned)",audio_output\output.c,"static void aout_RestartNotify (audio_output_t *aout, unsigned mode)
{
    aout_RequestRestart (aout, mode);
}",150.0,153.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
762,8602,aout_GainNotify,1,aout_GainNotify,"int aout_GainNotify (audio_output_t*,float)",audio_output\output.c,"static int aout_GainNotify (audio_output_t *aout, float gain)
{
    aout_owner_t *owner = aout_owner (aout);

    aout_OutputAssertLocked (aout);
    aout_volume_SetVolume (owner->volume, gain);
    /* XXX: ideally, return -1 if format cannot be amplified */
    return 0;
}",155.0,163.0,1.0,1.0,9.0,2,2,5,3,0,4,1,1,0,3,,0,2,4,2,2,int
763,8622,FilterCallback,1,FilterCallback,"int FilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",audio_output\output.c,"static int FilterCallback (vlc_object_t *obj, const char *var,
                           vlc_value_t prev, vlc_value_t cur, void *data)
{
    if (strcmp(prev.psz_string, cur.psz_string))
        aout_InputRequestRestart ((audio_output_t *)obj);
    (void) var; (void) data;
    return VLC_SUCCESS;
}",165.0,172.0,1.0,1.0,8.0,5,2,6,6,0,1,2,2,0,1,,0,0,10,5,5,int
764,8684,ViewpointCallback,1,ViewpointCallback,"int ViewpointCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\vout_intf.c,"static int ViewpointCallback( vlc_object_t *p_this, char const *psz_cmd,
                              vlc_value_t oldval, vlc_value_t newval, void *p_data)
{
    vout_thread_t *p_vout = (vout_thread_t *)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data);

    if( newval.p_address != NULL )
        vout_ControlChangeViewpoint( p_vout, newval.p_address );
    return VLC_SUCCESS;
}",609.0,618.0,1.0,1.0,10.0,7,3,8,7,0,1,2,2,0,1,,0,0,10,5,5,int
765,9538,aout_PrepareStereoMode,1,aout_PrepareStereoMode,"void aout_PrepareStereoMode (audio_output_t*,audio_sample_format_t*,aout_filters_cfg_t*,audio_channel_type_t,unsigned,int)",audio_output\output.c,"static void aout_PrepareStereoMode (audio_output_t *aout,
                                    audio_sample_format_t *restrict fmt,
                                    aout_filters_cfg_t *filters_cfg,
                                    audio_channel_type_t input_chan_type,
                                    unsigned i_nb_input_channels,
                                    int i_forced_stereo_mode)
{
    /* Fill Stereo mode choices */
    var_Change (aout, ""stereo-mode"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    vlc_value_t val, txt, default_val = { .i_int = AOUT_VAR_CHAN_UNSET };
    val.i_int = 0;

    if (!AOUT_FMT_LINEAR(fmt) || i_nb_input_channels == 1)
        return;

    val.i_int = AOUT_VAR_CHAN_MONO;
    txt.psz_string = _(""Mono"");
    var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOICE, &val, &txt);

    if (i_nb_input_channels != 2)
    {
        val.i_int = AOUT_VAR_CHAN_UNSET;
        txt.psz_string = _(""Original"");
        var_Change (aout, ""stereo-mode"", VLC_VAR_ADDCHOIC...",403.0,510.0,1.0,1.0,108.0,99,14,119,31,0,10,18,13,0,10,,0,0,12,6,6,void
766,10158,PauseDefault,1,PauseDefault,"void PauseDefault (audio_output_t*,bool,mtime_t)",audio_output\output.c,"static void PauseDefault (audio_output_t *aout, bool pause, mtime_t date)
{
    if (pause)
        aout_OutputFlush (aout, false);
    (void) date;
}",622.0,627.0,1.0,1.0,6.0,1,1,4,4,0,1,2,2,0,1,,0,0,6,3,3,void
767,10211,aout_OutputVolumeSet,1,aout_OutputVolumeSet,"int aout_OutputVolumeSet (audio_output_t*,float)",audio_output\output.c,"static int aout_OutputVolumeSet (audio_output_t *aout, float vol)
{
    aout_OutputAssertLocked (aout);
    return (aout->volume_set != NULL) ? aout->volume_set (aout, vol) : -1;
}",656.0,660.0,1.0,1.0,5.0,5,4,6,3,0,1,1,1,0,1,,0,0,4,2,2,int
768,10234,aout_OutputMuteSet,1,aout_OutputMuteSet,"int aout_OutputMuteSet (audio_output_t*,bool)",audio_output\output.c,"static int aout_OutputMuteSet (audio_output_t *aout, bool mute)
{
    aout_OutputAssertLocked (aout);
    return (aout->mute_set != NULL) ? aout->mute_set (aout, mute) : -1;
}",662.0,666.0,1.0,1.0,5.0,5,4,6,3,0,1,1,1,0,1,,0,0,4,2,2,int
769,10257,aout_OutputDeviceSet,1,aout_OutputDeviceSet,"int aout_OutputDeviceSet (audio_output_t*,char*)",audio_output\output.c,"static int aout_OutputDeviceSet (audio_output_t *aout, const char *id)
{
    aout_OutputAssertLocked (aout);
    return (aout->device_select != NULL) ? aout->device_select (aout, id) : -1;
}",668.0,672.0,1.0,1.0,5.0,5,4,6,3,0,1,1,1,0,1,,0,0,4,2,2,int
770,10295,aout_OutputTryLock,1,aout_OutputTryLock,int aout_OutputTryLock (audio_output_t*),audio_output\output.c,"static int aout_OutputTryLock (audio_output_t *aout)
{
    aout_owner_t *owner = aout_owner (aout);

    return vlc_mutex_trylock (&owner->lock);
}",681.0,686.0,1.0,1.0,6.0,3,3,3,2,3,3,1,1,0,2,,0,2,2,1,1,int
771,10431,aout_VolumeGet,1,aout_VolumeGet,float aout_VolumeGet (audio_output_t*),audio_output\output.c,"float aout_VolumeGet (audio_output_t *aout)
{
    return var_GetFloat (aout, ""volume"");
}",728.0,731.0,1.0,1.0,4.0,0,0,1,1,3,0,1,1,0,0,,0,0,2,1,1,float
772,10440,aout_VolumeSet,1,aout_VolumeSet,"int aout_VolumeSet (audio_output_t*,float)",audio_output\output.c,"int aout_VolumeSet (audio_output_t *aout, float vol)
{
    aout_owner_t *owner = aout_owner (aout);

    assert (vol >= 0.f);
    vlc_mutex_lock (&owner->req.lock);
    owner->req.volume = vol;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",738.0,750.0,1.0,1.0,13.0,12,6,9,3,2,5,2,2,1,5,,0,2,4,2,2,int
773,10486,aout_VolumeUpdate,1,aout_VolumeUpdate,"int aout_VolumeUpdate (audio_output_t*,int,float*)",audio_output\output.c,"int aout_VolumeUpdate (audio_output_t *aout, int value, float *volp)
{
    int ret = -1;
    float stepSize = var_InheritFloat (aout, ""volume-step"") / (float)AOUT_VOLUME_DEFAULT;
    float delta = value * stepSize;
    float vol = aout_VolumeGet (aout);

    if (vol >= 0.f)
    {
        vol += delta;
        if (vol < 0.f)
            vol = 0.f;
        if (vol > 2.f)
            vol = 2.f;
        vol = (roundf (vol / stepSize)) * stepSize;
        if (volp != NULL)
            *volp = vol;
        ret = aout_VolumeSet (aout, vol);
    }
    return ret;
}",757.0,777.0,1.0,1.0,21.0,21,11,28,9,1,2,5,8,0,2,,0,2,6,3,3,int
774,10567,aout_MuteGet,1,aout_MuteGet,int aout_MuteGet (audio_output_t*),audio_output\output.c,"int aout_MuteGet (audio_output_t *aout)
{
    return var_InheritBool (aout, ""mute"");
}",783.0,786.0,1.0,1.0,4.0,0,0,1,1,1,0,1,1,0,0,,0,0,2,1,1,int
775,10576,aout_MuteSet,1,aout_MuteSet,"int aout_MuteSet (audio_output_t*,bool)",audio_output\output.c,"int aout_MuteSet (audio_output_t *aout, bool mute)
{
    aout_owner_t *owner = aout_owner (aout);

    vlc_mutex_lock (&owner->req.lock);
    owner->req.mute = mute;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",792.0,803.0,1.0,1.0,12.0,11,5,8,3,1,5,2,2,1,5,,0,2,4,2,2,int
776,10627,aout_DeviceSet,1,aout_DeviceSet,"int aout_DeviceSet (audio_output_t*,char*)",audio_output\output.c,"int aout_DeviceSet (audio_output_t *aout, const char *id)
{
    aout_owner_t *owner = aout_owner (aout);

    char *dev = NULL;
    if (id != NULL)
    {
        dev = strdup (id);
        if (unlikely(dev == NULL))
            return -1;
    }

    vlc_mutex_lock (&owner->req.lock);
    if (owner->req.device != unset_str)
        free (owner->req.device);
    owner->req.device = dev;
    vlc_mutex_unlock (&owner->req.lock);

    if (aout_OutputTryLock (aout) == 0)
        aout_OutputUnlock (aout);
    return 0;
}",820.0,841.0,1.0,1.0,22.0,21,7,19,6,0,6,5,6,2,5,,0,3,4,2,2,int
777,10706,aout_DevicesList,1,aout_DevicesList,"int aout_DevicesList (audio_output_t*,char***,char***)",audio_output\output.c,"int aout_DevicesList (audio_output_t *aout, char ***ids, char ***names)
{
    aout_owner_t *owner = aout_owner (aout);
    char **tabid, **tabname;
    unsigned i = 0;

    vlc_mutex_lock (&owner->dev.lock);
    tabid = vlc_alloc (owner->dev.count, sizeof (*tabid));
    tabname = vlc_alloc (owner->dev.count, sizeof (*tabname));

    if (unlikely(tabid == NULL || tabname == NULL))
        goto error;

    *ids = tabid;
    *names = tabname;

    for (aout_dev_t *dev = owner->dev.list; dev != NULL; dev = dev->next)
    {
        tabid[i] = strdup(dev->id);
        if (unlikely(tabid[i] == NULL))
            goto error;

        tabname[i] = strdup(dev->name);
        if (unlikely(tabname[i] == NULL))
        {
            free(tabid[i]);
            goto error;
        }

        i++;
    }
    vlc_mutex_unlock (&owner->dev.lock);

    return i;

error:
    vlc_mutex_unlock(&owner->dev.lock);
    while (i > 0)
    {
        i--;
        free(tabname[i]);
        free(tabid[i]);
    }
...",854.0,900.0,1.0,1.0,47.0,49,14,48,9,0,4,9,8,0,4,,0,1,6,3,3,int
778,11344,IsEscapeNeeded,1,IsEscapeNeeded,bool IsEscapeNeeded (char),config\chain.c,"static bool IsEscapeNeeded( char c )
{
    return c == '\'' || c == '""' || c == '\\';
}",45.0,48.0,1.0,1.0,4.0,5,2,3,1,2,0,1,1,0,0,,0,0,2,1,1,bool
779,11361,IsEscape,1,IsEscape,bool IsEscape (char*),config\chain.c,"static bool IsEscape( const char *psz )
{
    if( !psz )
        return false;
    return psz[0] == '\\' && IsEscapeNeeded( psz[1] );
}",49.0,54.0,1.0,1.0,6.0,5,4,4,2,2,1,2,2,0,1,,0,0,2,1,1,bool
780,11396,ChainGetEnd,1,ChainGetEnd,const char* ChainGetEnd (char*),config\chain.c,"static const char *ChainGetEnd( const char *psz_string )
{
    const char *p = psz_string;
    char c;

    if( !psz_string )
        return NULL;

    /* Look for a opening character */
    SKIPSPACE( p );

    for( ;; p++)
    {
        if( *p == '\0' || *p == ',' || *p == '}' )
            return p;

        if( *p == '{' || *p == '""' || *p == '\'' )
            break;
    }

    /* Set c to the closing character */
    if( *p == '{' )
        c = '}';
    else
        c = *p;
    p++;

    /* Search the closing character, handle nested {..} */
    for( ;; )
    {
        if( *p == '\0')
            return p;

        if( IsEscape( p ) )
            p += 2;
        else if( *p == c )
            return ++p;
        else if( *p == '{' && c == '}' )
            p = ChainGetEnd( p );
        else
            p++;
    }
}",71.0,113.0,1.0,4.0,43.0,27,7,22,4,1,1,10,13,1,1,,0,1,2,1,1,const char*
781,11526,ChainGetValue,1,ChainGetValue,char* ChainGetValue (char**),config\chain.c,"static char *ChainGetValue( const char **ppsz_string )
{
    const char *p = *ppsz_string;

    char *psz_value = NULL;
    const char *end;
    bool b_keep_brackets = (*p == '{');

    if( *p == '=' )
        p++;

    end = ChainGetEnd( p );
    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        /* Skip heading and trailing spaces.
         * This ain't necessary but will avoid simple
         * user mistakes. */
        SKIPSPACE( p );
    }

    if( end <= p )
    {
        psz_value = NULL;
    }
    else
    {
        if( *p == '\'' || *p == '""' || ( !b_keep_brackets && *p == '{' ) )
        {
            p++;

            if( *(end-1) != '\'' && *(end-1) == '""' )
                SKIPTRAILINGSPACE( p, end );

            if( end - 1 <= p )
                psz_value = NULL;
            else
                psz_value = strndup( p, end -1 - p );
        }
        else
        {
            SKIPTRAILINGSPACE( p, end );
            if( end <= p )
          ...",119.0,178.0,1.0,8.0,60.0,16,5,23,6,1,2,5,5,0,2,,0,1,2,1,1,char*
782,11713,config_ChainParseOptions,1,config_ChainParseOptions,"const char* config_ChainParseOptions (config_chain_t**,char*)",config\chain.c,"const char *config_ChainParseOptions( config_chain_t **pp_cfg, const char *psz_opts )
{
    config_chain_t **pp_next = pp_cfg;
    bool first = true;
    do
    {
        if (!first)
            psz_opts++; /* skip previous delimiter */
        SKIPSPACE( psz_opts );

        first = false;

        /* Look for the end of the name (,={}_space_) */
        size_t len = strcspn( psz_opts, ""=,{} \t"" );
        if( len == 0 )
            continue; /* ignore empty parameter */

        /* Append the new parameter */
        config_chain_t *p_cfg = malloc( sizeof(*p_cfg) );
        if( !p_cfg )
            break;
        p_cfg->psz_name = strndup( psz_opts, len );
        psz_opts += len;
        p_cfg->psz_value = NULL;
        p_cfg->p_next = NULL;

        *pp_next = p_cfg;
        pp_next = &p_cfg->p_next;

        /* Extract the option value */
        SKIPSPACE( psz_opts );
        if( strchr( ""={"", *psz_opts ) )
        {
            p_cfg->psz_value = ChainGetValue( &psz_opts );
 ...",181.0,224.0,1.0,8.0,44.0,35,9,46,9,2,1,9,11,0,1,,0,1,4,2,2,const char*
783,11851,config_ChainCreate,1,config_ChainCreate,"char* config_ChainCreate (char**,config_chain_t**,char*)",config\chain.c,"char *config_ChainCreate( char **ppsz_name, config_chain_t **pp_cfg,
                          const char *psz_chain )
{
    size_t len;

    *ppsz_name = NULL;
    *pp_cfg    = NULL;

    if( !psz_chain )
        return NULL;
    SKIPSPACE( psz_chain );

    /* Look for parameter (a {...} or :...) or end of name (space or nul) */
    len = strcspn( psz_chain, ""{: \t"" );
    *ppsz_name = strndup( psz_chain, len );
    psz_chain += len;

    /* Parse the parameters */
    SKIPSPACE( psz_chain );
    if( *psz_chain == '{' )
        psz_chain = config_ChainParseOptions( pp_cfg, psz_chain );

    if( *psz_chain == ':' )
        return strdup( psz_chain + 1 );

    return NULL;
}",226.0,252.0,1.0,4.0,27.0,17,6,26,5,8,1,4,4,0,1,,0,1,6,3,3,char*
784,11927,config_ChainDestroy,1,config_ChainDestroy,void config_ChainDestroy (config_chain_t*),config\chain.c,"void config_ChainDestroy( config_chain_t *p_cfg )
{
    while( p_cfg != NULL )
    {
        config_chain_t *p_next;

        p_next = p_cfg->p_next;

        FREENULL( p_cfg->psz_name );
        FREENULL( p_cfg->psz_value );
        free( p_cfg );

        p_cfg = p_next;
    }
}",254.0,268.0,1.0,1.0,15.0,6,3,9,3,11,0,2,2,0,0,,0,0,2,1,1,void
785,11956,config_ChainParse,1,config_ChainParse,"void config_ChainParse (vlc_object_t*,char*,char**,config_chain_t*)",config\chain.c,"void config_ChainParse( vlc_object_t *p_this, const char *psz_prefix,
                        const char *const *ppsz_options, config_chain_t *cfg )
{
    if( psz_prefix == NULL ) psz_prefix = """";
    size_t plen = 1 + strlen( psz_prefix );

    /* First, var_Create all variables */
    for( size_t i = 0; ppsz_options[i] != NULL; i++ )
    {
        const char *optname = ppsz_options[i];
        if (optname[0] == '*')
            optname++;

        char name[plen + strlen( optname )];
        snprintf( name, sizeof (name), ""%s%s"", psz_prefix, optname );
        if( var_Create( p_this, name,
                        config_GetType( name ) | VLC_VAR_DOINHERIT ) )
            return /* VLC_xxx */;

        module_config_t* p_conf = config_FindConfig( name );
        if( p_conf )
        {
            switch( CONFIG_CLASS( p_conf->i_type ) )
            {
                case CONFIG_ITEM_INTEGER:
                    var_Change( p_this, name, VLC_VAR_SETMINMAX,
                        &(...",271.0,434.0,1.0,20.0,164.0,130,20,148,29,0,10,39,46,2,10,,0,6,8,4,4,void
786,12526,config_StringUnescape,1,config_StringUnescape,char* config_StringUnescape (char*),config\chain.c,"char *config_StringUnescape( char *psz_string )
{
    char *psz_src = psz_string;
    char *psz_dst = psz_string;
    if( !psz_src )
        return NULL;

    while( *psz_src )
    {
        if( IsEscape( psz_src ) )
            psz_src++;
        *psz_dst++ = *psz_src++;
    }
    *psz_dst = '\0';

    return psz_string;
}",456.0,472.0,1.0,1.0,17.0,12,4,13,4,1,1,4,5,1,1,,0,1,2,1,1,char*
787,12568,config_StringEscape,1,config_StringEscape,char* config_StringEscape (char*),config\chain.c,"char *config_StringEscape( const char *str )
{
    size_t length = 0;

    if( str == NULL )
        return NULL;

    for( const char *p = str; *p; p++ )
        length += IsEscapeNeeded( *p ) ? 2 : 1;

    char *ret = malloc( length + 1 ), *dst = ret;

    if( unlikely( !ret ) )
        return NULL;

    for( const char *p = str; *p; p++ )
    {
        if( IsEscapeNeeded( *p ) )
            *dst++ = '\\';
        *dst++ = *p;
    }
    *dst = '\0';;
    return ret;
}",474.0,497.0,1.0,1.0,24.0,20,6,22,6,0,1,6,7,1,1,,0,1,2,1,1,char*
788,12680,config_LoadCmdLine,1,config_LoadCmdLine,"int config_LoadCmdLine (vlc_object_t*,int,char[]*,int*)",config\cmdline.c,"int config_LoadCmdLine( vlc_object_t *p_this, int i_argc,
                        const char *ppsz_argv[], int *pindex )
{
    int i_cmd, i_index, i_opts, i_shortopts, flag, i_verbose = 0;
    struct vlc_option *p_longopts;
    const char **argv_copy = NULL;
#define b_ignore_errors (pindex == NULL)

    /* Short options */
    const module_config_t *pp_shortopts[256];
    char *psz_shortopts;

    /*
     * Generate the longopts and shortopts structures used by getopt_long
     */

    i_opts = 0;
    for (const vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
        /* count the number of exported configuration options (to allocate
         * longopts). We also need to allocate space for two options when
         * dealing with boolean to allow for --foo and --no-foo */
        i_opts += p->conf.count + 2 * p->conf.booleans;

    p_longopts = vlc_alloc( i_opts + 1, sizeof(*p_longopts)  );
    if( p_longopts == NULL )
        return -1;

    psz_shortopts = malloc( 2 * i_opts...",58.0,304.0,1.0,8.0,247.0,166,22,208,38,2,12,40,60,1,12,,0,2,8,4,4,int
789,13461,config_CreateDir,1,config_CreateDir,"int config_CreateDir (vlc_object_t*,char*)",config\file.c,"int config_CreateDir( vlc_object_t *p_this, const char *psz_dirname )
{
    if( !psz_dirname || !*psz_dirname ) return -1;

    if( vlc_mkdir( psz_dirname, 0700 ) == 0 )
        return 0;

    switch( errno )
    {
        case EEXIST:
            return 0;

        case ENOENT:
        {
            /* Let's try to create the parent directory */
            char psz_parent[strlen( psz_dirname ) + 1], *psz_end;
            strcpy( psz_parent, psz_dirname );

            psz_end = strrchr( psz_parent, DIR_SEP_CHAR );
            if( psz_end && psz_end != psz_parent )
            {
                *psz_end = '\0';
                if( config_CreateDir( p_this, psz_parent ) == 0 )
                {
                    if( !vlc_mkdir( psz_dirname, 0700 ) )
                        return 0;
                }
            }
        }
    }

    msg_Warn( p_this, ""could not create %s: %s"", psz_dirname,
              vlc_strerror_c(errno) );
    return -1;
}",266.0,300.0,1.0,1.0,35.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
790,13467,config_AutoSaveConfigFile,1,config_AutoSaveConfigFile,int config_AutoSaveConfigFile (vlc_object_t*),config\file.c,"int config_AutoSaveConfigFile( vlc_object_t *p_this )
{
    int ret = 0;

    assert( p_this );

    vlc_rwlock_rdlock (&config_lock);
    if (config_dirty)
    {
        /* Note: this will get the read lock recursively. Ok. */
        ret = config_SaveConfigFile (p_this);
        config_dirty = (ret != 0);
    }
    vlc_rwlock_unlock (&config_lock);

    return ret;
}",525.0,541.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
791,13472,config_Free,1,config_Free,"void config_Free (module_config_t*,ANY)",config\core.c,"void config_Free (module_config_t *tab, size_t confsize)
{
    for (size_t j = 0; j < confsize; j++)
    {
        module_config_t *p_item = &tab[j];

        if (IsConfigStringType (p_item->i_type))
        {
            free (p_item->value.psz);
            if (p_item->list_count)
                free (p_item->list.psz);
        }

        free (p_item->list_text);
    }

    free (tab);
}",538.0,555.0,1.0,12.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
792,13491,config_PrintHelp,1,config_PrintHelp,bool config_PrintHelp (vlc_object_t*),config\help.c,"bool config_PrintHelp (vlc_object_t *obj)
{
    char *str;

    /* Check for short help option */
    if (var_InheritBool (obj, ""help""))
    {
        Help (obj, ""help"");
        return true;
    }

    /* Check for version option */
    if (var_InheritBool (obj, ""version""))
    {
        Version();
        return true;
    }

    /* Check for help on modules */
    str = var_InheritString (obj, ""module"");
    if (str != NULL)
    {
        Help (obj, str);
        free (str);
        return true;
    }

    /* Check for full help option */
    if (var_InheritBool (obj, ""full-help""))
    {
        var_Create (obj, ""advanced"", VLC_VAR_BOOL);
        var_SetBool (obj, ""advanced"", true);
        var_Create (obj, ""help-verbose"", VLC_VAR_BOOL);
        var_SetBool (obj, ""help-verbose"", true);
        Help (obj, ""full-help"");
        return true;
    }

    /* Check for long help option */
    if (var_InheritBool (obj, ""longhelp""))
    {
        Help (obj, ""longhelp"");
        return true...",95.0,154.0,1.0,1.0,60.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,bool
793,13496,config_SortConfig,1,config_SortConfig,int config_SortConfig (void),config\core.c,"int config_SortConfig (void)
{
    vlc_plugin_t *p;
    size_t nconf = 0;

    for (p = vlc_plugins; p != NULL; p = p->next)
         nconf += p->conf.size;

    module_config_t **clist = vlc_alloc (nconf, sizeof (*clist));
    if (unlikely(clist == NULL))
        return VLC_ENOMEM;

    nconf = 0;
    for (p = vlc_plugins; p != NULL; p = p->next)
    {
        module_config_t *item, *end;

        for (item = p->conf.items, end = item + p->conf.size;
             item < end;
             item++)
        {
            if (!CONFIG_ITEM(item->i_type))
                continue; /* ignore hints */
            clist[nconf++] = item;
        }
    }

    qsort (clist, nconf, sizeof (*clist), confcmp);

    config.list = clist;
    config.count = nconf;
    return VLC_SUCCESS;
}",475.0,507.0,1.0,1.0,33.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
794,13501,config_UnsortConfig,1,config_UnsortConfig,void config_UnsortConfig (void),config\core.c,"void config_UnsortConfig (void)
{
    module_config_t **clist;

    clist = config.list;
    config.list = NULL;
    config.count = 0;

    free (clist);
}",509.0,518.0,1.0,1.0,10.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
795,13546,strdupnull,1,strdupnull,char* strdupnull (char*),config\file.c,"static inline char *strdupnull (const char *src)
{
    return src ? strdup (src) : NULL;
}",51.0,54.0,1.0,1.0,4.0,1,1,3,2,1,0,1,1,0,0,,0,0,2,1,1,char*
796,13557,config_GetType,1,config_GetType,int config_GetType (char*),config\core.c,"int config_GetType(const char *psz_name)
{
    module_config_t *p_config = config_FindConfig(psz_name);

    /* sanity checks */
    if( !p_config )
    {
        return 0;
    }

    switch( CONFIG_CLASS(p_config->i_type) )
    {
        case CONFIG_ITEM_FLOAT:
            return VLC_VAR_FLOAT;
        case CONFIG_ITEM_INTEGER:
            return VLC_VAR_INTEGER;
        case CONFIG_ITEM_BOOL:
            return VLC_VAR_BOOL;
        case CONFIG_ITEM_STRING:
            return VLC_VAR_STRING;
        default:
            return 0;
    }
}",54.0,77.0,1.0,12.0,24.0,6,5,13,10,2,1,3,3,0,1,,0,1,2,1,1,int
797,13623,config_GetInt,1,config_GetInt,"int64_t config_GetInt (vlc_object_t*,char*)",config\core.c,"int64_t config_GetInt( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    int64_t val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.i;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",93.0,112.0,1.0,11.0,20.0,12,8,13,6,2,5,2,2,0,3,,0,3,4,2,2,int64_t
798,13674,config_GetFloat,1,config_GetFloat,"float config_GetFloat (vlc_object_t*,char*)",config\core.c,"float config_GetFloat( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return -1;
    }

    assert(IsConfigFloatType(p_config->i_type));

    float val;

    vlc_rwlock_rdlock (&config_lock);
    val = p_config->value.f;
    vlc_rwlock_unlock (&config_lock);
    return val;
}",121.0,142.0,1.0,11.0,22.0,11,7,13,6,1,5,2,2,0,3,,0,3,4,2,2,float
799,13723,config_GetPsz,1,config_GetPsz,"char* config_GetPsz (vlc_object_t*,char*)",config\core.c,"char * config_GetPsz( vlc_object_t *p_this, const char *psz_name )
{
    module_config_t *p_config;

    p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Err( p_this, ""option %s does not exist"", psz_name );
        return NULL;
    }

    assert(IsConfigStringType (p_config->i_type));

    /* return a copy of the string */
    vlc_rwlock_rdlock (&config_lock);
    char *psz_value = strdupnull (p_config->value.psz);
    vlc_rwlock_unlock (&config_lock);

    return psz_value;
}",156.0,177.0,1.0,11.0,22.0,11,7,14,7,7,6,2,2,0,4,,0,4,4,2,2,char*
800,13774,config_PutPsz,1,config_PutPsz,"void config_PutPsz (vlc_object_t*,char*,char*)",config\core.c,"void config_PutPsz( vlc_object_t *p_this,
                      const char *psz_name, const char *psz_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );


    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigStringType(p_config->i_type));

    char *str, *oldstr;
    if ((psz_value != NULL) && *psz_value)
        str = strdup (psz_value);
    else
        str = NULL;

    vlc_rwlock_wrlock (&config_lock);
    oldstr = (char *)p_config->value.psz;
    p_config->value.psz = str;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);

    free (oldstr);
}",187.0,215.0,1.0,11.0,29.0,20,10,22,11,3,6,3,3,0,3,,0,4,6,3,3,void
801,13854,config_PutInt,1,config_PutInt,"void config_PutInt (vlc_object_t*,char*,int64_t)",config\core.c,"void config_PutInt( vlc_object_t *p_this, const char *psz_name,
                    int64_t i_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigIntegerType(p_config->i_type));

    if (i_value < p_config->min.i)
        i_value = p_config->min.i;
    if (i_value > p_config->max.i)
        i_value = p_config->max.i;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.i = i_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",225.0,248.0,1.0,11.0,24.0,24,9,22,8,0,6,4,4,0,3,,0,4,6,3,3,void
802,13936,config_PutFloat,1,config_PutFloat,"void config_PutFloat (vlc_object_t*,char*,float)",config\core.c,"void config_PutFloat( vlc_object_t *p_this,
                      const char *psz_name, float f_value )
{
    module_config_t *p_config = config_FindConfig( psz_name );

    /* sanity checks */
    if( !p_config )
    {
        msg_Warn( p_this, ""option %s does not exist"", psz_name );
        return;
    }

    assert(IsConfigFloatType(p_config->i_type));

    /* if f_min == f_max == 0, then do not use them */
    if ((p_config->min.f == 0.f) && (p_config->max.f == 0.f))
        ;
    else if (f_value < p_config->min.f)
        f_value = p_config->min.f;
    else if (f_value > p_config->max.f)
        f_value = p_config->max.f;

    vlc_rwlock_wrlock (&config_lock);
    p_config->value.f = f_value;
    config_dirty = true;
    vlc_rwlock_unlock (&config_lock);
}",257.0,283.0,1.0,11.0,27.0,18,7,16,8,0,6,3,3,0,3,,0,4,6,3,3,void
803,14037,config_GetIntChoices,1,config_GetIntChoices,"ssize_t config_GetIntChoices (vlc_object_t*,char*,int64_t**,char***)",config\core.c,"ssize_t config_GetIntChoices (vlc_object_t *obj, const char *name,
                             int64_t **restrict values, char ***restrict texts)
{
    *values = NULL;
    *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        msg_Warn (obj, ""option %s does not exist"", name);
        errno = ENOENT;
        return -1;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.i_cb == NULL)
            return 0;
        return cfg->list.i_cb(obj, name, values, texts);
    }

    int64_t *vals = vlc_alloc (count, sizeof (*vals));
    char **txts = vlc_alloc (count, sizeof (*txts));
    if (vals == NULL || txts == NULL)
    {
        errno = ENOMEM;
        goto error;
    }

    for (size_t i = 0; i < count; i++)
    {
        vals[i] = cfg->list.i[i];
        /* FIXME: use module_gettext() instea...",293.0,352.0,1.0,1.0,60.0,55,14,67,15,1,3,11,14,1,3,,0,3,8,4,4,ssize_t
804,14238,config_ListModules,1,config_ListModules,"ssize_t config_ListModules (char*,char***,char***)",config\core.c,"static ssize_t config_ListModules (const char *cap, char ***restrict values,
                                   char ***restrict texts)
{
    module_t **list;
    ssize_t n = module_list_cap (&list, cap);
    if (unlikely(n < 0))
    {
        *values = *texts = NULL;
        return n;
    }

    char **vals = xmalloc ((n + 2) * sizeof (*vals));
    char **txts = xmalloc ((n + 2) * sizeof (*txts));

    vals[0] = xstrdup (""any"");
    txts[0] = xstrdup (_(""Automatic""));

    for (ssize_t i = 0; i < n; i++)
    {
        vals[i + 1] = xstrdup (module_get_object (list[i]));
        txts[i + 1] = xstrdup (module_gettext (list[i],
                               module_get_name (list[i], true)));
    }

    vals[n + 1] = xstrdup (""none"");
    txts[n + 1] = xstrdup (_(""Disable""));

    *values = vals;
    *texts = txts;
    module_list_free (list);
    return n + 2;
}",355.0,386.0,1.0,1.0,32.0,43,8,40,10,1,5,3,3,0,5,,0,4,6,3,3,ssize_t
805,14373,config_GetPszChoices,1,config_GetPszChoices,"ssize_t config_GetPszChoices (vlc_object_t*,char*,char***,char***)",config\core.c,"ssize_t config_GetPszChoices (vlc_object_t *obj, const char *name,
                              char ***restrict values, char ***restrict texts)
{
    *values = *texts = NULL;

    module_config_t *cfg = config_FindConfig(name);
    if (cfg == NULL)
    {
        errno = ENOENT;
        return -1;
    }

    switch (cfg->i_type)
    {
        case CONFIG_ITEM_MODULE:
            return config_ListModules (cfg->psz_type, values, texts);
        default:
            if (!IsConfigStringType (cfg->i_type))
            {
                errno = EINVAL;
                return -1;
            }
            break;
    }

    size_t count = cfg->list_count;
    if (count == 0)
    {
        if (module_Map(obj, cfg->owner))
        {
            errno = EIO;
            return -1;
        }

        if (cfg->list.psz_cb == NULL)
            return 0;
        return cfg->list.psz_cb(obj, name, values, texts);
    }

    char **vals = xmalloc (sizeof (*vals) * count);
    char **txts = xmalloc...",397.0,450.0,1.0,17.0,54.0,60,14,61,16,1,4,9,11,1,4,,0,3,8,4,4,ssize_t
806,14766,config_FindConfig,1,config_FindConfig,module_config_t config_FindConfig (char*),config\core.c,"module_config_t *config_FindConfig(const char *name)
{
    if (unlikely(name == NULL))
        return NULL;

    module_config_t *const *p;
    p = bsearch (name, config.list, config.count, sizeof (*p), confnamecmp);
    return p ? *p : NULL;
}",523.0,531.0,1.0,1.0,9.0,8,6,11,4,14,2,2,2,0,0,,0,2,2,1,1,module_config_t
807,14862,config_ResetAll,1,config_ResetAll,void config_ResetAll (vlc_object_t*),config\core.c,"void config_ResetAll( vlc_object_t *p_this )
{
    vlc_rwlock_wrlock (&config_lock);
    for (vlc_plugin_t *p = vlc_plugins; p != NULL; p = p->next)
    {
        for (size_t i = 0; i < p->conf.size; i++ )
        {
            module_config_t *p_config = p->conf.items + i;

            if (IsConfigIntegerType (p_config->i_type))
                p_config->value.i = p_config->orig.i;
            else
            if (IsConfigFloatType (p_config->i_type))
                p_config->value.f = p_config->orig.f;
            else
            if (IsConfigStringType (p_config->i_type))
            {
                free ((char *)p_config->value.psz);
                p_config->value.psz =
                        strdupnull (p_config->orig.psz);
            }
        }
    }
    vlc_rwlock_unlock (&config_lock);

    VLC_UNUSED(p_this);
}",561.0,587.0,1.0,16.0,27.0,21,8,18,8,0,4,4,7,0,2,,0,2,2,1,1,void
808,15054,config_GetConfigFile,1,config_GetConfigFile,char* config_GetConfigFile (vlc_object_t*),config\file.c,"static char *config_GetConfigFile( vlc_object_t *obj )
{
    char *psz_file = var_CreateGetNonEmptyString( obj, ""config"" );
    var_Destroy( obj, ""config"" );
    if( psz_file == NULL )
    {
        char *psz_dir = config_GetUserDir( VLC_CONFIG_DIR );

        if( asprintf( &psz_file, ""%s"" DIR_SEP CONFIG_FILE, psz_dir ) == -1 )
            psz_file = NULL;
        free( psz_dir );
    }
    return psz_file;
}",59.0,72.0,1.0,46.0,14.0,4,2,11,5,2,1,3,4,0,1,,0,1,2,1,1,char*
809,15088,config_OpenConfigFile,1,config_OpenConfigFile,FILE config_OpenConfigFile (vlc_object_t*),config\file.c,"static FILE *config_OpenConfigFile( vlc_object_t *p_obj )
{
    char *psz_filename = config_GetConfigFile( p_obj );
    if( psz_filename == NULL )
        return NULL;

    msg_Dbg( p_obj, ""opening config file (%s)"", psz_filename );

    FILE *p_stream = vlc_fopen( psz_filename, ""rt"" );
    if( p_stream == NULL && errno != ENOENT )
    {
        msg_Err( p_obj, ""cannot open config file (%s): %s"",
                 psz_filename, vlc_strerror_c(errno) );

    }
#if !( defined(_WIN32) || defined(__APPLE__) || defined(__OS2__) )
    else if( p_stream == NULL && errno == ENOENT )
    {
        /* This is the fallback for pre XDG Base Directory
         * Specification configs */
        char *home = config_GetUserDir(VLC_HOME_DIR);
        char *psz_old;

        if( home != NULL
         && asprintf( &psz_old, ""%s/.vlc/"" CONFIG_FILE,
                      home ) != -1 )
        {
            p_stream = vlc_fopen( psz_old, ""rt"" );
            if( p_stream )
            {
                /...",74.0,138.0,1.0,43.0,65.0,6,4,18,6,0,3,3,3,0,3,,0,2,2,1,1,FILE
810,15578,config_Write,1,config_Write,"int config_Write (FILE*,char*,char*,bool,char*,char*...)",config\file.c,"static int
config_Write (FILE *file, const char *desc, const char *type,
              bool comment, const char *name, const char *fmt, ...)
{
    va_list ap;
    int ret;

    if (desc == NULL)
        desc = ""?"";

    if (fprintf (file, ""# %s (%s)\n%s%s="", desc, vlc_gettext (type),
                 comment ? ""#"" : """", name) < 0)
        return -1;

    va_start (ap, fmt);
    ret = vfprintf (file, fmt, ap);
    va_end (ap);
    if (ret < 0)
        return -1;

    if (fputs (""\n\n"", file) == EOF)
        return -1;
    return 0;
}",302.0,325.0,1.0,1.0,24.0,10,5,18,10,0,1,5,5,1,1,,0,1,12,6,6,int
811,15647,config_PrepareDir,1,config_PrepareDir,int config_PrepareDir (vlc_object_t*),config\file.c,"static int config_PrepareDir (vlc_object_t *obj)
{
    char *psz_configdir = config_GetUserDir (VLC_CONFIG_DIR);
    if (psz_configdir == NULL)
        return -1;

    int ret = config_CreateDir (obj, psz_configdir);
    free (psz_configdir);
    return ret;
}",328.0,337.0,1.0,1.0,10.0,4,3,9,5,1,2,2,2,0,2,,0,2,2,1,1,int
812,15675,config_SaveConfigFile,1,config_SaveConfigFile,int config_SaveConfigFile (vlc_object_t*),config\file.c,"int config_SaveConfigFile (vlc_object_t *p_this)
{

    if( config_PrepareDir( p_this ) )
    {
        msg_Err( p_this, ""no configuration directory"" );
        return -1;
    }

    /*
     * Save module config in file
     */
    char *temporary;
    char *permanent = config_GetConfigFile (p_this);
    if (permanent == NULL)
        return -1;
    if (asprintf (&temporary, ""%s.%u"", permanent, getpid ()) == -1)
    {
        free (permanent);
        return -1;
    }
    else
    {
        struct stat st;

        /* Some users make vlcrc read-only to prevent changes.
         * The atomic replacement scheme breaks this ""feature"",
         * so we check for read-only by hand. */
        if (stat (permanent, &st) == 0 && !(st.st_mode & S_IWUSR))
        {
            msg_Err (p_this, ""configuration file is read-only"");
            goto error;
        }
    }

    /* Configuration lock must be taken before vlcrc serializer below. */
    vlc_rwlock_rdlock (&config_lock);

    /* The t...",344.0,523.0,1.0,16.0,180.0,62,15,84,25,1,20,20,22,3,18,,0,6,2,1,1,int
813,16142,exchange,1,exchange,"void exchange (char**,vlc_getopt_t*)",config\getopt.c,"static void exchange(char **argv, vlc_getopt_t *restrict state)
{
    int bottom = state->first_nonopt;
    int middle = state->last_nonopt;
    int top = state->ind;
    char *tem;

    /* Exchange the shorter segment with the far end of the longer segment.
       That puts the shorter segment into the right place.
       It leaves the longer segment in the right place overall,
       but it consists of two parts that need to be swapped next.  */

    while (top > middle && middle > bottom)
    {
        if (top - middle > middle - bottom)
        {
            /* Bottom segment is the short one.  */
            int len = middle - bottom;
            register int i;

            /* Swap it with the top part of the top segment.  */
            for (i = 0; i < len; i++)
            {
                tem = argv[bottom + i];
                argv[bottom + i] = argv[top - (middle - bottom) + i];
                argv[top - (middle - bottom) + i] = tem;
            }
            /* Exclude...",41.0,93.0,1.0,1.0,53.0,40,10,45,8,2,0,4,7,0,0,,0,0,4,2,2,void
814,16305,vlc_getopt_long,1,vlc_getopt_long,"int vlc_getopt_long (int,char**,char*,vlc_option*,int*,vlc_getopt_t*)",config\getopt.c,"int vlc_getopt_long(int argc, char *const *argv,
                    const char *optstring,
                    const struct vlc_option *restrict longopts, int *longind,
                    vlc_getopt_t *restrict state)
{
    state->arg = NULL;

    if (state->ind == 0)
    {
        /* Initialize the internal data when the first call is made.  */
        /* Start processing options with ARGV-element 1 (since ARGV-element 0
           is the program name); the sequence of previously skipped
           non-option ARGV-elements is empty.  */
        state->first_nonopt = state->last_nonopt = state->ind = 1;
        state->nextchar = NULL;
    }

#define NONOPTION_P (argv[state->ind][0] != '-' || argv[state->ind][1] == '\0')

    if (state->nextchar == NULL || *state->nextchar == '\0')
    {
        /* Advance to the next ARGV-element.  */

        /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
           moved back by the user (who may also have changed the argu...",146.0,479.0,1.0,36.0,334.0,246,18,174,16,1,14,35,74,6,2,,0,12,12,6,6,int
815,17434,ConsoleWidth,1,ConsoleWidth,unsigned ConsoleWidth (void),config\help.c,"static unsigned ConsoleWidth(void)
{
#ifdef TIOCGWINSZ
    struct winsize ws;

    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0)
        return ws.ws_col;
#endif
#ifdef WIOCGETD
    struct uwdata uw;

    if (ioctl(STDOUT_FILENO, WIOCGETD, &uw) == 0)
        return uw.uw_height / uw.uw_vs;
#endif
#if defined (_WIN32) && !VLC_WINSTORE_APP
    CONSOLE_SCREEN_BUFFER_INFO buf;

    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &buf))
        return buf.dwSize.X;
#endif
    return 80;
}",66.0,87.0,1.0,1.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,unsigned
816,17630,print_section,1,print_section,"void print_section (module_t*,module_config_t**,bool,bool)",config\help.c,"static void print_section(const module_t *m, const module_config_t **sect,
                          bool color, bool desc)
{
    const module_config_t *item = *sect;

    if (item == NULL)
        return;
    *sect = NULL;

    printf(color ? RED""   %s:\n""GRAY : ""   %s:\n"",
           module_gettext(m, item->psz_text));
    if (desc && item->psz_longtext != NULL)
        printf(color ? MAGENTA""   %s\n""GRAY : ""   %s\n"",
               module_gettext(m, item->psz_longtext));
}",247.0,261.0,1.0,19.0,15.0,12,7,15,6,1,2,3,3,0,2,,0,0,8,4,4,void
817,17686,print_desc,1,print_desc,"void print_desc (char*,unsigned,bool)",config\help.c,"static void print_desc(const char *str, unsigned margin, bool color)
{
    unsigned width = ConsoleWidth() - margin;

    if (color)
        fputs(BLUE, stdout);

    const char *word = str;
    int wordlen = 0, wordwidth = 0;
    unsigned offset = 0;
    bool newline = true;

    while (str[0])
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);
        if (unlikely(charlen == (size_t)-1))
            break;

        int charwidth = wcwidth(cp);
        if (charwidth < 0)
            charwidth = 0;

        str += charlen;

        if (iswspace(cp))
        {
            if (!newline)
            {
                putchar(' '); /* insert space */
                charwidth = 1;
            }
            fwrite(word, 1, wordlen, stdout); /* write complete word */
            word = str;
            wordlen = 0;
            wordwidth = 0;
            newline = false;
        }
        else
        {
            wordlen += charlen;
            wordwidth += charwidth...",263.0,326.0,1.0,14.0,64.0,33,10,59,16,3,2,11,18,0,2,,0,2,6,3,3,void
818,17854,vlc_swidth,1,vlc_swidth,int vlc_swidth (char*),config\help.c,"static int vlc_swidth(const char *str)
{
    for (int total = 0;;)
    {
        uint32_t cp;
        size_t charlen = vlc_towc(str, &cp);

        if (charlen == 0)
            return total;
        if (charlen == (size_t)-1)
            return -1;
        str += charlen;

        int w = wcwidth(cp);
        if (w == -1)
            return -1;
        total += w;
    }
}",328.0,346.0,1.0,1.0,19.0,13,6,15,6,2,1,5,8,0,1,,0,1,2,1,1,int
819,17911,print_item,1,print_item,"void print_item (vlc_object_t*,module_t*,module_config_t*,module_config_t**,bool,bool)",config\help.c,"static void print_item(const vlc_object_t *p_this, const module_t *m, const module_config_t *item,
                       const module_config_t **section, bool color, bool desc)
{
#ifndef _WIN32
# define OPTION_VALUE_SEP "" ""
#else
# define OPTION_VALUE_SEP ""=""
#endif
    const char *bra = OPTION_VALUE_SEP ""<"", *type, *ket = "">"";
    const char *prefix = NULL, *suffix = NULL;
    char *typebuf = NULL;

    switch (CONFIG_CLASS(item->i_type))
    {
        case 0: // hint class
            switch (item->i_type)
            {
                case CONFIG_HINT_CATEGORY:
                case CONFIG_HINT_USAGE:
                    printf(color ? GREEN ""\n %s\n"" GRAY : ""\n %s\n"",
                           module_gettext(m, item->psz_text));

                    if (desc && item->psz_longtext != NULL)
                        printf(color ? CYAN "" %s\n"" GRAY : "" %s\n"",
                               module_gettext(m, item->psz_longtext));
                    break;

                case CONF...",348.0,544.0,1.0,22.0,197.0,132,20,160,30,0,12,32,54,0,12,,0,5,12,6,6,void
820,18586,module_match,1,module_match,"bool module_match (module_t*,char*,bool)",config\help.c,"static bool module_match(const module_t *m, const char *pattern, bool strict)
{
    if (pattern == NULL)
        return true;

    const char *objname = module_get_object(m);

    if (strict ? (strcmp(objname, pattern) == 0)
               : (strstr(objname, pattern) != NULL))
        return true;

    for (unsigned i = 0; i < m->i_shortcuts; i++)
    {
        const char *shortcut = m->pp_shortcuts[i];

        if (strict ? (strcmp(shortcut, pattern) == 0)
                   : (strstr(shortcut, pattern) != NULL))
            return true;
    }
    return false;
}",546.0,566.0,1.0,1.0,21.0,14,7,26,9,0,3,5,6,1,1,,0,3,6,3,3,bool
821,18661,plugin_show,1,plugin_show,"bool plugin_show (vlc_plugin_t*,bool)",config\help.c,"static bool plugin_show(const vlc_plugin_t *plugin, bool advanced)
{
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        const module_config_t *item = plugin->conf.items + i;

        if (!CONFIG_ITEM(item->i_type))
            continue;
        if (item->b_removed)
            continue;
        if ((!advanced) && item->b_advanced)
            continue;
        return true;
    }
    return false;
}",568.0,583.0,1.0,1.0,16.0,14,7,12,6,0,2,8,8,1,0,,0,2,4,2,2,bool
822,19147,config_AddIntf,1,config_AddIntf,"void config_AddIntf (vlc_object_t*,char*)",config\intf.c,"void config_AddIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            free( psz_config );
            return;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }

    /* interface not found in the config, let's add it */
    if( psz_con...",34.0,82.0,1.0,1.0,49.0,19,10,39,7,0,3,9,14,0,3,,0,2,4,2,2,void
823,19267,config_RemoveIntf,1,config_RemoveIntf,"void config_RemoveIntf (vlc_object_t*,char*)",config\intf.c,"void config_RemoveIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_intf, psz_parser, i_len ) )
        {
            char *psz_newconfig;
            char *psz_end = psz_parser + i_len;
            if( *psz_end == ':' ) psz_end++;
            *psz_parser = '\0';
            if( asprintf( &psz_newconfig, ""%s%s"", psz_config, psz_end ) != -1 )
            {
                config_PutPsz( libvlc, ""extraintf"", psz_newconfig );
                free( psz_newconfig );
            }
            break;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" )...",86.0,136.0,1.0,1.0,51.0,34,11,53,8,0,4,13,23,0,4,,0,2,4,2,2,void
824,19423,config_ExistIntf,1,config_ExistIntf,"bool config_ExistIntf (vlc_object_t*,char*)",config\intf.c,"bool config_ExistIntf( vlc_object_t *p_this, const char *psz_intf )
{
    vlc_object_t *libvlc = VLC_OBJECT(p_this->obj.libvlc);

    assert( psz_intf );

    char *psz_config, *psz_parser;
    size_t i_len = strlen( psz_intf );

    psz_config = psz_parser = config_GetPsz( libvlc, ""extraintf"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    psz_config = psz_parser = config_GetPsz( libvlc, ""control"" );
    while( psz_parser )
    {
        if( !strncmp( psz_parser, psz_intf, i_len ) )
        {
            free( psz_config );
            return true;
        }
        psz_parser = strchr( psz_parser, ':' );
        if( psz_parser ) psz_parser++; /* skip the ':' */
    }
    free( psz_config );

    return false;
}",143.0,179.0,1.0,1.0,37.0,14,5,34,8,0,2,7,11,0,2,,0,2,4,2,2,bool
825,19562,config_GetLibDir,1,config_GetLibDir,char* config_GetLibDir (void),win32\dirs.c,"char *config_GetLibDir (void)
{
#if VLC_WINSTORE_APP
    return NULL;
#else
    /* Get our full path */
    MEMORY_BASIC_INFORMATION mbi;
    if (!VirtualQuery (config_GetLibDir, &mbi, sizeof(mbi)))
        goto error;

    wchar_t wpath[MAX_PATH];
    if (!GetModuleFileName ((HMODULE) mbi.AllocationBase, wpath, MAX_PATH))
        goto error;

    wchar_t *file = wcsrchr (wpath, L'\\');
    if (file == NULL)
        goto error;
    *file = L'\0';

    return FromWide (wpath);
error:
    abort ();
#endif
}",184.0,207.0,1.0,1.0,24.0,34,12,39,9,1,0,9,16,0,0,,0,0,2,1,1,char*
826,19717,config_GetDataDir,1,config_GetDataDir,char* config_GetDataDir (void),win32\dirs.c,"char *config_GetDataDir (void)
{
    const char *path = getenv (""VLC_DATA_PATH"");
    return (path != NULL) ? strdup (path) : config_GetLibDir ();
}",209.0,213.0,1.0,1.0,5.0,6,4,10,4,1,1,3,3,0,1,,0,1,2,1,1,char*
827,19776,getAppDependentDir,1,getAppDependentDir,char* getAppDependentDir (vlc_userdir_t),darwin\dirs.c,"static char *getAppDependentDir(vlc_userdir_t type)
{
    const char *psz_path;
    switch (type) {
        case VLC_CONFIG_DIR:
            psz_path = ""%s/Library/Preferences/%s"";
            break;
        case VLC_TEMPLATES_DIR:
        case VLC_DATA_DIR:
            psz_path = ""%s/Library/Application Support/%s"";
            break;
        case VLC_CACHE_DIR:
            psz_path = ""%s/Library/Caches/%s"";
            break;
        default:
            vlc_assert_unreachable();
            break;
    }

    // Default fallback
    const char *fallback = ""org.videolan.vlc"";
    char *name = NULL;

    CFBundleRef mainBundle = CFBundleGetMainBundle();
    if (mainBundle) {
        CFStringRef identifierAsNS = CFBundleGetIdentifier(mainBundle);
        if (identifierAsNS) {
            CFIndex len = CFStringGetLength(identifierAsNS);
            CFIndex size = CFStringGetMaximumSizeForEncoding(len, kCFStringEncodingUTF8);
            char *identifier = calloc(len + 1, sizeof(char))...",121.0,169.0,1.0,1.0,49.0,21,8,46,19,0,1,11,13,0,1,,0,1,2,1,1,char*
828,20212,vlc_clock_setup_once,1,vlc_clock_setup_once,void vlc_clock_setup_once (void),darwin\thread.c,"static void vlc_clock_setup_once (void)
{
    if (unlikely(mach_timebase_info (&vlc_clock_conversion_factor) != 0))
        abort ();
}",47.0,51.0,1.0,1.0,5.0,2,2,1,1,0,1,2,2,1,0,,0,1,2,1,1,void
829,20230,mtime_to_ts,1,mtime_to_ts,struct timespec mtime_to_ts (mtime_t),posix\thread.c,"static struct timespec mtime_to_ts (mtime_t date)
{
    lldiv_t d = lldiv (date, CLOCK_FREQ);
    struct timespec ts = { d.quot, d.rem * (1000000000 / CLOCK_FREQ) };

    return ts;
}",110.0,116.0,1.0,1.0,7.0,7,5,8,4,3,0,1,1,0,0,,0,0,2,1,1,struct timespec
830,20257,vlc_trace,1,vlc_trace,"void vlc_trace (char*,char*,unsigned)",posix\thread.c,"void vlc_trace (const char *fn, const char *file, unsigned line)
{
     fprintf (stderr, ""at %s:%u in %s\n"", file, line, fn);
     fflush (stderr); /* needed before switch to low-level I/O */
#ifdef HAVE_BACKTRACE
     void *stack[20];
     int len = backtrace (stack, sizeof (stack) / sizeof (stack[0]));
     backtrace_symbols_fd (stack, len, 2);
#endif
     fsync (2);
}",121.0,131.0,1.0,1.0,11.0,5,4,11,6,1,0,1,1,0,0,,0,0,6,3,3,void
831,20291,vlc_thread_fatal,1,vlc_thread_fatal,"void vlc_thread_fatal (char*,int,char*,char*,unsigned)",posix\thread.c,"static void
vlc_thread_fatal (const char *action, int error,
                  const char *function, const char *file, unsigned line)
{
    int canc = vlc_savecancel ();
    fprintf (stderr, ""LibVLC fatal error %s (%d) in thread %lu "",
             action, error, vlc_thread_id ());
    vlc_trace (function, file, line);
    perror (""Thread error"");
    fflush (stderr);

    vlc_restorecancel (canc);
    abort ();
}",137.0,150.0,1.0,1.0,14.0,5,2,19,10,12,4,5,2,0,4,,0,1,10,5,5,void
832,20506,vlc_cond_init,1,vlc_cond_init,void vlc_cond_init (vlc_cond_t*),posix\thread.c,"void vlc_cond_init (vlc_cond_t *p_condvar)
{
    pthread_condattr_t attr;

    if (unlikely(pthread_condattr_init (&attr)))
        abort ();
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    pthread_condattr_setclock (&attr, vlc_clock_id);
#endif
    if (unlikely(pthread_cond_init (p_condvar, &attr)))
        abort ();
    pthread_condattr_destroy (&attr);
}",232.0,245.0,1.0,5.0,14.0,0,0,2,2,20,0,2,2,0,0,,0,0,2,1,1,void
833,20518,vlc_cond_init_daytime,1,vlc_cond_init_daytime,void vlc_cond_init_daytime (vlc_cond_t*),posix\thread.c,"void vlc_cond_init_daytime (vlc_cond_t *p_condvar)
{
    if (unlikely(pthread_cond_init (p_condvar, NULL)))
        abort ();
}",247.0,251.0,1.0,1.0,5.0,0,0,2,2,1,0,2,2,0,0,,0,0,2,1,1,void
834,20530,vlc_cond_destroy,1,vlc_cond_destroy,void vlc_cond_destroy (vlc_cond_t*),posix\thread.c,"void vlc_cond_destroy (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_destroy( p_condvar );
    VLC_THREAD_ASSERT (""destroying condition"");
}",253.0,257.0,1.0,4.0,5.0,3,3,9,4,27,1,3,4,0,1,,0,0,2,1,1,void
835,20566,vlc_cond_signal,1,vlc_cond_signal,void vlc_cond_signal (vlc_cond_t*),posix\thread.c,"void vlc_cond_signal (vlc_cond_t *p_condvar)
{
    int val = pthread_cond_signal( p_condvar );
    VLC_THREAD_ASSERT (""signaling condition variable"");
}",259.0,263.0,1.0,4.0,5.0,1,1,5,3,39,1,1,1,0,1,,0,0,2,1,1,void
836,20588,vlc_cond_broadcast,1,vlc_cond_broadcast,void vlc_cond_broadcast (vlc_cond_t*),posix\thread.c,"void vlc_cond_broadcast (vlc_cond_t *p_condvar)
{
    pthread_cond_broadcast (p_condvar);
}",265.0,268.0,1.0,1.0,4.0,0,0,1,1,8,0,1,1,0,0,,0,0,2,1,1,void
837,20595,vlc_cond_wait,1,vlc_cond_wait,"void vlc_cond_wait (vlc_cond_t*,vlc_mutex_t*)",posix\thread.c,"void vlc_cond_wait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex)
{
    int val = pthread_cond_wait( p_condvar, p_mutex );
    VLC_THREAD_ASSERT (""waiting on condition"");
}",270.0,274.0,1.0,4.0,5.0,1,1,6,4,9,1,1,1,0,1,,0,0,4,2,2,void
838,20619,vlc_cond_timedwait,1,vlc_cond_timedwait,"int vlc_cond_timedwait (vlc_cond_t*,vlc_mutex_t*,mtime_t)",posix\thread.c,"int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                        mtime_t deadline)
{
    struct timespec ts = mtime_to_ts (deadline);
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",276.0,284.0,1.0,8.0,9.0,8,5,17,8,7,3,3,3,0,3,,0,2,6,3,3,int
839,20674,vlc_cond_timedwait_daytime,1,vlc_cond_timedwait_daytime,"int vlc_cond_timedwait_daytime (vlc_cond_t*,vlc_mutex_t*,time_t)",posix\thread.c,"int vlc_cond_timedwait_daytime (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                time_t deadline)
{
    struct timespec ts = { deadline, 0 };
    int val = pthread_cond_timedwait (p_condvar, p_mutex, &ts);
    if (val != ETIMEDOUT)
        VLC_THREAD_ASSERT (""timed-waiting on condition"");
    return val;
}",286.0,294.0,1.0,8.0,9.0,4,3,12,7,0,2,2,2,0,2,,0,1,6,3,3,int
840,20714,vlc_sem_init,1,vlc_sem_init,"void vlc_sem_init (vlc_sem_t*,unsigned)",posix\thread.c,"void vlc_sem_init (vlc_sem_t *sem, unsigned value)
{
    if (unlikely(sem_init (sem, 0, value)))
        abort ();
}",296.0,300.0,1.0,1.0,5.0,1,1,4,4,4,0,2,2,0,0,,0,0,4,2,2,void
841,20731,vlc_sem_destroy,1,vlc_sem_destroy,void vlc_sem_destroy (vlc_sem_t*),posix\thread.c,"void vlc_sem_destroy (vlc_sem_t *sem)
{
    int val;

    if (likely(sem_destroy (sem) == 0))
        return;

    val = errno;

    VLC_THREAD_ASSERT (""destroying semaphore"");
}",302.0,312.0,1.0,4.0,11.0,3,3,7,5,7,1,2,2,0,1,,0,0,2,1,1,void
842,20762,vlc_sem_post,1,vlc_sem_post,int vlc_sem_post (vlc_sem_t*),posix\thread.c,"int vlc_sem_post (vlc_sem_t *sem)
{
    int val;

    if (likely(sem_post (sem) == 0))
        return 0;

    val = errno;

    if (unlikely(val != EOVERFLOW))
        VLC_THREAD_ASSERT (""unlocking semaphore"");
    return val;
}",314.0,326.0,1.0,8.0,13.0,4,4,10,6,8,1,3,3,0,1,,0,0,2,1,1,int
843,20801,vlc_sem_wait,1,vlc_sem_wait,void vlc_sem_wait (vlc_sem_t*),posix\thread.c,"void vlc_sem_wait (vlc_sem_t *sem)
{
    int val;

    do
        if (likely(sem_wait (sem) == 0))
            return;
    while ((val = errno) == EINTR);

    VLC_THREAD_ASSERT (""locking semaphore"");
}",328.0,338.0,1.0,4.0,11.0,3,3,7,5,6,1,2,2,0,1,,0,0,2,1,1,void
844,20843,vlc_rwlock_destroy,1,vlc_rwlock_destroy,void vlc_rwlock_destroy (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_destroy (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_destroy (lock);
    VLC_THREAD_ASSERT (""destroying R/W lock"");
}",346.0,350.0,1.0,4.0,5.0,1,1,5,3,0,1,1,1,0,1,,0,0,2,1,1,void
845,20865,vlc_rwlock_rdlock,1,vlc_rwlock_rdlock,void vlc_rwlock_rdlock (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_rdlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_rdlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for reading"");
}",352.0,356.0,1.0,4.0,5.0,1,1,5,3,5,1,1,1,0,1,,0,0,2,1,1,void
846,20887,vlc_rwlock_wrlock,1,vlc_rwlock_wrlock,void vlc_rwlock_wrlock (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_wrlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_wrlock (lock);
    VLC_THREAD_ASSERT (""acquiring R/W lock for writing"");
}",358.0,362.0,1.0,4.0,5.0,1,1,5,3,5,1,1,1,0,1,,0,0,2,1,1,void
847,20909,vlc_rwlock_unlock,1,vlc_rwlock_unlock,void vlc_rwlock_unlock (vlc_rwlock_t*),posix\thread.c,"void vlc_rwlock_unlock (vlc_rwlock_t *lock)
{
    int val = pthread_rwlock_unlock (lock);
    VLC_THREAD_ASSERT (""releasing R/W lock"");
}",364.0,368.0,1.0,4.0,5.0,1,1,5,3,12,1,1,1,0,1,,0,0,2,1,1,void
848,21137,vlc_thread_id,1,vlc_thread_id,unsigned long vlc_thread_id (void),win32\thread.c,"unsigned long vlc_thread_id (void)
{
    return GetCurrentThreadId ();
}",571.0,574.0,1.0,1.0,4.0,1,1,0,0,3,0,1,1,0,0,,0,0,2,1,1,unsigned long
849,21295,mwait,1,mwait,void mwait (mtime_t),posix\thread.c,"void mwait (mtime_t deadline)
{
#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    /* If the deadline is already elapsed, or within the clock precision,
     * do not even bother the system timer. */
    deadline -= vlc_clock_prec;

    struct timespec ts = mtime_to_ts (deadline);

    while (clock_nanosleep (vlc_clock_id, TIMER_ABSTIME, &ts, NULL) == EINTR);

#else
    deadline -= mdate ();
    if (deadline > 0)
        msleep (deadline);

#endif
}",648.0,666.0,1.0,5.0,19.0,2,2,3,1,2,2,2,2,0,2,,0,0,2,1,1,void
850,21310,msleep,1,msleep,void msleep (mtime_t),posix\thread.c,"void msleep (mtime_t delay)
{
    struct timespec ts = mtime_to_ts (delay);

#if (_POSIX_CLOCK_SELECTION > 0)
    vlc_clock_setup ();
    while (clock_nanosleep (vlc_clock_id, 0, &ts, &ts) == EINTR);

#else
    while (nanosleep (&ts, &ts) == -1)
        assert (errno == EINTR);

#endif
}",669.0,682.0,1.0,5.0,14.0,5,4,4,2,2,1,2,2,0,1,,0,1,2,1,1,void
851,22731,ISO6937toUTF8,1,ISO6937toUTF8,"size_t ISO6937toUTF8 (char**,size_t*,unsigned char**,size_t*,uint16_t*)",extras\libc.c,"static size_t ISO6937toUTF8( const char **inbuf, size_t *inbytesleft,
                             unsigned char **outbuf, size_t *outbytesleft,
                             const uint16_t *ucs4_table )


{
    if( !inbuf || !(*inbuf) )
        return (size_t)(0);    /* Reset state requested */

    const char *iptr = *inbuf;
    const char *iend = iptr + *inbytesleft;
    unsigned char *optr = *outbuf;
    unsigned char *oend = optr + *outbytesleft;
    int err = 0;

    while ( iptr < iend )
    {
        unsigned char c1 = *iptr;
        uint_fast16_t ch = ucs4_table[c1];

        if( c1 >= 0xc1 && c1 <= 0xcf )
        {
            /* Composed character */
            if ( iptr + 1 >= iend )
            {
                err = EINVAL;
                break;    /* No next character */
            }

            unsigned char c2 = iptr[1];
            if ( c2 < 0x40 || c2 >= 0x80 ||
                 !(ch = to_ucs4_comb[c1 - 0xc1][c2 - 0x40]) )
            {
                err = E...",292.0,391.0,1.0,1.0,100.0,58,14,57,18,1,1,12,17,1,0,,0,1,10,5,5,size_t
852,22999,vlc_iconv_open,1,vlc_iconv_open,"vlc_iconv_t vlc_iconv_open (char*,char*)",extras\libc.c,"vlc_iconv_t vlc_iconv_open( const char *tocode, const char *fromcode )
{
#ifndef __linux__
    if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937"") )
        return (vlc_iconv_t)(-2);
    else if( !strcasecmp(tocode, ""UTF-8"") && !strcasecmp(fromcode, ""ISO_6937-2"") )
        return (vlc_iconv_t)(-3);
#endif
#if defined(HAVE_ICONV)
# if defined(__OS2__) && defined(__INNOTEK_LIBC__)
    char tocode_ucs2[] = ""UCS-2LE"";
    char fromcode_ucs2[] = ""UCS-2LE"";
    os2_iconv_t *p_os2_iconv;

    /* Workaround for UTF-16 because OS/2 supports UCS-2 only not UTF-16 */
    if( !strncmp( tocode, ""UTF-16"", 6 ))
    {
        strncpy( tocode_ucs2 + 5, tocode + 6, 2 );
        tocode = tocode_ucs2;
    }

    if( !strncmp( fromcode, ""UTF-16"", 6 ))
    {
        strncpy( fromcode_ucs2 + 5, fromcode + 6, 2 );
        fromcode = fromcode_ucs2;
    }

    p_os2_iconv = ( os2_iconv_t * )iconv_open( tocode, fromcode );

    if( p_os2_iconv != ( iconv_t )(-1))
    {
        /* Mimic a beh...",397.0,445.0,1.0,1.0,49.0,5,3,2,2,3,0,2,2,0,0,,0,0,4,2,2,vlc_iconv_t
853,23041,vlc_iconv,1,vlc_iconv,"size_t vlc_iconv (vlc_iconv_t,char**,size_t*,char**,size_t*)",extras\libc.c,"size_t vlc_iconv( vlc_iconv_t cd, const char **inbuf, size_t *inbytesleft,
                  char **outbuf, size_t *outbytesleft )
{
    size_t ret;

#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
    {
        unsigned char *out = NULL;
        if (outbuf != NULL)
            out = (unsigned char *)*outbuf;

        const uint16_t *ucs4_table = ( cd == (vlc_iconv_t)(-2) ? ISO6937toUCS4 : ISO6937_2toUCS4 );

        ret = ISO6937toUTF8( inbuf, inbytesleft, &out, outbytesleft, ucs4_table );
        if (outbuf != NULL)
            *outbuf = (char *)out;
    }
    else
#endif
#if defined(HAVE_ICONV)
    {
        ICONV_CONST char *cin = NULL;
        if (inbuf != NULL)
            cin = (ICONV_CONST char *)*inbuf;

        ret = iconv( cd, &cin, inbytesleft, outbuf, outbytesleft );
        if (inbuf != NULL)
            *inbuf = cin;
    }
#else
        abort ();
#endif
    return ret;
}",447.0,481.0,1.0,1.0,35.0,20,9,23,11,4,3,4,6,0,1,,0,3,10,5,5,size_t
854,23115,vlc_iconv_close,1,vlc_iconv_close,int vlc_iconv_close (vlc_iconv_t),extras\libc.c,"int vlc_iconv_close( vlc_iconv_t cd )
{
#ifndef __linux__
    if ( cd == (vlc_iconv_t)(-2) || cd == (vlc_iconv_t)(-3) )
        return 0;
#endif
#if defined(HAVE_ICONV)
    return iconv_close( cd );
#else
    abort ();
#endif
}",483.0,494.0,1.0,1.0,12.0,5,3,2,1,4,0,2,2,0,0,,0,0,2,1,1,int
855,23136,vlc_ureduce,1,vlc_ureduce,"bool vlc_ureduce (unsigned*,unsigned*,uint64_t,uint64_t,uint64_t)",extras\libc.c,"bool vlc_ureduce( unsigned *pi_dst_nom, unsigned *pi_dst_den,
                        uint64_t i_nom, uint64_t i_den, uint64_t i_max )
{
    bool b_exact = 1;
    uint64_t i_gcd;

    if( i_den == 0 )
    {
        *pi_dst_nom = 0;
        *pi_dst_den = 1;
        return 1;
    }

    i_gcd = GCD( i_nom, i_den );
    i_nom /= i_gcd;
    i_den /= i_gcd;

    if( i_max == 0 ) i_max = INT64_C(0xFFFFFFFF);

    if( i_nom > i_max || i_den > i_max )
    {
        uint64_t i_a0_num = 0, i_a0_den = 1, i_a1_num = 1, i_a1_den = 0;
        b_exact = 0;

        for( ; ; )
        {
            uint64_t i_x = i_nom / i_den;
            uint64_t i_a2n = i_x * i_a1_num + i_a0_num;
            uint64_t i_a2d = i_x * i_a1_den + i_a0_den;

            if( i_a2n > i_max || i_a2d > i_max ) break;

            i_nom %= i_den;

            i_a0_num = i_a1_num; i_a0_den = i_a1_den;
            i_a1_num = i_a2n; i_a1_den = i_a2d;
            if( i_nom == 0 ) break;
            i_x = i_nom; i_nom = i_den; ...",500.0,547.0,1.0,1.0,48.0,44,9,63,14,11,0,9,12,0,0,,0,0,10,5,5,bool
856,23321,get_path,1,get_path,char* get_path (char*),input\access.c,"char *get_path(const char *location)
{
    char *url, *path;

    /* Prepending ""file://"" is a bit hackish. But then again, we do not want
     * to hard-code the list of schemes that use file paths in vlc_uri2path().
     */
    if (asprintf(&url, ""file://%s"", location) == -1)
        return NULL;

    path = vlc_uri2path (url);
    free (url);
    return path;
}",42.0,55.0,1.0,1.0,14.0,4,4,7,4,3,1,2,2,0,1,,0,1,2,1,1,char*
857,23348,vlc_access_Destroy,1,vlc_access_Destroy,void vlc_access_Destroy (stream_t*),input\access.c,"static void vlc_access_Destroy(stream_t *access)
{
    module_unneed(access, access->p_module);
    free(access->psz_filepath);
    free(access->psz_name);
}",57.0,62.0,1.0,1.0,6.0,3,1,4,1,0,1,1,1,0,1,,0,0,2,1,1,void
858,23366,access_New,1,access_New,"stream_t access_New (vlc_object_t*,input_thread_t*,bool,char*)",input\access.c,"static stream_t *access_New(vlc_object_t *parent, input_thread_t *input,
                            bool preparsing, const char *mrl)
{
    char *redirv[MAX_REDIR];
    unsigned redirc = 0;

    stream_t *access = vlc_stream_CommonNew(parent, vlc_access_Destroy);
    if (unlikely(access == NULL))
        return NULL;

    access->p_input = input;
    access->psz_name = NULL;
    access->psz_url = strdup(mrl);
    access->psz_filepath = NULL;
    access->b_preparsing = preparsing;

    if (unlikely(access->psz_url == NULL))
        goto error;

    while (redirc < MAX_REDIR)
    {
        char *url = access->psz_url;
        msg_Dbg(access, ""creating access: %s"", url);

        const char *p = strstr(url, ""://"");
        if (p == NULL)
            goto error;

        access->psz_name = strndup(url, p - url);
        if (unlikely(access->psz_name == NULL))
            goto error;

        access->psz_location = p + 3;
        access->psz_filepath = get_path(access->psz_location);
  ...",69.0,144.0,1.0,17.0,76.0,59,10,72,12,2,4,16,20,0,4,,0,3,8,4,4,stream_t
859,23625,vlc_access_NewMRL,1,vlc_access_NewMRL,"stream_t vlc_access_NewMRL (vlc_object_t*,char*)",input\access.c,"stream_t *vlc_access_NewMRL(vlc_object_t *parent, const char *mrl)
{
    return access_New(parent, NULL, false, mrl);
}",146.0,149.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,stream_t
860,23685,AStreamReadBlock,1,AStreamReadBlock,"block_t AStreamReadBlock (stream_t*,bool*)",input\access.c,"static block_t *AStreamReadBlock(stream_t *s, bool *restrict eof)
{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;
    block_t * block;

    if (vlc_stream_Eof(access))
    {
        *eof = true;
        return NULL;
    }
    if (vlc_killed())
        return NULL;

    block = vlc_stream_ReadBlock(access);

    if (block != NULL && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes,
                     block->i_buffer, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return block;
}",184.0,213.0,1.0,1.0,30.0,24,7,26,8,0,13,4,4,2,13,,0,8,4,2,2,block_t
861,23781,AStreamReadStream,1,AStreamReadStream,"ssize_t AStreamReadStream (stream_t*,void*,size_t)",input\access.c,"static ssize_t AStreamReadStream(stream_t *s, void *buf, size_t len)
{
    stream_t *access = s->p_sys;
    input_thread_t *input = s->p_input;

    if (vlc_stream_Eof(access))
        return 0;
    if (vlc_killed())
        return -1;

    ssize_t val = vlc_stream_ReadPartial(access, buf, len);

    if (val > 0 && input != NULL)
    {
        uint64_t total;

        vlc_mutex_lock(&input_priv(input)->counters.counters_lock);
        stats_Update(input_priv(input)->counters.p_read_bytes, val, &total);
        stats_Update(input_priv(input)->counters.p_input_bitrate, total, NULL);
        stats_Update(input_priv(input)->counters.p_read_packets, 1, NULL);
        vlc_mutex_unlock(&input_priv(input)->counters.counters_lock);
    }

    return val;
}",216.0,240.0,1.0,1.0,25.0,22,8,23,8,0,13,4,4,2,13,,0,8,6,3,3,ssize_t
862,23894,AStreamSeek,1,AStreamSeek,"int AStreamSeek (stream_t*,uint64_t)",input\access.c,"static int AStreamSeek(stream_t *s, uint64_t offset)
{
    stream_t *access = s->p_sys;

    return vlc_stream_Seek(access, offset);
}",251.0,256.0,1.0,1.0,6.0,2,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
863,23910,AStreamControl,1,AStreamControl,"int AStreamControl (stream_t*,int,va_list)",input\access.c,"static int AStreamControl(stream_t *s, int cmd, va_list args)
{
    stream_t *access = s->p_sys;

    return vlc_stream_vaControl(access, cmd, args);
}",258.0,263.0,1.0,1.0,6.0,2,2,5,4,0,1,1,1,0,1,,0,0,6,3,3,int
864,23928,AStreamDestroy,1,AStreamDestroy,void AStreamDestroy (stream_t*),input\access.c,"static void AStreamDestroy(stream_t *s)
{
    stream_t *access = s->p_sys;

    vlc_stream_Delete(access);
}",265.0,270.0,1.0,1.0,6.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
865,23941,stream_AccessNew,1,stream_AccessNew,"stream_t stream_AccessNew (vlc_object_t*,input_thread_t*,bool,char*)",input\access.c,"stream_t *stream_AccessNew(vlc_object_t *parent, input_thread_t *input,
                           bool preparsing, const char *url)
{
    stream_t *s = vlc_stream_CommonNew(parent, AStreamDestroy);
    if (unlikely(s == NULL))
        return NULL;

    stream_t *access = access_New(VLC_OBJECT(s), input, preparsing, url);
    if (access == NULL)
    {
        stream_CommonDelete(s);
        return NULL;
    }

    s->p_input = input;
    s->psz_url = strdup(access->psz_url);

    const char *cachename;

    if (access->pf_block != NULL)
    {
        s->pf_block = AStreamReadBlock;
        cachename = ""prefetch,cache_block"";
    }
    else
    if (access->pf_read != NULL)
    {
        s->pf_read = AStreamReadStream;
        cachename = ""prefetch,cache_read"";
    }
    else
    {
        cachename = NULL;
    }

    if (access->pf_readdir != NULL)
        s->pf_readdir = AStreamReadDir;
    else
        s->pf_readdir = AStreamNoReadDir;

    s->pf_seek    = AStreamSeek;
    s->pf_co...",272.0,319.0,1.0,1.0,48.0,26,4,35,8,2,5,6,6,0,5,,0,3,8,4,4,stream_t
866,24100,AvgInit,1,AvgInit,"void AvgInit (average_t*,int)",input\clock.c,"static void AvgInit( average_t *p_avg, int i_divider )
{
    p_avg->i_divider = i_divider;
    AvgReset( p_avg );
}",637.0,641.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
867,24106,AvgClean,1,AvgClean,void AvgClean (average_t*),input\clock.c,"static void AvgClean( average_t *p_avg )
{
    VLC_UNUSED(p_avg);
}",642.0,645.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
868,24111,AvgReset,1,AvgReset,void AvgReset (average_t*),input\clock.c,"static void AvgReset( average_t *p_avg )
{
    p_avg->i_value = 0;
    p_avg->i_residue = 0;
    p_avg->i_count = 0;
}",646.0,651.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
869,24116,AvgUpdate,1,AvgUpdate,"void AvgUpdate (average_t*,mtime_t)",input\clock.c,"static void AvgUpdate( average_t *p_avg, mtime_t i_value )
{
    const int i_f0 = __MIN( p_avg->i_divider - 1, p_avg->i_count );
    const int i_f1 = p_avg->i_divider - i_f0;

    const mtime_t i_tmp = i_f0 * p_avg->i_value + i_f1 * i_value + p_avg->i_residue;

    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;

    p_avg->i_count++;
}",652.0,663.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
870,24122,AvgGet,1,AvgGet,mtime_t AvgGet (average_t*),input\clock.c,"static mtime_t AvgGet( average_t *p_avg )
{
    return p_avg->i_value;
}",664.0,667.0,1.0,1.0,4.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,mtime_t
871,24127,AvgRescale,1,AvgRescale,"void AvgRescale (average_t*,int)",input\clock.c,"static void AvgRescale( average_t *p_avg, int i_divider )
{
    const mtime_t i_tmp = p_avg->i_value * p_avg->i_divider + p_avg->i_residue;

    p_avg->i_divider = i_divider;
    p_avg->i_value   = i_tmp / p_avg->i_divider;
    p_avg->i_residue = i_tmp % p_avg->i_divider;
}",668.0,675.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
872,24137,clock_point_Create,1,clock_point_Create,"clock_point_t clock_point_Create (mtime_t,mtime_t)",input\clock.c,"static inline clock_point_t clock_point_Create( mtime_t i_stream, mtime_t i_system )
{
    clock_point_t p = { .i_stream = i_stream, .i_system = i_system };
    return p;
}",132.0,136.0,1.0,1.0,5.0,4,2,6,3,5,0,1,1,0,0,,0,0,4,2,2,clock_point_t
873,24184,ClockStreamToSystem,1,ClockStreamToSystem,"mtime_t ClockStreamToSystem (input_clock_t*,mtime_t)",input\clock.c,"static mtime_t ClockStreamToSystem( input_clock_t *cl, mtime_t i_stream )
{
    if( !cl->b_has_reference )
        return VLC_TS_INVALID;

    return ( i_stream - cl->ref.i_stream ) * cl->i_rate / INPUT_RATE_DEFAULT +
           cl->ref.i_system;
}",604.0,611.0,1.0,1.0,8.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,mtime_t
874,24190,ClockSystemToStream,1,ClockSystemToStream,"mtime_t ClockSystemToStream (input_clock_t*,mtime_t)",input\clock.c,"static mtime_t ClockSystemToStream( input_clock_t *cl, mtime_t i_system )
{
    assert( cl->b_has_reference );
    return ( i_system - cl->ref.i_system ) * INPUT_RATE_DEFAULT / cl->i_rate +
            cl->ref.i_stream;
}",618.0,623.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,mtime_t
875,24196,ClockGetTsOffset,1,ClockGetTsOffset,mtime_t ClockGetTsOffset (input_clock_t*),input\clock.c,"static mtime_t ClockGetTsOffset( input_clock_t *cl )
{
    return cl->i_pts_delay * ( cl->i_rate - INPUT_RATE_DEFAULT ) / INPUT_RATE_DEFAULT;
}",629.0,632.0,1.0,1.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,mtime_t
876,24201,input_clock_New,1,input_clock_New,input_clock_t input_clock_New (int),input\clock.c,"input_clock_t *input_clock_New( int i_rate )
{
    input_clock_t *cl = malloc( sizeof(*cl) );
    if( !cl )
        return NULL;

    vlc_mutex_init( &cl->lock );
    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;

    cl->last = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );

    cl->i_ts_max = VLC_TS_INVALID;

    cl->i_buffering_duration = 0;

    cl->i_next_drift_update = VLC_TS_INVALID;
    AvgInit( &cl->drift, 10 );

    cl->late.i_index = 0;
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;

    cl->i_rate = i_rate;
    cl->i_pts_delay = 0;
    cl->b_paused = false;
    cl->i_pause_date = VLC_TS_INVALID;

    return cl;
}",191.0,221.0,1.0,24.0,31.0,35,8,32,6,1,17,3,3,0,4,,0,15,2,1,1,input_clock_t
877,24320,input_clock_Delete,1,input_clock_Delete,void input_clock_Delete (input_clock_t*),input\clock.c,"void input_clock_Delete( input_clock_t *cl )
{
    AvgClean( &cl->drift );
    vlc_mutex_destroy( &cl->lock );
    free( cl );
}",226.0,231.0,1.0,1.0,6.0,4,2,3,1,1,4,1,1,0,2,,0,2,2,1,1,void
878,24337,input_clock_Update,1,input_clock_Update,"void input_clock_Update (input_clock_t*,vlc_object_t*,bool*,bool,bool,mtime_t,mtime_t)",input\clock.c,"void input_clock_Update( input_clock_t *cl, vlc_object_t *p_log,
                         bool *pb_late,
                         bool b_can_pace_control, bool b_buffering_allowed,
                         mtime_t i_ck_stream, mtime_t i_ck_system )
{
    bool b_reset_reference = false;

    assert( i_ck_stream > VLC_TS_INVALID && i_ck_system > VLC_TS_INVALID );

    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        /* */
        b_reset_reference= true;
    }
    else if( cl->last.i_stream > VLC_TS_INVALID &&
             ( (cl->last.i_stream - i_ck_stream) > CR_MAX_GAP ||
               (cl->last.i_stream - i_ck_stream) < -CR_MAX_GAP ) )
    {
        /* Stream discontinuity, for which we haven't received a
         * warning from the stream control facilities (dd-edited
         * stream ?). */
        msg_Warn( p_log, ""clock gap, unexpected stream discontinuity"" );
        cl->i_ts_max = VLC_TS_INVALID;

        /* */
        msg_Warn( p_log, ""feeding syn...",239.0,327.0,1.0,51.0,89.0,66,15,57,13,1,25,6,6,2,9,,0,21,14,7,7,void
879,24631,input_clock_Reset,1,input_clock_Reset,void input_clock_Reset (input_clock_t*),input\clock.c,"void input_clock_Reset( input_clock_t *cl )
{
    vlc_mutex_lock( &cl->lock );

    cl->b_has_reference = false;
    cl->ref = clock_point_Create( VLC_TS_INVALID, VLC_TS_INVALID );
    cl->b_has_external_clock = false;
    cl->i_ts_max = VLC_TS_INVALID;

    vlc_mutex_unlock( &cl->lock );
}",332.0,342.0,1.0,1.0,11.0,12,3,11,3,1,9,1,1,0,3,,0,7,2,1,1,void
880,24668,input_clock_ChangeRate,1,input_clock_ChangeRate,"void input_clock_ChangeRate (input_clock_t*,int)",input\clock.c,"void input_clock_ChangeRate( input_clock_t *cl, int i_rate )
{
    vlc_mutex_lock( &cl->lock );

    if( cl->b_has_reference )
    {
        /* Move the reference point (as if we were playing at the new rate
         * from the start */
        cl->ref.i_system = cl->last.i_system - (cl->last.i_system - cl->ref.i_system) * i_rate / cl->i_rate;
    }
    cl->i_rate = i_rate;

    vlc_mutex_unlock( &cl->lock );
}",347.0,360.0,1.0,1.0,14.0,21,7,11,2,0,11,2,2,1,2,,0,9,4,2,2,void
881,24723,input_clock_ChangePause,1,input_clock_ChangePause,"void input_clock_ChangePause (input_clock_t*,bool,mtime_t)",input\clock.c,"void input_clock_ChangePause( input_clock_t *cl, bool b_paused, mtime_t i_date )
{
    vlc_mutex_lock( &cl->lock );
    assert( (!cl->b_paused) != (!b_paused) );

    if( cl->b_paused )
    {
        const mtime_t i_duration = i_date - cl->i_pause_date;

        if( cl->b_has_reference && i_duration > 0 )
        {
            cl->ref.i_system += i_duration;
            cl->last.i_system += i_duration;
        }
    }
    cl->i_pause_date = i_date;
    cl->b_paused = b_paused;

    vlc_mutex_unlock( &cl->lock );
}",365.0,384.0,1.0,1.0,20.0,25,10,18,4,1,12,3,4,2,2,,0,10,6,3,3,void
882,24794,input_clock_GetWakeup,1,input_clock_GetWakeup,mtime_t input_clock_GetWakeup (input_clock_t*),input\clock.c,"mtime_t input_clock_GetWakeup( input_clock_t *cl )
{
    mtime_t i_wakeup = 0;

    vlc_mutex_lock( &cl->lock );

    /* Synchronized, we can wait */
    if( cl->b_has_reference )
        i_wakeup = ClockStreamToSystem( cl, cl->last.i_stream + AvgGet( &cl->drift ) - cl->i_buffering_duration );

    vlc_mutex_unlock( &cl->lock );

    return i_wakeup;
}",389.0,402.0,1.0,1.0,14.0,14,6,10,2,1,10,2,2,1,4,,0,8,2,1,1,mtime_t
883,24839,input_clock_ConvertTS,1,input_clock_ConvertTS,"int input_clock_ConvertTS (vlc_object_t*,input_clock_t*,int*,mtime_t*,mtime_t*,mtime_t)",input\clock.c,"int input_clock_ConvertTS( vlc_object_t *p_object, input_clock_t *cl,
                           int *pi_rate, mtime_t *pi_ts0, mtime_t *pi_ts1,
                           mtime_t i_ts_bound )
{
    assert( pi_ts0 );
    vlc_mutex_lock( &cl->lock );

    if( pi_rate )
        *pi_rate = cl->i_rate;

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        msg_Err(p_object, ""Timestamp conversion failed for %""PRId64"": ""
                ""no reference clock"", *pi_ts0);
        *pi_ts0 = VLC_TS_INVALID;
        if( pi_ts1 )
            *pi_ts1 = VLC_TS_INVALID;
        return VLC_EGENERIC;
    }

    /* */
    const mtime_t i_ts_buffering = cl->i_buffering_duration * cl->i_rate / INPUT_RATE_DEFAULT;
    const mtime_t i_ts_delay = cl->i_pts_delay + ClockGetTsOffset( cl );

    /* */
    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 = ClockStreamToSystem( cl, *pi_ts0 + AvgGet( &cl->drift ) );
        if( *pi_ts0 > cl->i_ts_max )
            cl->i_ts_max = ...",407.0,462.0,1.0,1.0,56.0,58,13,51,12,2,21,9,12,3,9,,0,18,12,6,6,int
884,25003,input_clock_GetRate,1,input_clock_GetRate,int input_clock_GetRate (input_clock_t*),input\clock.c,"int input_clock_GetRate( input_clock_t *cl )
{
    int i_rate;

    vlc_mutex_lock( &cl->lock );
    i_rate = cl->i_rate;
    vlc_mutex_unlock( &cl->lock );

    return i_rate;
}",466.0,475.0,1.0,1.0,10.0,6,3,5,2,2,5,1,1,0,2,,0,3,2,1,1,int
885,25026,input_clock_GetState,1,input_clock_GetState,"int input_clock_GetState (input_clock_t*,mtime_t*,mtime_t*,mtime_t*,mtime_t*)",input\clock.c,"int input_clock_GetState( input_clock_t *cl,
                          mtime_t *pi_stream_start, mtime_t *pi_system_start,
                          mtime_t *pi_stream_duration, mtime_t *pi_system_duration )
{
    vlc_mutex_lock( &cl->lock );

    if( !cl->b_has_reference )
    {
        vlc_mutex_unlock( &cl->lock );
        return VLC_EGENERIC;
    }

    *pi_stream_start = cl->ref.i_stream;
    *pi_system_start = cl->ref.i_system;

    *pi_stream_duration = cl->last.i_stream - cl->ref.i_stream;
    *pi_system_duration = cl->last.i_system - cl->ref.i_system;

    vlc_mutex_unlock( &cl->lock );

    return VLC_SUCCESS;
}",477.0,498.0,1.0,1.0,22.0,30,7,16,7,1,13,2,2,1,3,,0,10,10,5,5,int
886,25104,input_clock_ChangeSystemOrigin,1,input_clock_ChangeSystemOrigin,"void input_clock_ChangeSystemOrigin (input_clock_t*,bool,mtime_t)",input\clock.c,"void input_clock_ChangeSystemOrigin( input_clock_t *cl, bool b_absolute, mtime_t i_system )
{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );
    mtime_t i_offset;
    if( b_absolute )
    {
        i_offset = i_system - cl->ref.i_system - ClockGetTsOffset( cl );
    }
    else
    {
        if( !cl->b_has_external_clock )
        {
            cl->b_has_external_clock = true;
            cl->i_external_clock     = i_system;
        }
        i_offset = i_system - cl->i_external_clock;
    }

    cl->ref.i_system += i_offset;
    cl->last.i_system += i_offset;

    vlc_mutex_unlock( &cl->lock );
}",500.0,524.0,1.0,1.0,25.0,16,6,12,4,1,9,2,2,0,3,,0,7,6,3,3,void
887,25180,input_clock_GetSystemOrigin,1,input_clock_GetSystemOrigin,"void input_clock_GetSystemOrigin (input_clock_t*,mtime_t*,mtime_t*)",input\clock.c,"void input_clock_GetSystemOrigin( input_clock_t *cl, mtime_t *pi_system, mtime_t *pi_delay )
{
    vlc_mutex_lock( &cl->lock );

    assert( cl->b_has_reference );

    *pi_system = cl->ref.i_system;
    if( pi_delay )
        *pi_delay  = cl->i_pts_delay;

    vlc_mutex_unlock( &cl->lock );
}",526.0,537.0,1.0,1.0,12.0,12,5,8,3,1,7,2,2,0,2,,0,5,6,3,3,void
888,25218,input_clock_SetJitter,1,input_clock_SetJitter,"void input_clock_SetJitter (input_clock_t*,mtime_t,int)",input\clock.c,"void input_clock_SetJitter( input_clock_t *cl,
                            mtime_t i_pts_delay, int i_cr_average )
{
    vlc_mutex_lock( &cl->lock );

    /* Update late observations */
    const mtime_t i_delay_delta = i_pts_delay - cl->i_pts_delay;
    mtime_t pi_late[INPUT_CLOCK_LATE_COUNT];
    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        pi_late[i] = __MAX( cl->late.pi_value[(cl->late.i_index + 1 + i)%INPUT_CLOCK_LATE_COUNT] - i_delay_delta, 0 );

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
        cl->late.pi_value[i] = 0;
    cl->late.i_index = 0;

    for( int i = 0; i < INPUT_CLOCK_LATE_COUNT; i++ )
    {
        if( pi_late[i] <= 0 )
            continue;
        cl->late.pi_value[cl->late.i_index] = pi_late[i];
        cl->late.i_index = ( cl->late.i_index + 1 ) % INPUT_CLOCK_LATE_COUNT;
    }

    /* TODO always save the value, and when rebuffering use the new one if smaller
     * TODO when increasing -> force rebuffering
     */
    if( cl->i_pts...",540.0,577.0,1.0,20.0,38.0,43,11,30,6,1,10,9,9,2,3,,0,7,6,3,3,void
889,25402,input_clock_GetJitter,1,input_clock_GetJitter,mtime_t input_clock_GetJitter (input_clock_t*),input\clock.c,"mtime_t input_clock_GetJitter( input_clock_t *cl )
{
    vlc_mutex_lock( &cl->lock );

#if INPUT_CLOCK_LATE_COUNT != 3
#   error ""unsupported INPUT_CLOCK_LATE_COUNT""
#endif
    /* Find the median of the last late values
     * It works pretty well at rejecting bad values
     *
     * XXX we only increase pts_delay over time, decreasing it is
     * not that easy if we want to be robust.
     */
    const mtime_t *p = cl->late.pi_value;
    mtime_t i_late_median = p[0] + p[1] + p[2] - __MIN(__MIN(p[0],p[1]),p[2]) - __MAX(__MAX(p[0],p[1]),p[2]);
    mtime_t i_pts_delay = cl->i_pts_delay ;

    vlc_mutex_unlock( &cl->lock );

    return i_pts_delay + i_late_median;
}",579.0,599.0,1.0,4.0,21.0,24,7,18,4,0,5,1,1,0,2,,0,3,2,1,1,mtime_t
890,25842,UpdateBookmarksOption,1,UpdateBookmarksOption,void UpdateBookmarksOption (input_thread_t*),input\control.c,"static void UpdateBookmarksOption( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_item_t* item = priv->p_item;
    struct vlc_memstream vstr;

    vlc_memstream_open( &vstr );
    vlc_memstream_puts( &vstr, ""bookmarks="" );

    vlc_mutex_lock( &item->lock );
    var_Change( p_input, ""bookmark"", VLC_VAR_CLEARCHOICES, 0, 0 );

    for( int i = 0; i < priv->i_bookmark; i++ )
    {
        seekpoint_t const* sp = priv->pp_bookmark[i];

        /* Add bookmark to choice-list */
        var_Change( p_input, ""bookmark"", VLC_VAR_ADDCHOICE,
                    &(vlc_value_t){ .i_int = i },
                    &(vlc_value_t){ .psz_string = sp->psz_name } );

        /* Append bookmark to option-buffer */
        /* TODO: escape inappropriate values */
        vlc_memstream_printf( &vstr, ""%s{name=%s,time=%.3f}"",
            i > 0 ? "","" : """", sp->psz_name, ( 1. * sp->i_time_offset ) / CLOCK_FREQ );
    }

    if( vlc_memstream_close( &vstr ) )
   ...",591.0,663.0,1.0,1.0,73.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
891,25847,input_Control,1,input_Control,"int input_Control (input_thread_t*,int...)",input\control.c,"int input_Control( input_thread_t *p_input, int i_query, ...  )
{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = input_vaControl( p_input, i_query, args );
    va_end( args );

    return i_result;
}",53.0,63.0,1.0,1.0,11.0,1,1,8,4,9,1,1,1,0,1,,0,1,4,2,2,int
892,25868,input_vaControl,1,input_vaControl,"int input_vaControl (input_thread_t*,int,va_list)",input\control.c,"int input_vaControl( input_thread_t *p_input, int i_query, va_list args )
{
    input_thread_private_t *priv = input_priv(p_input);
    seekpoint_t *p_bkmk, ***ppp_bkmk;
    int i_bkmk = 0;
    int *pi_bkmk;

    int i_int, *pi_int;
    bool b_bool, *pb_bool;
    double f, *pf;
    int64_t i_64, *pi_64;

    char *psz;
    vlc_value_t val;

    switch( i_query )
    {
        case INPUT_GET_POSITION:
            pf = va_arg( args, double * );
            *pf = var_GetFloat( p_input, ""position"" );
            return VLC_SUCCESS;

        case INPUT_SET_POSITION:
            f = va_arg( args, double );
            return var_SetFloat( p_input, ""position"", f );

        case INPUT_GET_LENGTH:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""length"" );
            return VLC_SUCCESS;

        case INPUT_GET_TIME:
            pi_64 = va_arg( args, int64_t * );
            *pi_64 = var_GetInteger( p_input, ""time"" );
            return VLC_SUCCE...",65.0,589.0,1.0,1.0,525.0,320,21,416,123,1,129,42,83,18,57,,0,82,6,3,3,int
893,27599,LoadDecoder,1,LoadDecoder,"int LoadDecoder (decoder_t*,bool,es_format_t*)",input\decoder.c,"static int LoadDecoder( decoder_t *p_dec, bool b_packetizer,
                        const es_format_t *restrict p_fmt )
{
    p_dec->b_frame_drop_allowed = true;
    p_dec->i_extra_picture_buffers = 0;

    p_dec->pf_decode = NULL;
    p_dec->pf_get_cc = NULL;
    p_dec->pf_packetize = NULL;
    p_dec->pf_flush = NULL;

    es_format_Copy( &p_dec->fmt_in, p_fmt );
    es_format_Init( &p_dec->fmt_out, p_fmt->i_cat, 0 );

    /* Find a suitable decoder/packetizer module */
    if( !b_packetizer )
    {
        static const char caps[ES_CATEGORY_COUNT][16] = {
            [VIDEO_ES] = ""video decoder"",
            [AUDIO_ES] = ""audio decoder"",
            [SPU_ES] = ""spu decoder"",
        };
        p_dec->p_module = module_need( p_dec, caps[p_dec->fmt_in.i_cat],
                                       ""$codec"", false );
    }
    else
        p_dec->p_module = module_need( p_dec, ""packetizer"", ""$packetizer"", false );

    if( !p_dec->p_module )
    {
        es_format_Clean( &p_dec->fm...",157.0,192.0,1.0,1.0,36.0,33,8,27,10,3,4,3,3,0,4,,0,1,6,3,3,int
894,27715,UnloadDecoder,1,UnloadDecoder,void UnloadDecoder (decoder_t*),input\decoder.c,"static void UnloadDecoder( decoder_t *p_dec )
{
    if( p_dec->p_module )
    {
        module_unneed( p_dec, p_dec->p_module );
        p_dec->p_module = NULL;
    }

    if( p_dec->p_description )
    {
        vlc_meta_Delete( p_dec->p_description );
        p_dec->p_description = NULL;
    }

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );
}",197.0,213.0,1.0,1.0,17.0,12,3,11,2,4,4,3,3,0,4,,0,0,2,1,1,void
895,27759,ReloadDecoder,1,ReloadDecoder,"int ReloadDecoder (decoder_t*,bool,es_format_t*,reload)",input\decoder.c,"static int ReloadDecoder( decoder_t *p_dec, bool b_packetizer,
                          const es_format_t *restrict p_fmt, enum reload reload )
{
    /* Copy p_fmt since it can be destroyed by UnloadDecoder */
    es_format_t fmt_in;
    if( es_format_Copy( &fmt_in, p_fmt ) != VLC_SUCCESS )
    {
        p_dec->p_owner->error = true;
        return VLC_EGENERIC;
    }

    /* Restart the decoder module */
    UnloadDecoder( p_dec );
    p_dec->p_owner->error = false;

    if( reload == RELOAD_DECODER_AOUT )
    {
        decoder_owner_sys_t *p_owner = p_dec->p_owner;
        assert( p_owner->fmt.i_cat == AUDIO_ES );
        audio_output_t *p_aout = p_owner->p_aout;

        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        if( p_aout )
        {
            aout_DecDelete( p_aout );
            input_resource_PutAout( p_owner->p_resource, p_aout );
        }
    }

    if( LoadDecoder( p_dec, b_packetizer, &fmt_in ...",215.0,254.0,1.0,1.0,40.0,29,6,34,14,0,15,5,6,2,9,,0,8,8,4,4,int
896,27868,DecoderUpdateFormatLocked,1,DecoderUpdateFormatLocked,void DecoderUpdateFormatLocked (decoder_t*),input\decoder.c,"static void DecoderUpdateFormatLocked( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    es_format_Clean( &p_owner->fmt );
    es_format_Copy( &p_owner->fmt, &p_dec->fmt_out );

    /* Move p_description */
    if( p_dec->p_description != NULL )
    {
        if( p_owner->p_description != NULL )
            vlc_meta_Delete( p_owner->p_description );
        p_owner->p_description = p_dec->p_description;
        p_dec->p_description = NULL;
    }

    p_owner->b_fmt_description = true;
}",256.0,275.0,1.0,1.0,20.0,22,4,17,4,3,10,3,4,1,3,,0,7,2,1,1,void
897,27933,aout_request_vout,1,aout_request_vout,"vout_thread_t aout_request_vout (void*,vout_thread_t*,video_format_t*,bool)",input\decoder.c,"static vout_thread_t *aout_request_vout( void *p_private,
                                         vout_thread_t *p_vout,
                                         const video_format_t *p_fmt, bool b_recyle )
{
    decoder_t *p_dec = p_private;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;
    video_format_t fmt;

    if (p_fmt != NULL)
    {
        fmt = *p_fmt;
        p_fmt = &fmt;
        video_format_AdjustColorSpace( &fmt );
    }

    p_vout = input_resource_RequestVout( p_owner->p_resource, p_vout, p_fmt, 1,
                                         b_recyle );
    if( p_input != NULL )
        input_SendEventVout( p_input );

    return p_vout;
}",280.0,302.0,1.0,1.0,23.0,14,5,22,9,0,4,3,3,0,2,,0,3,8,4,4,vout_thread_t
898,27993,aout_replaygain_changed,1,aout_replaygain_changed,"bool aout_replaygain_changed (audio_replay_gain_t*,audio_replay_gain_t*)",input\decoder.c,"static bool aout_replaygain_changed( const audio_replay_gain_t *a,
                                     const audio_replay_gain_t *b )
{
    for( size_t i=0; i<AUDIO_REPLAY_GAIN_MAX; i++ )
    {
        if( a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] ||
            a->pb_gain[i] != b->pb_gain[i] ||
            a->pb_peak[i] != b->pb_peak[i] )
            return true;
    }
    return false;
}",304.0,316.0,1.0,1.0,13.0,25,6,21,6,1,0,3,4,0,0,,0,0,4,2,2,bool
899,28064,aout_update_format,1,aout_update_format,int aout_update_format (decoder_t*),input\decoder.c,"static int aout_update_format( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_aout &&
       ( !AOUT_FMTS_IDENTICAL(&p_dec->fmt_out.audio, &p_owner->fmt.audio) ||
         p_dec->fmt_out.i_codec != p_dec->fmt_out.audio.i_format ||
         p_dec->fmt_out.i_profile != p_owner->fmt.i_profile ) )
    {
        audio_output_t *p_aout = p_owner->p_aout;

        /* Parameters changed, restart the aout */
        vlc_mutex_lock( &p_owner->lock );
        p_owner->p_aout = NULL;
        vlc_mutex_unlock( &p_owner->lock );
        aout_DecDelete( p_aout );

        input_resource_PutAout( p_owner->p_resource, p_aout );
    }

    /* Check if only replay gain has changed */
    if( aout_replaygain_changed( &p_dec->fmt_in.audio_replay_gain,
                                 &p_owner->fmt.audio_replay_gain ) )
    {
        p_dec->fmt_out.audio_replay_gain = p_dec->fmt_in.audio_replay_gain;
        if( p_owner->p_aout )
        {
            p_owner-...",318.0,412.0,1.0,1.0,95.0,117,13,77,13,0,38,12,23,9,15,,0,26,2,1,1,int
900,28403,vout_update_format,1,vout_update_format,int vout_update_format (decoder_t*),input\decoder.c,"static int vout_update_format( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->p_vout == NULL
     || p_dec->fmt_out.video.i_width != p_owner->fmt.video.i_width
     || p_dec->fmt_out.video.i_height != p_owner->fmt.video.i_height
     || p_dec->fmt_out.video.i_visible_width != p_owner->fmt.video.i_visible_width
     || p_dec->fmt_out.video.i_visible_height != p_owner->fmt.video.i_visible_height
     || p_dec->fmt_out.video.i_x_offset != p_owner->fmt.video.i_x_offset
     || p_dec->fmt_out.video.i_y_offset != p_owner->fmt.video.i_y_offset
     || p_dec->fmt_out.i_codec != p_owner->fmt.video.i_chroma
     || (int64_t)p_dec->fmt_out.video.i_sar_num * p_owner->fmt.video.i_sar_den !=
        (int64_t)p_dec->fmt_out.video.i_sar_den * p_owner->fmt.video.i_sar_num ||
        p_dec->fmt_out.video.orientation != p_owner->fmt.video.orientation ||
        p_dec->fmt_out.video.multiview_mode != p_owner->fmt.video.multiview_mode )
    {
        vout_threa...",414.0,561.0,1.0,1.0,148.0,278,18,126,17,0,42,20,36,18,13,,0,32,2,1,1,int
901,29122,vout_new_buffer,1,vout_new_buffer,picture_t vout_new_buffer (decoder_t*),input\decoder.c,"static picture_t *vout_new_buffer( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    assert( p_owner->p_vout );

    return vout_GetPicture( p_owner->p_vout );
}",563.0,569.0,1.0,1.0,7.0,4,2,4,2,0,3,1,1,0,1,,0,2,2,1,1,picture_t
902,29142,spu_new_buffer,1,spu_new_buffer,"subpicture_t spu_new_buffer (decoder_t*,subpicture_updater_t*)",input\decoder.c,"static subpicture_t *spu_new_buffer( decoder_t *p_dec,
                                     const subpicture_updater_t *p_updater )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = NULL;
    subpicture_t *p_subpic;
    int i_attempts = 30;

    while( i_attempts-- )
    {
        if( p_owner->error )
            break;

        p_vout = input_resource_HoldVout( p_owner->p_resource );
        if( p_vout )
            break;

        msleep( DECODER_SPU_VOUT_WAIT_DURATION );
    }

    if( !p_vout )
    {
        msg_Warn( p_dec, ""no vout found, dropping subpicture"" );
        return NULL;
    }

    if( p_owner->p_spu_vout != p_vout )
    {
        p_owner->i_spu_channel = vout_RegisterSubpictureChannel( p_vout );
        p_owner->i_spu_order = 0;
        p_owner->p_spu_vout = p_vout;
    }

    p_subpic = subpicture_New( p_updater );
    if( p_subpic )
    {
        p_subpic->i_channel = p_owner->i_spu_channel;
        p_subpic->i_order = p_owner->i_s...",571.0,615.0,1.0,16.0,45.0,29,8,32,9,0,13,9,9,2,5,,0,11,4,2,2,subpicture_t
903,29254,DecoderGetInputAttachments,1,DecoderGetInputAttachments,"int DecoderGetInputAttachments (decoder_t*,input_attachment_t***,int*)",input\decoder.c,"static int DecoderGetInputAttachments( decoder_t *p_dec,
                                       input_attachment_t ***ppp_attachment,
                                       int *pi_attachment )
{
    input_thread_t *p_input = p_dec->p_owner->p_input;

    if( unlikely(p_input == NULL) )
        return VLC_ENOOBJ;
    return input_Control( p_input, INPUT_GET_ATTACHMENTS,
                          ppp_attachment, pi_attachment );
}",617.0,627.0,1.0,1.0,11.0,4,3,9,7,0,1,2,2,0,1,,0,0,6,3,3,int
904,29283,DecoderGetDisplayDate,1,DecoderGetDisplayDate,"mtime_t DecoderGetDisplayDate (decoder_t*,mtime_t)",input\decoder.c,"static mtime_t DecoderGetDisplayDate( decoder_t *p_dec, mtime_t i_ts )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->b_waiting || p_owner->paused )
        i_ts = VLC_TS_INVALID;
    vlc_mutex_unlock( &p_owner->lock );

    if( !p_owner->p_clock || i_ts <= VLC_TS_INVALID )
        return i_ts;

    if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_owner->p_clock, NULL, &i_ts, NULL, INT64_MAX ) ) {
        msg_Err(p_dec, ""Could not get display date for timestamp %""PRId64"""", i_ts);
        return VLC_TS_INVALID;
    }

    return i_ts;
}",629.0,647.0,1.0,1.0,19.0,16,6,20,6,0,9,4,4,5,3,,0,7,4,2,2,mtime_t
905,29347,DecoderGetDisplayRate,1,DecoderGetDisplayRate,int DecoderGetDisplayRate (decoder_t*),input\decoder.c,"static int DecoderGetDisplayRate( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !p_owner->p_clock )
        return INPUT_RATE_DEFAULT;
    return input_clock_GetRate( p_owner->p_clock );
}",649.0,656.0,1.0,1.0,8.0,5,3,5,3,0,3,2,2,1,1,,0,2,2,1,1,int
906,29371,decoder_NewAudioBuffer,1,decoder_NewAudioBuffer,"block_t decoder_NewAudioBuffer (decoder_t*,int)",input\decoder.c,"block_t *decoder_NewAudioBuffer( decoder_t *dec, int samples )
{
    assert( dec->fmt_out.audio.i_frame_length > 0
         && dec->fmt_out.audio.i_bytes_per_frame  > 0 );

    size_t length = samples * dec->fmt_out.audio.i_bytes_per_frame
                            / dec->fmt_out.audio.i_frame_length;
    block_t *block = block_Alloc( length );
    if( likely(block != NULL) )
    {
        block->i_nb_samples = samples;
        block->i_pts = block->i_length = 0;
    }
    return block;
}",661.0,675.0,1.0,1.0,15.0,26,8,15,5,0,1,2,2,0,1,,0,1,4,2,2,block_t
907,29468,RequestReload,1,RequestReload,void RequestReload (decoder_t*),input\decoder.c,"static void RequestReload( decoder_t * p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    /* Don't override reload if it's RELOAD_DECODER_AOUT */
    int expected = RELOAD_NO_REQUEST;
    atomic_compare_exchange_strong( &p_owner->reload, &expected, RELOAD_DECODER );
}",686.0,692.0,1.0,1.0,7.0,6,3,7,5,2,1,1,1,0,0,,0,1,2,1,1,void
908,29554,decoder_AbortPictures,1,decoder_AbortPictures,"void decoder_AbortPictures (decoder_t*,bool)",input\decoder.c,"void decoder_AbortPictures( decoder_t *p_dec, bool b_abort )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->p_vout != NULL )
        vout_Cancel( p_owner->p_vout, b_abort );
    vlc_mutex_unlock( &p_owner->lock );
}",724.0,732.0,1.0,1.0,9.0,9,4,8,4,0,7,2,2,1,3,,0,4,4,2,2,void
909,29588,DecoderWaitUnblock,1,DecoderWaitUnblock,void DecoderWaitUnblock (decoder_t*),input\decoder.c,"static void DecoderWaitUnblock( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_assert_locked( &p_owner->lock );

    for( ;; )
    {
        if( !p_owner->b_waiting || !p_owner->b_has_data )
            break;
        vlc_cond_wait( &p_owner->wait_request, &p_owner->lock );
    }
}",734.0,746.0,1.0,1.0,13.0,13,5,7,2,3,6,4,4,2,1,,0,5,2,1,1,void
910,29628,DecoderTimedWait,1,DecoderTimedWait,"int DecoderTimedWait (decoder_t*,mtime_t)",input\decoder.c,"static int DecoderTimedWait( decoder_t *p_dec, mtime_t deadline )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if (deadline - mdate() <= 0)
        return VLC_SUCCESS;

    vlc_fifo_Lock( p_owner->p_fifo );
    while( !p_owner->flushing
        && vlc_fifo_TimedWaitCond( p_owner->p_fifo, &p_owner->wait_timed,
                                   deadline ) == 0 );
    int ret = p_owner->flushing ? VLC_EGENERIC : VLC_SUCCESS;
    vlc_fifo_Unlock( p_owner->p_fifo );
    return ret;
}",750.0,764.0,1.0,1.0,15.0,16,9,15,6,2,10,3,3,5,4,,0,8,4,2,2,int
911,29763,DecoderFixTs,1,DecoderFixTs,"void DecoderFixTs (decoder_t*,mtime_t*,mtime_t*,mtime_t*,int*,mtime_t)",input\decoder.c,"static void DecoderFixTs( decoder_t *p_dec, mtime_t *pi_ts0, mtime_t *pi_ts1,
                          mtime_t *pi_duration, int *pi_rate, mtime_t i_ts_bound )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_clock_t   *p_clock = p_owner->p_clock;

    vlc_assert_locked( &p_owner->lock );

    const mtime_t i_es_delay = p_owner->i_ts_delay;

    if( !p_clock )
        return;

    const bool b_ephemere = pi_ts1 && *pi_ts0 == *pi_ts1;
    int i_rate;

    if( *pi_ts0 > VLC_TS_INVALID )
    {
        *pi_ts0 += i_es_delay;
        if( pi_ts1 && *pi_ts1 > VLC_TS_INVALID )
            *pi_ts1 += i_es_delay;
        if( i_ts_bound != INT64_MAX )
            i_ts_bound += i_es_delay;
        if( input_clock_ConvertTS( VLC_OBJECT(p_dec), p_clock, &i_rate, pi_ts0, pi_ts1, i_ts_bound ) ) {
            const char *psz_name = module_get_name( p_dec->p_module, false );
            if( pi_ts1 != NULL )
                msg_Err(p_dec, ""Could not convert timestamps %""PRId64
         ...",780.0,828.0,1.0,1.0,49.0,47,14,50,16,3,5,9,12,1,2,,0,5,12,6,6,void
912,29912,DecoderPlayCc,1,DecoderPlayCc,"void DecoderPlayCc (decoder_t*,block_t*,decoder_cc_desc_t*)",input\decoder.c,"static void DecoderPlayCc( decoder_t *p_dec, block_t *p_cc,
                           const decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );

    p_owner->cc.desc = *p_desc;

    /* Fanout data to all decoders. We do not know if es_out
       selected 608 or 708. */
    uint64_t i_bitmap = p_owner->cc.desc.i_608_channels |
                        p_owner->cc.desc.i_708_channels;

    for( int i=0; i_bitmap > 0; i_bitmap >>= 1, i++ )
    {
        decoder_t *p_ccdec = p_owner->cc.pp_decoder[i];
        if( !p_ccdec )
            continue;

        if( i_bitmap > 1 )
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, block_Duplicate(p_cc) );
        }
        else
        {
            block_FifoPut( p_ccdec->p_owner->p_fifo, p_cc );
            p_cc = NULL; /* was last dec */
        }
    }

    vlc_mutex_unlock( &p_owner->lock );

    if( p_cc ) /* can have bitmap set but no created decs */
        ...",927.0,962.0,1.0,1.0,36.0,28,9,20,7,2,5,6,7,0,3,,0,2,6,3,3,void
913,30022,PacketizerGetCc,1,PacketizerGetCc,"void PacketizerGetCc (decoder_t*,decoder_t*)",input\decoder.c,"static void PacketizerGetCc( decoder_t *p_dec, decoder_t *p_dec_cc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    block_t *p_cc;
    decoder_cc_desc_t desc;

    /* Do not try retreiving CC if not wanted (sout) or cannot be retreived */
    if( !p_owner->cc.b_supported )
        return;

    assert( p_dec_cc->pf_get_cc != NULL );

    p_cc = p_dec_cc->pf_get_cc( p_dec_cc, &desc );
    if( !p_cc )
        return;
    DecoderPlayCc( p_dec, p_cc, &desc );
}",964.0,980.0,1.0,1.0,17.0,12,6,13,6,0,1,3,3,0,1,,0,0,4,2,2,void
914,30070,DecoderQueueCc,1,DecoderQueueCc,"int DecoderQueueCc (decoder_t*,block_t*,decoder_cc_desc_t*)",input\decoder.c,"static int DecoderQueueCc( decoder_t *p_videodec, block_t *p_cc,
                           const decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_videodec->p_owner;

    if( unlikely( p_cc != NULL ) )
    {
        if( p_owner->cc.b_supported &&
           ( !p_owner->p_packetizer || !p_owner->p_packetizer->pf_get_cc ) )
            DecoderPlayCc( p_videodec, p_cc, p_desc );
        else
            block_Release( p_cc );
    }
    return 0;
}",982.0,996.0,1.0,1.0,15.0,12,7,10,5,0,3,3,4,2,1,,0,2,6,3,3,int
915,30118,DecoderPlayVideo,1,DecoderPlayVideo,"int DecoderPlayVideo (decoder_t*,picture_t*,unsigned*)",input\decoder.c,"static int DecoderPlayVideo( decoder_t *p_dec, picture_t *p_picture,
                             unsigned *restrict pi_lost_sum )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t  *p_vout = p_owner->p_vout;
    bool prerolled;

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_picture->date )
    {
        vlc_mutex_unlock( &p_owner->lock );
        picture_Release( p_picture );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of video preroll"" );

        if( p_vout )
            vout_Flush( p_vout, VLC_TS_INVALID+1 );
    }

    if( p_picture->date <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated video buffer received"" );
        goto discard;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting && !p_owner->b_first )
   ...",998.0,1094.0,1.0,27.0,97.0,73,16,73,16,1,40,13,13,7,15,,0,25,6,3,3,int
916,30386,DecoderUpdateStatVideo,1,DecoderUpdateStatVideo,"void DecoderUpdateStatVideo (decoder_owner_sys_t*,unsigned,unsigned)",input\decoder.c,"static void DecoderUpdateStatVideo( decoder_owner_sys_t *p_owner,
                                    unsigned decoded, unsigned lost )
{
    input_thread_t *p_input = p_owner->p_input;
    unsigned displayed = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_vout != NULL )
    {
        unsigned vout_lost = 0;

        vout_GetResetStatistic( p_owner->p_vout, &displayed, &vout_lost );
        lost += vout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
    stats_Update( input_priv(p_input)->counters.p_decoded_video, decoded, NULL );
    stats_Update( input_priv(p_input)->counters.p_lost_pictures, lost , NULL);
    stats_Update( input_priv(p_input)->counters.p_displayed_pictures, displayed, NULL);
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
}",1096.0,1119.0,1.0,1.0,24.0,23,7,24,7,0,14,3,3,1,11,,0,8,6,3,3,void
917,30474,DecoderQueueVideo,1,DecoderQueueVideo,"int DecoderQueueVideo (decoder_t*,picture_t*)",input\decoder.c,"static int DecoderQueueVideo( decoder_t *p_dec, picture_t *p_pic )
{
    assert( p_pic );
    unsigned i_lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayVideo( p_dec, p_pic, &i_lost );

    p_owner->pf_update_stat( p_owner, 1, i_lost );
    return ret;
}",1121.0,1131.0,1.0,1.0,11.0,6,3,12,5,0,1,1,1,0,1,,0,1,4,2,2,int
918,30509,DecoderPlayAudio,1,DecoderPlayAudio,"int DecoderPlayAudio (decoder_t*,block_t*,unsigned*)",input\decoder.c,"static int DecoderPlayAudio( decoder_t *p_dec, block_t *p_audio,
                             unsigned *restrict pi_lost_sum )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool prerolled;

    assert( p_audio != NULL );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->i_preroll_end > p_audio->i_pts )
    {
        vlc_mutex_unlock( &p_owner->lock );
        block_Release( p_audio );
        return -1;
    }

    prerolled = p_owner->i_preroll_end > INT64_MIN;
    p_owner->i_preroll_end = INT64_MIN;
    vlc_mutex_unlock( &p_owner->lock );

    if( unlikely(prerolled) )
    {
        msg_Dbg( p_dec, ""end of audio preroll"" );

        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }

    /* */
    if( p_audio->i_pts <= VLC_TS_INVALID ) // FIXME --VLC_TS_INVALID verify audio_output/*
    {
        msg_Warn( p_dec, ""non-dated audio buffer received"" );
        *pi_lost_sum += 1;
        block_Release( p_audio );
        return 0;
    }

 ...",1133.0,1214.0,1.0,37.0,82.0,57,16,59,16,1,26,8,10,4,12,,0,16,6,3,3,int
919,30734,DecoderUpdateStatAudio,1,DecoderUpdateStatAudio,"void DecoderUpdateStatAudio (decoder_owner_sys_t*,unsigned,unsigned)",input\decoder.c,"static void DecoderUpdateStatAudio( decoder_owner_sys_t *p_owner,
                                    unsigned decoded, unsigned lost )
{
    input_thread_t *p_input = p_owner->p_input;
    unsigned played = 0;

    /* Update ugly stat */
    if( p_input == NULL )
        return;

    if( p_owner->p_aout != NULL )
    {
        unsigned aout_lost;

        aout_DecGetResetStats( p_owner->p_aout, &aout_lost, &played );
        lost += aout_lost;
    }

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    stats_Update( input_priv(p_input)->counters.p_lost_abuffers, lost, NULL );
    stats_Update( input_priv(p_input)->counters.p_played_abuffers, played, NULL );
    stats_Update( input_priv(p_input)->counters.p_decoded_audio, decoded, NULL );
    vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock);
}",1216.0,1239.0,1.0,1.0,24.0,22,7,23,7,0,14,3,3,1,11,,0,8,6,3,3,void
920,30819,DecoderQueueAudio,1,DecoderQueueAudio,"int DecoderQueueAudio (decoder_t*,block_t*)",input\decoder.c,"static int DecoderQueueAudio( decoder_t *p_dec, block_t *p_aout_buf )
{
    unsigned lost = 0;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = DecoderPlayAudio( p_dec, p_aout_buf, &lost );

    p_owner->pf_update_stat( p_owner, 1, lost );

    return ret;
}",1241.0,1251.0,1.0,1.0,11.0,6,3,11,5,0,1,1,1,0,1,,0,1,4,2,2,int
921,30852,DecoderPlaySpu,1,DecoderPlaySpu,"void DecoderPlaySpu (decoder_t*,subpicture_t*)",input\decoder.c,"static void DecoderPlaySpu( decoder_t *p_dec, subpicture_t *p_subpic )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    vout_thread_t *p_vout = p_owner->p_spu_vout;

    /* */
    if( p_subpic->i_start <= VLC_TS_INVALID )
    {
        msg_Warn( p_dec, ""non-dated spu buffer received"" );
        subpicture_Delete( p_subpic );
        return;
    }

    /* */
    vlc_mutex_lock( &p_owner->lock );

    if( p_owner->b_waiting )
    {
        p_owner->b_has_data = true;
        vlc_cond_signal( &p_owner->wait_acknowledge );
    }

    DecoderWaitUnblock( p_dec );
    DecoderFixTs( p_dec, &p_subpic->i_start, &p_subpic->i_stop, NULL,
                  NULL, INT64_MAX );
    vlc_mutex_unlock( &p_owner->lock );

    if( p_subpic->i_start <= VLC_TS_INVALID
     || DecoderTimedWait( p_dec, p_subpic->i_start - SPU_MAX_PREPARE_TIME ) )
    {
        subpicture_Delete( p_subpic );
        return;
    }

    vout_PutSubpicture( p_vout, p_subpic );
}",1253.0,1288.0,1.0,1.0,36.0,24,6,29,9,0,15,4,4,2,9,,0,7,4,2,2,void
922,30960,DecoderQueueSpu,1,DecoderQueueSpu,"int DecoderQueueSpu (decoder_t*,subpicture_t*)",input\decoder.c,"static int DecoderQueueSpu( decoder_t *p_dec, subpicture_t *p_spu )
{
    assert( p_spu );
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    input_thread_t *p_input = p_owner->p_input;

    if( p_input != NULL )
    {
        vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock );
        stats_Update( input_priv(p_input)->counters.p_decoded_sub, 1, NULL );
        vlc_mutex_unlock( &input_priv(p_input)->counters.counters_lock );
    }

    int i_ret = -1;
    vout_thread_t *p_vout = input_resource_HoldVout( p_owner->p_resource );
    if( p_vout && p_owner->p_spu_vout == p_vout )
    {
        /* Preroll does not work very well with subtitle */
        vlc_mutex_lock( &p_owner->lock );
        if( p_spu->i_start > VLC_TS_INVALID &&
            p_spu->i_start < p_owner->i_preroll_end &&
            ( p_spu->i_stop <= VLC_TS_INVALID || p_spu->i_stop < p_owner->i_preroll_end ) )
        {
            vlc_mutex_unlock( &p_owner->lock );
            subpicture_Delete( p_spu ...",1296.0,1336.0,1.0,1.0,41.0,37,12,31,8,0,18,5,6,3,11,,0,11,4,2,2,int
923,31096,DecoderProcess,1,DecoderProcess,"void DecoderProcess (decoder_t*,block_t*)",input\decoder.c,"static void DecoderProcess( decoder_t *p_dec, block_t *p_block )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( p_owner->error )
        goto error;

    /* Here, the atomic doesn't prevent to miss a reload request.
     * DecoderProcess() can still be called after the decoder module or the
     * audio output requested a reload. This will only result in a drop of an
     * input block or an output buffer. */
    enum reload reload;
    if( ( reload = atomic_exchange( &p_owner->reload, RELOAD_NO_REQUEST ) ) )
    {
        msg_Warn( p_dec, ""Reloading the decoder module%s"",
                  reload == RELOAD_DECODER_AOUT ? "" and the audio output"" : """" );

        if( ReloadDecoder( p_dec, false, &p_dec->fmt_in, reload ) != VLC_SUCCESS )
            goto error;
    }

    bool packetize = p_owner->p_packetizer != NULL;
    if( p_block )
    {
        if( p_block->i_buffer <= 0 )
            goto error;

        vlc_mutex_lock( &p_owner->lock );
        DecoderUpdatePrer...",1375.0,1472.0,1.0,41.0,98.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
924,31102,DecoderDecode,1,DecoderDecode,"void DecoderDecode (decoder_t*,block_t*)",input\decoder.c,"static void DecoderDecode( decoder_t *p_dec, block_t *p_block )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int ret = p_dec->pf_decode( p_dec, p_block );
    switch( ret )
    {
        case VLCDEC_SUCCESS:
            p_owner->pf_update_stat( p_owner, 1, 0 );
            break;
        case VLCDEC_ECRITICAL:
            p_owner->error = true;
            break;
        case VLCDEC_RELOAD:
            RequestReload( p_dec );
            if( unlikely( p_block == NULL ) )
                break;
            if( !( p_block->i_flags & BLOCK_FLAG_CORE_PRIVATE_RELOADED ) )
            {
                p_block->i_flags |= BLOCK_FLAG_CORE_PRIVATE_RELOADED;
                DecoderProcess( p_dec, p_block );
            }
            else /* We prefer loosing this block than an infinite recursion */
                block_Release( p_block );
            break;
        default:
            vlc_assert_unreachable();
    }
}",1339.0,1367.0,1.0,38.0,29.0,14,6,23,10,0,3,8,6,0,2,,0,1,4,2,2,void
925,31403,DecoderProcessFlush,1,DecoderProcessFlush,void DecoderProcessFlush (decoder_t*),input\decoder.c,"static void DecoderProcessFlush( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    decoder_t *p_packetizer = p_owner->p_packetizer;

    if( p_owner->error )
        return;

    if( p_packetizer != NULL && p_packetizer->pf_flush != NULL )
        p_packetizer->pf_flush( p_packetizer );

    if ( p_dec->pf_flush != NULL )
        p_dec->pf_flush( p_dec );

    /* flush CC sub decoders */
    if( p_owner->cc.b_supported )
    {
        for( int i=0; i<MAX_CC_DECODERS; i++ )
        {
            decoder_t *p_subdec = p_owner->cc.pp_decoder[i];
            if( p_subdec && p_subdec->pf_flush )
                p_subdec->pf_flush( p_subdec );
        }
    }

#ifdef ENABLE_SOUT
    if ( p_owner->p_sout_input != NULL )
    {
        sout_InputFlush( p_owner->p_sout_input );
    }
#endif
    if( p_dec->fmt_out.i_cat == AUDIO_ES )
    {
        if( p_owner->p_aout )
            aout_DecFlush( p_owner->p_aout, false );
    }
    else if( p_dec->fmt_out.i_cat == VIDE...",1474.0,1532.0,1.0,24.0,59.0,35,9,34,9,1,10,9,13,2,3,,0,7,2,1,1,void
926,31596,DecoderThread,1,DecoderThread,void* DecoderThread (void*),input\decoder.c,"static void *DecoderThread( void *p_data )
{
    decoder_t *p_dec = (decoder_t *)p_data;
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool paused = false;

    /* The decoder's main loop */
    vlc_fifo_Lock( p_owner->p_fifo );
    vlc_fifo_CleanupPush( p_owner->p_fifo );

    for( ;; )
    {
        if( p_owner->flushing )
        {   /* Flush before/regardless of pause. We do not want to resume just
             * for the sake of flushing (glitches could otherwise happen). */
            int canc = vlc_savecancel();

            vlc_fifo_Unlock( p_owner->p_fifo );

            /* Flush the decoder (and the output) */
            DecoderProcessFlush( p_dec );

            vlc_fifo_Lock( p_owner->p_fifo );
            vlc_restorecancel( canc );

            /* Reset flushing after DecoderProcess in case input_DecoderFlush
             * is called again. This will avoid a second useless flush (but
             * harmless). */
            p_owner->flushing = false;

        ...",1539.0,1645.0,1.0,1.0,107.0,74,9,80,10,0,66,16,26,9,28,,0,42,2,1,1,void*
927,31867,CreateDecoder,1,CreateDecoder,"decoder_t CreateDecoder (vlc_object_t*,input_thread_t*,es_format_t*,input_resource_t*,sout_instance_t*)",misc\image.c,"static decoder_t *CreateDecoder( vlc_object_t *p_this, const video_format_t *fmt )
{
    decoder_t *p_dec;

    p_dec = vlc_custom_create( p_this, sizeof( *p_dec ), ""image decoder"" );
    if( p_dec == NULL )
        return NULL;

    p_dec->p_module = NULL;
    es_format_InitFromVideo( &p_dec->fmt_in, fmt );
    es_format_Init( &p_dec->fmt_out, VIDEO_ES, 0 );
    p_dec->b_frame_drop_allowed = false;

    p_dec->pf_vout_format_update = video_update_format;
    p_dec->pf_vout_buffer_new = video_new_buffer;

    /* Find a suitable decoder module */
    p_dec->p_module = module_need( p_dec, ""video decoder"", ""$codec"", false );
    if( !p_dec->p_module )
    {
        msg_Err( p_dec, ""no suitable decoder module for fourcc `%4.4s'. ""
                 ""VLC probably does not support this image format."",
                 (char*)&p_dec->fmt_in.i_codec );

        DeleteDecoder( p_dec );
        return NULL;
    }

    return p_dec;
}",671.0,700.0,1.0,1.0,30.0,183,12,148,21,1,55,17,22,5,15,,0,45,4,2,2,decoder_t
928,32427,DeleteDecoder,1,DeleteDecoder,void DeleteDecoder (decoder_t*),misc\image.c,"static void DeleteDecoder( decoder_t * p_dec )
{
    if( p_dec->p_module ) module_unneed( p_dec, p_dec->p_module );

    es_format_Clean( &p_dec->fmt_in );
    es_format_Clean( &p_dec->fmt_out );

    if( p_dec->p_description )
        vlc_meta_Delete( p_dec->p_description );

    vlc_object_release( p_dec );
    p_dec = NULL;
}",702.0,714.0,1.0,1.0,13.0,48,7,50,8,4,50,10,15,7,22,,0,29,2,1,1,void
929,32611,DecoderUnsupportedCodec,1,DecoderUnsupportedCodec,"void DecoderUnsupportedCodec (decoder_t*,es_format_t*,bool)",input\decoder.c,"static void DecoderUnsupportedCodec( decoder_t *p_dec, const es_format_t *fmt, bool b_decoding )
{
    if (fmt->i_codec != VLC_CODEC_UNKNOWN && fmt->i_codec) {
        const char *desc = vlc_fourcc_GetDescription(fmt->i_cat, fmt->i_codec);
        if (!desc || !*desc)
            desc = N_(""No description for this codec"");
        msg_Err( p_dec, ""Codec `%4.4s' (%s) is not supported."", (char*)&fmt->i_codec, desc );
        vlc_dialog_display_error( p_dec, _(""Codec not supported""),
            _(""VLC could not decode the format \""%4.4s\"" (%s)""),
            (char*)&fmt->i_codec, desc );
    } else if( b_decoding ){
        msg_Err( p_dec, ""could not identify codec"" );
        vlc_dialog_display_error( p_dec, _(""Unidentified codec""),
            _(""VLC could not identify the audio or video codec"" ) );
    }
}",1888.0,1903.0,1.0,1.0,16.0,18,9,15,4,1,2,3,4,0,2,,0,1,6,3,3,void
930,32688,decoder_New,1,decoder_New,"decoder_t decoder_New (vlc_object_t*,input_thread_t*,es_format_t*,input_clock_t*,input_resource_t*,sout_instance_t*)",input\decoder.c,"static decoder_t *decoder_New( vlc_object_t *p_parent, input_thread_t *p_input,
                               const es_format_t *fmt, input_clock_t *p_clock,
                               input_resource_t *p_resource,
                               sout_instance_t *p_sout  )
{
    decoder_t *p_dec = NULL;
    const char *psz_type = p_sout ? N_(""packetizer"") : N_(""decoder"");
    int i_priority;

    /* Create the decoder configuration structure */
    p_dec = CreateDecoder( p_parent, p_input, fmt, p_resource, p_sout );
    if( p_dec == NULL )
    {
        msg_Err( p_parent, ""could not create %s"", psz_type );
        vlc_dialog_display_error( p_parent, _(""Streaming / Transcoding failed""),
            _(""VLC could not open the %s module.""), vlc_gettext( psz_type ) );
        return NULL;
    }

    if( !p_dec->p_module )
    {
        DecoderUnsupportedCodec( p_dec, fmt, !p_sout );

        DeleteDecoder( p_dec );
        return NULL;
    }

    p_dec->p_owner->p_clock = p_clock;
  ...",1906.0,1950.0,1.0,1.0,45.0,21,8,38,13,2,7,5,5,1,7,,0,3,12,6,6,decoder_t
931,32807,input_DecoderNew,1,input_DecoderNew,"decoder_t input_DecoderNew (input_thread_t*,es_format_t*,input_clock_t*,sout_instance_t*)",input\decoder.c,"decoder_t *input_DecoderNew( input_thread_t *p_input,
                             es_format_t *fmt, input_clock_t *p_clock,
                             sout_instance_t *p_sout  )
{
    return decoder_New( VLC_OBJECT(p_input), p_input, fmt, p_clock,
                        input_priv(p_input)->p_resource, p_sout );
}",1960.0,1966.0,1.0,1.0,7.0,1,1,6,4,3,2,1,1,0,2,,0,1,8,4,4,decoder_t
932,32827,input_DecoderCreate,1,input_DecoderCreate,"decoder_t input_DecoderCreate (vlc_object_t*,es_format_t*,input_resource_t*)",input\decoder.c,"decoder_t *input_DecoderCreate( vlc_object_t *p_parent, const es_format_t *fmt,
                                input_resource_t *p_resource )
{
    return decoder_New( p_parent, NULL, fmt, NULL, p_resource, NULL );
}",1971.0,1975.0,1.0,1.0,5.0,0,0,6,4,0,1,1,1,0,1,,0,0,6,3,3,decoder_t
933,32842,input_DecoderDelete,1,input_DecoderDelete,void input_DecoderDelete (decoder_t*),input\decoder.c,"void input_DecoderDelete( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_cancel( p_owner->thread );

    vlc_fifo_Lock( p_owner->p_fifo );
    /* Signal DecoderTimedWait */
    p_owner->flushing = true;
    vlc_cond_signal( &p_owner->wait_timed );
    vlc_fifo_Unlock( p_owner->p_fifo );

    /* Make sure we aren't waiting/decoding anymore */
    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );

    /* If the video output is paused or slow, or if the picture pool size was
     * under-estimated (e.g. greedy video filter, buggy decoder...), the
     * the picture pool may be empty, and the decoder thread or any decoder
     * module worker threads may be stuck waiting for free picture buffers.
     *
     * This unblocks the thread, allowing the decoder module to join all its
     * worker threads (if any) and the decoder thread to terminate. */
    if( p_owner->p_vout != NULL )
        v...",1985.0,2024.0,1.0,28.0,40.0,26,6,23,6,2,22,4,5,1,10,,0,12,2,1,1,void
934,32941,input_DecoderDecode,1,input_DecoderDecode,"void input_DecoderDecode (decoder_t*,block_t*,bool)",input\decoder.c,"void input_DecoderDecode( decoder_t *p_dec, block_t *p_block, bool b_do_pace )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !b_do_pace )
    {
        /* FIXME: ideally we would check the time amount of data
         * in the FIFO instead of its size. */
        /* 400 MiB, i.e. ~ 50mb/s for 60s */
        if( vlc_fifo_GetBytes( p_owner->p_fifo ) > 400*1024*1024 )
        {
            msg_Warn( p_dec, ""decoder/packetizer fifo full (data not ""
                      ""consumed quickly enough), resetting fifo!"" );
            block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );
            p_block->i_flags |= BLOCK_FLAG_DISCONTINUITY;
        }
    }
    else
    if( !p_owner->b_waiting )
    {   /* The FIFO is not consumed when waiting, so pacing would deadlock VLC.
         * Locking is not necessary as b_waiting is only read, not written by
         * the decoder thread. */
        while( vlc_fifo_GetCount( p_ow...",2033.0,2062.0,1.0,1.0,30.0,12,5,12,5,0,10,3,4,2,5,,0,6,6,3,3,void
935,33019,input_DecoderIsEmpty,1,input_DecoderIsEmpty,bool input_DecoderIsEmpty (decoder_t*),input\decoder.c,"bool input_DecoderIsEmpty( decoder_t * p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_fifo_Lock( p_owner->p_fifo );
    if( !vlc_fifo_IsEmpty( p_dec->p_owner->p_fifo ) || p_owner->b_draining )
    {
        vlc_fifo_Unlock( p_owner->p_fifo );
        return false;
    }
    vlc_fifo_Unlock( p_owner->p_fifo );

    bool b_empty;

    vlc_mutex_lock( &p_owner->lock );
#ifdef ENABLE_SOUT
    if( p_owner->p_sout_input != NULL )
        b_empty = sout_InputIsEmpty( p_owner->p_sout_input );
    else
#endif
    if( p_owner->fmt.i_cat == VIDEO_ES && p_owner->p_vout != NULL )
        b_empty = vout_IsEmpty( p_owner->p_vout );
    else if( p_owner->fmt.i_cat == AUDIO_ES )
        b_empty = !p_owner->b_draining || p_owner->drained;
    else
        b_empty = true; /* TODO subtitles support */
    vlc_mutex_unlock( &p_owner->lock );

    return b_empty;
}",2064.0,2095.0,1.0,1.0,32.0,24,9,18,6,2,16,3,3,3,6,,0,11,2,1,1,bool
936,33122,input_DecoderDrain,1,input_DecoderDrain,void input_DecoderDrain (decoder_t*),input\decoder.c,"void input_DecoderDrain( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->b_draining = true;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",2105.0,2113.0,1.0,1.0,9.0,7,2,7,3,1,7,1,1,0,3,,0,4,2,1,1,void
937,33150,input_DecoderFlush,1,input_DecoderFlush,void input_DecoderFlush (decoder_t*),input\decoder.c,"void input_DecoderFlush( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_fifo_Lock( p_owner->p_fifo );

    /* Empty the fifo */
    block_ChainRelease( vlc_fifo_DequeueAllUnlocked( p_owner->p_fifo ) );

    /* Don't need to wait for the DecoderThread to flush. Indeed, if called a
     * second time, this function will clear the FIFO again before anything was
     * dequeued by DecoderThread and there is no need to flush a second time in
     * a row. */
    p_owner->flushing = true;

    /* Flush video/spu decoder when paused: increment frames_countdown in order
     * to display one frame/subtitle */
    if( p_owner->paused
     && ( p_owner->fmt.i_cat == VIDEO_ES || p_owner->fmt.i_cat == SPU_ES )
     && p_owner->frames_countdown == 0 )
        p_owner->frames_countdown++;

    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_cond_signal( &p_owner->wait_timed );

    vlc_fifo_Unlock( p_owner->p_fifo );
}",2119.0,2145.0,1.0,1.0,27.0,24,8,16,5,1,16,2,2,4,5,,0,11,2,1,1,void
938,33219,input_DecoderGetCcDesc,1,input_DecoderGetCcDesc,"void input_DecoderGetCcDesc (decoder_t*,decoder_cc_desc_t*)",input\decoder.c,"void input_DecoderGetCcDesc( decoder_t *p_dec, decoder_cc_desc_t *p_desc )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    *p_desc = p_owner->cc.desc;
    vlc_mutex_unlock( &p_owner->lock );
}",2147.0,2154.0,1.0,1.0,8.0,10,5,6,3,0,4,1,1,0,2,,0,2,4,2,2,void
939,33249,input_DecoderHasCCChanFlag,1,input_DecoderHasCCChanFlag,"bool input_DecoderHasCCChanFlag (decoder_t*,vlc_fourcc_t,int)",input\decoder.c,"static bool input_DecoderHasCCChanFlag( decoder_t *p_dec,
                                        vlc_fourcc_t codec, int i_channel )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    int i_max_channels;
    uint64_t i_bitmap;
    if( codec == VLC_CODEC_CEA608 )
    {
        i_max_channels = 4;
        i_bitmap = p_owner->cc.desc.i_608_channels;
    }
    else if( codec == VLC_CODEC_CEA708 )
    {
        i_max_channels = 64;
        i_bitmap = p_owner->cc.desc.i_708_channels;
    }
    else return false;

    return ( i_channel >= 0 && i_channel < i_max_channels &&
             ( i_bitmap & ((uint64_t)1 << i_channel) ) );
}",2156.0,2177.0,1.0,1.0,22.0,15,10,12,7,2,0,2,2,0,0,,0,0,6,3,3,bool
940,33320,input_DecoderSetCcState,1,input_DecoderSetCcState,"int input_DecoderSetCcState (decoder_t*,vlc_fourcc_t,int,bool)",input\decoder.c,"int input_DecoderSetCcState( decoder_t *p_dec, vlc_fourcc_t codec,
                             int i_channel, bool b_decode )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    //msg_Warn( p_dec, ""input_DecoderSetCcState: %d @%x"", b_decode, i_channel );

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    if( b_decode )
    {
        decoder_t *p_cc;
        es_format_t fmt;

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i_channel;
        fmt.subs.cc.i_reorder_depth = p_owner->cc.desc.i_reorder_depth;
        p_cc = input_DecoderNew( p_owner->p_input, &fmt,
                              p_dec->p_owner->p_clock, p_owner->p_sout );
        if( !p_cc )
        {
            msg_Err( p_dec, ""could not create decoder"" );
            vlc_dialog_display_error( p_dec,
                _(""Streaming / Transcoding failed""), ""%s"",
                _(""VLC could not open the decoder module."") );
            ret...",2179.0,2232.0,1.0,1.0,54.0,34,6,31,10,0,11,4,5,1,6,,0,7,8,4,4,int
941,33492,input_DecoderGetCcState,1,input_DecoderGetCcState,"int input_DecoderGetCcState (decoder_t*,vlc_fourcc_t,int,bool*)",input\decoder.c,"int input_DecoderGetCcState( decoder_t *p_dec, vlc_fourcc_t codec,
                             int i_channel, bool *pb_decode )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    if( !input_DecoderHasCCChanFlag( p_dec, codec, i_channel ) )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_owner->lock );
    *pb_decode = p_owner->cc.pp_decoder[i_channel] != NULL;
    vlc_mutex_unlock( &p_owner->lock );
    return VLC_SUCCESS;
}",2234.0,2246.0,1.0,1.0,13.0,13,8,13,8,0,5,2,2,1,3,,0,3,8,4,4,int
942,33539,input_DecoderChangePause,1,input_DecoderChangePause,"void input_DecoderChangePause (decoder_t*,bool,mtime_t)",input\decoder.c,"void input_DecoderChangePause( decoder_t *p_dec, bool b_paused, mtime_t i_date )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    /* Normally, p_owner->b_paused != b_paused here. But if a track is added
     * while the input is paused (e.g. add sub file), then b_paused is
     * (incorrectly) false. FIXME: This is a bug in the decoder owner. */
    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->paused = b_paused;
    p_owner->pause_date = i_date;
    p_owner->frames_countdown = 0;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );
}",2248.0,2261.0,1.0,1.0,14.0,11,2,10,4,0,9,1,1,0,3,,0,6,6,3,3,void
943,33579,input_DecoderChangeDelay,1,input_DecoderChangeDelay,"void input_DecoderChangeDelay (decoder_t*,mtime_t)",input\decoder.c,"void input_DecoderChangeDelay( decoder_t *p_dec, mtime_t i_delay )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    p_owner->i_ts_delay = i_delay;
    vlc_mutex_unlock( &p_owner->lock );
}",2263.0,2270.0,1.0,1.0,8.0,8,3,6,3,0,5,1,1,0,2,,0,3,4,2,2,void
944,33606,input_DecoderStartWait,1,input_DecoderStartWait,void input_DecoderStartWait (decoder_t*),input\decoder.c,"void input_DecoderStartWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( !p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_first = true;
    p_owner->b_has_data = false;
    p_owner->b_waiting = true;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",2272.0,2284.0,1.0,1.0,13.0,16,4,12,4,4,10,1,1,0,3,,0,7,2,1,1,void
945,33652,input_DecoderStopWait,1,input_DecoderStopWait,void input_DecoderStopWait (decoder_t*),input\decoder.c,"void input_DecoderStopWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    p_owner->b_waiting = false;
    vlc_cond_signal( &p_owner->wait_request );
    vlc_mutex_unlock( &p_owner->lock );
}",2286.0,2296.0,1.0,1.0,11.0,11,3,8,3,0,8,1,1,0,3,,0,5,2,1,1,void
946,33687,input_DecoderWait,1,input_DecoderWait,void input_DecoderWait (decoder_t*),input\decoder.c,"void input_DecoderWait( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->b_waiting );

    vlc_mutex_lock( &p_owner->lock );
    while( !p_owner->b_has_data )
    {
        /* Don't need to lock p_owner->paused since it's only modified by the
         * owner */
        if( p_owner->paused )
            break;
        vlc_fifo_Lock( p_owner->p_fifo );
        if( p_owner->b_idle && vlc_fifo_IsEmpty( p_owner->p_fifo ) )
        {
            msg_Err( p_dec, ""buffer deadlock prevented"" );
            vlc_fifo_Unlock( p_owner->p_fifo );
            break;
        }
        vlc_fifo_Unlock( p_owner->p_fifo );
        vlc_cond_wait( &p_owner->wait_acknowledge, &p_owner->lock );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",2298.0,2322.0,1.0,1.0,25.0,20,5,15,2,0,18,6,6,4,6,,0,12,2,1,1,void
947,33759,input_DecoderFrameNext,1,input_DecoderFrameNext,"void input_DecoderFrameNext (decoder_t*,mtime_t*)",input\decoder.c,"void input_DecoderFrameNext( decoder_t *p_dec, mtime_t *pi_duration )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    assert( p_owner->paused );
    *pi_duration = 0;

    vlc_fifo_Lock( p_owner->p_fifo );
    p_owner->frames_countdown++;
    vlc_fifo_Signal( p_owner->p_fifo );
    vlc_fifo_Unlock( p_owner->p_fifo );

    vlc_mutex_lock( &p_owner->lock );
    if( p_owner->fmt.i_cat == VIDEO_ES )
    {
        if( p_owner->p_vout )
            vout_NextPicture( p_owner->p_vout, pi_duration );
    }
    vlc_mutex_unlock( &p_owner->lock );
}",2324.0,2343.0,1.0,1.0,20.0,19,7,15,4,1,16,3,4,2,6,,0,10,4,2,2,void
948,33824,input_DecoderHasFormatChanged,1,input_DecoderHasFormatChanged,"bool input_DecoderHasFormatChanged (decoder_t*,es_format_t*,vlc_meta_t**)",input\decoder.c,"bool input_DecoderHasFormatChanged( decoder_t *p_dec, es_format_t *p_fmt, vlc_meta_t **pp_meta )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;
    bool b_changed;

    vlc_mutex_lock( &p_owner->lock );
    b_changed = p_owner->b_fmt_description;
    if( b_changed )
    {
        if( p_fmt != NULL )
            es_format_Copy( p_fmt, &p_owner->fmt );

        if( pp_meta )
        {
            *pp_meta = NULL;
            if( p_owner->p_description )
            {
                *pp_meta = vlc_meta_New();
                if( *pp_meta )
                    vlc_meta_Merge( *pp_meta, p_owner->p_description );
            }
        }
        p_owner->b_fmt_description = false;
    }
    vlc_mutex_unlock( &p_owner->lock );
    return b_changed;
}",2345.0,2371.0,1.0,1.0,27.0,21,5,22,7,0,12,6,13,1,5,,0,8,6,3,3,bool
949,33900,input_DecoderGetFifoSize,1,input_DecoderGetFifoSize,size_t input_DecoderGetFifoSize (decoder_t*),input\decoder.c,"size_t input_DecoderGetFifoSize( decoder_t *p_dec )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    return block_FifoSize( p_owner->p_fifo );
}",2373.0,2378.0,1.0,1.0,6.0,3,2,3,2,2,2,1,1,0,1,,0,1,2,1,1,size_t
950,33916,input_DecoderGetObjects,1,input_DecoderGetObjects,"void input_DecoderGetObjects (decoder_t*,vout_thread_t**,audio_output_t**)",input\decoder.c,"void input_DecoderGetObjects( decoder_t *p_dec,
                              vout_thread_t **pp_vout, audio_output_t **pp_aout )
{
    decoder_owner_sys_t *p_owner = p_dec->p_owner;

    vlc_mutex_lock( &p_owner->lock );
    if( pp_vout )
        *pp_vout = p_owner->p_vout ? vlc_object_hold( p_owner->p_vout ) : NULL;
    if( pp_aout )
        *pp_aout = p_owner->p_aout ? vlc_object_hold( p_owner->p_aout ) : NULL;
    vlc_mutex_unlock( &p_owner->lock );
}",2380.0,2391.0,1.0,1.0,12.0,16,5,14,5,1,10,3,3,0,4,,0,8,6,3,3,void
951,34105,demux_mapping_cmp,1,demux_mapping_cmp,"int demux_mapping_cmp (void*,void*)",input\demux.c,"static int demux_mapping_cmp( const void *k, const void *v )
{
    demux_mapping* entry = v;
    return vlc_ascii_strcasecmp( k, entry->key );
}",46.0,50.0,1.0,1.0,5.0,2,2,4,3,0,1,1,1,0,0,,0,1,4,2,2,int
952,34121,demux_lookup,1,demux_lookup,"demux_mapping demux_lookup (char*,demux_mapping*,size_t)",input\demux.c,"static demux_mapping* demux_lookup( char const* key,
                                    demux_mapping* data, size_t size )
{
    return bsearch( key, data, size, sizeof( *data ), demux_mapping_cmp );
}",52.0,56.0,1.0,1.0,5.0,2,2,4,3,2,0,1,1,0,0,,0,0,6,3,3,demux_mapping
953,34137,demux_NameFromMimeType,1,demux_NameFromMimeType,const char* demux_NameFromMimeType (char*),input\demux.c,"static const char *demux_NameFromMimeType(const char *mime)
{
    static demux_mapping types[] =
    {   /* Must be sorted in ascending ASCII order */
        { ""audio/aac"",           ""m4a""     },
        { ""audio/aacp"",          ""m4a""     },
        { ""audio/mpeg"",          ""mp3""     },
        //{ ""video/MP1S"",          ""es,mpgv"" }, !b_force
        { ""video/dv"",            ""rawdv""   },
        { ""video/MP2P"",          ""ps""      },
        { ""video/MP2T"",          ""ts""      },
        { ""video/nsa"",           ""nsv""     },
        { ""video/nsv"",           ""nsv""     },
    };
    demux_mapping *type = demux_lookup( mime, types, ARRAY_SIZE( types ) );
    return (type != NULL) ? type->name : ""any"";
}",58.0,74.0,1.0,1.0,17.0,14,5,8,4,1,2,1,1,0,1,,0,2,2,1,1,const char*
954,34187,DemuxNameFromExtension,1,DemuxNameFromExtension,"const char* DemuxNameFromExtension (char*,bool)",input\demux.c,"static const char* DemuxNameFromExtension( char const* ext,
                                           bool b_preparsing )
{
    /* NOTE: Add only file without any problems here and with strong detection:
     * - no .mp3, .a52, ...
     *  - wav can't be added 'cause of a52 and dts in them as raw audio
     */
    static demux_mapping strong[] =
    { /* NOTE: must be sorted in asc order */
        { ""aiff"", ""aiff"" },
        { ""asf"",  ""asf"" },
        { ""au"",   ""au"" },
        { ""avi"",  ""avi"" },
        { ""drc"",  ""dirac"" },
        { ""dv"",   ""dv"" },
        { ""flac"", ""flac"" },
        { ""h264"", ""h264"" },
        { ""kar"", ""smf"" },
        { ""m3u"",  ""m3u"" },
        { ""m4a"",  ""mp4"" },
        { ""m4v"",  ""m4v"" },
        { ""mid"",  ""smf"" },
        { ""mka"",  ""mkv"" },
        { ""mks"",  ""mkv"" },
        { ""mkv"",  ""mkv"" },
        { ""moov"", ""mp4"" },
        { ""mov"",  ""mp4"" },
        { ""mp4"",  ""mp4"" },
        { ""nsv"",  ""nsv"" },
        { ""oga"",  ""ogg"" },
        { ""ogg"",  ""ogg"" },
      ...",76.0,139.0,1.0,1.0,64.0,51,5,18,9,1,2,1,1,0,1,,0,2,4,2,2,const char*
955,34347,demux_New,1,demux_New,"demux_t demux_New (vlc_object_t*,char*,char*,stream_t*,es_out_t*)",input\demux.c,"demux_t *demux_New( vlc_object_t *p_obj, const char *psz_name,
                    const char *psz_location, stream_t *s, es_out_t *out )
{
    return demux_NewAdvanced( p_obj, NULL,
                              (s == NULL) ? psz_name : """",
                              (s != NULL) ? psz_name : """",
                              psz_location, s, out, false );
}",145.0,152.0,1.0,11.0,8.0,4,3,18,7,0,1,1,1,0,1,,0,0,10,5,5,demux_t
956,34387,destroy,1,demux_priv_t.destroy,void demux_priv_t.destroy (demux_t*),input\demux.c,void (*destroy)(demux_t *);,157.0,157.0,10.0,30.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
957,34393,demux_DestroyDemux,1,demux_DestroyDemux,void demux_DestroyDemux (demux_t*),input\demux.c,"static void demux_DestroyDemux(demux_t *demux)
{
    assert(demux->s != NULL);
    vlc_stream_Delete(demux->s);
}",160.0,164.0,1.0,1.0,5.0,3,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
958,34422,demux_DestroyDemuxFilter,1,demux_DestroyDemuxFilter,void demux_DestroyDemuxFilter (demux_t*),input\demux.c,"static void demux_DestroyDemuxFilter(demux_t *demux)
{
    assert(demux->p_next != NULL);
    demux_Delete(demux->p_next);
}",172.0,176.0,1.0,1.0,5.0,3,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
959,34437,demux_Probe,1,demux_Probe,"int demux_Probe (void*,va_list)",input\demux.c,"static int demux_Probe(void *func, va_list ap)
{
    int (*probe)(vlc_object_t *) = func;
    demux_t *demux = va_arg(ap, demux_t *);

    /* Restore input stream offset (in case previous probed demux failed to
     * to do so). */
    if (vlc_stream_Tell(demux->s) != 0 && vlc_stream_Seek(demux->s, 0))
    {
        msg_Err(demux, ""seek failure before probing"");
        return VLC_EGENERIC;
    }

    return probe(VLC_OBJECT(demux));
}",178.0,192.0,1.0,1.0,15.0,4,3,5,2,0,2,2,2,2,2,,0,2,4,2,2,int
960,34472,demux_NewAdvanced,1,demux_NewAdvanced,"demux_t demux_NewAdvanced (vlc_object_t*,input_thread_t*,char*,char*,char*,stream_t*,es_out_t*,bool)",input\demux.c,"demux_t *demux_NewAdvanced( vlc_object_t *p_obj, input_thread_t *p_parent_input,
                            const char *psz_access, const char *psz_demux,
                            const char *psz_location,
                            stream_t *s, es_out_t *out, bool b_preparsing )
{
    demux_priv_t *priv = vlc_custom_create(p_obj, sizeof (*priv), ""demux"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    if( s != NULL && (!strcasecmp( psz_demux, ""any"" ) || !psz_demux[0]) )
    {   /* Look up demux by mime-type for hard to detect formats */
        char *type = stream_MimeType( s );
        if( type != NULL )
        {
            psz_demux = demux_NameFromMimeType( type );
            free( type );
        }
    }

    p_demux->p_input = p_parent_input;
    p_demux->psz_access = strdup( psz_access );
    p_demux->psz_demux = strdup( psz_demux );
    p_demux->psz_location = strdup( psz_location );
    p_demux->psz_file = get_path( p...",199.0,284.0,1.0,1.0,86.0,86,14,89,14,4,7,13,16,0,6,,0,6,16,8,8,demux_t
961,34776,demux_Delete,1,demux_Delete,void demux_Delete (demux_t*),input\demux.c,"void demux_Delete( demux_t *p_demux )
{
    demux_priv_t *priv = (demux_priv_t *)p_demux;

    module_unneed( p_demux, p_demux->p_module );

    priv->destroy(p_demux);
    free( p_demux->psz_file );
    free( p_demux->psz_location );
    free( p_demux->psz_demux );
    free( p_demux->psz_access );
    vlc_object_release( p_demux );
}",289.0,301.0,1.0,1.0,13.0,8,3,11,2,2,3,1,1,0,3,,0,0,2,1,1,void
962,34815,demux_ControlInternal,1,demux_ControlInternal,"int demux_ControlInternal (demux_t*,int...)",input\demux.c,"static int demux_ControlInternal( demux_t *demux, int query, ... )
{
    int ret;
    va_list ap;

    va_start( ap, query );
    ret = demux->pf_control( demux, query, ap );
    va_end( ap );
    return ret;
}",306.0,315.0,1.0,1.0,10.0,2,2,9,4,1,0,1,1,0,0,,0,0,4,2,2,int
963,34839,demux_vaControl,1,demux_vaControl,"int demux_vaControl (demux_t*,int,va_list)",input\demux.c,"int demux_vaControl( demux_t *demux, int query, va_list args )
{
    if( demux->s != NULL )
        switch( query )
        {
            /* Legacy fallback for missing getters in synchronous demuxers */
            case DEMUX_CAN_PAUSE:
            case DEMUX_CAN_CONTROL_PACE:
            case DEMUX_GET_PTS_DELAY:
            {
                int ret;
                va_list ap;

                va_copy( ap, args );
                ret = demux->pf_control( demux, query, args );
                if( ret != VLC_SUCCESS )
                    ret = vlc_stream_vaControl( demux->s, query, ap );
                va_end( ap );
                return ret;
            }

            /* Some demuxers need to control pause directly (e.g. adaptive),
             * but many legacy demuxers do not understand pause at all.
             * If DEMUX_CAN_PAUSE is not implemented, bypass the demuxer and
             * byte stream. If DEMUX_CAN_PAUSE is implemented and pause is
             * supported, ...",317.0,366.0,1.0,1.0,50.0,10,4,33,12,0,3,6,10,1,3,,0,2,6,3,3,int
964,34923,demux_vaControlHelper,1,demux_vaControlHelper,"int demux_vaControlHelper (stream_t*,int64_t,int64_t,int64_t,int,int,va_list)",input\demux.c,"int demux_vaControlHelper( stream_t *s,
                            int64_t i_start, int64_t i_end,
                            int64_t i_bitrate, int i_align,
                            int i_query, va_list args )
{
    int64_t i_tell;
    double  f, *pf;
    int64_t i64, *pi64;

    if( i_end < 0 )    i_end   = stream_Size( s );
    if( i_start < 0 )  i_start = 0;
    if( i_align <= 0 ) i_align = 1;
    i_tell = vlc_stream_Tell( s );

    static_control_match(CAN_PAUSE);
    static_control_match(CAN_CONTROL_PACE);
    static_control_match(GET_PTS_DELAY);
    static_control_match(GET_META);
    static_control_match(GET_SIGNAL);
    static_control_match(SET_PAUSE_STATE);

    switch( i_query )
    {
        case DEMUX_CAN_SEEK:
        {
            bool *b = va_arg( args, bool * );

            if( (i_bitrate <= 0 && i_start >= i_end)
             || vlc_stream_Control( s, STREAM_CAN_SEEK, b ) )
                *b = false;
            break;
        }

        case DEMUX_CAN_PAUSE...",371.0,503.0,1.0,4.0,133.0,71,14,135,62,0,4,14,23,2,4,,0,3,14,7,7,int
965,35295,demux_PacketizerNew,1,demux_PacketizerNew,"decoder_t demux_PacketizerNew (demux_t*,es_format_t*,char*)",input\demux.c,"decoder_t *demux_PacketizerNew( demux_t *p_demux, es_format_t *p_fmt, const char *psz_msg )
{
    decoder_t *p_packetizer;
    p_packetizer = vlc_custom_create( p_demux, sizeof( *p_packetizer ),
                                      ""demux packetizer"" );
    if( !p_packetizer )
    {
        es_format_Clean( p_fmt );
        return NULL;
    }
    p_fmt->b_packetized = false;

    p_packetizer->pf_decode = NULL;
    p_packetizer->pf_packetize = NULL;

    p_packetizer->fmt_in = *p_fmt;
    es_format_Init( &p_packetizer->fmt_out, p_fmt->i_cat, 0 );

    p_packetizer->p_module = module_need( p_packetizer, ""packetizer"", NULL, false );
    if( !p_packetizer->p_module )
    {
        es_format_Clean( p_fmt );
        vlc_object_release( p_packetizer );
        msg_Err( p_demux, ""cannot find packetizer for %s"", psz_msg );
        return NULL;
    }

    return p_packetizer;
}",508.0,536.0,1.0,1.0,29.0,20,6,27,6,0,6,3,3,0,6,,0,2,6,3,3,decoder_t
966,35376,demux_PacketizerDestroy,1,demux_PacketizerDestroy,void demux_PacketizerDestroy (decoder_t*),input\demux.c,"void demux_PacketizerDestroy( decoder_t *p_packetizer )
{
    if( p_packetizer->p_module )
        module_unneed( p_packetizer, p_packetizer->p_module );
    es_format_Clean( &p_packetizer->fmt_in );
    es_format_Clean( &p_packetizer->fmt_out );
    if( p_packetizer->p_description )
        vlc_meta_Delete( p_packetizer->p_description );
    vlc_object_release( p_packetizer );
}",538.0,547.0,1.0,1.0,10.0,8,2,8,1,0,5,3,3,0,5,,0,0,2,1,1,void
967,35412,demux_TestAndClearFlags,1,demux_TestAndClearFlags,"unsigned demux_TestAndClearFlags (demux_t*,unsigned)",input\demux.c,"unsigned demux_TestAndClearFlags( demux_t *p_demux, unsigned flags )
{
    unsigned update = flags;

    if ( demux_Control( p_demux, DEMUX_TEST_AND_CLEAR_FLAGS, &update ) == VLC_SUCCESS )
        return update;

    update = p_demux->info.i_update & flags;
    p_demux->info.i_update &= ~flags;
    return update;
}",549.0,559.0,1.0,1.0,11.0,10,7,13,5,2,0,2,2,0,0,,0,0,4,2,2,unsigned
968,35498,demux_FilterNew,1,demux_FilterNew,"demux_t demux_FilterNew (demux_t*,char*)",input\demux.c,"static demux_t *demux_FilterNew( demux_t *p_next, const char *p_name )
{
    demux_priv_t *priv = vlc_custom_create(p_next, sizeof (*priv), ""demux_filter"");
    if (unlikely(priv == NULL))
        return NULL;

    demux_t *p_demux = &priv->demux;

    p_demux->p_next       = p_next;
    p_demux->p_input      = NULL;
    p_demux->p_sys        = NULL;
    p_demux->psz_access   = NULL;
    p_demux->psz_demux    = NULL;
    p_demux->psz_location = NULL;
    p_demux->psz_file     = NULL;
    p_demux->out          = NULL;
    priv->destroy         = demux_DestroyDemuxFilter;
    p_demux->p_module =
        module_need( p_demux, ""demux_filter"", p_name, p_name != NULL );

    if( p_demux->p_module == NULL )
        goto error;

    return p_demux;
error:
    vlc_object_release( p_demux );
    return NULL;
}",577.0,604.0,1.0,1.0,28.0,30,7,35,5,1,4,4,3,0,3,,0,3,4,2,2,demux_t
969,35599,demux_FilterChainNew,1,demux_FilterChainNew,"demux_t demux_FilterChainNew (demux_t*,char*)",input\demux.c,"demux_t *demux_FilterChainNew( demux_t *p_demux, const char *psz_chain )
{
    if( !psz_chain || !*psz_chain )
        return NULL;

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        demux_t *filter = demux_FilterNew(p_demux, psz_name);
        if (filter != NULL)
            p_demux = filter;

        free(psz_name);
        config_ChainDestroy(p_cfg);
    }

    return p_demux;
}",606.0,633.0,1.0,1.0,28.0,13,6,25,8,1,3,5,6,0,3,,0,2,4,2,2,demux_t
970,35665,demux_filter_enable_disable,1,demux_filter_enable_disable,"bool demux_filter_enable_disable (demux_t*,char*,bool)",input\demux.c,"static bool demux_filter_enable_disable( demux_t *p_demux_chain,
                                          const char* psz_demux, bool b_enable )
{
    demux_t *p_demux = p_demux_chain;

     if( strcmp( module_get_name( p_demux->p_module, false ), psz_demux) == 0 ||
         strcmp( module_get_name( p_demux->p_module, true ), psz_demux ) == 0 )
     {
        demux_Control( p_demux,
                       b_enable ? DEMUX_FILTER_ENABLE : DEMUX_FILTER_DISABLE );
        return true;
    }
    return false;
}",635.0,648.0,1.0,1.0,14.0,7,5,14,8,2,2,2,2,2,2,,0,2,6,3,3,bool
971,35707,demux_FilterEnable,1,demux_FilterEnable,"bool demux_FilterEnable (demux_t*,char*)",input\demux.c,"bool demux_FilterEnable( demux_t *p_demux_chain, const char* psz_demux )
{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, true );
}",650.0,653.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,bool
972,35718,demux_FilterDisable,1,demux_FilterDisable,"bool demux_FilterDisable (demux_t*,char*)",input\demux.c,"bool demux_FilterDisable( demux_t *p_demux_chain, const char* psz_demux )
{
    return demux_filter_enable_disable( p_demux_chain, psz_demux, false );
}",655.0,658.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,bool
973,35823,vlc_demux_chained_Thread,1,vlc_demux_chained_Thread,void* vlc_demux_chained_Thread (void*),input\demux_chained.c,"static void *vlc_demux_chained_Thread(void *data)
{
    vlc_demux_chained_t *dc = data;
    demux_t *demux = demux_NewAdvanced(dc->fifo, NULL, """", dc->name, """",
                                       dc->fifo, dc->out, false);
    if (demux == NULL)
    {
        vlc_stream_Delete(dc->fifo);
        return NULL;
    }

    /* Stream FIFO cannot apply DVB filters.
     * Get all programs and let the E/S output sort them out. */
    demux_Control(demux, DEMUX_SET_GROUP, -1, NULL);

    /* Main loop */
    mtime_t next_update = 0;

    do
        if (demux_TestAndClearFlags(demux, UINT_MAX) || mdate() >= next_update)
        {
            double newpos;
            int64_t newlen, newtime;

            if (demux_Control(demux, DEMUX_GET_POSITION, &newpos))
                newpos = 0.;
            if (demux_Control(demux, DEMUX_GET_LENGTH, &newlen))
                newlen = 0;
            if (demux_Control(demux, DEMUX_GET_TIME, &newtime))
                newtime = 0;

            vlc_m...",53.0,96.0,1.0,21.0,44.0,38,10,50,15,0,19,3,3,7,8,,0,15,2,1,1,void*
974,35981,vlc_demux_chained_New,1,vlc_demux_chained_New,"vlc_demux_chained_t vlc_demux_chained_New (vlc_object_t*,char*,es_out_t*)",input\demux_chained.c,"vlc_demux_chained_t *vlc_demux_chained_New(vlc_object_t *parent,
                                           const char *name, es_out_t *out)
{
    vlc_demux_chained_t *dc = malloc(sizeof (*dc) + strlen(name) + 1);
    if (unlikely(dc == NULL))
        return NULL;

    dc->fifo = vlc_stream_fifo_New(parent);
    if (dc->fifo == NULL)
    {
        free(dc);
        return NULL;
    }

    dc->stats.position = 0.;
    dc->stats.length = 0;
    dc->stats.time = 0;
    dc->out = out;
    strcpy(dc->name, name);

    vlc_mutex_init(&dc->lock);

    if (vlc_clone(&dc->thread, vlc_demux_chained_Thread, dc,
                  VLC_THREAD_PRIORITY_INPUT))
    {
        vlc_stream_Delete(dc->fifo);
        vlc_stream_fifo_Close(dc->fifo);
        vlc_mutex_destroy(&dc->lock);
        free(dc);
        dc = NULL;
    }
    return dc;
}",98.0,130.0,1.0,1.0,33.0,31,8,30,6,0,15,4,4,3,6,,0,11,6,3,3,vlc_demux_chained_t
975,36091,vlc_demux_chained_Send,1,vlc_demux_chained_Send,"void vlc_demux_chained_Send (vlc_demux_chained_t*,block_t*)",input\demux_chained.c,"void vlc_demux_chained_Send(vlc_demux_chained_t *dc, block_t *block)
{
    vlc_stream_fifo_Queue(dc->fifo, block);
}",132.0,135.0,1.0,1.0,4.0,1,1,2,2,0,2,1,1,0,1,,0,1,4,2,2,void
976,36102,vlc_demux_chained_ControlVa,1,vlc_demux_chained_ControlVa,"int vlc_demux_chained_ControlVa (vlc_demux_chained_t*,int,va_list)",input\demux_chained.c,"int vlc_demux_chained_ControlVa(vlc_demux_chained_t *dc, int query, va_list ap)
{
    switch (query)
    {
        case DEMUX_GET_POSITION:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, double *) = dc->stats.position;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_LENGTH:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.length;
            vlc_mutex_unlock(&dc->lock);
            break;
        case DEMUX_GET_TIME:
            vlc_mutex_lock(&dc->lock);
            *va_arg(ap, int64_t *) = dc->stats.time;
            vlc_mutex_unlock(&dc->lock);
            break;
        default:
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",137.0,160.0,1.0,1.0,24.0,12,2,12,7,0,12,5,2,0,6,,0,6,6,3,3,int
977,36159,vlc_demux_chained_Delete,1,vlc_demux_chained_Delete,void vlc_demux_chained_Delete (vlc_demux_chained_t*),input\demux_chained.c,"void vlc_demux_chained_Delete(vlc_demux_chained_t *dc)
{
    vlc_stream_fifo_Close(dc->fifo);
    vlc_join(dc->thread, NULL);
    vlc_mutex_destroy(&dc->lock);
    free(dc);
}",162.0,168.0,1.0,1.0,7.0,4,2,5,2,0,6,1,1,0,3,,0,3,2,1,1,void
978,36312,EsOutDel,1,EsOutDel,"void EsOutDel (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsOutDel( es_out_t *out, es_out_id_t *es )
{
    es_out_sys_t *p_sys = out->p_sys;
    bool b_reselect = false;
    int i;

    vlc_mutex_lock( &p_sys->lock );

    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    /* We don't try to reselect */
    if( es->p_dec )
    {   /* FIXME: This might hold the ES output caller (i.e. the demux), and
         * the corresponding thread (typically the input thread), for a little
         * bit too long if the ES is deleted in the middle of a stream. */
        input_DecoderDrain( es->p_dec );
        while( !input_Stopped(p_sys->p_input) && !p_sys->b_buffering )
        {
            if( input_DecoderIsEmpty( es->p_dec ) &&
                ( !es->p_dec_record || input_DecoderIsEmpty( es->p_dec_record ) ))
                break;
            /* FIXME there should be a way to have auto deleted es, but there will be
             * a problem when another codec of the same type is created (mainly video) */
      ...",2179.0,2260.0,1.0,1.0,82.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
979,36330,EsOutTerminate,1,EsOutTerminate,void EsOutTerminate (es_out_t*),input\es_out.c,"static void EsOutTerminate( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    if( p_sys->p_sout_record )
        EsOutSetRecord( out, false );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_dec )
            input_DecoderDelete( p_sys->es[i]->p_dec );

        free( p_sys->es[i]->psz_language );
        free( p_sys->es[i]->psz_language_code );
        es_format_Clean( &p_sys->es[i]->fmt );

        free( p_sys->es[i] );
    }
    TAB_CLEAN( p_sys->i_es, p_sys->es );

    /* FIXME duplicate work EsOutProgramDel (but we cannot use it) add a EsOutProgramClean ? */
    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        es_out_pgrm_t *p_pgrm = p_sys->pgrm[i];
        input_clock_Delete( p_pgrm->p_clock );
        if( p_pgrm->p_meta )
            vlc_meta_Delete( p_pgrm->p_meta );

        free( p_pgrm );
    }
    TAB_CLEAN( p_sys->i_pgrm, p_sys->pgrm );

    p_sys->p_pgrm = NULL;

    input_item_SetEpgOffline( input_priv(p_sys->p_input)->p_i...",360.0,396.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
980,36335,EsOutSelect,1,EsOutSelect,"void EsOutSelect (es_out_t*,es_out_id_t*,bool)",input\es_out.c,"static void EsOutSelect( es_out_t *out, es_out_id_t *es, bool b_force )
{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_es_props_t *p_esprops = GetPropsByCat( p_sys, es->fmt.i_cat );

    if( !p_sys->b_active ||
        ( !b_force && es->fmt.i_priority < ES_PRIORITY_SELECTABLE_MIN ) )
    {
        return;
    }

    bool b_auto_unselect = p_esprops && p_sys->i_mode == ES_OUT_MODE_AUTO &&
                           p_esprops->e_policy == ES_OUT_ES_POLICY_EXCLUSIVE &&
                           p_esprops->p_main_es && p_esprops->p_main_es != es;

    if( p_sys->i_mode == ES_OUT_MODE_ALL || b_force )
    {
        if( !EsIsSelected( es ) )
        {
            if( b_auto_unselect )
                EsUnselect( out, p_esprops->p_main_es, false );

            EsSelect( out, es );
        }
    }
    else if( p_sys->i_mode == ES_OUT_MODE_PARTIAL )
    {
        char *prgms = var_GetNonEmptyString( p_sys->p_input, ""programs"" );
        if( prgms != NULL )
        {
            ch...",1871.0,2006.0,1.0,1.0,136.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
981,36342,EsOutUpdateInfo,1,EsOutUpdateInfo,"void EsOutUpdateInfo (es_out_t*,es_out_id_t*,es_format_t*,vlc_meta_t*)",input\es_out.c,"static void EsOutUpdateInfo( es_out_t *out, es_out_id_t *es, const es_format_t *fmt, const vlc_meta_t *p_meta )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;
    const es_format_t *p_fmt_es = &es->fmt;
    lldiv_t         div;

    if( es->fmt.i_cat == fmt->i_cat )
    {
        es_format_t update = *fmt;
        update.i_id = es->i_meta_id;
        update.i_codec = es->fmt.i_codec;
        update.i_original_fourcc = es->fmt.i_original_fourcc;

        /* Update infos that could have been lost by the decoder (no need to
         * dup them since input_item_UpdateTracksInfo() will do it). */
        if (update.psz_language == NULL)
            update.psz_language = es->fmt.psz_language;
        if (update.psz_description == NULL)
            update.psz_description = es->fmt.psz_description;
        if (update.i_cat == SPU_ES)
        {
            if (update.subs.psz_encoding == NULL)
                update.subs.psz_encoding = es->fmt.subs.ps...",3068.0,3407.0,1.0,1.0,340.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
982,36350,EsOutSetRecord,1,EsOutSetRecord,"int EsOutSetRecord (es_out_t*,bool)",input\es_out.c,"static int EsOutSetRecord(  es_out_t *out, bool b_record )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    assert( ( b_record && !p_sys->p_sout_record ) || ( !b_record && p_sys->p_sout_record ) );

    if( b_record )
    {
        char *psz_path = var_CreateGetNonEmptyString( p_input, ""input-record-path"" );
        if( !psz_path )
        {
            if( var_CountChoices( p_input, ""video-es"" ) )
                psz_path = config_GetUserDir( VLC_VIDEOS_DIR );
            else if( var_CountChoices( p_input, ""audio-es"" ) )
                psz_path = config_GetUserDir( VLC_MUSIC_DIR );
            else
                psz_path = config_GetUserDir( VLC_DOWNLOAD_DIR );
        }

        char *psz_sout = NULL;  // TODO conf

        if( !psz_sout && psz_path )
        {
            char *psz_file = input_CreateFilename( p_input, psz_path, INPUT_RECORD_PREFIX, NULL );
            if( psz_file )
            {
                char* psz_file_esc ...",473.0,554.0,1.0,1.0,82.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
983,36356,EsIsSelected,1,EsIsSelected,bool EsIsSelected (es_out_id_t*),input\es_out.c,"static bool EsIsSelected( es_out_id_t *es )
{
    if( es->p_master )
    {
        bool b_decode = false;
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            input_DecoderGetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, &b_decode );
        }
        return b_decode;
    }
    else
    {
        return es->p_dec != NULL;
    }
}",1676.0,1693.0,1.0,1.0,18.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,bool
984,36361,EsSelect,1,EsSelect,"void EsSelect (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsSelect( es_out_t *out, es_out_id_t *es )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already selected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        int i_channel;
        if( !es->p_master->p_dec )
            return;

        i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );

        if( i_channel == -1 ||
            input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                     i_channel, true ) )
            return;
    }
    else
    {
        const bool b_sout = input_priv(p_input)->p_sout != NULL;
        if( es->fmt.i_cat == VIDEO_ES || es->fmt.i_cat == SPU_ES )
        {
            if( !var_GetBool( p_input, b_sout ? ""sout-video"" : ""video"" ) )
            {
                msg_Dbg( p_input, ""video is disabled, not selecting ES 0x%x"",
                         es->i_id );
   ...",1732.0,1796.0,1.0,1.0,65.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
985,36373,EsUnselect,1,EsUnselect,"void EsUnselect (es_out_t*,es_out_id_t*,bool)",input\es_out.c,"static void EsUnselect( es_out_t *out, es_out_id_t *es, bool b_update )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !EsIsSelected( es ) )
    {
        msg_Warn( p_input, ""ES 0x%x is already unselected"", es->i_id );
        return;
    }

    if( es->p_master )
    {
        if( es->p_master->p_dec )
        {
            int i_channel = EsOutGetClosedCaptionsChannel( &es->fmt );
            if( i_channel != -1 )
                input_DecoderSetCcState( es->p_master->p_dec, es->fmt.i_codec,
                                         i_channel, false );
        }
    }
    else
    {
        EsDeleteCCChannels( out, es );
        EsDestroyDecoder( out, es );
    }

    if( !b_update )
        return;

    /* Mark it as unselected */
    input_SendEventEsSelect( p_input, es->fmt.i_cat, -1 );
    if( EsFmtIsTeletext( &es->fmt ) )
        input_SendEventTeletextSelect( p_input, -1 );
}",1826.0,1860.0,1.0,1.0,35.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
986,36380,EsOutDecoderChangeDelay,1,EsOutDecoderChangeDelay,"void EsOutDecoderChangeDelay (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsOutDecoderChangeDelay( es_out_t *out, es_out_id_t *p_es )
{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_delay = 0;
    if( p_es->fmt.i_cat == AUDIO_ES )
        i_delay = p_sys->i_audio_delay;
    else if( p_es->fmt.i_cat == SPU_ES )
        i_delay = p_sys->i_spu_delay;
    else
        return;

    if( p_es->p_dec )
        input_DecoderChangeDelay( p_es->p_dec, i_delay );
    if( p_es->p_dec_record )
        input_DecoderChangeDelay( p_es->p_dec_record, i_delay );
}",783.0,799.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
987,36386,EsOutDecodersChangePause,1,EsOutDecodersChangePause,"void EsOutDecodersChangePause (es_out_t*,bool,mtime_t)",input\es_out.c,"static void EsOutDecodersChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    /* Pause decoders first */
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec )
        {
            input_DecoderChangePause( es->p_dec, b_paused, i_date );
            if( es->p_dec_record )
                input_DecoderChangePause( es->p_dec_record, b_paused, i_date );
        }
    }
}",732.0,748.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
988,36393,EsOutProgramChangePause,1,EsOutProgramChangePause,"void EsOutProgramChangePause (es_out_t*,bool,mtime_t)",input\es_out.c,"static void EsOutProgramChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangePause( p_sys->pgrm[i]->p_clock, b_paused, i_date );
}",775.0,781.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
989,36400,EsOutProgramsChangeRate,1,EsOutProgramsChangeRate,void EsOutProgramsChangeRate (es_out_t*),input\es_out.c,"static void EsOutProgramsChangeRate( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
        input_clock_ChangeRate( p_sys->pgrm[i]->p_clock, p_sys->i_rate );
}",800.0,806.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
990,36405,EsOutDecodersStopBuffering,1,EsOutDecodersStopBuffering,"void EsOutDecodersStopBuffering (es_out_t*,bool)",input\es_out.c,"static void EsOutDecodersStopBuffering( es_out_t *out, bool b_forced )
{
    es_out_sys_t *p_sys = out->p_sys;

    mtime_t i_stream_start;
    mtime_t i_system_start;
    mtime_t i_stream_duration;
    mtime_t i_system_duration;
    if (input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ))
        return;

    mtime_t i_preroll_duration = 0;
    if( p_sys->i_preroll_end >= 0 )
        i_preroll_duration = __MAX( p_sys->i_preroll_end - i_stream_start, 0 );

    const mtime_t i_buffering_duration = p_sys->i_pts_delay +
                                         i_preroll_duration +
                                         p_sys->i_buffering_extra_stream - p_sys->i_buffering_extra_initial;

    if( i_stream_duration <= i_buffering_duration && !b_forced )
    {
        double f_level;
        if (i_buffering_duration == 0)
            f_level = 0;
      ...",642.0,731.0,1.0,1.0,90.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
991,36411,EsOutGlobalMeta,1,EsOutGlobalMeta,"void EsOutGlobalMeta (es_out_t*,vlc_meta_t*)",input\es_out.c,"static void EsOutGlobalMeta( es_out_t *p_out, const vlc_meta_t *p_meta )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    EsOutMeta( p_out, p_meta,
               (p_sys->p_pgrm && p_sys->p_pgrm->p_meta) ? p_sys->p_pgrm->p_meta : NULL );
}",1536.0,1541.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
992,36417,EsOutMeta,1,EsOutMeta,"void EsOutMeta (es_out_t*,vlc_meta_t*,vlc_meta_t*)",input\es_out.c,"static void EsOutMeta( es_out_t *p_out, const vlc_meta_t *p_meta, const vlc_meta_t *p_program_meta )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    input_item_t *p_item = input_GetItem( p_input );

    vlc_mutex_lock( &p_item->lock );
    if( p_meta )
        vlc_meta_Merge( p_item->p_meta, p_meta );
    vlc_mutex_unlock( &p_item->lock );

    /* Check program meta to not override GROUP_META values */
    if( p_meta && (!p_program_meta || vlc_meta_Get( p_program_meta, vlc_meta_Title ) == NULL) &&
         vlc_meta_Get( p_meta, vlc_meta_Title ) != NULL )
        input_item_SetName( p_item, vlc_meta_Get( p_meta, vlc_meta_Title ) );

    const char *psz_arturl = NULL;
    char *psz_alloc = NULL;

    if( p_program_meta )
        psz_arturl = vlc_meta_Get( p_program_meta, vlc_meta_ArtworkURL );
    if( psz_arturl == NULL && p_meta )
        psz_arturl = vlc_meta_Get( p_meta, vlc_meta_ArtworkURL );

    if( psz_arturl == NULL ) /* restore/...",1490.0,1534.0,1.0,1.0,45.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
993,36424,LanguageGetName,1,LanguageGetName,char* LanguageGetName (char*),input\es_out.c,"static char *LanguageGetName( const char *psz_code )
{
    const iso639_lang_t *pl;

    if( psz_code == NULL || !strcmp( psz_code, ""und"" ) )
    {
        return strdup( """" );
    }

    if( strlen( psz_code ) == 2 )
    {
        pl = GetLang_1( psz_code );
    }
    else if( strlen( psz_code ) == 3 )
    {
        pl = GetLang_2B( psz_code );
        if( !strcmp( pl->psz_iso639_1, ""??"" ) )
        {
            pl = GetLang_2T( psz_code );
        }
    }
    else
    {
        char *lang = LanguageGetCode( psz_code );
        pl = GetLang_1( lang );
        free( lang );
    }

    if( !strcmp( pl->psz_iso639_1, ""??"" ) )
    {
       return strdup( psz_code );
    }
    else
    {
        return strdup( vlc_gettext(pl->psz_eng_name) );
    }
}",2937.0,2973.0,1.0,1.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
994,36429,LanguageGetCode,1,LanguageGetCode,char* LanguageGetCode (char*),input\es_out.c,"static char *LanguageGetCode( const char *psz_lang )
{
    const iso639_lang_t *pl;

    if( psz_lang == NULL || *psz_lang == '\0' )
        return strdup(""??"");

    for( pl = p_languages; pl->psz_eng_name != NULL; pl++ )
    {
        if( !strcasecmp( pl->psz_eng_name, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_1, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2T, psz_lang ) ||
            !strcasecmp( pl->psz_iso639_2B, psz_lang ) )
            return strdup( pl->psz_iso639_1 );
    }

    return strdup(""??"");
}",2976.0,2993.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
995,36434,LanguageSplit,1,LanguageSplit,char** LanguageSplit (char*),input\es_out.c,"static char **LanguageSplit( const char *psz_langs )
{
    char *psz_dup;
    char *psz_parser;
    char **ppsz = NULL;
    int i_psz = 0;

    if( psz_langs == NULL ) return NULL;

    psz_parser = psz_dup = strdup(psz_langs);

    while( psz_parser && *psz_parser )
    {
        char *psz;
        char *psz_code;

        psz = strchr(psz_parser, ',' );
        if( psz ) *psz++ = '\0';

        if( !strcmp( psz_parser, ""any"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""any"") );
        }
        else if( !strcmp( psz_parser, ""none"" ) )
        {
            TAB_APPEND( i_psz, ppsz, strdup(""none"") );
        }
        else
        {
            psz_code = LanguageGetCode( psz_parser );
            if( strcmp( psz_code, ""??"" ) )
            {
                TAB_APPEND( i_psz, ppsz, psz_code );
            }
            else
            {
                free( psz_code );
            }
        }

        psz_parser = psz;
    }

    if( i_psz )
    {
        TAB_APPEND...",2995.0,3045.0,1.0,1.0,51.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char**
996,36445,EsOutProgramGetMetaName,1,EsOutProgramGetMetaName,char* EsOutProgramGetMetaName (es_out_pgrm_t*),input\es_out.c,"static char *EsOutProgramGetMetaName( es_out_pgrm_t *p_pgrm )
{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        if( asprintf( &psz, _(""%s [%s %d]""), vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ),
                      _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1193.0,1208.0,1.0,1.0,16.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,char*
997,36523,EsFmtIsTeletext,1,EsFmtIsTeletext,bool EsFmtIsTeletext (es_format_t*),input\es_out.c,"static inline bool EsFmtIsTeletext( const es_format_t *p_fmt )
{
    return p_fmt->i_cat == SPU_ES && p_fmt->i_codec == VLC_CODEC_TELETEXT;
}",226.0,229.0,1.0,1.0,4.0,5,3,4,3,2,0,1,1,0,0,,0,0,2,1,1,bool
998,36540,GetPropsByCat,1,GetPropsByCat,"es_out_es_props_t GetPropsByCat (es_out_sys_t*,int)",input\es_out.c,"static es_out_es_props_t * GetPropsByCat( es_out_sys_t *p_sys, int i_cat )
{
    switch( i_cat )
    {
    case AUDIO_ES:
        return &p_sys->audio;
    case SPU_ES:
        return &p_sys->sub;
    case VIDEO_ES:
        return &p_sys->video;
    }
    return NULL;
}",234.0,246.0,1.0,1.0,13.0,6,2,8,6,1,3,2,2,0,0,,0,3,4,2,2,es_out_es_props_t
999,36572,EsOutPropsCleanup,1,EsOutPropsCleanup,void EsOutPropsCleanup (es_out_es_props_t*),input\es_out.c,"static void EsOutPropsCleanup( es_out_es_props_t *p_props )
{
    if( p_props->ppsz_language )
    {
        for( int i = 0; p_props->ppsz_language[i]; i++ )
            free( p_props->ppsz_language[i] );
        free( p_props->ppsz_language );
    }
}",248.0,256.0,1.0,1.0,9.0,5,3,5,2,0,3,3,4,2,0,,0,3,2,1,1,void
1000,36605,EsOutPropsInit,1,EsOutPropsInit,"void EsOutPropsInit (es_out_es_props_t*,bool,input_thread_t*,es_out_policy_e,char*,char*,char*,char*)",input\es_out.c,"static void EsOutPropsInit( es_out_es_props_t *p_props,
                            bool autoselect,
                            input_thread_t *p_input,
                            enum es_out_policy_e e_default_policy,
                            const char *psz_trackidvar,
                            const char *psz_trackvar,
                            const char *psz_langvar,
                            const char *psz_debug )
{
    p_props->e_policy = e_default_policy;
    p_props->i_count = 0;
    p_props->b_autoselect = autoselect;
    p_props->i_id = (psz_trackidvar) ? var_GetInteger( p_input, psz_trackidvar ): -1;
    p_props->i_channel = (psz_trackvar) ? var_GetInteger( p_input, psz_trackvar ): -1;
    p_props->i_demux_id = -1;
    p_props->p_main_es = NULL;

    if( !input_priv(p_input)->b_preparsing && psz_langvar )
    {
        char *psz_string = var_GetString( p_input, psz_langvar );
        p_props->ppsz_language = LanguageSplit( psz_string );
        if( p_props->p...",258.0,287.0,1.0,1.0,30.0,29,7,28,10,3,12,4,7,3,2,,0,12,16,8,8,void
1001,36716,input_EsOutNew,1,input_EsOutNew,"es_out_t input_EsOutNew (input_thread_t*,int)",input\es_out.c,"es_out_t *input_EsOutNew( input_thread_t *p_input, int i_rate )
{
    es_out_t     *out = malloc( sizeof( *out ) );
    if( !out )
        return NULL;

    es_out_sys_t *p_sys = calloc( 1, sizeof( *p_sys ) );
    if( !p_sys )
    {
        free( out );
        return NULL;
    }

    out->pf_add     = EsOutAdd;
    out->pf_send    = EsOutSend;
    out->pf_del     = EsOutDel;
    out->pf_control = EsOutControl;
    out->pf_destroy = EsOutDelete;
    out->p_sys      = p_sys;

    vlc_mutex_init_recursive( &p_sys->lock );
    p_sys->p_input = p_input;

    p_sys->b_active = false;
    p_sys->i_mode   = ES_OUT_MODE_NONE;

    TAB_INIT( p_sys->i_pgrm, p_sys->pgrm );

    TAB_INIT( p_sys->i_es, p_sys->es );

    /* */
    EsOutPropsInit( &p_sys->video, true, p_input, ES_OUT_ES_POLICY_SIMULTANEOUS,
                    NULL, NULL, NULL, NULL );
    EsOutPropsInit( &p_sys->audio, true, p_input, ES_OUT_ES_POLICY_EXCLUSIVE,
                    ""audio-track-id"", ""audio-track"", ""audio-language""...",292.0,341.0,1.0,1.0,50.0,53,7,55,12,0,21,3,3,0,4,,0,17,4,2,2,es_out_t
1002,37081,EsOutGetWakeup,1,EsOutGetWakeup,mtime_t EsOutGetWakeup (es_out_t*),input\es_out.c,"static mtime_t EsOutGetWakeup( es_out_t *out )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( !p_sys->p_pgrm )
        return 0;

    /* We do not have a wake up date if the input cannot have its speed
     * controlled or sout is imposing its own or while buffering
     *
     * FIXME for !input_priv(p_input)->b_can_pace_control a wake-up time is still needed
     * to avoid too heavy buffering */
    if( !input_priv(p_input)->b_can_pace_control ||
        input_priv(p_input)->b_out_pace_control ||
        p_sys->b_buffering )
        return 0;

    return input_clock_GetWakeup( p_sys->p_pgrm->p_clock );
}",398.0,417.0,1.0,1.0,20.0,14,4,9,3,1,7,3,3,4,3,,0,6,2,1,1,mtime_t
1003,37134,EsOutGetFromID,1,EsOutGetFromID,"es_out_id_t EsOutGetFromID (es_out_t*,int)",input\es_out.c,"static es_out_id_t *EsOutGetFromID( es_out_t *out, int i_id )
{
    if( i_id < 0 )
    {
        /* Special HACK, -i_id is the cat of the stream */
        return es_cat - i_id;
    }

    for( int i = 0; i < out->p_sys->i_es; i++ )
    {
        if( out->p_sys->es[i]->i_id == i_id )
            return out->p_sys->es[i];
    }
    return NULL;
}",421.0,435.0,1.0,1.0,15.0,14,6,12,5,3,1,4,5,0,0,,0,1,4,2,2,es_out_id_t
1004,37188,EsOutDecodersIsEmpty,1,EsOutDecodersIsEmpty,bool EsOutDecodersIsEmpty (es_out_t*),input\es_out.c,"static bool EsOutDecodersIsEmpty( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    if( p_sys->b_buffering && p_sys->p_pgrm )
    {
        EsOutDecodersStopBuffering( out, true );
        if( p_sys->b_buffering )
            return true;
    }

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *es = p_sys->es[i];

        if( es->p_dec && !input_DecoderIsEmpty( es->p_dec ) )
            return false;
        if( es->p_dec_record && !input_DecoderIsEmpty( es->p_dec_record ) )
            return false;
    }
    return true;
}",437.0,458.0,1.0,1.0,22.0,20,6,21,6,1,12,6,9,10,3,,0,11,2,1,1,bool
1005,37268,EsOutSetDelay,1,EsOutSetDelay,"void EsOutSetDelay (es_out_t*,int,int64_t)",input\es_out.c,"static void EsOutSetDelay( es_out_t *out, int i_cat, int64_t i_delay )
{
    es_out_sys_t *p_sys = out->p_sys;

    if( i_cat == AUDIO_ES )
        p_sys->i_audio_delay = i_delay;
    else if( i_cat == SPU_ES )
        p_sys->i_spu_delay = i_delay;

    for( int i = 0; i < p_sys->i_es; i++ )
        EsOutDecoderChangeDelay( out, p_sys->es[i] );
}",460.0,471.0,1.0,1.0,12.0,8,4,9,6,1,2,3,3,1,0,,0,2,6,3,3,void
1006,37568,EsOutChangePause,1,EsOutChangePause,"void EsOutChangePause (es_out_t*,bool,mtime_t)",input\es_out.c,"static void EsOutChangePause( es_out_t *out, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = out->p_sys;

    /* XXX the order is important */
    if( b_paused )
    {
        EsOutDecodersChangePause( out, true, i_date );
        EsOutProgramChangePause( out, true, i_date );
    }
    else
    {
        if( p_sys->i_buffering_extra_initial > 0 )
        {
            mtime_t i_stream_start;
            mtime_t i_system_start;
            mtime_t i_stream_duration;
            mtime_t i_system_duration;
            int i_ret;
            i_ret = input_clock_GetState( p_sys->p_pgrm->p_clock,
                                          &i_stream_start, &i_system_start,
                                          &i_stream_duration, &i_system_duration );
            if( !i_ret )
            {
                /* FIXME pcr != exactly what wanted */
                const mtime_t i_used = /*(i_stream_duration - input_priv(p_sys->p_input)->i_pts_delay)*/ p_sys->i_buffering_extra_sys...",555.0,594.0,1.0,1.0,40.0,6,2,13,5,1,4,2,2,0,2,,0,2,6,3,3,void
1007,37674,EsOutChangeRate,1,EsOutChangeRate,"void EsOutChangeRate (es_out_t*,int)",input\es_out.c,"static void EsOutChangeRate( es_out_t *out, int i_rate )
{
    es_out_sys_t      *p_sys = out->p_sys;

    p_sys->i_rate = i_rate;
    EsOutProgramsChangeRate( out );
}",596.0,602.0,1.0,1.0,7.0,4,2,5,3,1,2,1,1,0,1,,0,1,4,2,2,void
1008,37693,EsOutChangePosition,1,EsOutChangePosition,void EsOutChangePosition (es_out_t*),input\es_out.c,"static void EsOutChangePosition( es_out_t *out )
{
    es_out_sys_t      *p_sys = out->p_sys;

    input_SendEventCache( p_sys->p_input, 0.0 );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec != NULL )
        {
            input_DecoderFlush( p_es->p_dec );
            if( !p_sys->b_buffering )
            {
                input_DecoderStartWait( p_es->p_dec );
                if( p_es->p_dec_record != NULL )
                    input_DecoderStartWait( p_es->p_dec_record );
            }
        }
        p_es->i_pts_level = VLC_TS_INVALID;
    }

    for( int i = 0; i < p_sys->i_pgrm; i++ ) {
        input_clock_Reset( p_sys->pgrm[i]->p_clock );
        p_sys->pgrm[i]->i_last_pcr = VLC_TS_INVALID;
    }

    p_sys->b_buffering = true;
    p_sys->i_buffering_extra_initial = 0;
    p_sys->i_buffering_extra_stream = 0;
    p_sys->i_buffering_extra_system = 0;
    p_sys->i_preroll_end = -1;
    p_sys->i_prev_stream_...",604.0,638.0,1.0,1.0,35.0,44,7,34,7,2,24,6,12,5,5,,0,19,2,1,1,void
1009,38206,EsOutIsExtraBufferingAllowed,1,EsOutIsExtraBufferingAllowed,bool EsOutIsExtraBufferingAllowed (es_out_t*),input\es_out.c,"static bool EsOutIsExtraBufferingAllowed( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;

    size_t i_size = 0;
    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->p_dec )
            i_size += input_DecoderGetFifoSize( p_es->p_dec );
        if( p_es->p_dec_record )
            i_size += input_DecoderGetFifoSize( p_es->p_dec_record );
    }
    //msg_Info( out, ""----- EsOutIsExtraBufferingAllowed =% 5d KiB -- "", i_size / 1024 );

    /* TODO maybe we want to be able to tune it ? */
#if defined(OPTIMIZE_MEMORY)
    const size_t i_level_high = 512*1024;  /* 0.5 MiB */
#else
    const size_t i_level_high = 10*1024*1024; /* 10 MiB */
#endif
    return i_size < i_level_high;
}",750.0,773.0,1.0,1.0,24.0,19,6,18,6,1,8,4,6,3,2,,0,6,2,1,1,bool
1010,38417,EsOutFrameNext,1,EsOutFrameNext,void EsOutFrameNext (es_out_t*),input\es_out.c,"static void EsOutFrameNext( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;
    es_out_id_t *p_es_video = NULL;

    if( p_sys->b_buffering )
    {
        msg_Warn( p_sys->p_input, ""buffering, ignoring 'frame next'"" );
        return;
    }

    assert( p_sys->b_paused );

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        es_out_id_t *p_es = p_sys->es[i];

        if( p_es->fmt.i_cat == VIDEO_ES && p_es->p_dec )
        {
            p_es_video = p_es;
            break;
        }
    }

    if( !p_es_video )
    {
        msg_Warn( p_sys->p_input, ""No video track selected, ignoring 'frame next'"" );
        return;
    }

    mtime_t i_duration;
    input_DecoderFrameNext( p_es_video->p_dec, &i_duration );

    msg_Dbg( out->p_sys->p_input, ""EsOutFrameNext consummed %d ms"", (int)(i_duration/1000) );

    if( i_duration <= 0 )
        i_duration = 40*1000;

    /* FIXME it is not a clean way ? */
    if( p_sys->i_buffering_extra_initial <= 0 )
    {
        mtime_t i_...",808.0,876.0,1.0,1.0,69.0,70,17,54,16,1,28,9,10,5,3,,0,27,2,1,1,void
1011,38629,EsOutGetBuffering,1,EsOutGetBuffering,mtime_t EsOutGetBuffering (es_out_t*),input\es_out.c,"static mtime_t EsOutGetBuffering( es_out_t *out )
{
    es_out_sys_t *p_sys = out->p_sys;
    mtime_t i_stream_duration, i_system_start;

    if( !p_sys->p_pgrm )
        return 0;
    else
    {
        mtime_t i_stream_start, i_system_duration;

        if( input_clock_GetState( p_sys->p_pgrm->p_clock,
                                  &i_stream_start, &i_system_start,
                                  &i_stream_duration, &i_system_duration ) )
            return 0;
    }

    mtime_t i_delay;

    if( p_sys->b_buffering && p_sys->i_buffering_extra_initial <= 0 )
    {
        i_delay = i_stream_duration;
    }
    else
    {
        mtime_t i_system_duration;

        if( p_sys->b_paused )
        {
            i_system_duration = p_sys->i_pause_date  - i_system_start;
            if( p_sys->i_buffering_extra_initial > 0 )
                i_system_duration += p_sys->i_buffering_extra_system - p_sys->i_buffering_extra_initial;
        }
        else
        {
            i_system_...",877.0,921.0,1.0,1.0,45.0,10,6,9,4,1,3,4,4,3,0,,0,3,2,1,1,mtime_t
1012,38753,EsOutESVarUpdateGeneric,1,EsOutESVarUpdateGeneric,"void EsOutESVarUpdateGeneric (es_out_t*,int,es_format_t*,char*,bool)",input\es_out.c,"static void EsOutESVarUpdateGeneric( es_out_t *out, int i_id,
                                     const es_format_t *fmt, const char *psz_language,
                                     bool b_delete )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    vlc_value_t       val, text;

    if( b_delete )
    {
        if( EsFmtIsTeletext( fmt ) )
            input_SendEventTeletextDel( p_sys->p_input, i_id );

        input_SendEventEsDel( p_input, fmt->i_cat, i_id );
        return;
    }

    /* Get the number of ES already added */
    const char *psz_var;
    if( fmt->i_cat == AUDIO_ES )
        psz_var = ""audio-es"";
    else if( fmt->i_cat == VIDEO_ES )
        psz_var = ""video-es"";
    else
        psz_var = ""spu-es"";

    var_Change( p_input, psz_var, VLC_VAR_CHOICESCOUNT, &val, NULL );
    if( val.i_int == 0 )
    {
        vlc_value_t val2;

        /* First one, we need to add the ""Disable"" choice */
        val2.i_int = -1; text....",923.0,997.0,1.0,1.0,75.0,50,12,52,16,1,11,9,13,2,8,,0,5,10,5,5,void
1013,38988,EsOutESVarUpdate,1,EsOutESVarUpdate,"void EsOutESVarUpdate (es_out_t*,es_out_id_t*,bool)",input\es_out.c,"static void EsOutESVarUpdate( es_out_t *out, es_out_id_t *es,
                              bool b_delete )
{
    EsOutESVarUpdateGeneric( out, es->i_id, &es->fmt, es->psz_language, b_delete );
}",999.0,1003.0,1.0,1.0,5.0,4,2,5,3,2,4,1,1,0,1,,0,3,6,3,3,void
1014,39008,EsOutIsProgramVisible,1,EsOutIsProgramVisible,"bool EsOutIsProgramVisible (es_out_t*,int)",input\es_out.c,"static bool EsOutIsProgramVisible( es_out_t *out, int i_group )
{
    return out->p_sys->i_group_id == 0 || out->p_sys->i_group_id == i_group;
}",1005.0,1008.0,1.0,1.0,4.0,7,3,3,2,4,0,1,1,0,0,,0,0,4,2,2,bool
1015,39030,EsOutProgramSelect,1,EsOutProgramSelect,"void EsOutProgramSelect (es_out_t*,es_out_pgrm_t*)",input\es_out.c,"static void EsOutProgramSelect( es_out_t *out, es_out_pgrm_t *p_pgrm )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    int               i;

    if( p_sys->p_pgrm == p_pgrm )
        return; /* Nothing to do */

    if( p_sys->p_pgrm )
    {
        es_out_pgrm_t *old = p_sys->p_pgrm;
        msg_Dbg( p_input, ""unselecting program id=%d"", old->i_id );

        for( i = 0; i < p_sys->i_es; i++ )
        {
            if( p_sys->es[i]->p_pgrm == old && EsIsSelected( p_sys->es[i] ) &&
                p_sys->i_mode != ES_OUT_MODE_ALL )
                EsUnselect( out, p_sys->es[i], true );
        }

        p_sys->audio.p_main_es = NULL;
        p_sys->video.p_main_es = NULL;
        p_sys->sub.p_main_es = NULL;
    }

    msg_Dbg( p_input, ""selecting program id=%d"", p_pgrm->i_id );

    /* Mark it selected */
    p_pgrm->b_selected = true;

    /* Switch master stream */
    p_sys->p_pgrm = p_pgrm;

    /* Update ""program"" */
    input...",1013.0,1086.0,1.0,1.0,74.0,74,10,83,16,2,51,8,12,11,20,,0,33,4,2,2,void
1016,39296,EsOutProgramAdd,1,EsOutProgramAdd,"es_out_pgrm_t EsOutProgramAdd (es_out_t*,int)",input\es_out.c,"static es_out_pgrm_t *EsOutProgramAdd( es_out_t *out, int i_group )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    es_out_pgrm_t *p_pgrm = malloc( sizeof( es_out_pgrm_t ) );
    if( !p_pgrm )
        return NULL;

    /* Init */
    p_pgrm->i_id = i_group;
    p_pgrm->i_es = 0;
    p_pgrm->b_selected = false;
    p_pgrm->b_scrambled = false;
    p_pgrm->i_last_pcr = VLC_TS_INVALID;
    p_pgrm->p_meta = NULL;
    p_pgrm->p_clock = input_clock_New( p_sys->i_rate );
    if( !p_pgrm->p_clock )
    {
        free( p_pgrm );
        return NULL;
    }
    if( p_sys->b_paused )
        input_clock_ChangePause( p_pgrm->p_clock, p_sys->b_paused, p_sys->i_pause_date );
    input_clock_SetJitter( p_pgrm->p_clock, p_sys->i_pts_delay, p_sys->i_cr_average );

    /* Append it */
    TAB_APPEND( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* Update ""program"" variable */
    if( EsOutIsProgramVisible( out, i_group ) )
        input_SendEventProgram...",1091.0,1128.0,1.0,1.0,38.0,41,7,46,9,2,29,6,6,6,6,,0,25,4,2,2,es_out_pgrm_t
1017,39439,EsOutProgramDel,1,EsOutProgramDel,"int EsOutProgramDel (es_out_t*,int)",input\es_out.c,"static int EsOutProgramDel( es_out_t *out, int i_group )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    es_out_pgrm_t     *p_pgrm = NULL;
    int               i;

    for( i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
        {
            p_pgrm = p_sys->pgrm[i];
            break;
        }
    }

    if( p_pgrm == NULL )
        return VLC_EGENERIC;

    if( p_pgrm->i_es )
    {
        msg_Dbg( p_input, ""can't delete program %d which still has %i ES"",
                 i_group, p_pgrm->i_es );
        return VLC_EGENERIC;
    }

    TAB_REMOVE( p_sys->i_pgrm, p_sys->pgrm, p_pgrm );

    /* If program is selected we need to unselect it */
    if( p_sys->p_pgrm == p_pgrm )
        p_sys->p_pgrm = NULL;

    input_clock_Delete( p_pgrm->p_clock );

    if( p_pgrm->p_meta )
        vlc_meta_Delete( p_pgrm->p_meta );
    free( p_pgrm );

    /* Update ""program"" variable */
    input_SendEventProgr...",1133.0,1175.0,1.0,1.0,43.0,27,5,37,9,1,16,8,8,5,3,,0,13,4,2,2,int
1018,39555,EsOutProgramFind,1,EsOutProgramFind,"es_out_pgrm_t EsOutProgramFind (es_out_t*,int)",input\es_out.c,"static es_out_pgrm_t *EsOutProgramFind( es_out_t *p_out, int i_group )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    for( int i = 0; i < p_sys->i_pgrm; i++ )
    {
        if( p_sys->pgrm[i]->i_id == i_group )
            return p_sys->pgrm[i];
    }
    return EsOutProgramAdd( p_out, i_group );
}",1179.0,1189.0,1.0,1.0,11.0,11,5,12,4,4,4,3,4,2,1,,0,3,4,2,2,es_out_pgrm_t
1019,39664,EsOutProgramGetProgramName,1,EsOutProgramGetProgramName,char* EsOutProgramGetProgramName (es_out_pgrm_t*),input\es_out.c,"static char *EsOutProgramGetProgramName( es_out_pgrm_t *p_pgrm )
{
    char *psz = NULL;
    if( p_pgrm->p_meta && vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) )
    {
        return strdup( vlc_meta_Get( p_pgrm->p_meta, vlc_meta_Title ) );
    }
    else
    {
        if( asprintf( &psz, ""%s %d"", _(""Program""), p_pgrm->i_id ) == -1 )
            return NULL;
    }
    return psz;
}",1210.0,1223.0,1.0,1.0,14.0,5,3,8,4,1,5,2,2,3,2,,0,4,2,1,1,char*
1020,39734,EsOutProgramMeta,1,EsOutProgramMeta,"void EsOutProgramMeta (es_out_t*,int,vlc_meta_t*)",input\es_out.c,"static void EsOutProgramMeta( es_out_t *out, int i_group, const vlc_meta_t *p_meta )
{
    es_out_sys_t      *p_sys = out->p_sys;
    es_out_pgrm_t     *p_pgrm;
    input_thread_t    *p_input = p_sys->p_input;
    const char        *psz_title = NULL;
    const char        *psz_provider = NULL;
    int i;

    msg_Dbg( p_input, ""EsOutProgramMeta: number=%d"", i_group );

    /* Check against empty meta data (empty for what we handle) */
    if( !vlc_meta_Get( p_meta, vlc_meta_Title) &&
        !vlc_meta_Get( p_meta, vlc_meta_ESNowPlaying) &&
        !vlc_meta_Get( p_meta, vlc_meta_Publisher) )
    {
        return;
    }

    if( i_group < 0 )
    {
        EsOutGlobalMeta( out, p_meta );
        return;
    }

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    if( p_pgrm->p_meta )
    {
        const char *psz_current_title = vlc_meta_Get( p_pgrm->p_meta, vlc_met...",1235.0,1355.0,1.0,1.0,121.0,60,12,123,22,1,40,22,33,9,30,,0,27,6,3,3,void
1021,40052,EsOutProgramEpgEvent,1,EsOutProgramEpgEvent,"void EsOutProgramEpgEvent (es_out_t*,int,vlc_epg_event_t*)",input\es_out.c,"static void EsOutProgramEpgEvent( es_out_t *out, int i_group, const vlc_epg_event_t *p_event )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    input_item_SetEpgEvent( p_item, p_event );
}",1357.0,1372.0,1.0,1.0,16.0,9,3,14,7,1,5,3,3,1,4,,0,4,6,3,3,void
1022,40099,EsOutProgramEpg,1,EsOutProgramEpg,"void EsOutProgramEpg (es_out_t*,int,vlc_epg_t*)",input\es_out.c,"static void EsOutProgramEpg( es_out_t *out, int i_group, const vlc_epg_t *p_epg )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;
    es_out_pgrm_t     *p_pgrm;
    char *psz_cat;

    /* Find program */
    if( !EsOutIsProgramVisible( out, i_group ) )
        return;
    p_pgrm = EsOutProgramFind( out, i_group );
    if( !p_pgrm )
        return;

    /* Update info */
    psz_cat = EsOutProgramGetMetaName( p_pgrm );
    msg_Dbg( p_input, ""EsOutProgramEpg: number=%d name=%s"", i_group, psz_cat );

    /* Merge EPG */
    vlc_epg_t epg;

    epg = *p_epg;
    epg.psz_name = EsOutProgramGetProgramName( p_pgrm );

    input_item_SetEpg( p_item, &epg, p_sys->p_pgrm && (p_epg->i_source_id == p_sys->p_pgrm->i_id) );
    input_SendEventMetaEpg( p_sys->p_input );

    free( epg.psz_name );

    /* Update now playing */
    if( p_epg->b_present && p_pgrm->p_meta &&
       ( p_epg->p_cur...",1374.0,1450.0,1.0,1.0,77.0,65,12,72,16,1,30,11,16,6,16,,0,22,6,3,3,void
1023,40343,EsOutEpgTime,1,EsOutEpgTime,"void EsOutEpgTime (es_out_t*,int64_t)",input\es_out.c,"static void EsOutEpgTime( es_out_t *out, int64_t time )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;
    input_item_t      *p_item = input_priv(p_input)->p_item;

    input_item_SetEpgTime( p_item, time );
}",1452.0,1459.0,1.0,1.0,8.0,6,2,8,5,1,3,1,1,0,2,,0,2,4,2,2,void
1024,40371,EsOutProgramUpdateScrambled,1,EsOutProgramUpdateScrambled,"void EsOutProgramUpdateScrambled (es_out_t*,es_out_pgrm_t*)",input\es_out.c,"static void EsOutProgramUpdateScrambled( es_out_t *p_out, es_out_pgrm_t *p_pgrm )
{
    es_out_sys_t    *p_sys = p_out->p_sys;
    input_thread_t  *p_input = p_sys->p_input;
    bool b_scrambled = false;

    for( int i = 0; i < p_sys->i_es; i++ )
    {
        if( p_sys->es[i]->p_pgrm == p_pgrm && p_sys->es[i]->b_scrambled )
        {
            b_scrambled = true;
            break;
        }
    }
    if( !p_pgrm->b_scrambled == !b_scrambled )
        return;

    p_pgrm->b_scrambled = b_scrambled;
    char *psz_cat = EsOutProgramGetMetaName( p_pgrm );

    if( b_scrambled )
        input_Control( p_input, INPUT_ADD_INFO, psz_cat, _(""Scrambled""), _(""Yes"") );
    else
        input_Control( p_input, INPUT_DEL_INFO, psz_cat, _(""Scrambled"") );
    free( psz_cat );

    input_SendEventProgramScrambled( p_input, p_pgrm->i_id, b_scrambled );
}",1461.0,1488.0,1.0,1.0,28.0,25,7,30,10,2,10,6,6,4,3,,0,8,4,2,2,void
1025,40656,EsOutAddSlave,1,EsOutAddSlave,"es_out_id_t EsOutAddSlave (es_out_t*,es_format_t*,es_out_id_t*)",input\es_out.c,"static es_out_id_t *EsOutAddSlave( es_out_t *out, const es_format_t *fmt, es_out_id_t *p_master )
{
    es_out_sys_t      *p_sys = out->p_sys;
    input_thread_t    *p_input = p_sys->p_input;

    if( fmt->i_group < 0 )
    {
        msg_Err( p_input, ""invalid group number"" );
        return NULL;
    }

    es_out_id_t   *es = malloc( sizeof( *es ) );
    es_out_pgrm_t *p_pgrm;
    int i;

    if( !es )
        return NULL;

    vlc_mutex_lock( &p_sys->lock );

    /* Search the program */
    p_pgrm = EsOutProgramFind( out, fmt->i_group );
    if( !p_pgrm )
    {
        vlc_mutex_unlock( &p_sys->lock );
        free( es );
        return NULL;
    }

    /* Increase ref count for program */
    p_pgrm->i_es++;

    /* Set up ES */
    es->p_pgrm = p_pgrm;
    es_format_Copy( &es->fmt, fmt );
    if( es->fmt.i_id < 0 )
        es->fmt.i_id = p_sys->i_id;
    if( !es->fmt.i_original_fourcc )
        es->fmt.i_original_fourcc = es->fmt.i_codec;

    es->i_id = es->fmt.i_id;
    es->...",1543.0,1666.0,1.0,1.0,124.0,217,13,131,16,1,89,18,21,12,21,,0,77,6,3,3,es_out_id_t
1026,41301,EsCreateDecoder,1,EsCreateDecoder,"void EsCreateDecoder (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsCreateDecoder( es_out_t *out, es_out_id_t *p_es )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    p_es->p_dec = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, input_priv(p_input)->p_sout );
    if( p_es->p_dec )
    {
        if( p_sys->b_buffering )
            input_DecoderStartWait( p_es->p_dec );

        if( !p_es->p_master && p_sys->p_sout_record )
        {
            p_es->p_dec_record = input_DecoderNew( p_input, &p_es->fmt, p_es->p_pgrm->p_clock, p_sys->p_sout_record );
            if( p_es->p_dec_record && p_sys->b_buffering )
                input_DecoderStartWait( p_es->p_dec_record );
        }
    }

    EsOutDecoderChangeDelay( out, p_es );
}",1694.0,1714.0,1.0,1.0,21.0,29,5,24,4,3,22,5,9,6,6,,0,19,4,2,2,void
1027,41396,EsDestroyDecoder,1,EsDestroyDecoder,"void EsDestroyDecoder (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsDestroyDecoder( es_out_t *out, es_out_id_t *p_es )
{
    VLC_UNUSED(out);

    if( !p_es->p_dec )
        return;

    input_DecoderDelete( p_es->p_dec );
    p_es->p_dec = NULL;

    if( p_es->p_dec_record )
    {
        input_DecoderDelete( p_es->p_dec_record );
        p_es->p_dec_record = NULL;
    }
}",1715.0,1730.0,1.0,1.0,16.0,9,3,9,3,3,8,3,3,2,2,,0,6,4,2,2,void
1028,41644,EsDeleteCCChannels,1,EsDeleteCCChannels,"void EsDeleteCCChannels (es_out_t*,es_out_id_t*)",input\es_out.c,"static void EsDeleteCCChannels( es_out_t *out, es_out_id_t *parent )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    if( parent->cc.type == 0 )
        return;

    const int i_spu_id = var_GetInteger( p_input, ""spu-es"");

    uint64_t i_bitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1 )
    {
        if( (i_bitmap & 1) == 0 || !parent->cc.pp_es[i] )
            continue;

        if( i_spu_id == parent->cc.pp_es[i]->i_id )
        {
            /* Force unselection of the CC */
            input_SendEventEsSelect( p_input, SPU_ES, -1 );
        }
        EsOutDel( out, parent->cc.pp_es[i] );
    }

    parent->cc.i_bitmap = 0;
    parent->cc.type = 0;
}",1798.0,1824.0,1.0,1.0,27.0,35,10,24,8,0,3,6,7,0,2,,0,1,4,2,2,void
1029,42334,EsOutCreateCCChannels,1,EsOutCreateCCChannels,"void EsOutCreateCCChannels (es_out_t*,vlc_fourcc_t,uint64_t,char*,es_out_id_t*)",input\es_out.c,"static void EsOutCreateCCChannels( es_out_t *out, vlc_fourcc_t codec, uint64_t i_bitmap,
                                   const char *psz_descfmt, es_out_id_t *parent )
{
    es_out_sys_t   *p_sys = out->p_sys;
    input_thread_t *p_input = p_sys->p_input;

    /* Only one type of captions is allowed ! */
    if( parent->cc.type && parent->cc.type != codec )
        return;

    uint64_t i_existingbitmap = parent->cc.i_bitmap;
    for( int i = 0; i_bitmap > 0; i++, i_bitmap >>= 1, i_existingbitmap >>= 1 )
    {
        es_format_t fmt;

        if( (i_bitmap & 1) == 0 || (i_existingbitmap & 1) )
            continue;

        msg_Dbg( p_input, ""Adding CC track %d for es[%d]"", 1+i, parent->i_id );

        es_format_Init( &fmt, SPU_ES, codec );
        fmt.subs.cc.i_channel = i;
        fmt.i_group = parent->fmt.i_group;
        if( asprintf( &fmt.psz_description, psz_descfmt, 1 + i ) == -1 )
            fmt.psz_description = NULL;

        es_out_id_t **pp_es = &parent->cc.pp_es[i...",2008.0,2046.0,1.0,1.0,39.0,56,15,45,14,0,8,7,9,1,4,,0,5,10,5,5,void
1030,43141,EsOutControlLocked,1,EsOutControlLocked,"int EsOutControlLocked (es_out_t*,int,va_list)",input\es_out.c,"static int EsOutControlLocked( es_out_t *out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = out->p_sys;

    switch( i_query )
    {
    case ES_OUT_SET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool b = va_arg( args, int );
        if( b && !EsIsSelected( es ) )
        {
            EsSelect( out, es );
            return EsIsSelected( es ) ? VLC_SUCCESS : VLC_EGENERIC;
        }
        else if( !b && EsIsSelected( es ) )
        {
            EsUnselect( out, es, es->p_pgrm == p_sys->p_pgrm );
            return VLC_SUCCESS;
        }
        return VLC_SUCCESS;
    }

    case ES_OUT_GET_ES_STATE:
    {
        es_out_id_t *es = va_arg( args, es_out_id_t * );
        bool *pb = va_arg( args, bool * );

        *pb = EsIsSelected( es );
        return VLC_SUCCESS;
    }

    case ES_OUT_SET_ES_CAT_POLICY:
    {
        enum es_format_category_e i_cat = va_arg( args, enum es_format_category_e );
        enum es_out_policy_e i_pol =...",2270.0,2921.0,1.0,20.0,652.0,268,22,452,114,0,129,57,123,32,58,,0,91,6,3,3,int
1031,46695,es_out_SetMode,1,es_out_SetMode,"void es_out_SetMode (es_out_t*,int)",input\es_out.h,"static inline void es_out_SetMode( es_out_t *p_out, int i_mode )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_MODE, i_mode );
    assert( !i_ret );
}",93.0,97.0,1.0,1.0,5.0,2,2,5,4,1,0,1,1,0,0,,0,0,4,2,2,void
1032,46768,es_out_SetDelay,1,es_out_SetDelay,"void es_out_SetDelay (es_out_t*,int,mtime_t)",input\es_out.h,"static inline void es_out_SetDelay( es_out_t *p_out, int i_cat, mtime_t i_delay )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_DELAY, i_cat, i_delay );
    assert( !i_ret );
}",122.0,126.0,1.0,1.0,5.0,2,2,6,5,2,0,1,1,0,0,,0,0,6,3,3,void
1033,46797,es_out_SetPauseState,1,es_out_SetPauseState,"int es_out_SetPauseState (es_out_t*,bool,bool,mtime_t)",input\es_out.h,"static inline int es_out_SetPauseState( es_out_t *p_out, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    return es_out_Control( p_out, ES_OUT_SET_PAUSE_STATE, b_source_paused, b_paused, i_date );
}",131.0,134.0,1.0,1.0,4.0,0,0,5,5,2,0,1,1,0,0,,0,0,8,4,4,int
1034,46812,es_out_SetRate,1,es_out_SetRate,"int es_out_SetRate (es_out_t*,int,int)",input\es_out.h,"static inline int es_out_SetRate( es_out_t *p_out, int i_source_rate, int i_rate )
{
    return es_out_Control( p_out, ES_OUT_SET_RATE, i_source_rate, i_rate );
}",135.0,138.0,1.0,1.0,4.0,0,0,4,4,1,0,1,1,0,0,,0,0,6,3,3,int
1035,46825,es_out_SetTime,1,es_out_SetTime,"int es_out_SetTime (es_out_t*,mtime_t)",input\es_out.h,"static inline int es_out_SetTime( es_out_t *p_out, mtime_t i_date )
{
    return es_out_Control( p_out, ES_OUT_SET_TIME, i_date );
}",139.0,142.0,1.0,1.0,4.0,0,0,3,3,1,0,1,1,0,0,,0,0,4,2,2,int
1036,46836,es_out_SetFrameNext,1,es_out_SetFrameNext,int es_out_SetFrameNext (es_out_t*),input\es_out.h,"static inline int es_out_SetFrameNext( es_out_t *p_out )
{
    return es_out_Control( p_out, ES_OUT_SET_FRAME_NEXT );
}",143.0,146.0,1.0,1.0,4.0,0,0,2,2,1,0,1,1,0,0,,0,0,2,1,1,int
1037,46845,es_out_SetTimes,1,es_out_SetTimes,"void es_out_SetTimes (es_out_t*,double,mtime_t,mtime_t)",input\es_out.h,"static inline void es_out_SetTimes( es_out_t *p_out, double f_position, mtime_t i_time, mtime_t i_length )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_TIMES, f_position, i_time, i_length );
    assert( !i_ret );
}",147.0,151.0,1.0,1.0,5.0,2,2,7,6,1,0,1,1,0,0,,0,0,8,4,4,void
1038,46865,es_out_SetJitter,1,es_out_SetJitter,"void es_out_SetJitter (es_out_t*,mtime_t,mtime_t,int)",input\es_out.h,"static inline void es_out_SetJitter( es_out_t *p_out,
                                     mtime_t i_pts_delay, mtime_t i_pts_jitter, int i_cr_average )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_JITTER,
                                i_pts_delay, i_pts_jitter, i_cr_average );
    assert( !i_ret );
}",152.0,158.0,1.0,1.0,7.0,2,2,7,6,1,0,1,1,0,0,,0,0,8,4,4,void
1039,46921,es_out_Eos,1,es_out_Eos,void es_out_Eos (es_out_t*),input\es_out.h,"static inline void es_out_Eos( es_out_t *p_out )
{
    int i_ret = es_out_Control( p_out, ES_OUT_SET_EOS );
    assert( !i_ret );
}",171.0,175.0,1.0,1.0,5.0,2,2,4,3,1,0,1,1,0,0,,0,0,2,1,1,void
1040,47128,Destroy,1,Destroy,void Destroy (es_out_t*),misc\variables.c,"static void Destroy( variable_t *p_var )
{
    p_var->ops->pf_free( &p_var->val );
    if( p_var->choices.i_count )
    {
        for( int i = 0 ; i < p_var->choices.i_count ; i++ )
        {
            p_var->ops->pf_free( &p_var->choices.p_values[i] );
            free( p_var->choices_text.p_values[i].psz_string );
        }
        free( p_var->choices.p_values );
        free( p_var->choices_text.p_values );
    }

    free( p_var->psz_name );
    free( p_var->psz_text );
    free( p_var->value_callbacks.p_entries );
    free( p_var );
}",163.0,181.0,1.0,1.0,19.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1041,47148,TsPushCmd,1,TsPushCmd,"void TsPushCmd (ts_thread_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static void TsPushCmd( ts_thread_t *p_ts, ts_cmd_t *p_cmd )
{
    vlc_mutex_lock( &p_ts->lock );

    if( !p_ts->p_storage_w || TsStorageIsFull( p_ts->p_storage_w, p_cmd ) )
    {
        ts_storage_t *p_storage = TsStorageNew( p_ts->psz_tmp_path, p_ts->i_tmp_size_max );

        if( !p_storage )
        {
            CmdClean( p_cmd );
            vlc_mutex_unlock( &p_ts->lock );
            /* TODO warn the user (but only once) */
            return;
        }

        if( !p_ts->p_storage_w )
        {
            p_ts->p_storage_r = p_ts->p_storage_w = p_storage;
        }
        else
        {
            TsStoragePack( p_ts->p_storage_w );
            p_ts->p_storage_w->p_next = p_storage;
            p_ts->p_storage_w = p_storage;
        }
    }

    /* TODO return error and warn the user (but only once) */
    TsStoragePushCmd( p_ts->p_storage_w, p_cmd, p_ts->p_storage_r == p_ts->p_storage_w );

    vlc_cond_signal( &p_ts->wait );

    vlc_mutex_unlock( &p_ts->lock );
}",855.0,889.0,1.0,1.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1042,47161,TsHasCmd,1,TsHasCmd,bool TsHasCmd (ts_thread_t*),input\es_out_timeshift.c,"static bool TsHasCmd( ts_thread_t *p_ts )
{
    bool b_cmd;

    vlc_mutex_lock( &p_ts->lock );
    b_cmd = !TsStorageIsEmpty( p_ts->p_storage_r );
    vlc_mutex_unlock( &p_ts->lock );

    return b_cmd;
}",911.0,920.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,bool
1043,47232,CmdClean,1,CmdClean,void CmdClean (ts_cmd_t*),input\es_out_timeshift.c,"static void CmdClean( ts_cmd_t *p_cmd )
{
    switch( p_cmd->i_type )
    {
    case C_ADD:
        CmdCleanAdd( p_cmd );
        break;
    case C_SEND:
        CmdCleanSend( p_cmd );
        break;
    case C_CONTROL:
        CmdCleanControl( p_cmd );
        break;
    case C_DEL:
        break;
    default:
        vlc_assert_unreachable();
        break;
    }
}",1285.0,1304.0,1.0,1.0,20.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1044,47237,cmd_cleanup_routine,1,cmd_cleanup_routine,void cmd_cleanup_routine (void*),input\es_out_timeshift.c,static void cmd_cleanup_routine( void *p ) { CmdClean( p ); },278.0,278.0,1.0,61.0,1.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1045,47265,CmdInitControl,1,CmdInitControl,"int CmdInitControl (ts_cmd_t*,int,ANY,bool)",input\es_out_timeshift.c,"static int CmdInitControl( ts_cmd_t *p_cmd, int i_query, va_list args, bool b_copy )
{
    p_cmd->i_type = C_CONTROL;
    p_cmd->i_date = mdate();
    p_cmd->u.control.i_query = i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        p_cmd->u.control.u.i_int = (int)va_arg( args, int );
        break;

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        p_cmd->u.control.u.i_i64 = (int64_t)va_arg( args, int64_t );
        break;

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        p_cmd->u.control.u.int_i64.i_int = (int)va_arg( args, int );
        p_cmd->u.control.u.int_i64.i_i64 = (in...",1375.0,1536.0,1.0,1.0,162.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
1046,47306,CmdExecuteControl,1,CmdExecuteControl,"int CmdExecuteControl (es_out_t*,ts_cmd_t*)",input\es_out_timeshift.c,"static int CmdExecuteControl( es_out_t *p_out, ts_cmd_t *p_cmd )
{
    const int i_query = p_cmd->u.control.i_query;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:    /* arg1= int                            */
    case ES_OUT_SET_GROUP:   /* arg1= int                            */
    case ES_OUT_DEL_GROUP:   /* arg1=int i_group */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_int );

    case ES_OUT_SET_PCR:                /* arg1=int64_t i_pcr(microsecond!) (using default group 0)*/
    case ES_OUT_SET_NEXT_DISPLAY_TIME:  /* arg1=int64_t i_pts(microsecond) */
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.i_i64 );

    case ES_OUT_SET_GROUP_PCR:          /* arg1= int i_group, arg2=int64_t i_pcr(microsecond!)*/
        return es_out_Control( p_out, i_query, p_cmd->u.control.u.int_i64.i_int,
                                               p_cmd->u.control.u.int_i64.i_i64 );

    case ES_OUT_RESET_PCR:    ...",1537.0,1616.0,1.0,1.0,80.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1047,47318,input_EsOutTimeshiftNew,1,input_EsOutTimeshiftNew,"es_out_t input_EsOutTimeshiftNew (input_thread_t*,es_out_t*,int)",input\es_out_timeshift.c,"es_out_t *input_EsOutTimeshiftNew( input_thread_t *p_input, es_out_t *p_next_out, int i_rate )
{
    es_out_t *p_out = malloc( sizeof(*p_out) );
    if( !p_out )
        return NULL;

    es_out_sys_t *p_sys = malloc( sizeof(*p_sys) );
    if( !p_sys )
    {
        free( p_out );
        return NULL;
    }

    /* */
    p_out->pf_add     = Add;
    p_out->pf_send    = Send;
    p_out->pf_del     = Del;
    p_out->pf_control = Control;
    p_out->pf_destroy = Destroy;
    p_out->p_sys      = p_sys;

    /* */
    p_sys->b_input_paused = false;
    p_sys->b_input_paused_source = false;
    p_sys->p_input = p_input;
    p_sys->i_input_rate = i_rate;
    p_sys->i_input_rate_source = i_rate;

    p_sys->p_out = p_next_out;
    vlc_mutex_init_recursive( &p_sys->lock );

    p_sys->b_delayed = false;
    p_sys->p_ts = NULL;

    TAB_INIT( p_sys->i_es, p_sys->pp_es );

    /* */
    const int i_tmp_size_max = var_CreateGetInteger( p_input, ""input-timeshift-granularity"" );
    if( i_tmp_si...",302.0,402.0,1.0,1.0,101.0,55,11,48,8,0,17,5,5,1,1,,0,16,6,3,3,es_out_t
1048,47765,ControlLockedGetEmpty,1,ControlLockedGetEmpty,"int ControlLockedGetEmpty (es_out_t*,bool*)",input\es_out_timeshift.c,"static int ControlLockedGetEmpty( es_out_t *p_out, bool *pb_empty )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed && TsHasCmd( p_sys->p_ts ) )
        *pb_empty = false;
    else
        *pb_empty = es_out_GetEmpty( p_sys->p_out );

    return VLC_SUCCESS;
}",498.0,508.0,1.0,1.0,11.0,7,4,7,5,1,3,2,2,3,1,,0,3,4,2,2,int
1049,47802,ControlLockedGetWakeup,1,ControlLockedGetWakeup,"int ControlLockedGetWakeup (es_out_t*,mtime_t*)",input\es_out_timeshift.c,"static int ControlLockedGetWakeup( es_out_t *p_out, mtime_t *pi_wakeup )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
    {
        assert( !input_priv(p_sys->p_input)->b_can_pace_control );
        *pi_wakeup = 0;
    }
    else
    {
        *pi_wakeup = es_out_GetWakeup( p_sys->p_out );
    }

    return VLC_SUCCESS;
}",509.0,524.0,1.0,1.0,16.0,8,4,6,4,1,3,2,2,1,1,,0,2,4,2,2,int
1050,47842,ControlLockedGetBuffering,1,ControlLockedGetBuffering,"int ControlLockedGetBuffering (es_out_t*,bool*)",input\es_out_timeshift.c,"static int ControlLockedGetBuffering( es_out_t *p_out, bool *pb_buffering )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( p_sys->b_delayed )
        *pb_buffering = true;
    else
        *pb_buffering = es_out_GetBuffering( p_sys->p_out );

    return VLC_SUCCESS;
}",525.0,535.0,1.0,1.0,11.0,5,3,6,5,1,1,2,2,1,0,,0,1,4,2,2,int
1051,47874,ControlLockedSetPauseState,1,ControlLockedSetPauseState,"int ControlLockedSetPauseState (es_out_t*,bool,bool,mtime_t)",input\es_out_timeshift.c,"static int ControlLockedSetPauseState( es_out_t *p_out, bool b_source_paused, bool b_paused, mtime_t i_date )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && !b_source_paused == !b_paused )
    {
        i_ret = es_out_SetPauseState( p_sys->p_out, b_source_paused, b_paused, i_date );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangePause( p_sys->p_ts, b_source_paused, b_paused, i_date );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }...",536.0,570.0,1.0,1.0,35.0,15,5,16,6,1,5,3,3,1,1,,0,5,8,4,4,int
1052,47969,ControlLockedSetRate,1,ControlLockedSetRate,"int ControlLockedSetRate (es_out_t*,int,int)",input\es_out_timeshift.c,"static int ControlLockedSetRate( es_out_t *p_out, int i_src_rate, int i_rate )
{
    es_out_sys_t *p_sys = p_out->p_sys;
    int i_ret;

    if( !p_sys->b_delayed && i_src_rate == i_rate )
    {
        i_ret = es_out_SetRate( p_sys->p_out, i_src_rate, i_rate );
    }
    else
    {
        i_ret = VLC_EGENERIC;
        if( !input_priv(p_sys->p_input)->b_can_pace_control )
        {
            if( !p_sys->b_delayed )
                TsStart( p_out );
            if( p_sys->b_delayed )
                i_ret = TsChangeRate( p_sys->p_ts, i_src_rate, i_rate );
        }
        else
        {
            /* XXX we may do it BUT it would be better to finish the clock clean up+improvements
             * and so be able to advertize correctly pace control property in access
             * module */
            msg_Err( p_sys->p_input, ""EsOutTimeshift does not work with streams that have pace control"" );
        }

    }

    if( !i_ret )
    {
        p_sys->i_input_rate_source = i_src_ra...",571.0,606.0,1.0,1.0,36.0,13,5,15,5,1,5,3,3,1,1,,0,5,6,3,3,int
1053,48059,ControlLockedSetTime,1,ControlLockedSetTime,"int ControlLockedSetTime (es_out_t*,mtime_t)",input\es_out_timeshift.c,"static int ControlLockedSetTime( es_out_t *p_out, mtime_t i_date )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    if( !p_sys->b_delayed )
        return es_out_SetTime( p_sys->p_out, i_date );

    /* TODO */
    msg_Err( p_sys->p_input, ""EsOutTimeshift does not yet support time change"" );
    return VLC_EGENERIC;
}",607.0,617.0,1.0,1.0,11.0,6,3,7,4,1,4,2,2,1,1,,0,3,4,2,2,int
1054,48090,ControlLockedSetFrameNext,1,ControlLockedSetFrameNext,int ControlLockedSetFrameNext (es_out_t*),input\es_out_timeshift.c,"static int ControlLockedSetFrameNext( es_out_t *p_out )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    return es_out_SetFrameNext( p_sys->p_out );
}",618.0,623.0,1.0,1.0,6.0,3,2,3,2,1,2,1,1,0,1,,0,1,2,1,1,int
1055,48106,ControlLocked,1,ControlLocked,"int ControlLocked (es_out_t*,int,va_list)",input\es_out_timeshift.c,"static int ControlLocked( es_out_t *p_out, int i_query, va_list args )
{
    es_out_sys_t *p_sys = p_out->p_sys;

    switch( i_query )
    {
    /* Pass-through control */
    case ES_OUT_SET_MODE:
    case ES_OUT_SET_GROUP:
    case ES_OUT_SET_PCR:
    case ES_OUT_SET_GROUP_PCR:
    case ES_OUT_RESET_PCR:
    case ES_OUT_SET_NEXT_DISPLAY_TIME:
    case ES_OUT_SET_GROUP_META:
    case ES_OUT_SET_GROUP_EPG:
    case ES_OUT_SET_GROUP_EPG_EVENT:
    case ES_OUT_SET_EPG_TIME:
    case ES_OUT_SET_ES_SCRAMBLED_STATE:
    case ES_OUT_DEL_GROUP:
    case ES_OUT_SET_META:
    case ES_OUT_SET_ES:
    case ES_OUT_RESTART_ES:
    case ES_OUT_RESTART_ALL_ES:
    case ES_OUT_SET_ES_DEFAULT:
    case ES_OUT_SET_ES_STATE:
    case ES_OUT_SET_ES_CAT_POLICY:
    case ES_OUT_SET_ES_FMT:
    case ES_OUT_SET_TIMES:
    case ES_OUT_SET_JITTER:
    case ES_OUT_SET_EOS:
    {
        ts_cmd_t cmd;
        if( CmdInitControl( &cmd, i_query, args, p_sys->b_delayed ) )
            return VLC_EGENERIC;
      ...",625.0,754.0,1.0,1.0,130.0,26,6,106,65,0,20,7,12,6,10,,0,11,6,3,3,int
1056,48414,TsDestroy,1,TsDestroy,void TsDestroy (ts_thread_t*),input\es_out_timeshift.c,"static void TsDestroy( ts_thread_t *p_ts )
{
    vlc_cond_destroy( &p_ts->wait );
    vlc_mutex_destroy( &p_ts->lock );
    free( p_ts );
}",774.0,779.0,1.0,1.0,6.0,4,2,3,1,0,4,1,1,0,2,,0,2,2,1,1,void
1057,51536,Trigger,1,Trigger,"void Trigger (input_thread_t*,int)",input\vlm_event.c,"static void Trigger( vlm_t *p_vlm, int i_type, int64_t id, const char *psz_name )
{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = 0;
    event.psz_instance_name = NULL;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",74.0,84.0,1.0,1.0,11.0,0,0,0,0,25,0,1,1,0,0,,0,0,8,4,4,void
1058,51542,VarListAdd,1,VarListAdd,"void VarListAdd (input_thread_t*,char*,int,int,char*)",input\event.c,"static void VarListAdd( input_thread_t *p_input,
                        const char *psz_variable, int i_event,
                        int i_value, const char *psz_text )
{
    vlc_value_t val;
    vlc_value_t text;

    val.i_int = i_value;
    text.psz_string = (char*)psz_text;

    var_Change( p_input, psz_variable, VLC_VAR_ADDCHOICE,
                &val, psz_text ? &text : NULL );

    Trigger( p_input, i_event );
}",304.0,318.0,1.0,1.0,15.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,void
1059,51551,VarListDel,1,VarListDel,"void VarListDel (input_thread_t*,char*,int,int)",input\event.c,"static void VarListDel( input_thread_t *p_input,
                        const char *psz_variable, int i_event,
                        int i_value )
{
    vlc_value_t val;

    if( i_value >= 0 )
    {
        val.i_int = i_value;
        var_Change( p_input, psz_variable, VLC_VAR_DELCHOICE, &val, NULL );
    }
    else
    {
        var_Change( p_input, psz_variable, VLC_VAR_CLEARCHOICES, &val, NULL );
    }

    Trigger( p_input, i_event );
}",319.0,336.0,1.0,1.0,18.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,void
1060,51559,VarListSelect,1,VarListSelect,"void VarListSelect (input_thread_t*,char*,int,int)",input\event.c,"static void VarListSelect( input_thread_t *p_input,
                           const char *psz_variable, int i_event,
                           int i_value )
{
    vlc_value_t val;

    val.i_int = i_value;
    var_Change( p_input, psz_variable, VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, i_event );
}",337.0,347.0,1.0,1.0,11.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,void
1061,51567,input_SendEventDead,1,input_SendEventDead,void input_SendEventDead (input_thread_t*),input\event.c,"void input_SendEventDead( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_DEAD );
}",52.0,55.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
1062,51575,input_SendEventPosition,1,input_SendEventPosition,"void input_SendEventPosition (input_thread_t*,double,mtime_t)",input\event.c,"void input_SendEventPosition( input_thread_t *p_input, double f_position, mtime_t i_time )
{
    vlc_value_t val;

    /* */
    val.f_float = f_position;
    var_Change( p_input, ""position"", VLC_VAR_SETVALUE, &val, NULL );

    /* */
    val.i_int = i_time;
    var_Change( p_input, ""time"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_POSITION );
}",57.0,70.0,1.0,1.0,14.0,6,3,14,7,1,3,1,1,0,3,,0,0,6,3,3,void
1063,51610,input_SendEventLength,1,input_SendEventLength,"void input_SendEventLength (input_thread_t*,mtime_t)",input\event.c,"void input_SendEventLength( input_thread_t *p_input, mtime_t i_length )
{
    vlc_value_t val;

    /* FIXME ugly + what about meta change event ? */
    if( var_GetInteger( p_input, ""length"" ) == i_length )
        return;

    input_item_SetDuration( input_priv(p_input)->p_item, i_length );

    val.i_int = i_length;
    var_Change( p_input, ""length"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_LENGTH );
}",71.0,85.0,1.0,1.0,15.0,5,5,12,6,1,4,2,2,0,4,,0,1,4,2,2,void
1064,51646,input_SendEventStatistics,1,input_SendEventStatistics,void input_SendEventStatistics (input_thread_t*),input\event.c,"void input_SendEventStatistics( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_STATISTICS );
}",86.0,89.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
1065,51654,input_SendEventRate,1,input_SendEventRate,"void input_SendEventRate (input_thread_t*,int)",input\event.c,"void input_SendEventRate( input_thread_t *p_input, int i_rate )
{
    vlc_value_t val;

    val.f_float = (float)INPUT_RATE_DEFAULT / (float)i_rate;
    var_Change( p_input, ""rate"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RATE );
}",90.0,98.0,1.0,1.0,9.0,6,5,9,7,0,2,1,1,0,2,,0,0,4,2,2,void
1066,51682,input_SendEventAudioDelay,1,input_SendEventAudioDelay,"void input_SendEventAudioDelay (input_thread_t*,mtime_t)",input\event.c,"void input_SendEventAudioDelay( input_thread_t *p_input, mtime_t i_delay )
{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""audio-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_AUDIO_DELAY );
}",99.0,107.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
1067,51704,input_SendEventSubtitleDelay,1,input_SendEventSubtitleDelay,"void input_SendEventSubtitleDelay (input_thread_t*,mtime_t)",input\event.c,"void input_SendEventSubtitleDelay( input_thread_t *p_input, mtime_t i_delay )
{
    vlc_value_t val;

    val.i_int = i_delay;
    var_Change( p_input, ""spu-delay"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SUBTITLE_DELAY );
}",109.0,117.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
1068,51726,input_SendEventRecord,1,input_SendEventRecord,"void input_SendEventRecord (input_thread_t*,bool)",input\event.c,"void input_SendEventRecord( input_thread_t *p_input, bool b_recording )
{
    vlc_value_t val;

    val.b_bool = b_recording;
    var_Change( p_input, ""record"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_RECORD );
}",120.0,128.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
1069,51748,input_SendEventTitle,1,input_SendEventTitle,"void input_SendEventTitle (input_thread_t*,int)",input\event.c,"void input_SendEventTitle( input_thread_t *p_input, int i_title )
{
    vlc_value_t val;

    val.i_int = i_title;
    var_Change( p_input, ""title"", VLC_VAR_SETVALUE, &val, NULL );

    input_ControlVarTitle( p_input, i_title );

    Trigger( p_input, INPUT_EVENT_TITLE );
}",130.0,140.0,1.0,1.0,11.0,3,3,10,6,1,3,1,1,0,3,,0,0,4,2,2,void
1070,51773,input_SendEventSeekpoint,1,input_SendEventSeekpoint,"void input_SendEventSeekpoint (input_thread_t*,int,int)",input\event.c,"void input_SendEventSeekpoint( input_thread_t *p_input, int i_title, int i_seekpoint )
{
    vlc_value_t val;

    /* ""chapter"" */
    val.i_int = i_seekpoint;
    var_Change( p_input, ""chapter"", VLC_VAR_SETVALUE, &val, NULL );

    /* ""title %2u"" */
    char psz_title[sizeof (""title "") + 3 * sizeof (int)];
    sprintf( psz_title, ""title %2u"", i_title );
    var_Change( p_input, psz_title, VLC_VAR_SETVALUE, &val, NULL );

    /* */
    Trigger( p_input, INPUT_EVENT_CHAPTER );
}",142.0,157.0,1.0,1.0,16.0,4,3,15,8,0,3,1,1,0,3,,0,0,6,3,3,void
1071,51808,input_SendEventSignal,1,input_SendEventSignal,"void input_SendEventSignal (input_thread_t*,double,double)",input\event.c,"void input_SendEventSignal( input_thread_t *p_input, double f_quality, double f_strength )
{
    vlc_value_t val;

    val.f_float = f_quality;
    var_Change( p_input, ""signal-quality"", VLC_VAR_SETVALUE, &val, NULL );

    val.f_float = f_strength;
    var_Change( p_input, ""signal-strength"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_SIGNAL );
}",159.0,170.0,1.0,1.0,12.0,6,3,14,7,0,3,1,1,0,3,,0,0,6,3,3,void
1072,51843,input_SendEventState,1,input_SendEventState,"void input_SendEventState (input_thread_t*,int)",input\event.c,"void input_SendEventState( input_thread_t *p_input, int i_state )
{
    vlc_value_t val;

    val.i_int = i_state;
    var_Change( p_input, ""state"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_STATE );
}",172.0,180.0,1.0,1.0,9.0,3,3,8,6,0,2,1,1,0,2,,0,0,4,2,2,void
1073,51865,input_SendEventCache,1,input_SendEventCache,"void input_SendEventCache (input_thread_t*,double)",input\event.c,"void input_SendEventCache( input_thread_t *p_input, double f_level )
{
    vlc_value_t val;

    val.f_float = f_level;
    var_Change( p_input, ""cache"", VLC_VAR_SETVALUE, &val, NULL );

    Trigger( p_input, INPUT_EVENT_CACHE );
}",182.0,190.0,1.0,1.0,9.0,3,3,8,6,1,2,1,1,0,2,,0,0,4,2,2,void
1074,51887,input_SendEventMeta,1,input_SendEventMeta,void input_SendEventMeta (input_thread_t*),input\event.c,"void input_SendEventMeta( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_META );
}",192.0,195.0,1.0,1.0,4.0,0,0,2,2,3,1,1,1,0,1,,0,0,2,1,1,void
1075,51895,input_SendEventMetaInfo,1,input_SendEventMetaInfo,void input_SendEventMetaInfo (input_thread_t*),input\event.c,"void input_SendEventMetaInfo( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_INFO );
}",197.0,200.0,1.0,1.0,4.0,0,0,2,2,3,1,1,1,0,1,,0,0,2,1,1,void
1076,51903,input_SendEventMetaEpg,1,input_SendEventMetaEpg,void input_SendEventMetaEpg (input_thread_t*),input\event.c,"void input_SendEventMetaEpg( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_ITEM_EPG );
}",202.0,205.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
1077,51911,input_SendEventProgramAdd,1,input_SendEventProgramAdd,"void input_SendEventProgramAdd (input_thread_t*,int,char*)",input\event.c,"void input_SendEventProgramAdd( input_thread_t *p_input,
                                int i_program, const char *psz_text )
{
    VarListAdd( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program, psz_text );
}",209.0,213.0,1.0,1.0,5.0,0,0,4,4,2,1,1,1,0,1,,0,0,6,3,3,void
1078,51924,input_SendEventProgramDel,1,input_SendEventProgramDel,"void input_SendEventProgramDel (input_thread_t*,int)",input\event.c,"void input_SendEventProgramDel( input_thread_t *p_input, int i_program )
{
    VarListDel( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",214.0,217.0,1.0,1.0,4.0,0,0,3,3,2,1,1,1,0,1,,0,0,4,2,2,void
1079,51935,input_SendEventProgramSelect,1,input_SendEventProgramSelect,"void input_SendEventProgramSelect (input_thread_t*,int)",input\event.c,"void input_SendEventProgramSelect( input_thread_t *p_input, int i_program )
{
    VarListSelect( p_input, ""program"", INPUT_EVENT_PROGRAM, i_program );
}",218.0,221.0,1.0,1.0,4.0,0,0,3,3,2,1,1,1,0,1,,0,0,4,2,2,void
1080,51946,input_SendEventProgramScrambled,1,input_SendEventProgramScrambled,"void input_SendEventProgramScrambled (input_thread_t*,int,bool)",input\event.c,"void input_SendEventProgramScrambled( input_thread_t *p_input, int i_group, bool b_scrambled )
{
    if( var_GetInteger( p_input, ""program"" ) != i_group )
        return;

    var_SetBool( p_input, ""program-scrambled"", b_scrambled );
    Trigger( p_input, INPUT_EVENT_PROGRAM );
}",222.0,229.0,1.0,1.0,8.0,1,1,6,4,2,1,2,2,0,1,,0,0,6,3,3,void
1081,51968,GetEsVarName,1,GetEsVarName,const char* GetEsVarName (es_format_category_e),input\event.c,"static const char *GetEsVarName( enum es_format_category_e i_cat )
{
    switch( i_cat )
    {
    case VIDEO_ES:
        return ""video-es"";
    case AUDIO_ES:
        return ""audio-es"";
    case SPU_ES:
        return ""spu-es"";
    default:
        return NULL;
    }
}",231.0,244.0,1.0,1.0,14.0,0,0,5,5,3,0,2,2,0,0,,0,0,2,1,1,const char*
1082,51991,input_SendEventEsAdd,1,input_SendEventEsAdd,"void input_SendEventEsAdd (input_thread_t*,es_format_category_e,int,char*)",input\event.c,"void input_SendEventEsAdd( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id, const char *psz_text )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListAdd( p_input, psz_varname, INPUT_EVENT_ES, i_id, psz_text );
}",245.0,250.0,1.0,1.0,6.0,1,1,8,6,1,2,2,2,0,2,,0,1,8,4,4,void
1083,52013,input_SendEventEsDel,1,input_SendEventEsDel,"void input_SendEventEsDel (input_thread_t*,es_format_category_e,int)",input\event.c,"void input_SendEventEsDel( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListDel( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",251.0,256.0,1.0,1.0,6.0,1,1,7,5,4,2,2,2,0,2,,0,1,6,3,3,void
1084,52033,input_SendEventEsSelect,1,input_SendEventEsSelect,"void input_SendEventEsSelect (input_thread_t*,es_format_category_e,int)",input\event.c,"void input_SendEventEsSelect( input_thread_t *p_input, enum es_format_category_e i_cat, int i_id )
{
    const char *psz_varname = GetEsVarName( i_cat );
    if( psz_varname )
        VarListSelect( p_input, psz_varname, INPUT_EVENT_ES, i_id );
}",258.0,263.0,1.0,1.0,6.0,1,1,7,5,1,2,2,2,0,2,,0,1,6,3,3,void
1085,52053,input_SendEventTeletextAdd,1,input_SendEventTeletextAdd,"void input_SendEventTeletextAdd (input_thread_t*,int,char*)",input\event.c,"void input_SendEventTeletextAdd( input_thread_t *p_input,
                                 int i_teletext, const char *psz_text )
{
    VarListAdd( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext, psz_text );
}",265.0,269.0,1.0,1.0,5.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
1086,52066,input_SendEventTeletextDel,1,input_SendEventTeletextDel,"void input_SendEventTeletextDel (input_thread_t*,int)",input\event.c,"void input_SendEventTeletextDel( input_thread_t *p_input, int i_teletext )
{
    VarListDel( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",270.0,273.0,1.0,1.0,4.0,0,0,3,3,2,1,1,1,0,1,,0,0,4,2,2,void
1087,52077,input_SendEventTeletextSelect,1,input_SendEventTeletextSelect,"void input_SendEventTeletextSelect (input_thread_t*,int)",input\event.c,"void input_SendEventTeletextSelect( input_thread_t *p_input, int i_teletext )
{
    VarListSelect( p_input, ""teletext-es"", INPUT_EVENT_TELETEXT, i_teletext );
}",274.0,277.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
1088,52088,input_SendEventVout,1,input_SendEventVout,void input_SendEventVout (input_thread_t*),input\event.c,"void input_SendEventVout( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_VOUT );
}",279.0,282.0,1.0,1.0,4.0,0,0,2,2,3,1,1,1,0,1,,0,0,2,1,1,void
1089,52096,input_SendEventAout,1,input_SendEventAout,void input_SendEventAout (input_thread_t*),input\event.c,"void input_SendEventAout( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_AOUT );
}",284.0,287.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,2,1,1,void
1090,52104,input_SendEventBookmark,1,input_SendEventBookmark,void input_SendEventBookmark (input_thread_t*),input\event.c,"void input_SendEventBookmark( input_thread_t *p_input )
{
    Trigger( p_input, INPUT_EVENT_BOOKMARK );
}",292.0,295.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
1091,52411,info_New,1,info_New,"info_t info_New (char*,char*)",input\info.h,"static inline info_t *info_New(const char *name, const char *value )
{
    info_t *info = malloc(sizeof(*info));
    if (!info)
        return NULL;

    info->psz_name = strdup(name);
    info->psz_value = value ? strdup(value) : NULL;
    return info;
}",29.0,38.0,1.0,1.0,10.0,9,6,11,4,1,0,2,2,0,0,,0,0,4,2,2,info_t
1092,52447,info_Delete,1,info_Delete,void info_Delete (info_t*),input\info.h,"static inline void info_Delete(info_t *i)
{
    free(i->psz_name);
    free(i->psz_value);
    free(i);
}",40.0,45.0,1.0,1.0,6.0,2,1,3,1,2,0,1,1,0,0,,0,0,2,1,1,void
1093,52462,info_category_New,1,info_category_New,info_category_t info_category_New (char*),input\info.h,"static inline info_category_t *info_category_New(const char *name)
{
    info_category_t *cat = malloc(sizeof(*cat));
    if (!cat)
        return NULL;
    cat->psz_name = strdup(name);
    cat->i_infos  = 0;
    cat->pp_infos = NULL;

    return cat;
}",47.0,57.0,1.0,1.0,11.0,10,5,10,3,2,0,2,2,0,0,,0,0,2,1,1,info_category_t
1094,52498,info_category_FindInfo,1,info_category_FindInfo,"info_t info_category_FindInfo (info_category_t*,int*,char*)",input\info.h,"static inline info_t *info_category_FindInfo(const info_category_t *cat,
                                             int *index, const char *name)
{
    for (int i = 0; i < cat->i_infos; i++) {
        if (!strcmp(cat->pp_infos[i]->psz_name, name)) {
            if (index)
                *index = i;
            return cat->pp_infos[i];
        }
    }
    return NULL;
}",59.0,70.0,1.0,1.0,12.0,11,6,12,5,4,0,4,7,0,0,,0,0,6,3,3,info_t
1095,52546,info_category_ReplaceInfo,1,info_category_ReplaceInfo,"void info_category_ReplaceInfo (info_category_t*,info_t*)",input\info.h,"static inline void info_category_ReplaceInfo(info_category_t *cat,
                                             info_t *info)
{
    int index;
    info_t *old = info_category_FindInfo(cat, &index, info->psz_name);
    if (old) {
        info_Delete(cat->pp_infos[index]);
        cat->pp_infos[index] = info;
    } else
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
}",72.0,82.0,1.0,1.0,11.0,8,4,10,4,0,2,2,2,0,2,,0,1,4,2,2,void
1096,52589,info_category_VaAddInfo,1,info_category_VaAddInfo,"info_t info_category_VaAddInfo (info_category_t*,char*,char*,va_list)",input\info.h,"static inline info_t *info_category_VaAddInfo(info_category_t *cat,
                                              const char *name,
                                              const char *format, va_list args)
{
    info_t *info = info_category_FindInfo(cat, NULL, name);
    if (!info) {
        info = info_New(name, NULL);
        if (!info)
            return NULL;
        TAB_APPEND(cat->i_infos, cat->pp_infos, info);
    } else
        free(info->psz_value);
    if (vasprintf(&info->psz_value, format, args) == -1)
        info->psz_value = NULL;
    return info;
}",84.0,99.0,1.0,1.0,16.0,12,6,19,6,2,2,4,5,0,2,,0,2,8,4,4,info_t
1097,52652,info_category_AddInfo,1,info_category_AddInfo,"info_t info_category_AddInfo (info_category_t*,char*,char*...)",input\info.h,"static inline info_t *info_category_AddInfo(info_category_t *cat,
                                            const char *name,
                                            const char *format, ...)
{
    va_list args;

    va_start(args, format);
    info_t *info = info_category_VaAddInfo(cat, name, format, args);
    va_end(args);

    return info;
}",101.0,112.0,1.0,1.0,12.0,1,1,9,5,2,1,1,1,0,1,,0,1,6,3,3,info_t
1098,52675,info_category_DeleteInfo,1,info_category_DeleteInfo,"int info_category_DeleteInfo (info_category_t*,char*)",input\info.h,"static inline int info_category_DeleteInfo(info_category_t *cat, const char *name)
{
    int index;
    if (info_category_FindInfo(cat, &index, name)) {
        info_Delete(cat->pp_infos[index]);
        TAB_ERASE(cat->i_infos, cat->pp_infos, index);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",114.0,123.0,1.0,1.0,10.0,5,3,10,5,1,2,2,2,1,2,,0,1,4,2,2,int
1099,52707,info_category_Delete,1,info_category_Delete,void info_category_Delete (info_category_t*),input\info.h,"static inline void info_category_Delete(info_category_t *cat)
{
    for (int i = 0; i < cat->i_infos; i++)
        info_Delete(cat->pp_infos[i]);
    free(cat->pp_infos);
    free(cat->psz_name);
    free(cat);
}",125.0,132.0,1.0,1.0,8.0,5,3,6,2,2,0,2,2,0,0,,0,0,2,1,1,void
1100,52804,Create,1,Create,"input_thread_t* Create (vlc_object_t*,input_item_t*,char*,ANY,input_resource_t*,vlc_renderer_item_t*)",input\input.c,"static input_thread_t *Create( vlc_object_t *p_parent, input_item_t *p_item,
                               const char *psz_header, bool b_preparsing,
                               input_resource_t *p_resource,
                               vlc_renderer_item_t *p_renderer )
{
    /* Allocate descriptor */
    input_thread_private_t *priv;

    priv = vlc_custom_create( p_parent, sizeof( *priv ), ""input"" );
    if( unlikely(priv == NULL) )
        return NULL;

    input_thread_t *p_input = &priv->input;

    char * psz_name = input_item_GetName( p_item );
    msg_Dbg( p_input, ""Creating an input for %s'%s'"",
             b_preparsing ? ""preparsing "" : """", psz_name);
    free( psz_name );

    /* Parse input options */
    input_item_ApplyOptions( VLC_OBJECT(p_input), p_item );

    p_input->obj.header = psz_header ? strdup( psz_header ) : NULL;

    /* Init Common fields */
    priv->b_preparsing = b_preparsing;
    priv->b_can_pace_control = true;
    priv->i_start = 0;
    priv-...",285.0,482.0,1.0,1.0,198.0,0,0,0,0,3,0,1,1,0,0,,0,0,12,6,6,input_thread_t
1101,52814,Init,1,Init,int Init (input_thread_t*),input\input.c,"static int Init( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *master;

    if( var_Type( p_input->obj.parent, ""meta-file"" ) )
    {
        msg_Dbg( p_input, ""Input is a meta file: disabling unneeded options"" );
        var_SetString( p_input, ""sout"", """" );
        var_SetBool( p_input, ""sout-all"", false );
        var_SetString( p_input, ""input-slave"", """" );
        var_SetInteger( p_input, ""input-repeat"", 0 );
        var_SetString( p_input, ""sub-file"", """" );
        var_SetBool( p_input, ""sub-autodetect-file"", false );
    }

    InitStatistics( p_input );
#ifdef ENABLE_SOUT
    if( InitSout( p_input ) )
        goto error;
#endif

    /* Create es out */
    priv->p_es_out = input_EsOutTimeshiftNew( p_input, priv->p_es_out_display,
                                              priv->i_rate );
    if( priv->p_es_out == NULL )
        goto error;

    /* */
    input_ChangeState( p_input, OPENING_S );
    input_SendEventC...",1344.0,1493.0,1.0,8.0,150.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1102,52819,End,1,End,void End (input_thread_t*),input\input.c,"static void End( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    /* We are at the end */
    input_ChangeState( p_input, END_S );

    /* Clean control variables */
    input_ControlVarStop( p_input );

    /* Stop es out activity */
    es_out_SetMode( priv->p_es_out, ES_OUT_MODE_NONE );

    /* Delete slave */
    for( int i = 0; i < priv->i_slave; i++ )
        InputSourceDestroy( priv->slave[i] );
    free( priv->slave );

    /* Clean up master */
    InputSourceDestroy( priv->master );
    priv->i_title = 0;
    priv->title = NULL;
    priv->i_title_offset = 0;
    priv->i_seekpoint_offset = 0;

    /* Unload all modules */
    if( priv->p_es_out )
        es_out_Delete( priv->p_es_out );
    es_out_SetMode( priv->p_es_out_display, ES_OUT_MODE_END );

    if( !priv->b_preparsing )
    {
#define CL_CO( c ) \
do { \
    stats_CounterClean( priv->counters.p_##c ); \
    priv->counters.p_##c = NULL; \
} while (0)

        if( libvlc_stats(...",1498.0,1589.0,1.0,12.0,92.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1103,52824,MainLoop,1,MainLoop,"void MainLoop (input_thread_t*,bool)",input\input.c,"static void MainLoop( input_thread_t *p_input, bool b_interactive )
{
    mtime_t i_intf_update = 0;
    mtime_t i_last_seek_mdate = 0;

    if( b_interactive && var_InheritBool( p_input, ""start-paused"" ) )
        ControlPause( p_input, mdate() );

    bool b_pause_after_eof = b_interactive &&
                           var_InheritBool( p_input, ""play-and-pause"" );
    bool b_paused_at_eof = false;

    demux_t *p_demux = input_priv(p_input)->master->p_demux;
    const bool b_can_demux = p_demux->pf_demux != NULL;

    while( !input_Stopped( p_input ) && input_priv(p_input)->i_state != ERROR_S )
    {
        mtime_t i_wakeup = -1;
        bool b_paused = input_priv(p_input)->i_state == PAUSE_S;
        /* FIXME if input_priv(p_input)->i_state == PAUSE_S the access/access_demux
         * is paused -> this may cause problem with some of them
         * The same problem can be seen when seeking while paused */
        if( b_paused )
            b_paused = !es_out_GetBuffering( input...",691.0,813.0,1.0,1.0,123.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1104,52839,ControlRelease,1,ControlRelease,"void ControlRelease (int,vlc_value_t)",input\input.c,"static void ControlRelease( int i_type, vlc_value_t val )
{
    switch( i_type )
    {
    case INPUT_CONTROL_ADD_SLAVE:
        if( val.p_address )
            input_item_slave_Delete( val.p_address );
        break;
    case INPUT_CONTROL_SET_VIEWPOINT:
    case INPUT_CONTROL_SET_INITIAL_VIEWPOINT:
    case INPUT_CONTROL_UPDATE_VIEWPOINT:
        free( val.p_address );
        break;
    case INPUT_CONTROL_SET_RENDERER:
        if( val.p_address )
            vlc_renderer_item_release( val.p_address );
        break;

    default:
        break;
    }
}",1738.0,1759.0,1.0,1.0,22.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
1105,52863,UpdateTitleSeekpointFromDemux,1,UpdateTitleSeekpointFromDemux,int UpdateTitleSeekpointFromDemux (input_thread_t*),input\input.c,"static int UpdateTitleSeekpointFromDemux( input_thread_t *p_input )
{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    /* TODO event-like */
    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE ) )
        input_SendEventTitle( p_input, demux_GetTitle( p_demux ) );

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_SEEKPOINT ) )
        input_SendEventSeekpoint( p_input, demux_GetTitle( p_demux ),
                                  demux_GetSeekpoint( p_demux ) );

    return UpdateTitleSeekpoint( p_input,
                                 demux_GetTitle( p_demux ),
                                 demux_GetSeekpoint( p_demux ) );
}",2494.0,2509.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1106,52868,UpdateGenericFromDemux,1,UpdateGenericFromDemux,void UpdateGenericFromDemux (input_thread_t*),input\input.c,"static void UpdateGenericFromDemux( input_thread_t *p_input )
{
    demux_t *p_demux = input_priv(p_input)->master->p_demux;

    if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_META ) )
        InputUpdateMeta( p_input, p_demux );

    {
        double quality;
        double strength;

        if( !demux_Control( p_demux, DEMUX_GET_SIGNAL, &quality, &strength ) )
            input_SendEventSignal( p_input, quality, strength );
    }
}",2511.0,2525.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1107,52873,UpdateTitleListfromDemux,1,UpdateTitleListfromDemux,void UpdateTitleListfromDemux (input_thread_t*),input\input.c,"static void UpdateTitleListfromDemux( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *in = priv->master;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Delete the preexisting titles */
    if( in->i_title > 0 )
    {
        for( int i = 0; i < in->i_title; i++ )
            vlc_input_title_Delete( in->title[i] );
        TAB_CLEAN( in->i_title, in->title );
        priv->i_title = 0;
        priv->title = NULL;
        in->b_title_demux = false;
    }

    /* Get the new title list */
    if( demux_Control( in->p_demux, DEMUX_GET_TITLE_INFO,
                       &in->title, &in->i_title,
                       &in->i_title_offset, &in->i_seekpoint_offset ) )
        TAB_INIT( in->i_title, in->title );
    else
        in->b_title_demux = true;

    vlc_mutex_unlock( &priv->p_item->lock );

    InitTitle( p_input );
}",2527.0,2555.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1108,52878,MRLSections,1,MRLSections,"void MRLSections (char*,int*,int*,int*,int*)",input\input.c,"static void MRLSections( const char *p,
                         int *pi_title_start, int *pi_title_end,
                         int *pi_chapter_start, int *pi_chapter_end )
{
    *pi_title_start = *pi_title_end = *pi_chapter_start = *pi_chapter_end = -1;

    int title_start, chapter_start, title_end, chapter_end;

    if( !p )
        return;

    if( *p != '-' )
        p = MRLSeekPoint( p, &title_start, &chapter_start );
    else
        title_start = chapter_start = -1;

    if( *p == '-' )
        p = MRLSeekPoint( p + 1, &title_end, &chapter_end );
    else
        title_end = chapter_end = -1;

    if( *p ) /* syntax error */
        return;

    *pi_title_start = title_start;
    *pi_title_end = title_end;
    *pi_chapter_start = chapter_start;
    *pi_chapter_end = chapter_end;
}",3345.0,3373.0,1.0,1.0,29.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
1109,52948,input_SlaveSourceAdd,1,input_SlaveSourceAdd,"int input_SlaveSourceAdd (input_thread_t*,slave_type,char*,unsigned)",input\input.c,"static int input_SlaveSourceAdd( input_thread_t *p_input,
                                 enum slave_type i_type, const char *psz_uri,
                                 unsigned i_flags )
{
    vlc_value_t count;
    const char *psz_es;
    const char *psz_forced_demux;
    const bool b_can_fail = i_flags & SLAVE_ADD_CANFAIL;
    const bool b_forced = i_flags & SLAVE_ADD_FORCED;
    const bool b_set_time = i_flags & SLAVE_ADD_SET_TIME;

    switch( i_type )
    {
    case SLAVE_TYPE_SPU:
        psz_es = ""spu-es"";
        psz_forced_demux = ""subtitle"";
        break;
    case SLAVE_TYPE_AUDIO:
        psz_es = ""audio-es"";
        psz_forced_demux = NULL;
        break;
    default:
        vlc_assert_unreachable();
    }

    if( b_forced )
        var_Change( p_input, psz_es, VLC_VAR_CHOICESCOUNT, &count, NULL );

    msg_Dbg( p_input, ""loading %s slave: %s (forced: %d)"", psz_es, psz_uri,
             b_forced );

    input_source_t *p_source = InputSourceNew( p_input, psz_uri,
   ...",3375.0,3472.0,1.0,38.0,98.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,int
1110,52956,input_SubtitleFile2Uri,1,input_SubtitleFile2Uri,"char* input_SubtitleFile2Uri (input_thread_t*,char*)",input\input.c,"static char *input_SubtitleFile2Uri( input_thread_t *p_input,
                                     const char *psz_subtitle )
{
    /* if we are provided a subtitle.sub file,
     * see if we don't have a subtitle.idx and use it instead */
    char *psz_idxpath = NULL;
    char *psz_extension = strrchr( psz_subtitle, '.');
    if( psz_extension && strcmp( psz_extension, "".sub"" ) == 0 )
    {
        psz_idxpath = strdup( psz_subtitle );
        if( psz_idxpath )
        {
            struct stat st;

            psz_extension = psz_extension - psz_subtitle + psz_idxpath;
            strcpy( psz_extension, "".idx"" );

            if( !vlc_stat( psz_idxpath, &st ) && S_ISREG( st.st_mode ) )
            {
                msg_Dbg( p_input, ""using %s as subtitle file instead of %s"",
                         psz_idxpath, psz_subtitle );
                psz_subtitle = psz_idxpath;
            }
        }
    }

    char *psz_uri = vlc_path2uri( psz_subtitle, NULL );
    free( psz_idxpath );...",3474.0,3503.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
1111,52962,input_ChangeState,1,input_ChangeState,"void input_ChangeState (input_thread_t*,int)",input\input.c,"static void input_ChangeState( input_thread_t *p_input, int i_state )
{
    if( input_priv(p_input)->i_state == i_state )
        return;

    input_priv(p_input)->i_state = i_state;
    if( i_state == ERROR_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, true );
    else if ( i_state == PLAYING_S )
        input_item_SetErrorWhenReading( input_priv(p_input)->p_item, false );
    input_SendEventState( p_input, i_state );
}",3243.0,3254.0,1.0,1.0,12.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
1112,52968,input_Create,1,input_Create,"input_thread_t input_Create (vlc_object_t*,input_item_t*,char*,input_resource_t*,vlc_renderer_item_t*)",input\input.c,"input_thread_t *input_Create( vlc_object_t *p_parent,
                              input_item_t *p_item,
                              const char *psz_log, input_resource_t *p_resource,
                              vlc_renderer_item_t *p_renderer )
{
    return Create( p_parent, p_item, psz_log, false, p_resource, p_renderer );
}",128.0,134.0,1.0,1.0,7.0,0,0,6,6,2,1,1,1,0,1,,0,0,10,5,5,input_thread_t
1113,52985,input_Read,1,input_Read,"int input_Read (vlc_object_t*,input_item_t*)",input\input.c,"int input_Read( vlc_object_t *p_parent, input_item_t *p_item )
{
    input_thread_t *p_input = Create( p_parent, p_item, NULL, false, NULL, NULL );
    if( !p_input )
        return VLC_EGENERIC;

    if( !Init( p_input ) )
    {
        MainLoop( p_input, false );
        End( p_input );
    }

    vlc_object_release( p_input );
    return VLC_SUCCESS;
}",144.0,158.0,1.0,1.0,15.0,3,2,15,7,2,5,3,3,1,5,,0,2,4,2,2,int
1114,53021,input_CreatePreparser,1,input_CreatePreparser,"input_thread_t input_CreatePreparser (vlc_object_t*,input_item_t*)",input\input.c,"input_thread_t *input_CreatePreparser( vlc_object_t *parent,
                                       input_item_t *item )
{
    return Create( parent, item, NULL, true, NULL, NULL );
}",160.0,164.0,1.0,1.0,5.0,0,0,6,4,1,1,1,1,0,1,,0,0,4,2,2,input_thread_t
1115,53035,input_Start,1,input_Start,int input_Start (input_thread_t*),input\input.c,"int input_Start( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    void *(*func)(void *) = Run;

    if( priv->b_preparsing )
        func = Preparse;

    assert( !priv->is_running );
    /* Create thread and wait for its readiness. */
    priv->is_running = !vlc_clone( &priv->thread, func, priv,
                                   VLC_THREAD_PRIORITY_INPUT );
    if( !priv->is_running )
    {
        input_ChangeState( p_input, ERROR_S );
        msg_Err( p_input, ""cannot create input thread"" );
        return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",173.0,192.0,1.0,1.0,20.0,12,4,17,8,3,8,3,3,2,3,,0,7,2,1,1,int
1116,53092,input_Stop,1,input_Stop,void input_Stop (input_thread_t*),input\input.c,"void input_Stop( input_thread_t *p_input )
{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    /* Discard all pending controls */
    for( int i = 0; i < sys->i_control; i++ )
    {
        input_control_t *ctrl = &sys->control[i];
        ControlRelease( ctrl->i_type, ctrl->val );
    }
    sys->i_control = 0;
    sys->is_stopped = true;
    vlc_cond_signal( &sys->wait_control );
    vlc_mutex_unlock( &sys->lock_control );
    vlc_interrupt_kill( &sys->interrupt );
}",199.0,215.0,1.0,1.0,17.0,22,5,17,5,4,16,2,2,1,6,,0,11,2,1,1,void
1117,53162,input_Close,1,input_Close,void input_Close (input_thread_t*),input\input.c,"void input_Close( input_thread_t *p_input )
{
    if( input_priv(p_input)->is_running )
        vlc_join( input_priv(p_input)->thread, NULL );
    vlc_interrupt_deinit( &input_priv(p_input)->interrupt );
    vlc_object_release( p_input );
}",222.0,228.0,1.0,1.0,7.0,4,2,5,2,6,6,2,2,1,6,,0,3,2,1,1,void
1118,53187,input_Destructor,1,input_Destructor,void input_Destructor (vlc_object_t*),input\input.c,"static void input_Destructor( vlc_object_t *obj )
{
    input_thread_t *p_input = (input_thread_t *)obj;
    input_thread_private_t *priv = input_priv(p_input);
#ifndef NDEBUG
    char * psz_name = input_item_GetName( priv->p_item );
    msg_Dbg( p_input, ""Destroying the input for '%s'"", psz_name);
    free( psz_name );
#endif

    if( priv->p_renderer )
        vlc_renderer_item_release( priv->p_renderer );
    if( priv->p_es_out_display )
        es_out_Delete( priv->p_es_out_display );

    if( priv->p_resource )
        input_resource_Release( priv->p_resource );
    if( priv->p_resource_private )
        input_resource_Release( priv->p_resource_private );

    input_item_Release( priv->p_item );

    vlc_mutex_destroy( &priv->counters.counters_lock );

    for( int i = 0; i < priv->i_control; i++ )
    {
        input_control_t *p_ctrl = &priv->control[i];
        ControlRelease( p_ctrl->i_type, p_ctrl->val );
    }

    vlc_cond_destroy( &priv->wait_control );
    vlc_mutex_de...",233.0,265.0,1.0,1.0,33.0,30,7,29,6,0,26,6,6,5,10,,0,18,2,1,1,void
1119,53303,input_GetItem,1,input_GetItem,input_item_t input_GetItem (input_thread_t*),input\input.c,"input_item_t *input_GetItem( input_thread_t *p_input )
{
    assert( p_input != NULL );
    return input_priv(p_input)->p_item;
}",273.0,277.0,1.0,1.0,5.0,2,2,3,2,3,1,1,1,0,1,,0,0,2,1,1,input_item_t
1120,54024,input_Stopped,1,input_Stopped,bool input_Stopped (input_thread_t*),input\input.c,"bool input_Stopped( input_thread_t *input )
{
    input_thread_private_t *sys = input_priv(input);
    bool ret;

    vlc_mutex_lock( &sys->lock_control );
    ret = sys->is_stopped;
    vlc_mutex_unlock( &sys->lock_control );
    return ret;
}",540.0,549.0,1.0,1.0,10.0,7,3,7,3,0,6,1,1,0,3,,0,4,2,1,1,bool
1121,54052,MainLoopDemux,1,MainLoopDemux,"void MainLoopDemux (input_thread_t*,bool*)",input\input.c,"static void MainLoopDemux( input_thread_t *p_input, bool *pb_changed )
{
    input_thread_private_t* p_priv = input_priv(p_input);
    demux_t *p_demux = p_priv->master->p_demux;
    int i_ret = VLC_DEMUXER_SUCCESS;

    *pb_changed = false;

    if( p_priv->i_stop > 0 )
    {
        if( demux_Control( p_demux, DEMUX_GET_TIME, &p_priv->i_time ) )
            p_priv->i_time = 0;

        if( p_priv->i_stop <= p_priv->i_time )
            i_ret = VLC_DEMUXER_EOF;
    }

    if( i_ret == VLC_DEMUXER_SUCCESS )
        i_ret = demux_Demux( p_demux );

    i_ret = i_ret > 0 ? VLC_DEMUXER_SUCCESS : ( i_ret < 0 ? VLC_DEMUXER_EGENERIC : VLC_DEMUXER_EOF);

    if( i_ret == VLC_DEMUXER_SUCCESS )
    {
        if( demux_TestAndClearFlags( p_demux, INPUT_UPDATE_TITLE_LIST ) )
            UpdateTitleListfromDemux( p_input );

        if( p_priv->master->b_title_demux )
        {
            i_ret = UpdateTitleSeekpointFromDemux( p_input );
            *pb_changed = true;
        }

        Updat...",559.0,607.0,1.0,1.0,49.0,35,9,44,12,0,15,9,13,6,6,,0,12,4,2,2,void
1122,54203,MainLoopTryRepeat,1,MainLoopTryRepeat,int MainLoopTryRepeat (input_thread_t*),input\input.c,"static int MainLoopTryRepeat( input_thread_t *p_input )
{
    int i_repeat = var_GetInteger( p_input, ""input-repeat"" );
    if( i_repeat <= 0 )
        return VLC_EGENERIC;

    vlc_value_t val;

    msg_Dbg( p_input, ""repeating the same input (%d)"", i_repeat );
    if( i_repeat > 0 )
    {
        i_repeat--;
        var_SetInteger( p_input, ""input-repeat"", i_repeat );
    }

    /* Seek to start title/seekpoint */
    val.i_int = input_priv(p_input)->master->i_title_start -
        input_priv(p_input)->master->i_title_offset;
    if( val.i_int < 0 || val.i_int >= input_priv(p_input)->master->i_title )
        val.i_int = 0;
    input_ControlPush( p_input,
                       INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = input_priv(p_input)->master->i_seekpoint_start -
        input_priv(p_input)->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input,
                           INPUT_CONTROL_SET_SEEKPOINT, &va...",609.0,651.0,1.0,1.0,43.0,37,11,34,8,0,10,6,6,2,10,,0,7,2,1,1,int
1123,54346,MainLoopStatistics,1,MainLoopStatistics,void MainLoopStatistics (input_thread_t*),input\input.c,"static void MainLoopStatistics( input_thread_t *p_input )
{
    double f_position = 0.0;
    mtime_t i_time = 0;
    mtime_t i_length = 0;

    /* update input status variables */
    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_POSITION, &f_position ) )
        f_position = 0.0;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_TIME, &i_time ) )
        i_time = 0;
    input_priv(p_input)->i_time = i_time;

    if( demux_Control( input_priv(p_input)->master->p_demux,
                       DEMUX_GET_LENGTH, &i_length ) )
        i_length = 0;

    es_out_SetTimes( input_priv(p_input)->p_es_out, f_position, i_time, i_length );

    /* update current bookmark */
    vlc_mutex_lock( &input_priv(p_input)->p_item->lock );
    input_priv(p_input)->bookmark.i_time_offset = i_time;
    vlc_mutex_unlock( &input_priv(p_input)->p_item->lock );

    stats_ComputeInputStats( p_input, input_priv(p_input)->p...",656.0,685.0,1.0,1.0,30.0,29,4,28,7,0,14,4,4,3,14,,0,7,2,1,1,void
1124,54779,InitStatistics,1,InitStatistics,void InitStatistics (input_thread_t*),input\input.c,"static void InitStatistics( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    if( priv->b_preparsing ) return;

    /* Prepare statistics */
#define INIT_COUNTER( c, compute ) free( priv->counters.p_##c ); \
    priv->counters.p_##c = \
 stats_CounterCreate( STATS_##compute);
    if( libvlc_stats( p_input ) )
    {
        INIT_COUNTER( read_bytes, COUNTER );
        INIT_COUNTER( read_packets, COUNTER );
        INIT_COUNTER( demux_read, COUNTER );
        INIT_COUNTER( input_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_bitrate, DERIVATIVE );
        INIT_COUNTER( demux_corrupted, COUNTER );
        INIT_COUNTER( demux_discontinuity, COUNTER );
        INIT_COUNTER( played_abuffers, COUNTER );
        INIT_COUNTER( lost_abuffers, COUNTER );
        INIT_COUNTER( displayed_pictures, COUNTER );
        INIT_COUNTER( lost_pictures, COUNTER );
        INIT_COUNTER( decoded_audio, COUNTER );
        INIT_COUNTER( decoded_video, COUNTER );
   ...",815.0,845.0,1.0,8.0,31.0,81,3,52,5,0,16,3,3,1,15,,0,16,2,1,1,void
1125,55044,InitTitle,1,InitTitle,void InitTitle (input_thread_t*),input\input.c,"static void InitTitle( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    input_source_t *p_master = priv->master;

    if( priv->b_preparsing )
        return;

    vlc_mutex_lock( &priv->p_item->lock );
    /* Create global title (from master) */
    priv->i_title = p_master->i_title;
    priv->title   = p_master->title;
    priv->i_title_offset = p_master->i_title_offset;
    priv->i_seekpoint_offset = p_master->i_seekpoint_offset;
    if( priv->i_title > 0 )
    {
        /* Setup variables */
        input_ControlVarNavigation( p_input );
        input_SendEventTitle( p_input, 0 );
    }

    /* Global flag */
    priv->b_can_pace_control = p_master->b_can_pace_control;
    priv->b_can_pause        = p_master->b_can_pause;
    priv->b_can_rate_control = p_master->b_can_rate_control;
    vlc_mutex_unlock( &priv->p_item->lock );
}",898.0,924.0,1.0,1.0,27.0,33,4,24,3,0,24,3,3,2,5,,0,20,2,1,1,void
1126,55141,StartTitle,1,StartTitle,void StartTitle (input_thread_t*),input\input.c,"static void StartTitle( input_thread_t * p_input )
{
    input_thread_private_t *priv = input_priv(p_input);
    vlc_value_t val;

    /* Start title/chapter */
    val.i_int = priv->master->i_title_start - priv->master->i_title_offset;
    if( val.i_int > 0 && val.i_int < priv->master->i_title )
        input_ControlPush( p_input, INPUT_CONTROL_SET_TITLE, &val );

    val.i_int = priv->master->i_seekpoint_start -
                priv->master->i_seekpoint_offset;
    if( val.i_int > 0 /* TODO: check upper boundary */ )
        input_ControlPush( p_input, INPUT_CONTROL_SET_SEEKPOINT, &val );

    /* Start/stop/run time */
    priv->i_start = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""start-time"" ));
    priv->i_stop  = llroundf(1000000.f
                                     * var_GetFloat( p_input, ""stop-time"" ));
    if( priv->i_stop <= 0 )
    {
        priv->i_stop = llroundf(1000000.f
                                     * var_GetFloat( p_in...",926.0,975.0,1.0,1.0,50.0,57,10,41,7,0,22,7,8,7,4,,0,19,2,1,1,void
1127,55395,SlaveExists,1,SlaveExists,"bool SlaveExists (input_item_slave_t**,int,char*)",input\input.c,"static bool SlaveExists( input_item_slave_t **pp_slaves, int i_slaves,
                         const char *psz_uri)
{
    for( int i = 0; i < i_slaves; i++ )
    {
        if( pp_slaves[i] != NULL
         && !strcmp( pp_slaves[i]->psz_uri, psz_uri ) )
            return true;
    }
    return false;
}",997.0,1007.0,1.0,1.0,11.0,8,7,11,7,1,0,3,4,0,0,,0,0,6,3,3,bool
1128,55434,SetSubtitlesOptions,1,SetSubtitlesOptions,void SetSubtitlesOptions (input_thread_t*),input\input.c,"static void SetSubtitlesOptions( input_thread_t *p_input )
{
    /* Get fps and set it if not already set */
    const float f_fps = input_priv(p_input)->master->f_fps;
    if( f_fps > 1.f )
    {
        var_Create( p_input, ""sub-original-fps"", VLC_VAR_FLOAT );
        var_SetFloat( p_input, ""sub-original-fps"", f_fps );

        float f_requested_fps = var_CreateGetFloat( p_input, ""sub-fps"" );
        if( f_requested_fps != f_fps )
        {
            var_Create( p_input, ""sub-fps"", VLC_VAR_FLOAT|
                                            VLC_VAR_DOINHERIT );
            var_SetFloat( p_input, ""sub-fps"", f_requested_fps );
        }
    }

    const int i_delay = var_CreateGetInteger( p_input, ""sub-delay"" );
    if( i_delay != 0 )
        var_SetInteger( p_input, ""spu-delay"", (mtime_t)i_delay * 100000 );
}",1009.0,1030.0,1.0,1.0,22.0,11,7,21,6,0,3,4,5,0,3,,0,1,2,1,1,void
1129,55501,DeduceSlaveType,1,DeduceSlaveType,"enum slave_type DeduceSlaveType (input_thread_t*,char*)",input\input.c,"static enum slave_type DeduceSlaveType( input_thread_t *p_input,
                                        const char *psz_uri )
{
    vlc_url_t parsed_uri;
    if( vlc_UrlParse( &parsed_uri, psz_uri ) != VLC_SUCCESS ||
        parsed_uri.psz_path == NULL )
    {
        goto fail;
    }

    enum slave_type i_type;
    if( !input_item_slave_GetType( parsed_uri.psz_path, &i_type ) )
        goto fail;

    vlc_UrlClean( &parsed_uri );
    return i_type;

fail:
    msg_Dbg( p_input, ""Can't deduce slave type of \""%s\"" with file extension."",
             psz_uri );
    vlc_UrlClean( &parsed_uri );
    return SLAVE_TYPE_AUDIO;
}",1032.0,1054.0,1.0,1.0,23.0,10,6,13,7,1,4,5,3,2,4,,0,2,4,2,2,enum slave_type
1130,55549,GetVarSlaves,1,GetVarSlaves,"void GetVarSlaves (input_thread_t*,input_item_slave_t***,int*)",input\input.c,"static void GetVarSlaves( input_thread_t *p_input,
                          input_item_slave_t ***ppp_slaves, int *p_slaves )
{
    char *psz = var_GetNonEmptyString( p_input, ""input-slave"" );
    if( !psz )
        return;

    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;

    char *psz_org = psz;
    while( psz && *psz )
    {
        while( *psz == ' ' || *psz == '#' )
            psz++;

        char *psz_delim = strchr( psz, '#' );
        if( psz_delim )
            *psz_delim++ = '\0';

        if( *psz == 0 )
            break;

        char *uri = strstr(psz, ""://"")
                                   ? strdup( psz ) : vlc_path2uri( psz, NULL );
        psz = psz_delim;
        if( uri == NULL )
            continue;

        const enum slave_type i_type = DeduceSlaveType( p_input, uri );
        input_item_slave_t *p_slave =
            input_item_slave_New( uri, i_type, SLAVE_PRIORITY_USER );
        free( uri );

        if( unlikely( p_sla...",1056.0,1098.0,1.0,1.0,43.0,31,8,45,13,1,3,11,13,0,3,,0,3,6,3,3,void
1131,55677,LoadSlaves,1,LoadSlaves,void LoadSlaves (input_thread_t*),input\input.c,"static void LoadSlaves( input_thread_t *p_input )
{
    input_item_slave_t **pp_slaves;
    int i_slaves;
    TAB_INIT( i_slaves, pp_slaves );

    /* Look for and add slaves */

    char *psz_subtitle = var_GetNonEmptyString( p_input, ""sub-file"" );
    if( psz_subtitle != NULL )
    {
        msg_Dbg( p_input, ""forced subtitle: %s"", psz_subtitle );
        char *psz_uri = input_SubtitleFile2Uri( p_input, psz_subtitle );
        free( psz_subtitle );
        psz_subtitle = NULL;
        if( psz_uri != NULL )
        {
            input_item_slave_t *p_slave =
                input_item_slave_New( psz_uri, SLAVE_TYPE_SPU,
                                      SLAVE_PRIORITY_USER );
            free( psz_uri );
            if( p_slave )
            {
                TAB_APPEND(i_slaves, pp_slaves, p_slave);
                psz_subtitle = p_slave->psz_uri;
            }
        }
    }

    if( var_GetBool( p_input, ""sub-autodetect-file"" ) )
    {
        /* Add local subtitles */
    ...",1100.0,1256.0,1.0,29.0,157.0,120,17,166,26,0,20,25,47,6,20,,0,13,2,1,1,void
1132,56184,UpdatePtsDelay,1,UpdatePtsDelay,void UpdatePtsDelay (input_thread_t*),input\input.c,"static void UpdatePtsDelay( input_thread_t *p_input )
{
    input_thread_private_t *p_sys = input_priv(p_input);

    /* Get max pts delay from input source */
    mtime_t i_pts_delay = p_sys->master->i_pts_delay;
    for( int i = 0; i < p_sys->i_slave; i++ )
        i_pts_delay = __MAX( i_pts_delay, p_sys->slave[i]->i_pts_delay );

    if( i_pts_delay < 0 )
        i_pts_delay = 0;

    /* Take care of audio/spu delay */
    const mtime_t i_audio_delay = var_GetInteger( p_input, ""audio-delay"" );
    const mtime_t i_spu_delay   = var_GetInteger( p_input, ""spu-delay"" );
    const mtime_t i_extra_delay = __MIN( i_audio_delay, i_spu_delay );
    if( i_extra_delay < 0 )
        i_pts_delay -= i_extra_delay;

    /* Update cr_average depending on the caching */
    const int i_cr_average = var_GetInteger( p_input, ""cr-average"" ) * i_pts_delay / DEFAULT_PTS_DELAY;

    /* */
    es_out_SetDelay( input_priv(p_input)->p_es_out_display, AUDIO_ES, i_audio_delay );
    es_out_SetDelay( input_p...",1258.0,1284.0,1.0,1.0,27.0,20,6,32,11,1,9,4,4,1,7,,0,6,2,1,1,void
1133,56292,InitPrograms,1,InitPrograms,void InitPrograms (input_thread_t*),input\input.c,"static void InitPrograms( input_thread_t * p_input )
{
    int i_es_out_mode;
    vlc_list_t list;

    /* Compute correct pts_delay */
    UpdatePtsDelay( p_input );

    /* Set up es_out */
    i_es_out_mode = ES_OUT_MODE_AUTO;
    if( input_priv(p_input)->p_sout && !input_priv(p_input)->p_renderer )
    {
        char *prgms;

        if( (prgms = var_GetNonEmptyString( p_input, ""programs"" )) != NULL )
        {
            char *buf;

            TAB_INIT( list.i_count, list.p_values );
            for( const char *prgm = strtok_r( prgms, "","", &buf );
                 prgm != NULL;
                 prgm = strtok_r( NULL, "","", &buf ) )
            {
                vlc_value_t val = { .i_int = atoi( prgm ) };
                TAB_APPEND(list.i_count, list.p_values, val);
            }

            if( list.i_count > 0 )
                i_es_out_mode = ES_OUT_MODE_PARTIAL;
                /* Note : we should remove the ""program"" callback. */

            free( prgms );
        }
  ...",1286.0,1342.0,1.0,1.0,57.0,25,11,32,13,0,6,6,11,2,6,,0,3,2,1,1,void
1134,57804,input_ControlPush,1,input_ControlPush,"void input_ControlPush (input_thread_t*,int,vlc_value_t*)",input\input.c,"void input_ControlPush( input_thread_t *p_input,
                        int i_type, vlc_value_t *p_val )
{
    input_thread_private_t *sys = input_priv(p_input);

    vlc_mutex_lock( &sys->lock_control );
    if( sys->is_stopped || sys->i_control >= INPUT_CONTROL_FIFO_SIZE )
    {
        if( sys->is_stopped )
            msg_Dbg( p_input, ""input control stopped, trashing type=%d"",
                     i_type );
        else
            msg_Err( p_input, ""input control fifo overflow, trashing type=%d"",
                     i_type );
        if( p_val )
            ControlRelease( i_type, *p_val );
    }
    else
    {
        input_control_t c;
        c.i_type = i_type;
        if( p_val )
            c.val = *p_val;
        else
            memset( &c.val, 0, sizeof(c.val) );

        sys->control[sys->i_control++] = c;

        vlc_cond_signal( &sys->wait_control );
    }
    vlc_mutex_unlock( &sys->lock_control );
}",1594.0,1625.0,1.0,45.0,32.0,11,6,12,4,12,9,4,6,3,4,,0,6,6,3,3,void
1135,57905,ControlGetReducedIndexLocked,1,ControlGetReducedIndexLocked,int ControlGetReducedIndexLocked (input_thread_t*),input\input.c,"static int ControlGetReducedIndexLocked( input_thread_t *p_input )
{
    const int i_lt = input_priv(p_input)->control[0].i_type;
    int i;
    for( i = 1; i < input_priv(p_input)->i_control; i++ )
    {
        const int i_ct = input_priv(p_input)->control[i].i_type;

        if( i_lt == i_ct &&
            ( i_ct == INPUT_CONTROL_SET_STATE ||
              i_ct == INPUT_CONTROL_SET_RATE ||
              i_ct == INPUT_CONTROL_SET_POSITION ||
              i_ct == INPUT_CONTROL_SET_TIME ||
              i_ct == INPUT_CONTROL_SET_PROGRAM ||
              i_ct == INPUT_CONTROL_SET_TITLE ||
              i_ct == INPUT_CONTROL_SET_SEEKPOINT ||
              i_ct == INPUT_CONTROL_SET_BOOKMARK ) )
        {
            continue;
        }
        else
        {
            /* TODO but that's not that important
                - merge SET_X with SET_X_CMD
                - ignore SET_SEEKPOINT/SET_POSITION/SET_TIME before a SET_TITLE
                - ignore SET_SEEKPOINT/SET_POSITION/SET...",1627.0,1659.0,1.0,1.0,33.0,29,9,27,12,0,3,4,4,1,3,,0,3,2,1,1,int
1136,58319,ControlUnpause,1,ControlUnpause,"void ControlUnpause (input_thread_t*,mtime_t)",input\input.c,"static void ControlUnpause( input_thread_t *p_input, mtime_t i_control_date )
{
    if( input_priv(p_input)->b_can_pause )
    {
        demux_t *p_demux = input_priv(p_input)->master->p_demux;

        if( demux_Control( p_demux, DEMUX_SET_PAUSE_STATE, false ) )
        {
            msg_Err( p_input, ""cannot resume"" );
            input_ChangeState( p_input, ERROR_S );
            return;
        }
    }

    /* Switch to play */
    input_ChangeState( p_input, PLAYING_S );
    es_out_SetPauseState( input_priv(p_input)->p_es_out, false, false, i_control_date );
}",1789.0,1806.0,1.0,1.0,18.0,5,2,15,7,0,6,3,4,1,6,,0,3,4,2,2,void
1137,58364,ViewpointApply,1,ViewpointApply,void ViewpointApply (input_thread_t*),input\input.c,"static void ViewpointApply( input_thread_t *p_input )
{
    input_thread_private_t *priv = input_priv(p_input);

    vlc_viewpoint_clip( &priv->viewpoint );

    vout_thread_t **pp_vout;
    size_t i_vout;
    input_resource_HoldVouts( priv->p_resource, &pp_vout, &i_vout );

    for( size_t i = 0; i < i_vout; ++i )
    {
        var_SetAddress( pp_vout[i], ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( pp_vout[i], ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL );
        vlc_object_release( pp_vout[i] );
    }
    free( pp_vout );

    audio_output_t *p_aout = input_resource_HoldAout( priv->p_resource );
    if( p_aout )
    {

        var_SetAddress( p_aout, ""viewpoint"", &priv->viewpoint );
        /* This variable can only be read from callbacks */
        var_Change( p_aout, ""viewpoint"", VLC_VAR_SETVALUE,
                    &(vlc_value_t) { .p_address = NULL }, NULL )...",1808.0,1838.0,1.0,1.0,31.0,25,7,32,9,1,12,3,3,0,7,,0,7,2,1,1,void
1138,58463,ControlNavDisplayVolume,1,ControlNavDisplayVolume,"void ControlNavDisplayVolume (vout_thread_t*,float)",input\input.c,"static void ControlNavDisplayVolume( vout_thread_t *p_vout, float vol )
{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, _( ""Volume %ld%%"" ),
                     lroundf( vol * 100.f ) );
}",1843.0,1848.0,1.0,1.0,6.0,1,1,5,3,0,2,1,1,0,2,,0,0,4,2,2,void
1139,58481,ControlNavDisplayPosition,1,ControlNavDisplayPosition,"void ControlNavDisplayPosition (vout_thread_t*,input_thread_t*)",input\input.c,"static void ControlNavDisplayPosition( vout_thread_t *p_vout,
                                       input_thread_t *p_input )
{
    vout_FlushSubpictureChannel( p_vout, VOUT_SPU_CHANNEL_OSD );

    int64_t t = var_GetInteger( p_input, ""time"" ) / CLOCK_FREQ;
    int64_t l = var_GetInteger( p_input, ""length"" ) / CLOCK_FREQ;

    char psz_time[MSTRTIME_MAX_SIZE];
    secstotimestr( psz_time, t );

    if( l > 0 )
    {
        char psz_duration[MSTRTIME_MAX_SIZE];

        secstotimestr( psz_duration, l );
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD,
                         ""%s / %s"", psz_time, psz_duration );
    }
    else if( t > 0 )
    {
        vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_time );
    }
}",1850.0,1873.0,1.0,1.0,24.0,5,3,17,8,1,4,2,2,0,4,,0,0,4,2,2,void
1140,58537,ControlNav,1,ControlNav,"void ControlNav (input_thread_t*,int)",input\input.c,"static void ControlNav( input_thread_t *p_input, int i_type )
{
    input_thread_private_t *priv = input_priv(p_input);

    if( !demux_Control( priv->master->p_demux, i_type
                        - INPUT_CONTROL_NAV_ACTIVATE + DEMUX_NAV_ACTIVATE ) )
        return; /* The demux handled the navigation control */

    /* Handle Up/Down/Left/Right if the demux can't navigate */
    vlc_viewpoint_t vp = {};
    int vol_direction = 0;
    int seek_direction = 0;
    switch( i_type )
    {
        case INPUT_CONTROL_NAV_UP:
            vol_direction = 1;
            vp.pitch = -1.f;
            break;
        case INPUT_CONTROL_NAV_DOWN:
            vol_direction = -1;
            vp.pitch = 1.f;
            break;
        case INPUT_CONTROL_NAV_LEFT:
            seek_direction = -1;
            vp.yaw = -1.f;
            break;
        case INPUT_CONTROL_NAV_RIGHT:
            seek_direction = 1;
            vp.yaw = 1.f;
            break;
        case INPUT_CONTROL_NAV_ACTIVATE:
   ...",1875.0,1962.0,1.0,1.0,88.0,62,16,64,22,0,11,14,11,1,4,,0,8,4,2,2,void
1141,58802,ControlInsertDemuxFilter,1,ControlInsertDemuxFilter,"void ControlInsertDemuxFilter (input_thread_t*,char*)",input\input.c,"static void ControlInsertDemuxFilter( input_thread_t* p_input, const char* psz_demux_chain )
{
    input_source_t *p_inputSource = input_priv(p_input)->master;
    demux_t *p_filtered_demux = demux_FilterChainNew( p_inputSource->p_demux, psz_demux_chain );
    if ( p_filtered_demux != NULL )
        p_inputSource->p_demux = p_filtered_demux;
    else if ( psz_demux_chain != NULL )
        msg_Dbg(p_input, ""Failed to create demux filter %s"", psz_demux_chain);
}",1984.0,1992.0,1.0,1.0,9.0,7,3,9,5,0,4,2,2,0,2,,0,4,4,2,2,void
1142,60086,UpdateTitleSeekpoint,1,UpdateTitleSeekpoint,"int UpdateTitleSeekpoint (input_thread_t*,int,int)",input\input.c,"static int UpdateTitleSeekpoint( input_thread_t *p_input,
                                 int i_title, int i_seekpoint )
{
    int i_title_end = input_priv(p_input)->master->i_title_end -
                        input_priv(p_input)->master->i_title_offset;
    int i_seekpoint_end = input_priv(p_input)->master->i_seekpoint_end -
                            input_priv(p_input)->master->i_seekpoint_offset;

    if( i_title_end >= 0 && i_seekpoint_end >= 0 )
    {
        if( i_title > i_title_end ||
            ( i_title == i_title_end && i_seekpoint > i_seekpoint_end ) )
            return VLC_DEMUXER_EOF;
    }
    else if( i_seekpoint_end >= 0 )
    {
        if( i_seekpoint > i_seekpoint_end )
            return VLC_DEMUXER_EOF;
    }
    else if( i_title_end >= 0 )
    {
        if( i_title > i_title_end )
            return VLC_DEMUXER_EOF;
    }
    return VLC_DEMUXER_SUCCESS;
}",2465.0,2490.0,1.0,1.0,26.0,20,8,16,7,0,4,3,4,0,4,,0,4,6,3,3,int
1143,60376,InputStreamHandleAnchor,1,InputStreamHandleAnchor,"int InputStreamHandleAnchor (input_source_t*,stream_t**,char*)",input\input.c,"static int
InputStreamHandleAnchor( input_source_t *source, stream_t **stream,
                         char const *anchor )
{
    char const* extra;
    if( stream_extractor_AttachParsed( stream, anchor, &extra ) )
    {
        msg_Err( source, ""unable to attach stream-extractors for %s"",
            (*stream)->psz_url );

        return VLC_EGENERIC;
    }

    if( vlc_stream_directory_Attach( stream, NULL ) )
        msg_Dbg( source, ""attachment of directory-extractor failed for %s"",
            (*stream)->psz_url );

    MRLSections( extra ? extra : """",
        &source->i_title_start, &source->i_title_end,
        &source->i_seekpoint_start, &source->i_seekpoint_end );

    return VLC_SUCCESS;
}",2557.0,2579.0,1.0,1.0,23.0,14,4,17,7,1,7,3,3,2,3,,0,6,6,3,3,int
1144,60435,InputDemuxNew,1,InputDemuxNew,"demux_t InputDemuxNew (input_thread_t*,input_source_t*,char*,char*,char*,char*)",input\input.c,"static demux_t *InputDemuxNew( input_thread_t *p_input, input_source_t *p_source,
                               const char *psz_access, const char *psz_demux,
                               const char *psz_path, const char *psz_anchor )
{
    input_thread_private_t *priv = input_priv(p_input );
    demux_t *p_demux = NULL;

    /* first, try to create an access demux */
    p_demux = demux_NewAdvanced( VLC_OBJECT( p_source ), p_input,
                                 psz_access, psz_demux, psz_path,
                                 NULL, priv->p_es_out, priv->b_preparsing );
    if( p_demux )
    {
        MRLSections( psz_anchor,
            &p_source->i_title_start, &p_source->i_title_end,
            &p_source->i_seekpoint_start, &p_source->i_seekpoint_end );

        return p_demux;
    }

    /* not an access-demux: create the underlying access stream */
    char *psz_base_mrl;

    if( asprintf( &psz_base_mrl, ""%s://%s"", psz_access, psz_path ) < 0 )
        return NULL;

    ...",2581.0,2646.0,1.0,14.0,66.0,29,5,77,12,0,22,11,9,1,9,,0,20,12,6,6,demux_t
1145,62032,InputGetExtraFilesPattern,1,InputGetExtraFilesPattern,"void InputGetExtraFilesPattern (input_thread_t*,int*,char***,char*,char*,char*,int,int)",input\input.c,"static void InputGetExtraFilesPattern( input_thread_t *p_input,
                                       int *pi_list, char ***pppsz_list,
                                       const char *psz_path,
                                       const char *psz_match,
                                       const char *psz_format,
                                       int i_start, int i_stop )
{
    int i_list;
    char **ppsz_list;
    TAB_INIT( i_list, ppsz_list );

    char *psz_base = strdup( psz_path );
    if( !psz_base )
        goto exit;

    /* Remove the extension */
    char *psz_end = &psz_base[strlen(psz_base)-strlen(psz_match)];
    assert( psz_end >= psz_base);
    *psz_end = '\0';

    /* Try to list files */
    for( int i = i_start; i <= i_stop; i++ )
    {
        char *psz_probe;
        if( asprintf( &psz_probe, psz_format, psz_base, i ) < 0 )
            break;

        char *filepath = get_path( psz_probe );

        struct stat st;
        if( filepath == NULL ||
   ...",3141.0,3192.0,1.0,1.0,52.0,28,12,46,18,0,3,9,9,1,3,,0,3,16,8,8,void
1146,62989,input_UpdateStatistic,1,input_UpdateStatistic,"void input_UpdateStatistic (input_thread_t*,input_statistic_t,int)",input\input.c,"void input_UpdateStatistic( input_thread_t *p_input,
                            input_statistic_t i_type, int i_delta )
{
    assert( input_priv(p_input)->i_state != INIT_S );

    vlc_mutex_lock( &input_priv(p_input)->counters.counters_lock);
    switch( i_type )
    {
#define I(c) stats_Update( input_priv(p_input)->counters.c, i_delta, NULL )
    case INPUT_STATISTIC_DECODED_VIDEO:
        I(p_decoded_video);
        break;
    case INPUT_STATISTIC_DECODED_AUDIO:
        I(p_decoded_audio);
        break;
    case INPUT_STATISTIC_DECODED_SUBTITLE:
        I(p_decoded_sub);
        break;
    case INPUT_STATISTIC_SENT_PACKET:
        I(p_sout_sent_packets);
        break;
#undef I
    case INPUT_STATISTIC_SENT_BYTE:
    {
        uint64_t bytes;

        stats_Update( input_priv(p_input)->counters.p_sout_sent_bytes, i_delta, &bytes );
        stats_Update( input_priv(p_input)->counters.p_sout_send_bitrate, bytes, NULL );
        break;
    }
    default:
        msg_Err( p_input, ...",3508.0,3543.0,1.0,8.0,36.0,21,4,30,11,0,17,8,2,0,17,,0,8,6,3,3,void
1147,63108,input_CreateFilename,1,input_CreateFilename,"char* input_CreateFilename (input_thread_t*,char*,char*,char*)",input\input.c,"char *input_CreateFilename(input_thread_t *input, const char *dir,
                           const char *filenamefmt, const char *ext)
{
    char *path;
    char *filename = str_format(input, filenamefmt);
    if (unlikely(filename == NULL))
        return NULL;

    filename_sanitize(filename);

    if (((ext != NULL)
            ? asprintf(&path, ""%s""DIR_SEP""%s.%s"", dir, filename, ext)
            : asprintf(&path, ""%s""DIR_SEP""%s"", dir, filename)) < 0)
        path = NULL;

    free(filename);
    return path;
}",3547.0,3564.0,1.0,1.0,18.0,3,2,11,5,0,1,3,3,0,1,,0,0,8,4,4,char*
1148,63152,input_item_SignalPreparseEnded,1,input_item_SignalPreparseEnded,"void input_item_SignalPreparseEnded (input_item_t*,int)",input\item.c,"void input_item_SignalPreparseEnded( input_item_t *p_i, int status )
{
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemPreparseEnded,
        .u.input_item_preparse_ended.new_status = status } );
}",69.0,74.0,1.0,1.0,6.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,void
1149,63158,input_item_SetPreparsed,1,input_item_SetPreparsed,"void input_item_SetPreparsed (input_item_t*,bool)",input\item.c,"void input_item_SetPreparsed( input_item_t *p_i, bool b_preparsed )
{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);
    int new_status;
    if( b_preparsed )
        new_status = status | ITEM_PREPARSED;
    else
        new_status = status & ~ITEM_PREPARSED;
    if( status != new_status )
    {
        vlc_meta_SetStatus(p_i->p_meta, new_status);
        b_send_event = true;
    }

    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemPreparsedChanged,
            .u.input_item_preparsed_changed.new_status = new_status } );
    }
}",76.0,105.0,1.0,1.0,30.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1150,63164,input_item_SetArtNotFound,1,input_item_SetArtNotFound,"void input_item_SetArtNotFound (input_item_t*,bool)",input\item.c,"void input_item_SetArtNotFound( input_item_t *p_i, bool b_not_found )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_not_found )
        status |= ITEM_ART_NOTFOUND;
    else
        status &= ~ITEM_ART_NOTFOUND;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",107.0,124.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1151,63170,input_item_SetArtFetched,1,input_item_SetArtFetched,"void input_item_SetArtFetched (input_item_t*,bool)",input\item.c,"void input_item_SetArtFetched( input_item_t *p_i, bool b_art_fetched )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();

    int status = vlc_meta_GetStatus(p_i->p_meta);

    if( b_art_fetched )
        status |= ITEM_ART_FETCHED;
    else
        status &= ~ITEM_ART_FETCHED;

    vlc_meta_SetStatus(p_i->p_meta, status);

    vlc_mutex_unlock( &p_i->lock );
}",126.0,143.0,1.0,1.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1152,63176,input_item_SetEpg,1,input_item_SetEpg,"void input_item_SetEpg (input_item_t*,vlc_epg_t*,ANY)",input\item.c,"void input_item_SetEpg( input_item_t *p_item, const vlc_epg_t *p_update, bool b_current_source )
{
    vlc_epg_t *p_epg = vlc_epg_Duplicate( p_update );
    if( !p_epg )
        return;

    vlc_mutex_lock( &p_item->lock );

    /* */
    vlc_epg_t **pp_epg = NULL;
    for( int i = 0; i < p_item->i_epg; i++ )
    {
        if( p_item->pp_epg[i]->i_source_id == p_update->i_source_id &&
            p_item->pp_epg[i]->i_id == p_update->i_id )
        {
            pp_epg = &p_item->pp_epg[i];
            break;
        }
    }

    /* replace with new version */
    if( pp_epg )
    {
        vlc_epg_Delete( *pp_epg );
        if( *pp_epg == p_item->p_epg_table ) /* current table can have changed */
            p_item->p_epg_table = NULL;
        *pp_epg = p_epg;
    }
    else
    {
        TAB_APPEND( p_item->i_epg, p_item->pp_epg, p_epg );
    }

    if( b_current_source && p_epg->b_present )
        p_item->p_epg_table = p_epg;

    vlc_mutex_unlock( &p_item->lock );

#ifdef EPG_DE...",919.0,994.0,1.0,1.0,76.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1153,63183,input_item_ChangeEPGSource,1,input_item_ChangeEPGSource,"void input_item_ChangeEPGSource (input_item_t*,int)",input\item.c,"void input_item_ChangeEPGSource( input_item_t *p_item, int i_source_id )
{
    vlc_mutex_lock( &p_item->lock );
    p_item->p_epg_table = NULL;
    if( i_source_id > 0 )
    {
        /* Update pointer to current/next table in the full schedule */
        for( int i = 0; i < p_item->i_epg; i++ )
        {
            if( p_item->pp_epg[i]->i_source_id == i_source_id &&
                p_item->pp_epg[i]->b_present )
            {
                p_item->p_epg_table = p_item->pp_epg[i];
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );
}",996.0,1014.0,1.0,1.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1154,63189,input_item_SetEpgEvent,1,input_item_SetEpgEvent,"void input_item_SetEpgEvent (input_item_t*,vlc_epg_event_t*)",input\item.c,"void input_item_SetEpgEvent( input_item_t *p_item, const vlc_epg_event_t *p_epg_evt )
{
    bool b_changed = false;
    vlc_mutex_lock( &p_item->lock );

    for( int i = 0; i < p_item->i_epg; i++ )
    {
        vlc_epg_t *p_epg = p_item->pp_epg[i];
        for( size_t j = 0; j < p_epg->i_event; j++ )
        {
            /* Same event can exist in more than one table */
            if( p_epg->pp_event[j]->i_id == p_epg_evt->i_id )
            {
                vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_epg_evt );
                if( p_dup )
                {
                    if( p_epg->p_current == p_epg->pp_event[j] )
                        p_epg->p_current = p_dup;
                    vlc_epg_event_Delete( p_epg->pp_event[j] );
                    p_epg->pp_event[j] = p_dup;
                    b_changed = true;
                }
                break;
            }
        }
    }
    vlc_mutex_unlock( &p_item->lock );

    if ( b_changed )
    {
        vlc_event...",867.0,900.0,1.0,1.0,34.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1155,63195,input_item_SetEpgTime,1,input_item_SetEpgTime,"void input_item_SetEpgTime (input_item_t*,ANY)",input\item.c,"void input_item_SetEpgTime( input_item_t *p_item, int64_t i_time )
{
    vlc_mutex_lock( &p_item->lock );
    p_item->i_epg_time = i_time;
    vlc_mutex_unlock( &p_item->lock );
}",1016.0,1021.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1156,63219,input_resource_TerminateSout,1,input_resource_TerminateSout,void input_resource_TerminateSout (input_resource_t*),input\resource.c,"void input_resource_TerminateSout( input_resource_t *p_resource )
{
    input_resource_RequestSout( p_resource, NULL, NULL );
}",511.0,514.0,1.0,1.0,4.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1157,63364,input_priv,1,input_priv,input_thread_private_t input_priv (input_thread_t*),input\input_internal.h,"static inline input_thread_private_t *input_priv(input_thread_t *input)
{
    return container_of(input, input_thread_private_t, input);
}",181.0,184.0,1.0,1.0,4.0,0,0,3,2,119,0,1,1,0,0,,0,0,2,1,1,input_thread_private_t
1158,63433,input_ControlVarNavigation,1,input_ControlVarNavigation,void input_ControlVarNavigation (input_thread_t*),input\var.c,"void input_ControlVarNavigation( input_thread_t *p_input )
{
    vlc_value_t text;

    /* Create more command variables */
    if( input_priv(p_input)->i_title > 1 )
    {
        if( var_Type( p_input, ""next-title"" ) == 0 ) {
            var_Create( p_input, ""next-title"", VLC_VAR_VOID );
            text.psz_string = _(""Next title"");
            var_Change( p_input, ""next-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""next-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""prev-title"" ) == 0 ) {
            var_Create( p_input, ""prev-title"", VLC_VAR_VOID );
            text.psz_string = _(""Previous title"");
            var_Change( p_input, ""prev-title"", VLC_VAR_SETTEXT, &text, NULL );
            var_AddCallback( p_input, ""prev-title"", TitleCallback, NULL );
        }

        if( var_Type( p_input, ""menu-title"" ) == 0 ) {
            var_Create( p_input, ""menu-title"", VLC_VAR_VOID );
            text.psz_string = _(""Menu titl...",255.0,359.0,1.0,1.0,105.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1159,63438,input_ControlVarTitle,1,input_ControlVarTitle,"void input_ControlVarTitle (input_thread_t*,int)",input\var.c,"void input_ControlVarTitle( input_thread_t *p_input, int i_title )
{
    const input_title_t *t = input_priv(p_input)->title[i_title];
    vlc_value_t text;
    int  i;

    /* Create/Destroy command variables */
    if( t->i_seekpoint <= 1 )
    {
        var_Destroy( p_input, ""next-chapter"" );
        var_Destroy( p_input, ""prev-chapter"" );
    }
    else if( var_Type( p_input, ""next-chapter"" ) == 0 )
    {
        var_Create( p_input, ""next-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Next chapter"");
        var_Change( p_input, ""next-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""next-chapter"", SeekpointCallback, NULL );

        var_Create( p_input, ""prev-chapter"", VLC_VAR_VOID );
        text.psz_string = _(""Previous chapter"");
        var_Change( p_input, ""prev-chapter"", VLC_VAR_SETTEXT, &text, NULL );
        var_AddCallback( p_input, ""prev-chapter"", SeekpointCallback, NULL );
    }

    /* Build chapter list */
    var_Change( p_input...",365.0,413.0,1.0,1.0,49.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1160,63449,subtitles_Detect,1,subtitles_Detect,"int subtitles_Detect (input_thread_t*,char*,char*,input_item_slave_t***,int*)",input\subtitles.c,"int subtitles_Detect( input_thread_t *p_this, char *psz_path, const char *psz_name_org,
                      input_item_slave_t ***ppp_slaves, int *p_slaves )
{
    int i_fuzzy = var_GetInteger( p_this, ""sub-autodetect-fuzzy"" );
    if ( i_fuzzy == 0 )
        return VLC_EGENERIC;
    int i_fname_len;
    input_item_slave_t **pp_slaves = *ppp_slaves;
    int i_slaves = *p_slaves;
    char *f_fname_noext = NULL, *f_fname_trim = NULL;
    char **subdirs; /* list of subdirectories to look in */

    if( !psz_name_org )
        return VLC_EGENERIC;

    char *psz_fname = vlc_uri2path( psz_name_org );
    if( !psz_fname )
        return VLC_EGENERIC;

    /* extract filename & dirname from psz_fname */
    char *f_dir = strdup( psz_fname );
    if( f_dir == 0 )
    {
        free( psz_fname );
        return VLC_ENOMEM;
    }

    const char *f_fname = strrchr( psz_fname, DIR_SEP_CHAR );
    if( !f_fname )
    {
        free( f_dir );
        free( psz_fname );
        return VLC_EGENER...",214.0,432.0,1.0,1.0,219.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
1161,63458,subtitles_Filter,1,subtitles_Filter,int subtitles_Filter (char*),input\subtitles.c,"int subtitles_Filter( const char *psz_dir_content )
{
    const char *tmp = strrchr( psz_dir_content, '.');

    if( !tmp )
        return 0;
    tmp++;

    for( int i = 0; sub_exts[i][0]; i++ )
        if( strcasecmp( sub_exts[i], tmp ) == 0 )
            return 1;
    return 0;
}",138.0,150.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1162,63472,vlc_audio_replay_gain_MergeFromMeta,1,vlc_audio_replay_gain_MergeFromMeta,"void vlc_audio_replay_gain_MergeFromMeta (audio_replay_gain_t*,vlc_meta_t*)",input\meta.c,"void vlc_audio_replay_gain_MergeFromMeta( audio_replay_gain_t *p_dst,
                                          const vlc_meta_t *p_meta )
{
    const char * psz_value;

    if( !p_meta )
        return;

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_GAIN"")) ||
        (psz_value = vlc_meta_GetExtra(p_meta, ""RG_RADIO"")) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_gain[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_TRACK_PEAK"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_PEAK"" )) )
    {
        p_dst->pb_peak[AUDIO_REPLAY_GAIN_TRACK] = true;
        p_dst->pf_peak[AUDIO_REPLAY_GAIN_TRACK] = us_atof( psz_value );
    }

    if( (psz_value = vlc_meta_GetExtra(p_meta, ""REPLAYGAIN_ALBUM_GAIN"" )) ||
             (psz_value = vlc_meta_GetExtra(p_meta, ""RG_AUDIOPHILE"" )) )
    {
        p_dst->pb_gain[AUDIO_REPLAY_GAIN_ALBUM] = true;
        p_dst->p...",290.0,324.0,1.0,1.0,35.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1163,63478,input_item_node_PostAndDelete,1,input_item_node_PostAndDelete,void input_item_node_PostAndDelete (input_item_node_t*),input\item.c,"void input_item_node_PostAndDelete( input_item_node_t *p_root )
{
    vlc_event_send( &p_root->p_item->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemSubItemTreeAdded,
        .u.input_item_subitem_tree_added.p_root = p_root } );

    input_item_node_Delete( p_root );
}",1302.0,1309.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1164,63525,GuessType,1,GuessType,"int GuessType (input_item_t*,bool*)",input\item.c,"static int GuessType( const input_item_t *p_item, bool *p_net )
{
    static const struct item_type_entry tab[] =
    {   /* /!\ Alphabetical order /!\ */
        /* Short match work, not just exact match */
        { ""alsa"",   ITEM_TYPE_CARD, false },
        { ""atsc"",   ITEM_TYPE_CARD, false },
        { ""bd"",     ITEM_TYPE_DISC, false },
        { ""bluray"", ITEM_TYPE_DISC, false },
        { ""cable"",  ITEM_TYPE_CARD, false },
        { ""cdda"",   ITEM_TYPE_DISC, false },
        { ""cqam"",   ITEM_TYPE_CARD, false },
        { ""dc1394"", ITEM_TYPE_CARD, false },
        { ""dccp"",   ITEM_TYPE_STREAM, true },
        { ""deckli"", ITEM_TYPE_CARD, false }, /* decklink */
        { ""dir"",    ITEM_TYPE_DIRECTORY, false },
        { ""dshow"",  ITEM_TYPE_CARD, false },
        { ""dtv"",    ITEM_TYPE_CARD, false },
        { ""dvb"",    ITEM_TYPE_CARD, false },
        { ""dvd"",    ITEM_TYPE_DISC, false },
        { ""eyetv"",  ITEM_TYPE_CARD, false },
        { ""fd"",     ITEM_TYPE_UNKNOWN, false },
...",1154.0,1239.0,1.0,1.0,86.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1165,63531,input_item_SetErrorWhenReading,1,input_item_SetErrorWhenReading,"void input_item_SetErrorWhenReading (input_item_t*,bool)",input\item.c,"void input_item_SetErrorWhenReading( input_item_t *p_i, bool b_error )
{
    bool b_changed;

    vlc_mutex_lock( &p_i->lock );

    b_changed = p_i->b_error_when_reading != b_error;
    p_i->b_error_when_reading = b_error;

    vlc_mutex_unlock( &p_i->lock );

    if( b_changed )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemErrorWhenReadingChanged,
            .u.input_item_error_when_reading_changed.new_value = b_error } );
    }
}",51.0,68.0,1.0,1.0,18.0,18,6,17,8,0,3,2,2,0,3,,0,0,4,2,2,void
1166,63811,input_item_SetMeta,1,input_item_SetMeta,"void input_item_SetMeta (input_item_t*,vlc_meta_type_t,char*)",input\item.c,"void input_item_SetMeta( input_item_t *p_i, vlc_meta_type_t meta_type, const char *psz_val )
{
    vlc_mutex_lock( &p_i->lock );
    if( !p_i->p_meta )
        p_i->p_meta = vlc_meta_New();
    vlc_meta_Set( p_i->p_meta, meta_type, psz_val );
    vlc_mutex_unlock( &p_i->lock );

    /* Notify interested third parties */
    vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
        .type = vlc_InputItemMetaChanged,
        .u.input_item_meta_changed.meta_type = meta_type } );
}",145.0,157.0,1.0,1.0,13.0,18,6,16,7,0,5,2,2,0,5,,0,1,6,3,3,void
1167,63868,input_item_CopyOptions,1,input_item_CopyOptions,"void input_item_CopyOptions (input_item_t*,input_item_t*)",input\item.c,"void input_item_CopyOptions( input_item_t *p_child,
                             input_item_t *p_parent )
{
    char **optv = NULL;
    uint8_t *flagv = NULL;
    int optc = 0;
    char **optv_realloc = NULL;
    uint8_t *flagv_realloc = NULL;

    vlc_mutex_lock( &p_parent->lock );

    if( p_parent->i_options > 0 )
    {
        optv = vlc_alloc( p_parent->i_options, sizeof (*optv) );
        if( likely(optv) )
            flagv = vlc_alloc( p_parent->i_options, sizeof (*flagv) );

        if( likely(flagv) )
        {
            for( int i = 0; i < p_parent->i_options; i++ )
            {
                char *psz_dup = strdup( p_parent->ppsz_options[i] );
                if( likely(psz_dup) )
                {
                    flagv[optc] = p_parent->optflagv[i];
                    optv[optc++] = psz_dup;
                }
            }
        }
    }

    vlc_mutex_unlock( &p_parent->lock );

    if( likely(optv && flagv && optc ) )
    {
        vlc_mutex_lock( &p_child-...",159.0,230.0,1.0,1.0,72.0,93,18,87,12,3,4,13,27,0,4,,0,0,4,2,2,void
1168,64146,input_item_HasErrorWhenReading,1,input_item_HasErrorWhenReading,bool input_item_HasErrorWhenReading (input_item_t*),input\item.c,"bool input_item_HasErrorWhenReading( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );

    bool b_error = p_item->b_error_when_reading;

    vlc_mutex_unlock( &p_item->lock );

    return b_error;
}",232.0,241.0,1.0,1.0,10.0,6,3,5,2,1,2,1,1,0,2,,0,0,2,1,1,bool
1169,64169,input_item_MetaMatch,1,input_item_MetaMatch,"bool input_item_MetaMatch (input_item_t*,vlc_meta_type_t,char*)",input\item.c,"bool input_item_MetaMatch( input_item_t *p_i,
                           vlc_meta_type_t meta_type, const char *psz )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return false;
    }
    const char *psz_meta = vlc_meta_Get( p_i->p_meta, meta_type );
    bool b_ret = psz_meta && strcasestr( psz_meta, psz );

    vlc_mutex_unlock( &p_i->lock );

    return b_ret;
}",243.0,259.0,1.0,1.0,17.0,12,5,13,6,0,4,2,2,0,4,,0,1,6,3,3,bool
1170,64217,input_item_GetMeta,1,input_item_GetMeta,"char* input_item_GetMeta (input_item_t*,vlc_meta_type_t)",input\item.c,"char *input_item_GetMeta( input_item_t *p_i, vlc_meta_type_t meta_type )
{
    vlc_mutex_lock( &p_i->lock );

    if( !p_i->p_meta )
    {
        vlc_mutex_unlock( &p_i->lock );
        return NULL;
    }

    char *psz = NULL;
    if( vlc_meta_Get( p_i->p_meta, meta_type ) )
        psz = strdup( vlc_meta_Get( p_i->p_meta, meta_type ) );

    vlc_mutex_unlock( &p_i->lock );
    return psz;
}",261.0,277.0,1.0,1.0,17.0,12,4,13,4,7,5,3,3,1,5,,0,2,4,2,2,char*
1171,64267,input_item_GetTitleFbName,1,input_item_GetTitleFbName,char* input_item_GetTitleFbName (input_item_t*),input\item.c,"char *input_item_GetTitleFbName( input_item_t *p_item )
{
    char *psz_ret;
    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
    {
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;
        vlc_mutex_unlock( &p_item->lock );
        return psz_ret;
    }

    const char *psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !EMPTY_STR( psz_title ) )
        psz_ret = strdup( psz_title );
    else
        psz_ret = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_ret;
}",280.0,300.0,1.0,1.0,21.0,16,5,16,5,4,4,3,3,0,4,,0,1,2,1,1,char*
1172,64339,input_item_GetName,1,input_item_GetName,char* input_item_GetName (input_item_t*),input\item.c,"char *input_item_GetName( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );

    char *psz_name = p_item->psz_name ? strdup( p_item->psz_name ) : NULL;

    vlc_mutex_unlock( &p_item->lock );
    return psz_name;
}",302.0,310.0,1.0,1.0,9.0,8,4,7,3,2,2,1,1,0,2,,0,0,2,1,1,char*
1173,64368,input_item_SetName,1,input_item_SetName,"void input_item_SetName (input_item_t*,char*)",input\item.c,"void input_item_SetName( input_item_t *p_item, const char *psz_name )
{
    vlc_mutex_lock( &p_item->lock );

    free( p_item->psz_name );
    p_item->psz_name = strdup( psz_name );

    vlc_mutex_unlock( &p_item->lock );
}",311.0,319.0,1.0,1.0,9.0,7,3,5,2,1,2,1,1,0,2,,0,0,4,2,2,void
1174,64394,input_item_GetURI,1,input_item_GetURI,char* input_item_GetURI (input_item_t*),input\item.c,"char *input_item_GetURI( input_item_t *p_i )
{
    vlc_mutex_lock( &p_i->lock );

    char *psz_s = p_i->psz_uri ? strdup( p_i->psz_uri ) : NULL;

    vlc_mutex_unlock( &p_i->lock );
    return psz_s;
}",321.0,329.0,1.0,1.0,9.0,8,4,7,3,4,2,1,1,0,2,,0,0,2,1,1,char*
1175,64423,input_item_SetURI,1,input_item_SetURI,"void input_item_SetURI (input_item_t*,char*)",input\item.c,"void input_item_SetURI( input_item_t *p_i, const char *psz_uri )
{
    assert( psz_uri );
#ifndef NDEBUG
    if( !strstr( psz_uri, ""://"" )
     || strchr( psz_uri, ' ' ) || strchr( psz_uri, '""' ) )
        fprintf( stderr, ""Warning: %s(\""%s\""): file path instead of URL.\n"",
                 __func__, psz_uri );
#endif
    vlc_mutex_lock( &p_i->lock );
    free( p_i->psz_uri );
    p_i->psz_uri = strdup( psz_uri );

    p_i->i_type = GuessType( p_i, &p_i->b_net );

    if( p_i->psz_name )
        ;
    else
    if( p_i->i_type == ITEM_TYPE_FILE || p_i->i_type == ITEM_TYPE_DIRECTORY )
    {
        const char *psz_filename = strrchr( p_i->psz_uri, '/' );

        if( psz_filename && *psz_filename == '/' )
            psz_filename++;
        if( psz_filename && *psz_filename )
            p_i->psz_name = strdup( psz_filename );

        /* Make the name more readable */
        if( p_i->psz_name )
        {
            vlc_uri_decode( p_i->psz_name );
            EnsureUTF8( p_i->psz_n...",331.0,397.0,1.0,1.0,67.0,15,5,16,4,2,3,3,3,0,3,,0,1,4,2,2,void
1176,64683,input_item_GetDuration,1,input_item_GetDuration,mtime_t input_item_GetDuration (input_item_t*),input\item.c,"mtime_t input_item_GetDuration( input_item_t *p_i )
{
    vlc_mutex_lock( &p_i->lock );

    mtime_t i_duration = p_i->i_duration;

    vlc_mutex_unlock( &p_i->lock );
    return i_duration;
}",399.0,407.0,1.0,1.0,9.0,6,3,5,2,5,2,1,1,0,2,,0,0,2,1,1,mtime_t
1177,64706,input_item_SetDuration,1,input_item_SetDuration,"void input_item_SetDuration (input_item_t*,mtime_t)",input\item.c,"void input_item_SetDuration( input_item_t *p_i, mtime_t i_duration )
{
    bool b_send_event = false;

    vlc_mutex_lock( &p_i->lock );
    if( p_i->i_duration != i_duration )
    {
        p_i->i_duration = i_duration;
        b_send_event = true;
    }
    vlc_mutex_unlock( &p_i->lock );

    if( b_send_event )
    {
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemDurationChanged,
            .u.input_item_duration_changed.new_duration = i_duration } );
    }
}",409.0,427.0,1.0,1.0,19.0,19,6,20,10,1,3,3,3,0,3,,0,0,4,2,2,void
1178,64767,input_item_GetNowPlayingFb,1,input_item_GetNowPlayingFb,char* input_item_GetNowPlayingFb (input_item_t*),input\item.c,"char *input_item_GetNowPlayingFb( input_item_t *p_item )
{
    char *psz_meta = input_item_GetMeta( p_item, vlc_meta_NowPlaying );
    if( !psz_meta || strlen( psz_meta ) == 0 )
    {
        free( psz_meta );
        return input_item_GetMeta( p_item, vlc_meta_ESNowPlaying );
    }

    return psz_meta;
}",429.0,439.0,1.0,1.0,11.0,4,4,9,4,3,2,2,2,0,2,,0,1,2,1,1,char*
1179,64795,input_item_IsPreparsed,1,input_item_IsPreparsed,bool input_item_IsPreparsed (input_item_t*),input\item.c,"bool input_item_IsPreparsed( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );
    bool b_preparsed = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_PREPARSED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_preparsed;
}",441.0,448.0,1.0,1.0,8.0,10,6,8,4,0,3,1,1,0,3,,0,1,2,1,1,bool
1180,64828,input_item_IsArtFetched,1,input_item_IsArtFetched,bool input_item_IsArtFetched (input_item_t*),input\item.c,"bool input_item_IsArtFetched( input_item_t *p_item )
{
    vlc_mutex_lock( &p_item->lock );
    bool b_fetched = p_item->p_meta ? ( vlc_meta_GetStatus(p_item->p_meta) & ITEM_ART_FETCHED ) != 0 : false;
    vlc_mutex_unlock( &p_item->lock );

    return b_fetched;
}",450.0,457.0,1.0,1.0,8.0,10,6,8,4,0,3,1,1,0,3,,0,1,2,1,1,bool
1181,64861,input_item_ShouldPreparseSubItems,1,input_item_ShouldPreparseSubItems,bool input_item_ShouldPreparseSubItems (input_item_t*),input\item.c,"bool input_item_ShouldPreparseSubItems( input_item_t *p_item )
{
    bool b_ret;

    vlc_mutex_lock( &p_item->lock );
    b_ret = p_item->i_preparse_depth == -1 ? true : p_item->i_preparse_depth > 0;
    vlc_mutex_unlock( &p_item->lock );

    return b_ret;
}",459.0,468.0,1.0,1.0,10.0,11,7,7,3,0,2,1,1,0,2,,0,0,2,1,1,bool
1182,64894,input_item_Hold,1,input_item_Hold,input_item_t input_item_Hold (input_item_t*),input\item.c,"input_item_t *input_item_Hold( input_item_t *p_item )
{
    input_item_owner_t *owner = item_owner(p_item);

    atomic_fetch_add( &owner->refs, 1 );
    return p_item;
}",470.0,476.0,1.0,32.0,7.0,4,4,5,2,4,0,1,1,0,0,,0,0,2,1,1,input_item_t
1183,64916,input_item_Release,1,input_item_Release,void input_item_Release (input_item_t*),input\item.c,"void input_item_Release( input_item_t *p_item )
{
    input_item_owner_t *owner = item_owner(p_item);

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    vlc_event_manager_fini( &p_item->event_manager );

    free( p_item->psz_name );
    free( p_item->psz_uri );
    if( p_item->p_stats != NULL )
    {
        vlc_mutex_destroy( &p_item->p_stats->lock );
        free( p_item->p_stats );
    }

    if( p_item->p_meta != NULL )
        vlc_meta_Delete( p_item->p_meta );

    for( input_item_opaque_t *o = p_item->opaques, *next; o != NULL; o = next )
    {
        next = o->next;
        free( o );
    }

    for( int i = 0; i < p_item->i_options; i++ )
        free( p_item->ppsz_options[i] );
    TAB_CLEAN( p_item->i_options, p_item->ppsz_options );
    free( p_item->optflagv );

    for( int i = 0; i < p_item->i_es; i++ )
    {
        es_format_Clean( p_item->es[i] );
        free( p_item->es[i] );
    }
    TAB_CLEAN( p_item->i_es, p_item->es );

    for( int i =...",478.0,530.0,1.0,32.0,53.0,55,7,53,6,13,5,10,10,0,5,,0,0,2,1,1,void
1184,65154,input_item_AddOption,1,input_item_AddOption,"int input_item_AddOption (input_item_t*,char*,unsigned)",input\item.c,"int input_item_AddOption( input_item_t *p_input, const char *psz_option,
                          unsigned flags )
{
    int err = VLC_SUCCESS;

    if( psz_option == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_input->lock );
    if (flags & VLC_INPUT_OPTION_UNIQUE)
    {
        for (int i = 0 ; i < p_input->i_options; i++)
            if( !strcmp( p_input->ppsz_options[i], psz_option ) )
                goto out;
    }

    uint8_t *flagv = realloc (p_input->optflagv, p_input->optflagc + 1);
    if (flagv == NULL)
    {
        err = VLC_ENOMEM;
        goto out;
    }

    p_input->optflagv = flagv;

    char* psz_option_dup = strdup( psz_option );
    if( unlikely( !psz_option_dup ) )
    {
        err = VLC_ENOMEM;
        goto out;
    }

    TAB_APPEND(p_input->i_options, p_input->ppsz_options, psz_option_dup);

    flagv[p_input->optflagc++] = flags;

out:
    vlc_mutex_unlock( &p_input->lock );
    return err;
}",532.0,571.0,1.0,1.0,40.0,27,10,33,12,1,2,8,7,0,2,,0,0,6,3,3,int
1185,65270,input_item_AddOptions,1,input_item_AddOptions,"int input_item_AddOptions (input_item_t*,int,char**,unsigned)",input\item.c,"int input_item_AddOptions( input_item_t *p_item, int i_options,
                           const char *const *ppsz_options,
                           unsigned i_flags )
{
    int i_ret = VLC_SUCCESS;
    for( int i = 0; i < i_options && i_ret == VLC_SUCCESS; i++ )
        i_ret = input_item_AddOption( p_item, ppsz_options[i], i_flags );
    return i_ret;
}",573.0,581.0,1.0,1.0,9.0,5,4,8,4,2,0,2,2,0,0,,0,0,8,4,4,int
1186,65307,input_item_AddOpaque,1,input_item_AddOpaque,"int input_item_AddOpaque (input_item_t*,char*,void*)",input\item.c,"int input_item_AddOpaque(input_item_t *item, const char *name, void *value)
{
    assert(name != NULL);

    size_t namelen = strlen(name);
    input_item_opaque_t *entry = malloc(sizeof (*entry) + namelen);
    if (unlikely(entry == NULL))
        return VLC_ENOMEM;

    memcpy(entry->name, name, namelen + 1);
    entry->value = value;

    vlc_mutex_lock(&item->lock);
    entry->next = item->opaques;
    item->opaques = entry;
    vlc_mutex_unlock(&item->lock);
    return VLC_SUCCESS;
}",583.0,600.0,1.0,1.0,18.0,20,8,22,8,0,2,2,2,0,2,,0,0,6,3,3,int
1187,65377,input_item_ApplyOptions,1,input_item_ApplyOptions,"void input_item_ApplyOptions (vlc_object_t*,input_item_t*)",input\item.c,"void input_item_ApplyOptions(vlc_object_t *obj, input_item_t *item)
{
    vlc_mutex_lock(&item->lock);
    assert(item->optflagc == (unsigned)item->i_options);

    for (unsigned i = 0; i < (unsigned)item->i_options; i++)
        var_OptionParse(obj, item->ppsz_options[i],
                        !!(item->optflagv[i] & VLC_INPUT_OPTION_TRUSTED));

    for (const input_item_opaque_t *o = item->opaques; o != NULL; o = o->next)
    {
        var_Create(obj, o->name, VLC_VAR_ADDRESS);
        var_SetAddress(obj, o->name, o->value);
    }

    vlc_mutex_unlock(&item->lock);
}",602.0,618.0,1.0,1.0,17.0,18,7,17,6,1,3,3,3,0,3,,0,0,4,2,2,void
1188,65480,input_item_IsMaster,1,input_item_IsMaster,bool input_item_IsMaster (char*),input\item.c,"static bool input_item_IsMaster(const char *psz_filename)
{
    static const char *const ppsz_master_exts[] = { MASTER_EXTENSIONS };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    return bsearch(psz_ext, ppsz_master_exts, ARRAY_SIZE(ppsz_master_exts),
                   sizeof(const char *), bsearch_strcmp_cb) != NULL;
}",626.0,636.0,1.0,1.0,11.0,10,8,13,7,1,0,2,2,0,0,,0,0,2,1,1,bool
1189,65520,input_item_slave_GetType,1,input_item_slave_GetType,"bool input_item_slave_GetType (char*,slave_type*)",input\item.c,"bool input_item_slave_GetType(const char *psz_filename,
                              enum slave_type *p_slave_type)
{
    static const char *const ppsz_sub_exts[] = { SLAVE_SPU_EXTENSIONS };
    static const char *const ppsz_audio_exts[] = { SLAVE_AUDIO_EXTENSIONS };

    static struct {
        enum slave_type i_type;
        const char *const *ppsz_exts;
        size_t nmemb;
    } p_slave_list[] = {
        { SLAVE_TYPE_SPU, ppsz_sub_exts, ARRAY_SIZE(ppsz_sub_exts) },
        { SLAVE_TYPE_AUDIO, ppsz_audio_exts, ARRAY_SIZE(ppsz_audio_exts) },
    };

    const char *psz_ext = strrchr(psz_filename, '.');
    if (psz_ext == NULL || *(++psz_ext) == '\0')
        return false;

    for (unsigned int i = 0; i < sizeof(p_slave_list) / sizeof(*p_slave_list); ++i)
    {
        if (bsearch(psz_ext, p_slave_list[i].ppsz_exts, p_slave_list[i].nmemb,
                    sizeof(const char *), bsearch_strcmp_cb))
        {
            *p_slave_type = p_slave_list[i].i_type;
            retur...",638.0,667.0,1.0,1.0,30.0,29,11,32,15,3,0,4,5,0,0,,0,0,4,2,2,bool
1190,65615,input_item_slave_New,1,input_item_slave_New,"input_item_slave_t input_item_slave_New (char*,slave_type,slave_priority)",input\item.c,"input_item_slave_t *input_item_slave_New(const char *psz_uri, enum slave_type i_type,
                                       enum slave_priority i_priority)
{
    if( !psz_uri )
        return NULL;

    input_item_slave_t *p_slave = malloc( sizeof( *p_slave ) + strlen( psz_uri ) + 1 );
    if( !p_slave )
        return NULL;

    p_slave->i_type = i_type;
    p_slave->i_priority = i_priority;
    p_slave->b_forced = false;
    strcpy( p_slave->psz_uri, psz_uri );

    return p_slave;
}",669.0,685.0,1.0,1.0,17.0,14,6,16,6,5,0,3,3,0,0,,0,0,6,3,3,input_item_slave_t
1191,65668,input_item_AddSlave,1,input_item_AddSlave,"int input_item_AddSlave (input_item_t*,input_item_slave_t*)",input\item.c,"int input_item_AddSlave(input_item_t *p_item, input_item_slave_t *p_slave)
{
    if( p_item == NULL || p_slave == NULL
     || p_slave->i_priority < SLAVE_PRIORITY_MATCH_NONE )
        return VLC_EGENERIC;

    vlc_mutex_lock( &p_item->lock );

    TAB_APPEND(p_item->i_slaves, p_item->pp_slaves, p_slave);

    vlc_mutex_unlock( &p_item->lock );
    return VLC_SUCCESS;
}",687.0,699.0,1.0,1.0,13.0,12,5,13,6,2,2,2,2,0,2,,0,0,4,2,2,int
1192,65711,InputItemFindCat,1,InputItemFindCat,"info_category_t InputItemFindCat (input_item_t*,int*,char*)",input\item.c,"static info_category_t *InputItemFindCat( input_item_t *p_item,
                                          int *pi_index, const char *psz_cat )
{
    vlc_assert_locked( &p_item->lock );
    for( int i = 0; i < p_item->i_categories && psz_cat; i++ )
    {
        info_category_t *p_cat = p_item->pp_categories[i];

        if( !strcmp( p_cat->psz_name, psz_cat ) )
        {
            if( pi_index )
                *pi_index = i;
            return p_cat;
        }
    }
    return NULL;
}",701.0,717.0,1.0,1.0,17.0,13,8,15,6,5,0,4,7,0,0,,0,0,6,3,3,info_category_t
1193,65766,input_item_GetInfo,1,input_item_GetInfo,"char* input_item_GetInfo (input_item_t*,char*,char*)",input\item.c,"char *input_item_GetInfo( input_item_t *p_i,
                          const char *psz_cat,
                          const char *psz_name )
{
    vlc_mutex_lock( &p_i->lock );

    const info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( p_cat )
    {
        info_t *p_info = info_category_FindInfo( p_cat, NULL, psz_name );
        if( p_info && p_info->psz_value )
        {
            char *psz_ret = strdup( p_info->psz_value );
            vlc_mutex_unlock( &p_i->lock );
            return psz_ret;
        }
    }
    vlc_mutex_unlock( &p_i->lock );
    return strdup( """" );
}",729.0,748.0,1.0,1.0,20.0,12,4,17,7,2,5,3,4,0,5,,0,2,6,3,3,char*
1194,65824,InputItemVaAddInfo,1,InputItemVaAddInfo,"int InputItemVaAddInfo (input_item_t*,char*,char*,char*,va_list)",input\item.c,"static int InputItemVaAddInfo( input_item_t *p_i,
                               const char *psz_cat,
                               const char *psz_name,
                               const char *psz_format, va_list args )
{
    vlc_assert_locked( &p_i->lock );

    info_category_t *p_cat = InputItemFindCat( p_i, NULL, psz_cat );
    if( !p_cat )
    {
        p_cat = info_category_New( psz_cat );
        if( !p_cat )
            return VLC_ENOMEM;
        TAB_APPEND(p_i->i_categories, p_i->pp_categories, p_cat);
    }
    info_t *p_info = info_category_VaAddInfo( p_cat, psz_name, psz_format, args );
    if( !p_info || !p_info->psz_value )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",750.0,769.0,1.0,1.0,20.0,13,5,22,11,1,3,4,5,0,3,,0,3,10,5,5,int
1195,65888,input_item_AddInfo,1,input_item_AddInfo,"int input_item_AddInfo (input_item_t*,char*,char*,char*...)",input\item.c,"int input_item_AddInfo( input_item_t *p_i,
                        const char *psz_cat,
                        const char *psz_name,
                        const char *psz_format, ... )
{
    va_list args;

    vlc_mutex_lock( &p_i->lock );

    va_start( args, psz_format );
    const int i_ret = InputItemVaAddInfo( p_i, psz_cat, psz_name, psz_format, args );
    va_end( args );

    vlc_mutex_unlock( &p_i->lock );


    if( !i_ret )
        vlc_event_send( &p_i->event_manager, &(vlc_event_t) {
            .type = vlc_InputItemInfoChanged } );

    return i_ret;
}",771.0,792.0,1.0,1.0,22.0,12,6,16,8,1,4,2,2,0,4,,0,1,8,4,4,int
1196,65940,input_item_DelInfo,1,input_item_DelInfo,"int input_item_DelInfo (input_item_t*,char*,char*)",input\item.c,"int input_item_DelInfo( input_item_t *p_i,
                        const char *psz_cat,
                        const char *psz_name )
{
    vlc_mutex_lock( &p_i->lock );
    int i_cat;
    info_category_t *p_cat = InputItemFindCat( p_i, &i_cat, psz_cat );
    if( !p_cat )
    {
        vlc_mutex_unlock( &p_i->lock );
        return VLC_EGENERIC;
    }

    if( psz_name )
    {
        /* Remove a specific info */
        int i_ret = info_category_DeleteInfo( p_cat, psz_name );
        if( i_ret )
        {
            vlc_mutex_unlock( &p_i->lock );
            return VLC_EGENERIC;
        }
    }
    else
    {
        /* Remove the complete categorie */
        info_category_Delete( p_cat );
        TAB_ERASE(p_i->i_categories, p_i->pp_categories, i_cat);
    }
    vlc_mutex_unlock( &p_i->lock );

    vlc_event_send( &p_i->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );

    return VLC_SUCCESS;
}",794.0,829.0,1.0,1.0,36.0,18,6,20,10,1,7,4,5,0,7,,0,2,6,3,3,int
1197,66023,input_item_ReplaceInfos,1,input_item_ReplaceInfos,"void input_item_ReplaceInfos (input_item_t*,info_category_t*)",input\item.c,"void input_item_ReplaceInfos( input_item_t *p_item, info_category_t *p_cat )
{
    vlc_mutex_lock( &p_item->lock );
    int i_cat;
    info_category_t *p_old = InputItemFindCat( p_item, &i_cat, p_cat->psz_name );
    if( p_old )
    {
        info_category_Delete( p_old );
        p_item->pp_categories[i_cat] = p_cat;
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",830.0,846.0,1.0,1.0,17.0,16,6,14,6,1,5,2,2,0,5,,0,1,4,2,2,void
1198,66085,input_item_MergeInfos,1,input_item_MergeInfos,"void input_item_MergeInfos (input_item_t*,info_category_t*)",input\item.c,"void input_item_MergeInfos( input_item_t *p_item, info_category_t *p_cat )
{
    vlc_mutex_lock( &p_item->lock );
    info_category_t *p_old = InputItemFindCat( p_item, NULL, p_cat->psz_name );
    if( p_old )
    {
        for( int i = 0; i < p_cat->i_infos; i++ )
            info_category_ReplaceInfo( p_old, p_cat->pp_infos[i] );
        TAB_CLEAN( p_cat->i_infos, p_cat->pp_infos );
        info_category_Delete( p_cat );
    }
    else
        TAB_APPEND(p_item->i_categories, p_item->pp_categories, p_cat);
    vlc_mutex_unlock( &p_item->lock );

    vlc_event_send( &p_item->event_manager,
                    &(vlc_event_t) { .type = vlc_InputItemInfoChanged } );
}",848.0,865.0,1.0,1.0,18.0,17,6,16,7,0,5,3,4,0,5,,0,1,4,2,2,void
1199,66540,input_item_NewExt,1,input_item_NewExt,"input_item_t input_item_NewExt (char*,char*,mtime_t,int,input_item_net_type)",input\item.c,"input_item_t *
input_item_NewExt( const char *psz_uri, const char *psz_name,
                   mtime_t duration, int type, enum input_item_net_type i_net )
{
    input_item_owner_t *owner = calloc( 1, sizeof( *owner ) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    input_item_t *p_input = &owner->item;
    vlc_event_manager_t * p_em = &p_input->event_manager;

    vlc_mutex_init( &p_input->lock );

    p_input->psz_name = NULL;
    if( psz_name )
        input_item_SetName( p_input, psz_name );

    p_input->psz_uri = NULL;
    if( psz_uri )
        input_item_SetURI( p_input, psz_uri );
    else
    {
        p_input->i_type = ITEM_TYPE_UNKNOWN;
        p_input->b_net = false;
    }

    TAB_INIT( p_input->i_options, p_input->ppsz_options );
    p_input->optflagc = 0;
    p_input->optflagv = NULL;
    p_input->opaques = NULL;

    p_input->i_duration = duration;
    TAB_INIT( p_input->i_categories, p_input->pp_categories );
    T...",1057.0,1107.0,1.0,1.0,51.0,49,7,56,13,4,4,6,6,0,4,,0,0,10,5,5,input_item_t
1200,66721,input_item_Copy,1,input_item_Copy,input_item_t input_item_Copy (input_item_t*),input\item.c,"input_item_t *input_item_Copy( input_item_t *p_input )
{
    vlc_meta_t *meta = NULL;
    input_item_t *item;
    bool b_net;

    vlc_mutex_lock( &p_input->lock );

    item = input_item_NewExt( p_input->psz_uri, p_input->psz_name,
                              p_input->i_duration, p_input->i_type,
                              ITEM_NET_UNKNOWN );
    if( likely(item != NULL) && p_input->p_meta != NULL )
    {
        meta = vlc_meta_New();
        vlc_meta_Merge( meta, p_input->p_meta );
    }
    b_net = p_input->b_net;
    vlc_mutex_unlock( &p_input->lock );

    if( likely(item != NULL) )
    {   /* No need to lock; no other thread has seen this new item yet. */
        input_item_CopyOptions( item, p_input );
        item->p_meta = meta;
        item->b_net = b_net;
    }

    return item;
}",1109.0,1136.0,1.0,1.0,28.0,23,5,28,6,0,6,3,3,0,6,,0,2,2,1,1,input_item_t
1201,66808,typecmp,1,typecmp,"int typecmp (void*,void*)",input\item.c,"static int typecmp( const void *key, const void *entry )
{
    const struct item_type_entry *type = entry;
    const char *uri = key, *scheme = type->psz_scheme;

    return strncmp( uri, scheme, strlen( scheme ) );
}",1145.0,1151.0,1.0,1.0,7.0,4,2,9,5,0,1,1,1,0,0,,0,1,4,2,2,int
1202,67157,input_item_node_Create,1,input_item_node_Create,input_item_node_t input_item_node_Create (input_item_t*),input\item.c,"input_item_node_t *input_item_node_Create( input_item_t *p_input )
{
    input_item_node_t* p_node = malloc( sizeof( input_item_node_t ) );
    if( !p_node )
        return NULL;

    assert( p_input );

    p_node->p_item = p_input;
    input_item_Hold( p_input );

    p_node->i_children = 0;
    p_node->pp_children = NULL;

    return p_node;
}",1241.0,1256.0,1.0,1.0,16.0,9,4,12,4,1,1,2,2,0,1,,0,0,2,1,1,input_item_node_t
1203,67195,input_item_node_Delete,1,input_item_node_Delete,void input_item_node_Delete (input_item_node_t*),input\item.c,"void input_item_node_Delete( input_item_node_t *p_node )
{
    for( int i = 0; i < p_node->i_children; i++ )
        input_item_node_Delete( p_node->pp_children[i] );

    input_item_Release( p_node->p_item );
    free( p_node->pp_children );
    free( p_node );
}",1258.0,1266.0,1.0,1.0,9.0,5,3,6,2,1,1,2,2,0,1,,0,0,2,1,1,void
1204,67229,input_item_node_AppendItem,1,input_item_node_AppendItem,"input_item_node_t input_item_node_AppendItem (input_item_node_t*,input_item_t*)",input\item.c,"input_item_node_t *input_item_node_AppendItem( input_item_node_t *p_node, input_item_t *p_item )
{
    int i_preparse_depth;
    input_item_node_t *p_new_child = input_item_node_Create( p_item );
    if( !p_new_child ) return NULL;

    vlc_mutex_lock( &p_node->p_item->lock );
    i_preparse_depth = p_node->p_item->i_preparse_depth;
    vlc_mutex_unlock( &p_node->p_item->lock );

    vlc_mutex_lock( &p_item->lock );
    p_item->i_preparse_depth = i_preparse_depth > 0 ?
                               i_preparse_depth -1 :
                               i_preparse_depth;
    vlc_mutex_unlock( &p_item->lock );

    input_item_node_AppendNode( p_node, p_new_child );
    return p_new_child;
}",1268.0,1286.0,1.0,1.0,19.0,20,7,17,5,2,6,2,2,0,6,,0,1,4,2,2,input_item_node_t
1205,67295,input_item_node_AppendNode,1,input_item_node_AppendNode,"void input_item_node_AppendNode (input_item_node_t*,input_item_node_t*)",input\item.c,"void input_item_node_AppendNode( input_item_node_t *p_parent,
                                 input_item_node_t *p_child )
{
    assert(p_parent != NULL);
    assert(p_child != NULL);
    TAB_APPEND(p_parent->i_children, p_parent->pp_children, p_child);
}",1288.0,1294.0,1.0,1.0,7.0,4,2,7,3,1,0,1,1,0,0,,0,0,4,2,2,void
1206,67317,input_item_node_RemoveNode,1,input_item_node_RemoveNode,"void input_item_node_RemoveNode (input_item_node_t*,input_item_node_t*)",input\item.c,"void input_item_node_RemoveNode( input_item_node_t *parent,
                                 input_item_node_t *child )
{
    TAB_REMOVE(parent->i_children, parent->pp_children, child);
}",1296.0,1300.0,1.0,1.0,5.0,2,1,3,2,1,0,1,1,0,0,,0,0,4,2,2,void
1207,67363,input_item_UpdateTracksInfo,1,input_item_UpdateTracksInfo,"void input_item_UpdateTracksInfo (input_item_t*,es_format_t*)",input\item.c,"void input_item_UpdateTracksInfo(input_item_t *item, const es_format_t *fmt)
{
    int i;
    es_format_t *fmt_copy = malloc(sizeof *fmt_copy);
    if (!fmt_copy)
        return;

    es_format_Copy(fmt_copy, fmt);

    vlc_mutex_lock( &item->lock );

    for( i = 0; i < item->i_es; i++ )
    {
        if (item->es[i]->i_id != fmt->i_id)
            continue;

        /* We've found the right ES, replace it */
        es_format_Clean(item->es[i]);
        free(item->es[i]);
        item->es[i] = fmt_copy;
        vlc_mutex_unlock( &item->lock );
        return;
    }

    /* ES not found, insert it */
    TAB_APPEND(item->i_es, item->es, fmt_copy);
    vlc_mutex_unlock( &item->lock );
}",1312.0,1339.0,1.0,1.0,28.0,27,9,24,4,0,5,5,5,0,5,,0,0,4,2,2,void
1208,67455,rdh_compar_type,1,rdh_compar_type,"int rdh_compar_type (input_item_t*,input_item_t*)",input\item.c,"static int rdh_compar_type(input_item_t *p1, input_item_t *p2)
{
    if (p1->i_type != p2->i_type)
    {
        if (p1->i_type == ITEM_TYPE_DIRECTORY)
            return -1;
        if (p2->i_type == ITEM_TYPE_DIRECTORY)
            return 1;
    }
    return 0;
}",1341.0,1351.0,1.0,1.0,11.0,8,4,6,3,1,0,4,6,0,0,,0,0,4,2,2,int
1209,67491,rdh_compar_filename,1,rdh_compar_filename,"int rdh_compar_filename (void*,void*)",input\item.c,"static int rdh_compar_filename(const void *a, const void *b)
{
    input_item_node_t *const *na = a, *const *nb = b;
    input_item_t *ia = (*na)->p_item, *ib = (*nb)->p_item;

    int i_ret = rdh_compar_type(ia, ib);
    if (i_ret != 0)
        return i_ret;

    return vlc_filenamecmp(ia->psz_name, ib->psz_name);
}",1353.0,1363.0,1.0,1.0,11.0,12,4,15,7,0,2,2,2,0,2,,0,1,4,2,2,int
1210,67540,rdh_sort,1,rdh_sort,void rdh_sort (input_item_node_t*),input\item.c,"static void rdh_sort(input_item_node_t *p_node)
{
    if (p_node->i_children <= 0)
        return;

    /* Sort current node */
    qsort(p_node->pp_children, p_node->i_children,
          sizeof(input_item_node_t *), rdh_compar_filename);

    /* Sort all children */
    for (int i = 0; i < p_node->i_children; i++)
        rdh_sort(p_node->pp_children[i]);
}",1365.0,1377.0,1.0,1.0,13.0,8,5,7,3,1,0,3,3,0,0,,0,0,2,1,1,void
1211,67582,rdh_file_has_ext,1,rdh_file_has_ext,"bool rdh_file_has_ext (char*,char*)",input\item.c,"static bool rdh_file_has_ext(const char *psz_filename,
                             const char *psz_ignored_exts)
{
    if (psz_ignored_exts == NULL)
        return false;

    const char *ext = strrchr(psz_filename, '.');
    if (ext == NULL)
        return false;

    size_t extlen = strlen(++ext);

    for (const char *type = psz_ignored_exts, *end; type[0]; type = end + 1)
    {
        end = strchr(type, ',');
        if (end == NULL)
            end = type + strlen(type);

        if (type + extlen == end && !strncasecmp(ext, type, extlen))
            return true;

        if (*end == '\0')
            break;
    }

    return false;
}",1382.0,1408.0,1.0,1.0,27.0,17,8,29,9,1,0,8,10,0,0,,0,0,4,2,2,bool
1212,67670,rdh_file_is_ignored,1,rdh_file_is_ignored,"bool rdh_file_is_ignored (vlc_readdir_helper*,char*)",input\item.c,"static bool rdh_file_is_ignored(struct vlc_readdir_helper *p_rdh,
                                const char *psz_filename)
{
    return (psz_filename[0] == '\0'
         || strcmp(psz_filename, ""."") == 0
         || strcmp(psz_filename, "".."") == 0
         || (!p_rdh->b_show_hiddenfiles && psz_filename[0] == '.')
         || rdh_file_has_ext(psz_filename, p_rdh->psz_ignored_exts));
}",1410.0,1418.0,1.0,1.0,9.0,14,6,7,2,1,1,1,1,0,1,,0,0,4,2,2,bool
1213,67723,rdh_name_from_filename,1,rdh_name_from_filename,char* rdh_name_from_filename (char*),input\item.c,"static char *rdh_name_from_filename(const char *psz_filename)
{
    /* remove leading white spaces */
    while (*psz_filename != '\0' && *psz_filename == ' ')
        psz_filename++;

    char *psz_name = strdup(psz_filename);
    if (!psz_name)
        return NULL;

    /* remove extension */
    char *psz_ptr = strrchr(psz_name, '.');
    if (psz_ptr && psz_ptr != psz_name)
        *psz_ptr = '\0';

    /* remove trailing white spaces */
    int i = strlen(psz_name) - 1;
    while (psz_name[i] == ' ' && i >= 0)
        psz_name[i--] = '\0';

    /* convert to lower case */
    psz_ptr = psz_name;
    while (*psz_ptr != '\0')
    {
        *psz_ptr = tolower(*psz_ptr);
        psz_ptr++;
    }

    return psz_name;
}",1433.0,1462.0,1.0,1.0,30.0,25,10,24,5,2,0,6,6,0,0,,0,0,2,1,1,char*
1214,67810,rdh_get_slave_priority,1,rdh_get_slave_priority,"uint8_t rdh_get_slave_priority (input_item_t*,input_item_slave_t*,char*)",input\item.c,"static uint8_t rdh_get_slave_priority(input_item_t *p_item,
                                      input_item_slave_t *p_slave,
                                      const char *psz_slave_filename)
{
    uint8_t i_priority = SLAVE_PRIORITY_MATCH_NONE;
    char *psz_item_name = rdh_name_from_filename(p_item->psz_name);
    char *psz_slave_name = rdh_name_from_filename(psz_slave_filename);

    if (!psz_item_name || !psz_slave_name)
        goto done;

    size_t i_item_len = strlen(psz_item_name);
    size_t i_slave_len = strlen(psz_slave_name);

    /* The slave name len should not be twice longer than the item name len. */
    if (i_item_len > i_slave_len || i_slave_len > 2 * i_item_len)
        goto done;

    /* check if the names match exactly */
    if (!strcmp(psz_item_name, psz_slave_name))
    {
        i_priority = SLAVE_PRIORITY_MATCH_ALL;
        goto done;
    }

    /* ""cdg"" slaves have to be a full match */
    if (p_slave->i_type == SLAVE_TYPE_SPU)
    {
        char *...",1464.0,1519.0,1.0,1.0,56.0,26,11,38,15,1,2,13,10,0,2,,0,2,6,3,3,uint8_t
1215,67934,rdh_should_match_idx,1,rdh_should_match_idx,"int rdh_should_match_idx (vlc_readdir_helper*,rdh_slave*)",input\item.c,"static int rdh_should_match_idx(struct vlc_readdir_helper *p_rdh,
                                struct rdh_slave *p_rdh_sub)
{
    char *psz_ext = strrchr(p_rdh_sub->psz_filename, '.');
    if (!psz_ext)
        return false;
    psz_ext++;

    if (strcasecmp(psz_ext, ""sub"") != 0)
        return false;

    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];

        if (p_rdh_slave == NULL || p_rdh_slave == p_rdh_sub)
            continue;

        /* check that priorities match */
        if (p_rdh_slave->p_slave->i_priority !=
            p_rdh_sub->p_slave->i_priority)
            continue;

        /* check that the filenames without extension match */
        if (strncasecmp(p_rdh_sub->psz_filename, p_rdh_slave->psz_filename,
                        strlen(p_rdh_sub->psz_filename) - 3 ) != 0)
            continue;

        /* check that we have an idx file */
        char *psz_ext_idx = strrchr(p_rdh_slave->psz_fil...",1521.0,1558.0,1.0,1.0,38.0,29,10,30,9,1,7,13,14,5,0,,0,7,4,2,2,int
1216,68056,rdh_attach_slaves,1,rdh_attach_slaves,"void rdh_attach_slaves (vlc_readdir_helper*,input_item_node_t*)",input\item.c,"static void rdh_attach_slaves(struct vlc_readdir_helper *p_rdh,
                              input_item_node_t *p_parent_node)
{
    if (p_rdh->i_sub_autodetect_fuzzy == 0)
        return;

    /* Try to match slaves for each items of the node */
    for (int i = 0; i < p_parent_node->i_children; i++)
    {
        input_item_node_t *p_node = p_parent_node->pp_children[i];
        input_item_t *p_item = p_node->p_item;

        enum slave_type unused;
        if (!input_item_IsMaster(p_item->psz_name)
         || input_item_slave_GetType(p_item->psz_name, &unused))
            continue; /* don't match 2 possible slaves between each others */

        for (size_t j = 0; j < p_rdh->i_slaves; j++)
        {
            struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[j];

            /* Don't try to match slaves with themselves or slaves already
             * attached with the higher priority */
            if (p_rdh_slave->p_node == p_node
             || p_rdh_slave->p_slave->i_pri...",1560.0,1628.0,1.0,1.0,69.0,55,10,54,14,1,20,18,26,8,8,,0,18,4,2,2,void
1217,68264,rdh_unflatten,1,rdh_unflatten,"int rdh_unflatten (vlc_readdir_helper*,input_item_node_t**,char*,int)",input\item.c,"static int rdh_unflatten(struct vlc_readdir_helper *p_rdh,
                         input_item_node_t **pp_node, const char *psz_path,
                         int i_net)
{
    /* Create an input input for each sub folders that is contained in the full
     * path. Update pp_node to point to the direct parent of the future item to
     * add. */

    assert(psz_path != NULL);
    const char *psz_subpaths = psz_path;

    while ((psz_subpaths = strchr(psz_subpaths, '/')))
    {
        input_item_node_t *p_subnode = NULL;

        /* Check if this sub folder item was already added */
        for (size_t i = 0; i < p_rdh->i_dirs && p_subnode == NULL; i++)
        {
            struct rdh_dir *rdh_dir = p_rdh->pp_dirs[i];
            if (!strncmp(rdh_dir->psz_path, psz_path, psz_subpaths - psz_path))
                p_subnode = rdh_dir->p_node;
        }

        /* The sub folder item doesn't exist, so create it */
        if (p_subnode == NULL)
        {
            size_t i_sub_path...",1630.0,1694.0,1.0,1.0,65.0,49,15,68,17,1,10,9,21,1,4,,0,8,8,4,4,int
1218,68464,vlc_readdir_helper_init,1,vlc_readdir_helper_init,"void vlc_readdir_helper_init (vlc_readdir_helper*,vlc_object_t*,input_item_node_t*)",input\item.c,"void vlc_readdir_helper_init(struct vlc_readdir_helper *p_rdh,
                             vlc_object_t *p_obj, input_item_node_t *p_node)
{
    /* Read options from the parent item. This allows vlc_stream_ReadDir()
     * users to specify options whitout touhing any vlc_object_t. Apply options
     * on a temporary object in order to not apply options (that can be
     * insecure) to the current object. */
    vlc_object_t *p_var_obj = vlc_object_create(p_obj, sizeof(vlc_object_t));
    if (p_var_obj != NULL)
    {
        input_item_ApplyOptions(p_var_obj, p_node->p_item);
        p_obj = p_var_obj;
    }

    p_rdh->p_node = p_node;
    p_rdh->b_show_hiddenfiles = var_InheritBool(p_obj, ""show-hiddenfiles"");
    p_rdh->psz_ignored_exts = var_InheritString(p_obj, ""ignore-filetypes"");
    bool b_autodetect = var_InheritBool(p_obj, ""sub-autodetect-file"");
    p_rdh->i_sub_autodetect_fuzzy = !b_autodetect ? 0 :
        var_InheritInteger(p_obj, ""sub-autodetect-fuzzy"");
    p_rdh->b_f...",1697.0,1723.0,1.0,1.0,27.0,23,6,29,7,0,3,3,3,0,3,,0,1,6,3,3,void
1219,68555,vlc_readdir_helper_finish,1,vlc_readdir_helper_finish,"void vlc_readdir_helper_finish (vlc_readdir_helper*,bool)",input\item.c,"void vlc_readdir_helper_finish(struct vlc_readdir_helper *p_rdh, bool b_success)
{
    if (b_success)
    {
        rdh_sort(p_rdh->p_node);
        rdh_attach_slaves(p_rdh, p_rdh->p_node);
    }
    free(p_rdh->psz_ignored_exts);

    /* Remove unmatched slaves */
    for (size_t i = 0; i < p_rdh->i_slaves; i++)
    {
        struct rdh_slave *p_rdh_slave = p_rdh->pp_slaves[i];
        if (p_rdh_slave != NULL)
        {
            input_item_slave_Delete(p_rdh_slave->p_slave);
            free(p_rdh_slave->psz_filename);
            free(p_rdh_slave);
        }
    }
    TAB_CLEAN(p_rdh->i_slaves, p_rdh->pp_slaves);

    for (size_t i = 0; i < p_rdh->i_dirs; i++)
        free(p_rdh->pp_dirs[i]);
    TAB_CLEAN(p_rdh->i_dirs, p_rdh->pp_dirs);
}",1725.0,1750.0,1.0,1.0,26.0,19,5,23,5,0,4,5,6,0,2,,0,2,4,2,2,void
1220,68647,vlc_readdir_helper_additem,1,vlc_readdir_helper_additem,"int vlc_readdir_helper_additem (vlc_readdir_helper*,char*,char*,char*,int,int)",input\item.c,"int vlc_readdir_helper_additem(struct vlc_readdir_helper *p_rdh,
                               const char *psz_uri, const char *psz_flatpath,
                               const char *psz_filename, int i_type, int i_net)
{
    enum slave_type i_slave_type;
    struct rdh_slave *p_rdh_slave = NULL;
    assert(psz_flatpath || psz_filename);

    if (!p_rdh->b_flatten)
    {
        if (psz_filename == NULL)
        {
            psz_filename = strrchr(psz_flatpath, '/');
            if (psz_filename != NULL)
                ++psz_filename;
            else
                psz_filename = psz_flatpath;
        }
    }
    else
    {
        if (psz_filename == NULL)
            psz_filename = psz_flatpath;
        psz_flatpath = NULL;
    }

    if (p_rdh->i_sub_autodetect_fuzzy != 0
     && input_item_slave_GetType(psz_filename, &i_slave_type))
    {
        p_rdh_slave = malloc(sizeof(*p_rdh_slave));
        if (!p_rdh_slave)
            return VLC_ENOMEM;

        p_rdh_slave->p_no...",1752.0,1828.0,1.0,1.0,77.0,45,12,72,15,0,15,13,19,4,8,,0,13,12,6,6,int
1221,68924,vlc_meta_TypeToLocalizedString,1,vlc_meta_TypeToLocalizedString,const char* vlc_meta_TypeToLocalizedString (vlc_meta_type_t),input\meta.c,"const char * vlc_meta_TypeToLocalizedString( vlc_meta_type_t meta_type )
{
    static const char posix_names[][18] =
    {
        [vlc_meta_Title]       = N_(""Title""),
        [vlc_meta_Artist]      = N_(""Artist""),
        [vlc_meta_Genre]       = N_(""Genre""),
        [vlc_meta_Copyright]   = N_(""Copyright""),
        [vlc_meta_Album]       = N_(""Album""),
        [vlc_meta_TrackNumber] = N_(""Track number""),
        [vlc_meta_Description] = N_(""Description""),
        [vlc_meta_Rating]      = N_(""Rating""),
        [vlc_meta_Date]        = N_(""Date""),
        [vlc_meta_Setting]     = N_(""Setting""),
        [vlc_meta_URL]         = N_(""URL""),
        [vlc_meta_Language]    = N_(""Language""),
        [vlc_meta_ESNowPlaying]= N_(""Now Playing""),
        [vlc_meta_NowPlaying]  = N_(""Now Playing""),
        [vlc_meta_Publisher]   = N_(""Publisher""),
        [vlc_meta_EncodedBy]   = N_(""Encoded by""),
        [vlc_meta_ArtworkURL]  = N_(""Artwork URL""),
        [vlc_meta_TrackID]     = N_(""Track I...",51.0,85.0,1.0,1.0,35.0,34,6,32,28,2,1,1,1,0,1,,0,0,2,1,1,const char*
1222,69078,vlc_meta_New,1,vlc_meta_New,vlc_meta_t vlc_meta_New (void),input\meta.c,"vlc_meta_t *vlc_meta_New( void )
{
    vlc_meta_t *m = (vlc_meta_t*)malloc( sizeof(*m) );
    if( !m )
        return NULL;
    memset( m->ppsz_meta, 0, sizeof(m->ppsz_meta) );
    m->i_status = 0;
    vlc_dictionary_init( &m->extra_tags, 0 );
    return m;
}",92.0,101.0,1.0,1.0,10.0,12,7,9,2,6,4,2,2,0,0,,0,4,2,1,1,vlc_meta_t
1223,69130,vlc_meta_Delete,1,vlc_meta_Delete,void vlc_meta_Delete (vlc_meta_t*),input\meta.c,"void vlc_meta_Delete( vlc_meta_t *m )
{
    for( int i = 0; i < VLC_META_TYPE_COUNT ; i++ )
        free( m->ppsz_meta[i] );
    vlc_dictionary_clear( &m->extra_tags, vlc_meta_FreeExtraKey, NULL );
    free( m );
}",110.0,116.0,1.0,1.0,7.0,4,4,6,4,7,1,2,2,0,0,,0,1,2,1,1,void
1224,69161,vlc_meta_Set,1,vlc_meta_Set,"void vlc_meta_Set (vlc_meta_t*,vlc_meta_type_t,char*)",input\meta.c,"void vlc_meta_Set( vlc_meta_t *p_meta, vlc_meta_type_t meta_type, const char *psz_val )
{
    free( p_meta->ppsz_meta[meta_type] );
    assert( psz_val == NULL || IsUTF8( psz_val ) );
    p_meta->ppsz_meta[meta_type] = psz_val ? strdup( psz_val ) : NULL;
}",124.0,129.0,1.0,1.0,6.0,8,6,10,4,2,2,1,1,0,0,,0,2,6,3,3,void
1225,69192,vlc_meta_Get,1,vlc_meta_Get,"const char* vlc_meta_Get (vlc_meta_t*,vlc_meta_type_t)",input\meta.c,"const char *vlc_meta_Get( const vlc_meta_t *p_meta, vlc_meta_type_t meta_type )
{
    return p_meta->ppsz_meta[meta_type];
}",131.0,134.0,1.0,1.0,4.0,2,2,2,2,30,1,1,1,0,0,,0,1,4,2,2,const char*
1226,69204,vlc_meta_AddExtra,1,vlc_meta_AddExtra,"void vlc_meta_AddExtra (vlc_meta_t*,char*,char*)",input\meta.c,"void vlc_meta_AddExtra( vlc_meta_t *m, const char *psz_name, const char *psz_value )
{
    char *psz_oldvalue = (char *)vlc_dictionary_value_for_key( &m->extra_tags, psz_name );
    if( psz_oldvalue != kVLCDictionaryNotFound )
        vlc_dictionary_remove_value_for_key( &m->extra_tags, psz_name,
                                            vlc_meta_FreeExtraKey, NULL );
    vlc_dictionary_insert( &m->extra_tags, psz_name, strdup(psz_value) );
}",136.0,143.0,1.0,1.0,8.0,9,5,11,6,0,3,2,2,0,0,,0,3,6,3,3,void
1227,69243,vlc_meta_GetExtra,1,vlc_meta_GetExtra,"const char* vlc_meta_GetExtra (vlc_meta_t*,char*)",input\meta.c,"const char * vlc_meta_GetExtra( const vlc_meta_t *m, const char *psz_name )
{
    return (char *)vlc_dictionary_value_for_key(&m->extra_tags, psz_name);
}",145.0,148.0,1.0,1.0,4.0,3,3,2,2,1,1,1,1,0,0,,0,1,4,2,2,const char*
1228,69258,vlc_meta_GetExtraCount,1,vlc_meta_GetExtraCount,unsigned vlc_meta_GetExtraCount (vlc_meta_t*),input\meta.c,"unsigned vlc_meta_GetExtraCount( const vlc_meta_t *m )
{
    return vlc_dictionary_keys_count(&m->extra_tags);
}",150.0,153.0,1.0,1.0,4.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned
1229,69269,vlc_meta_CopyExtraNames,1,vlc_meta_CopyExtraNames,char** vlc_meta_CopyExtraNames (vlc_meta_t*),input\meta.c,"char** vlc_meta_CopyExtraNames( const vlc_meta_t *m )
{
    return vlc_dictionary_all_keys(&m->extra_tags);
}",155.0,158.0,1.0,1.0,4.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,char**
1230,69280,vlc_meta_GetStatus,1,vlc_meta_GetStatus,int vlc_meta_GetStatus (vlc_meta_t*),input\meta.c,"int vlc_meta_GetStatus( vlc_meta_t *m )
{
    return m->i_status;
}",163.0,166.0,1.0,1.0,4.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,int
1231,69289,vlc_meta_SetStatus,1,vlc_meta_SetStatus,"void vlc_meta_SetStatus (vlc_meta_t*,int)",input\meta.c,"void vlc_meta_SetStatus( vlc_meta_t *m, int status )
{
    m->i_status = status;
}",168.0,171.0,1.0,1.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
1232,69300,vlc_meta_Merge,1,vlc_meta_Merge,"void vlc_meta_Merge (vlc_meta_t*,vlc_meta_t*)",input\meta.c,"void vlc_meta_Merge( vlc_meta_t *dst, const vlc_meta_t *src )
{
    if( !dst || !src )
        return;

    for( int i = 0; i < VLC_META_TYPE_COUNT; i++ )
    {
        if( src->ppsz_meta[i] )
        {
            free( dst->ppsz_meta[i] );
            dst->ppsz_meta[i] = strdup( src->ppsz_meta[i] );
        }
    }

    /* XXX: If speed up are needed, it is possible */
    char **ppsz_all_keys = vlc_dictionary_all_keys( &src->extra_tags );
    for( int i = 0; ppsz_all_keys && ppsz_all_keys[i]; i++ )
    {
        /* Always try to remove the previous value */
        vlc_dictionary_remove_value_for_key( &dst->extra_tags, ppsz_all_keys[i], vlc_meta_FreeExtraKey, NULL );

        void *p_value = vlc_dictionary_value_for_key( &src->extra_tags, ppsz_all_keys[i] );
        vlc_dictionary_insert( &dst->extra_tags, ppsz_all_keys[i], strdup( (const char*)p_value ) );
        free( ppsz_all_keys[i] );
    }
    free( ppsz_all_keys );
}",177.0,203.0,1.0,1.0,27.0,32,9,34,7,3,8,5,6,1,0,,0,8,4,2,2,void
1233,69555,input_item_WriteMeta,1,input_item_WriteMeta,"int input_item_WriteMeta (vlc_object_t*,input_item_t*)",input\meta.c,"int input_item_WriteMeta( vlc_object_t *obj, input_item_t *p_item )
{
    meta_export_t *p_export =
        vlc_custom_create( obj, sizeof( *p_export ), ""meta writer"" );
    if( p_export == NULL )
        return VLC_ENOMEM;
    p_export->p_item = p_item;

    int type;
    vlc_mutex_lock( &p_item->lock );
    type = p_item->i_type;
    vlc_mutex_unlock( &p_item->lock );
    if( type != ITEM_TYPE_FILE )
        goto error;

    char *psz_uri = input_item_GetURI( p_item );
    p_export->psz_file = vlc_uri2path( psz_uri );
    if( p_export->psz_file == NULL )
        msg_Err( p_export, ""cannot write meta to remote media %s"", psz_uri );
    free( psz_uri );
    if( p_export->psz_file == NULL )
        goto error;

    module_t *p_mod = module_need( p_export, ""meta writer"", NULL, false );
    if( p_mod )
        module_unneed( p_export, p_mod );
    vlc_object_release( p_export );
    return VLC_SUCCESS;

error:
    vlc_object_release( p_export );
    return VLC_EGENERIC;
}",256.0,288.0,1.0,1.0,33.0,21,7,36,12,0,9,8,6,0,9,,0,4,4,2,2,int
1234,69794,mrl_EscapeFragmentIdentifier,1,mrl_EscapeFragmentIdentifier,"int mrl_EscapeFragmentIdentifier (char**,char*)",input\mrl_helpers.h,"static inline int
mrl_EscapeFragmentIdentifier( char** out, char const* payload )
{
    struct vlc_memstream mstream;

#define RFC3986_SUBDELIMS  ""!"" ""$"" ""&"" ""'"" ""("" "")"" \
                           ""*"" ""+"" "","" "";"" ""=""
#define RFC3986_ALPHA      ""abcdefghijklmnopqrstuvwxyz"" \
                           ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""
#define RFC3986_DIGIT      ""0123456789""
#define RFC3986_UNRESERVED RFC3986_ALPHA RFC3986_DIGIT ""-"" ""."" ""_"" ""~""
#define RFC3986_PCHAR      RFC3986_UNRESERVED RFC3986_SUBDELIMS "":"" ""@""
#define RFC3986_FRAGMENT   RFC3986_PCHAR ""/"" ""?""

    if( vlc_memstream_open( &mstream ) )
        return VLC_EGENERIC;

    for( char const* p = payload; *p; ++p )
    {
        vlc_memstream_printf( &mstream,
            ( strchr( ""!?"", *p ) == NULL &&
              strchr( RFC3986_FRAGMENT, *p ) ? ""%c"" : ""%%%02hhx""), *p );
    }

#undef RFC3986_FRAGMENT
#undef RFC3986_PCHAR
#undef RFC3986_UNRESERVEd
#undef RFC3986_DIGIT
#undef RFC3986_ALPHA
#undef RFC3986_SUBDELIMS

    if(...",57.0,93.0,1.0,22.0,37.0,14,7,15,7,1,3,4,4,2,3,,0,2,4,2,2,int
1235,69855,mrl_FragmentSplit,1,mrl_FragmentSplit,"int mrl_FragmentSplit (vlc_array_t*,char**,char*)",input\mrl_helpers.h,"static inline int
mrl_FragmentSplit( vlc_array_t* out_items,
                   char const** out_extra,
                   char const* payload )
{
    char const* extra = NULL;

    vlc_array_init( out_items );

    while( strncmp( payload, ""!/"", 2 ) == 0 )
    {
        payload += 2;

        int len = strcspn( payload, ""!?"" );
        char* decoded = strndup( payload, len );

        if( unlikely( !decoded ) || !vlc_uri_decode( decoded ) )
            goto error;

        if( vlc_array_append( out_items, decoded ) )
        {
            free( decoded );
            goto error;
        }
        payload += len;
    }

    if( *payload )
    {
        if( *payload == '!' )
            goto error;

        if( *payload == '?' && vlc_array_count( out_items ) )
            ++payload;

        extra = payload;
    }

    *out_extra = extra;
    return VLC_SUCCESS;

error:
    for( size_t i = 0; i < vlc_array_count( out_items ); ++i )
        free( vlc_array_item_at_index( out_items, i ...",114.0,160.0,1.0,1.0,47.0,21,9,32,10,0,1,11,12,1,1,,0,1,6,3,3,int
1236,70009,DestroySout,1,DestroySout,void DestroySout (input_resource_t*),input\resource.c,"static void DestroySout( input_resource_t *p_resource )
{
#ifdef ENABLE_SOUT
    if( p_resource->p_sout )
        sout_DeleteInstance( p_resource->p_sout );
#endif
    p_resource->p_sout = NULL;
}",79.0,86.0,1.0,1.0,8.0,2,2,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
1237,70019,RequestSout,1,RequestSout,"sout_instance_t RequestSout (input_resource_t*,sout_instance_t*,char*)",input\resource.c,"static sout_instance_t *RequestSout( input_resource_t *p_resource,
                                     sout_instance_t *p_sout, const char *psz_sout )
{
#ifdef ENABLE_SOUT
    if( !p_sout && !psz_sout )
    {
        if( p_resource->p_sout )
        {
            msg_Dbg( p_resource->p_sout, ""destroying useless sout"" );
            DestroySout( p_resource );
        }
        return NULL;
    }

    assert( !p_sout || ( !p_resource->p_sout && !psz_sout ) );

    /* Check the validity of the sout */
    if( p_resource->p_sout &&
        strcmp( p_resource->p_sout->psz_sout, psz_sout ) )
    {
        msg_Dbg( p_resource->p_parent, ""destroying unusable sout"" );
        DestroySout( p_resource );
    }

    if( psz_sout )
    {
        if( p_resource->p_sout )
        {
            /* Reuse it */
            msg_Dbg( p_resource->p_parent, ""reusing sout"" );
            msg_Dbg( p_resource->p_parent, ""you probably want to use gather stream_out"" );
        }
        else
        {
      ...",88.0,140.0,1.0,1.0,53.0,0,0,4,4,1,0,1,1,0,0,,0,0,6,3,3,sout_instance_t
1238,70034,DestroyVout,1,DestroyVout,void DestroyVout (input_resource_t*),input\resource.c,"static void DestroyVout( input_resource_t *p_resource )
{
    assert( p_resource->i_vout == 0 );

    if( p_resource->p_vout_free )
        vout_CloseAndRelease( p_resource->p_vout_free );

    p_resource->p_vout_free = NULL;
}",143.0,151.0,1.0,1.0,9.0,6,3,5,2,1,4,2,2,1,0,,0,4,2,1,1,void
1239,70059,DisplayVoutTitle,1,DisplayVoutTitle,"void DisplayVoutTitle (input_resource_t*,vout_thread_t*)",input\resource.c,"static void DisplayVoutTitle( input_resource_t *p_resource,
                              vout_thread_t *p_vout )
{
    if( p_resource->p_input == NULL )
        return;

    /* TODO display the title only one time for the same input ? */

    input_item_t *p_item = input_GetItem( p_resource->p_input );

    char *psz_nowplaying = input_item_GetNowPlayingFb( p_item );
    if( psz_nowplaying && *psz_nowplaying )
    {
        vout_DisplayTitle( p_vout, psz_nowplaying );
    }
    else
    {
        char *psz_artist = input_item_GetArtist( p_item );
        char *psz_name = input_item_GetTitle( p_item );

        if( !psz_name || *psz_name == '\0' )
        {
            free( psz_name );
            psz_name = input_item_GetName( p_item );
        }
        if( psz_artist && *psz_artist )
        {
            char *psz_string;
            if( asprintf( &psz_string, ""%s - %s"", psz_name, psz_artist ) != -1 )
            {
                vout_DisplayTitle( p_vout, psz_string );
      ...",153.0,195.0,1.0,1.0,43.0,7,5,11,5,1,5,3,3,1,3,,0,4,4,2,2,void
1240,70158,RequestVout,1,RequestVout,"vout_thread_t RequestVout (input_resource_t*,vout_thread_t*,video_format_t*,unsigned,bool)",input\resource.c,"static vout_thread_t *RequestVout( input_resource_t *p_resource,
                                   vout_thread_t *p_vout,
                                   const video_format_t *p_fmt, unsigned dpb_size,
                                   bool b_recycle )
{
    vlc_assert_locked( &p_resource->lock );

    if( !p_vout && !p_fmt )
    {
        if( p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_vout_free, ""destroying useless vout"" );
            vout_CloseAndRelease( p_resource->p_vout_free );
            p_resource->p_vout_free = NULL;
        }
        return NULL;
    }

    if( p_fmt )
    {
        /* */
        if( !p_vout && p_resource->p_vout_free )
        {
            msg_Dbg( p_resource->p_parent, ""trying to reuse free vout"" );
            p_vout = p_resource->p_vout_free;

            p_resource->p_vout_free = NULL;
        }
        else if( p_vout )
        {
            assert( p_vout != p_resource->p_vout_free );

            vlc_mutex_lock( ...",196.0,290.0,1.0,4.0,95.0,44,8,47,12,1,23,7,11,3,5,,0,19,10,5,5,vout_thread_t
1241,70442,HoldVout,1,HoldVout,vout_thread_t HoldVout (input_resource_t*),input\resource.c,"static vout_thread_t *HoldVout( input_resource_t *p_resource )
{
    /* TODO FIXME: p_resource->pp_vout order is NOT stable */
    vlc_mutex_lock( &p_resource->lock_hold );

    vout_thread_t *p_vout = p_resource->i_vout > 0 ? p_resource->pp_vout[0] : NULL;
    if( p_vout )
        vlc_object_hold( p_vout );

    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_vout;
}",291.0,303.0,1.0,1.0,13.0,10,6,9,3,1,7,2,2,0,3,,0,4,2,1,1,vout_thread_t
1242,70479,HoldVouts,1,HoldVouts,"void HoldVouts (input_resource_t*,vout_thread_t***,size_t*)",input\resource.c,"static void HoldVouts( input_resource_t *p_resource, vout_thread_t ***ppp_vout,
                       size_t *pi_vout )
{
    vout_thread_t **pp_vout;

    *pi_vout = 0;
    *ppp_vout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );

    if( p_resource->i_vout <= 0 )
        goto exit;

    pp_vout = vlc_alloc( p_resource->i_vout, sizeof(*pp_vout) );
    if( !pp_vout )
        goto exit;

    *ppp_vout = pp_vout;
    *pi_vout = p_resource->i_vout;

    for( int i = 0; i < p_resource->i_vout; i++ )
    {
        pp_vout[i] = p_resource->pp_vout[i];
        vlc_object_hold( pp_vout[i] );
    }

exit:
    vlc_mutex_unlock( &p_resource->lock_hold );
}",305.0,333.0,1.0,1.0,29.0,28,9,23,6,1,10,6,4,2,3,,0,7,6,3,3,void
1243,70565,input_resource_GetAout,1,input_resource_GetAout,audio_output_t input_resource_GetAout (input_resource_t*),input\resource.c,"audio_output_t *input_resource_GetAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;

    if( p_aout == NULL || p_resource->b_aout_busy )
    {
        msg_Dbg( p_resource->p_parent, ""creating audio output"" );
        vlc_mutex_unlock( &p_resource->lock_hold );

        p_aout = aout_New( p_resource->p_parent );
        if( p_aout == NULL )
            return NULL; /* failed */

        vlc_mutex_lock( &p_resource->lock_hold );
        if( p_resource->p_aout == NULL )
            p_resource->p_aout = p_aout;
    }
    else
        msg_Dbg( p_resource->p_parent, ""reusing audio output"" );

    if( p_resource->p_aout == p_aout )
    {
        assert( !p_resource->b_aout_busy );
        p_resource->b_aout_busy = true;
    }
    vlc_mutex_unlock( &p_resource->lock_hold );
    return p_aout;
}",336.0,366.0,1.0,17.0,31.0,28,6,26,4,2,19,5,7,3,5,,0,15,2,1,1,audio_output_t
1244,70667,input_resource_PutAout,1,input_resource_PutAout,"void input_resource_PutAout (input_resource_t*,audio_output_t*)",input\resource.c,"void input_resource_PutAout( input_resource_t *p_resource,
                             audio_output_t *p_aout )
{
    assert( p_aout != NULL );

    vlc_mutex_lock( &p_resource->lock_hold );
    if( p_aout == p_resource->p_aout )
    {
        assert( p_resource->b_aout_busy );
        p_resource->b_aout_busy = false;
        msg_Dbg( p_resource->p_parent, ""keeping audio output"" );
        p_aout = NULL;
    }
    else
        msg_Dbg( p_resource->p_parent, ""destroying extra audio output"" );
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",368.0,387.0,1.0,1.0,20.0,13,5,15,4,5,9,3,3,1,3,,0,6,4,2,2,void
1245,70725,input_resource_HoldAout,1,input_resource_HoldAout,audio_output_t input_resource_HoldAout (input_resource_t*),input\resource.c,"audio_output_t *input_resource_HoldAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout;

    vlc_mutex_lock( &p_resource->lock_hold );
    p_aout = p_resource->p_aout;
    if( p_aout != NULL )
        vlc_object_hold( p_aout );
    vlc_mutex_unlock( &p_resource->lock_hold );

    return p_aout;
}",389.0,400.0,1.0,1.0,12.0,7,4,8,3,3,6,2,2,0,3,,0,3,2,1,1,audio_output_t
1246,70755,input_resource_ResetAout,1,input_resource_ResetAout,void input_resource_ResetAout (input_resource_t*),input\resource.c,"void input_resource_ResetAout( input_resource_t *p_resource )
{
    audio_output_t *p_aout = NULL;

    vlc_mutex_lock( &p_resource->lock_hold );
    if( !p_resource->b_aout_busy )
        p_aout = p_resource->p_aout;

    p_resource->p_aout = NULL;
    p_resource->b_aout_busy = false;
    vlc_mutex_unlock( &p_resource->lock_hold );

    if( p_aout != NULL )
        aout_Destroy( p_aout );
}",402.0,416.0,1.0,1.0,15.0,14,5,14,4,1,9,3,3,1,3,,0,6,2,1,1,void
1247,70802,input_resource_New,1,input_resource_New,input_resource_t input_resource_New (vlc_object_t*),input\resource.c,"input_resource_t *input_resource_New( vlc_object_t *p_parent )
{
    input_resource_t *p_resource = calloc( 1, sizeof(*p_resource) );
    if( !p_resource )
        return NULL;

    atomic_init( &p_resource->refs, 1 );
    p_resource->p_parent = p_parent;
    vlc_mutex_init( &p_resource->lock );
    vlc_mutex_init( &p_resource->lock_hold );
    return p_resource;
}",419.0,430.0,1.0,1.0,12.0,12,6,10,3,2,6,2,2,0,2,,0,4,2,1,1,input_resource_t
1248,70844,input_resource_Release,1,input_resource_Release,void input_resource_Release (input_resource_t*),input\resource.c,"void input_resource_Release( input_resource_t *p_resource )
{
    if( atomic_fetch_sub( &p_resource->refs, 1 ) != 1 )
        return;

    DestroySout( p_resource );
    DestroyVout( p_resource );
    if( p_resource->p_aout != NULL )
        aout_Destroy( p_resource->p_aout );

    vlc_mutex_destroy( &p_resource->lock_hold );
    vlc_mutex_destroy( &p_resource->lock );
    free( p_resource );
}",432.0,445.0,1.0,1.0,14.0,10,3,9,2,4,10,3,3,2,5,,0,5,2,1,1,void
1249,70887,input_resource_Hold,1,input_resource_Hold,input_resource_t input_resource_Hold (input_resource_t*),input\resource.c,"input_resource_t *input_resource_Hold( input_resource_t *p_resource )
{
    atomic_fetch_add( &p_resource->refs, 1 );
    return p_resource;
}",447.0,451.0,1.0,1.0,5.0,2,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,input_resource_t
1250,70900,input_resource_SetInput,1,input_resource_SetInput,"void input_resource_SetInput (input_resource_t*,input_thread_t*)",input\resource.c,"void input_resource_SetInput( input_resource_t *p_resource, input_thread_t *p_input )
{
    vlc_mutex_lock( &p_resource->lock );

    if( p_resource->p_input && !p_input )
        assert( p_resource->i_vout == 0 );

    /* */
    p_resource->p_input = p_input;

    vlc_mutex_unlock( &p_resource->lock );
}",453.0,464.0,1.0,1.0,12.0,11,6,7,2,0,7,2,2,1,2,,0,5,4,2,2,void
1251,70935,input_resource_RequestVout,1,input_resource_RequestVout,"vout_thread_t input_resource_RequestVout (input_resource_t*,vout_thread_t*,video_format_t*,unsigned,bool)",input\resource.c,"vout_thread_t *input_resource_RequestVout( input_resource_t *p_resource,
                                            vout_thread_t *p_vout,
                                            const video_format_t *p_fmt, unsigned dpb_size,
                                            bool b_recycle )
{
    vlc_mutex_lock( &p_resource->lock );
    vout_thread_t *p_ret = RequestVout( p_resource, p_vout, p_fmt, dpb_size, b_recycle );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",466.0,476.0,1.0,1.0,11.0,5,3,9,6,4,5,1,1,0,3,,0,3,10,5,5,vout_thread_t
1252,70965,input_resource_HoldVout,1,input_resource_HoldVout,vout_thread_t input_resource_HoldVout (input_resource_t*),input\resource.c,"vout_thread_t *input_resource_HoldVout( input_resource_t *p_resource )
{
    return HoldVout( p_resource );
}",477.0,480.0,1.0,1.0,4.0,0,0,1,1,3,1,1,1,0,1,,0,0,2,1,1,vout_thread_t
1253,70973,input_resource_HoldVouts,1,input_resource_HoldVouts,"void input_resource_HoldVouts (input_resource_t*,vout_thread_t***,size_t*)",input\resource.c,"void input_resource_HoldVouts( input_resource_t *p_resource, vout_thread_t ***ppp_vout,
                               size_t *pi_vout )
{
    HoldVouts( p_resource, ppp_vout, pi_vout );
}",482.0,486.0,1.0,1.0,5.0,0,0,3,3,3,1,1,1,0,1,,0,0,6,3,3,void
1254,70984,input_resource_TerminateVout,1,input_resource_TerminateVout,void input_resource_TerminateVout (input_resource_t*),input\resource.c,"void input_resource_TerminateVout( input_resource_t *p_resource )
{
    input_resource_RequestVout( p_resource, NULL, NULL, 0, false );
}",488.0,491.0,1.0,1.0,4.0,0,0,4,3,4,1,1,1,0,1,,0,0,2,1,1,void
1255,71025,input_resource_RequestSout,1,input_resource_RequestSout,"sout_instance_t input_resource_RequestSout (input_resource_t*,sout_instance_t*,char*)",input\resource.c,"sout_instance_t *input_resource_RequestSout( input_resource_t *p_resource, sout_instance_t *p_sout, const char *psz_sout )
{
    vlc_mutex_lock( &p_resource->lock );
    sout_instance_t *p_ret = RequestSout( p_resource, p_sout, psz_sout );
    vlc_mutex_unlock( &p_resource->lock );

    return p_ret;
}",503.0,510.0,1.0,1.0,8.0,5,3,7,4,0,5,1,1,0,3,,0,3,6,3,3,sout_instance_t
1256,71060,input_resource_Terminate,1,input_resource_Terminate,void input_resource_Terminate (input_resource_t*),input\resource.c,"void input_resource_Terminate( input_resource_t *p_resource )
{
    input_resource_TerminateSout( p_resource );
    input_resource_ResetAout( p_resource );
    input_resource_TerminateVout( p_resource );
}",516.0,521.0,1.0,1.0,6.0,0,0,3,1,1,3,1,1,0,3,,0,0,2,1,1,void
1257,71146,vlc_sd_probe_Add,1,vlc_sd_probe_Add,"int vlc_sd_probe_Add (vlc_probe_t*,char*,char*,int)",input\services_discovery.c,"int vlc_sd_probe_Add (vlc_probe_t *probe, const char *name,
                      const char *longname, int category)
{
    vlc_sd_probe_t names = { strdup(name), strdup(longname), category };

    if (unlikely (names.name == NULL || names.longname == NULL
               || vlc_probe_add (probe, &names, sizeof (names))))
    {
        free (names.name);
        free (names.longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",41.0,54.0,1.0,1.0,14.0,12,7,15,8,0,4,2,2,2,0,,0,4,8,4,4,int
1258,71196,vlc_sd_GetNames,1,vlc_sd_GetNames,"char** vlc_sd_GetNames (vlc_object_t*,char***,int**)",input\services_discovery.c,"char **vlc_sd_GetNames (vlc_object_t *obj, char ***pppsz_longnames, int **pp_categories)
{
    size_t count;
    vlc_sd_probe_t *tab = vlc_probe (obj, ""services probe"", &count);

    if (count == 0)
    {
        free (tab);
        return NULL;
    }

    char **names = vlc_alloc (count + 1, sizeof(char *));
    char **longnames = vlc_alloc (count + 1, sizeof(char *));
    int *categories = vlc_alloc (count + 1, sizeof(int));

    if (unlikely (names == NULL || longnames == NULL || categories == NULL))
    {
        free(names);
        free(longnames);
        free(categories);
        free(tab);
        return NULL;
    }
    for( size_t i = 0; i < count; i++ )
    {
        names[i] = tab[i].name;
        longnames[i] = tab[i].longname;
        categories[i] = tab[i].category;
    }
    free (tab);
    names[count] = longnames[count] = NULL;
    categories[count] = 0;
    *pppsz_longnames = longnames;
    if( pp_categories ) *pp_categories = categories;
    else free( categories...",61.0,97.0,1.0,1.0,37.0,41,10,55,12,0,1,5,5,0,1,,0,1,6,3,3,char**
1259,71344,vlc_sd_Create,1,vlc_sd_Create,"services_discovery_t vlc_sd_Create (vlc_object_t*,char*,services_discovery_owner_t*)",input\services_discovery.c,"services_discovery_t *vlc_sd_Create(vlc_object_t *parent, const char *cfg,
    const struct services_discovery_owner_t *restrict owner)
{
    services_discovery_t *sd = vlc_custom_create(parent, sizeof (*sd),
                                                 ""services discovery"");
    if (unlikely(sd == NULL))
        return NULL;

    free(config_ChainCreate(&sd->psz_name, &sd->p_cfg, cfg));
    sd->description = NULL;
    sd->owner = *owner;

    sd->p_module = module_need(sd, ""services_discovery"",
                               sd->psz_name, true);
    if (sd->p_module == NULL)
    {
        msg_Err(sd, ""no suitable services discovery module"");
        vlc_sd_Destroy(sd);
        sd = NULL;
    }

    return sd;
}",106.0,128.0,1.0,31.0,23.0,19,6,25,6,1,4,3,3,0,4,,0,2,6,3,3,services_discovery_t
1260,71422,vlc_sd_Destroy,1,vlc_sd_Destroy,void vlc_sd_Destroy (services_discovery_t*),input\services_discovery.c,"void vlc_sd_Destroy(services_discovery_t *sd)
{
    if (sd->p_module != NULL)
        module_unneed(sd, sd->p_module);
    config_ChainDestroy(sd->p_cfg);
    free(sd->psz_name);
    vlc_object_release(sd);
}",130.0,137.0,1.0,1.0,8.0,5,2,7,2,2,3,2,2,0,3,,0,0,2,1,1,void
1261,71460,stats_CounterCreate,1,stats_CounterCreate,counter_t stats_CounterCreate (int),input\stats.c,"counter_t * stats_CounterCreate( int i_compute_type )
{
    counter_t *p_counter = (counter_t*) malloc( sizeof( counter_t ) ) ;

    if( !p_counter ) return NULL;
    p_counter->i_compute_type = i_compute_type;
    p_counter->i_samples = 0;
    p_counter->pp_samples = NULL;

    p_counter->last_update = 0;

    return p_counter;
}",38.0,50.0,1.0,1.0,13.0,12,5,11,4,14,4,2,2,0,0,,0,4,2,1,1,counter_t
1262,71501,stats_GetTotal,1,stats_GetTotal,int64_t stats_GetTotal (counter_t*),input\stats.c,"static inline int64_t stats_GetTotal(const counter_t *counter)
{
    if (counter == NULL || counter->i_samples == 0)
        return 0;
    return counter->pp_samples[0]->value;
}",52.0,57.0,1.0,1.0,6.0,7,4,4,2,13,2,2,2,1,0,,0,2,2,1,1,int64_t
1263,71527,stats_GetRate,1,stats_GetRate,float stats_GetRate (counter_t*),input\stats.c,"static inline float stats_GetRate(const counter_t *counter)
{
    if (counter == NULL || counter->i_samples < 2)
        return 0.;

    return (counter->pp_samples[0]->value - counter->pp_samples[1]->value)
        / (float)(counter->pp_samples[0]->date - counter->pp_samples[1]->date);
}",59.0,66.0,1.0,1.0,8.0,20,8,7,2,3,5,2,2,1,0,,0,5,2,1,1,float
1264,71609,stats_ComputeInputStats,1,stats_ComputeInputStats,"void stats_ComputeInputStats (input_thread_t*,input_stats_t*)",input\stats.c,"void stats_ComputeInputStats(input_thread_t *input, input_stats_t *st)
{
    input_thread_private_t *priv = input_priv(input);

    if (!libvlc_stats(input))
        return;

    vlc_mutex_lock(&priv->counters.counters_lock);
    vlc_mutex_lock(&st->lock);

    /* Input */
    st->i_read_packets = stats_GetTotal(priv->counters.p_read_packets);
    st->i_read_bytes = stats_GetTotal(priv->counters.p_read_bytes);
    st->f_input_bitrate = stats_GetRate(priv->counters.p_input_bitrate);
    st->i_demux_read_bytes = stats_GetTotal(priv->counters.p_demux_read);
    st->f_demux_bitrate = stats_GetRate(priv->counters.p_demux_bitrate);
    st->i_demux_corrupted = stats_GetTotal(priv->counters.p_demux_corrupted);
    st->i_demux_discontinuity = stats_GetTotal(priv->counters.p_demux_discontinuity);

    /* Decoders */
    st->i_decoded_video = stats_GetTotal(priv->counters.p_decoded_video);
    st->i_decoded_audio = stats_GetTotal(priv->counters.p_decoded_audio);

    /* Sout */
    if (priv->c...",81.0,122.0,1.0,1.0,42.0,78,5,40,3,1,21,3,3,0,21,,0,17,4,2,2,void
1265,71817,stats_ReinitInputStats,1,stats_ReinitInputStats,void stats_ReinitInputStats (input_stats_t*),input\stats.c,"void stats_ReinitInputStats( input_stats_t *p_stats )
{
    vlc_mutex_lock( &p_stats->lock );
    p_stats->i_read_packets = p_stats->i_read_bytes =
    p_stats->f_input_bitrate = p_stats->f_average_input_bitrate =
    p_stats->i_demux_read_packets = p_stats->i_demux_read_bytes =
    p_stats->f_demux_bitrate = p_stats->f_average_demux_bitrate =
    p_stats->i_demux_corrupted = p_stats->i_demux_discontinuity =
    p_stats->i_displayed_pictures = p_stats->i_lost_pictures =
    p_stats->i_played_abuffers = p_stats->i_lost_abuffers =
    p_stats->i_decoded_video = p_stats->i_decoded_audio =
    p_stats->i_sent_bytes = p_stats->i_sent_packets = p_stats->f_send_bitrate
     = 0;
    vlc_mutex_unlock( &p_stats->lock );
}",124.0,138.0,1.0,1.0,15.0,42,3,21,1,0,2,1,1,0,2,,0,0,2,1,1,void
1266,71909,stats_CounterClean,1,stats_CounterClean,void stats_CounterClean (counter_t*),input\stats.c,"void stats_CounterClean( counter_t *p_c )
{
    if( p_c )
    {
        for( int i = 0; i < p_c->i_samples; i++ )
            free( p_c->pp_samples[i] );
        TAB_CLEAN(p_c->i_samples, p_c->pp_samples);
        free( p_c );
    }
}",140.0,149.0,1.0,1.0,10.0,5,3,7,2,0,3,3,4,1,0,,0,3,2,1,1,void
1267,71945,stats_Update,1,stats_Update,"void stats_Update (counter_t*,uint64_t,uint64_t*)",input\stats.c,"void stats_Update( counter_t *p_counter, uint64_t val, uint64_t *new_val )
{
    if( !p_counter )
        return;

    switch( p_counter->i_compute_type )
    {
    case STATS_DERIVATIVE:
    {
        counter_sample_t *p_new, *p_old;
        mtime_t now = mdate();
        if( now - p_counter->last_update < CLOCK_FREQ )
            return;
        p_counter->last_update = now;
        /* Insert the new one at the beginning */
        p_new = (counter_sample_t*)malloc( sizeof( counter_sample_t ) );
        if (unlikely(p_new == NULL))
            return; /* NOTE: Losing sample here */

        p_new->value = val;
        p_new->date = p_counter->last_update;
        TAB_INSERT(p_counter->i_samples, p_counter->pp_samples, p_new, 0);

        if( p_counter->i_samples == 3 )
        {
            p_old = p_counter->pp_samples[2];
            TAB_ERASE(p_counter->i_samples, p_counter->pp_samples, 2);
            free( p_old );
        }
        break;
    }
    case STATS_COUNTER:
      ...",158.0,209.0,1.0,1.0,52.0,47,11,42,11,19,20,12,19,5,1,,0,20,6,3,3,void
1268,72152,destroy,1,stream_priv_t.destroy,void stream_priv_t.destroy (stream_t*),input\stream.c,void (*destroy)(stream_t *);,50.0,50.0,10.0,31.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1269,72167,vlc_stream_CommonNew,1,vlc_stream_CommonNew,"stream_t vlc_stream_CommonNew (vlc_object_t*,void)",input\stream.c,"stream_t *vlc_stream_CommonNew(vlc_object_t *parent,
                               void (*destroy)(stream_t *))
{
    stream_priv_t *priv = vlc_custom_create(parent, sizeof (*priv), ""stream"");
    if (unlikely(priv == NULL))
        return NULL;

    stream_t *s = &priv->stream;

    s->p_module = NULL;
    s->psz_url = NULL;
    s->p_source = NULL;
    s->pf_read = NULL;
    s->pf_block = NULL;
    s->pf_readdir = NULL;
    s->pf_seek = NULL;
    s->pf_control = NULL;
    s->p_sys = NULL;
    s->p_input = NULL;
    assert(destroy != NULL);
    priv->destroy = destroy;
    priv->block = NULL;
    priv->peek = NULL;
    priv->offset = 0;
    priv->eof = false;

    /* UTF16 and UTF32 text file conversion */
    priv->text.conv = (vlc_iconv_t)(-1);
    priv->text.char_width = 1;
    priv->text.little_endian = false;

    return s;
}",67.0,99.0,1.0,1.0,33.0,48,9,44,6,6,6,2,2,0,1,,0,6,4,2,2,stream_t
1270,72301,stream_CommonDelete,1,stream_CommonDelete,void stream_CommonDelete (stream_t*),input\stream.c,"void stream_CommonDelete(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    if (priv->text.conv != (vlc_iconv_t)(-1))
        vlc_iconv_close(priv->text.conv);

    if (priv->peek != NULL)
        block_Release(priv->peek);
    if (priv->block != NULL)
        block_Release(priv->block);

    free(s->psz_url);
    vlc_object_release(s);
}",101.0,115.0,1.0,1.0,15.0,15,6,12,3,6,6,4,4,2,2,,0,4,2,1,1,void
1271,72357,vlc_stream_Delete,1,vlc_stream_Delete,void vlc_stream_Delete (stream_t*),input\stream.c,"void vlc_stream_Delete(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->destroy(s);
    stream_CommonDelete(s);
}",120.0,126.0,1.0,1.0,7.0,3,3,5,2,10,2,1,1,0,2,,0,0,2,1,1,void
1272,72375,vlc_stream_NewURL,1,,"stream_t (vlc_object_t*,char*)",input\stream.c,"stream_t *(vlc_stream_NewURL)(vlc_object_t *p_parent, const char *psz_url)
{
    if( !psz_url )
        return NULL;

    stream_t *s = stream_AccessNew( p_parent, NULL, false, psz_url );
    if( s == NULL )
        msg_Err( p_parent, ""no suitable access module for `%s'"", psz_url );
    return s;
}",128.0,137.0,1.0,1.0,10.0,3,3,12,5,0,1,3,3,0,1,,0,1,4,2,2,stream_t
1273,72406,vlc_stream_NewMRL,1,,"stream_t (vlc_object_t*,char*)",input\stream.c,"stream_t *(vlc_stream_NewMRL)(vlc_object_t* parent, const char* mrl )
{
    stream_t* stream = vlc_stream_NewURL( parent, mrl );

    if( stream == NULL )
        return NULL;

    char const* anchor = strchr( mrl, '#' );

    if( anchor == NULL )
        return stream;

    char const* extra;
    if( stream_extractor_AttachParsed( &stream, anchor + 1, &extra ) )
    {
        msg_Err( parent, ""unable to open %s"", mrl );
        vlc_stream_Delete( stream );
        return NULL;
    }

    if( extra && *extra )
        msg_Warn( parent, ""ignoring extra fragment data: %s"", extra );

    return stream;
}",139.0,163.0,1.0,1.0,25.0,9,6,23,6,0,2,5,5,1,2,,0,1,4,2,2,stream_t
1274,72469,vlc_stream_ReadLine,1,vlc_stream_ReadLine,char* vlc_stream_ReadLine (stream_t*),input\stream.c,"char *vlc_stream_ReadLine( stream_t *s )
{
    stream_priv_t *priv = (stream_priv_t *)s;
    char *p_line = NULL;
    int i_line = 0, i_read = 0;

    /* Let's fail quickly if this is a readdir access */
    if( s->pf_read == NULL && s->pf_block == NULL )
        return NULL;

    for( ;; )
    {
        char *psz_eol;
        const uint8_t *p_data;
        int i_data;
        int64_t i_pos;

        /* Probe new data */
        i_data = vlc_stream_Peek( s, &p_data, STREAM_PROBE_LINE );
        if( i_data <= 0 ) break; /* No more data */

        /* BOM detection */
        i_pos = vlc_stream_Tell( s );
        if( i_pos == 0 && i_data >= 2 )
        {
            const char *psz_encoding = NULL;
            bool little_endian = false;

            if( unlikely(priv->text.conv != (vlc_iconv_t)-1) )
            {   /* seek back to beginning? reset */
                vlc_iconv_close( priv->text.conv );
                priv->text.conv = (vlc_iconv_t)-1;
            }
            priv->...",172.0,359.0,1.0,46.0,188.0,145,20,152,23,0,8,34,54,1,8,,0,6,2,1,1,char*
1275,73084,vlc_stream_CopyBlock,1,vlc_stream_CopyBlock,"ssize_t vlc_stream_CopyBlock (block_t**,void*,size_t)",input\stream.c,"static ssize_t vlc_stream_CopyBlock(block_t **restrict pp,
                                    void *buf, size_t len)
{
    block_t *block = *pp;

    if (block == NULL)
        return -1;

    if (len > block->i_buffer)
        len = block->i_buffer;

    if (buf != NULL)
        memcpy(buf, block->p_buffer, len);

    block->p_buffer += len;
    block->i_buffer -= len;

    if (block->i_buffer == 0)
    {
        block_Release(block);
        *pp = NULL;
    }

    return likely(len > 0) ? (ssize_t)len : -1;
}",361.0,385.0,1.0,1.0,25.0,22,11,23,5,3,0,5,5,0,0,,0,0,6,3,3,ssize_t
1276,73161,vlc_stream_ReadRaw,1,vlc_stream_ReadRaw,"ssize_t vlc_stream_ReadRaw (stream_t*,void*,size_t)",input\stream.c,"static ssize_t vlc_stream_ReadRaw(stream_t *s, void *buf, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    assert(len <= SSIZE_MAX);

    if (vlc_killed())
        return 0;

    if (s->pf_read != NULL)
    {
        assert(priv->block == NULL);
        if (buf == NULL)
        {
            if (unlikely(len == 0))
                return 0;

            char dummy[(len <= 256 ? len : 256)];
            ret = s->pf_read(s, dummy, sizeof (dummy));
        }
        else
            ret = s->pf_read(s, buf, len);
        return ret;
    }

    ret = vlc_stream_CopyBlock(&priv->block, buf, len);
    if (ret >= 0)
        return ret;

    if (s->pf_block != NULL)
    {
        bool eof = false;

        priv->block = s->pf_block(s, &eof);
        ret = vlc_stream_CopyBlock(&priv->block, buf, len);
        if (ret >= 0)
            return ret;
        return eof ? 0 : -1;
    }

    return 0;
}",387.0,429.0,1.0,1.0,43.0,29,11,38,10,2,7,8,12,1,3,,0,7,6,3,3,ssize_t
1277,73296,vlc_stream_ReadPartial,1,vlc_stream_ReadPartial,"ssize_t vlc_stream_ReadPartial (stream_t*,void*,size_t)",input\stream.c,"ssize_t vlc_stream_ReadPartial(stream_t *s, void *buf, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    ssize_t ret;

    ret = vlc_stream_CopyBlock(&priv->peek, buf, len);
    if (ret >= 0)
    {
        priv->offset += ret;
        assert(ret <= (ssize_t)len);
        return ret;
    }

    ret = vlc_stream_ReadRaw(s, buf, len);
    if (ret > 0)
        priv->offset += ret;
    if (ret == 0)
        priv->eof = len != 0;
    assert(ret <= (ssize_t)len);
    return ret;
}",431.0,451.0,1.0,1.0,21.0,20,10,25,5,2,6,4,4,0,2,,0,6,6,3,3,ssize_t
1278,73373,vlc_stream_Read,1,vlc_stream_Read,"ssize_t vlc_stream_Read (stream_t*,void*,size_t)",input\stream.c,"ssize_t vlc_stream_Read(stream_t *s, void *buf, size_t len)
{
    size_t copied = 0;

    while (len > 0)
    {
        ssize_t ret = vlc_stream_ReadPartial(s, buf, len);
        if (ret < 0)
            continue;
        if (ret == 0)
            break;

        if (buf != NULL)
            buf = (char *)buf + ret;
        assert(len >= (size_t)ret);
        len -= ret;
        copied += ret;
    }

    return copied;
}",453.0,473.0,1.0,1.0,21.0,13,10,20,6,5,1,7,8,0,1,,0,1,6,3,3,ssize_t
1279,73434,vlc_stream_Peek,1,vlc_stream_Peek,"ssize_t vlc_stream_Peek (stream_t*,uint8_t**,size_t)",input\stream.c,"ssize_t vlc_stream_Peek(stream_t *s, const uint8_t **restrict bufp, size_t len)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *peek;

    peek = priv->peek;
    if (peek == NULL)
    {
        peek = priv->block;
        priv->peek = peek;
        priv->block = NULL;
    }

    if (peek == NULL)
    {
        peek = block_Alloc(len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = 0;
    }
    else
    if (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;

        peek = block_TryRealloc(peek, 0, len);
        if (unlikely(peek == NULL))
            return VLC_ENOMEM;

        peek->i_buffer = avail;
    }

    priv->peek = peek;
    *bufp = peek->p_buffer;

    while (peek->i_buffer < len)
    {
        size_t avail = peek->i_buffer;
        ssize_t ret;

        ret = vlc_stream_ReadRaw(s, peek->p_buffer + avail, len - avail);
        if (ret < 0)
            continue;

        peek->i_buffer += ret;

    ...",475.0,527.0,1.0,1.0,53.0,34,9,40,9,1,7,8,10,0,2,,0,7,6,3,3,ssize_t
1280,73588,vlc_stream_ReadBlock,1,vlc_stream_ReadBlock,block_t vlc_stream_ReadBlock (stream_t*),input\stream.c,"block_t *vlc_stream_ReadBlock(stream_t *s)
{
    stream_priv_t *priv = (stream_priv_t *)s;
    block_t *block;

    if (vlc_killed())
    {
        priv->eof = true;
        return NULL;
    }

    if (priv->peek != NULL)
    {
        block = priv->peek;
        priv->peek = NULL;
    }
    else if (priv->block != NULL)
    {
        block = priv->block;
        priv->block = NULL;
    }
    else if (s->pf_block != NULL)
    {
        priv->eof = false;
        block = s->pf_block(s, &priv->eof);
    }
    else
    {
        block = block_Alloc(4096);
        if (unlikely(block == NULL))
            return NULL;

        ssize_t ret = s->pf_read(s, block->p_buffer, block->i_buffer);
        if (ret > 0)
            block->i_buffer = ret;
        else
        {
            block_Release(block);
            block = NULL;
        }

        priv->eof = !ret;
    }

    if (block != NULL)
        priv->offset += block->i_buffer;

    return block;
}",529.0,577.0,1.0,1.0,49.0,14,5,16,5,1,6,4,4,2,1,,0,6,2,1,1,block_t
1281,73736,vlc_stream_Tell,1,vlc_stream_Tell,uint64_t vlc_stream_Tell (stream_t*),input\stream.c,"uint64_t vlc_stream_Tell(const stream_t *s)
{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->offset;
}",579.0,584.0,1.0,1.0,6.0,3,3,3,2,3,1,1,1,0,0,,0,1,2,1,1,uint64_t
1282,73751,vlc_stream_Eof,1,vlc_stream_Eof,bool vlc_stream_Eof (stream_t*),input\stream.c,"bool vlc_stream_Eof(const stream_t *s)
{
    const stream_priv_t *priv = (const stream_priv_t *)s;

    return priv->eof;
}",586.0,591.0,1.0,1.0,6.0,3,3,3,2,2,1,1,1,0,0,,0,1,2,1,1,bool
1283,73766,vlc_stream_Seek,1,vlc_stream_Seek,"int vlc_stream_Seek (stream_t*,uint64_t)",input\stream.c,"int vlc_stream_Seek(stream_t *s, uint64_t offset)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    priv->eof = false;

    block_t *peek = priv->peek;
    if (peek != NULL)
    {
        if (offset >= priv->offset
         && offset <= (priv->offset + peek->i_buffer))
        {   /* Seeking within the peek buffer */
            size_t fwd = offset - priv->offset;

            peek->p_buffer += fwd;
            peek->i_buffer -= fwd;
            priv->offset = offset;

            if (peek->i_buffer == 0)
            {
                priv->peek = NULL;
                block_Release(peek);
            }

            return VLC_SUCCESS;
        }
    }
    else
    {
        if (priv->offset == offset)
            return VLC_SUCCESS; /* Nothing to do! */
    }

    if (s->pf_seek == NULL)
        return VLC_EGENERIC;

    int ret = s->pf_seek(s, offset);
    if (ret != VLC_SUCCESS)
        return ret;

    priv->offset = offset;

    if (peek != NULL)
    {
        priv->peek = NU...",593.0,648.0,1.0,1.0,56.0,42,12,50,10,4,12,8,11,3,0,,0,12,4,2,2,int
1284,73921,vlc_stream_vaControl,1,vlc_stream_vaControl,"int vlc_stream_vaControl (stream_t*,int,va_list)",input\stream.c,"int vlc_stream_vaControl(stream_t *s, int cmd, va_list args)
{
    stream_priv_t *priv = (stream_priv_t *)s;

    switch (cmd)
    {
        case STREAM_SET_TITLE:
        case STREAM_SET_SEEKPOINT:
        {
            int ret = s->pf_control(s, cmd, args);
            if (ret != VLC_SUCCESS)
                return ret;

            priv->offset = 0;

            if (priv->peek != NULL)
            {
                block_Release(priv->peek);
                priv->peek = NULL;
            }

            if (priv->block != NULL)
            {
                block_Release(priv->block);
                priv->block = NULL;
            }

            return VLC_SUCCESS;
        }
    }
    return s->pf_control(s, cmd, args);
}",655.0,686.0,1.0,1.0,32.0,18,4,29,9,4,7,5,8,2,0,,0,7,6,3,3,int
1285,74006,vlc_stream_Block,1,vlc_stream_Block,"block_t vlc_stream_Block (stream_t*,size_t)",input\stream.c,"block_t *vlc_stream_Block( stream_t *s, size_t size )
{
    if( unlikely(size > SSIZE_MAX) )
        return NULL;

    block_t *block = block_Alloc( size );
    if( unlikely(block == NULL) )
        return NULL;

    ssize_t val = vlc_stream_Read( s, block->p_buffer, size );
    if( val <= 0 )
    {
        block_Release( block );
        return NULL;
    }

    block->i_buffer = val;
    return block;
}",697.0,715.0,1.0,1.0,19.0,8,5,18,6,0,2,4,4,0,2,,0,2,4,2,2,block_t
1286,74058,vlc_stream_ReadDir,1,vlc_stream_ReadDir,"int vlc_stream_ReadDir (stream_t*,input_item_node_t*)",input\stream.c,"int vlc_stream_ReadDir( stream_t *s, input_item_node_t *p_node )
{
    return s->pf_readdir( s, p_node );
}",721.0,724.0,1.0,1.0,4.0,1,1,3,2,1,0,1,1,0,0,,0,0,4,2,2,int
1287,74093,stream_FilterAutoNew,1,stream_FilterAutoNew,stream_t* stream_FilterAutoNew (stream_t*),input\stream_filter.c,"stream_t *stream_FilterAutoNew( stream_t *p_source )
{
    /* Limit number of entries to avoid infinite recursion. */
    for( unsigned i = 0; i < 16; i++ )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, NULL );
        if( p_filter == NULL )
            break;

        msg_Dbg( p_filter, ""stream filter added to %p"", (void *)p_source );
        p_source = p_filter;
    }
    return p_source;
}",71.0,84.0,1.0,1.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,stream_t
1288,74100,stream_FilterChainNew,1,stream_FilterChainNew,"stream_t* stream_FilterChainNew (stream_t*,char*)",input\stream_filter.c,"stream_t *stream_FilterChainNew( stream_t *p_source, const char *psz_chain )
{
    /* Add user stream filter */
    char *chain = strdup( psz_chain );
    if( unlikely(chain == NULL) )
        return p_source;

    char *buf;
    for( const char *name = strtok_r( chain, "":"", &buf );
         name != NULL;
         name = strtok_r( NULL, "":"", &buf ) )
    {
        stream_t *p_filter = vlc_stream_FilterNew( p_source, name );
        if( p_filter != NULL )
            p_source = p_filter;
        else
            msg_Warn( p_source, ""cannot insert stream filter %s"", name );
    }
    free( chain );

    return p_source;
}",87.0,108.0,1.0,1.0,22.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,stream_t
1289,74108,stream_extractor_AttachParsed,1,stream_extractor_AttachParsed,"int stream_extractor_AttachParsed (stream_t**,char*,char**)",input\stream_extractor.c,"int
stream_extractor_AttachParsed( stream_t** source, char const* data,
                               char const** out_extra )
{
    vlc_array_t identifiers;

    if( mrl_FragmentSplit( &identifiers, out_extra, data ) )
        return VLC_EGENERIC;

    size_t count = vlc_array_count( &identifiers );
    size_t idx = 0;

    while( idx < count )
    {
        char* id = vlc_array_item_at_index( &identifiers, idx );

        if( vlc_stream_extractor_Attach( source, id, NULL ) )
            break;

        ++idx;
    }

    for( size_t i = 0; i < count; ++i )
        free( vlc_array_item_at_index( &identifiers, i ) );
    vlc_array_clear( &identifiers );

    return idx == count ? VLC_SUCCESS : VLC_EGENERIC;
}",346.0,373.0,1.0,1.0,28.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
1290,74151,pf_init,1,stream_extractor_private.pf_init,"int stream_extractor_private.pf_init (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"int (*pf_init)( struct stream_extractor_private*, stream_t* );",61.0,61.0,9.0,65.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1291,74157,pf_clean,1,stream_extractor_private.pf_clean,void stream_extractor_private.pf_clean (stream_extractor_private*),input\stream_extractor.c,void (*pf_clean)( struct stream_extractor_private* );,70.0,70.0,10.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1292,74166,StreamExtractorCreateMRL,1,StreamExtractorCreateMRL,"char* StreamExtractorCreateMRL (char*,char*)",input\stream_extractor.c,"static char*
StreamExtractorCreateMRL( char const* base, char const* subentry )
{
    struct vlc_memstream buffer;
    char* escaped;

    if( mrl_EscapeFragmentIdentifier( &escaped, subentry ) )
        return NULL;

    if( vlc_memstream_open( &buffer ) )
    {
        free( escaped );
        return NULL;
    }

    vlc_memstream_puts( &buffer, base );

    if( !strstr( base, ""#"" ) )
        vlc_memstream_putc( &buffer, '#' );

    vlc_memstream_printf( &buffer, ""!/%s"", escaped );

    free( escaped );
    return vlc_memstream_close( &buffer ) ? NULL : buffer.ptr;
}",88.0,112.0,1.0,1.0,25.0,9,4,16,5,2,5,4,4,2,5,,0,2,4,2,2,char*
1293,74221,se_Release,1,se_Release,void se_Release (stream_extractor_private*),input\stream_extractor.c,"static void se_Release( struct stream_extractor_private* priv )
{
    if( priv->pf_clean )
        priv->pf_clean( priv );

    if( priv->module )
    {
        module_unneed( priv->object, priv->module );

        if( priv->source )
            vlc_stream_Delete( priv->source );
    }

    vlc_object_release( priv->object );
}",118.0,132.0,1.0,1.0,15.0,8,1,9,1,2,10,4,5,2,4,,0,6,2,1,1,void
1294,74261,se_StreamDelete,1,se_StreamDelete,void se_StreamDelete (stream_t*),input\stream_extractor.c,"static void
se_StreamDelete( stream_t* stream )
{
    se_Release( stream->p_sys );
}",140.0,144.0,1.0,1.0,5.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1295,74270,se_StreamRead,1,se_StreamRead,"ssize_t se_StreamRead (stream_t*,void*,size_t)",input\stream_extractor.c,"static ssize_t
se_StreamRead( stream_t* stream, void* buf, size_t len )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_read( &priv->extractor, buf, len );
}",146.0,151.0,1.0,1.0,6.0,6,4,6,4,0,2,1,1,0,0,,0,2,6,3,3,ssize_t
1296,74296,se_StreamBlock,1,se_StreamBlock,"block_t se_StreamBlock (stream_t*,bool*)",input\stream_extractor.c,"static block_t*
se_StreamBlock( stream_t* stream, bool* eof )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_block( &priv->extractor, eof );
}",153.0,158.0,1.0,1.0,6.0,6,4,5,3,0,2,1,1,0,0,,0,2,4,2,2,block_t
1297,74320,se_StreamSeek,1,se_StreamSeek,"int se_StreamSeek (stream_t*,uint64_t)",input\stream_extractor.c,"static int
se_StreamSeek( stream_t* stream, uint64_t offset )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_seek( &priv->extractor, offset );
}",160.0,165.0,1.0,1.0,6.0,6,4,5,3,0,2,1,1,0,0,,0,2,4,2,2,int
1298,74344,se_ReadDir,1,se_ReadDir,"int se_ReadDir (stream_t*,input_item_node_t*)",input\stream_extractor.c,"static int
se_ReadDir( stream_t* stream, input_item_node_t* node )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->directory.pf_readdir( &priv->directory, node );
}",167.0,172.0,1.0,1.0,6.0,6,4,5,3,0,2,1,1,0,0,,0,2,4,2,2,int
1299,74368,se_StreamControl,1,se_StreamControl,"int se_StreamControl (stream_t*,int,va_list)",input\stream_extractor.c,"static int
se_StreamControl( stream_t* stream, int req, va_list args )
{
    struct stream_extractor_private* priv = stream->p_sys;
    return priv->extractor.pf_control( &priv->extractor, req, args );
}",174.0,179.0,1.0,1.0,6.0,6,4,6,4,0,2,1,1,0,0,,0,2,6,3,3,int
1300,74416,se_InitStream,1,se_InitStream,"int se_InitStream (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"static int
se_InitStream( struct stream_extractor_private* priv, stream_t* s )
{
    if( priv->extractor.pf_read ) s->pf_read = se_StreamRead;
    else                          s->pf_block = se_StreamBlock;

    s->pf_seek = se_StreamSeek;
    s->pf_control = se_StreamControl;
    s->psz_url = StreamExtractorCreateMRL( priv->extractor.source->psz_url,
                                           priv->extractor.identifier );
    if( unlikely( !s->psz_url ) )
        return VLC_ENOMEM;

    return VLC_SUCCESS;
}",203.0,217.0,1.0,1.0,15.0,17,4,10,4,0,4,3,3,1,1,,0,4,4,2,2,int
1301,74479,se_CleanStream,1,se_CleanStream,void se_CleanStream (stream_extractor_private*),input\stream_extractor.c,"static void
se_CleanStream( struct stream_extractor_private* priv )
{
    free( (char*)priv->extractor.identifier );
}",219.0,223.0,1.0,1.0,5.0,3,3,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
1302,74492,se_InitDirectory,1,se_InitDirectory,"int se_InitDirectory (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"static int
se_InitDirectory( struct stream_extractor_private* priv, stream_t* s )
{
    stream_directory_t* directory = &priv->directory;

    s->pf_readdir = se_ReadDir;
    s->pf_control = se_DirControl;
    s->psz_url = strdup( directory->source->psz_url );

    if( unlikely( !s->psz_url ) )
        return VLC_EGENERIC;

    return VLC_SUCCESS;
}",225.0,238.0,1.0,1.0,14.0,13,4,9,5,0,1,2,2,0,0,,0,1,4,2,2,int
1303,74536,se_AttachWrapper,1,se_AttachWrapper,"int se_AttachWrapper (stream_extractor_private*,stream_t*)",input\stream_extractor.c,"static int
se_AttachWrapper( struct stream_extractor_private* priv, stream_t* source )
{
    stream_t* s = vlc_stream_CommonNew( source->obj.parent, se_StreamDelete );

    if( unlikely( !s ) )
        return VLC_ENOMEM;

    if( priv->pf_init( priv, s ) )
    {
        stream_CommonDelete( s );
        return VLC_EGENERIC;
    }

    priv->wrapper = s;
    priv->wrapper->p_input = source->p_input;
    priv->wrapper->p_sys = priv;

    priv->source = source;

    if( priv->wrapper->pf_read )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_read"" );
    else if( priv->wrapper->pf_block )
        priv->wrapper = stream_FilterChainNew( priv->wrapper, ""cache_block"" );

    return VLC_SUCCESS;
}",255.0,281.0,1.0,1.0,27.0,21,4,21,6,1,11,4,4,2,4,,0,10,4,2,2,int
1304,74633,StreamExtractorAttach,1,StreamExtractorAttach,"int StreamExtractorAttach (stream_t**,char*,char*)",input\stream_extractor.c,"static int
StreamExtractorAttach( stream_t** source, char const* identifier,
    char const* module_name )
{
    const bool extractor = identifier != NULL;
    char const* capability = extractor ? ""stream_extractor""
                                       : ""stream_directory"";

    struct stream_extractor_private* priv = vlc_custom_create(
        (*source)->obj.parent, sizeof( *priv ), capability );

    if( unlikely( !priv ) )
        return VLC_ENOMEM;

    if( extractor )
    {
        priv->object = VLC_OBJECT( &priv->extractor );

        priv->pf_init = se_InitStream;
        priv->pf_clean = se_CleanStream;

        priv->extractor.source = *source;
        priv->extractor.identifier = strdup( identifier );

        if( unlikely( !priv->extractor.identifier ) )
            goto error;
    }
    else
    {
        priv->object = VLC_OBJECT( &priv->directory );

        priv->pf_init = se_InitDirectory;
        priv->pf_clean = NULL;

        priv->directory.source = *source;
 ...",283.0,331.0,1.0,1.0,49.0,39,10,34,11,2,13,7,6,3,4,,0,12,6,3,3,int
1305,74787,vlc_stream_directory_Attach,1,vlc_stream_directory_Attach,"int vlc_stream_directory_Attach (stream_t**,char*)",input\stream_extractor.c,"int
vlc_stream_directory_Attach( stream_t** source, char const* module_name )
{
    return StreamExtractorAttach( source, NULL, module_name );
}",333.0,337.0,1.0,1.0,5.0,0,0,3,3,1,1,1,1,0,1,,0,0,4,2,2,int
1306,74798,vlc_stream_extractor_Attach,1,vlc_stream_extractor_Attach,"int vlc_stream_extractor_Attach (stream_t**,char*,char*)",input\stream_extractor.c,"int
vlc_stream_extractor_Attach( stream_t** source, char const* identifier,
                             char const* module_name )
{
    return StreamExtractorAttach( source, identifier, module_name );
}",339.0,344.0,1.0,1.0,6.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
1307,74884,vlc_stream_extractor_CreateMRL,1,vlc_stream_extractor_CreateMRL,"char* vlc_stream_extractor_CreateMRL (stream_directory_t*,char*)",input\stream_extractor.c,"char*
vlc_stream_extractor_CreateMRL( stream_directory_t* directory,
                                char const* subentry )
{
    return StreamExtractorCreateMRL( directory->source->psz_url, subentry );
}",375.0,380.0,1.0,1.0,6.0,2,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,char*
1308,74924,vlc_stream_fifo_Destroy,1,vlc_stream_fifo_Destroy,void vlc_stream_fifo_Destroy (stream_t*),input\stream_fifo.c,"static void vlc_stream_fifo_Destroy(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;
    bool closed;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Unlock(fifo);

    block_ChainRelease(block);

    if (closed)
    {   /* Destroy shared state if write end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }
}",42.0,62.0,1.0,1.0,21.0,9,2,16,6,0,7,2,2,0,4,,0,4,2,1,1,void
1309,74970,vlc_stream_fifo_Block,1,vlc_stream_fifo_Block,"block_t vlc_stream_fifo_Block (stream_t*,bool*)",input\stream_fifo.c,"static block_t *vlc_stream_fifo_Block(stream_t *s, bool *restrict eof)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    block_t *block;

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        if (sys->eof)
        {
            *eof = true;
            break;
        }
        vlc_fifo_Wait(fifo);
    }

    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    return block;
}",64.0,84.0,1.0,1.0,21.0,8,3,14,6,0,6,4,4,1,4,,0,3,4,2,2,block_t
1310,75047,vlc_stream_fifo_New,1,vlc_stream_fifo_New,stream_t vlc_stream_fifo_New (vlc_object_t*),input\stream_fifo.c,"stream_t *vlc_stream_fifo_New(vlc_object_t *parent)
{
    stream_sys_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->fifo = block_FifoNew();
    if (unlikely(sys->fifo == NULL))
    {
        free(sys);
        return NULL;
    }

    sys->eof = false;

    stream_t *s = vlc_stream_CommonNew(parent, vlc_stream_fifo_Destroy);
    if (unlikely(s == NULL))
    {
        block_FifoRelease(sys->fifo);
        free(sys);
        return NULL;
    }

    s->pf_block = vlc_stream_fifo_Block;
    s->pf_seek = NULL;
    s->pf_control = vlc_stream_fifo_Control;
    s->p_sys = sys;
    return vlc_object_hold(s);
}",109.0,137.0,1.0,1.0,29.0,21,5,26,5,1,8,4,4,1,4,,0,6,2,1,1,stream_t
1311,75132,vlc_stream_fifo_Queue,1,vlc_stream_fifo_Queue,"int vlc_stream_fifo_Queue (stream_t*,block_t*)",input\stream_fifo.c,"int vlc_stream_fifo_Queue(stream_t *s, block_t *block)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;

    vlc_fifo_Lock(fifo);
    if (likely(!sys->eof))
    {
        vlc_fifo_QueueUnlocked(fifo, block);
        block = NULL;
    }
    vlc_fifo_Unlock(fifo);

    if (unlikely(block != NULL))
    {
        block_Release(block);
        errno = EPIPE;
        return -1;
    }
    return 0;
}",139.0,159.0,1.0,1.0,21.0,10,5,16,7,2,5,3,3,1,3,,0,2,4,2,2,int
1312,75183,vlc_stream_fifo_Write,1,vlc_stream_fifo_Write,"ssize_t vlc_stream_fifo_Write (stream_t*,void*,size_t)",input\stream_fifo.c,"ssize_t vlc_stream_fifo_Write(stream_t *s, const void *buf, size_t len)
{
    block_t *block = block_Alloc(len);
    if (unlikely(block == NULL))
        return -1;

    memcpy(block->p_buffer, buf, len);
    return vlc_stream_fifo_Queue(s, block) ? -1 : (ssize_t)len;
}",161.0,169.0,1.0,1.0,9.0,7,6,10,5,0,2,2,2,0,2,,0,1,6,3,3,ssize_t
1313,75220,vlc_stream_fifo_Close,1,vlc_stream_fifo_Close,void vlc_stream_fifo_Close (stream_t*),input\stream_fifo.c,"void vlc_stream_fifo_Close(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;
    vlc_fifo_t *fifo = sys->fifo;
    bool closed;

    vlc_fifo_Lock(fifo);
    closed = sys->eof;
    sys->eof = true;
    vlc_fifo_Signal(fifo);
    vlc_fifo_Unlock(fifo);

    if (closed)
    {   /* Destroy shared state if read end is already closed */
        block_FifoRelease(fifo);
        free(sys);
    }

    vlc_object_release(s);
}",171.0,190.0,1.0,1.0,20.0,8,2,15,5,2,8,2,2,0,5,,0,3,2,1,1,void
1314,75287,vlc_stream_FilterNew,1,vlc_stream_FilterNew,"stream_t vlc_stream_FilterNew (stream_t*,char*)",input\stream_filter.c,"stream_t *vlc_stream_FilterNew( stream_t *p_source,
                                const char *psz_stream_filter )
{
    stream_t *s;
    assert( p_source != NULL );

    s = vlc_stream_CommonNew( p_source->obj.parent, StreamDelete );
    if( s == NULL )
        return NULL;

    s->p_input = p_source->p_input;

    if( p_source->psz_url != NULL )
    {
        s->psz_url = strdup( p_source->psz_url );
        if( unlikely(s->psz_url == NULL) )
            goto error;
    }
    s->p_source = p_source;

    /* */
    s->p_module = module_need( s, ""stream_filter"", psz_stream_filter, true );
    if( s->p_module == NULL )
        goto error;

    return s;
error:
    stream_CommonDelete( s );
    return NULL;
}",39.0,68.0,1.0,1.0,30.0,21,5,27,6,0,3,7,6,0,3,,0,2,4,2,2,stream_t
1315,75498,vlc_stream_FilterDefaultReadDir,1,vlc_stream_FilterDefaultReadDir,"int vlc_stream_FilterDefaultReadDir (stream_t*,input_item_node_t*)",input\stream_filter.c,"int vlc_stream_FilterDefaultReadDir( stream_t *s, input_item_node_t *p_node )
{
    assert( s->p_source != NULL );
    return vlc_stream_ReadDir( s->p_source, p_node );
}",118.0,122.0,1.0,1.0,5.0,3,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
1316,75549,stream_MemoryPreserveDelete,1,stream_MemoryPreserveDelete,void stream_MemoryPreserveDelete (stream_t*),input\stream_memory.c,"static void stream_MemoryPreserveDelete(stream_t *s)
{
    free(s->p_sys);
}",41.0,44.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
1317,75558,stream_MemoryDelete,1,stream_MemoryDelete,void stream_MemoryDelete (stream_t*),input\stream_memory.c,"static void stream_MemoryDelete(stream_t *s)
{
    stream_sys_t *sys = s->p_sys;

    free(sys->p_buffer);
    stream_MemoryPreserveDelete(s);
}",46.0,52.0,1.0,1.0,7.0,3,2,4,2,0,2,1,1,0,1,,0,1,2,1,1,void
1318,75575,vlc_stream_MemoryNew,1,,"stream_t (vlc_object_t*,uint8_t*,size_t,bool)",input\stream_memory.c,"stream_t *(vlc_stream_MemoryNew)(vlc_object_t *p_this, uint8_t *p_buffer,
                                 size_t i_size, bool preserve)
{
    stream_t *s = vlc_stream_CommonNew( p_this,
                                        preserve ? stream_MemoryPreserveDelete
                                                 : stream_MemoryDelete );
    stream_sys_t *p_sys;

    if( !s )
        return NULL;

    s->p_sys = p_sys = malloc( sizeof( stream_sys_t ) );
    if( !s->p_sys )
    {
        stream_CommonDelete( s );
        return NULL;
    }
    p_sys->i_pos = 0;
    p_sys->i_size = i_size;
    p_sys->p_buffer = p_buffer;

    s->pf_read    = Read;
    s->pf_seek    = Seek;
    s->pf_control = Control;

    return s;
}",54.0,80.0,1.0,1.0,27.0,21,5,23,11,0,5,3,3,0,2,,0,4,8,4,4,stream_t
1319,79350,InputEventPreparse,1,InputEventPreparse,"int InputEventPreparse (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",input\vlm.c,"static int InputEventPreparse( vlc_object_t *p_this, char const *psz_cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    preparse_data_t *p_pre = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD ||
        ( p_pre->b_mux && newval.i_int == INPUT_EVENT_ITEM_META ) )
        vlc_sem_post( p_pre->p_sem );

    return VLC_SUCCESS;
}",67.0,78.0,1.0,1.0,12.0,9,6,12,9,0,3,2,2,1,1,,0,2,10,5,5,int
1320,79392,InputEvent,1,InputEvent,"int InputEvent (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\thread.c,"static int InputEvent( vlc_object_t *p_this, char const *psz_cmd,
                       vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    VLC_UNUSED(p_this); VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval);
    playlist_t *p_playlist = p_data;

    if( newval.i_int == INPUT_EVENT_DEAD )
    {
        playlist_private_t *sys = pl_priv(p_playlist);

        PL_LOCK;
        sys->request.input_dead = true;
        vlc_cond_signal( &sys->signal );
        PL_UNLOCK;
    }
    return VLC_SUCCESS;
}",94.0,110.0,1.0,34.0,17.0,37,8,38,16,0,15,6,9,2,5,,0,11,10,5,5,int
1321,79547,vlm_New,1,vlm_New,vlm_t vlm_New (vlc_object_t*),missing.c,"vlm_t *vlm_New (vlc_object_t *obj)
{
     msg_Err (obj, ""VLM not compiled-in!"");
     return NULL;
}",244.0,248.0,1.0,1.0,5.0,72,12,75,13,0,49,8,12,4,22,,0,31,2,1,1,vlm_t
1322,79804,vlm_Delete,1,vlm_Delete,void vlm_Delete (vlm_t*),missing.c,"void vlm_Delete (vlm_t *vlm)
{
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",203.0,207.0,1.0,1.0,5.0,44,7,35,5,0,43,4,4,2,20,,0,23,2,1,1,void
1323,79953,vlm_ExecuteCommand,1,vlm_ExecuteCommand,"int vlm_ExecuteCommand (vlm_t*,char*,vlm_message_t**)",missing.c,"int vlm_ExecuteCommand (vlm_t *vlm, const char *cmd, vlm_message_t **pm)
{
    VLC_UNUSED (vlm);
    VLC_UNUSED (cmd);
    VLC_UNUSED (pm);
    vlc_assert_unreachable ();
}",209.0,215.0,1.0,1.0,7.0,5,3,7,4,1,5,1,1,0,3,,0,3,6,3,3,int
1324,80769,vlm_ControlMediaGetById,1,vlm_ControlMediaGetById,"vlm_media_sys_t vlm_ControlMediaGetById (vlm_t*,int64_t)",input\vlm.c,"static vlm_media_sys_t *vlm_ControlMediaGetById( vlm_t *p_vlm, int64_t id )
{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == id )
            return p_vlm->media[i];
    }
    return NULL;
}",554.0,562.0,1.0,1.0,9.0,10,6,9,4,10,3,3,4,2,0,,0,3,4,2,2,vlm_media_sys_t
1325,80810,vlm_ControlMediaGetByName,1,vlm_ControlMediaGetByName,"vlm_media_sys_t vlm_ControlMediaGetByName (vlm_t*,char*)",input\vlm.c,"static vlm_media_sys_t *vlm_ControlMediaGetByName( vlm_t *p_vlm, const char *psz_name )
{
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, psz_name ) )
            return p_vlm->media[i];
    }
    return NULL;
}",563.0,571.0,1.0,1.0,9.0,10,6,9,4,2,3,3,4,2,0,,0,3,4,2,2,vlm_media_sys_t
1326,80852,vlm_MediaDescriptionCheck,1,vlm_MediaDescriptionCheck,"int vlm_MediaDescriptionCheck (vlm_t*,vlm_media_t*)",input\vlm.c,"static int vlm_MediaDescriptionCheck( vlm_t *p_vlm, vlm_media_t *p_cfg )
{
    if( !p_cfg || !p_cfg->psz_name ||
        !strcmp( p_cfg->psz_name, ""all"" ) || !strcmp( p_cfg->psz_name, ""media"" ) || !strcmp( p_cfg->psz_name, ""schedule"" ) )
        return VLC_EGENERIC;

    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        if( p_vlm->media[i]->cfg.id == p_cfg->id )
            continue;
        if( !strcmp( p_vlm->media[i]->cfg.psz_name, p_cfg->psz_name ) )
            return VLC_EGENERIC;
    }
    return VLC_SUCCESS;
}",572.0,586.0,1.0,1.0,15.0,28,8,17,5,2,3,6,7,3,0,,0,3,4,2,2,int
1327,80940,vlm_OnMediaUpdate,1,vlm_OnMediaUpdate,"int vlm_OnMediaUpdate (vlm_t*,vlm_media_sys_t*)",input\vlm.c,"static int vlm_OnMediaUpdate( vlm_t *p_vlm, vlm_media_sys_t *p_media )
{
    vlm_media_t *p_cfg = &p_media->cfg;
    /* Check if we need to create/delete a vod media */
    if( p_cfg->b_vod && p_vlm->p_vod )
    {
        if( !p_cfg->b_enabled && p_media->vod.p_media )
        {
            p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );
            p_media->vod.p_media = NULL;
        }
        else if( p_cfg->b_enabled && !p_media->vod.p_media && p_cfg->i_input )
        {
            /* Pre-parse the input */
            input_thread_t *p_input;
            char *psz_output;
            char *psz_header;
            char *psz_dup;

            input_item_Release( p_media->vod.p_item );

            if( strstr( p_cfg->ppsz_input[0], ""://"" ) == NULL )
            {
                char *psz_uri = vlc_path2uri( p_cfg->ppsz_input[0], NULL );
                p_media->vod.p_item = input_item_New( psz_uri,
                                                      p_cfg->ps...",590.0,723.0,1.0,1.0,134.0,21,6,15,5,3,5,3,4,1,1,,0,4,4,2,2,int
1328,81431,vlm_ControlMediaChange,1,vlm_ControlMediaChange,"int vlm_ControlMediaChange (vlm_t*,vlm_media_t*)",input\vlm.c,"static int vlm_ControlMediaChange( vlm_t *p_vlm, vlm_media_t *p_cfg )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, p_cfg->id );

    /* */
    if( !p_media || vlm_MediaDescriptionCheck( p_vlm, p_cfg ) )
        return VLC_EGENERIC;
    if( ( p_media->cfg.b_vod && !p_cfg->b_vod ) || ( !p_media->cfg.b_vod && p_cfg->b_vod ) )
        return VLC_EGENERIC;

    if( 0 )
    {
        /* TODO check what are the changes being done (stop instance if needed) */
    }

    vlm_media_Clean( &p_media->cfg );
    vlm_media_Copy( &p_media->cfg, p_cfg );

    return vlm_OnMediaUpdate( p_vlm, p_media );
}",724.0,743.0,1.0,1.0,20.0,19,7,17,4,1,7,4,4,3,3,,0,6,4,2,2,int
1329,81498,vlm_ControlMediaAdd,1,vlm_ControlMediaAdd,"int vlm_ControlMediaAdd (vlm_t*,vlm_media_t*,int64_t*)",input\vlm.c,"static int vlm_ControlMediaAdd( vlm_t *p_vlm, vlm_media_t *p_cfg, int64_t *p_id )
{
    vlm_media_sys_t *p_media;

    if( vlm_MediaDescriptionCheck( p_vlm, p_cfg ) || vlm_ControlMediaGetByName( p_vlm, p_cfg->psz_name ) )
    {
        msg_Err( p_vlm, ""invalid media description"" );
        return VLC_EGENERIC;
    }
    /* Check if we need to load the VOD server */
    if( p_cfg->b_vod && !p_vlm->p_vod )
    {
        msg_Info( p_vlm, ""VoD support will be removed from the VLM in the next major version of VLC."" );

        p_vlm->p_vod = vlc_custom_create( VLC_OBJECT(p_vlm), sizeof( vod_t ),
                                          ""vod server"" );
        p_vlm->p_vod->p_module = module_need( p_vlm->p_vod, ""vod server"", ""$vod-server"", false );
        if( !p_vlm->p_vod->p_module )
        {
            msg_Err( p_vlm, ""cannot find vod server"" );
            vlc_object_release( p_vlm->p_vod );
            p_vlm->p_vod = NULL;
            return VLC_EGENERIC;
        }

        p_vlm-...",745.0,796.0,1.0,23.0,52.0,53,10,51,10,1,26,6,7,4,7,,0,23,6,3,3,int
1330,81685,vlm_ControlMediaDel,1,vlm_ControlMediaDel,"int vlm_ControlMediaDel (vlm_t*,int64_t)",input\vlm.c,"static int vlm_ControlMediaDel( vlm_t *p_vlm, int64_t id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlInternal( p_vlm, VLM_STOP_MEDIA_INSTANCE, id, p_media->instance[0]->psz_name );

    if( p_media->cfg.b_vod )
    {
        p_media->cfg.b_enabled = false;
        vlm_OnMediaUpdate( p_vlm, p_media );
    }

    /* */
    vlm_SendEventMediaRemoved( p_vlm, id, p_media->cfg.psz_name );

    vlm_media_Clean( &p_media->cfg );

    input_item_Release( p_media->vod.p_item );

    if( p_media->vod.p_media )
        p_vlm->p_vod->pf_media_del( p_vlm->p_vod, p_media->vod.p_media );

    TAB_REMOVE( p_vlm->i_media, p_vlm->media, p_media );
    free( p_media );

    return VLC_SUCCESS;
}",798.0,828.0,1.0,1.0,31.0,24,6,25,6,1,13,5,5,2,4,,0,10,4,2,2,int
1331,81789,vlm_ControlMediaGets,1,vlm_ControlMediaGets,"int vlm_ControlMediaGets (vlm_t*,vlm_media_t***,int*)",input\vlm.c,"static int vlm_ControlMediaGets( vlm_t *p_vlm, vlm_media_t ***ppp_dsc, int *pi_dsc )
{
    vlm_media_t **pp_dsc;
    int                     i_dsc;

    TAB_INIT( i_dsc, pp_dsc );
    for( int i = 0; i < p_vlm->i_media; i++ )
    {
        vlm_media_t *p_dsc = vlm_media_Duplicate( &p_vlm->media[i]->cfg );
        TAB_APPEND( i_dsc, pp_dsc, p_dsc );
    }

    *ppp_dsc = pp_dsc;
    *pi_dsc = i_dsc;

    return VLC_SUCCESS;
}",830.0,846.0,1.0,1.0,17.0,12,6,16,8,1,2,2,2,1,0,,0,2,6,3,3,int
1332,81841,vlm_ControlMediaClear,1,vlm_ControlMediaClear,int vlm_ControlMediaClear (vlm_t*),input\vlm.c,"static int vlm_ControlMediaClear( vlm_t *p_vlm )
{
    while( p_vlm->i_media > 0 )
        vlm_ControlMediaDel( p_vlm, p_vlm->media[0]->cfg.id );

    return VLC_SUCCESS;
}",847.0,853.0,1.0,1.0,7.0,2,2,2,2,1,1,2,2,1,0,,0,1,2,1,1,int
1333,81865,vlm_ControlMediaGet,1,vlm_ControlMediaGet,"int vlm_ControlMediaGet (vlm_t*,int64_t,vlm_media_t**)",input\vlm.c,"static int vlm_ControlMediaGet( vlm_t *p_vlm, int64_t id, vlm_media_t **pp_dsc )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    if( !p_media )
        return VLC_EGENERIC;

    *pp_dsc = vlm_media_Duplicate( &p_media->cfg );
    return VLC_SUCCESS;
}",854.0,862.0,1.0,1.0,9.0,6,5,8,6,1,2,2,2,0,1,,0,2,6,3,3,int
1334,81894,vlm_ControlMediaGetId,1,vlm_ControlMediaGetId,"int vlm_ControlMediaGetId (vlm_t*,char*,int64_t*)",input\vlm.c,"static int vlm_ControlMediaGetId( vlm_t *p_vlm, const char *psz_name, int64_t *p_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetByName( p_vlm, psz_name );
    if( !p_media )
        return VLC_EGENERIC;

    *p_id = p_media->cfg.id;
    return VLC_SUCCESS;
}",863.0,871.0,1.0,1.0,9.0,6,5,8,6,1,2,2,2,0,1,,0,2,6,3,3,int
1335,81923,vlm_ControlMediaInstanceGetByName,1,vlm_ControlMediaInstanceGetByName,"vlm_media_instance_sys_t vlm_ControlMediaInstanceGetByName (vlm_media_sys_t*,char*)",input\vlm.c,"static vlm_media_instance_sys_t *vlm_ControlMediaInstanceGetByName( vlm_media_sys_t *p_media, const char *psz_id )
{
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        const char *psz = p_media->instance[i]->psz_name;
        if( ( psz == NULL && psz_id == NULL ) ||
            ( psz && psz_id && !strcmp( psz, psz_id ) ) )
            return p_media->instance[i];
    }
    return NULL;
}",873.0,883.0,1.0,1.0,11.0,16,8,17,5,5,3,3,4,1,0,,0,3,4,2,2,vlm_media_instance_sys_t
1336,81979,vlm_MediaInstanceNew,1,vlm_MediaInstanceNew,"vlm_media_instance_sys_t vlm_MediaInstanceNew (vlm_t*,char*)",input\vlm.c,"static vlm_media_instance_sys_t *vlm_MediaInstanceNew( vlm_t *p_vlm, const char *psz_name )
{
    vlm_media_instance_sys_t *p_instance = calloc( 1, sizeof(vlm_media_instance_sys_t) );
    if( !p_instance )
        return NULL;

    p_instance->psz_name = NULL;
    if( psz_name )
        p_instance->psz_name = strdup( psz_name );

    p_instance->p_item = input_item_New( NULL, NULL );

    p_instance->i_index = 0;
    p_instance->b_sout_keep = false;
    p_instance->p_parent = vlc_object_create( p_vlm, sizeof (vlc_object_t) );
    p_instance->p_input = NULL;
    p_instance->p_input_resource = input_resource_New( p_instance->p_parent );

    return p_instance;
}",884.0,903.0,1.0,1.0,20.0,21,4,23,7,1,11,3,3,0,2,,0,11,4,2,2,vlm_media_instance_sys_t
1337,82052,vlm_MediaInstanceDelete,1,vlm_MediaInstanceDelete,"void vlm_MediaInstanceDelete (vlm_t*,int64_t,vlm_media_instance_sys_t*,vlm_media_sys_t*)",input\vlm.c,"static void vlm_MediaInstanceDelete( vlm_t *p_vlm, int64_t id, vlm_media_instance_sys_t *p_instance, vlm_media_sys_t *p_media )
{
    input_thread_t *p_input = p_instance->p_input;
    if( p_input )
    {
        input_Stop( p_input );
        input_Close( p_input );

        vlm_SendEventMediaInstanceStopped( p_vlm, id, p_media->cfg.psz_name );
    }
    input_resource_Terminate( p_instance->p_input_resource );
    input_resource_Release( p_instance->p_input_resource );
    vlc_object_release( p_instance->p_parent );

    TAB_REMOVE( p_media->i_instance, p_media->instance, p_instance );
    input_item_Release( p_instance->p_item );
    free( p_instance->psz_name );
    free( p_instance );
}",904.0,922.0,1.0,1.0,19.0,11,3,17,5,2,16,2,2,0,7,,0,9,8,4,4,void
1338,82111,vlm_ControlMediaInstanceStart,1,vlm_ControlMediaInstanceStart,"int vlm_ControlMediaInstanceStart (vlm_t*,int64_t,char*,int,char*)",input\vlm.c,"static int vlm_ControlMediaInstanceStart( vlm_t *p_vlm, int64_t id, const char *psz_id, int i_input_index, const char *psz_vod_output )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    char *psz_log;

    if( !p_media || !p_media->cfg.b_enabled || p_media->cfg.i_input <= 0 )
        return VLC_EGENERIC;

    /* TODO support multiple input for VOD with sout-keep ? */

    if( ( p_media->cfg.b_vod && !psz_vod_output ) || ( !p_media->cfg.b_vod && psz_vod_output ) )
        return VLC_EGENERIC;

    if( i_input_index < 0 || i_input_index >= p_media->cfg.i_input )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
    {
        vlm_media_t *p_cfg = &p_media->cfg;

        p_instance = vlm_MediaInstanceNew( p_vlm, psz_id );
        if( !p_instance )
            return VLC_ENOMEM;

        if ( p_cfg->b_vod )
        {
            var_Create( p_instanc...",925.0,1062.0,1.0,1.0,138.0,129,19,133,28,2,67,21,39,15,23,,0,51,10,5,5,int
1339,82630,vlm_ControlMediaInstanceStop,1,vlm_ControlMediaInstanceStop,"int vlm_ControlMediaInstanceStop (vlm_t*,int64_t,char*)",input\vlm.c,"static int vlm_ControlMediaInstanceStop( vlm_t *p_vlm, int64_t id, const char *psz_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance )
        return VLC_EGENERIC;

    vlm_MediaInstanceDelete( p_vlm, id, p_instance, p_media );

    return VLC_SUCCESS;
}",1064.0,1079.0,1.0,1.0,16.0,4,2,15,7,1,3,3,3,0,3,,0,2,6,3,3,int
1340,82668,vlm_ControlMediaInstancePause,1,vlm_ControlMediaInstancePause,"int vlm_ControlMediaInstancePause (vlm_t*,int64_t,char*)",input\vlm.c,"static int vlm_ControlMediaInstancePause( vlm_t *p_vlm, int64_t id, const char *psz_id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;
    int i_state;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    /* Toggle pause state */
    i_state = var_GetInteger( p_instance->p_input, ""state"" );
    if( i_state == PAUSE_S && !p_media->cfg.b_vod )
        var_SetInteger( p_instance->p_input, ""state"", PLAYING_S );
    else if( i_state == PLAYING_S )
        var_SetInteger( p_instance->p_input, ""state"", PAUSE_S );
    return VLC_SUCCESS;
}",1080.0,1100.0,1.0,1.0,21.0,15,7,19,10,1,6,4,4,2,2,,0,6,6,3,3,int
1341,82745,vlm_ControlMediaInstanceGetTimePosition,1,vlm_ControlMediaInstanceGetTimePosition,"int vlm_ControlMediaInstanceGetTimePosition (vlm_t*,int64_t,char*,int64_t*,double*)",input\vlm.c,"static int vlm_ControlMediaInstanceGetTimePosition( vlm_t *p_vlm, int64_t id, const char *psz_id, int64_t *pi_time, double *pd_position )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( pi_time )
        *pi_time = var_GetInteger( p_instance->p_input, ""time"" );
    if( pd_position )
        *pd_position = var_GetFloat( p_instance->p_input, ""position"" );
    return VLC_SUCCESS;
}",1101.0,1118.0,1.0,1.0,18.0,13,5,18,9,2,5,5,5,1,2,,0,5,10,5,5,int
1342,82807,vlm_ControlMediaInstanceSetTimePosition,1,vlm_ControlMediaInstanceSetTimePosition,"int vlm_ControlMediaInstanceSetTimePosition (vlm_t*,int64_t,char*,int64_t,double)",input\vlm.c,"static int vlm_ControlMediaInstanceSetTimePosition( vlm_t *p_vlm, int64_t id, const char *psz_id, int64_t i_time, double d_position )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_sys_t *p_instance;

    if( !p_media )
        return VLC_EGENERIC;

    p_instance = vlm_ControlMediaInstanceGetByName( p_media, psz_id );
    if( !p_instance || !p_instance->p_input )
        return VLC_EGENERIC;

    if( i_time >= 0 )
        return var_SetInteger( p_instance->p_input, ""time"", i_time );
    else if( d_position >= 0 && d_position <= 100 )
        return var_SetFloat( p_instance->p_input, ""position"", d_position );
    return VLC_EGENERIC;
}",1119.0,1136.0,1.0,1.0,18.0,9,5,15,7,2,4,4,4,1,2,,0,4,10,5,5,int
1343,82877,vlm_ControlMediaInstanceGets,1,vlm_ControlMediaInstanceGets,"int vlm_ControlMediaInstanceGets (vlm_t*,int64_t,vlm_media_instance_t***,int*)",input\vlm.c,"static int vlm_ControlMediaInstanceGets( vlm_t *p_vlm, int64_t id, vlm_media_instance_t ***ppp_idsc, int *pi_instance )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );
    vlm_media_instance_t **pp_idsc;
    int                              i_idsc;

    if( !p_media )
        return VLC_EGENERIC;

    TAB_INIT( i_idsc, pp_idsc );
    for( int i = 0; i < p_media->i_instance; i++ )
    {
        vlm_media_instance_sys_t *p_instance = p_media->instance[i];
        vlm_media_instance_t *p_idsc = vlm_media_instance_New();

        if( p_instance->psz_name )
            p_idsc->psz_name = strdup( p_instance->psz_name );
        if( p_instance->p_input )
        {
            p_idsc->i_time = var_GetInteger( p_instance->p_input, ""time"" );
            p_idsc->i_length = var_GetInteger( p_instance->p_input, ""length"" );
            p_idsc->d_position = var_GetFloat( p_instance->p_input, ""position"" );
            if( var_GetInteger( p_instance->p_input, ""state"" ) == PAUS...",1138.0,1171.0,1.0,1.0,34.0,35,8,39,15,1,11,6,10,4,1,,0,11,8,4,4,int
1344,83012,vlm_ControlMediaInstanceClear,1,vlm_ControlMediaInstanceClear,"int vlm_ControlMediaInstanceClear (vlm_t*,int64_t)",input\vlm.c,"static int vlm_ControlMediaInstanceClear( vlm_t *p_vlm, int64_t id )
{
    vlm_media_sys_t *p_media = vlm_ControlMediaGetById( p_vlm, id );

    if( !p_media )
        return VLC_EGENERIC;

    while( p_media->i_instance > 0 )
        vlm_ControlMediaInstanceStop( p_vlm, id, p_media->instance[0]->psz_name );

    return VLC_SUCCESS;
}",1173.0,1184.0,1.0,1.0,12.0,4,4,7,5,1,2,3,3,1,1,,0,2,4,2,2,int
1345,83048,vlm_ControlScheduleClear,1,vlm_ControlScheduleClear,int vlm_ControlScheduleClear (vlm_t*),input\vlm.c,"static int vlm_ControlScheduleClear( vlm_t *p_vlm )
{
    while( p_vlm->i_schedule > 0 )
        vlm_ScheduleDelete( p_vlm, p_vlm->schedule[0] );

    return VLC_SUCCESS;
}",1186.0,1192.0,1.0,1.0,7.0,2,2,2,2,1,1,2,2,1,0,,0,1,2,1,1,int
1346,83068,vlm_vaControlInternal,1,vlm_vaControlInternal,"int vlm_vaControlInternal (vlm_t*,int,va_list)",input\vlm.c,"static int vlm_vaControlInternal( vlm_t *p_vlm, int i_query, va_list args )
{
    vlm_media_t *p_dsc;
    vlm_media_t **pp_dsc;
    vlm_media_t ***ppp_dsc;
    vlm_media_instance_t ***ppp_idsc;
    const char *psz_id;
    const char *psz_vod;
    int64_t *p_id;
    int64_t id;
    int i_int;
    int *pi_int;

    int64_t *pi_i64;
    int64_t i_i64;
    double *pd_double;
    double d_double;

    switch( i_query )
    {
    /* Media control */
    case VLM_GET_MEDIAS:
        ppp_dsc = (vlm_media_t ***)va_arg( args, vlm_media_t *** );
        pi_int = (int *)va_arg( args, int * );
        return vlm_ControlMediaGets( p_vlm, ppp_dsc, pi_int );

    case VLM_CLEAR_MEDIAS:
        return vlm_ControlMediaClear( p_vlm );

    case VLM_CHANGE_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        return vlm_ControlMediaChange( p_vlm, p_dsc );

    case VLM_ADD_MEDIA:
        p_dsc = (vlm_media_t*)va_arg( args, vlm_media_t * );
        p_id = (int64_t*)va_arg( args, in...",1194.0,1313.0,1.0,1.0,120.0,29,4,120,38,2,18,3,4,0,18,,0,0,6,3,3,int
1347,83353,vlm_ControlInternal,1,vlm_ControlInternal,"int vlm_ControlInternal (vlm_t*,int...)",input\vlm.c,"int vlm_ControlInternal( vlm_t *p_vlm, int i_query, ... )
{
    va_list args;
    int     i_result;

    va_start( args, i_query );
    i_result = vlm_vaControlInternal( p_vlm, i_query, args );
    va_end( args );

    return i_result;
}",1315.0,1325.0,1.0,1.0,11.0,1,1,8,4,2,1,1,1,0,1,,0,1,4,2,2,int
1348,83374,vlm_Control,1,vlm_Control,"int vlm_Control (vlm_t*,int...)",missing.c,"int vlm_Control (vlm_t *vlm, int query, ...)
{
    VLC_UNUSED (query);
    VLC_UNUSED (vlm);
    vlc_assert_unreachable ();
}",196.0,201.0,1.0,1.0,6.0,5,3,10,4,0,5,1,1,0,3,,0,3,4,2,2,int
1349,83430,TriggerInstanceState,1,TriggerInstanceState,"void TriggerInstanceState (vlm_t*,int,int64_t,char*,char*,input_state_e)",input\vlm_event.c,"static void TriggerInstanceState( vlm_t *p_vlm, int i_type, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e input_state )
{
    vlm_event_t event;

    event.i_type = i_type;
    event.id = id;
    event.psz_name = psz_name;
    event.input_state = input_state;
    event.psz_instance_name = psz_instance_name;
    var_SetAddress( p_vlm, ""intf-event"", &event );
}",86.0,96.0,1.0,1.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,void
1350,83440,vlm_SendEventMediaAdded,1,vlm_SendEventMediaAdded,"void vlm_SendEventMediaAdded (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaAdded( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_ADDED, id, psz_name );
}",44.0,47.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
1351,83452,vlm_SendEventMediaRemoved,1,vlm_SendEventMediaRemoved,"void vlm_SendEventMediaRemoved (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaRemoved( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_REMOVED, id, psz_name );
}",48.0,51.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
1352,83464,vlm_SendEventMediaChanged,1,vlm_SendEventMediaChanged,"void vlm_SendEventMediaChanged (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaChanged( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_CHANGED, id, psz_name );
}",52.0,55.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
1353,83476,vlm_SendEventMediaInstanceStarted,1,vlm_SendEventMediaInstanceStarted,"void vlm_SendEventMediaInstanceStarted (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaInstanceStarted( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STARTED, id, psz_name );
}",57.0,60.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
1354,83488,vlm_SendEventMediaInstanceStopped,1,vlm_SendEventMediaInstanceStopped,"void vlm_SendEventMediaInstanceStopped (vlm_t*,int64_t,char*)",input\vlm_event.c,"void vlm_SendEventMediaInstanceStopped( vlm_t *p_vlm, int64_t id, const char *psz_name )
{
    Trigger( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STOPPED, id, psz_name );
}",61.0,64.0,1.0,1.0,4.0,0,0,4,4,2,1,1,1,0,1,,0,0,6,3,3,void
1355,83500,vlm_SendEventMediaInstanceState,1,vlm_SendEventMediaInstanceState,"void vlm_SendEventMediaInstanceState (vlm_t*,int64_t,char*,char*,input_state_e)",input\vlm_event.c,"void vlm_SendEventMediaInstanceState( vlm_t *p_vlm, int64_t id, const char *psz_name, const char *psz_instance_name, input_state_e state )
{
    TriggerInstanceState( p_vlm, VLM_EVENT_MEDIA_INSTANCE_STATE, id, psz_name, psz_instance_name, state );
}",66.0,69.0,1.0,1.0,4.0,0,0,6,6,1,1,1,1,0,1,,0,0,10,5,5,void
1356,83707,ExecuteCommand,1,ExecuteCommand,"int ExecuteCommand (vlm_t*,char*,vlm_message_t**)",input\vlm_internal.h,"int ExecuteCommand( vlm_t *, const char *, vlm_message_t ** );",119.0,119.0,5.0,61.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
1357,83849,get_dialog_provider,1,get_dialog_provider,"vlc_dialog_provider get_dialog_provider (vlc_object_t*,bool)",interface\dialog.c,"static inline vlc_dialog_provider *
get_dialog_provider(vlc_object_t *p_obj, bool b_check_interact)
{
    if (b_check_interact && p_obj->obj.flags & OBJECT_FLAGS_NOINTERACT)
        return NULL;

    vlc_dialog_provider *p_provider =
        libvlc_priv(p_obj->obj.libvlc)->p_dialog_provider;
    assert(p_provider != NULL);
    return p_provider;
}",122.0,132.0,1.0,1.0,11.0,9,6,9,5,9,1,2,2,0,1,,0,1,4,2,2,vlc_dialog_provider
1358,83885,dialog_id_release,1,dialog_id_release,void dialog_id_release (vlc_dialog_id*),interface\dialog.c,"static void
dialog_id_release(vlc_dialog_id *p_id)
{
    if (p_id->answer.i_type == VLC_DIALOG_LOGIN)
    {
        free(p_id->answer.u.login.psz_username);
        free(p_id->answer.u.login.psz_password);
    }
    free(p_id->psz_progress_text);
    vlc_mutex_destroy(&p_id->lock);
    vlc_cond_destroy(&p_id->wait);
    free(p_id);
}",134.0,146.0,1.0,1.0,13.0,16,4,8,2,1,8,2,2,1,2,,0,6,2,1,1,void
1359,83935,libvlc_InternalDialogInit,1,libvlc_InternalDialogInit,int libvlc_InternalDialogInit (libvlc_int_t*),interface\dialog.c,"int
libvlc_InternalDialogInit(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = malloc(sizeof(*p_provider));
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_mutex_init(&p_provider->lock);
    vlc_array_init(&p_provider->dialog_array);

    memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
    p_provider->p_cbs_data = NULL;

    p_provider->pf_ext_update = NULL;
    p_provider->p_ext_data = NULL;
    libvlc_priv(p_libvlc)->p_dialog_provider = p_provider;

    return VLC_SUCCESS;
}",148.0,167.0,1.0,1.0,20.0,21,7,20,5,1,9,2,2,0,2,,0,7,2,1,1,int
1360,84001,dialog_cancel_locked,1,dialog_cancel_locked,"void dialog_cancel_locked (vlc_dialog_provider*,vlc_dialog_id*)",interface\dialog.c,"static void
dialog_cancel_locked(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id)
{
    vlc_mutex_lock(&p_id->lock);
    if (p_id->b_cancelled || p_id->b_answered)
    {
        vlc_mutex_unlock(&p_id->lock);
        return;
    }
    p_id->b_cancelled = true;
    vlc_mutex_unlock(&p_id->lock);

    p_provider->cbs.pf_cancel(p_provider->p_cbs_data, p_id);
}",169.0,182.0,1.0,1.0,14.0,14,5,10,3,3,11,2,2,2,3,,0,8,4,2,2,void
1361,84047,dialog_add_locked,1,dialog_add_locked,"vlc_dialog_id dialog_add_locked (vlc_dialog_provider*,dialog_type)",interface\dialog.c,"static vlc_dialog_id *
dialog_add_locked(vlc_dialog_provider *p_provider, enum dialog_type i_type)
{
    vlc_dialog_id *p_id = calloc(1, sizeof(*p_id));

    if (p_id == NULL)
        return NULL;

    if(vlc_array_append(&p_provider->dialog_array, p_id))
    {
        free(p_id);
        return NULL;
    }

    vlc_mutex_init(&p_id->lock);
    vlc_cond_init(&p_id->wait);

    p_id->i_type = i_type;
    p_id->i_refcount = 2; /* provider and callbacks */

    return p_id;
}",184.0,205.0,1.0,1.0,22.0,14,6,15,4,3,7,3,3,1,2,,0,5,4,2,2,vlc_dialog_id
1362,84102,dialog_remove_locked,1,dialog_remove_locked,"void dialog_remove_locked (vlc_dialog_provider*,vlc_dialog_id*)",interface\dialog.c,"static void
dialog_remove_locked(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id)
{
    ssize_t i_idx = vlc_array_index_of_item(&p_provider->dialog_array, p_id);
    assert(i_idx >= 0);
    vlc_array_remove(&p_provider->dialog_array, i_idx);

    vlc_mutex_lock(&p_id->lock);
    p_id->i_refcount--;
    if (p_id->i_refcount == 0)
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    else
        vlc_mutex_unlock(&p_id->lock);
}",207.0,223.0,1.0,1.0,17.0,14,6,11,3,2,9,2,2,1,3,,0,6,4,2,2,void
1363,84157,dialog_clear_all_locked,1,dialog_clear_all_locked,void dialog_clear_all_locked (vlc_dialog_provider*),interface\dialog.c,"static void
dialog_clear_all_locked(vlc_dialog_provider *p_provider)
{
    for (size_t i = 0; i < vlc_array_count(&p_provider->dialog_array); ++i)
    {
        vlc_dialog_id *p_id =
            vlc_array_item_at_index(&p_provider->dialog_array, i);
        dialog_cancel_locked(p_provider, p_id);
    }
}",225.0,234.0,1.0,1.0,10.0,7,4,8,3,2,3,2,2,1,1,,0,2,2,1,1,void
1364,84190,libvlc_InternalDialogClean,1,libvlc_InternalDialogClean,void libvlc_InternalDialogClean (libvlc_int_t*),interface\dialog.c,"void
libvlc_InternalDialogClean(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    vlc_dialog_provider *p_provider = libvlc_priv(p_libvlc)->p_dialog_provider;

    if (p_provider == NULL)
        return;
    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_destroy(&p_provider->lock);
    free(p_provider);
    libvlc_priv(p_libvlc)->p_dialog_provider = NULL;
}",236.0,251.0,1.0,1.0,16.0,12,5,13,3,1,9,2,2,0,6,,0,4,2,1,1,void
1365,84237,vlc_dialog_provider_set_callbacks,1,vlc_dialog_provider_set_callbacks,"void vlc_dialog_provider_set_callbacks (vlc_object_t*,vlc_dialog_cbs*,void*)",interface\dialog.c,"void
vlc_dialog_provider_set_callbacks(vlc_object_t *p_obj,
                                  const vlc_dialog_cbs *p_cbs, void *p_data)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_clear_all_locked(p_provider);

    if (p_cbs == NULL)
    {
        memset(&p_provider->cbs, 0, sizeof(p_provider->cbs));
        p_provider->p_cbs_data = NULL;
    }
    else
    {
        p_provider->cbs = *p_cbs;
        p_provider->p_cbs_data = p_data;
    }
    vlc_mutex_unlock(&p_provider->lock);
}",254.0,275.0,1.0,1.0,22.0,13,6,14,5,0,9,2,2,0,4,,0,6,6,3,3,void
1366,84299,dialog_wait_interrupted,1,dialog_wait_interrupted,void dialog_wait_interrupted (void*),interface\dialog.c,"static void
dialog_wait_interrupted(void *p_data)
{
    struct dialog_i11e_context *p_context = p_data;
    vlc_dialog_provider *p_provider = p_context->p_provider;
    vlc_dialog_id *p_id = p_context->p_id;

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);

    vlc_mutex_lock(&p_id->lock);
    vlc_cond_signal(&p_id->wait);
    vlc_mutex_unlock(&p_id->lock);
}",277.0,291.0,1.0,1.0,15.0,15,3,13,4,0,13,1,1,0,6,,0,7,2,1,1,void
1367,84348,dialog_wait,1,dialog_wait,"int dialog_wait (vlc_dialog_provider*,vlc_dialog_id*,dialog_type,dialog_answer*)",interface\dialog.c,"static int
dialog_wait(vlc_dialog_provider *p_provider, vlc_dialog_id *p_id,
            enum dialog_type i_type, struct dialog_answer *p_answer)
{
    struct dialog_i11e_context context = {
        .p_provider = p_provider,
        .p_id = p_id,
    };
    vlc_interrupt_register(dialog_wait_interrupted, &context);

    vlc_mutex_lock(&p_id->lock);
    /* Wait for the dialog to be dismissed, interrupted or answered */
    while (!p_id->b_cancelled && !p_id->b_answered)
        vlc_cond_wait(&p_id->wait, &p_id->lock);

    int i_ret;
    if (p_id->b_cancelled)
        i_ret = 0;
    else if (p_id->answer.i_type != i_type)
        i_ret = VLC_EGENERIC;
    else
    {
        i_ret = 1;
        memcpy(p_answer, &p_id->answer, sizeof(p_id->answer));
        memset(&p_id->answer, 0, sizeof(p_id->answer));
    }

    vlc_mutex_unlock(&p_id->lock);
    vlc_interrupt_unregister();

    vlc_mutex_lock(&p_provider->lock);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_pro...",293.0,327.0,1.0,1.0,35.0,20,6,17,4,2,14,3,3,3,7,,0,7,8,4,4,int
1368,84465,dialog_display_error_va,1,dialog_display_error_va,"int dialog_display_error_va (vlc_dialog_provider*,char*,char*,va_list)",interface\dialog.c,"static int
dialog_display_error_va(vlc_dialog_provider *p_provider, const char *psz_title,
                        const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_error == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    p_provider->cbs.pf_display_error(p_provider->p_cbs_data, psz_title, psz_text);
    free(psz_text);
    vlc_mutex_unlock(&p_provider->lock);

    return VLC_SUCCESS;
}",329.0,352.0,1.0,1.0,24.0,17,5,17,9,1,11,3,3,1,4,,0,7,8,4,4,int
1369,84532,vlc_dialog_display_error_va,1,vlc_dialog_display_error_va,"int vlc_dialog_display_error_va (vlc_object_t*,char*,char*,va_list)",interface\dialog.c,"int
vlc_dialog_display_error_va(vlc_object_t *p_obj, const char *psz_title,
                            const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);
    int i_ret;
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);

    if (p_provider != NULL)
        i_ret = dialog_display_error_va(p_provider, psz_title, psz_fmt, ap);
    else
        i_ret = VLC_EGENERIC;

    if (i_ret != VLC_SUCCESS)
    {
        msg_Err(p_obj, ""%s"", psz_title);
        msg_GenericVa(p_obj, VLC_MSG_ERR, psz_fmt, ap);
    }
    return i_ret;
}",354.0,373.0,1.0,1.0,20.0,9,3,25,10,1,2,3,3,0,2,,0,2,8,4,4,int
1370,84592,vlc_dialog_display_error,1,vlc_dialog_display_error,"int vlc_dialog_display_error (vlc_object_t*,char*,char*...)",interface\dialog.c,"int
vlc_dialog_display_error(vlc_object_t *p_obj, const char *psz_title,
                         const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_display_error_va(p_obj, psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",377.0,387.0,1.0,1.0,11.0,2,2,11,6,4,1,1,1,0,1,,0,1,6,3,3,int
1371,84619,dialog_display_login_va,1,dialog_display_login_va,"int dialog_display_login_va (vlc_dialog_provider*,vlc_dialog_id**,char*,bool,char*,char*,va_list)",interface\dialog.c,"static int
dialog_display_login_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                        const char *psz_default_username, bool b_ask_store,
                        const char *psz_title, const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_login == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_LOGIN);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_login(p_provider->p_cbs_data, p_id, psz_title,
                                     psz_text, psz_default_username, b_ask_store);
    free(p...",389.0,423.0,1.0,1.0,35.0,27,8,32,14,1,15,4,4,2,6,,0,10,14,7,7,int
1372,84724,vlc_dialog_wait_login_va,1,vlc_dialog_wait_login_va,"int vlc_dialog_wait_login_va (vlc_object_t*,char**,char**,bool*,char*,char*,char*,va_list)",interface\dialog.c,"int
vlc_dialog_wait_login_va(vlc_object_t *p_obj,  char **ppsz_username,
                         char **ppsz_password, bool *p_store,
                         const char *psz_default_username,
                         const char *psz_title, const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && ppsz_username != NULL && ppsz_password != NULL
        && psz_fmt != NULL && psz_title != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_login_va(p_provider, &p_id, psz_default_username,
                                        p_store != NULL, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_LOGIN, &answer);
    if (i_ret <= 0)
        return i_ret;

    *ppsz_username = answer.u.login.psz_username;
    *ppsz_password = a...",425.0,455.0,1.0,1.0,31.0,36,10,44,16,2,6,5,5,0,3,,0,6,16,8,8,int
1373,84848,vlc_dialog_wait_login,1,vlc_dialog_wait_login,"int vlc_dialog_wait_login (vlc_object_t*,char**,char**,bool*,char*,char*,char*...)",interface\dialog.c,"int
vlc_dialog_wait_login(vlc_object_t *p_obj,  char **ppsz_username,
                      char **ppsz_password, bool *p_store,
                      const char *psz_default_username, const char *psz_title,
                      const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_login_va(p_obj, ppsz_username, ppsz_password,
                                         p_store,psz_default_username,
                                         psz_title, psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",458.0,472.0,1.0,1.0,15.0,2,2,15,10,0,1,1,1,0,1,,0,1,14,7,7,int
1374,84883,dialog_display_question_va,1,dialog_display_question_va,"int dialog_display_question_va (vlc_dialog_provider*,vlc_dialog_id**,vlc_dialog_question_type,char*,char*,char*,char*,char*,va_list)",interface\dialog.c,"static int
dialog_display_question_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                           vlc_dialog_question_type i_type,
                           const char *psz_cancel, const char *psz_action1,
                           const char *psz_action2, const char *psz_title,
                           const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_question == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_QUESTION);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_provider->cbs.pf_display_question(p_provi...",474.0,511.0,1.0,1.0,38.0,27,8,34,16,1,15,4,4,2,6,,0,10,18,9,9,int
1375,84992,vlc_dialog_wait_question_va,1,vlc_dialog_wait_question_va,"int vlc_dialog_wait_question_va (vlc_object_t*,vlc_dialog_question_type,char*,char*,char*,char*,char*,va_list)",interface\dialog.c,"int
vlc_dialog_wait_question_va(vlc_object_t *p_obj,
                            vlc_dialog_question_type i_type,
                            const char *psz_cancel, const char *psz_action1,
                            const char *psz_action2, const char *psz_title,
                            const char *psz_fmt, va_list ap)
{
    assert(p_obj != NULL && psz_fmt != NULL && psz_title != NULL
        && psz_cancel != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return VLC_EGENERIC;

    vlc_dialog_id *p_id;
    int i_ret = dialog_display_question_va(p_provider, &p_id, i_type,
                                           psz_cancel, psz_action1,
                                           psz_action2, psz_title, psz_fmt, ap);
    if (i_ret < 0 || p_id == NULL)
        return i_ret;

    struct dialog_answer answer;
    i_ret = dialog_wait(p_provider, p_id, VLC_DIALOG_QUESTION, &answer);
    if (i_ret <= 0)
        ret...",513.0,543.0,1.0,1.0,31.0,29,9,39,16,1,6,5,5,2,3,,0,6,16,8,8,int
1376,85106,vlc_dialog_wait_question,1,vlc_dialog_wait_question,"int vlc_dialog_wait_question (vlc_object_t*,vlc_dialog_question_type,char*,char*,char*,char*,char*...)",interface\dialog.c,"int
vlc_dialog_wait_question(vlc_object_t *p_obj,
                         vlc_dialog_question_type i_type,
                         const char *psz_cancel, const char *psz_action1,
                         const char *psz_action2, const char *psz_title,
                         const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_wait_question_va(p_obj, i_type, psz_cancel,
                                            psz_action1, psz_action2, psz_title,
                                            psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",546.0,561.0,1.0,1.0,16.0,2,2,15,10,0,1,1,1,0,1,,0,1,14,7,7,int
1377,85141,display_progress_va,1,display_progress_va,"int display_progress_va (vlc_dialog_provider*,vlc_dialog_id**,bool,float,char*,char*,char*,va_list)",interface\dialog.c,"static int
display_progress_va(vlc_dialog_provider *p_provider, vlc_dialog_id **pp_id,
                    bool b_indeterminate, float f_position,
                    const char *psz_cancel, const char *psz_title,
                    const char *psz_fmt, va_list ap)
{
    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_display_progress == NULL
     || p_provider->cbs.pf_update_progress == NULL
     || p_provider->cbs.pf_cancel == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }

    vlc_dialog_id *p_id = dialog_add_locked(p_provider, VLC_DIALOG_PROGRESS);
    if (p_id == NULL)
    {
        free(psz_text);
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_ENOMEM;
    }
    p_id->b_progress_indeterminate = b_indeterminate;
    p_id->psz_progress_text = psz_text;
...",563.0,601.0,1.0,1.0,39.0,35,8,38,15,1,18,4,4,3,6,,0,13,16,8,8,int
1378,85264,vlc_dialog_display_progress_va,1,vlc_dialog_display_progress_va,"vlc_dialog_id vlc_dialog_display_progress_va (vlc_object_t*,bool,float,char*,char*,char*,va_list)",interface\dialog.c,"vlc_dialog_id *
vlc_dialog_display_progress_va(vlc_object_t *p_obj, bool b_indeterminate,
                               float f_position, const char *psz_cancel,
                               const char *psz_title, const char *psz_fmt,
                               va_list ap)
{
    assert(p_obj != NULL && psz_title != NULL && psz_fmt != NULL);

    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, true);
    if (p_provider == NULL)
        return NULL;
    vlc_dialog_id *p_id;
    int i_ret = display_progress_va(p_provider, &p_id, b_indeterminate,
                                    f_position, psz_cancel, psz_title, psz_fmt,
                                    ap);
    return i_ret == VLC_SUCCESS ? p_id : NULL;
}",603.0,619.0,1.0,1.0,17.0,11,6,25,13,1,2,2,2,0,2,,0,2,14,7,7,vlc_dialog_id
1379,85321,vlc_dialog_display_progress,1,vlc_dialog_display_progress,"vlc_dialog_id vlc_dialog_display_progress (vlc_object_t*,bool,float,char*,char*,char*...)",interface\dialog.c,"vlc_dialog_id *
vlc_dialog_display_progress(vlc_object_t *p_obj, bool b_indeterminate,
                            float f_position, const char *psz_cancel,
                            const char *psz_title, const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    vlc_dialog_id *p_id =
        vlc_dialog_display_progress_va(p_obj, b_indeterminate, f_position,
                                       psz_cancel, psz_title, psz_fmt, ap);
    va_end(ap);
    return p_id;
}",622.0,635.0,1.0,1.0,14.0,2,2,14,9,0,1,1,1,0,1,,0,1,12,6,6,vlc_dialog_id
1380,85354,dialog_update_progress,1,dialog_update_progress,"int dialog_update_progress (vlc_object_t*,vlc_dialog_id*,float,char*)",interface\dialog.c,"static int
dialog_update_progress(vlc_object_t *p_obj, vlc_dialog_id *p_id, float f_value,
                       char *psz_text)
{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->cbs.pf_update_progress == NULL ||
        vlc_dialog_is_cancelled(p_obj, p_id))
    {
        vlc_mutex_unlock(&p_provider->lock);
        free(psz_text);
        return VLC_EGENERIC;
    }

    if (p_id->b_progress_indeterminate)
        f_value = 0.0f;

    if (psz_text != NULL)
    {
        free(p_id->psz_progress_text);
        p_id->psz_progress_text = psz_text;
    }
    p_provider->cbs.pf_update_progress(p_provider->p_cbs_data, p_id, f_value,
                                       p_id->psz_progress_text);

    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",637.0,666.0,1.0,1.0,30.0,24,8,29,9,2,15,4,4,3,5,,0,12,8,4,4,int
1381,85446,vlc_dialog_update_progress,1,vlc_dialog_update_progress,"int vlc_dialog_update_progress (vlc_object_t*,vlc_dialog_id*,float)",interface\dialog.c,"int
vlc_dialog_update_progress(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                           float f_value)
{
    return dialog_update_progress(p_obj, p_id, f_value, NULL);
}",669.0,674.0,1.0,1.0,6.0,0,0,4,4,0,1,1,1,0,1,,0,0,6,3,3,int
1382,85459,vlc_dialog_update_progress_text_va,1,vlc_dialog_update_progress_text_va,"int vlc_dialog_update_progress_text_va (vlc_object_t*,vlc_dialog_id*,float,char*,va_list)",interface\dialog.c,"int
vlc_dialog_update_progress_text_va(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                                   float f_value, const char *psz_fmt,
                                   va_list ap)
{
    assert(psz_fmt != NULL);

    char *psz_text;
    if (vasprintf(&psz_text, psz_fmt, ap) == -1)
        return VLC_ENOMEM;
    return dialog_update_progress(p_obj, p_id, f_value, psz_text);
}",676.0,687.0,1.0,1.0,12.0,4,4,10,8,1,1,2,2,0,1,,0,0,10,5,5,int
1383,85491,vlc_dialog_update_progress_text,1,vlc_dialog_update_progress_text,"int vlc_dialog_update_progress_text (vlc_object_t*,vlc_dialog_id*,float,char*...)",interface\dialog.c,"int
vlc_dialog_update_progress_text(vlc_object_t *p_obj, vlc_dialog_id *p_id,
                                float f_value, const char *psz_fmt, ...)
{
    assert(psz_fmt != NULL);
    va_list ap;
    va_start(ap, psz_fmt);
    int i_ret = vlc_dialog_update_progress_text_va(p_obj, p_id, f_value,
                                                   psz_fmt, ap);
    va_end(ap);
    return i_ret;
}",690.0,701.0,1.0,1.0,12.0,2,2,12,7,0,1,1,1,0,1,,0,1,8,4,4,int
1384,85520,vlc_dialog_release,1,vlc_dialog_release,"void vlc_dialog_release (vlc_object_t*,vlc_dialog_id*)",interface\dialog.c,"void
vlc_dialog_release(vlc_object_t *p_obj, vlc_dialog_id *p_id)
{
    assert(p_obj != NULL && p_id != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    dialog_cancel_locked(p_provider, p_id);
    dialog_remove_locked(p_provider, p_id);
    vlc_mutex_unlock(&p_provider->lock);
}",704.0,714.0,1.0,1.0,11.0,8,5,13,5,0,7,1,1,0,5,,0,3,4,2,2,void
1385,85556,vlc_dialog_is_cancelled,1,vlc_dialog_is_cancelled,"bool vlc_dialog_is_cancelled (vlc_object_t*,vlc_dialog_id*)",interface\dialog.c,"bool
vlc_dialog_is_cancelled(vlc_object_t *p_obj, vlc_dialog_id *p_id)
{
    (void) p_obj;
    assert(p_id != NULL);

    vlc_mutex_lock(&p_id->lock);
    bool b_cancelled = p_id->b_cancelled;
    vlc_mutex_unlock(&p_id->lock);
    return b_cancelled;
}",717.0,727.0,1.0,1.0,11.0,8,5,8,4,1,5,1,1,0,2,,0,3,4,2,2,bool
1386,85587,vlc_dialog_id_set_context,1,vlc_dialog_id_set_context,"void vlc_dialog_id_set_context (vlc_dialog_id*,void*)",interface\dialog.c,"void
vlc_dialog_id_set_context(vlc_dialog_id *p_id, void *p_context)
{
    vlc_mutex_lock(&p_id->lock);
    p_id->p_context = p_context;
    vlc_mutex_unlock(&p_id->lock);
}",729.0,735.0,1.0,1.0,7.0,6,3,4,2,0,5,1,1,0,2,,0,3,4,2,2,void
1387,85608,vlc_dialog_id_get_context,1,vlc_dialog_id_get_context,void* vlc_dialog_id_get_context (vlc_dialog_id*),interface\dialog.c,"void *
vlc_dialog_id_get_context(vlc_dialog_id *p_id)
{
    assert(p_id != NULL);
    vlc_mutex_lock(&p_id->lock);
    void *p_context = p_id->p_context;
    vlc_mutex_unlock(&p_id->lock);
    return p_context;
}",737.0,745.0,1.0,1.0,9.0,7,4,7,3,0,5,1,1,0,2,,0,3,2,1,1,void*
1388,85635,dialog_id_post,1,dialog_id_post,"int dialog_id_post (vlc_dialog_id*,dialog_answer*)",interface\dialog.c,"static int
dialog_id_post(vlc_dialog_id *p_id, struct dialog_answer *p_answer)
{
    vlc_mutex_lock(&p_id->lock);
    if (p_answer == NULL)
    {
        p_id->b_cancelled = true;
    }
    else
    {
        p_id->answer = *p_answer;
        p_id->b_answered = true;
    }
    p_id->i_refcount--;
    if (p_id->i_refcount > 0)
    {
        vlc_cond_signal(&p_id->wait);
        vlc_mutex_unlock(&p_id->lock);
    }
    else
    {
        vlc_mutex_unlock(&p_id->lock);
        dialog_id_release(p_id);
    }
    return VLC_SUCCESS;
}",747.0,772.0,1.0,1.0,26.0,13,6,10,5,4,9,3,3,1,3,,0,6,4,2,2,int
1389,85701,vlc_dialog_id_post_login,1,vlc_dialog_id_post_login,"int vlc_dialog_id_post_login (vlc_dialog_id*,char*,char*,bool)",interface\dialog.c,"int
vlc_dialog_id_post_login(vlc_dialog_id *p_id, const char *psz_username,
                         const char *psz_password, bool b_store)
{
    assert(p_id != NULL && psz_username != NULL && psz_password != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_LOGIN,
        .u.login = {
            .b_store = b_store,
            .psz_username = strdup(psz_username),
            .psz_password = strdup(psz_password),
        },
    };
    if (answer.u.login.psz_username == NULL
     || answer.u.login.psz_password == NULL)
    {
        free(answer.u.login.psz_username);
        free(answer.u.login.psz_password);
        dialog_id_post(p_id, NULL);
        return VLC_ENOMEM;
    }

    return dialog_id_post(p_id, &answer);
}",774.0,798.0,1.0,1.0,25.0,34,8,34,11,0,6,2,2,2,2,,0,4,8,4,4,int
1390,85811,vlc_dialog_id_post_action,1,vlc_dialog_id_post_action,"int vlc_dialog_id_post_action (vlc_dialog_id*,int)",interface\dialog.c,"int
vlc_dialog_id_post_action(vlc_dialog_id *p_id, int i_action)
{
    assert(p_id != NULL);

    struct dialog_answer answer = {
        .i_type = VLC_DIALOG_QUESTION,
        .u.question = { .i_action = i_action },
    };

    return dialog_id_post(p_id, &answer);
}",800.0,811.0,1.0,1.0,12.0,11,4,13,8,0,1,1,1,0,1,,0,0,4,2,2,int
1391,85849,vlc_dialog_id_dismiss,1,vlc_dialog_id_dismiss,int vlc_dialog_id_dismiss (vlc_dialog_id*),interface\dialog.c,"int
vlc_dialog_id_dismiss(vlc_dialog_id *p_id)
{
    return dialog_id_post(p_id, NULL);
}",813.0,817.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
1392,85858,vlc_dialog_provider_set_ext_callback,1,vlc_dialog_provider_set_ext_callback,"void vlc_dialog_provider_set_ext_callback (vlc_object_t*,vlc_dialog_ext_update_cb,void*)",interface\dialog.c,"void
vlc_dialog_provider_set_ext_callback(vlc_object_t *p_obj,
                                     vlc_dialog_ext_update_cb pf_update,
                                     void *p_data)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);

    p_provider->pf_ext_update = pf_update;
    p_provider->p_ext_data = p_data;

    vlc_mutex_unlock(&p_provider->lock);
}",820.0,834.0,1.0,1.0,15.0,10,4,11,6,0,7,1,1,0,3,,0,5,6,3,3,void
1393,85895,vlc_ext_dialog_update,1,vlc_ext_dialog_update,"int vlc_ext_dialog_update (vlc_object_t*,extension_dialog_t*)",interface\dialog.c,"int
vlc_ext_dialog_update(vlc_object_t *p_obj, extension_dialog_t *p_ext_dialog)
{
    assert(p_obj != NULL);
    vlc_dialog_provider *p_provider = get_dialog_provider(p_obj, false);

    vlc_mutex_lock(&p_provider->lock);
    if (p_provider->pf_ext_update == NULL)
    {
        vlc_mutex_unlock(&p_provider->lock);
        return VLC_EGENERIC;
    }
    p_provider->pf_ext_update(p_ext_dialog, p_provider->p_ext_data);
    vlc_mutex_unlock(&p_provider->lock);
    return VLC_SUCCESS;
}",837.0,852.0,1.0,1.0,16.0,12,5,15,7,0,10,2,2,1,4,,0,7,4,2,2,int
1394,85981,intf_Create,1,intf_Create,"int intf_Create (playlist_t*,char*)",interface\interface.c,"int intf_Create( playlist_t *playlist, const char *chain )
{
    /* Allocate structure */
    intf_thread_t *p_intf = vlc_custom_create( playlist, sizeof( *p_intf ),
                                               ""interface"" );
    if( unlikely(p_intf == NULL) )
        return VLC_ENOMEM;

    /* Variable used for interface spawning */
    vlc_value_t val, text;
    var_Create( p_intf, ""intf-add"", VLC_VAR_STRING | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Add Interface"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_SETTEXT, &text, NULL );
#if !defined(_WIN32) && defined(HAVE_ISATTY)
    if( isatty( 0 ) )
#endif
    {
        val.psz_string = (char *)""rc,none"";
        text.psz_string = (char *)_(""Console"");
        var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    }
    val.psz_string = (char *)""telnet,none"";
    text.psz_string = (char *)_(""Telnet"");
    var_Change( p_intf, ""intf-add"", VLC_VAR_ADDCHOICE, &val, &text );
    val.psz_string = (char *)""http,none...",71.0,130.0,1.0,28.0,60.0,59,9,73,18,0,17,5,4,0,15,,0,4,4,2,2,int
1395,86216,intf_GetPlaylist,1,intf_GetPlaylist,playlist_t intf_GetPlaylist (libvlc_int_t*),interface\interface.c,"static playlist_t *intf_GetPlaylist(libvlc_int_t *libvlc)
{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist == NULL)
    {
        playlist = playlist_Create(VLC_OBJECT(libvlc));
        libvlc_priv(libvlc)->playlist = playlist;
    }
    vlc_mutex_unlock(&lock);

    return playlist;
}",137.0,151.0,1.0,1.0,15.0,8,4,11,4,2,7,2,2,0,5,,0,4,2,1,1,playlist_t
1396,86252,intf_InsertItem,1,intf_InsertItem,"int intf_InsertItem (libvlc_int_t*,char*,unsigned,char**,unsigned)",interface\interface.c,"int intf_InsertItem(libvlc_int_t *libvlc, const char *mrl, unsigned optc,
                    const char *const *optv, unsigned flags)
{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    input_item_t *item = input_item_New(mrl, NULL);

    if (unlikely(item == NULL))
        return -1;

    int ret = -1;

    if (input_item_AddOptions(item, optc, optv, flags) == VLC_SUCCESS)
    {
        playlist_Lock(playlist);
        if (playlist_NodeAddInput(playlist, item, playlist->p_playing,
                                  0) != NULL)
            ret = 0;
        playlist_Unlock(playlist);
    }
    input_item_Release(item);
    return ret;
}",163.0,184.0,1.0,1.0,22.0,10,5,22,10,1,6,4,5,2,6,,0,3,10,5,5,int
1397,86317,libvlc_InternalPlay,1,libvlc_InternalPlay,void libvlc_InternalPlay (libvlc_int_t*),interface\interface.c,"void libvlc_InternalPlay(libvlc_int_t *libvlc)
{
    playlist_t *pl;

    vlc_mutex_lock(&lock);
    pl = libvlc_priv(libvlc)->playlist;
    vlc_mutex_unlock(&lock);

    if (pl != NULL && var_GetBool(pl, ""playlist-autostart""))
        playlist_Control(pl, PLAYLIST_PLAY, false);
}",186.0,196.0,1.0,1.0,11.0,6,5,10,6,0,6,2,2,0,4,,0,3,2,1,1,void
1398,86348,libvlc_InternalAddIntf,1,libvlc_InternalAddIntf,"int libvlc_InternalAddIntf (libvlc_int_t*,char*)",interface\interface.c,"int libvlc_InternalAddIntf(libvlc_int_t *libvlc, const char *name)
{
    playlist_t *playlist = intf_GetPlaylist(libvlc);
    int ret;

    if (unlikely(playlist == NULL))
        ret = VLC_ENOMEM;
    else
    if (name != NULL)
        ret = intf_Create(playlist, name);
    else
    {   /* Default interface */
        char *intf = var_InheritString(libvlc, ""intf"");
        if (intf == NULL) /* ""intf"" has not been set */
        {
#if !defined(_WIN32) && !defined(__OS2__)
            char *pidfile = var_InheritString(libvlc, ""pidfile"");
            if (pidfile != NULL)
                free(pidfile);
            else
#endif
                msg_Info(libvlc, _(""Running vlc with the default interface. ""
                         ""Use 'cvlc' to use vlc without interface.""));
        }
        ret = intf_Create(playlist, intf);
        free(intf);
        name = ""default"";
    }
    if (ret != VLC_SUCCESS)
        msg_Err(libvlc, ""interface \""%s\"" initialization failed"", name);
    return ...",201.0,232.0,1.0,1.0,32.0,4,3,11,7,2,1,3,3,0,1,,0,1,4,2,2,int
1399,86434,intf_DestroyAll,1,intf_DestroyAll,void intf_DestroyAll (libvlc_int_t*),interface\interface.c,"void intf_DestroyAll(libvlc_int_t *libvlc)
{
    playlist_t *playlist;

    vlc_mutex_lock(&lock);
    playlist = libvlc_priv(libvlc)->playlist;
    if (playlist != NULL)
    {
        intf_thread_t *intf, **pp = &(pl_priv(playlist)->interface);

        while ((intf = *pp) != NULL)
        {
            *pp = intf->p_next;
            vlc_mutex_unlock(&lock);

            module_unneed(intf, intf->p_module);
            config_ChainDestroy(intf->p_cfg);
            var_DelCallback(intf, ""intf-add"", AddIntfCallback, playlist);
            vlc_object_release(intf);

            vlc_mutex_lock(&lock);
        }

        libvlc_priv(libvlc)->playlist = NULL;
    }
    vlc_mutex_unlock(&lock);

    if (playlist != NULL)
        playlist_Destroy(playlist);
}",239.0,268.0,1.0,38.0,30.0,21,5,29,8,1,15,4,5,0,11,,0,5,2,1,1,void
1400,86988,GetFilenames,1,GetFilenames,"void GetFilenames (libvlc_int_t*,unsigned,char[]*)",libvlc.c,"static void GetFilenames( libvlc_int_t *p_vlc, unsigned n,
                          const char *const args[] )
{
    while( n > 0 )
    {
        /* Count the input options */
        unsigned i_options = 0;

        while( args[--n][0] == ':' )
        {
            i_options++;
            if( n == 0 )
            {
                msg_Warn( p_vlc, ""options %s without item"", args[n] );
                return; /* syntax!? */
            }
        }

        char *mrl = NULL;
        if( strstr( args[n], ""://"" ) == NULL )
        {
            mrl = vlc_path2uri( args[n], NULL );
            if( !mrl )
                continue;
        }

        intf_InsertItem( p_vlc, (mrl != NULL) ? mrl : args[n], i_options,
                         ( i_options ? &args[n + 1] : NULL ),
                         VLC_INPUT_OPTION_TRUSTED );
        free( mrl );
    }
}",456.0,487.0,1.0,1.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1401,86995,libvlc_InternalCreate,1,libvlc_InternalCreate,libvlc_int_t libvlc_InternalCreate (void),libvlc.c,"libvlc_int_t * libvlc_InternalCreate( void )
{
    libvlc_int_t *p_libvlc;
    libvlc_priv_t *priv;

    /* Allocate a libvlc instance object */
    p_libvlc = (vlc_custom_create)( NULL, sizeof (*priv), ""libvlc"" );
    if( p_libvlc == NULL )
        return NULL;

    priv = libvlc_priv (p_libvlc);
    priv->playlist = NULL;
    priv->p_vlm = NULL;

    vlc_ExitInit( &priv->exit );

    return p_libvlc;
}",83.0,100.0,1.0,1.0,18.0,11,6,14,3,0,6,2,2,0,3,,0,5,2,1,1,libvlc_int_t
1402,87038,libvlc_InternalInit,1,libvlc_InternalInit,"int libvlc_InternalInit (libvlc_int_t*,int,char[]*)",libvlc.c,"int libvlc_InternalInit( libvlc_int_t *p_libvlc, int i_argc,
                         const char *ppsz_argv[] )
{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);
    char *       psz_modules = NULL;
    char *       psz_parser = NULL;
    char *       psz_control = NULL;
    char        *psz_val;
    int          i_ret = VLC_EGENERIC;

    /* System specific initialization code */
    system_Init();

    vlc_LogPreinit(p_libvlc);

    /* Initialize the module bank and load the configuration of the
     * core module. We need to do this at this stage to be able to display
     * a short help if required by the user. (short help == core module
     * options) */
    module_InitBank ();

    /* Get command line options that affect module loading. */
    if( config_LoadCmdLine( p_libvlc, i_argc, ppsz_argv, NULL ) )
    {
        module_EndBank (false);
        return VLC_EGENERIC;
    }

    vlc_threads_setup (p_libvlc);

    /* Load the builtins and plugins into the module_bank.
    ...",110.0,376.0,1.0,8.0,267.0,45,12,143,26,0,39,23,22,7,36,,0,12,6,3,3,int
1403,87422,libvlc_InternalCleanup,1,libvlc_InternalCleanup,void libvlc_InternalCleanup (libvlc_int_t*),libvlc.c,"void libvlc_InternalCleanup( libvlc_int_t *p_libvlc )
{
    libvlc_priv_t *priv = libvlc_priv (p_libvlc);

    if (priv->parser != NULL)
        playlist_preparser_Deactivate(priv->parser);

    /* Ask the interfaces to stop and destroy them */
    msg_Dbg( p_libvlc, ""removing all interfaces"" );
    intf_DestroyAll( p_libvlc );

    libvlc_InternalDialogClean( p_libvlc );
    libvlc_InternalKeystoreClean( p_libvlc );

#ifdef ENABLE_VLM
    /* Destroy VLM if created in libvlc_InternalInit */
    if( priv->p_vlm )
    {
        vlm_Delete( priv->p_vlm );
    }
#endif

#if !defined( _WIN32 ) && !defined( __OS2__ )
    char *pidfile = var_InheritString( p_libvlc, ""pidfile"" );
    if( pidfile != NULL )
    {
        msg_Dbg( p_libvlc, ""removing PID file %s"", pidfile );
        if( unlink( pidfile ) )
            msg_Warn( p_libvlc, ""cannot remove PID file %s: %s"",
                      pidfile, vlc_strerror_c(errno) );
        free( pidfile );
    }
#endif

    if (priv->parser != NULL)
...",382.0,431.0,1.0,1.0,50.0,10,4,28,6,2,15,6,7,2,11,,0,5,2,1,1,void
1404,87505,libvlc_InternalDestroy,1,libvlc_InternalDestroy,void libvlc_InternalDestroy (libvlc_int_t*),libvlc.c,"void libvlc_InternalDestroy( libvlc_int_t *p_libvlc )
{
    libvlc_priv_t *priv = libvlc_priv( p_libvlc );

    vlc_ExitDestroy( &priv->exit );

    assert( atomic_load(&(vlc_internals(p_libvlc)->refs)) == 1 );
    vlc_object_release( p_libvlc );
}",440.0,448.0,1.0,26.0,9.0,8,6,6,2,0,4,1,1,0,3,,0,2,2,1,1,void
1405,87626,vlc_MetadataRequest,1,vlc_MetadataRequest,"int vlc_MetadataRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t,int,void*)",libvlc.c,"int vlc_MetadataRequest(libvlc_int_t *libvlc, input_item_t *item,
                        input_item_meta_request_option_t i_options,
                        int timeout, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
    {
        vlc_mutex_lock( &item->lock );
        item->b_preparse_interact = true;
        vlc_mutex_unlock( &item->lock );
    }
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;

}",489.0,507.0,1.0,1.0,19.0,11,5,17,11,0,6,3,3,1,4,,0,3,10,5,5,int
1406,87680,libvlc_MetadataRequest,1,libvlc_MetadataRequest,"int libvlc_MetadataRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t,int,void*)",libvlc.c,"int libvlc_MetadataRequest(libvlc_int_t *libvlc, input_item_t *item,
                           input_item_meta_request_option_t i_options,
                           int timeout, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    vlc_mutex_lock( &item->lock );
    if( item->i_preparse_depth == 0 )
        item->i_preparse_depth = 1;
    if( i_options & META_REQUEST_OPTION_DO_INTERACT )
        item->b_preparse_interact = true;
    vlc_mutex_unlock( &item->lock );
    playlist_preparser_Push( priv->parser, item, i_options, timeout, id );
    return VLC_SUCCESS;
}",514.0,531.0,1.0,1.0,18.0,15,5,19,11,0,6,4,4,1,4,,0,3,10,5,5,int
1407,87746,libvlc_ArtRequest,1,libvlc_ArtRequest,"int libvlc_ArtRequest (libvlc_int_t*,input_item_t*,input_item_meta_request_option_t)",libvlc.c,"int libvlc_ArtRequest(libvlc_int_t *libvlc, input_item_t *item,
                      input_item_meta_request_option_t i_options)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return VLC_ENOMEM;

    playlist_preparser_fetcher_Push(priv->parser, item, i_options);
    return VLC_SUCCESS;
}",537.0,547.0,1.0,1.0,11.0,4,3,9,7,1,4,2,2,1,2,,0,3,6,3,3,int
1408,87776,libvlc_MetadataCancel,1,libvlc_MetadataCancel,"void libvlc_MetadataCancel (libvlc_int_t*,void*)",libvlc.c,"void libvlc_MetadataCancel(libvlc_int_t *libvlc, void *id)
{
    libvlc_priv_t *priv = libvlc_priv(libvlc);

    if (unlikely(priv->parser == NULL))
        return;

    playlist_preparser_Cancel(priv->parser, id);
}",555.0,563.0,1.0,1.0,9.0,4,3,6,4,1,4,2,2,1,2,,0,3,4,2,2,void
1409,87829,vlc_CPU_dump,1,vlc_CPU_dump,void vlc_CPU_dump (vlc_object_t*),misc\cpu.c,"void vlc_CPU_dump (vlc_object_t *obj)
{
    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

#if defined (__i386__) || defined (__x86_64__)
    if (vlc_CPU_MMX())
        vlc_memstream_puts(&stream, ""MMX "");
    if (vlc_CPU_MMXEXT())
        vlc_memstream_puts(&stream, ""MMXEXT "");
    if (vlc_CPU_SSE())
        vlc_memstream_puts(&stream, ""SSE "");
    if (vlc_CPU_SSE2())
        vlc_memstream_puts(&stream, ""SSE2 "");
    if (vlc_CPU_SSE3())
        vlc_memstream_puts(&stream, ""SSE3 "");
    if (vlc_CPU_SSSE3())
        vlc_memstream_puts(&stream, ""SSSE3 "");
    if (vlc_CPU_SSE4_1())
        vlc_memstream_puts(&stream, ""SSE4.1 "");
    if (vlc_CPU_SSE4_2())
        vlc_memstream_puts(&stream, ""SSE4.2 "");
    if (vlc_CPU_SSE4A())
        vlc_memstream_puts(&stream, ""SSE4A "");
    if (vlc_CPU_AVX())
        vlc_memstream_puts(&stream, ""AVX "");
    if (vlc_CPU_AVX2())
        vlc_memstream_puts(&stream, ""AVX2 "");
    if (vlc_CPU_3dNOW())
        vlc_memstream_puts(&stream, ""...",281.0,336.0,1.0,1.0,56.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1410,87862,vlc_LogPreinit,1,vlc_LogPreinit,int vlc_LogPreinit (libvlc_int_t*),misc\messages.c,"int vlc_LogPreinit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = vlc_custom_create(vlc, sizeof (*logger), ""logger"");

    libvlc_priv(vlc)->logger = logger;

    if (unlikely(logger == NULL))
        return -1;

    vlc_rwlock_init(&logger->lock);

    if (vlc_LogEarlyOpen(logger))
    {
        logger->log = vlc_vaLogDiscard;
        return -1;
    }

    /* Announce who we are */
    msg_Dbg(vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg(vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg(vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg(vlc, ""configured with %s"", CONFIGURE_LINE);
    return 0;
}",323.0,346.0,1.0,27.0,24.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1411,87867,vlc_LogInit,1,vlc_LogInit,int vlc_LogInit (libvlc_int_t*),misc\messages.c,"int vlc_LogInit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    if (unlikely(logger == NULL))
        return -1;

    vlc_log_cb cb;
    void *sys, *early_sys = NULL;

    /* TODO: module configuration item */
    module_t *module = vlc_module_load(logger, ""logger"", NULL, false,
                                       vlc_logger_load, logger, &cb, &sys);
    if (module == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    if (logger->log == vlc_vaLogEarly)
        early_sys = logger->sys;

    logger->log = cb;
    logger->sys = sys;
    assert(logger->module == NULL); /* Only one call to vlc_LogInit()! */
    logger->module = module;
    vlc_rwlock_unlock(&logger->lock);

    if (early_sys != NULL)
        vlc_LogEarlyClose(logger, early_sys);

    return 0;
}",354.0,383.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1412,87872,vlc_LogDeinit,1,vlc_LogDeinit,void vlc_LogDeinit (libvlc_int_t*),misc\messages.c,"void vlc_LogDeinit(libvlc_int_t *vlc)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    if (logger->module != NULL)
        vlc_module_unload(vlc, logger->module, vlc_logger_unload, logger->sys);
    else
    /* Flush early log messages (corner case: no call to vlc_LogInit()) */
    if (logger->log == vlc_vaLogEarly)
    {
        logger->log = vlc_vaLogDiscard;
        vlc_LogEarlyClose(logger, logger->sys);
    }

    vlc_rwlock_destroy(&logger->lock);
    vlc_object_release(logger);
    libvlc_priv(vlc)->logger = NULL;
}",422.0,442.0,1.0,1.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1413,87879,handler,1,vlc_exit.handler,void vlc_exit.handler (void*),libvlc.h,void (*handler) (void *);,83.0,83.0,10.0,28.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1414,87886,vlc_ExitInit,1,vlc_ExitInit,void vlc_ExitInit (vlc_exit_t*),misc\exit.c,"void vlc_ExitInit( vlc_exit_t *exit )
{
    vlc_mutex_init( &exit->lock );
    exit->handler = NULL;
    exit->opaque = NULL;
}",30.0,35.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1415,87891,vlc_ExitDestroy,1,vlc_ExitDestroy,void vlc_ExitDestroy (vlc_exit_t*),misc\exit.c,"void vlc_ExitDestroy( vlc_exit_t *exit )
{
    vlc_mutex_destroy( &exit->lock );
}",37.0,40.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1416,87896,vlc_custom_create,1,vlc_custom_create,"void* vlc_custom_create (vlc_object_t*,size_t,char*)",misc\objects.c,"void *vlc_custom_create (vlc_object_t *parent, size_t length,
                         const char *typename)
{
    /* NOTE:
     * VLC objects are laid out as follow:
     * - first the LibVLC-private per-object data,
     * - then VLC_COMMON members from vlc_object_t,
     * - finally, the type-specific data (if any).
     *
     * This function initializes the LibVLC and common data,
     * and zeroes the rest.
     */
    assert (length >= sizeof (vlc_object_t));

    vlc_object_internals_t *priv = malloc (sizeof (*priv) + length);
    if (unlikely(priv == NULL))
        return NULL;
    priv->psz_name = NULL;
    priv->var_root = NULL;
    vlc_mutex_init (&priv->var_lock);
    vlc_cond_init (&priv->var_wait);
    atomic_init (&priv->refs, 1);
    priv->pf_destructor = NULL;
    priv->prev = NULL;
    priv->first = NULL;
    vlc_mutex_init (&priv->tree_lock);
    priv->resources = NULL;

    vlc_object_t *obj = (vlc_object_t *)(priv + 1);
    obj->obj.object_type = typename;
    ...",176.0,247.0,1.0,41.0,72.0,0,0,0,0,42,0,1,1,0,0,,0,0,6,3,3,void*
1417,87903,vlc_object_set_name,1,vlc_object_set_name,"int vlc_object_set_name (vlc_object_t*,char*)",misc\objects.c,"int vlc_object_set_name(vlc_object_t *obj, const char *name)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *newname = name ? strdup (name) : NULL;
    char *oldname;

    vlc_mutex_lock (&name_lock);
    oldname = priv->psz_name;
    priv->psz_name = newname;
    vlc_mutex_unlock (&name_lock);

    free (oldname);
    return (priv->psz_name || !name) ? VLC_SUCCESS : VLC_ENOMEM;
}",282.0,295.0,1.0,35.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1418,87914,vlc_object_set_destructor,1,vlc_object_set_destructor,"void vlc_object_set_destructor (vlc_object_t*,vlc_destructor_t)",misc\objects.c,"void vlc_object_set_destructor( vlc_object_t *p_this,
                                vlc_destructor_t pf_destructor )
{
    vlc_object_internals_t *p_priv = vlc_internals(p_this );

    p_priv->pf_destructor = pf_destructor;
}",271.0,277.0,1.0,37.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1419,87920,vlc_objres_new,1,vlc_objres_new,"void* vlc_objres_new (size_t,void)",misc\objres.c,"void *vlc_objres_new(size_t size, void (*release)(void *))
{
    if (unlikely(add_overflow(sizeof (struct vlc_res), size, &size)))
    {
        errno = ENOMEM;
        return NULL;
    }

    struct vlc_res *res = malloc(size);
    if (unlikely(res == NULL))
        return NULL;

    res->release = release;
    return res->payload;
}",47.0,61.0,1.0,1.0,15.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void*
1420,87926,vlc_objres_push,1,vlc_objres_push,"void vlc_objres_push (vlc_object_t*,void*)",misc\objres.c,"void vlc_objres_push(vlc_object_t *obj, void *data)
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = container_of(data, struct vlc_res, payload);

    res->prev = *pp;
    *pp = res;
}",63.0,70.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
1421,87932,vlc_objres_clear,1,vlc_objres_clear,void vlc_objres_clear (vlc_object_t*),misc\objres.c,"void vlc_objres_clear(vlc_object_t *obj)
{
    void *data;

    while ((data = vlc_objres_pop(obj)) != NULL)
    {
        struct vlc_res *res = container_of(data, struct vlc_res, payload);

        res->release(res->payload);
        free(res);
    }
}",83.0,94.0,1.0,1.0,12.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1422,87937,vlc_objres_remove,1,vlc_objres_remove,"void vlc_objres_remove (vlc_object_t*,void*,bool)",misc\objres.c,"void vlc_objres_remove(vlc_object_t *obj, void *data,
                       bool (*match)(void *, void *))
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);

    /* With a doubly-linked list, this function could have constant complexity.
     * But that would require one more pointer per resource.
     *
     * Any given list should contain a fairly small number of resources,
     * and in most cases, the resources are destroyed implicitly by
     * vlc_objres_clear().
     */
    for (;;)
    {
        struct vlc_res *res = *pp;

        assert(res != NULL); /* invalid free? */

        if (match(res->payload, data))
        {
            *pp = res->prev;
            res->release(res->payload);
            free(res);
            return;
        }

        pp = &res->prev;
    }
}",96.0,124.0,1.0,1.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1423,87964,libvlc_priv,1,libvlc_priv,libvlc_priv_t libvlc_priv (libvlc_int_t*),libvlc.h,"static inline libvlc_priv_t *libvlc_priv (libvlc_int_t *libvlc)
{
    return container_of(libvlc, libvlc_priv_t, public_data);
}",199.0,202.0,1.0,1.0,4.0,0,0,3,3,33,0,1,1,0,0,,0,0,2,1,1,libvlc_priv_t
1424,87997,var_OptionParse,1,var_OptionParse,"void var_OptionParse (vlc_object_t*,char*,bool)",misc\variables.c,"void var_OptionParse( vlc_object_t *p_obj, const char *psz_option,
                      bool trusted )
{
    char *psz_name, *psz_value;
    int  i_type;
    bool b_isno = false;
    vlc_value_t val;

    val.psz_string = NULL;

    /* It's too much of a hassle to remove the ':' when we parse
     * the cmd line :) */
    if( psz_option[0] == ':' )
        psz_option++;

    if( !psz_option[0] )
        return;

    psz_name = strdup( psz_option );
    if( psz_name == NULL )
        return;

    psz_value = strchr( psz_name, '=' );
    if( psz_value != NULL )
        *psz_value++ = '\0';

    i_type = config_GetType( psz_name );
    if( !i_type && !psz_value )
    {
        /* check for ""no-foo"" or ""nofoo"" */
        if( !strncmp( psz_name, ""no-"", 3 ) )
        {
            memmove( psz_name, psz_name + 3, strlen(psz_name) + 1 - 3 );
        }
        else if( !strncmp( psz_name, ""no"", 2 ) )
        {
            memmove( psz_name, psz_name + 2, strlen(psz_name) + 1 - 2 );
       ...",1031.0,1119.0,1.0,1.0,89.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1425,88396,vlc_getaddrinfo_notify,1,vlc_getaddrinfo_notify,void vlc_getaddrinfo_notify (union sigval),linux\getaddrinfo.c,"static void vlc_getaddrinfo_notify(union sigval val)
{
    vlc_sem_post(val.sival_ptr);
}",34.0,37.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1426,88405,vlc_getaddrinfo_i11e,1,vlc_getaddrinfo_i11e,"int vlc_getaddrinfo_i11e (char*,unsigned,addrinfo*,addrinfo**)",posix\getaddrinfo.c,"int vlc_getaddrinfo_i11e(const char *name, unsigned port,
                         const struct addrinfo *hints,
                         struct addrinfo **res)
{
    struct vlc_gai_req req =
    {
        .name = name,
        .service = NULL,
        .hints = hints,
    };
    char portbuf[6];
    vlc_thread_t th;

    if (port != 0)
    {
        if ((size_t)snprintf(portbuf, sizeof (portbuf), ""%u"",
                             port) >= sizeof (portbuf))
            return EAI_NONAME;

        req.service = portbuf;
    }

    vlc_sem_init(&req.done, 0);

    if (vlc_clone(&th, vlc_gai_thread, &req, VLC_THREAD_PRIORITY_LOW))
    {
        vlc_sem_destroy(&req.done);
        return EAI_SYSTEM;
    }

    vlc_sem_wait_i11e(&req.done);

    vlc_cancel(th);
    vlc_join(th, NULL);
    vlc_sem_destroy(&req.done);

    *res = req.result;
    return req.error;
}",54.0,92.0,1.0,1.0,39.0,45,10,46,23,3,5,7,8,0,5,,0,0,8,4,4,int
1427,88597,sys_futex,1,sys_futex,"int sys_futex (void*,int,unsigned,timespec*,void*,int)",linux\thread.c,"static int sys_futex(void *addr, int op, unsigned val,
                     const struct timespec *to, void *addr2, int val3)
{
    return syscall(__NR_futex, addr, op, val, to, addr2, val3);
}",50.0,54.0,1.0,1.0,5.0,0,0,7,7,2,0,1,1,0,0,,0,0,12,6,6,int
1428,88616,vlc_futex_wake,1,vlc_futex_wake,"int vlc_futex_wake (void*,int)",linux\thread.c,"static int vlc_futex_wake(void *addr, int nr)
{
    return sys_futex(addr, FUTEX_WAKE_PRIVATE, nr, NULL, NULL, 0);
}",56.0,59.0,1.0,27.0,4.0,0,0,5,4,2,1,1,1,0,1,,0,0,4,2,2,int
1429,88632,vlc_futex_wait,1,vlc_futex_wait,"int vlc_futex_wait (void*,unsigned,timespec*)",linux\thread.c,"static int vlc_futex_wait(void *addr, unsigned val, const struct timespec *to)
{
    return sys_futex(addr, FUTEX_WAIT_PRIVATE, val, to, NULL, 0);
}",61.0,64.0,1.0,27.0,4.0,0,0,5,5,2,1,1,1,0,1,,0,0,6,3,3,int
1430,88649,vlc_addr_signal,1,vlc_addr_signal,void vlc_addr_signal (void*),win32\thread.c,"void vlc_addr_signal(void *addr)
{
    WakeByAddressSingle(addr);
}",447.0,450.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1431,88657,vlc_addr_broadcast,1,vlc_addr_broadcast,void vlc_addr_broadcast (void*),win32\thread.c,"void vlc_addr_broadcast(void *addr)
{
    WakeByAddressAll(addr);
}",452.0,455.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
1432,88665,vlc_addr_wait,1,vlc_addr_wait,"void vlc_addr_wait (void*,unsigned)",win32\thread.c,"void vlc_addr_wait(void *addr, unsigned val)
{
    WaitOnAddress(addr, &val, sizeof (val), -1);
}",429.0,432.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
1433,88675,vlc_addr_timedwait,1,vlc_addr_timedwait,"bool vlc_addr_timedwait (void*,unsigned,mtime_t)",win32\thread.c,"bool vlc_addr_timedwait(void *addr, unsigned val, mtime_t delay)
{
    delay = (delay + 999) / 1000;

    if (delay > 0x7fffffff)
    {
        WaitOnAddress(addr, &val, sizeof (val), 0x7fffffff);
        return true; /* woke up early, claim spurious wake-up */
    }

    return WaitOnAddress(addr, &val, sizeof (val), delay);
}",434.0,445.0,1.0,1.0,12.0,11,9,12,8,0,1,1,1,0,1,,0,0,6,3,3,bool
1434,89040,utf8_cp,1,utf8_cp,"char* utf8_cp (uint_fast32_t,char*)",misc\actions.c,"static char *utf8_cp (uint_fast32_t cp, char *buf)
{
    if (cp < (1 << 7))
    {
        buf[1] = 0;
        buf[0] = cp;
    }
    else if (cp < (1 << 11))
    {
        buf[2] = 0;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xC0 | cp;
    }
    else if (cp < (1 << 16))
    {
        buf[3] = 0;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else if (cp < (1 << 21))
    {
        buf[4] = 0;
        buf[3] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[2] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[1] = 0x80 | (cp & 0x3F);
        cp >>= 6;
        buf[0] = 0xE0 | cp;
    }
    else
        return NULL;
    return buf;
}",129.0,166.0,1.0,1.0,38.0,6,4,5,2,1,0,2,2,0,0,,0,0,4,2,2,char*
1435,89204,vlc_str2keycode,1,vlc_str2keycode,uint_fast32_t vlc_str2keycode (char*),misc\actions.c,"uint_fast32_t vlc_str2keycode (const char *name)
{
    uint_fast32_t mods = 0;
    uint32_t code;

    for (;;)
    {
        size_t len = strcspn (name, ""-+"");
        if (len == 0 || name[len] == '\0')
            break;

        if (len == 4 && !strncasecmp (name, ""Ctrl"", 4))
            mods |= KEY_MODIFIER_CTRL;
        if (len == 3 && !strncasecmp (name, ""Alt"", 3))
            mods |= KEY_MODIFIER_ALT;
        if (len == 5 && !strncasecmp (name, ""Shift"", 5))
            mods |= KEY_MODIFIER_SHIFT;
        if (len == 4 && !strncasecmp (name, ""Meta"", 4))
            mods |= KEY_MODIFIER_META;
        if (len == 7 && !strncasecmp (name, ""Command"", 7))
            mods |= KEY_MODIFIER_COMMAND;

        name += len + 1;
    }

    struct key_descriptor *d = bsearch (name, s_keys, KEYS_COUNT,
                                        sizeof (s_keys[0]), keystrcmp);
    if (d != NULL)
        code = d->i_code;
    else
    if (vlc_towc (name, &code) <= 0)
        code = KEY_UNSET;

   ...",175.0,211.0,1.0,54.0,37.0,34,12,43,13,2,5,11,16,0,0,,0,5,2,1,1,uint_fast32_t
1436,89372,vlc_keycode2str,1,vlc_keycode2str,"char* vlc_keycode2str (uint_fast32_t,bool)",misc\actions.c,"char *vlc_keycode2str (uint_fast32_t code, bool locale)
{
    char *(*tr) (const char *) = locale ? vlc_gettext : nooptext;
    const char *name;
    char *str, buf[5];
    uintptr_t key = code & ~KEY_MODIFIER;

    for (size_t i = 0; i < KEYS_COUNT; i++)
        if (s_keys[i].i_code == key)
        {
            name = s_keys[i].psz;
            goto found;
        }

    if (utf8_cp (key, buf) == NULL)
        return NULL;
    name = buf;

found:
    if (asprintf (&str, ""%s%s%s%s%s%s"",
                  (code & KEY_MODIFIER_CTRL) ? tr(N_(""Ctrl+"")) : """",
                  (code & KEY_MODIFIER_ALT) ? tr(N_(""Alt+"")) : """",
                  (code & KEY_MODIFIER_SHIFT) ? tr(N_(""Shift+"")) : """",
                  (code & KEY_MODIFIER_META) ? tr(N_(""Meta+"")) : """",
                  (code & KEY_MODIFIER_COMMAND) ? tr(N_(""Command+"")) : """",
                  tr(name)) == -1)
        return NULL;
    return str;
}",226.0,254.0,1.0,27.0,29.0,24,11,27,14,0,3,4,4,3,1,,0,3,4,2,2,char*
1437,89848,keycmp,1,keycmp,"int keycmp (void*,void*)",misc\actions.c,"static int keycmp (const void *a, const void *b)
{
    const struct mapping *ka = a, *kb = b;

    return (ka->key < kb->key) ? -1 : (ka->key > kb->key) ? +1 : 0;
}",387.0,392.0,1.0,1.0,6.0,12,7,8,4,0,4,1,1,0,0,,0,4,4,2,2,int
1438,89941,add_mapping,1,add_mapping,"int add_mapping (void**,uint32_t,vlc_action_id_t)",misc\actions.c,"static int add_mapping (void **map, uint32_t keycode, vlc_action_id_t action)
{
    struct mapping *entry = malloc (sizeof (*entry));
    if (entry == NULL)
        return ENOMEM;
    entry->key = keycode;
    entry->action = action;

    struct mapping **pent = tsearch (entry, map, keycmp);
    if (unlikely(pent == NULL))
        return ENOMEM;
    if (*pent != entry)
    {
        free (entry);
        return EEXIST;
    }
    return 0;
}",420.0,437.0,1.0,1.0,18.0,12,6,19,8,3,2,4,4,0,0,,0,2,6,3,3,int
1439,89999,add_wheel_mapping,1,add_wheel_mapping,"void add_wheel_mapping (void**,uint32_t,uint32_t,int)",misc\actions.c,"static void add_wheel_mapping (void **map, uint32_t kmore, uint32_t kless,
                                 int mode)
{
    vlc_action_id_t amore = ACTIONID_NONE, aless = ACTIONID_NONE;

    switch (mode)
    {
        case 0: /* volume up/down */
            amore = ACTIONID_COMBO_VOL_FOV_UP;
            aless = ACTIONID_COMBO_VOL_FOV_DOWN;
            break;
        case 2: /* position latter/earlier */
            amore = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            break;
        case 3: /* position earlier/latter */
            amore = ACTIONID_JUMP_BACKWARD_EXTRASHORT;
            aless = ACTIONID_JUMP_FORWARD_EXTRASHORT;
            break;
    }

    if (amore != ACTIONID_NONE)
        add_mapping (map, kmore, amore);
    if (aless != ACTIONID_NONE)
        add_mapping (map, kless, aless);
}",439.0,464.0,1.0,1.0,26.0,10,2,27,11,2,2,7,4,0,2,,0,0,8,4,4,void
1440,90063,init_action,1,init_action,"void init_action (vlc_object_t*,void**,char*,vlc_action_id_t)",misc\actions.c,"static void init_action (vlc_object_t *obj, void **map,
                            const char *confname, vlc_action_id_t action)
{
    char *keys = var_InheritString (obj, confname);
    if (keys == NULL)
        return;

    for (char *buf, *key = strtok_r (keys, ""\t"", &buf);
         key != NULL;
         key = strtok_r (NULL, ""\t"", &buf))
    {
        uint32_t code = vlc_str2keycode (key);
        if (code == KEY_UNSET)
        {
            msg_Warn (obj, ""Key \""%s\"" unrecognized"", key);
            continue;
        }

        if (add_mapping (map, code, action) == EEXIST)
            msg_Warn (obj, ""Key \""%s\"" bound to multiple actions"", key);
    }
    free (keys);
}",473.0,495.0,1.0,1.0,23.0,8,4,23,11,2,2,6,7,1,2,,0,2,8,4,4,void
1441,90134,libvlc_InternalActionsInit,1,libvlc_InternalActionsInit,int libvlc_InternalActionsInit (libvlc_int_t*),misc\actions.c,"int libvlc_InternalActionsInit (libvlc_int_t *libvlc)
{
    assert(libvlc != NULL);

    vlc_object_t *obj = VLC_OBJECT(libvlc);
    vlc_actions_t *as = malloc (sizeof (*as) + (1 + ACTIONS_COUNT)
                      * sizeof (*as->ppsz_keys));

    if (unlikely(as == NULL))
        return VLC_ENOMEM;
    as->map = NULL;
    as->global_map = NULL;

    var_Create (obj, ""key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""global-key-pressed"", VLC_VAR_INTEGER);
    var_Create (obj, ""key-action"", VLC_VAR_INTEGER);

    /* Initialize from configuration */
    for (size_t i = 0; i < ACTIONS_COUNT; i++)
    {
#ifndef NDEBUG
        if (i > 0
         && strcmp (s_names2actions[i-1].psz, s_names2actions[i].psz) >= 0)
        {
            msg_Err (libvlc, ""key-%s and key-%s are not ordered properly"",
                     s_names2actions[i-1].psz, s_names2actions[i].psz);
            abort ();
        }
#endif
        as->ppsz_keys[i] = s_names2actions[i].psz;

        char name[12 + MAX...",500.0,550.0,1.0,52.0,51.0,73,17,73,14,1,35,4,5,4,10,,0,25,2,1,1,int
1442,90367,libvlc_InternalActionsClean,1,libvlc_InternalActionsClean,void libvlc_InternalActionsClean (libvlc_int_t*),misc\actions.c,"void libvlc_InternalActionsClean (libvlc_int_t *libvlc)
{
    assert(libvlc != NULL);

    vlc_actions_t *as = libvlc_priv(libvlc)->actions;
    if (unlikely(as == NULL))
        return;

    var_DelCallback (libvlc, ""global-key-pressed"", vlc_key_to_action,
                     &as->global_map);
    var_DelCallback (libvlc, ""key-pressed"", vlc_key_to_action, &as->map);

    tdestroy (as->global_map, free);
    tdestroy (as->map, free);
    free (as);
    libvlc_priv(libvlc)->actions = NULL;
}",555.0,571.0,1.0,1.0,17.0,12,5,17,4,1,8,2,2,0,4,,0,5,2,1,1,void
1443,90424,actcmp,1,actcmp,"int actcmp (void*,void*)",misc\actions.c,"static int actcmp(const void *key, const void *ent)
{
    const struct name2action *act = ent;
    return strcmp(key, act->psz);
}",574.0,578.0,1.0,1.0,5.0,2,2,4,3,0,1,1,1,0,0,,0,1,4,2,2,int
1444,90440,vlc_actions_get_id,1,vlc_actions_get_id,vlc_action_id_t vlc_actions_get_id (char*),misc\actions.c,"vlc_action_id_t
vlc_actions_get_id (const char *name)
{
    const struct name2action *act;

    if (strncmp (name, ""key-"", 4))
        return ACTIONID_NONE;
    name += 4;

    act = bsearch(name, s_names2actions, ACTIONS_COUNT, sizeof(*act), actcmp);
    return (act != NULL) ? act->id : ACTIONID_NONE;
}",584.0,595.0,1.0,41.0,12.0,11,9,13,5,0,4,2,2,0,0,,0,4,2,1,1,vlc_action_id_t
1445,90484,vlc_actions_get_keycodes,1,vlc_actions_get_keycodes,"size_t vlc_actions_get_keycodes (vlc_object_t*,char*,bool,uint_fast32_t**)",misc\actions.c,"size_t
vlc_actions_get_keycodes(vlc_object_t *p_obj, const char *psz_key_name,
                        bool b_global, uint_fast32_t **pp_keycodes)
{
    char varname[12 /* ""global-key-"" */ + strlen( psz_key_name )];
    sprintf( varname, ""%skey-%s"", b_global ? ""global-"" : """", psz_key_name );

    *pp_keycodes = NULL;

    char *psz_keys = var_InheritString( p_obj, varname );
    if( psz_keys == NULL )
        return 0;

    size_t i_nb_keycodes = 0;
    for( const char* psz_it = psz_keys; *psz_it; ++psz_it )
    {
        if( *psz_it == '\t' )
            ++i_nb_keycodes;
    }
    ++i_nb_keycodes;
    *pp_keycodes = vlc_alloc( i_nb_keycodes, sizeof( **pp_keycodes ) );
    if( unlikely( !*pp_keycodes ) )
    {
        free( psz_keys );
        return 0;
    }
    size_t i = 0;
    for( char *buf, *key = strtok_r( psz_keys, ""\t"", &buf );
         key != NULL;
         key = strtok_r( NULL, ""\t"", &buf ), ++i )
    {
        (*pp_keycodes)[i] = vlc_str2keycode( key );
    }
    assert(...",598.0,634.0,1.0,1.0,37.0,27,10,35,12,0,1,6,7,0,1,,0,1,8,4,4,size_t
1446,90606,vlc_actions_get_key_names,1,vlc_actions_get_key_names,const char* const* vlc_actions_get_key_names (vlc_object_t*),misc\actions.c,"const char* const*
vlc_actions_get_key_names(vlc_object_t *p_obj)
{
    vlc_actions_t *as = libvlc_priv(p_obj->obj.libvlc)->actions;
    return as->ppsz_keys;
}",637.0,642.0,1.0,1.0,6.0,5,3,3,2,0,2,1,1,0,1,,0,2,2,1,1,const char* const*
1447,90693,LoadLocalStorage,1,LoadLocalStorage,void LoadLocalStorage (addons_manager_t*),misc\addons.c,"static void LoadLocalStorage( addons_manager_t *p_manager )
{
    addons_finder_t *p_finder =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_finder ), ""entries finder"" );
    p_finder->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_finder, ""addons finder"",
                                      ""addons.store.list"", true );
    if( p_module )
    {
        ARRAY_INIT( p_finder->entries );
        p_finder->psz_uri = NULL;
        p_finder->pf_find( p_finder );
        module_unneed( p_finder, p_module );

        MergeSources( p_manager, p_finder->entries.p_elems, p_finder->entries.i_size );

        ARRAY_RESET( p_finder->entries );
    }
    vlc_object_release( p_finder );
}",298.0,318.0,1.0,8.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1448,90698,addon_entry_New,1,addon_entry_New,addon_entry_t addon_entry_New (void),misc\addons.c,"addon_entry_t * addon_entry_New(void)
{
    addon_entry_owner_t *owner = calloc( 1, sizeof(addon_entry_owner_t) );
    if( unlikely(owner == NULL) )
        return NULL;

    atomic_init( &owner->refs, 1 );

    addon_entry_t *p_entry = &owner->entry;
    vlc_mutex_init( &p_entry->lock );
    ARRAY_INIT( p_entry->files );
    return p_entry;
}",77.0,89.0,1.0,1.0,13.0,11,5,11,4,0,1,2,2,0,1,,0,0,2,1,1,addon_entry_t
1449,90742,addon_entry_Hold,1,addon_entry_Hold,addon_entry_t addon_entry_Hold (addon_entry_t*),misc\addons.c,"addon_entry_t * addon_entry_Hold( addon_entry_t * p_entry )
{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    atomic_fetch_add( &owner->refs, 1 );
    return p_entry;
}",91.0,97.0,1.0,1.0,7.0,4,4,4,2,2,0,1,1,0,0,,0,0,2,1,1,addon_entry_t
1450,90761,addon_entry_Release,1,addon_entry_Release,void addon_entry_Release (addon_entry_t*),misc\addons.c,"void addon_entry_Release( addon_entry_t * p_entry )
{
    addon_entry_owner_t *owner = (addon_entry_owner_t *) p_entry;

    if( atomic_fetch_sub(&owner->refs, 1) != 1 )
        return;

    free( p_entry->psz_name );
    free( p_entry->psz_summary );
    free( p_entry->psz_description );
    free( p_entry->psz_archive_uri );
    free( p_entry->psz_author );
    free( p_entry->psz_source_uri );
    free( p_entry->psz_image_uri );
    free( p_entry->psz_image_data );
    free( p_entry->psz_source_module );
    free( p_entry->psz_version );
    free( p_entry->p_custom );

    addon_file_t *p_file;
    FOREACH_ARRAY( p_file, p_entry->files )
    free( p_file->psz_filename );
    free( p_file->psz_download_uri );
    free( p_file );
    FOREACH_END()
    ARRAY_RESET( p_entry->files );

    vlc_mutex_destroy( &p_entry->lock );
    free( owner );
}",99.0,128.0,1.0,1.0,30.0,22,5,22,3,4,1,2,2,0,1,,0,0,2,1,1,void
1451,90857,addons_manager_New,1,addons_manager_New,"addons_manager_t addons_manager_New (vlc_object_t*,addons_manager_owner*)",misc\addons.c,"addons_manager_t *addons_manager_New( vlc_object_t *p_this,
    const struct addons_manager_owner *restrict owner )
{
    addons_manager_t *p_manager = malloc( sizeof(addons_manager_t) );
    if ( !p_manager ) return NULL;

    p_manager->p_priv = malloc( sizeof(addons_manager_private_t) );
    if ( !p_manager->p_priv )
    {
        free( p_manager );
        return NULL;
    }

    p_manager->owner = *owner;
    p_manager->p_priv->p_parent = p_this;

    p_manager->p_priv->finder.p_interrupt = vlc_interrupt_create();
    p_manager->p_priv->installer.p_interrupt = vlc_interrupt_create();
    if ( !p_manager->p_priv->finder.p_interrupt ||
         !p_manager->p_priv->installer.p_interrupt )
    {
        if( p_manager->p_priv->finder.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->finder.p_interrupt );
        if( p_manager->p_priv->installer.p_interrupt )
            vlc_interrupt_destroy( p_manager->p_priv->installer.p_interrupt );
        free( p_manager->p_pr...",130.0,171.0,1.0,4.0,42.0,77,8,36,7,0,8,6,8,0,8,,0,2,4,2,2,addons_manager_t
1452,91068,addons_manager_Delete,1,addons_manager_Delete,void addons_manager_Delete (addons_manager_t*),misc\addons.c,"void addons_manager_Delete( addons_manager_t *p_manager )
{
    bool b_live;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    b_live = p_manager->p_priv->finder.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->finder.p_interrupt );
        vlc_join( p_manager->p_priv->finder.thread, NULL );
    }

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    b_live = p_manager->p_priv->installer.b_live;
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    if ( b_live )
    {
        vlc_interrupt_kill( p_manager->p_priv->installer.p_interrupt );
        vlc_join( p_manager->p_priv->installer.thread, NULL );
    }

#define FREE_QUEUE( name ) \
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->name.entries )\
        addon_entry_Release( p_entry );\
    FOREACH_END();\
    ARRAY_RESET( p_manager->p_priv->name.entries );\
    vlc_mutex_destroy( &p_manager->p_priv->na...",173.0,213.0,1.0,4.0,41.0,76,5,35,5,0,16,3,3,0,16,,0,0,2,1,1,void
1453,91286,addons_manager_Gather,1,addons_manager_Gather,"void addons_manager_Gather (addons_manager_t*,char*)",misc\addons.c,"void addons_manager_Gather( addons_manager_t *p_manager, const char *psz_uri )
{
    if ( !psz_uri )
        return;

    vlc_mutex_lock( &p_manager->p_priv->finder.lock );

    ARRAY_APPEND( p_manager->p_priv->finder.uris, strdup( psz_uri ) );

    if( !p_manager->p_priv->finder.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->finder.thread, FinderThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn entries provider thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
            return;
        }
        p_manager->p_priv->finder.b_live = true;
    }

    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
}",215.0,239.0,1.0,1.0,25.0,34,5,15,5,0,5,4,5,1,5,,0,1,4,2,2,void
1454,91384,getHeldEntryByUUID,1,getHeldEntryByUUID,"addon_entry_t getHeldEntryByUUID (addons_manager_t*,addon_uuid_t)",misc\addons.c,"static addon_entry_t * getHeldEntryByUUID( addons_manager_t *p_manager,
                                           const addon_uuid_t uuid )
{
    addon_entry_t *p_return = NULL;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    FOREACH_ARRAY( addon_entry_t *p_entry, p_manager->p_priv->finder.entries )
    if ( !memcmp( p_entry->uuid, uuid, sizeof( addon_uuid_t ) ) )
    {
        p_return = p_entry;
        addon_entry_Hold( p_return );
        break;
    }
    FOREACH_END()
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
    return p_return;
}",245.0,260.0,1.0,1.0,16.0,17,7,14,7,2,3,3,2,0,3,,0,0,4,2,2,addon_entry_t
1455,91444,MergeSources,1,MergeSources,"void MergeSources (addons_manager_t*,addon_entry_t**,int)",misc\addons.c,"static void MergeSources( addons_manager_t *p_manager,
                          addon_entry_t **pp_addons, int i_count )
{
    addon_entry_t *p_entry, *p_manager_entry;
    addon_uuid_t zerouuid;
    memset( zerouuid, 0, sizeof( addon_uuid_t ) );
    for ( int i=0; i < i_count; i++ )
    {
        p_entry = pp_addons[i];
        vlc_mutex_lock( &p_entry->lock );
        if ( memcmp( p_entry->uuid, zerouuid, sizeof( addon_uuid_t ) ) )
            p_manager_entry = getHeldEntryByUUID( p_manager, p_entry->uuid );
        else
            p_manager_entry = NULL;
        if ( !p_manager_entry )
        {
            ARRAY_APPEND( p_manager->p_priv->finder.entries, p_entry );
            p_manager->owner.addon_found( p_manager, p_entry );
        }
        else
        {
            vlc_mutex_lock( &p_manager_entry->lock );
            if ( ( p_manager_entry->psz_version && p_entry->psz_version )
                 && /* FIXME: better version comparison */
                 strcmp( p_manage...",262.0,296.0,1.0,1.0,35.0,19,8,22,8,0,3,4,6,0,3,,0,1,6,3,3,void
1456,91643,finder_thread_interrupted,1,finder_thread_interrupted,void finder_thread_interrupted (void*),misc\addons.c,"static void finder_thread_interrupted( void* p_data )
{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->finder.lock );
    p_manager->p_priv->finder.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->finder.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
}",320.0,327.0,1.0,1.0,8.0,17,4,7,3,0,3,1,1,0,3,,0,0,2,1,1,void
1457,91922,addons_manager_WriteCatalog,1,addons_manager_WriteCatalog,int addons_manager_WriteCatalog (addons_manager_t*),misc\addons.c,"static int addons_manager_WriteCatalog( addons_manager_t *p_manager )
{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        vlc_mutex_lock( &p_manager->p_priv->finder.lock );
        i_return = p_storage->pf_catalog( p_storage, p_manager->p_priv->finder.entries.p_elems,
                                          p_manager->p_priv->finder.entries.i_size );
        vlc_mutex_unlock( &p_manager->p_priv->finder.lock );
        module_unneed( p_storage, p_module );
    }
    vlc_object_release( p_storage );

    return i_return;
}",386.0,407.0,1.0,8.0,22.0,29,6,23,7,1,6,2,2,0,6,,0,2,2,1,1,int
1458,92020,addons_manager_LoadCatalog,1,addons_manager_LoadCatalog,int addons_manager_LoadCatalog (addons_manager_t*),misc\addons.c,"int addons_manager_LoadCatalog( addons_manager_t *p_manager )
{
    LoadLocalStorage( p_manager );
    return VLC_SUCCESS;
}",409.0,413.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
1459,92029,installOrRemoveAddon,1,installOrRemoveAddon,"int installOrRemoveAddon (addons_manager_t*,addon_entry_t*,bool)",misc\addons.c,"static int installOrRemoveAddon( addons_manager_t *p_manager, addon_entry_t *p_entry, bool b_install )
{
    int i_return = VLC_EGENERIC;

    addons_storage_t *p_storage =
        vlc_custom_create( p_manager->p_priv->p_parent, sizeof( *p_storage ), ""entries storage"" );
    p_storage->obj.flags |= OBJECT_FLAGS_NOINTERACT;

    module_t *p_module = module_need( p_storage, ""addons storage"",
                                      ""addons.store.install"", true );
    if( p_module )
    {
        if ( b_install )
            i_return = p_storage->pf_install( p_storage, p_entry );
        else
            i_return = p_storage->pf_remove( p_storage, p_entry );
        module_unneed( p_storage, p_module );
        msg_Dbg( p_manager->p_priv->p_parent, ""InstallAddon returns %d"", i_return );
        if ( i_return == VLC_SUCCESS )
        {
            /* Reset flags */
            vlc_mutex_lock( &p_entry->lock );
            p_entry->e_flags = ADDON_MANAGEABLE;
            vlc_mutex_unlock( &...",415.0,444.0,1.0,8.0,30.0,22,7,29,11,1,6,4,6,0,6,,0,2,6,3,3,int
1460,92135,installer_thread_interrupted,1,installer_thread_interrupted,void installer_thread_interrupted (void*),misc\addons.c,"static void installer_thread_interrupted( void* p_data )
{
    addons_manager_t *p_manager = p_data;
    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    p_manager->p_priv->installer.b_live = false;
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
}",446.0,453.0,1.0,1.0,8.0,17,4,7,3,0,3,1,1,0,3,,0,0,2,1,1,void
1461,92180,InstallerThread,1,InstallerThread,void* InstallerThread (void*),misc\addons.c,"static void *InstallerThread( void *p_data )
{
    addons_manager_t *p_manager = p_data;
    int i_cancel = vlc_savecancel();
    vlc_interrupt_set( p_manager->p_priv->installer.p_interrupt );
    int i_ret;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    while( p_manager->p_priv->installer.b_live )
    {
        vlc_interrupt_register( installer_thread_interrupted, p_data );
        while ( !p_manager->p_priv->installer.entries.i_size &&
                p_manager->p_priv->installer.b_live )
        {
            /* No queued addons */
            vlc_cond_wait( &p_manager->p_priv->installer.waitcond,
                           &p_manager->p_priv->installer.lock );
        }
        vlc_interrupt_unregister();
        if( !p_manager->p_priv->installer.b_live )
            break;

        addon_entry_t *p_entry = p_manager->p_priv->installer.entries.p_elems[0];
        ARRAY_REMOVE( p_manager->p_priv->installer.entries, 0 );
        addon_entry_Hold( p_entry );
       ...",455.0,525.0,1.0,1.0,71.0,75,9,46,11,0,18,6,8,0,18,,0,2,2,1,1,void*
1462,92444,InstallEntry,1,InstallEntry,"int InstallEntry (addons_manager_t*,addon_entry_t*)",misc\addons.c,"static int InstallEntry( addons_manager_t *p_manager, addon_entry_t *p_entry )
{
    if ( p_entry->e_type == ADDON_UNKNOWN ||
         p_entry->e_type == ADDON_PLUGIN ||
         p_entry->e_type == ADDON_OTHER )
        return VLC_EBADVAR;

    vlc_mutex_lock( &p_manager->p_priv->installer.lock );
    ARRAY_APPEND( p_manager->p_priv->installer.entries, p_entry );
    if( !p_manager->p_priv->installer.b_live )
    {
        if( vlc_clone( &p_manager->p_priv->installer.thread, InstallerThread, p_manager,
                       VLC_THREAD_PRIORITY_LOW ) )
        {
            msg_Err( p_manager->p_priv->p_parent,
                     ""cannot spawn addons installer thread"" );
            vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
            return VLC_EGENERIC;
        }
        else
            p_manager->p_priv->installer.b_live = true;
    }
    vlc_mutex_unlock( &p_manager->p_priv->installer.lock );
    vlc_cond_signal( &p_manager->p_priv->installer.waitcond );
    re...",527.0,552.0,1.0,1.0,26.0,37,6,20,9,1,5,4,5,1,5,,0,1,4,2,2,int
1463,92562,addons_manager_Install,1,addons_manager_Install,"int addons_manager_Install (addons_manager_t*,addon_uuid_t)",misc\addons.c,"int addons_manager_Install( addons_manager_t *p_manager, const addon_uuid_t uuid )
{
    addon_entry_t *p_install_entry = getHeldEntryByUUID( p_manager, uuid );
    if ( ! p_install_entry ) return VLC_EGENERIC;
    int i_ret = InstallEntry( p_manager, p_install_entry );
    addon_entry_Release( p_install_entry );
    return i_ret;
}",554.0,561.0,1.0,1.0,8.0,3,2,10,5,1,3,2,2,0,3,,0,2,4,2,2,int
1464,92590,addons_manager_Remove,1,addons_manager_Remove,"int addons_manager_Remove (addons_manager_t*,addon_uuid_t)",misc\addons.c,"int addons_manager_Remove( addons_manager_t *p_manager, const addon_uuid_t uuid )
{
    return addons_manager_Install( p_manager, uuid );
}",563.0,566.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
1465,92640,Thread,1,Thread,void* Thread (void*),video_output\video_output.c,"static void *Thread(void *object)
{
    vout_thread_t *vout = object;
    vout_thread_sys_t *sys = vout->p;

    mtime_t deadline = VLC_TS_INVALID;
    bool wait = false;
    for (;;) {
        vout_control_cmd_t cmd;

        if (wait)
        {
            const mtime_t max_deadline = mdate() + 100000;
            deadline = deadline <= VLC_TS_INVALID ? max_deadline : __MIN(deadline, max_deadline);
        } else {
            deadline = VLC_TS_INVALID;
        }
        while (!vout_control_Pop(&sys->control, &cmd, deadline))
            if (ThreadControl(vout, cmd))
                return NULL;

        deadline = VLC_TS_INVALID;
        wait = ThreadDisplayPicture(vout, &deadline) != VLC_SUCCESS;

        const bool picture_interlaced = sys->displayed.is_interlaced;

        vout_SetInterlacingState(vout, picture_interlaced);
        vout_ManageWrapper(vout);
    }
}",1789.0,1818.0,1.0,1.0,30.0,94,14,63,8,0,39,16,29,9,17,,0,27,2,1,1,void*
1466,92975,BackgroundWorkerCancel,1,BackgroundWorkerCancel,"void BackgroundWorkerCancel (background_worker*,void*)",misc\background_worker.c,"static void BackgroundWorkerCancel( struct background_worker* worker, void* id)
{
    vlc_mutex_lock( &worker->lock );
    for( size_t i = 0; i < vlc_array_count( &worker->tail.data ); )
    {
        struct bg_queued_item* item =
            vlc_array_item_at_index( &worker->tail.data, i );

        if( id == NULL || item->id == id )
        {
            vlc_array_remove( &worker->tail.data, i );
            worker->conf.pf_release( item->entity );
            free( item );
            continue;
        }

        ++i;
    }

    while( ( id == NULL && worker->head.active )
        || ( id != NULL && worker->head.id == id ) )
    {
        worker->head.deadline = VLC_TS_0;
        vlc_cond_signal( &worker->head.worker_wait );
        vlc_cond_signal( &worker->tail.wait );
        vlc_cond_wait( &worker->head.wait, &worker->lock );
    }
    vlc_mutex_unlock( &worker->lock );
}",154.0,182.0,1.0,1.0,29.0,48,10,31,6,2,12,5,5,1,6,,0,6,4,2,2,void
1467,93106,background_worker_New,1,background_worker_New,"struct background_worker background_worker_New (void*,background_worker_config*)",misc\background_worker.c,"struct background_worker* background_worker_New( void* owner,
    struct background_worker_config* conf )
{
    struct background_worker* worker = malloc( sizeof *worker );

    if( unlikely( !worker ) )
        return NULL;

    worker->conf = *conf;
    worker->owner = owner;
    worker->head.id = NULL;
    worker->head.active = false;
    worker->head.deadline = VLC_TS_INVALID;

    vlc_mutex_init( &worker->lock );
    vlc_cond_init( &worker->head.wait );
    vlc_cond_init( &worker->head.worker_wait );

    vlc_array_init( &worker->tail.data );
    vlc_cond_init( &worker->tail.wait );

    return worker;
}",184.0,206.0,1.0,1.0,23.0,32,7,20,6,2,7,2,2,0,4,,0,3,4,2,2,struct background_worker
1468,93193,background_worker_Push,1,background_worker_Push,"int background_worker_Push (background_worker*,void*,void*,int)",misc\background_worker.c,"int background_worker_Push( struct background_worker* worker, void* entity,
                        void* id, int timeout )
{
    struct bg_queued_item* item = malloc( sizeof( *item ) );

    if( unlikely( !item ) )
        return VLC_EGENERIC;

    item->id = id;
    item->entity = entity;
    item->timeout = timeout < 0 ? worker->conf.default_timeout : timeout;

    vlc_mutex_lock( &worker->lock );
    int i_ret = vlc_array_append( &worker->tail.data, item );
    vlc_cond_signal( &worker->tail.wait );
    if( i_ret != 0 )
    {
        free( item );
        return VLC_EGENERIC;
    }

    if( worker->head.active == false )
    {
        worker->head.probe_request = false;
        worker->head.active =
            !vlc_clone_detach( NULL, Thread, worker, VLC_THREAD_PRIORITY_LOW );
    }

    if( worker->head.active )
        worker->conf.pf_hold( item->entity );

    int ret = worker->head.active ? VLC_SUCCESS : VLC_EGENERIC;
    vlc_mutex_unlock( &worker->lock );

    return ret;
}",208.0,243.0,1.0,1.0,36.0,45,11,37,12,4,13,5,5,0,5,,0,9,8,4,4,int
1469,93333,background_worker_Cancel,1,background_worker_Cancel,"void background_worker_Cancel (background_worker*,void*)",misc\background_worker.c,"void background_worker_Cancel( struct background_worker* worker, void* id )
{
    BackgroundWorkerCancel( worker, id );
}",245.0,248.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,void
1470,93342,background_worker_RequestProbe,1,background_worker_RequestProbe,void background_worker_RequestProbe (background_worker*),misc\background_worker.c,"void background_worker_RequestProbe( struct background_worker* worker )
{
    vlc_mutex_lock( &worker->lock );
    worker->head.probe_request = true;
    vlc_cond_signal( &worker->head.worker_wait );
    vlc_mutex_unlock( &worker->lock );
}",250.0,256.0,1.0,1.0,7.0,10,4,5,2,1,5,1,1,0,3,,0,2,2,1,1,void
1471,93371,background_worker_Delete,1,background_worker_Delete,void background_worker_Delete (background_worker*),misc\background_worker.c,"void background_worker_Delete( struct background_worker* worker )
{
    BackgroundWorkerCancel( worker, NULL );
    vlc_array_clear( &worker->tail.data );
    vlc_mutex_destroy( &worker->lock );
    vlc_cond_destroy( &worker->head.wait );
    vlc_cond_destroy( &worker->head.worker_wait );
    vlc_cond_destroy( &worker->tail.wait );
    free( worker );
}",258.0,267.0,1.0,1.0,10.0,14,3,8,2,7,6,1,1,0,5,,0,1,2,1,1,void
1472,93421,pf_release,1,background_worker_config.pf_release,void background_worker_config.pf_release (void*),misc\background_worker.h,void( *pf_release )( void* entity );,42.0,42.0,9.0,39.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1473,93426,pf_hold,1,background_worker_config.pf_hold,void background_worker_config.pf_hold (void*),misc\background_worker.h,void( *pf_hold )( void* entity );,53.0,53.0,9.0,36.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1474,93431,pf_start,1,background_worker_config.pf_start,"int background_worker_config.pf_start (void*,void*,void**)",misc\background_worker.h,"int( *pf_start )( void* owner, void* entity, void** out );",72.0,72.0,8.0,61.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
1475,93438,pf_probe,1,background_worker_config.pf_probe,"int background_worker_config.pf_probe (void*,void*)",misc\background_worker.h,"int( *pf_probe )( void* owner, void* handle );",85.0,85.0,8.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1476,93444,pf_stop,1,background_worker_config.pf_stop,"void background_worker_config.pf_stop (void*,void*)",misc\background_worker.h,"void( *pf_stop )( void* owner, void* handle );",101.0,101.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1477,93517,block_Check,1,block_Check,void block_Check (block_t*),misc\block.c,"static void block_Check (block_t *block)
{
    while (block != NULL)
    {
        unsigned char *start = block->p_start;
        unsigned char *end = block->p_start + block->i_size;
        unsigned char *bufstart = block->p_buffer;
        unsigned char *bufend = block->p_buffer + block->i_buffer;

        assert (block->pf_release != BlockNoRelease);
        assert (start <= end);
        assert (bufstart <= bufend);
        assert (bufstart >= start);
        assert (bufend <= end);

        block = block->p_next;
    }
}",46.0,63.0,1.0,1.0,18.0,21,6,23,6,2,0,2,2,0,0,,0,0,2,1,1,void
1478,93586,block_Invalidate,1,block_Invalidate,void block_Invalidate (block_t*),misc\block.c,"static void block_Invalidate (block_t *block)
{
    block->p_next = NULL;
    block_Check (block);
    block->pf_release = BlockNoRelease;
}",65.0,70.0,1.0,1.0,6.0,4,2,4,2,2,1,1,1,0,1,,0,0,2,1,1,void
1479,93603,block_Init,1,block_Init,"void block_Init (block_t*,void*,size_t)",misc\block.c,"void block_Init( block_t *restrict b, void *buf, size_t size )
{
    /* Fill all fields to their default */
    b->p_next = NULL;
    b->p_buffer = buf;
    b->i_buffer = size;
    b->p_start = buf;
    b->i_size = size;
    b->i_flags = 0;
    b->i_nb_samples = 0;
    b->i_pts =
    b->i_dts = VLC_TS_INVALID;
    b->i_length = 0;
#ifndef NDEBUG
    b->pf_release = BlockNoRelease;
#endif
}",76.0,92.0,1.0,1.0,17.0,22,2,17,5,2,0,1,1,0,0,,0,0,6,3,3,void
1480,93664,block_generic_Release,1,block_generic_Release,void block_generic_Release (block_t*),misc\block.c,"static void block_generic_Release (block_t *block)
{
    /* That is always true for blocks allocated with block_Alloc(). */
    assert (block->p_start == (unsigned char *)(block + 1));
    block_Invalidate (block);
    free (block);
}",94.0,100.0,1.0,1.0,7.0,4,4,4,1,0,1,1,1,0,1,,0,0,2,1,1,void
1481,93683,BlockMetaCopy,1,BlockMetaCopy,"void BlockMetaCopy (block_t*,block_t*)",misc\block.c,"static void BlockMetaCopy( block_t *restrict out, const block_t *in )
{
    out->p_next    = in->p_next;
    out->i_nb_samples = in->i_nb_samples;
    out->i_dts     = in->i_dts;
    out->i_pts     = in->i_pts;
    out->i_flags   = in->i_flags;
    out->i_length  = in->i_length;
}",102.0,110.0,1.0,1.0,9.0,18,2,12,2,2,0,1,1,0,0,,0,0,4,2,2,void
1482,93731,block_Alloc,1,block_Alloc,block_t block_Alloc (size_t),misc\block.c,"block_t *block_Alloc (size_t size)
{
    if (unlikely(size >> 27))
    {
        errno = ENOBUFS;
        return NULL;
    }

    /* 2 * BLOCK_PADDING: pre + post padding */
    const size_t alloc = sizeof (block_t) + BLOCK_ALIGN + (2 * BLOCK_PADDING)
                       + size;
    if (unlikely(alloc <= size))
        return NULL;

    block_t *b = malloc (alloc);
    if (unlikely(b == NULL))
        return NULL;

    block_Init (b, b + 1, alloc - sizeof (*b));
    static_assert ((BLOCK_PADDING % BLOCK_ALIGN) == 0,
                   ""BLOCK_PADDING must be a multiple of BLOCK_ALIGN"");
    b->p_buffer += BLOCK_PADDING + BLOCK_ALIGN - 1;
    b->p_buffer = (void *)(((uintptr_t)b->p_buffer) & ~(BLOCK_ALIGN - 1));
    b->i_buffer = size;
    b->pf_release = block_generic_Release;
    return b;
}",120.0,146.0,1.0,44.0,27.0,33,15,26,7,8,1,4,4,0,1,,0,0,2,1,1,block_t
1483,93849,block_TryRealloc,1,block_TryRealloc,"block_t block_TryRealloc (block_t*,ssize_t,size_t)",misc\block.c,"block_t *block_TryRealloc (block_t *p_block, ssize_t i_prebody, size_t i_body)
{
    block_Check( p_block );

    /* Corner case: empty block requested */
    if( i_prebody <= 0 && i_body <= (size_t)(-i_prebody) )
        i_prebody = i_body = 0;

    assert( p_block->p_start <= p_block->p_buffer );
    assert( p_block->p_start + p_block->i_size
                                    >= p_block->p_buffer + p_block->i_buffer );

    /* First, shrink payload */

    /* Pull payload start */
    if( i_prebody < 0 )
    {
        if( p_block->i_buffer >= (size_t)-i_prebody )
        {
            p_block->p_buffer -= i_prebody;
            p_block->i_buffer += i_prebody;
        }
        else /* Discard current payload entirely */
            p_block->i_buffer = 0;
        i_body += i_prebody;
        i_prebody = 0;
    }

    /* Trim payload end */
    if( p_block->i_buffer > i_body )
        p_block->i_buffer = i_body;

    size_t requested = i_prebody + i_body;

    if( p_block->i_buffe...",148.0,237.0,1.0,1.0,90.0,77,16,87,10,1,5,11,15,0,5,,0,2,6,3,3,block_t
1484,94110,block_Realloc,1,block_Realloc,"block_t block_Realloc (block_t*,ssize_t,size_t)",misc\block.c,"block_t *block_Realloc (block_t *block, ssize_t prebody, size_t body)
{
    block_t *rea = block_TryRealloc (block, prebody, body);
    if (rea == NULL)
        block_Release(block);
    return rea;
}",239.0,245.0,1.0,1.0,7.0,2,2,8,5,0,1,2,2,0,1,,0,1,6,3,3,block_t
1485,94133,block_heap_Release,1,block_heap_Release,void block_heap_Release (block_t*),misc\block.c,"static void block_heap_Release (block_t *block)
{
    block_Invalidate (block);
    free (block->p_start);
    free (block);
}",247.0,252.0,1.0,1.0,6.0,1,1,3,1,0,1,1,1,0,1,,0,0,2,1,1,void
1486,94146,block_heap_Alloc,1,block_heap_Alloc,"block_t block_heap_Alloc (void*,size_t)",misc\block.c,"block_t *block_heap_Alloc (void *addr, size_t length)
{
    block_t *block = malloc (sizeof (*block));
    if (block == NULL)
    {
        free (addr);
        return NULL;
    }

    block_Init (block, addr, length);
    block->pf_release = block_heap_Release;
    return block;
}",254.0,266.0,1.0,1.0,13.0,6,5,11,4,0,1,2,2,0,1,,0,0,4,2,2,block_t
1487,94206,block_File,1,block_File,"block_t block_File (int,bool)",misc\block.c,"block_t *block_File(int fd, bool write)
{
    size_t length;
    struct stat st;

    /* First, get the file size */
    if (fstat (fd, &st))
        return NULL;

    /* st_size is meaningful for regular files, shared memory and typed memory.
     * It's also meaning for symlinks, but that's not possible with fstat().
     * In other cases, it's undefined, and we should really not go further. */
#ifndef S_TYPEISSHM
# define S_TYPEISSHM( buf ) (0)
#endif
    if (S_ISDIR (st.st_mode))
    {
        errno = EISDIR;
        return NULL;
    }
    if (!S_ISREG (st.st_mode) && !S_TYPEISSHM (&st))
    {
        errno = ESPIPE;
        return NULL;
    }

    /* Prevent an integer overflow in mmap() and malloc() */
    if ((uintmax_t)st.st_size >= SIZE_MAX)
    {
        errno = ENOMEM;
        return NULL;
    }
    length = (size_t)st.st_size;

#ifdef HAVE_MMAP
    if (length > 0)
    {
        int prot = PROT_READ | (write ? PROT_WRITE : 0);
        int flags = write ? MAP_PRIVATE : MAP...",368.0,433.0,1.0,34.0,66.0,27,14,41,12,1,1,9,9,0,1,,0,1,4,2,2,block_t
1488,94327,block_FilePath,1,block_FilePath,"block_t block_FilePath (char*,bool)",misc\block.c,"block_t *block_FilePath(const char *path, bool write)
{
    /* NOTE: Writeable shared mappings are not supported here. So there are no
     * needs to open the file for writing (even if the mapping is writable). */
    int fd = vlc_open (path, O_RDONLY);
    if (fd == -1)
        return NULL;

    block_t *block = block_File(fd, write);
    vlc_close (fd);
    return block;
}",435.0,446.0,1.0,1.0,12.0,4,3,10,6,0,3,2,2,0,3,,0,2,4,2,2,block_t
1489,94459,vlc_epg_event_Clean,1,vlc_epg_event_Clean,void vlc_epg_event_Clean (vlc_epg_event_t*),misc\epg.c,"static void vlc_epg_event_Clean(vlc_epg_event_t *p_event)
{
    for(int i=0; i<p_event->i_description_items; i++)
    {
        free(p_event->description_items[i].psz_key);
        free(p_event->description_items[i].psz_value);
    }
    free(p_event->description_items);
    free(p_event->psz_description);
    free(p_event->psz_short_description);
    free(p_event->psz_name);
}",35.0,46.0,1.0,1.0,12.0,13,5,11,2,1,0,2,2,0,0,,0,0,2,1,1,void
1490,94510,vlc_epg_event_Delete,1,vlc_epg_event_Delete,void vlc_epg_event_Delete (vlc_epg_event_t*),misc\epg.c,"void vlc_epg_event_Delete(vlc_epg_event_t *p_event)
{
    vlc_epg_event_Clean(p_event);
    free(p_event);
}",48.0,52.0,1.0,1.0,5.0,0,0,2,1,3,1,1,1,0,1,,0,0,2,1,1,void
1491,94519,vlc_epg_event_Init,1,vlc_epg_event_Init,"void vlc_epg_event_Init (vlc_epg_event_t*,uint16_t,int64_t,uint32_t)",misc\epg.c,"static void vlc_epg_event_Init(vlc_epg_event_t *p_event, uint16_t i_id,
                               int64_t i_start, uint32_t i_duration)
{
    memset(p_event, 0, sizeof(*p_event));
    p_event->i_start = i_start;
    p_event->i_id = i_id;
    p_event->i_duration = i_duration;
    p_event->i_description_items = 0;
    p_event->description_items = NULL;
}",54.0,63.0,1.0,1.0,10.0,12,4,11,5,1,0,1,1,0,0,,0,0,8,4,4,void
1492,94558,vlc_epg_event_New,1,vlc_epg_event_New,"vlc_epg_event_t vlc_epg_event_New (uint16_t,int64_t,uint32_t)",misc\epg.c,"vlc_epg_event_t * vlc_epg_event_New(uint16_t i_id,
                                    int64_t i_start, uint32_t i_duration)
{
    vlc_epg_event_t *p_event = (vlc_epg_event_t *) malloc(sizeof(*p_event));
    if(p_event)
        vlc_epg_event_Init(p_event, i_id, i_start, i_duration);

    return p_event;
}",65.0,73.0,1.0,1.0,9.0,4,4,8,4,1,1,2,2,0,1,,0,0,6,3,3,vlc_epg_event_t
1493,94584,vlc_epg_event_Duplicate,1,vlc_epg_event_Duplicate,vlc_epg_event_t vlc_epg_event_Duplicate (vlc_epg_event_t*),misc\epg.c,"vlc_epg_event_t * vlc_epg_event_Duplicate( const vlc_epg_event_t *p_src )
{
    vlc_epg_event_t *p_evt = vlc_epg_event_New( p_src->i_id, p_src->i_start,
                                                p_src->i_duration );
    if( likely(p_evt) )
    {
        if( p_src->psz_description )
            p_evt->psz_description = strdup( p_src->psz_description );
        if( p_src->psz_name )
            p_evt->psz_name = strdup( p_src->psz_name );
        if( p_src->psz_short_description )
            p_evt->psz_short_description = strdup( p_src->psz_short_description );
        if( p_src->i_description_items )
        {
            p_evt->description_items = malloc( sizeof(*p_evt->description_items) *
                                               p_src->i_description_items );
            if( p_evt->description_items )
            {
                for( int i=0; i<p_src->i_description_items; i++ )
                {
                    p_evt->description_items[i].psz_key =
              ...",75.0,113.0,1.0,1.0,39.0,62,11,42,3,3,1,10,22,0,1,,0,1,2,1,1,vlc_epg_event_t
1494,94764,vlc_epg_Init,1,vlc_epg_Init,"void vlc_epg_Init (vlc_epg_t*,uint32_t,uint16_t)",misc\epg.c,"static void vlc_epg_Init( vlc_epg_t *p_epg, uint32_t i_id, uint16_t i_source_id )
{
    p_epg->i_id = i_id;
    p_epg->i_source_id = i_source_id;
    p_epg->psz_name = NULL;
    p_epg->p_current = NULL;
    p_epg->b_present = false;
    TAB_INIT( p_epg->i_event, p_epg->pp_event );
}",115.0,123.0,1.0,1.0,9.0,12,2,12,5,1,0,1,1,0,0,,0,0,6,3,3,void
1495,94803,vlc_epg_Clean,1,vlc_epg_Clean,void vlc_epg_Clean (vlc_epg_t*),misc\epg.c,"static void vlc_epg_Clean( vlc_epg_t *p_epg )
{
    size_t i;
    for( i = 0; i < p_epg->i_event; i++ )
        vlc_epg_event_Delete( p_epg->pp_event[i] );
    TAB_CLEAN( p_epg->i_event, p_epg->pp_event );
    free( p_epg->psz_name );
}",125.0,132.0,1.0,1.0,8.0,6,3,6,2,1,0,2,2,0,0,,0,0,2,1,1,void
1496,94838,vlc_epg_AddEvent,1,vlc_epg_AddEvent,"bool vlc_epg_AddEvent (vlc_epg_t*,vlc_epg_event_t*)",misc\epg.c,"bool vlc_epg_AddEvent( vlc_epg_t *p_epg, vlc_epg_event_t *p_evt )
{
    ssize_t i_pos = -1;

    /* Insertions are supposed in sequential order first */
    if( p_epg->i_event )
    {
        if( p_epg->pp_event[0]->i_start > p_evt->i_start )
        {
            i_pos = 0;
        }
        else if ( p_epg->pp_event[p_epg->i_event - 1]->i_start >= p_evt->i_start )
        {
            /* Do bisect search lower start time entry */
            size_t i_lower = 0;
            size_t i_upper = p_epg->i_event - 1;

            while( i_lower < i_upper )
            {
                size_t i_split = ( i_lower + i_upper ) / 2;
                vlc_epg_event_t *p_cur = p_epg->pp_event[i_split];

                if( p_cur->i_start < p_evt->i_start )
                {
                    i_lower = i_split + 1;
                }
                else if ( p_cur->i_start >= p_evt->i_start )
                {
                    i_upper = i_split;
                }
            }
            i_...",134.0,189.0,1.0,1.0,56.0,27,7,21,4,2,1,6,10,0,1,,0,0,4,2,2,bool
1497,95026,vlc_epg_New,1,vlc_epg_New,"vlc_epg_t vlc_epg_New (uint32_t,uint16_t)",misc\epg.c,"vlc_epg_t *vlc_epg_New( uint32_t i_id, uint16_t i_source_id )
{
    vlc_epg_t *p_epg = malloc( sizeof(*p_epg) );
    if( p_epg )
        vlc_epg_Init( p_epg, i_id, i_source_id );
    return p_epg;
}",191.0,197.0,1.0,1.0,7.0,3,3,7,3,2,1,2,2,0,1,,0,0,4,2,2,vlc_epg_t
1498,95048,vlc_epg_Delete,1,vlc_epg_Delete,void vlc_epg_Delete (vlc_epg_t*),misc\epg.c,"void vlc_epg_Delete( vlc_epg_t *p_epg )
{
    vlc_epg_Clean( p_epg );
    free( p_epg );
}",199.0,203.0,1.0,1.0,5.0,0,0,2,1,3,1,1,1,0,1,,0,0,2,1,1,void
1499,95109,vlc_epg_Duplicate,1,vlc_epg_Duplicate,vlc_epg_t vlc_epg_Duplicate (vlc_epg_t*),misc\epg.c,"vlc_epg_t * vlc_epg_Duplicate( const vlc_epg_t *p_src )
{
    vlc_epg_t *p_epg = vlc_epg_New( p_src->i_id, p_src->i_source_id );
    if( p_epg )
    {
        p_epg->psz_name = ( p_src->psz_name ) ? strdup( p_src->psz_name ) : NULL;
        p_epg->b_present = p_src->b_present;
        for( size_t i=0; i<p_src->i_event; i++ )
        {
            vlc_epg_event_t *p_dup = vlc_epg_event_Duplicate( p_src->pp_event[i] );
            if( p_dup )
            {
                if( p_src->p_current == p_src->pp_event[i] )
                    p_epg->p_current = p_dup;
                TAB_APPEND( p_epg->i_event, p_epg->pp_event, p_dup );
            }
        }
    }
    return p_epg;
}",222.0,241.0,1.0,1.0,20.0,25,6,26,5,0,2,5,11,0,2,,0,2,2,1,1,vlc_epg_t
1500,95264,BinaryLog,1,BinaryLog,int BinaryLog (uint32_t),misc\es_format.c,"static int BinaryLog( uint32_t i )
{
    int i_log = 0;

    if( i == 0 ) return -31337;

    if( i & 0xffff0000 ) i_log += 16;
    if( i & 0xff00ff00 ) i_log += 8;
    if( i & 0xf0f0f0f0 ) i_log += 4;
    if( i & 0xcccccccc ) i_log += 2;
    if( i & 0xaaaaaaaa ) i_log += 1;

    return i_log;
}",44.0,57.0,1.0,1.0,14.0,13,5,13,2,2,0,7,7,0,0,,0,0,2,1,1,int
1501,95323,MaskToShift,1,MaskToShift,"void MaskToShift (int*,int*,uint32_t)",misc\es_format.c,"static void MaskToShift( int *pi_left, int *pi_right, uint32_t i_mask )
{
    uint32_t i_low, i_high;            /* lower and higher bits of the mask */

    if( !i_mask )
    {
        *pi_left = *pi_right = 0;
        return;
    }

    /* Get bits */
    i_low = i_high = i_mask;

    i_low &= - (int32_t)i_low;          /* lower bit of the mask */
    i_high += i_low;                    /* higher bit of the mask */

    /* Transform bits into an index. Also deal with i_high overflow, which
     * is faster than changing the BinaryLog code to handle 64 bit integers. */
    i_low =  BinaryLog (i_low);
    i_high = i_high ? BinaryLog (i_high) : 32;

    /* Update pointers and return */
    *pi_left =   i_low;
    *pi_right = (8 - i_high + i_low);
}",63.0,87.0,1.0,1.0,25.0,19,9,20,5,3,2,2,2,0,2,,0,2,6,3,3,void
1502,95381,video_format_FixRgb,1,video_format_FixRgb,void video_format_FixRgb (video_format_t*),misc\es_format.c,"void video_format_FixRgb( video_format_t *p_fmt )
{
    /* FIXME find right default mask */
    if( !p_fmt->i_rmask || !p_fmt->i_gmask || !p_fmt->i_bmask )
    {
        switch( p_fmt->i_chroma )
        {
        case VLC_CODEC_RGB15:
            p_fmt->i_rmask = 0x7c00;
            p_fmt->i_gmask = 0x03e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB16:
            p_fmt->i_rmask = 0xf800;
            p_fmt->i_gmask = 0x07e0;
            p_fmt->i_bmask = 0x001f;
            break;

        case VLC_CODEC_RGB24:
            p_fmt->i_rmask = 0xff0000;
            p_fmt->i_gmask = 0x00ff00;
            p_fmt->i_bmask = 0x0000ff;
            break;
        case VLC_CODEC_RGB32:
            p_fmt->i_rmask = 0x00ff0000;
            p_fmt->i_gmask = 0x0000ff00;
            p_fmt->i_bmask = 0x000000ff;
            break;

        default:
            return;
        }
    }

    MaskToShift( &p_fmt->i_lrshift, &p_fmt->i_rrshift,
                 p_fm...",90.0,131.0,1.0,1.0,42.0,48,5,29,5,6,3,7,4,0,3,,0,0,2,1,1,void
1503,95517,video_format_Setup,1,video_format_Setup,"void video_format_Setup (video_format_t*,vlc_fourcc_t,int,int,int,int,int,int)",misc\es_format.c,"void video_format_Setup( video_format_t *p_fmt, vlc_fourcc_t i_chroma,
                         int i_width, int i_height,
                         int i_visible_width, int i_visible_height,
                         int i_sar_num, int i_sar_den )
{
    p_fmt->i_chroma         = vlc_fourcc_GetCodec( VIDEO_ES, i_chroma );
    p_fmt->i_width          = i_width;
    p_fmt->i_visible_width  = i_visible_width;
    p_fmt->i_height         = i_height;
    p_fmt->i_visible_height = i_visible_height;
    p_fmt->i_x_offset       =
    p_fmt->i_y_offset       = 0;
    vlc_ureduce( &p_fmt->i_sar_num, &p_fmt->i_sar_den,
                 i_sar_num, i_sar_den, 0 );

    switch( p_fmt->i_chroma )
    {
    case VLC_CODEC_YUVA:
        p_fmt->i_bits_per_pixel = 32;
        break;
    case VLC_CODEC_YUV420A:
        p_fmt->i_bits_per_pixel = 20;
        break;
    case VLC_CODEC_YUV422A:
        p_fmt->i_bits_per_pixel = 24;
        break;
    case VLC_CODEC_I444:
    case VLC_CODEC_J444:
        p_fm...",133.0,226.0,1.0,1.0,94.0,55,3,70,43,3,2,20,2,0,2,,0,1,16,8,8,void
1504,95759,video_format_CopyCrop,1,video_format_CopyCrop,"void video_format_CopyCrop (video_format_t*,video_format_t*)",misc\es_format.c,"void video_format_CopyCrop( video_format_t *p_dst, const video_format_t *p_src )
{
    p_dst->i_x_offset       = p_src->i_x_offset;
    p_dst->i_y_offset       = p_src->i_y_offset;
    p_dst->i_visible_width  = p_src->i_visible_width;
    p_dst->i_visible_height = p_src->i_visible_height;
}",228.0,234.0,1.0,1.0,7.0,12,2,8,2,4,0,1,1,0,0,,0,0,4,2,2,void
1505,95793,video_format_ScaleCropAr,1,video_format_ScaleCropAr,"void video_format_ScaleCropAr (video_format_t*,video_format_t*)",misc\es_format.c,"void video_format_ScaleCropAr( video_format_t *p_dst, const video_format_t *p_src )
{
    p_dst->i_x_offset       = (uint64_t)p_src->i_x_offset       * p_dst->i_width  / p_src->i_width;
    p_dst->i_y_offset       = (uint64_t)p_src->i_y_offset       * p_dst->i_height / p_src->i_height;
    p_dst->i_visible_width  = (uint64_t)p_src->i_visible_width  * p_dst->i_width  / p_src->i_width;
    p_dst->i_visible_height = (uint64_t)p_src->i_visible_height * p_dst->i_height / p_src->i_height;

    p_dst->i_sar_num *= p_src->i_width;
    p_dst->i_sar_den *= p_dst->i_width;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);

    p_dst->i_sar_num *= p_dst->i_height;
    p_dst->i_sar_den *= p_src->i_height;
    vlc_ureduce(&p_dst->i_sar_num, &p_dst->i_sar_den,
                p_dst->i_sar_num, p_dst->i_sar_den, 65536);
}",236.0,252.0,1.0,1.0,17.0,56,7,32,2,0,2,1,1,0,2,,0,0,4,2,2,void
1506,95927,transform_GetBasicOps,1,transform_GetBasicOps,"void transform_GetBasicOps (video_transform_t,unsigned*,bool*)",misc\es_format.c,"static void transform_GetBasicOps( video_transform_t transform,
                                   unsigned *restrict angle,
                                   bool *restrict hflip )
{
    *hflip = ORIENT_IS_MIRROR(transform);

    switch ( transform )
    {
        case TRANSFORM_R90:
        case TRANSFORM_TRANSPOSE:
            *angle = 90;
            break;
        case TRANSFORM_R180:
        case TRANSFORM_VFLIP:
            *angle = 180;
            break;
        case TRANSFORM_R270:
        case TRANSFORM_ANTI_TRANSPOSE:
            *angle = 270;
            break;
        case TRANSFORM_HFLIP:
        case TRANSFORM_IDENTITY:
            *angle = 0;
            break;
        default:
            vlc_assert_unreachable ();
    }
}",255.0,282.0,1.0,1.0,28.0,10,2,15,11,4,0,6,2,0,0,,0,0,6,3,3,void
1507,95980,transform_FromBasicOps,1,transform_FromBasicOps,"video_transform_t transform_FromBasicOps (unsigned,bool)",misc\es_format.c,"static video_transform_t transform_FromBasicOps( unsigned angle, bool hflip )
{
    switch ( angle )
    {
        case 90:
            return hflip ? TRANSFORM_TRANSPOSE : TRANSFORM_R90;
        case 180:
            return hflip ? TRANSFORM_VFLIP : TRANSFORM_R180;
        case 270:
            return hflip ? TRANSFORM_ANTI_TRANSPOSE : TRANSFORM_R270;
        default:
            return hflip ? TRANSFORM_HFLIP : TRANSFORM_IDENTITY;
    }
}",284.0,297.0,1.0,1.0,14.0,4,1,13,10,1,0,2,2,0,0,,0,0,4,2,2,video_transform_t
1508,96016,video_format_GetTransform,1,video_format_GetTransform,"video_transform_t video_format_GetTransform (video_orientation_t,video_orientation_t)",misc\es_format.c,"video_transform_t video_format_GetTransform( video_orientation_t src,
                                             video_orientation_t dst )
{
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps(  (video_transform_t)src, &angle1, &hflip1 );
    transform_GetBasicOps( transform_Inverse( (video_transform_t)dst ),
                           &angle2, &hflip2 );

    int angle = (angle1 + angle2) % 360;
    bool hflip = hflip1 ^ hflip2;

    return transform_FromBasicOps(angle, hflip);
}",299.0,313.0,1.0,1.0,15.0,11,6,14,8,2,3,1,1,0,3,,0,0,4,2,2,video_transform_t
1509,96061,video_format_TransformBy,1,video_format_TransformBy,"void video_format_TransformBy (video_format_t*,video_transform_t)",misc\es_format.c,"void video_format_TransformBy( video_format_t *fmt, video_transform_t transform )
{
    /* Get destination orientation */
    unsigned angle1, angle2;
    bool hflip1, hflip2;

    transform_GetBasicOps( transform, &angle1, &hflip1 );
    transform_GetBasicOps( (video_transform_t)fmt->orientation, &angle2, &hflip2 );

    unsigned angle = (angle2 - angle1 + 360) % 360;
    bool hflip = hflip2 ^ hflip1;

    video_orientation_t dst_orient = ORIENT_NORMAL;

    if( hflip ) {

        if( angle == 0 )
            dst_orient = ORIENT_HFLIPPED;
        else if( angle == 90 )
            dst_orient = ORIENT_ANTI_TRANSPOSED;
        else if( angle == 180 )
            dst_orient = ORIENT_VFLIPPED;
        else if( angle == 270 )
            dst_orient = ORIENT_TRANSPOSED;
    }
    else {

        if( angle == 90 )
            dst_orient = ORIENT_ROTATED_90;
        else if( angle == 180 )
            dst_orient = ORIENT_ROTATED_180;
        else if( angle == 270 )
            dst_orient =...",315.0,366.0,1.0,1.0,52.0,45,12,40,12,1,2,4,5,0,2,,0,0,4,2,2,void
1510,96253,video_format_TransformTo,1,video_format_TransformTo,"void video_format_TransformTo (video_format_t*,video_orientation_t)",misc\es_format.c,"void video_format_TransformTo( video_format_t *restrict fmt,
                               video_orientation_t dst_orientation )
{
    video_transform_t transform = video_format_GetTransform(fmt->orientation,
                                                            dst_orientation);
    video_format_TransformBy(fmt, transform);
}",368.0,374.0,1.0,1.0,7.0,2,2,5,3,2,2,1,1,0,2,,0,1,4,2,2,void
1511,96270,video_format_ApplyRotation,1,video_format_ApplyRotation,"void video_format_ApplyRotation (video_format_t*,video_format_t*)",misc\es_format.c,"void video_format_ApplyRotation( video_format_t *restrict out,
                                 const video_format_t *restrict in )
{
    *out = *in;

    video_format_TransformTo(out, ORIENT_NORMAL);
}",376.0,382.0,1.0,1.0,7.0,3,2,4,3,2,1,1,1,0,1,,0,0,4,2,2,void
1512,96284,video_format_IsSimilar,1,video_format_IsSimilar,"bool video_format_IsSimilar (video_format_t*,video_format_t*)",misc\es_format.c,"bool video_format_IsSimilar( const video_format_t *f1,
                             const video_format_t *f2 )
{
    if( f1->i_chroma != f2->i_chroma )
        return false;

    if( f1->i_width != f2->i_width || f1->i_height != f2->i_height ||
        f1->i_visible_width != f2->i_visible_width ||
        f1->i_visible_height != f2->i_visible_height ||
        f1->i_x_offset != f2->i_x_offset || f1->i_y_offset != f2->i_y_offset )
        return false;
    if( (int64_t)f1->i_sar_num * f2->i_sar_den !=
        (int64_t)f2->i_sar_num * f1->i_sar_den )
        return false;

    if( f1->orientation != f2->orientation)
        return false;

    if( f1->multiview_mode!= f2->multiview_mode )
       return false;

    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
...",384.0,422.0,1.0,1.0,39.0,69,10,49,10,4,2,8,9,0,2,,0,0,4,2,2,bool
1513,96467,video_format_Print,1,video_format_Print,"void video_format_Print (vlc_object_t*,char*,video_format_t*)",misc\es_format.c,"void video_format_Print( vlc_object_t *p_this,
                         const char *psz_text, const video_format_t *fmt )
{
    msg_Dbg( p_this,
             ""%s sz %ix%i, of (%i,%i), vsz %ix%i, 4cc %4.4s, sar %i:%i, msk r0x%x g0x%x b0x%x"",
             psz_text,
             fmt->i_width, fmt->i_height, fmt->i_x_offset, fmt->i_y_offset,
             fmt->i_visible_width, fmt->i_visible_height,
             (char*)&fmt->i_chroma,
             fmt->i_sar_num, fmt->i_sar_den,
             fmt->i_rmask, fmt->i_gmask, fmt->i_bmask );
}",423.0,434.0,1.0,1.0,12.0,14,3,14,3,3,0,1,1,0,0,,0,0,6,3,3,void
1514,96517,es_format_Init,1,es_format_Init,"void es_format_Init (es_format_t*,int,vlc_fourcc_t)",misc\es_format.c,"void es_format_Init( es_format_t *fmt,
                     int i_cat, vlc_fourcc_t i_codec )
{
    memset(fmt, 0, sizeof (*fmt));
    fmt->i_cat                  = i_cat;
    fmt->i_codec                = i_codec;
    fmt->i_profile              = -1;
    fmt->i_level                = -1;
    fmt->i_id                   = -1;
    fmt->i_priority             = ES_PRIORITY_SELECTABLE_MIN;
    fmt->psz_language           = NULL;
    fmt->psz_description        = NULL;
    fmt->p_extra_languages      = NULL;

    if (fmt->i_cat == VIDEO_ES)
        video_format_Init(&fmt->video, 0);

    fmt->b_packetized           = true;
    fmt->p_extra                = NULL;
}",436.0,455.0,1.0,1.0,20.0,31,7,24,7,15,0,2,2,0,0,,0,0,6,3,3,void
1515,96601,es_format_InitFromVideo,1,es_format_InitFromVideo,"void es_format_InitFromVideo (es_format_t*,video_format_t*)",misc\es_format.c,"void es_format_InitFromVideo( es_format_t *p_es, const video_format_t *p_fmt )
{
    es_format_Init( p_es, VIDEO_ES, p_fmt->i_chroma );
    video_format_Copy( &p_es->video, p_fmt );
}",457.0,461.0,1.0,1.0,5.0,3,2,5,3,3,1,1,1,0,1,,0,0,4,2,2,void
1516,96619,es_format_Copy,1,es_format_Copy,"int es_format_Copy (es_format_t*,es_format_t*)",misc\es_format.c,"int es_format_Copy(es_format_t *restrict dst, const es_format_t *src)
{
    int ret = VLC_SUCCESS;

    *dst = *src;

    if (src->psz_language != NULL)
    {
        dst->psz_language = strdup(src->psz_language);
        if (unlikely(dst->psz_language == NULL))
            ret = VLC_ENOMEM;
    }
    if (src->psz_description != NULL)
    {
        dst->psz_description = strdup(src->psz_description);
        if (unlikely(dst->psz_description == NULL))
            ret = VLC_ENOMEM;
    }

    if (src->i_extra > 0)
    {
        assert(src->p_extra != NULL);
        dst->p_extra = malloc( src->i_extra );

        if( likely(dst->p_extra != NULL) )
            memcpy(dst->p_extra, src->p_extra, src->i_extra);
        else
        {
            dst->i_extra = 0;
            ret = VLC_ENOMEM;
        }
    }
    else
        dst->p_extra = NULL;

    if (src->i_cat == VIDEO_ES)
        ret = video_format_Copy( &dst->video, &src->video );

    if (src->i_cat == SPU_ES)
    {
        if (s...",463.0,540.0,1.0,1.0,78.0,105,11,81,9,12,1,18,36,0,1,,0,1,4,2,2,int
1517,96956,es_format_Clean,1,es_format_Clean,void es_format_Clean (es_format_t*),misc\es_format.c,"void es_format_Clean(es_format_t *fmt)
{
    free(fmt->psz_language);
    free(fmt->psz_description);
    assert(fmt->i_extra == 0 || fmt->p_extra != NULL);
    free(fmt->p_extra);

    if (fmt->i_cat == VIDEO_ES)
        video_format_Clean( &fmt->video );
    if (fmt->i_cat == SPU_ES)
    {
        free(fmt->subs.psz_encoding);

        if (fmt->subs.p_style != NULL)
            text_style_Delete(fmt->subs.p_style);
    }

    for (unsigned i = 0; i < fmt->i_extra_languages; i++)
    {
        free(fmt->p_extra_languages[i].psz_language);
        free(fmt->p_extra_languages[i].psz_description);
    }
    free(fmt->p_extra_languages);

    /* es_format_Clean can be called multiple times */
    es_format_Init(fmt, UNKNOWN_ES, 0);
}",542.0,568.0,1.0,1.0,27.0,31,9,25,6,27,2,5,6,0,2,,0,0,2,1,1,void
1518,97063,es_format_IsSimilar,1,es_format_IsSimilar,"bool es_format_IsSimilar (es_format_t*,es_format_t*)",misc\es_format.c,"bool es_format_IsSimilar( const es_format_t *p_fmt1, const es_format_t *p_fmt2 )
{
    if( p_fmt1->i_cat != p_fmt2->i_cat ||
        vlc_fourcc_GetCodec( p_fmt1->i_cat, p_fmt1->i_codec ) !=
        vlc_fourcc_GetCodec( p_fmt2->i_cat, p_fmt2->i_codec ) )
        return false;

    switch( p_fmt1->i_cat )
    {
    case AUDIO_ES:
    {
        audio_format_t a1 = p_fmt1->audio;
        audio_format_t a2 = p_fmt2->audio;

        if( a1.i_format && a2.i_format && a1.i_format != a2.i_format )
            return false;
        if( a1.channel_type != a2.channel_type ||
            a1.i_rate != a2.i_rate ||
            a1.i_channels != a2.i_channels ||
            a1.i_physical_channels != a2.i_physical_channels ||
            a1.i_chan_mode != a2.i_chan_mode )
            return false;
        if( p_fmt1->i_profile != p_fmt2->i_profile )
            return false;
        return true;
    }

    case VIDEO_ES:
    {
        video_format_t v1 = p_fmt1->video;
        video_format_t v2 = p_f...",570.0,612.0,1.0,1.0,43.0,63,8,50,11,1,5,8,13,2,5,,0,4,4,2,2,bool
1519,97274,vlc_event_manager_init,1,vlc_event_manager_init,"void vlc_event_manager_init (vlc_event_manager_t*,void*)",misc\events.c,"void vlc_event_manager_init( vlc_event_manager_t * p_em, void * p_obj )
{
    p_em->p_obj = p_obj;
    /* This is an unsafe work-around for a long-standing playlist bug.
     * Do not rely on this. */
    vlc_mutex_init_recursive( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
       ARRAY_INIT( p_em->events[i].listeners );
}",66.0,75.0,1.0,1.0,10.0,7,4,6,3,1,1,2,2,0,1,,0,0,4,2,2,void
1520,97312,vlc_event_manager_fini,1,vlc_event_manager_fini,void vlc_event_manager_fini (vlc_event_manager_t*),misc\events.c,"void vlc_event_manager_fini( vlc_event_manager_t * p_em )
{
    struct vlc_event_listener_t * listener;

    vlc_mutex_destroy( &p_em->lock );

    for( size_t i = 0; i < ARRAY_SIZE(p_em->events); i++ )
    {
        struct vlc_event_listeners_group_t *slot = p_em->events + i;

        FOREACH_ARRAY( listener, slot->listeners )
            free( listener );
        FOREACH_END()
        ARRAY_RESET( slot->listeners );
    }
}",80.0,95.0,1.0,1.0,16.0,10,5,11,4,1,1,2,2,0,1,,0,0,2,1,1,void
1521,97360,vlc_event_send,1,vlc_event_send,"void vlc_event_send (vlc_event_manager_t*,vlc_event_t*)",misc\events.c,"void vlc_event_send( vlc_event_manager_t * p_em,
                     vlc_event_t * p_event )
{
    vlc_event_listeners_group_t *slot = &p_em->events[p_event->type];
    vlc_event_listener_t * listener;

    /* Fill event with the sending object now */
    p_event->p_obj = p_em->p_obj;

    vlc_mutex_lock( &p_em->lock ) ;

    FOREACH_ARRAY( listener, slot->listeners )
        listener->pf_callback( p_event, listener->p_user_data );
    FOREACH_END()

    vlc_mutex_unlock( &p_em->lock );
}",100.0,116.0,1.0,1.0,17.0,15,4,12,4,7,4,1,1,0,2,,0,2,4,2,2,void
1522,97411,vlc_event_attach,1,vlc_event_attach,"int vlc_event_attach (vlc_event_manager_t*,vlc_event_type_t,vlc_event_callback_t,void*)",misc\events.c,"int vlc_event_attach( vlc_event_manager_t * p_em,
                      vlc_event_type_t event_type,
                      vlc_event_callback_t pf_callback,
                      void *p_user_data )
{
    vlc_event_listener_t * listener;
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];

    listener = malloc(sizeof(vlc_event_listener_t));
    if( !listener )
        return VLC_ENOMEM;

    listener->p_user_data = p_user_data;
    listener->pf_callback = pf_callback;

    vlc_mutex_lock( &p_em->lock );
    ARRAY_APPEND( slot->listeners, listener );
    vlc_mutex_unlock( &p_em->lock );
    return VLC_SUCCESS;
}",122.0,141.0,1.0,1.0,20.0,16,6,16,9,7,4,2,2,0,2,,0,2,8,4,4,int
1523,97467,vlc_event_detach,1,vlc_event_detach,"void vlc_event_detach (vlc_event_manager_t*,vlc_event_type_t,vlc_event_callback_t,void*)",misc\events.c,"void vlc_event_detach( vlc_event_manager_t *p_em,
                       vlc_event_type_t event_type,
                       vlc_event_callback_t pf_callback,
                       void *p_user_data )
{
    vlc_event_listeners_group_t *slot = &p_em->events[event_type];
    struct vlc_event_listener_t * listener;

    vlc_mutex_lock( &p_em->lock );

    FOREACH_ARRAY( listener, slot->listeners )
        if( listener->pf_callback == pf_callback &&
            listener->p_user_data == p_user_data )
        {
            /* that's our listener */
            ARRAY_REMOVE( slot->listeners,
                          fe_idx /* This comes from the macro (and that's why
                                    I hate macro) */ );
            vlc_mutex_unlock( &p_em->lock );
            free( listener );
            return;
        }
    FOREACH_END()

    vlc_assert_unreachable();
}",147.0,172.0,1.0,1.0,26.0,15,6,14,7,7,4,2,2,2,2,,0,2,8,4,4,void
1524,97570,libvlc_SetExitHandler,1,libvlc_SetExitHandler,"void libvlc_SetExitHandler (libvlc_int_t*,void,void*)",misc\exit.c,"void libvlc_SetExitHandler( libvlc_int_t *p_libvlc, void (*handler) (void *),
                            void *opaque )
{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    vlc_mutex_lock( &exit->lock );
    exit->handler = handler;
    exit->opaque = opaque;
    vlc_mutex_unlock( &exit->lock );
}",46.0,55.0,1.0,1.0,10.0,11,3,8,4,0,3,1,1,0,3,,0,1,6,3,3,void
1525,97605,libvlc_Quit,1,libvlc_Quit,void libvlc_Quit (libvlc_int_t*),misc\exit.c,"void libvlc_Quit( libvlc_int_t *p_libvlc )
{
    vlc_exit_t *exit = &libvlc_priv( p_libvlc )->exit;

    msg_Dbg( p_libvlc, ""exiting"" );
    vlc_mutex_lock( &exit->lock );
    if( exit->handler != NULL )
        exit->handler( exit->opaque );
    else
        msg_Dbg( p_libvlc, ""no exit handler"" );
    vlc_mutex_unlock( &exit->lock );
}",61.0,72.0,1.0,1.0,12.0,11,4,9,3,0,4,2,2,0,4,,0,1,2,1,1,void
1526,97674,vlc_fifo_Lock,1,vlc_fifo_Lock,void vlc_fifo_Lock (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Lock(vlc_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
}",49.0,52.0,1.0,1.0,4.0,2,2,1,1,21,1,1,1,0,1,,0,0,2,1,1,void
1527,97684,vlc_fifo_Unlock,1,vlc_fifo_Unlock,void vlc_fifo_Unlock (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Unlock(vlc_fifo_t *fifo)
{
    vlc_mutex_unlock(&fifo->lock);
}",54.0,57.0,1.0,1.0,4.0,2,2,1,1,22,1,1,1,0,1,,0,0,2,1,1,void
1528,97694,vlc_fifo_Signal,1,vlc_fifo_Signal,void vlc_fifo_Signal (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Signal(vlc_fifo_t *fifo)
{
    vlc_cond_signal(&fifo->wait);
}",59.0,62.0,1.0,1.0,4.0,2,2,1,1,6,1,1,1,0,1,,0,0,2,1,1,void
1529,97704,vlc_fifo_Wait,1,vlc_fifo_Wait,void vlc_fifo_Wait (vlc_fifo_t*),misc\fifo.c,"void vlc_fifo_Wait(vlc_fifo_t *fifo)
{
    vlc_fifo_WaitCond(fifo, &fifo->wait);
}",64.0,67.0,1.0,1.0,4.0,2,2,2,1,4,1,1,1,0,1,,0,0,2,1,1,void
1530,97715,vlc_fifo_WaitCond,1,vlc_fifo_WaitCond,"void vlc_fifo_WaitCond (vlc_fifo_t*,vlc_cond_t*)",misc\fifo.c,"void vlc_fifo_WaitCond(vlc_fifo_t *fifo, vlc_cond_t *condvar)
{
    vlc_cond_wait(condvar, &fifo->lock);
}",69.0,72.0,1.0,1.0,4.0,2,2,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
1531,97727,vlc_fifo_TimedWaitCond,1,vlc_fifo_TimedWaitCond,"int vlc_fifo_TimedWaitCond (vlc_fifo_t*,vlc_cond_t*,mtime_t)",misc\fifo.c,"int vlc_fifo_TimedWaitCond(vlc_fifo_t *fifo, vlc_cond_t *condvar, mtime_t deadline)
{
    return vlc_cond_timedwait(condvar, &fifo->lock, deadline);
}",74.0,77.0,1.0,1.0,4.0,2,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,int
1532,97751,vlc_fifo_GetBytes,1,vlc_fifo_GetBytes,size_t vlc_fifo_GetBytes (vlc_fifo_t*),misc\fifo.c,"size_t vlc_fifo_GetBytes(const vlc_fifo_t *fifo)
{
    return fifo->i_size;
}",84.0,87.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,size_t
1533,97760,vlc_fifo_QueueUnlocked,1,vlc_fifo_QueueUnlocked,"void vlc_fifo_QueueUnlocked (block_fifo_t*,block_t*)",misc\fifo.c,"void vlc_fifo_QueueUnlocked(block_fifo_t *fifo, block_t *block)
{
    vlc_assert_locked(&fifo->lock);
    assert(*(fifo->pp_last) == NULL);

    *(fifo->pp_last) = block;

    while (block != NULL)
    {
        fifo->pp_last = &block->p_next;
        fifo->i_depth++;
        fifo->i_size += block->i_buffer;

        block = block->p_next;
    }

    vlc_fifo_Signal(fifo);
}",89.0,106.0,1.0,4.0,18.0,23,9,16,3,3,8,2,2,0,1,,0,7,4,2,2,void
1534,97822,vlc_fifo_DequeueUnlocked,1,vlc_fifo_DequeueUnlocked,block_t vlc_fifo_DequeueUnlocked (block_fifo_t*),misc\fifo.c,"block_t *vlc_fifo_DequeueUnlocked(block_fifo_t *fifo)
{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    if (block == NULL)
        return NULL; /* Nothing to do */

    fifo->p_first = block->p_next;
    if (block->p_next == NULL)
        fifo->pp_last = &fifo->p_first;
    block->p_next = NULL;

    assert(fifo->i_depth > 0);
    fifo->i_depth--;
    assert(fifo->i_size >= block->i_buffer);
    fifo->i_size -= block->i_buffer;

    return block;
}",108.0,128.0,1.0,4.0,21.0,29,9,22,3,3,10,3,3,0,0,,0,10,2,1,1,block_t
1535,97906,vlc_fifo_DequeueAllUnlocked,1,vlc_fifo_DequeueAllUnlocked,block_t vlc_fifo_DequeueAllUnlocked (block_fifo_t*),misc\fifo.c,"block_t *vlc_fifo_DequeueAllUnlocked(block_fifo_t *fifo)
{
    vlc_assert_locked(&fifo->lock);

    block_t *block = fifo->p_first;

    fifo->p_first = NULL;
    fifo->pp_last = &fifo->p_first;
    fifo->i_depth = 0;
    fifo->i_size = 0;

    return block;
}",130.0,142.0,1.0,4.0,13.0,17,4,11,3,4,8,1,1,0,0,,0,8,2,1,1,block_t
1536,97954,block_FifoNew,1,block_FifoNew,block_fifo_t block_FifoNew (void),misc\fifo.c,"block_fifo_t *block_FifoNew( void )
{
    block_fifo_t *p_fifo = malloc( sizeof( block_fifo_t ) );
    if( !p_fifo )
        return NULL;

    vlc_mutex_init( &p_fifo->lock );
    vlc_cond_init( &p_fifo->wait );
    p_fifo->p_first = NULL;
    p_fifo->pp_last = &p_fifo->p_first;
    p_fifo->i_depth = p_fifo->i_size = 0;

    return p_fifo;
}",144.0,157.0,1.0,1.0,14.0,17,5,13,3,2,9,2,2,0,2,,0,7,2,1,1,block_fifo_t
1537,98005,block_FifoRelease,1,block_FifoRelease,void block_FifoRelease (block_fifo_t*),misc\fifo.c,"void block_FifoRelease( block_fifo_t *p_fifo )
{
    block_ChainRelease( p_fifo->p_first );
    vlc_cond_destroy( &p_fifo->wait );
    vlc_mutex_destroy( &p_fifo->lock );
    free( p_fifo );
}",159.0,165.0,1.0,1.0,7.0,5,2,4,1,4,5,1,1,0,2,,0,3,2,1,1,void
1538,98026,block_FifoEmpty,1,block_FifoEmpty,void block_FifoEmpty (block_fifo_t*),misc\fifo.c,"void block_FifoEmpty(block_fifo_t *fifo)
{
    block_t *block;

    vlc_fifo_Lock(fifo);
    block = vlc_fifo_DequeueAllUnlocked(fifo);
    vlc_fifo_Unlock(fifo);
    block_ChainRelease(block);
}",167.0,175.0,1.0,1.0,9.0,1,1,5,2,0,3,1,1,0,3,,0,1,2,1,1,void
1539,98042,block_FifoPut,1,block_FifoPut,"void block_FifoPut (block_fifo_t*,block_t*)",misc\fifo.c,"void block_FifoPut(block_fifo_t *fifo, block_t *block)
{
    vlc_fifo_Lock(fifo);
    vlc_fifo_QueueUnlocked(fifo, block);
    vlc_fifo_Unlock(fifo);
}",177.0,182.0,1.0,1.0,6.0,0,0,4,2,1,3,1,1,0,3,,0,0,4,2,2,void
1540,98055,block_FifoGet,1,block_FifoGet,block_t block_FifoGet (block_fifo_t*),misc\fifo.c,"block_t *block_FifoGet(block_fifo_t *fifo)
{
    block_t *block;

    vlc_testcancel();

    vlc_fifo_Lock(fifo);
    while (vlc_fifo_IsEmpty(fifo))
    {
        vlc_fifo_CleanupPush(fifo);
        vlc_fifo_Wait(fifo);
        vlc_cleanup_pop();
    }
    block = vlc_fifo_DequeueUnlocked(fifo);
    vlc_fifo_Unlock(fifo);

    return block;
}",184.0,201.0,1.0,1.0,18.0,1,1,8,2,0,5,2,2,0,5,,0,1,2,1,1,block_t
1541,98081,block_FifoShow,1,block_FifoShow,block_t block_FifoShow (block_fifo_t*),misc\fifo.c,"block_t *block_FifoShow( block_fifo_t *p_fifo )
{
    block_t *b;

    vlc_mutex_lock( &p_fifo->lock );
    assert(p_fifo->p_first != NULL);
    b = p_fifo->p_first;
    vlc_mutex_unlock( &p_fifo->lock );

    return b;
}",203.0,213.0,1.0,1.0,11.0,8,4,7,3,0,6,1,1,0,2,,0,4,2,1,1,block_t
1542,98110,block_FifoSize,1,block_FifoSize,size_t block_FifoSize (block_fifo_t*),misc\fifo.c,"size_t block_FifoSize (block_fifo_t *fifo)
{
    size_t size;

    vlc_mutex_lock (&fifo->lock);
    size = fifo->i_size;
    vlc_mutex_unlock (&fifo->lock);
    return size;
}",216.0,224.0,1.0,1.0,9.0,6,3,5,2,1,5,1,1,0,2,,0,3,2,1,1,size_t
1543,98133,block_FifoCount,1,block_FifoCount,size_t block_FifoCount (block_fifo_t*),misc\fifo.c,"size_t block_FifoCount (block_fifo_t *fifo)
{
    size_t depth;

    vlc_mutex_lock (&fifo->lock);
    depth = fifo->i_depth;
    vlc_mutex_unlock (&fifo->lock);
    return depth;
}",227.0,235.0,1.0,1.0,9.0,6,3,5,2,0,5,1,1,0,2,,0,3,2,1,1,size_t
1544,98177,TriggerFilterCallback,1,TriggerFilterCallback,"int TriggerFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",misc\filter.c,"static int TriggerFilterCallback(vlc_object_t *p_this, char const *psz_var,
                                 vlc_value_t oldval, vlc_value_t newval,
                                 void *p_data)
{
    (void) p_this; (void) oldval;
    var_Set((filter_t *)p_data, psz_var, newval);
    return 0;
}",38.0,45.0,1.0,1.0,8.0,3,1,5,5,0,1,1,1,0,1,,0,0,10,5,5,int
1545,98200,filter_AddProxyCallbacks,1,filter_AddProxyCallbacks,"void filter_AddProxyCallbacks (vlc_object_t*,filter_t*,vlc_callback_t)",misc\filter.c,"void filter_AddProxyCallbacks( vlc_object_t *obj, filter_t *filter,
                               vlc_callback_t restart_cb )
{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        int var_type = var_Type(filter, name);
        if (var_Type(obj, name))
        {
            free(name);
            continue;
        }
        var_Create(obj, name,
                   var_type | VLC_VAR_DOINHERIT | VLC_VAR_ISCOMMAND);
        if ((var_type & VLC_VAR_ISCOMMAND))
            var_AddCallback(obj, name, TriggerFilterCallback, filter);
        else
            var_AddCallback(obj, name, restart_cb, obj);
        free(name);
    }
    free(names);
}",48.0,73.0,1.0,1.0,26.0,11,6,28,9,2,5,6,7,1,5,,0,3,6,3,3,void
1546,98280,filter_DelProxyCallbacks,1,filter_DelProxyCallbacks,"void filter_DelProxyCallbacks (vlc_object_t*,filter_t*,vlc_callback_t)",misc\filter.c,"void filter_DelProxyCallbacks( vlc_object_t *obj, filter_t *filter,
                               vlc_callback_t restart_cb )
{
    char **names = var_GetAllNames(VLC_OBJECT(filter));
    if (names == NULL)
        return;

    for (char **pname = names; *pname != NULL; pname++)
    {
        char *name = *pname;
        if (!(var_Type(obj, name) & VLC_VAR_ISCOMMAND))
        {
            free(name);
            continue;
        }
        int filter_var_type = var_Type(filter, name);

        if (filter_var_type & VLC_VAR_ISCOMMAND)
            var_DelCallback(obj, name, TriggerFilterCallback, filter);
        else if (filter_var_type)
            var_DelCallback(obj, name, restart_cb, obj);
        var_Destroy(obj, name);
        free(name);
    }
    free(names);
}",76.0,101.0,1.0,1.0,26.0,11,6,26,8,3,4,6,7,1,4,,0,3,6,3,3,void
1547,98361,filter_NewBlend,1,filter_NewBlend,"filter_t filter_NewBlend (vlc_object_t*,video_format_t*)",misc\filter.c,"filter_t *filter_NewBlend( vlc_object_t *p_this,
                           const video_format_t *p_dst_chroma )
{
    filter_t *p_blend = vlc_custom_create( p_this, sizeof(*p_blend), ""blend"" );
    if( !p_blend )
        return NULL;

    es_format_Init( &p_blend->fmt_in, VIDEO_ES, 0 );

    es_format_Init( &p_blend->fmt_out, VIDEO_ES, 0 );

    p_blend->fmt_out.i_codec        =
    p_blend->fmt_out.video.i_chroma = p_dst_chroma->i_chroma;
    p_blend->fmt_out.video.i_rmask  = p_dst_chroma->i_rmask;
    p_blend->fmt_out.video.i_gmask  = p_dst_chroma->i_gmask;
    p_blend->fmt_out.video.i_bmask  = p_dst_chroma->i_bmask;
    p_blend->fmt_out.video.i_rrshift= p_dst_chroma->i_rrshift;
    p_blend->fmt_out.video.i_rgshift= p_dst_chroma->i_rgshift;
    p_blend->fmt_out.video.i_rbshift= p_dst_chroma->i_rbshift;
    p_blend->fmt_out.video.i_lrshift= p_dst_chroma->i_lrshift;
    p_blend->fmt_out.video.i_lgshift= p_dst_chroma->i_lgshift;
    p_blend->fmt_out.video.i_lbshift= p_dst_chroma->i_...",105.0,133.0,1.0,1.0,29.0,63,7,33,5,1,3,2,2,0,3,,0,1,4,2,2,filter_t
1548,98519,filter_ConfigureBlend,1,filter_ConfigureBlend,"int filter_ConfigureBlend (filter_t*,int,int,video_format_t*)",misc\filter.c,"int filter_ConfigureBlend( filter_t *p_blend,
                           int i_dst_width, int i_dst_height,
                           const video_format_t *p_src )
{
    /* */
    if( p_blend->p_module &&
        p_blend->fmt_in.video.i_chroma != p_src->i_chroma )
    {
        /* The chroma is not the same, we need to reload the blend module */
        module_unneed( p_blend, p_blend->p_module );
        p_blend->p_module = NULL;
    }

    /* */

    p_blend->fmt_in.i_codec = p_src->i_chroma;
    p_blend->fmt_in.video   = *p_src;

    /* */
    p_blend->fmt_out.video.i_width          =
    p_blend->fmt_out.video.i_visible_width  = i_dst_width;
    p_blend->fmt_out.video.i_height         =
    p_blend->fmt_out.video.i_visible_height = i_dst_height;

    /* */
    if( !p_blend->p_module )
        p_blend->p_module = module_need( p_blend, ""video blending"", NULL, false );
    if( !p_blend->p_module )
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",135.0,165.0,1.0,1.0,31.0,40,7,25,8,1,2,4,4,0,2,,0,1,8,4,4,int
1549,98630,filter_Blend,1,filter_Blend,"int filter_Blend (filter_t*,picture_t*,int,int,picture_t*,int)",misc\filter.c,"int filter_Blend( filter_t *p_blend,
                  picture_t *p_dst, int i_dst_x, int i_dst_y,
                  const picture_t *p_src, int i_alpha )
{
    if( !p_blend->p_module )
        return VLC_EGENERIC;

    p_blend->pf_video_blend( p_blend, p_dst, p_src, i_dst_x, i_dst_y, i_alpha );
    return VLC_SUCCESS;
}",167.0,176.0,1.0,1.0,10.0,3,2,10,8,1,0,2,2,0,0,,0,0,12,6,6,int
1550,98660,filter_DeleteBlend,1,filter_DeleteBlend,void filter_DeleteBlend (filter_t*),misc\filter.c,"void filter_DeleteBlend( filter_t *p_blend )
{
    if( p_blend->p_module )
        module_unneed( p_blend, p_blend->p_module );

    vlc_object_release( p_blend );
}",178.0,184.0,1.0,1.0,7.0,2,1,4,1,2,2,2,2,0,2,,0,0,2,1,1,void
1551,98677,video_splitter_New,1,video_splitter_New,"video_splitter_t video_splitter_New (vlc_object_t*,char*,video_format_t*)",misc\filter.c,"video_splitter_t *video_splitter_New( vlc_object_t *p_this,
                                      const char *psz_name,
                                      const video_format_t *p_fmt )
{
    video_splitter_t *p_splitter = vlc_custom_create( p_this,
                                       sizeof(*p_splitter), ""video splitter"" );
    if( !p_splitter )
        return NULL;

    video_format_Copy( &p_splitter->fmt, p_fmt );

    /* */
    p_splitter->p_module = module_need( p_splitter, ""video splitter"", psz_name, true );
    if( ! p_splitter->p_module )
    {
        video_splitter_Delete( p_splitter );
        return NULL;
    }

    return p_splitter;
}",189.0,209.0,1.0,1.0,21.0,10,6,15,6,1,3,3,3,0,3,,0,2,6,3,3,video_splitter_t
1552,98726,video_splitter_Delete,1,video_splitter_Delete,void video_splitter_Delete (video_splitter_t*),misc\filter.c,"void video_splitter_Delete( video_splitter_t *p_splitter )
{
    if( p_splitter->p_module )
        module_unneed( p_splitter, p_splitter->p_module );

    video_format_Clean( &p_splitter->fmt );

    vlc_object_release( p_splitter );
}",211.0,219.0,1.0,1.0,9.0,4,2,5,1,2,2,2,2,0,2,,0,0,2,1,1,void
1553,98775,chained,1,chained,chained_filter_t chained (filter_t*),misc\filter_chain.c,"static inline chained_filter_t *chained(filter_t *filter)
{
    return container_of(filter, chained_filter_t, filter);
}",46.0,49.0,1.0,1.0,4.0,0,0,3,2,1,0,1,1,0,0,,0,0,2,1,1,chained_filter_t
1554,98795,FilterDeletePictures,1,FilterDeletePictures,void FilterDeletePictures (picture_t*),misc\filter_chain.c,"static void FilterDeletePictures( picture_t *picture )
{
    while( picture )
    {
        picture_t *next = picture->p_next;
        picture_Release( picture );
        picture = next;
    }
}",521.0,529.0,1.0,1.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1555,98800,filter_chain_NewInner,1,filter_chain_NewInner,"filter_chain_t filter_chain_NewInner (filter_owner_t*,char*,char*,bool,filter_owner_t*,es_format_category_e)",misc\filter_chain.c,"static filter_chain_t *filter_chain_NewInner( const filter_owner_t *callbacks,
    const char *cap, const char *conv_cap, bool fmt_out_change,
    const filter_owner_t *owner, enum es_format_category_e cat )
{
    assert( callbacks != NULL && callbacks->sys != NULL );
    assert( cap != NULL );

    filter_chain_t *chain = malloc( sizeof (*chain) );
    if( unlikely(chain == NULL) )
        return NULL;

    chain->callbacks = *callbacks;
    if( owner != NULL )
        chain->owner = *owner;
    chain->first = NULL;
    chain->last = NULL;
    es_format_Init( &chain->fmt_in, cat, 0 );
    es_format_Init( &chain->fmt_out, cat, 0 );
    chain->b_allow_fmt_out_change = fmt_out_change;
    chain->filter_cap = cap;
    chain->conv_cap = conv_cap;
    return chain;
}",71.0,93.0,1.0,1.0,23.0,30,8,32,8,2,11,3,3,0,2,,0,9,12,6,6,filter_chain_t
1556,98897,filter_chain_New,1,filter_chain_New,"filter_chain_t filter_chain_New (vlc_object_t*,char*,es_format_category_e)",misc\filter_chain.c,"filter_chain_t *filter_chain_New( vlc_object_t *obj, const char *cap,
                                  enum es_format_category_e cat )
{
    filter_owner_t callbacks = {
        .sys = obj,
    };

    return filter_chain_NewInner( &callbacks, cap, NULL, false, NULL, cat );
}",99.0,107.0,1.0,1.0,9.0,4,3,9,7,2,1,1,1,0,1,,0,0,6,3,3,filter_chain_t
1557,98921,filter_chain_VideoBufferNew,1,filter_chain_VideoBufferNew,picture_t filter_chain_VideoBufferNew (filter_t*),misc\filter_chain.c,"static picture_t *filter_chain_VideoBufferNew( filter_t *filter )
{
    if( chained(filter)->next != NULL )
    {
        picture_t *pic = picture_NewFromFormat( &filter->fmt_out.video );
        if( pic == NULL )
            msg_Err( filter, ""Failed to allocate picture"" );
        return pic;
    }
    else
    {
        filter_chain_t *chain = filter->owner.sys;

        /* XXX ugly */
        filter->owner.sys = chain->owner.sys;
        picture_t *pic = chain->owner.video.buffer_new( filter );
        filter->owner.sys = chain;
        return pic;
    }
}",110.0,129.0,1.0,1.0,20.0,7,6,8,3,0,2,3,4,1,2,,0,2,2,1,1,picture_t
1558,98996,filter_chain_NewVideo,1,filter_chain_NewVideo,"filter_chain_t filter_chain_NewVideo (vlc_object_t*,bool,filter_owner_t*)",misc\filter_chain.c,"filter_chain_t *filter_chain_NewVideo( vlc_object_t *obj, bool allow_change,
                                       const filter_owner_t *restrict owner )
{
    filter_owner_t callbacks = {
        .sys = obj,
        .video = {
            .buffer_new = filter_chain_VideoBufferNew,
        },
    };

    return filter_chain_NewInner( &callbacks, ""video filter"",
                                  ""video converter"", allow_change, owner, VIDEO_ES );
}",132.0,144.0,1.0,1.0,13.0,7,3,9,8,4,1,1,1,0,1,,0,0,6,3,3,filter_chain_t
1559,99028,filter_chain_Delete,1,filter_chain_Delete,void filter_chain_Delete (filter_chain_t*),misc\filter_chain.c,"void filter_chain_Delete( filter_chain_t *p_chain )
{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    es_format_Clean( &p_chain->fmt_in );
    es_format_Clean( &p_chain->fmt_out );

    free( p_chain );
}",149.0,158.0,1.0,1.0,10.0,6,3,5,2,10,5,2,2,1,2,,0,3,2,1,1,void
1560,99059,filter_chain_Reset,1,filter_chain_Reset,"void filter_chain_Reset (filter_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"void filter_chain_Reset( filter_chain_t *p_chain, const es_format_t *p_fmt_in,
                         const es_format_t *p_fmt_out )
{
    while( p_chain->first != NULL )
        filter_chain_DeleteFilter( p_chain, &p_chain->first->filter );

    if( p_fmt_in )
    {
        es_format_Clean( &p_chain->fmt_in );
        es_format_Copy( &p_chain->fmt_in, p_fmt_in );
    }
    if( p_fmt_out )
    {
        es_format_Clean( &p_chain->fmt_out );
        es_format_Copy( &p_chain->fmt_out, p_fmt_out );
    }
}",162.0,178.0,1.0,1.0,17.0,10,3,10,4,6,9,4,4,1,4,,0,5,6,3,3,void
1561,99108,filter_chain_AppendInner,1,filter_chain_AppendInner,"filter_t filter_chain_AppendInner (filter_chain_t*,char*,char*,config_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"static filter_t *filter_chain_AppendInner( filter_chain_t *chain,
    const char *name, const char *capability, config_chain_t *cfg,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    vlc_object_t *parent = chain->callbacks.sys;
    chained_filter_t *chained =
        vlc_custom_create( parent, sizeof(*chained), ""filter"" );
    if( unlikely(chained == NULL) )
        return NULL;

    filter_t *filter = &chained->filter;

    if( fmt_in == NULL )
    {
        if( chain->last != NULL )
            fmt_in = &chain->last->filter.fmt_out;
        else
            fmt_in = &chain->fmt_in;
    }

    if( fmt_out == NULL )
        fmt_out = &chain->fmt_out;

    es_format_Copy( &filter->fmt_in, fmt_in );
    es_format_Copy( &filter->fmt_out, fmt_out );
    filter->b_allow_fmt_out_change = chain->b_allow_fmt_out_change;
    filter->p_cfg = cfg;
    filter->psz_name = name;

    filter->owner = chain->callbacks;
    filter->owner.sys = chain;

    assert( capability != NULL )...",180.0,265.0,1.0,1.0,86.0,84,11,90,14,2,28,12,12,2,10,,0,20,12,6,6,filter_t
1562,99419,filter_chain_AppendFilter,1,filter_chain_AppendFilter,"filter_t filter_chain_AppendFilter (filter_chain_t*,char*,config_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"filter_t *filter_chain_AppendFilter( filter_chain_t *chain,
    const char *name, config_chain_t *cfg,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    return filter_chain_AppendInner( chain, name, chain->filter_cap, cfg,
                                     fmt_in, fmt_out );
}",267.0,273.0,1.0,1.0,7.0,1,1,6,5,2,2,1,1,0,1,,0,1,10,5,5,filter_t
1563,99438,filter_chain_AppendConverter,1,filter_chain_AppendConverter,"int filter_chain_AppendConverter (filter_chain_t*,es_format_t*,es_format_t*)",misc\filter_chain.c,"int filter_chain_AppendConverter( filter_chain_t *chain,
    const es_format_t *fmt_in, const es_format_t *fmt_out )
{
    return filter_chain_AppendInner( chain, NULL, chain->conv_cap, NULL,
                                     fmt_in, fmt_out ) != NULL ? 0 : -1;
}",275.0,280.0,1.0,1.0,6.0,4,4,7,4,3,2,1,1,0,1,,0,1,6,3,3,int
1564,99461,filter_chain_DeleteFilter,1,filter_chain_DeleteFilter,"void filter_chain_DeleteFilter (filter_chain_t*,filter_t*)",misc\filter_chain.c,"void filter_chain_DeleteFilter( filter_chain_t *chain, filter_t *filter )
{
    vlc_object_t *obj = chain->callbacks.sys;
    chained_filter_t *chained = (chained_filter_t *)filter;

    /* Remove it from the chain */
    if( chained->prev != NULL )
        chained->prev->next = chained->next;
    else
    {
        assert( chained == chain->first );
        chain->first = chained->next;
    }

    if( chained->next != NULL )
        chained->next->prev = chained->prev;
    else
    {
        assert( chained == chain->last );
        chain->last = chained->prev;
    }

    module_unneed( filter, filter->p_module );

    msg_Dbg( obj, ""Filter %p removed from chain"", (void *)filter );
    FilterDeletePictures( chained->pending );

    free( chained->mouse );
    es_format_Clean( &filter->fmt_out );
    es_format_Clean( &filter->fmt_in );

    vlc_object_release( filter );
    /* FIXME: check fmt_in/fmt_out consitency */
}",282.0,315.0,1.0,1.0,34.0,25,6,21,5,1,14,3,3,2,5,,0,9,4,2,2,void
1565,99574,filter_chain_AppendFromString,1,filter_chain_AppendFromString,"int filter_chain_AppendFromString (filter_chain_t*,char*)",misc\filter_chain.c,"int filter_chain_AppendFromString( filter_chain_t *chain, const char *str )
{
    vlc_object_t *obj = chain->callbacks.sys;
    char *buf = NULL;
    int ret = 0;

    while( str != NULL && str[0] != '\0' )
    {
        config_chain_t *cfg;
        char *name;

        char *next = config_ChainCreate( &name, &cfg, str );

        str = next;
        free( buf );
        buf = next;

        filter_t *filter = filter_chain_AppendFilter( chain, name, cfg,
                                                      NULL, NULL );
        if( cfg )
            config_ChainDestroy( cfg );

        if( filter == NULL )
        {
            msg_Err( obj, ""Failed to append '%s' to chain"", name );
            free( name );
            goto error;
        }

        free( name );
        ret++;
    }

    free( buf );
    return ret;

error:
    while( ret > 0 ) /* Unwind */
    {
        filter_chain_DeleteFilter( chain, &chain->last->filter );
        ret--;
    }
    free( buf );
    return VLC...",318.0,362.0,1.0,1.0,45.0,22,11,40,11,2,6,6,7,0,4,,0,4,4,2,2,int
1566,99680,filter_chain_ForEach,1,filter_chain_ForEach,"int filter_chain_ForEach (filter_chain_t*,int,void*)",misc\filter_chain.c,"int filter_chain_ForEach( filter_chain_t *chain,
                          int (*cb)( filter_t *, void * ), void *opaque )
{
    for( chained_filter_t *f = chain->first; f != NULL; f = f->next )
    {
        int ret = cb( &f->filter, opaque );
        if( ret )
            return ret;
    }
    return VLC_SUCCESS;
}",364.0,374.0,1.0,1.0,11.0,6,4,10,6,10,1,3,4,0,0,,0,1,6,3,3,int
1567,99720,filter_chain_IsEmpty,1,filter_chain_IsEmpty,bool filter_chain_IsEmpty (filter_chain_t*),misc\filter_chain.c,"bool filter_chain_IsEmpty(const filter_chain_t *chain)
{
    return chain->first == NULL;
}",376.0,379.0,1.0,1.0,4.0,2,2,2,2,3,1,1,1,0,0,,0,1,2,1,1,bool
1568,99731,filter_chain_GetFmtOut,1,filter_chain_GetFmtOut,es_format_t filter_chain_GetFmtOut (filter_chain_t*),misc\filter_chain.c,"const es_format_t *filter_chain_GetFmtOut( filter_chain_t *p_chain )
{

    if( p_chain->b_allow_fmt_out_change )
        return &p_chain->fmt_out;

    if( p_chain->last != NULL )
        return &p_chain->last->filter.fmt_out;

    /* Unless filter_chain_Reset has been called we are doomed */
    return &p_chain->fmt_out;
}",381.0,392.0,1.0,1.0,12.0,11,4,6,2,1,5,3,3,2,0,,0,5,2,1,1,es_format_t
1569,99767,FilterChainVideoFilter,1,FilterChainVideoFilter,"picture_t FilterChainVideoFilter (chained_filter_t*,picture_t*)",misc\filter_chain.c,"static picture_t *FilterChainVideoFilter( chained_filter_t *f, picture_t *p_pic )
{
    for( ; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        p_pic = p_filter->pf_video_filter( p_filter, p_pic );
        if( !p_pic )
            break;
        if( f->pending )
        {
            msg_Warn( p_filter, ""dropping pictures"" );
            FilterDeletePictures( f->pending );
        }
        f->pending = p_pic->p_next;
        p_pic->p_next = NULL;
    }
    return p_pic;
}",394.0,411.0,1.0,1.0,18.0,14,5,17,4,2,5,5,6,1,1,,0,4,4,2,2,picture_t
1570,99830,filter_chain_VideoFilter,1,filter_chain_VideoFilter,"picture_t filter_chain_VideoFilter (filter_chain_t*,picture_t*)",misc\filter_chain.c,"picture_t *filter_chain_VideoFilter( filter_chain_t *p_chain, picture_t *p_pic )
{
    if( p_pic )
    {
        p_pic = FilterChainVideoFilter( p_chain->first, p_pic );
        if( p_pic )
            return p_pic;
    }
    for( chained_filter_t *b = p_chain->last; b != NULL; b = b->prev )
    {
        p_pic = b->pending;
        if( !p_pic )
            continue;
        b->pending = p_pic->p_next;
        p_pic->p_next = NULL;

        p_pic = FilterChainVideoFilter( b->next, p_pic );
        if( p_pic )
            return p_pic;
    }
    return NULL;
}",413.0,434.0,1.0,1.0,22.0,15,4,23,4,5,4,7,9,0,2,,0,4,4,2,2,picture_t
1571,99904,filter_chain_VideoFlush,1,filter_chain_VideoFlush,void filter_chain_VideoFlush (filter_chain_t*),misc\filter_chain.c,"void filter_chain_VideoFlush( filter_chain_t *p_chain )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        FilterDeletePictures( f->pending );
        f->pending = NULL;

        filter_Flush( p_filter );
    }
}",436.0,447.0,1.0,1.0,12.0,9,4,10,4,3,2,2,2,0,1,,0,1,2,1,1,void
1572,99944,filter_chain_SubSource,1,filter_chain_SubSource,"void filter_chain_SubSource (filter_chain_t*,spu_t*,mtime_t)",misc\filter_chain.c,"void filter_chain_SubSource( filter_chain_t *p_chain, spu_t *spu,
                             mtime_t display_date )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;
        subpicture_t *p_subpic = p_filter->pf_sub_source( p_filter, display_date );
        if( p_subpic )
            spu_PutSubpicture( spu, p_subpic );
    }
}",449.0,459.0,1.0,1.0,11.0,8,4,13,7,1,2,3,4,0,1,,0,1,6,3,3,void
1573,99990,filter_chain_SubFilter,1,filter_chain_SubFilter,"subpicture_t filter_chain_SubFilter (filter_chain_t*,subpicture_t*)",misc\filter_chain.c,"subpicture_t *filter_chain_SubFilter( filter_chain_t *p_chain, subpicture_t *p_subpic )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        p_subpic = p_filter->pf_sub_filter( p_filter, p_subpic );

        if( !p_subpic )
            break;
    }
    return p_subpic;
}",461.0,473.0,1.0,1.0,13.0,9,5,12,5,1,1,4,4,0,0,,0,1,4,2,2,subpicture_t
1574,100035,filter_chain_MouseFilter,1,filter_chain_MouseFilter,"int filter_chain_MouseFilter (filter_chain_t*,vlc_mouse_t*,vlc_mouse_t*)",misc\filter_chain.c,"int filter_chain_MouseFilter( filter_chain_t *p_chain, vlc_mouse_t *p_dst, const vlc_mouse_t *p_src )
{
    vlc_mouse_t current = *p_src;

    for( chained_filter_t *f = p_chain->last; f != NULL; f = f->prev )
    {
        filter_t *p_filter = &f->filter;
        vlc_mouse_t *p_mouse = f->mouse;

        if( p_filter->pf_video_mouse && p_mouse )
        {
            vlc_mouse_t old = *p_mouse;
            vlc_mouse_t filtered;

            *p_mouse = current;
            if( p_filter->pf_video_mouse( p_filter, &filtered, &old, &current ) )
                return VLC_EGENERIC;
            current = filtered;
        }
    }

    *p_dst = current;
    return VLC_SUCCESS;
}",475.0,498.0,1.0,1.0,24.0,23,6,27,12,2,1,4,7,0,0,,0,1,6,3,3,int
1575,100118,filter_chain_MouseEvent,1,filter_chain_MouseEvent,"int filter_chain_MouseEvent (filter_chain_t*,vlc_mouse_t*,video_format_t*)",misc\filter_chain.c,"int filter_chain_MouseEvent( filter_chain_t *p_chain,
                             const vlc_mouse_t *p_mouse,
                             const video_format_t *p_fmt )
{
    for( chained_filter_t *f = p_chain->first; f != NULL; f = f->next )
    {
        filter_t *p_filter = &f->filter;

        if( p_filter->pf_sub_mouse )
        {
            vlc_mouse_t old = *f->mouse;
            *f->mouse = *p_mouse;
            if( p_filter->pf_sub_mouse( p_filter, &old, p_mouse, p_fmt ) )
                return VLC_EGENERIC;
        }
    }

    return VLC_SUCCESS;
}",500.0,518.0,1.0,1.0,19.0,16,5,18,9,0,1,4,7,0,0,,0,1,6,3,3,int
1576,100217,fingerprinter_Create,1,fingerprinter_Create,fingerprinter_thread_t fingerprinter_Create (vlc_object_t*),misc\fingerprinter.c,"fingerprinter_thread_t *fingerprinter_Create( vlc_object_t *p_this )
{
    fingerprinter_thread_t *p_fingerprint;

    p_fingerprint = ( fingerprinter_thread_t * )
            vlc_custom_create( p_this, sizeof( *p_fingerprint ), ""fingerprinter"" );
    if( !p_fingerprint )
    {
        msg_Err( p_this, ""unable to create fingerprinter"" );
        return NULL;
    }

    p_fingerprint->p_module = module_need( p_fingerprint, ""fingerprinter"",
                                           NULL, false );
    if( !p_fingerprint->p_module )
    {
        vlc_object_release( p_fingerprint );
        msg_Err( p_this, ""AcoustID fingerprinter not found"" );
        return NULL;
    }

    return p_fingerprint;
}",30.0,52.0,1.0,12.0,23.0,9,6,16,4,0,3,3,3,0,3,,0,2,2,1,1,fingerprinter_thread_t
1577,100271,fingerprinter_Destroy,1,fingerprinter_Destroy,void fingerprinter_Destroy (fingerprinter_thread_t*),misc\fingerprinter.c,"void fingerprinter_Destroy( fingerprinter_thread_t *p_fingerprint )
{
    module_unneed( p_fingerprint, p_fingerprint->p_module );
    vlc_object_release( p_fingerprint );
}",54.0,58.0,1.0,1.0,5.0,1,1,3,1,0,2,1,1,0,2,,0,0,2,1,1,void
1578,100311,Lookup,1,Lookup,"vlc_fourcc_t Lookup (vlc_fourcc_t,char**,fourcc_mapping*,size_t,fourcc_desc*,size_t)",misc\variables.c,"static variable_t *Lookup( vlc_object_t *obj, const char *psz_name )
{
    vlc_object_internals_t *priv = vlc_internals( obj );
    variable_t **pp_var;

    vlc_mutex_lock(&priv->var_lock);
    pp_var = tfind( &psz_name, &priv->var_root, varcmp );
    return (pp_var != NULL) ? *pp_var : NULL;
}",153.0,161.0,1.0,35.0,9.0,26,7,33,9,12,0,6,9,0,0,,0,0,4,2,2,variable_t
1579,100406,LookupVideo,1,LookupVideo,"vlc_fourcc_t LookupVideo (vlc_fourcc_t,char**)",misc\fourcc.c,"static vlc_fourcc_t LookupVideo(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_video,
                  sizeof (mapping_video) / sizeof (mapping_video[0]),
                  desc_video, sizeof (desc_video) / sizeof (desc_video[0]));
}",73.0,78.0,1.0,1.0,6.0,6,2,8,4,2,1,1,1,0,1,,0,0,4,2,2,vlc_fourcc_t
1580,100428,LookupAudio,1,LookupAudio,"vlc_fourcc_t LookupAudio (vlc_fourcc_t,char**)",misc\fourcc.c,"static vlc_fourcc_t LookupAudio(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_audio,
                  sizeof (mapping_audio) / sizeof (mapping_audio[0]),
                  desc_audio, sizeof (desc_audio) / sizeof (desc_audio[0]));
}",80.0,85.0,1.0,1.0,6.0,6,2,8,4,2,1,1,1,0,1,,0,0,4,2,2,vlc_fourcc_t
1581,100450,LookupSpu,1,LookupSpu,"vlc_fourcc_t LookupSpu (vlc_fourcc_t,char**)",misc\fourcc.c,"static vlc_fourcc_t LookupSpu(vlc_fourcc_t fourcc, const char **restrict dsc)
{
    return Lookup(fourcc, dsc, mapping_spu,
                  sizeof (mapping_spu) / sizeof (mapping_spu[0]),
                  desc_spu, sizeof (desc_spu) / sizeof (desc_spu[0]));
}",87.0,92.0,1.0,1.0,6.0,6,2,8,4,2,1,1,1,0,1,,0,0,4,2,2,vlc_fourcc_t
1582,100472,LookupCat,1,LookupCat,"vlc_fourcc_t LookupCat (vlc_fourcc_t,char**,int)",misc\fourcc.c,"static vlc_fourcc_t LookupCat(vlc_fourcc_t fourcc, const char **restrict dsc,
                              int cat)
{
    switch (cat)
    {
        case VIDEO_ES:
            return LookupVideo(fourcc, dsc);
        case AUDIO_ES:
            return LookupAudio(fourcc, dsc);
        case SPU_ES:
            return LookupSpu(fourcc, dsc);
    }

    vlc_fourcc_t ret = LookupVideo(fourcc, dsc);
    if (!ret)
        ret = LookupAudio(fourcc, dsc);
    if (!ret)
        ret = LookupSpu(fourcc, dsc);
    return ret;
}",94.0,113.0,1.0,1.0,20.0,5,2,22,7,2,6,4,4,0,6,,0,3,6,3,3,vlc_fourcc_t
1583,100526,vlc_fourcc_GetCodec,1,vlc_fourcc_GetCodec,"vlc_fourcc_t vlc_fourcc_GetCodec (int,vlc_fourcc_t)",misc\fourcc.c,"vlc_fourcc_t vlc_fourcc_GetCodec(int cat, vlc_fourcc_t fourcc)
{
    vlc_fourcc_t codec = LookupCat(fourcc, NULL, cat);
    return codec ? codec : fourcc;
}",115.0,119.0,1.0,1.0,5.0,2,2,7,4,10,1,1,1,0,1,,0,1,4,2,2,vlc_fourcc_t
1584,100544,vlc_fourcc_GetCodecFromString,1,vlc_fourcc_GetCodecFromString,"vlc_fourcc_t vlc_fourcc_GetCodecFromString (int,char*)",misc\fourcc.c,"vlc_fourcc_t vlc_fourcc_GetCodecFromString( int i_cat, const char *psz_fourcc )
{
    if( !psz_fourcc || strlen(psz_fourcc) != 4 )
        return 0;
    return vlc_fourcc_GetCodec( i_cat,
                                VLC_FOURCC( psz_fourcc[0], psz_fourcc[1],
                                            psz_fourcc[2], psz_fourcc[3] ) );
}",121.0,128.0,1.0,1.0,8.0,7,4,7,2,0,1,2,2,0,1,,0,0,4,2,2,vlc_fourcc_t
1585,100577,vlc_fourcc_GetCodecAudio,1,vlc_fourcc_GetCodecAudio,"vlc_fourcc_t vlc_fourcc_GetCodecAudio (vlc_fourcc_t,int)",misc\fourcc.c,"vlc_fourcc_t vlc_fourcc_GetCodecAudio( vlc_fourcc_t i_fourcc, int i_bits )
{
    const int i_bytes = ( i_bits + 7 ) / 8;

    if( i_fourcc == VLC_FOURCC( 'a', 'f', 'l', 't' ) )
    {
        switch( i_bytes )
        {
        case 4:
            return VLC_CODEC_FL32;
        case 8:
            return VLC_CODEC_FL64;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 'a', 'r', 'a', 'w' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_U8;
        case 2:
            return VLC_CODEC_S16L;
        case 3:
            return VLC_CODEC_S24L;
        case 4:
            return VLC_CODEC_S32L;
        default:
            return 0;
        }
    }
    else if( i_fourcc == VLC_FOURCC( 't', 'w', 'o', 's' ) )
    {
        switch( i_bytes )
        {
        case 1:
            return VLC_CODEC_S8;
        case 2:
            return VLC_CODEC_S16B;
        case 3:
            return VLC_CODEC_S24B;
        c...",130.0,198.0,1.0,1.0,69.0,4,4,6,5,1,0,3,4,0,0,,0,0,4,2,2,vlc_fourcc_t
1586,100719,vlc_fourcc_GetDescription,1,vlc_fourcc_GetDescription,"const char* vlc_fourcc_GetDescription (int,vlc_fourcc_t)",misc\fourcc.c,"const char *vlc_fourcc_GetDescription(int cat, vlc_fourcc_t fourcc)
{
    const char *ret;

    return LookupCat(fourcc, &ret, cat) ? ret : """";
}",200.0,205.0,1.0,1.0,6.0,2,2,4,3,1,1,1,1,0,1,,0,0,4,2,2,const char*
1587,101940,GetFallback,1,GetFallback,"vlc_fourcc_t GetFallback (vlc_fourcc_t,vlc_fourcc_t[]*,vlc_fourcc_t[])",misc\fourcc.c,"static const vlc_fourcc_t *GetFallback( vlc_fourcc_t i_fourcc,
                                        const vlc_fourcc_t *pp_fallback[],
                                        const vlc_fourcc_t p_list[] )
{
    for( unsigned i = 0; pp_fallback[i]; i++ )
    {
        if( pp_fallback[i][0] == i_fourcc )
            return pp_fallback[i];
    }
    return p_list;
}",597.0,607.0,1.0,1.0,11.0,6,3,9,4,2,0,3,4,0,0,,0,0,6,3,3,vlc_fourcc_t
1588,101974,vlc_fourcc_GetYUVFallback,1,vlc_fourcc_GetYUVFallback,vlc_fourcc_t vlc_fourcc_GetYUVFallback (vlc_fourcc_t),misc\fourcc.c,"const vlc_fourcc_t *vlc_fourcc_GetYUVFallback( vlc_fourcc_t i_fourcc )
{
    return GetFallback( i_fourcc, pp_YUV_fallback, p_list_YUV );
}",609.0,612.0,1.0,1.0,4.0,0,0,3,3,0,3,1,1,0,1,,0,2,2,1,1,vlc_fourcc_t
1589,101984,vlc_fourcc_GetRGBFallback,1,vlc_fourcc_GetRGBFallback,vlc_fourcc_t vlc_fourcc_GetRGBFallback (vlc_fourcc_t),misc\fourcc.c,"const vlc_fourcc_t *vlc_fourcc_GetRGBFallback( vlc_fourcc_t i_fourcc )
{
    return GetFallback( i_fourcc, pp_RGB_fallback, p_RGB32_fallback );
}",613.0,616.0,1.0,1.0,4.0,0,0,3,3,0,3,1,1,0,1,,0,2,2,1,1,vlc_fourcc_t
1590,102085,vlc_fourcc_IsYUV,1,vlc_fourcc_IsYUV,bool vlc_fourcc_IsYUV (vlc_fourcc_t),misc\fourcc.c,"bool vlc_fourcc_IsYUV(vlc_fourcc_t fcc)
{
    for( unsigned i = 0; p_list_YUV[i]; i++ )
    {
        if( p_list_YUV[i] == fcc )
            return true;
    }
    return false;
}",645.0,653.0,1.0,1.0,9.0,4,3,8,5,2,2,3,4,2,0,,0,2,2,1,1,bool
1591,104764,vlc_fourcc_GetChromaDescription,1,vlc_fourcc_GetChromaDescription,vlc_chroma_description_t vlc_fourcc_GetChromaDescription (vlc_fourcc_t),misc\fourcc.c,"const vlc_chroma_description_t *vlc_fourcc_GetChromaDescription( vlc_fourcc_t i_fourcc )
{
    for( unsigned i = 0; p_list_chroma_description[i].p_fourcc[0]; i++ )
    {
        const vlc_fourcc_t *p_fourcc = p_list_chroma_description[i].p_fourcc;
        for( unsigned j = 0; j < 4 && p_fourcc[j] != 0; j++ )
        {
            if( p_fourcc[j] == i_fourcc )
                return &p_list_chroma_description[i].description;
        }
    }
    return NULL;
}",781.0,793.0,1.0,1.0,13.0,17,8,16,6,2,3,4,7,1,0,,0,3,2,1,1,vlc_chroma_description_t
1592,104878,cmp_entry,1,cmp_entry,"int cmp_entry (void*,void*)",misc\fourcc_gen.c,"static int cmp_entry(const void *a, const void *b)
{
    const struct entry *ea = a, *eb = b;
    int d = memcmp(ea->alias, eb->alias, 4);
    if (d == 0)
        d = memcmp(ea->fourcc, eb->fourcc, 4);
    return d;
}",58.0,65.0,1.0,1.0,8.0,9,3,12,5,0,4,2,2,0,0,,0,4,4,2,2,int
1593,104920,process_list,1,process_list,"void process_list (char*,staticentry_t*,size_t)",misc\fourcc_gen.c,"static void process_list(const char *name, const staticentry_t *list, size_t n)
{
    struct entry *entries = malloc(sizeof (*entries) * n);
    if (entries == NULL)
        abort();

    const staticentry_t *klass = NULL;

    for (size_t i = 0; i < n; i++)
    {
        if (list[i].klass)
            klass = &list[i];

        if (klass == NULL)
        {
            fprintf(stderr, ""Error: FourCC \""%.4s\"" not mapped!\n"",
                    list[i].fourcc);
            exit(1);
        }

        memcpy(entries[i].fourcc, klass->fourcc, 4);
        memcpy(entries[i].alias, list[i].fourcc, 4);
        entries[i].desc = list[i].description;
    }

    qsort(entries, n, sizeof (*entries), cmp_entry);

    size_t dups = 0;
    for (size_t i = 1; i < n; i++)
        if (!memcmp(entries[i - 1].alias, entries[i].alias, 4)
         && memcmp(entries[i - 1].fourcc, entries[i].fourcc, 4))
        {
            fprintf(stderr, ""Error: FourCC alias \""%.4s\"" conflict: ""
                    ""\...",67.0,133.0,1.0,1.0,67.0,84,12,84,9,3,1,13,15,0,0,,0,1,6,3,3,void
1594,105262,main,1,main,int main (void),misc\fourcc_gen.c,"int main(void)
{
    puts(""/* This file is generated automatically. DO NOT EDIT! */"");
    puts(""struct fourcc_mapping {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    union { unsigned char fourcc_str[4]; vlc_fourcc_t fourcc; };"");
    puts(""};"");
    puts(""struct fourcc_desc {"");
    puts(""    union { unsigned char alias_str[4]; vlc_fourcc_t alias; };"");
    puts(""    const char desc[52];"");
    puts(""};"");

#define p(t) \
    process_list(#t, p_list_##t, \
                 sizeof (p_list_##t) / sizeof ((p_list_##t)[0]))
    p(video);
    p(audio);
    p(spu);
    return 0;
}",135.0,154.0,1.0,4.0,20.0,12,3,9,3,0,3,1,1,0,3,,0,0,2,1,1,int
1595,108252,cookie_get_attribute_value,1,cookie_get_attribute_value,"char* cookie_get_attribute_value (char*,char*)",misc\httpcookies.c,"static char *cookie_get_attribute_value( const char *cookie, const char *attr )
{
    size_t attrlen = strlen( attr );
    const char * str = strchr( cookie, ';' );
    while( str )
    {
        /* skip ; and blank */
        str++;
        str = str + strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=') )
        {
            str += attrlen + 1;
            size_t value_length = strcspn( str, "";"" );
            return strndup( str, value_length );
        }

        str = strchr( str, ';' );
    }
    return NULL;
}",48.0,69.0,1.0,1.0,22.0,13,8,23,6,2,0,3,4,0,0,,0,0,4,2,2,char*
1596,108316,cookie_has_attribute,1,cookie_has_attribute,"bool cookie_has_attribute (char*,char*)",misc\httpcookies.c,"static bool cookie_has_attribute( const char *cookie, const char *attr )
{
    size_t attrlen = strlen(attr);
    const char * str = strchr(cookie, ';');
    while( str )
    {
        /* skip ; and blank */
        str++;
        str += strspn( str, "" "" );

        if( !vlc_ascii_strncasecmp( str, attr, attrlen )
         && (str[attrlen] == '=' || str[attrlen] == ';' || str[attrlen] == '\0') )
            return true;

        str = strchr(str, ';');
    }
    return false;
}",71.0,88.0,1.0,1.0,18.0,15,8,21,6,1,0,3,4,0,0,,0,0,4,2,2,bool
1597,108377,cookie_get_domain,1,cookie_get_domain,char* cookie_get_domain (char*),misc\httpcookies.c,"static char *cookie_get_domain( const char *cookie )
{
    char *domain = cookie_get_attribute_value( cookie, ""domain"" );
    if( domain == NULL )
        return NULL;

    if( domain[0] == '.' )
    {
        const char *real_domain = domain + strspn( domain, ""."" );
        memmove( domain, real_domain, strlen( real_domain ) + 1 );
    }
    return domain;
}",91.0,103.0,1.0,1.0,13.0,7,4,13,4,1,1,3,3,0,1,,0,1,2,1,1,char*
1598,108419,cookie_domain_matches,1,cookie_domain_matches,"bool cookie_domain_matches (http_cookie_t*,char*)",misc\httpcookies.c,"static bool cookie_domain_matches( const http_cookie_t *cookie,
                                   const char *host )
{
    // TODO: should convert domain names to punycode before comparing

    if (host == NULL)
        return false;
    if ( vlc_ascii_strcasecmp(cookie->psz_domain, host) == 0 )
        return true;
    else if ( cookie->b_host_only )
        return false;

    size_t host_len = strlen(host);
    size_t cookie_domain_len = strlen(cookie->psz_domain);
    bool is_suffix = false, has_dot_before_suffix = false;

    if( host_len > cookie_domain_len )
    {
        size_t i = host_len - cookie_domain_len;

        is_suffix = vlc_ascii_strcasecmp( &host[i], cookie->psz_domain ) == 0;
        has_dot_before_suffix = host[i-1] == '.';
    }

    bool host_is_ipv4 = strspn(host, ""0123456789."") == host_len;
    bool host_is_ipv6 = strchr(host, ':') != NULL;
    return is_suffix && has_dot_before_suffix &&
        !( host_is_ipv4 || host_is_ipv6 );
}",105.0,133.0,1.0,1.0,29.0,28,11,36,12,2,3,4,4,1,0,,0,3,4,2,2,bool
1599,108529,cookie_get_path,1,cookie_get_path,char* cookie_get_path (char*),misc\httpcookies.c,"static char *cookie_get_path(const char *cookie)
{
    return cookie_get_attribute_value(cookie, ""path"");
}",135.0,138.0,1.0,1.0,4.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,char*
1600,108538,cookie_path_matches,1,cookie_path_matches,"bool cookie_path_matches (http_cookie_t*,char*)",misc\httpcookies.c,"static bool cookie_path_matches( const http_cookie_t * cookie, const char *uripath )
{
    if (uripath == NULL )
        return false;
    else if ( strcmp(cookie->psz_path, uripath) == 0 )
        return true;

    size_t path_len = strlen( uripath );
    size_t prefix_len = strlen( cookie->psz_path );
    return ( path_len > prefix_len ) &&
        ( strncmp(uripath, cookie->psz_path, prefix_len) == 0 ) &&
        ( uripath[prefix_len - 1] == '/' || uripath[prefix_len] == '/' );
}",140.0,152.0,1.0,1.0,13.0,15,8,16,6,1,2,2,2,0,0,,0,2,4,2,2,bool
1601,108603,cookie_should_be_sent,1,cookie_should_be_sent,"bool cookie_should_be_sent (http_cookie_t*,bool,char*,char*)",misc\httpcookies.c,"static bool cookie_should_be_sent(const http_cookie_t *cookie, bool secure,
                                  const char *host, const char *path)
{
    bool protocol_ok = secure || !cookie->b_secure;
    bool domain_ok = cookie_domain_matches(cookie, host);
    bool path_ok = cookie_path_matches(cookie, path);
    return protocol_ok && domain_ok && path_ok;
}",154.0,161.0,1.0,1.0,8.0,8,5,12,7,1,3,1,1,0,2,,0,3,8,4,4,bool
1602,108638,cookie_default_path,1,cookie_default_path,char* cookie_default_path (char*),misc\httpcookies.c,"static char *cookie_default_path( const char *request_path )
{
    if ( request_path == NULL || request_path[0] != '/' )
        return strdup(""/"");

    char *path;
    const char *query_start = strchr( request_path, '?' );
    if ( query_start != NULL )
        path = strndup( request_path, query_start - request_path );
    else
        path = strdup( request_path );

    if ( path == NULL )
        return NULL;

    char *last_slash = strrchr(path, '/');
    assert(last_slash != NULL);
    if ( last_slash == path )
        path[1] = '\0';
    else
        *last_slash = '\0';

    return path;
}",163.0,186.0,1.0,1.0,24.0,14,6,22,5,1,0,5,5,0,0,,0,0,2,1,1,char*
1603,108717,cookie_destroy,1,cookie_destroy,void cookie_destroy (http_cookie_t*),misc\httpcookies.c,"static void cookie_destroy(http_cookie_t *cookie)
{
    assert(cookie != NULL);
    free(cookie->psz_name);
    free(cookie->psz_value);
    free(cookie->psz_domain);
    free(cookie->psz_path);
    free(cookie);
}",188.0,196.0,1.0,1.0,9.0,5,2,7,2,4,4,1,1,0,0,,0,4,2,1,1,void
1604,108746,cookie_parse,1,cookie_parse,"http_cookie_t cookie_parse (char*,char*,char*)",misc\httpcookies.c,"static http_cookie_t *cookie_parse(const char *value,
                                   const char *host, const char *path)
{
    http_cookie_t *cookie = malloc(sizeof (*cookie));
    if (unlikely(cookie == NULL))
        return NULL;

    cookie->psz_domain = NULL;
    cookie->psz_path = NULL;

    /* Get the NAME=VALUE part of the Cookie */
    size_t value_length = strcspn(value, "";"");
    const char *p = memchr(value, '=', value_length);

    if (p != NULL)
    {
        cookie->psz_name = strndup(value, p - value);
        p++;
        cookie->psz_value = strndup(p, value_length - (p - value));
        if (unlikely(cookie->psz_value == NULL))
            goto error;
    }
    else
    {
        cookie->psz_name = strndup(value, value_length);
        cookie->psz_value = NULL;
    }

    if (unlikely(cookie->psz_name == NULL))
        goto error;

    /* Cookie name is a token; it cannot be empty. */
    if (cookie->psz_name[0] == '\0')
        goto error;

    /* Get domain */...",199.0,264.0,1.0,1.0,66.0,46,9,54,8,1,22,15,13,7,5,,0,21,6,3,3,http_cookie_t
1605,108945,vlc_http_cookies_new,1,vlc_http_cookies_new,vlc_http_cookie_jar_t vlc_http_cookies_new (void),misc\httpcookies.c,"vlc_http_cookie_jar_t * vlc_http_cookies_new(void)
{
    vlc_http_cookie_jar_t * jar = malloc( sizeof( vlc_http_cookie_jar_t ) );
    if ( unlikely(jar == NULL) )
        return NULL;

    vlc_array_init( &jar->cookies );
    vlc_mutex_init( &jar->lock );

    return jar;
}",272.0,282.0,1.0,1.0,11.0,7,5,8,3,1,3,2,2,0,1,,0,2,2,1,1,vlc_http_cookie_jar_t
1606,108976,vlc_http_cookies_destroy,1,vlc_http_cookies_destroy,void vlc_http_cookies_destroy (vlc_http_cookie_jar_t*),misc\httpcookies.c,"void vlc_http_cookies_destroy( vlc_http_cookie_jar_t * p_jar )
{
    if ( !p_jar )
        return;

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
        cookie_destroy( vlc_array_item_at_index( &p_jar->cookies, i ) );

    vlc_array_clear( &p_jar->cookies );
    vlc_mutex_destroy( &p_jar->lock );

    free( p_jar );
}",284.0,296.0,1.0,1.0,13.0,9,5,7,2,1,4,3,3,1,1,,0,3,2,1,1,void
1607,109020,vlc_http_cookies_store,1,vlc_http_cookies_store,"bool vlc_http_cookies_store (vlc_http_cookie_jar_t*,char*,char*,char*)",misc\httpcookies.c,"bool vlc_http_cookies_store(vlc_http_cookie_jar_t *p_jar, const char *cookies,
                            const char *host, const char *path)
{
    assert(host != NULL);
    assert(path != NULL);

    http_cookie_t *cookie = cookie_parse(cookies, host, path);
    if (cookie == NULL)
        return false;

    /* Check if a cookie from host should be added to the cookie jar */
    // FIXME: should check if domain is one of ""public suffixes"" at
    // http://publicsuffix.org/. The purpose of this check is to
    // prevent a host from setting a ""too wide"" cookie, for example
    // ""example.com"" should not be able to set a cookie for ""com"".
    // The current implementation prevents all top-level domains.
    if (strchr(cookie->psz_domain, '.') == NULL
     || !cookie_domain_matches(cookie, host))
    {
        cookie_destroy(cookie);
        return false;
    }

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        ht...",298.0,351.0,1.0,1.0,54.0,43,9,49,13,0,23,7,7,3,7,,0,18,8,4,4,bool
1608,109186,vlc_http_cookies_fetch,1,vlc_http_cookies_fetch,"char* vlc_http_cookies_fetch (vlc_http_cookie_jar_t*,bool,char*,char*)",misc\httpcookies.c,"char *vlc_http_cookies_fetch(vlc_http_cookie_jar_t *p_jar, bool secure,
                             const char *host, const char *path)
{
    char *psz_cookiebuf = NULL;

    vlc_mutex_lock( &p_jar->lock );

    for( size_t i = 0; i < vlc_array_count( &p_jar->cookies ); i++ )
    {
        const http_cookie_t * cookie = vlc_array_item_at_index( &p_jar->cookies, i );
        if (cookie_should_be_sent(cookie, secure, host, path))
        {
            char *psz_updated_buf = NULL;
            if ( asprintf(&psz_updated_buf, ""%s%s%s=%s"",
                          psz_cookiebuf ? psz_cookiebuf : """",
                          psz_cookiebuf ? ""; "" : """",
                          cookie->psz_name ? cookie->psz_name : """",
                          cookie->psz_value ? cookie->psz_value : """") == -1 )
            {
                // TODO: report error
                free( psz_cookiebuf );
                vlc_mutex_unlock( &p_jar->lock );
                return NULL;
            }
          ...",353.0,385.0,1.0,1.0,33.0,27,7,31,9,0,13,4,7,6,4,,0,10,8,4,4,char*
1609,109385,DeleteEncoder,1,DeleteEncoder,void DeleteEncoder (encoder_t*),misc\image.c,"static void DeleteEncoder( encoder_t * p_enc )
{
    if( p_enc->p_module ) module_unneed( p_enc, p_enc->p_module );

    es_format_Clean( &p_enc->fmt_in );
    es_format_Clean( &p_enc->fmt_out );

    vlc_object_release( p_enc );
    p_enc = NULL;
}",785.0,794.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1610,109397,DeleteFilter,1,DeleteFilter,void DeleteFilter (filter_t*),misc\image.c,"static void DeleteFilter( filter_t * p_filter )
{
    if( p_filter->p_module ) module_unneed( p_filter, p_filter->p_module );

    es_format_Clean( &p_filter->fmt_in );
    es_format_Clean( &p_filter->fmt_out );

    vlc_object_release( p_filter );
}",830.0,838.0,1.0,1.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1611,109402,image_Type2Fourcc,1,image_Type2Fourcc,vlc_fourcc_t image_Type2Fourcc (char*),misc\image.c,"vlc_fourcc_t image_Type2Fourcc( const char *psz_type )
{
    for( unsigned i = 0; i < ARRAY_SIZE(ext_table); i++ )
        if( !strcasecmp( ext_table[i].psz_ext, psz_type ) )
            return ext_table[i].i_codec;

    return 0;
}",608.0,615.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,vlc_fourcc_t
1612,109412,image_HandlerCreate,1,image_HandlerCreate,image_handler_t image_HandlerCreate (vlc_object_t*),misc\image.c,"image_handler_t *image_HandlerCreate( vlc_object_t *p_this )
{
    image_handler_t *p_image = calloc( 1, sizeof(image_handler_t) );
    if( !p_image )
        return NULL;

    p_image->p_parent = p_this;

    p_image->pf_read = ImageRead;
    p_image->pf_read_url = ImageReadUrl;
    p_image->pf_write = ImageWrite;
    p_image->pf_write_url = ImageWriteUrl;
    p_image->pf_convert = ImageConvert;

    p_image->outfifo = picture_fifo_New();

    return p_image;
}",82.0,99.0,1.0,1.0,18.0,17,4,15,6,3,1,2,2,0,1,,0,1,2,1,1,image_handler_t
1613,109467,image_HandlerDelete,1,image_HandlerDelete,void image_HandlerDelete (image_handler_t*),misc\image.c,"void image_HandlerDelete( image_handler_t *p_image )
{
    if( !p_image ) return;

    if( p_image->p_dec ) DeleteDecoder( p_image->p_dec );
    if( p_image->p_enc ) DeleteEncoder( p_image->p_enc );
    if( p_image->p_filter ) DeleteFilter( p_image->p_filter );

    picture_fifo_Delete( p_image->outfifo );

    free( p_image );
    p_image = NULL;
}",105.0,117.0,1.0,1.0,13.0,9,3,11,2,3,4,5,5,0,4,,0,0,2,1,1,void
1614,109513,ImageQueueVideo,1,ImageQueueVideo,"int ImageQueueVideo (decoder_t*,picture_t*)",misc\image.c,"static int ImageQueueVideo( decoder_t *p_dec, picture_t *p_pic )
{
    image_handler_t *p_image = p_dec->p_queue_ctx;
    picture_fifo_Push( p_image->outfifo, p_pic );
    return 0;
}",124.0,129.0,1.0,1.0,6.0,3,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
1615,110301,BitMapFormatIsSimilar,1,BitMapFormatIsSimilar,"bool BitMapFormatIsSimilar (video_format_t*,video_format_t*)",misc\image.c,"static bool BitMapFormatIsSimilar( const video_format_t *f1,
                                   const video_format_t *f2 )
{
    if( f1->i_chroma == VLC_CODEC_RGB15 ||
        f1->i_chroma == VLC_CODEC_RGB16 ||
        f1->i_chroma == VLC_CODEC_RGB24 ||
        f1->i_chroma == VLC_CODEC_RGB32 )
    {
        video_format_t v1 = *f1;
        video_format_t v2 = *f2;

        video_format_FixRgb( &v1 );
        video_format_FixRgb( &v2 );

        if( v1.i_rmask != v2.i_rmask ||
            v1.i_gmask != v2.i_gmask ||
            v1.i_bmask != v2.i_bmask )
            return false;
    }
    return true;
}",327.0,347.0,1.0,1.0,21.0,28,8,22,10,0,2,3,4,0,2,,0,0,4,2,2,bool
1616,111392,image_Mime2Fourcc,1,image_Mime2Fourcc,vlc_fourcc_t image_Mime2Fourcc (char*),misc\image.c,"vlc_fourcc_t image_Mime2Fourcc( const char *psz_mime )
{
    for( int i = 0; mime_table[i].i_codec; i++ )
        if( !strcmp( psz_mime, mime_table[i].psz_mime ) )
            return mime_table[i].i_codec;
    return 0;
}",652.0,658.0,1.0,1.0,7.0,3,3,3,2,0,1,2,2,1,0,,0,1,2,1,1,vlc_fourcc_t
1617,111448,video_new_buffer,1,video_new_buffer,picture_t video_new_buffer (decoder_t*),misc\image.c,"static picture_t *video_new_buffer( decoder_t *p_dec )
{
    return picture_NewFromFormat( &p_dec->fmt_out.video );
}",666.0,669.0,1.0,1.0,4.0,3,3,1,1,0,1,1,1,0,1,,0,0,2,1,1,picture_t
1618,111966,filter_new_picture,1,filter_new_picture,picture_t filter_new_picture (filter_t*),misc\image.c,"static picture_t *filter_new_picture( filter_t *p_filter )
{
    return picture_NewFromFormat( &p_filter->fmt_out.video );
}",796.0,799.0,1.0,1.0,4.0,3,3,1,1,0,1,1,1,0,1,,0,0,2,1,1,picture_t
1619,112139,vlc_interrupt_init,1,vlc_interrupt_init,void vlc_interrupt_init (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_init(vlc_interrupt_t *ctx)
{
    vlc_mutex_init(&ctx->lock);
    ctx->interrupted = false;
    atomic_init(&ctx->killed, false);
    ctx->callback = NULL;
}",51.0,57.0,1.0,1.0,7.0,8,3,7,3,2,1,1,1,0,1,,0,0,2,1,1,void
1620,112165,vlc_interrupt_create,1,vlc_interrupt_create,vlc_interrupt_t vlc_interrupt_create (void),misc\interrupt.c,"vlc_interrupt_t *vlc_interrupt_create(void)
{
    vlc_interrupt_t *ctx = malloc(sizeof (*ctx));
    if (likely(ctx != NULL))
        vlc_interrupt_init(ctx);
    return ctx;
}",59.0,65.0,1.0,1.0,7.0,4,4,6,2,2,1,2,2,0,1,,0,0,2,1,1,vlc_interrupt_t
1621,112187,vlc_interrupt_deinit,1,vlc_interrupt_deinit,void vlc_interrupt_deinit (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_deinit(vlc_interrupt_t *ctx)
{
    assert(ctx->callback == NULL);
    vlc_mutex_destroy(&ctx->lock);
}",71.0,75.0,1.0,1.0,5.0,4,3,3,2,4,1,1,1,0,1,,0,0,2,1,1,void
1622,112203,vlc_interrupt_destroy,1,vlc_interrupt_destroy,void vlc_interrupt_destroy (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_destroy(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);
    vlc_interrupt_deinit(ctx);
    free(ctx);
}",77.0,82.0,1.0,1.0,6.0,1,1,4,2,4,1,1,1,0,1,,0,0,2,1,1,void
1623,112216,vlc_interrupt_raise,1,vlc_interrupt_raise,void vlc_interrupt_raise (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_raise(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);

    /* This function must be reentrant. But the callback typically is not
     * reentrant. The lock ensures that all calls to the callback for a given
     * context are serialized. The lock also protects against invalid memory
     * accesses to the callback pointer proper, and the interrupted flag. */
    vlc_mutex_lock(&ctx->lock);
    ctx->interrupted = true;
    if (ctx->callback != NULL)
        ctx->callback(ctx->data);
    vlc_mutex_unlock(&ctx->lock);
}",84.0,97.0,1.0,1.0,14.0,11,4,10,3,1,2,2,2,0,2,,0,0,2,1,1,void
1624,112254,vlc_interrupt_set,1,vlc_interrupt_set,vlc_interrupt_t vlc_interrupt_set (vlc_interrupt_t*),misc\interrupt.c,"vlc_interrupt_t *vlc_interrupt_set(vlc_interrupt_t *newctx)
{
    vlc_interrupt_t *oldctx = vlc_interrupt_var;

    vlc_interrupt_var = newctx;
    return oldctx;
}",99.0,105.0,1.0,1.0,7.0,2,1,5,3,2,0,1,1,0,0,,0,0,2,1,1,vlc_interrupt_t
1625,112268,vlc_interrupt_prepare,1,vlc_interrupt_prepare,"void vlc_interrupt_prepare (vlc_interrupt_t*,void,void*)",misc\interrupt.c,"static void vlc_interrupt_prepare(vlc_interrupt_t *ctx,
                                  void (*cb)(void *), void *data)
{
    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    vlc_mutex_lock(&ctx->lock);
    assert(ctx->callback == NULL);
    ctx->callback = cb;
    ctx->data = data;

    if (unlikely(ctx->interrupted))
        cb(data);
    vlc_mutex_unlock(&ctx->lock);
}",114.0,128.0,1.0,1.0,15.0,13,5,14,5,5,2,2,2,0,2,,0,0,6,3,3,void
1626,112317,vlc_interrupt_finish,1,vlc_interrupt_finish,int vlc_interrupt_finish (vlc_interrupt_t*),misc\interrupt.c,"static int vlc_interrupt_finish(vlc_interrupt_t *ctx)
{
    int ret = 0;

    assert(ctx != NULL);
    assert(ctx == vlc_interrupt_var);

    /* Wait for pending callbacks to prevent access by other threads. */
    vlc_mutex_lock(&ctx->lock);
    ctx->callback = NULL;
    if (ctx->interrupted)
    {
        ret = EINTR;
        ctx->interrupted = false;
    }
    vlc_mutex_unlock(&ctx->lock);
    return ret;
}",141.0,158.0,1.0,1.0,18.0,13,5,15,6,8,2,2,2,0,2,,0,0,2,1,1,int
1627,112364,vlc_interrupt_register,1,vlc_interrupt_register,"void vlc_interrupt_register (void,void*)",misc\interrupt.c,"void vlc_interrupt_register(void (*cb)(void *), void *opaque)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx != NULL)
        vlc_interrupt_prepare(ctx, cb, opaque);
}",160.0,165.0,1.0,1.0,6.0,2,2,7,5,2,1,2,2,0,1,,0,0,4,2,2,void
1628,112383,vlc_interrupt_unregister,1,vlc_interrupt_unregister,int vlc_interrupt_unregister (void),misc\interrupt.c,"int vlc_interrupt_unregister(void)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    return (ctx != NULL) ? vlc_interrupt_finish(ctx) : 0;
}",167.0,171.0,1.0,1.0,5.0,3,3,5,3,2,1,1,1,0,1,,0,0,2,1,1,int
1629,112400,vlc_interrupt_cleanup,1,vlc_interrupt_cleanup,void vlc_interrupt_cleanup (void*),misc\interrupt.c,"static void vlc_interrupt_cleanup(void *opaque)
{
    vlc_interrupt_finish(opaque);
}",173.0,176.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1630,112407,vlc_interrupt_kill,1,vlc_interrupt_kill,void vlc_interrupt_kill (vlc_interrupt_t*),misc\interrupt.c,"void vlc_interrupt_kill(vlc_interrupt_t *ctx)
{
    assert(ctx != NULL);

    atomic_store(&ctx->killed, true);
    vlc_interrupt_raise(ctx);
}",178.0,184.0,1.0,1.0,7.0,3,3,5,3,4,1,1,1,0,1,,0,0,2,1,1,void
1631,112424,vlc_killed,1,vlc_killed,bool vlc_killed (void),misc\interrupt.c,"bool vlc_killed(void)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;

    return (ctx != NULL) && atomic_load(&ctx->killed);
}",186.0,191.0,1.0,1.0,6.0,5,5,5,3,14,0,1,1,0,0,,0,0,2,1,1,bool
1632,112443,vlc_interrupt_sem,1,vlc_interrupt_sem,void vlc_interrupt_sem (void*),misc\interrupt.c,"static void vlc_interrupt_sem(void *opaque)
{
    vlc_sem_post(opaque);
}",193.0,196.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1633,112450,vlc_sem_wait_i11e,1,vlc_sem_wait_i11e,int vlc_sem_wait_i11e (vlc_sem_t*),misc\interrupt.c,"int vlc_sem_wait_i11e(vlc_sem_t *sem)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return vlc_sem_wait(sem), 0;

    vlc_interrupt_prepare(ctx, vlc_interrupt_sem, sem);

    vlc_cleanup_push(vlc_interrupt_cleanup, ctx);
    vlc_sem_wait(sem);
    vlc_cleanup_pop();

    return vlc_interrupt_finish(ctx);
}",198.0,211.0,1.0,1.0,14.0,3,3,10,4,1,4,2,2,0,4,,0,0,2,1,1,int
1634,112482,vlc_mwait_i11e_wake,1,vlc_mwait_i11e_wake,void vlc_mwait_i11e_wake (void*),misc\interrupt.c,"static void vlc_mwait_i11e_wake(void *opaque)
{
    vlc_cond_signal(opaque);
}",213.0,216.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1635,112489,vlc_mwait_i11e_cleanup,1,vlc_mwait_i11e_cleanup,void vlc_mwait_i11e_cleanup (void*),misc\interrupt.c,"static void vlc_mwait_i11e_cleanup(void *opaque)
{
    vlc_interrupt_t *ctx = opaque;
    vlc_cond_t *cond = ctx->data;

    vlc_mutex_unlock(&ctx->lock);
    vlc_interrupt_finish(ctx);
    vlc_cond_destroy(cond);
}",218.0,226.0,1.0,1.0,9.0,5,3,7,3,0,3,1,1,0,3,,0,0,2,1,1,void
1636,112513,vlc_mwait_i11e,1,vlc_mwait_i11e,int vlc_mwait_i11e (mtime_t),misc\interrupt.c,"int vlc_mwait_i11e(mtime_t deadline)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return mwait(deadline), 0;

    vlc_cond_t wait;
    vlc_cond_init(&wait);

    vlc_interrupt_prepare(ctx, vlc_mwait_i11e_wake, &wait);

    vlc_mutex_lock(&ctx->lock);
    vlc_cleanup_push(vlc_mwait_i11e_cleanup, ctx);
    while (!ctx->interrupted
        && vlc_cond_timedwait(&wait, &ctx->lock, deadline) == 0);
    vlc_cleanup_pop();
    vlc_mutex_unlock(&ctx->lock);

    int ret = vlc_interrupt_finish(ctx);
    vlc_cond_destroy(&wait);
    return ret;
}",228.0,249.0,1.0,1.0,22.0,18,7,19,6,0,8,3,3,1,8,,0,2,2,1,1,int
1637,112612,vlc_interrupt_forward_start,1,vlc_interrupt_forward_start,"void vlc_interrupt_forward_start (vlc_interrupt_t*,void[2]*)",misc\interrupt.c,"void vlc_interrupt_forward_start(vlc_interrupt_t *to, void *data[2])
{
    data[0] = data[1] = NULL;

    vlc_interrupt_t *from = vlc_interrupt_var;
    if (from == NULL)
        return;

    assert(from != to);
    data[0] = to;
    data[1] = from;
    vlc_interrupt_prepare(from, vlc_interrupt_forward_wake, data);
}",261.0,273.0,1.0,1.0,13.0,11,4,15,5,0,1,2,2,0,1,,0,0,4,2,2,void
1638,112655,vlc_interrupt_forward_stop,1,vlc_interrupt_forward_stop,int vlc_interrupt_forward_stop (void[2]*),misc\interrupt.c,"int vlc_interrupt_forward_stop(void *const data[2])
{
    vlc_interrupt_t *from = data[1];
    if (from == NULL)
        return 0;

    assert(from->callback == vlc_interrupt_forward_wake);
    assert(from->data == data);
    return vlc_interrupt_finish(from);
}",275.0,284.0,1.0,1.0,10.0,7,4,8,3,0,1,2,2,0,1,,0,0,2,1,1,int
1639,112688,vlc_poll_i11e_wake,1,vlc_poll_i11e_wake,void vlc_poll_i11e_wake (void*),misc\interrupt.c,"static void vlc_poll_i11e_wake(void *opaque)
{
    uint64_t value = 1;
    int *fd = opaque;
    int canc;

    canc = vlc_savecancel();
    write(fd[1], &value, sizeof (value));
    vlc_restorecancel(canc);
}",287.0,296.0,1.0,1.0,10.0,6,4,8,4,0,2,1,1,0,2,,0,1,2,1,1,void
1640,112715,vlc_poll_i11e_cleanup,1,vlc_poll_i11e_cleanup,void vlc_poll_i11e_cleanup (void*),misc\interrupt.c,"static void vlc_poll_i11e_cleanup(void *opaque)
{
    vlc_interrupt_t *ctx = opaque;
    int *fd = ctx->data;

    vlc_interrupt_finish(ctx);
    if (fd[1] != fd[0])
        vlc_close(fd[1]);
    vlc_close(fd[0]);
}",298.0,307.0,1.0,1.0,10.0,8,4,9,3,0,3,2,2,0,3,,0,0,2,1,1,void
1641,112749,vlc_poll_i11e_inner,1,vlc_poll_i11e_inner,"int vlc_poll_i11e_inner (pollfd*,unsigned,int,vlc_interrupt_t*,pollfd*)",misc\interrupt.c,"static int vlc_poll_i11e_inner(struct pollfd *restrict fds, unsigned nfds,
                               int timeout, vlc_interrupt_t *ctx,
                               struct pollfd *restrict ufd)
{
    int fd[2];
    int ret = -1;
    int canc;

    /* TODO: cache this */
# if defined (HAVE_EVENTFD) && defined (EFD_CLOEXEC)
    canc = vlc_savecancel();
    fd[0] = eventfd(0, EFD_CLOEXEC);
    vlc_restorecancel(canc);
    if (fd[0] != -1)
        fd[1] = fd[0];
    else
# endif
    if (vlc_pipe(fd))
    {
        vlc_testcancel();
        errno = ENOMEM;
        return -1;
    }

    for (unsigned i = 0; i < nfds; i++)
    {
        ufd[i].fd = fds[i].fd;
        ufd[i].events = fds[i].events;
    }
    ufd[nfds].fd = fd[0];
    ufd[nfds].events = POLLIN;

    vlc_interrupt_prepare(ctx, vlc_poll_i11e_wake, fd);

    vlc_cleanup_push(vlc_poll_i11e_cleanup, ctx);
    ret = poll(ufd, nfds + 1, timeout);

    for (unsigned i = 0; i < nfds; i++)
        fds[i].revents = ufd[i].revent...",309.0,370.0,1.0,1.0,62.0,44,12,49,14,1,8,7,7,2,8,,0,3,10,5,5,int
1642,112921,vlc_poll_i11e,1,vlc_poll_i11e,"int vlc_poll_i11e (pollfd*,unsigned,int)",misc\interrupt.c,"int vlc_poll_i11e(struct pollfd *fds, unsigned nfds, int timeout)
{
    vlc_interrupt_t *ctx = vlc_interrupt_var;
    if (ctx == NULL)
        return poll(fds, nfds, timeout);

    int ret;

    if (likely(nfds < 255))
    {   /* Fast path with stack allocation */
        struct pollfd ufd[nfds + 1];

        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
    }
    else
    {   /* Slow path but poll() is slow with large nfds anyway. */
        struct pollfd *ufd = vlc_alloc(nfds + 1, sizeof (*ufd));
        if (unlikely(ufd == NULL))
            return -1; /* ENOMEM */

        vlc_cleanup_push(free, ufd);
        ret = vlc_poll_i11e_inner(fds, nfds, timeout, ctx, ufd);
        vlc_cleanup_pop();
        free(ufd);
    }
    return ret;
}",372.0,398.0,1.0,1.0,27.0,4,3,15,8,10,1,3,3,0,1,,0,1,6,3,3,int
1643,112995,vlc_readv_i11e,1,vlc_readv_i11e,"ssize_t vlc_readv_i11e (int,iovec*,int)",misc\interrupt.c,"ssize_t vlc_readv_i11e(int fd, struct iovec *iov, int count)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return readv(fd, iov, count);
}",417.0,427.0,1.0,1.0,11.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
1644,113031,vlc_writev_i11e,1,vlc_writev_i11e,"ssize_t vlc_writev_i11e (int,iovec*,int)",misc\interrupt.c,"ssize_t vlc_writev_i11e(int fd, const struct iovec *iov, int count)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    return writev(fd, iov, count);
}",436.0,446.0,1.0,1.0,11.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
1645,113067,vlc_read_i11e,1,vlc_read_i11e,"ssize_t vlc_read_i11e (int,void*,size_t)",misc\interrupt.c,"ssize_t vlc_read_i11e(int fd, void *buf, size_t count)
{
    struct iovec iov = { .iov_base = buf, .iov_len = count };
    return vlc_readv_i11e(fd, &iov, 1);
}",452.0,456.0,1.0,1.0,5.0,5,3,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
1646,113092,vlc_write_i11e,1,vlc_write_i11e,"ssize_t vlc_write_i11e (int,void*,size_t)",misc\interrupt.c,"ssize_t vlc_write_i11e(int fd, const void *buf, size_t count)
{
    struct iovec iov = { .iov_base = (void*)buf, .iov_len = count };
    return vlc_writev_i11e(fd, &iov, 1);
}",465.0,469.0,1.0,1.0,5.0,6,4,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
1647,113119,vlc_recvmsg_i11e,1,vlc_recvmsg_i11e,"ssize_t vlc_recvmsg_i11e (int,msghdr*,int)",misc\interrupt.c,"ssize_t vlc_recvmsg_i11e(int fd, struct msghdr *msg, int flags)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_OOB and MSG_PEEK should work fine here.
     * MSG_WAITALL is not supported at this point. */
    return recvmsg(fd, msg, flags);
}",471.0,483.0,1.0,1.0,13.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
1648,113155,vlc_recvfrom_i11e,1,vlc_recvfrom_i11e,"ssize_t vlc_recvfrom_i11e (int,void*,size_t,int,sockaddr*,socklen_t*)",misc\interrupt.c,"ssize_t vlc_recvfrom_i11e(int fd, void *buf, size_t len, int flags,
                        struct sockaddr *addr, socklen_t *addrlen)
{
    struct iovec iov = { .iov_base = buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = addr,
        .msg_namelen = (addrlen != NULL) ? *addrlen : 0,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    ssize_t ret = vlc_recvmsg_i11e(fd, &msg, flags);
    if (ret >= 0 && addrlen != NULL)
        *addrlen = msg.msg_namelen;
    return ret;
}",485.0,500.0,1.0,1.0,16.0,22,9,25,16,0,1,2,2,0,1,,0,1,12,6,6,ssize_t
1649,113229,vlc_sendmsg_i11e,1,vlc_sendmsg_i11e,"ssize_t vlc_sendmsg_i11e (int,msghdr*,int)",misc\interrupt.c,"ssize_t vlc_sendmsg_i11e(int fd, const struct msghdr *msg, int flags)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;
    /* NOTE: MSG_EOR, MSG_OOB and MSG_NOSIGNAL should all work fine here. */
    return sendmsg(fd, msg, flags);
}",502.0,513.0,1.0,1.0,12.0,8,5,8,5,1,1,2,2,1,1,,0,1,6,3,3,ssize_t
1650,113265,vlc_sendto_i11e,1,vlc_sendto_i11e,"ssize_t vlc_sendto_i11e (int,void*,size_t,int,sockaddr*,socklen_t)",misc\interrupt.c,"ssize_t vlc_sendto_i11e(int fd, const void *buf, size_t len, int flags,
                      const struct sockaddr *addr, socklen_t addrlen)
{
    struct iovec iov = { .iov_base = (void *)buf, .iov_len = len };
    struct msghdr msg = {
        .msg_name = (struct sockaddr *)addr,
        .msg_namelen = addrlen,
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    return vlc_sendmsg_i11e(fd, &msg, flags);
}",515.0,527.0,1.0,1.0,13.0,14,4,16,14,0,1,1,1,0,1,,0,0,12,6,6,ssize_t
1651,113318,vlc_accept_i11e,1,vlc_accept_i11e,"int vlc_accept_i11e (int,sockaddr*,socklen_t*,bool)",misc\interrupt.c,"int vlc_accept_i11e(int fd, struct sockaddr *addr, socklen_t *addrlen,
                  bool blocking)
{
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLIN;

    if (vlc_poll_i11e(&ufd, 1, -1) < 0)
        return -1;

    return vlc_accept(fd, addr, addrlen, blocking);
}",529.0,541.0,1.0,1.0,13.0,8,5,9,6,0,2,2,2,1,2,,0,1,8,4,4,int
1652,113408,keystore_create,1,keystore_create,"vlc_keystore keystore_create (vlc_object_t*,char*)",misc\keystore.c,"static vlc_keystore *
keystore_create(vlc_object_t *p_parent, const char *psz_name)
{
    vlc_keystore *p_keystore = vlc_custom_create(p_parent, sizeof (*p_keystore),
                                                 ""keystore"");
    if (unlikely(p_keystore == NULL))
        return NULL;

    p_keystore->p_module = module_need(p_keystore, ""keystore"", psz_name, true);
    if (p_keystore->p_module == NULL)
    {
        vlc_object_release(p_keystore);
        return NULL;
    }
    assert(p_keystore->pf_store);
    assert(p_keystore->pf_find);
    assert(p_keystore->pf_remove);

    return p_keystore;
}",35.0,54.0,1.0,1.0,20.0,11,5,18,5,2,3,3,3,0,3,,0,2,4,2,2,vlc_keystore
1653,113465,vlc_keystore_create,1,vlc_keystore_create,vlc_keystore vlc_keystore_create (vlc_object_t*),misc\keystore.c,"vlc_keystore *
vlc_keystore_create(vlc_object_t *p_parent)
{
    assert(p_parent);
    return keystore_create(p_parent, ""$keystore"");
}",57.0,62.0,1.0,1.0,6.0,0,0,2,1,1,1,1,1,0,1,,0,0,2,1,1,vlc_keystore
1654,113476,vlc_keystore_release,1,vlc_keystore_release,void vlc_keystore_release (vlc_keystore*),misc\keystore.c,"void
vlc_keystore_release(vlc_keystore *p_keystore)
{
    assert(p_keystore);
    module_unneed(p_keystore, p_keystore->p_module);

    vlc_object_release(p_keystore);
}",64.0,71.0,1.0,1.0,8.0,1,1,4,1,2,2,1,1,0,2,,0,0,2,1,1,void
1655,113490,vlc_keystore_store,1,vlc_keystore_store,"int vlc_keystore_store (vlc_keystore*,char[KEY_MAX]*,uint8_t*,ssize_t,char*)",misc\keystore.c,"int
vlc_keystore_store(vlc_keystore *p_keystore,
                   const char * const ppsz_values[KEY_MAX],
                   const uint8_t *p_secret, ssize_t i_secret_len,
                   const char *psz_label)
{
    assert(p_keystore && ppsz_values && p_secret && i_secret_len);

    if (!ppsz_values[KEY_PROTOCOL] || !ppsz_values[KEY_SERVER])
    {
        msg_Err(p_keystore, ""invalid store request: ""
                ""protocol and server should be valid"");
        return VLC_EGENERIC;
    }
    if (ppsz_values[KEY_PORT])
    {
        long int i_port = strtol(ppsz_values[KEY_PORT], NULL, 10);
        if (i_port == LONG_MIN || i_port == LONG_MAX)
        {
            msg_Err(p_keystore, ""invalid store request: ""
                    ""port is not valid number"");
            return VLC_EGENERIC;
        }
    }
    if (i_secret_len < 0)
        i_secret_len = strlen((const char *)p_secret) + 1;
    return p_keystore->pf_store(p_keystore, ppsz_values, p_secret, i_secret_len,
     ...",73.0,101.0,1.0,1.0,29.0,19,10,31,13,1,0,5,6,0,0,,0,0,10,5,5,int
1656,113574,vlc_keystore_find,1,vlc_keystore_find,"unsigned int vlc_keystore_find (vlc_keystore*,char[KEY_MAX]*,vlc_keystore_entry**)",misc\keystore.c,"unsigned int
vlc_keystore_find(vlc_keystore *p_keystore,
                  const char * const ppsz_values[KEY_MAX],
                  vlc_keystore_entry **pp_entries)
{
    assert(p_keystore && ppsz_values && pp_entries);
    return p_keystore->pf_find(p_keystore, ppsz_values, pp_entries);
}",103.0,110.0,1.0,1.0,8.0,3,2,7,3,1,0,1,1,0,0,,0,0,6,3,3,unsigned int
1657,113612,vlc_keystore_release_entries,1,vlc_keystore_release_entries,"void vlc_keystore_release_entries (vlc_keystore_entry*,unsigned int)",misc\keystore.c,"void
vlc_keystore_release_entries(vlc_keystore_entry *p_entries, unsigned int i_count)
{
    for (unsigned int i = 0; i < i_count; ++i)
        vlc_keystore_release_entry(&p_entries[i]);
    free(p_entries);
}",120.0,126.0,1.0,1.0,7.0,2,2,4,3,3,0,2,2,0,0,,0,0,4,2,2,void
1658,113636,libvlc_InternalKeystoreInit,1,libvlc_InternalKeystoreInit,int libvlc_InternalKeystoreInit (libvlc_int_t*),misc\keystore.c,"int
libvlc_InternalKeystoreInit(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    p_priv->p_memory_keystore = keystore_create(VLC_OBJECT(p_libvlc), ""memory"");
    return p_priv->p_memory_keystore != NULL ? VLC_SUCCESS : VLC_EGENERIC;
}",128.0,136.0,1.0,1.0,9.0,7,4,10,5,1,4,1,1,0,2,,0,4,2,1,1,int
1659,113667,libvlc_InternalKeystoreClean,1,libvlc_InternalKeystoreClean,void libvlc_InternalKeystoreClean (libvlc_int_t*),misc\keystore.c,"void
libvlc_InternalKeystoreClean(libvlc_int_t *p_libvlc)
{
    assert(p_libvlc != NULL);
    libvlc_priv_t *p_priv = libvlc_priv(p_libvlc);

    if (p_priv->p_memory_keystore != NULL)
    {
        vlc_keystore_release(p_priv->p_memory_keystore);
        p_priv->p_memory_keystore = NULL;
    }
}",138.0,149.0,1.0,1.0,12.0,7,3,9,3,1,5,2,2,1,2,,0,4,2,1,1,void
1660,113697,get_memory_keystore,1,get_memory_keystore,vlc_keystore get_memory_keystore (vlc_object_t*),misc\keystore.c,"static vlc_keystore *
get_memory_keystore(vlc_object_t *p_obj)
{
    return libvlc_priv(p_obj->obj.libvlc)->p_memory_keystore;
}",151.0,155.0,1.0,1.0,5.0,3,2,1,1,1,1,1,1,0,1,,0,0,2,1,1,vlc_keystore
1661,113711,find_closest_path,1,find_closest_path,"vlc_keystore_entry find_closest_path (vlc_keystore_entry*,unsigned,char*)",misc\keystore.c,"static vlc_keystore_entry *
find_closest_path(vlc_keystore_entry *p_entries, unsigned i_count,
                  const char *psz_path)
{
    vlc_keystore_entry *p_match_entry = NULL;
    size_t i_last_pathlen = 0;
    char *psz_decoded_path = vlc_uri_decode_duplicate(psz_path);
    if (psz_decoded_path == NULL)
        return NULL;

    /* Try to find the entry that has the closest path to psz_url */
    for (unsigned int i = 0; i < i_count; ++i)
    {
        vlc_keystore_entry *p_entry = &p_entries[i];
        const char *psz_entry_path = p_entry->ppsz_values[KEY_PATH];
        if (psz_entry_path == NULL)
        {
            if (p_match_entry == NULL)
                p_match_entry = p_entry;
            continue;
        }
        size_t i_entry_pathlen = strlen(psz_entry_path);

        if (strncasecmp(psz_decoded_path, psz_entry_path, i_entry_pathlen) == 0
         && i_entry_pathlen > i_last_pathlen)
        {
            i_last_pathlen = i_entry_pathlen;
            p_match_...",157.0,189.0,1.0,1.0,33.0,21,8,36,12,1,1,7,10,0,1,,0,1,6,3,3,vlc_keystore_entry
1662,113806,is_credential_valid,1,is_credential_valid,bool is_credential_valid (vlc_credential*),misc\keystore.c,"static bool
is_credential_valid(vlc_credential *p_credential)
{
    if (p_credential->psz_username && p_credential->psz_password)
        return true;
    p_credential->psz_password = NULL;
    return false;
}",191.0,198.0,1.0,1.0,8.0,5,3,6,4,3,0,2,2,0,0,,0,0,2,1,1,bool
1663,113829,is_url_valid,1,is_url_valid,bool is_url_valid (vlc_url_t*),misc\keystore.c,"static bool
is_url_valid(const vlc_url_t *p_url)
{
    return p_url && p_url->psz_protocol && p_url->psz_protocol[0]
        && p_url->psz_host && p_url->psz_host[0];
}",200.0,205.0,1.0,1.0,6.0,10,3,5,1,1,0,1,1,0,0,,0,0,2,1,1,bool
1664,113881,protocol_set_port,1,protocol_set_port,"bool protocol_set_port (vlc_url_t*,char*)",misc\keystore.c,"static bool
protocol_set_port(const vlc_url_t *p_url, char *psz_port)
{
    int i_port = -1;

    if (p_url->i_port != 0 && p_url->i_port <= UINT16_MAX)
        i_port = p_url->i_port;
    else
    {
        for (unsigned int i = 0; i < sizeof(protocol_default_ports)
                                   / sizeof(*protocol_default_ports); ++i)
        {
            if (strcasecmp(p_url->psz_protocol,
                           protocol_default_ports[i].psz_protocol) == 0)
            {
                i_port = protocol_default_ports[i].i_port;
                break;
            }
        }
    }
    if (i_port != -1)
    {
        sprintf(psz_port, ""%u"", (uint16_t) i_port);
        return true;
    }
    return false;
}",222.0,248.0,1.0,1.0,27.0,12,7,11,6,2,0,3,3,0,0,,0,0,4,2,2,bool
1665,113966,protocol_is_smb,1,protocol_is_smb,bool protocol_is_smb (vlc_url_t*),misc\keystore.c,"static bool
protocol_is_smb(const vlc_url_t *p_url)
{
    return strcasecmp(p_url->psz_protocol, ""smb"") == 0;
}",250.0,254.0,1.0,1.0,5.0,2,2,1,1,4,0,1,1,0,0,,0,0,2,1,1,bool
1666,113979,protocol_store_path,1,protocol_store_path,bool protocol_store_path (vlc_url_t*),misc\keystore.c,"static bool
protocol_store_path(const vlc_url_t *p_url)
{
    return p_url->psz_path
      && (strncasecmp(p_url->psz_protocol, ""http"", 4) == 0
      || strcasecmp(p_url->psz_protocol, ""rtsp"") == 0
      || protocol_is_smb(p_url));
}",256.0,263.0,1.0,1.0,8.0,8,4,4,1,2,1,1,1,0,1,,0,0,2,1,1,bool
1667,114008,smb_split_domain,1,smb_split_domain,void smb_split_domain (vlc_credential*),misc\keystore.c,"static void
smb_split_domain(vlc_credential *p_credential)
{
    char *psz_delim = strchr(p_credential->psz_username, ';');
    if (psz_delim)
    {
        size_t i_len = psz_delim - p_credential->psz_username;
        if (i_len > 0)
        {
            free(p_credential->psz_split_domain);
            p_credential->psz_split_domain =
                strndup(p_credential->psz_username, i_len);
            p_credential->psz_realm = p_credential->psz_split_domain;
        }
        p_credential->psz_username = psz_delim + 1;
    }
}",266.0,282.0,1.0,1.0,17.0,16,5,15,3,2,0,3,4,0,0,,0,0,2,1,1,void
1668,114064,credential_find_keystore,1,credential_find_keystore,"void credential_find_keystore (vlc_credential*,vlc_keystore*)",misc\keystore.c,"static void
credential_find_keystore(vlc_credential *p_credential, vlc_keystore *p_keystore)
{
    const vlc_url_t *p_url = p_credential->p_url;

    const char *ppsz_values[KEY_MAX] = { 0 };
    ppsz_values[KEY_PROTOCOL] = p_url->psz_protocol;
    ppsz_values[KEY_USER] = p_credential->psz_username;
    ppsz_values[KEY_SERVER] = p_url->psz_host;
    /* don't try to match with the path */
    ppsz_values[KEY_REALM] = p_credential->psz_realm;
    ppsz_values[KEY_AUTHTYPE] = p_credential->psz_authtype;
    char psz_port[21];
    if (protocol_set_port(p_url, psz_port))
        ppsz_values[KEY_PORT] = psz_port;

    vlc_keystore_entry *p_entries;
    unsigned int i_entries_count;
    i_entries_count = vlc_keystore_find(p_keystore, ppsz_values, &p_entries);

    /* Remove last entries after vlc_keystore_find call since
     * p_credential->psz_username (default username) can be a pointer to an
     * entry */
    if (p_credential->i_entries_count > 0)
    {
        vlc_keystore_release_en...",284.0,342.0,1.0,1.0,59.0,50,10,48,15,2,6,6,8,2,6,,0,4,4,2,2,void
1669,114294,vlc_credential_clean,1,vlc_credential_clean,void vlc_credential_clean (vlc_credential*),misc\keystore.c,"void
vlc_credential_clean(vlc_credential *p_credential)
{
    if (p_credential->i_entries_count > 0)
        vlc_keystore_release_entries(p_credential->p_entries,
                                     p_credential->i_entries_count);
    if (p_credential->p_keystore)
        vlc_keystore_release(p_credential->p_keystore);

    free(p_credential->psz_split_domain);
    free(p_credential->psz_var_username);
    free(p_credential->psz_var_password);
    free(p_credential->psz_dialog_username);
    free(p_credential->psz_dialog_password);
}",354.0,368.0,1.0,1.0,15.0,11,2,10,1,0,2,3,3,0,2,,0,0,2,1,1,void
1670,114342,vlc_credential_get,1,vlc_credential_get,"bool vlc_credential_get (vlc_credential*,vlc_object_t*,char*,char*,char*,char*...)",misc\keystore.c,"bool
vlc_credential_get(vlc_credential *p_credential, vlc_object_t *p_parent,
                   const char *psz_option_username,
                   const char *psz_option_password,
                   const char *psz_dialog_title,
                   const char *psz_dialog_fmt, ...)
{
    assert(p_credential && p_parent);
    const vlc_url_t *p_url = p_credential->p_url;

    if (!is_url_valid(p_url))
    {
        msg_Err(p_parent, ""vlc_credential_get: invalid url"");
        return false;
    }

    p_credential->b_from_keystore = false;
    /* Don't set username to NULL, we may want to use the last one set */
    p_credential->psz_password = NULL;

    while (!is_credential_valid(p_credential))
    {
        /* First, fetch credential from URL (if any).
         * Secondly, fetch credential from VLC Options (if any).
         * Thirdly, fetch credential from keystore (if any) using user and realm
         * previously set by the caller, the URL or by VLC Options.
         * Finally...",371.0,498.0,1.0,1.0,128.0,89,10,109,20,0,12,22,44,4,12,,0,7,12,6,6,bool
1671,114675,vlc_credential_store,1,vlc_credential_store,"bool vlc_credential_store (vlc_credential*,vlc_object_t*)",misc\keystore.c,"bool
vlc_credential_store(vlc_credential *p_credential, vlc_object_t *p_parent)
{
    if (!is_credential_valid(p_credential))
        return false;
    /* Don't need to store again */
    if (p_credential->b_from_keystore)
        return p_credential->b_from_keystore;

    vlc_keystore *p_keystore;
    if (p_credential->b_store)
    {
        /* Store in permanent keystore */
        assert(p_credential->p_keystore != NULL);
        p_keystore = p_credential->p_keystore;
    }
    else
    {
        /* Store in memory keystore */
        p_keystore = get_memory_keystore(p_parent);
    }
    if (p_keystore == NULL)
        return false;

    const vlc_url_t *p_url = p_credential->p_url;

    char *psz_path = NULL;
    if (protocol_store_path(p_url)
     && (psz_path =  vlc_uri_decode_duplicate(p_url->psz_path)) != NULL)
    {
        char *p_slash;
        if (protocol_is_smb(p_url))
        {
            /* Remove all characters after the first slash (store the share but
           ...",501.0,577.0,1.0,1.0,77.0,58,14,71,20,0,6,10,12,5,6,,0,6,4,2,2,bool
1672,114916,md5_init,1,md5_init,void md5_init (void*),misc\md5.c,"static void
md5_init( void *context )
{
  MD5_CONTEXT *ctx = context;

  ctx->A = 0x67452301;
  ctx->B = 0xefcdab89;
  ctx->C = 0x98badcfe;
  ctx->D = 0x10325476;

  ctx->nblocks = 0;
  ctx->count = 0;
}",54.0,66.0,1.0,1.0,13.0,13,2,8,2,1,0,1,1,0,0,,0,0,2,1,1,void
1673,114955,transform,1,transform,"void transform (MD5_CONTEXT*,unsigned char*)",misc\md5.c,"static void
transform ( MD5_CONTEXT *ctx, const unsigned char *data )
{
  u32 correct_words[16];
  register u32 A = ctx->A;
  register u32 B = ctx->B;
  register u32 C = ctx->C;
  register u32 D = ctx->D;
  u32 *cwp = correct_words;

#ifdef WORDS_BIGENDIAN
  {
    int i;
    byte *p2, *p1;
    for(i=0, p1=data, p2=(byte*)correct_words; i < 16; i++, p2 += 4 )
      {
        p2[3] = *p1++;
	p2[2] = *p1++;
	p2[1] = *p1++;
	p2[0] = *p1++;
      }
  }
#else
  memcpy( correct_words, data, 64 );
#endif


#define OP(a, b, c, d, s, T) \
  do			         	   \
    {					   \
      a += FF (b, c, d) + (*cwp++) + T;    \
      a = rol(a, s);			   \
      a += b;				   \
    }					   \
  while (0)

  /* Before we start, one word about the strange constants.
     They are defined in RFC 1321 as

     T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64
  */

  /* Round 1.  */
  OP (A, B, C, D,  7, 0xd76aa478);
  OP (D, A, B, C, 12, 0xe8c7b756);
  OP (C, D, A, B, 17, 0x242070db);
  OP (B, C, D, A...",82.0,211.0,1.0,2.0,130.0,849,14,948,8,3,0,1,1,0,0,,0,0,4,2,2,void
1674,117574,md5_write,1,md5_write,"void md5_write (void*,void*,size_t)",misc\md5.c,"static void
md5_write( void *context, const void *inbuf_arg , size_t inlen)
{
  const unsigned char *inbuf = inbuf_arg;
  MD5_CONTEXT *hd = context;

  if( hd->count == 64 )  /* flush the buffer */
    {
      transform( hd, hd->buf );
      hd->count = 0;
      hd->nblocks++;
    }
  if( !inbuf )
    return;

  if( hd->count )
    {
      for( ; inlen && hd->count < 64; inlen-- )
        hd->buf[hd->count++] = *inbuf++;
      md5_write( hd, NULL, 0 );
      if( !inlen )
        return;
    }

  while( inlen >= 64 )
    {
      transform( hd, inbuf );
      hd->count = 0;
      hd->nblocks++;
      inlen -= 64;
      inbuf += 64;
    }
  for( ; inlen && hd->count < 64; inlen-- )
    hd->buf[hd->count++] = *inbuf++;

}",219.0,254.0,1.0,1.0,36.0,25,10,25,6,2,2,8,10,0,2,,0,0,6,3,3,void
1675,117698,md5_final,1,md5_final,void md5_final (void*),misc\md5.c,"static void
md5_final( void *context)
{
  MD5_CONTEXT *hd = context;
  u32 t, msb, lsb;
  byte *p;

  md5_write(hd, NULL, 0); /* flush */;

  t = hd->nblocks;
  /* multiply by 64 to make a byte count */
  lsb = t << 6;
  msb = t >> 26;
  /* add the count */
  t = lsb;
  if( (lsb += hd->count) < t )
    msb++;
  /* multiply by 8 to make a bit count */
  t = lsb;
  lsb <<= 3;
  msb <<= 3;
  msb |= t >> 29;

  if( hd->count < 56 )  /* enough room */
    {
      hd->buf[hd->count++] = 0x80; /* pad */
      while( hd->count < 56 )
        hd->buf[hd->count++] = 0;  /* pad */
    }
  else  /* need one extra block */
    {
      hd->buf[hd->count++] = 0x80; /* pad character */
      while( hd->count < 64 )
        hd->buf[hd->count++] = 0;
      md5_write(hd, NULL, 0);  /* flush */;
      memset(hd->buf, 0, 56 ); /* fill next block with zeroes */
    }
  /* append the 64 bit count */
  hd->buf[56] = lsb	   ;
  hd->buf[57] = lsb >>  8;
  hd->buf[58] = lsb >> 16;
  hd->buf[59] = lsb >> 24;
 ...",264.0,325.0,1.0,2.0,62.0,80,11,58,7,1,2,4,5,0,2,,0,0,2,1,1,void
1676,117975,InitMD5,1,InitMD5,void InitMD5 (md5_s*),misc\md5.c,"void InitMD5( struct md5_s *h )
{
    md5_init( h );
}",336.0,339.0,1.0,1.0,4.0,0,0,1,1,4,1,1,1,0,1,,0,0,2,1,1,void
1677,117982,AddMD5,1,AddMD5,"void AddMD5 (md5_s*,void*,size_t)",misc\md5.c,"void AddMD5( struct md5_s *restrict h, const void *data, size_t len )
{
    md5_write( h, data, len );
}",341.0,344.0,1.0,1.0,4.0,0,0,3,3,18,1,1,1,0,1,,0,0,6,3,3,void
1678,117993,EndMD5,1,EndMD5,void EndMD5 (md5_s*),misc\md5.c,"void EndMD5( struct md5_s *h )
{
    md5_final( h );
}",346.0,349.0,1.0,1.0,4.0,0,0,1,1,4,1,1,1,0,1,,0,0,2,1,1,void
1679,118032,vlc_vaLogCallback,1,vlc_vaLogCallback,"void vlc_vaLogCallback (libvlc_int_t*,int,vlc_log_t*,char*,va_list)",misc\messages.c,"static void vlc_vaLogCallback(libvlc_int_t *vlc, int type,
                              const vlc_log_t *item, const char *format,
                              va_list ap)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;
    int canc;

    assert(logger != NULL);
    canc = vlc_savecancel();
    vlc_rwlock_rdlock(&logger->lock);
    logger->log(logger->sys, type, item, format, ap);
    vlc_rwlock_unlock(&logger->lock);
    vlc_restorecancel(canc);
}",55.0,68.0,1.0,1.0,14.0,10,4,14,8,2,9,1,1,0,5,,0,6,10,5,5,void
1680,118079,vlc_LogCallback,1,vlc_LogCallback,"void vlc_LogCallback (libvlc_int_t*,int,vlc_log_t*,char*...)",misc\messages.c,"static void vlc_LogCallback(libvlc_int_t *vlc, int type, const vlc_log_t *item,
                            const char *format, ...)
{
    va_list ap;

    va_start(ap, format);
    vlc_vaLogCallback(vlc, type, item, format, ap);
    va_end(ap);
}",70.0,78.0,1.0,1.0,9.0,0,0,8,5,1,1,1,1,0,1,,0,0,8,4,4,void
1681,118099,vlc_vaLog,1,vlc_vaLog,"void vlc_vaLog (vlc_object_t*,int,char*,char*,unsigned,char*,char*,va_list)",misc\messages.c,"void vlc_vaLog (vlc_object_t *obj, int type, const char *module,
                const char *file, unsigned line, const char *func,
                const char *format, va_list args)
{
    if (obj != NULL && obj->obj.flags & OBJECT_FLAGS_QUIET)
        return;

    /* Get basename from the module filename */
    char *p = strrchr(module, '/');
    if (p != NULL)
        module = p + 1;
    p = strchr(module, '.');

    size_t modlen = (p != NULL) ? (p - module) : 0;
    char modulebuf[modlen + 1];
    if (p != NULL)
    {
        memcpy(modulebuf, module, modlen);
        modulebuf[modlen] = '\0';
        module = modulebuf;
    }

    /* Fill message information fields */
    vlc_log_t msg;

    msg.i_object_id = (uintptr_t)obj;
    msg.psz_object_type = (obj != NULL) ? obj->obj.object_type : ""generic"";
    msg.psz_module = module;
    msg.psz_header = NULL;
    msg.file = file;
    msg.line = line;
    msg.func = func;
    msg.tid = vlc_thread_id();

    for (vlc_object_t *o = obj;...",89.0,141.0,1.0,1.0,53.0,45,12,54,15,1,2,6,6,0,2,,0,1,16,8,8,void
1682,118278,vlc_Log,1,vlc_Log,"void vlc_Log (vlc_object_t*,int,char*,char*,unsigned,char*,char*...)",misc\messages.c,"void vlc_Log(vlc_object_t *obj, int type, const char *module,
             const char *file, unsigned line, const char *func,
             const char *format, ... )
{
    va_list ap;

    va_start(ap, format);
    vlc_vaLog(obj, type, module, file, line, func, format, ap);
    va_end(ap);
}",154.0,163.0,1.0,1.0,10.0,0,0,11,8,0,1,1,1,0,1,,0,0,14,7,7,void
1683,118316,vlc_vaLogEarly,1,vlc_vaLogEarly,"void vlc_vaLogEarly (void*,int,vlc_log_t*,char*,va_list)",misc\messages.c,"static void vlc_vaLogEarly(void *d, int type, const vlc_log_t *item,
                           const char *format, va_list ap)
{
    vlc_logger_early_t *sys = d;

    vlc_log_early_t *log = malloc(sizeof (*log));
    if (unlikely(log == NULL))
        return;

    log->next = NULL;
    log->type = type;
    log->meta.i_object_id = item->i_object_id;
    /* NOTE: Object types MUST be static constant - no need to copy them. */
    log->meta.psz_object_type = item->psz_object_type;
    log->meta.psz_module = item->psz_module; /* Ditto. */
    log->meta.psz_header = item->psz_header ? strdup(item->psz_header) : NULL;
    log->meta.file = item->file;
    log->meta.line = item->line;
    log->meta.func = item->func;

    if (vasprintf(&log->msg, format, ap) == -1)
        log->msg = NULL;

    vlc_mutex_lock(&sys->lock);
    assert(sys->tailp != NULL);
    assert(*(sys->tailp) == NULL);
    *(sys->tailp) = log;
    sys->tailp = &log->next;
    vlc_mutex_unlock(&sys->lock);
}",223.0,252.0,1.0,1.0,30.0,61,10,41,8,0,20,3,3,1,2,,0,18,10,5,5,void
1684,118476,vlc_LogEarlyOpen,1,vlc_LogEarlyOpen,int vlc_LogEarlyOpen (vlc_logger_t*),misc\messages.c,"static int vlc_LogEarlyOpen(vlc_logger_t *logger)
{
    vlc_logger_early_t *sys = malloc(sizeof (*sys));

    if (unlikely(sys == NULL))
        return -1;

    vlc_mutex_init(&sys->lock);
    sys->head = NULL;
    sys->tailp = &sys->head;

    logger->log = vlc_vaLogEarly;
    logger->sys = sys;
    return 0;
}",254.0,268.0,1.0,1.0,15.0,17,7,12,3,0,7,2,2,0,1,,0,6,2,1,1,int
1685,118527,vlc_LogEarlyClose,1,vlc_LogEarlyClose,"void vlc_LogEarlyClose (vlc_logger_t*,void*)",misc\messages.c,"static void vlc_LogEarlyClose(vlc_logger_t *logger, void *d)
{
    libvlc_int_t *vlc = logger->obj.libvlc;
    vlc_logger_early_t *sys = d;

    /* Drain early log messages */
    for (vlc_log_early_t *log = sys->head, *next; log != NULL; log = next)
    {
        vlc_LogCallback(vlc, log->type, &log->meta, ""%s"",
                        (log->msg != NULL) ? log->msg : ""message lost"");
        free(log->msg);
        next = log->next;
        free(log);
    }

    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",270.0,287.0,1.0,1.0,18.0,19,6,20,7,0,4,2,2,0,2,,0,2,4,2,2,void
1686,118838,vlc_LogSet,1,vlc_LogSet,"void vlc_LogSet (libvlc_int_t*,vlc_log_cb,void*)",misc\messages.c,"void vlc_LogSet(libvlc_int_t *vlc, vlc_log_cb cb, void *opaque)
{
    vlc_logger_t *logger = libvlc_priv(vlc)->logger;

    if (unlikely(logger == NULL))
        return;

    module_t *module;
    void *sys;

    if (cb == NULL)
        cb = vlc_vaLogDiscard;

    vlc_rwlock_wrlock(&logger->lock);
    sys = logger->sys;
    module = logger->module;

    logger->log = cb;
    logger->sys = opaque;
    logger->module = NULL;
    vlc_rwlock_unlock(&logger->lock);

    if (module != NULL)
        vlc_module_unload(vlc, module, vlc_logger_unload, sys);

    /* Announce who we are */
    msg_Dbg (vlc, ""VLC media player - %s"", VERSION_MESSAGE);
    msg_Dbg (vlc, ""%s"", COPYRIGHT_MESSAGE);
    msg_Dbg (vlc, ""revision %s"", psz_vlc_changeset);
    msg_Dbg (vlc, ""configured with %s"", CONFIGURE_LINE);
}",390.0,420.0,1.0,1.0,31.0,20,5,32,11,0,11,4,4,0,4,,0,8,6,3,3,void
1687,119140,vlc_mime_Ext2Mime,1,vlc_mime_Ext2Mime,const char* vlc_mime_Ext2Mime (char*),misc\mime.c,"const char *vlc_mime_Ext2Mime( const char *psz_url )
{

    char *psz_ext;

    psz_ext = strrchr( psz_url, '.' );
    if( psz_ext )
    {
        int i;

        for( i = 0; ext_mime[i].psz_ext[0] ; i++ )
        {
            if( !strcasecmp( ext_mime[i].psz_ext, psz_ext ) )
            {
                return ext_mime[i].psz_mime;
            }
        }
    }
    return ""application/octet-stream"";
}",89.0,108.0,1.0,1.0,20.0,10,4,11,4,2,3,4,7,2,0,,0,3,2,1,1,const char*
1688,119201,secstotimestr,1,secstotimestr,"char* secstotimestr (char*,int32_t)",misc\mtime.c,"char *secstotimestr( char *psz_buffer, int32_t i_seconds )
{
    if( unlikely(i_seconds < 0) )
    {
        secstotimestr( psz_buffer + 1, -i_seconds );
        *psz_buffer = '-';
        return psz_buffer;
    }

    div_t d;

    d = div( i_seconds, 60 );
    i_seconds = d.rem;
    d = div( d.quot, 60 );

    if( d.quot )
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%u:%02u:%02u"",
                 d.quot, d.rem, i_seconds );
    else
        snprintf( psz_buffer, MSTRTIME_MAX_SIZE, ""%02u:%02u"",
                  d.rem, i_seconds );
    return psz_buffer;
}",51.0,73.0,1.0,1.0,23.0,13,6,18,4,2,0,3,3,0,0,,0,0,4,2,2,char*
1689,119587,PrintObject,1,PrintObject,"void PrintObject (vlc_object_t*,char*)",misc\objects.c,"static void PrintObject (vlc_object_t *obj, const char *prefix)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    int canc = vlc_savecancel ();
    printf ("" %so %p %s, %u refs, parent %p\n"", prefix, (void *)obj,
            obj->obj.object_type, atomic_load(&priv->refs),
            (void *)obj->obj.parent);
    vlc_restorecancel (canc);
}",58.0,67.0,1.0,35.0,10.0,12,6,10,4,2,2,1,1,0,2,,0,1,4,2,2,void
1690,119634,DumpStructure,1,DumpStructure,"void DumpStructure (vlc_object_t*,unsigned,char*)",misc\objects.c,"static void DumpStructure (vlc_object_t *obj, unsigned level, char *psz_foo)
{
    char back = psz_foo[level];

    psz_foo[level] = '\0';
    PrintObject (obj, psz_foo);
    psz_foo[level] = back;

    if (level / 2 >= MAX_DUMPSTRUCTURE_DEPTH)
    {
        msg_Warn (obj, ""structure tree is too deep"");
        return;
    }

    vlc_object_internals_t *priv = vlc_internals(obj);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = priv->first; priv != NULL; priv = priv->next)
    {
        if (level > 0)
        {
            assert(level >= 2);
            psz_foo[level - 1] = ' ';

            if (psz_foo[level - 2] == '`')
                psz_foo[level - 2] = ' ';
        }

        psz_foo[level] = priv->next ? '|' : '`';
        psz_foo[level + 1] = '-';
        psz_foo[level + 2] = '\0';

        DumpStructure (vlc_externals(priv), level + 2, psz_foo);
    }
    vlc_mutex_unlock (&vlc_internals(obj)-...",69.0,105.0,1.0,35.0,37.0,46,13,43,7,1,3,5,8,0,3,,0,0,6,3,3,void
1691,119794,TreeCommand,1,TreeCommand,"int TreeCommand (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",misc\objects.c,"static int TreeCommand (vlc_object_t *obj, char const *cmd,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    (void) cmd; (void) oldval; (void) newval; (void) data;

    if (cmd[0] == 't')
    {
        char psz_foo[2 * MAX_DUMPSTRUCTURE_DEPTH + 1];

        psz_foo[0] = '|';
        DumpStructure (obj, 0, psz_foo);
    }

    return VLC_SUCCESS;
}",114.0,128.0,1.0,1.0,15.0,8,4,9,7,0,1,2,2,0,1,,0,0,10,5,5,int
1692,119834,ObjectExists,1,ObjectExists,"vlc_object_t ObjectExists (vlc_object_t*,void*)",misc\objects.c,"static vlc_object_t *ObjectExists (vlc_object_t *root, void *obj)
{
    if (root == obj)
        return vlc_object_hold (root);

    vlc_object_internals_t *priv = vlc_internals(root);
    vlc_object_t *ret = NULL;

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(root)->tree_lock);

    for (priv = priv->first; priv != NULL && ret == NULL; priv = priv->next)
        ret = ObjectExists (vlc_externals (priv), obj);

    vlc_mutex_unlock (&vlc_internals(root)->tree_lock);
    return ret;
}",130.0,146.0,1.0,35.0,17.0,18,8,19,5,1,3,3,3,0,3,,0,0,4,2,2,vlc_object_t
1693,119923,VarsCommand,1,VarsCommand,"int VarsCommand (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",misc\objects.c,"static int VarsCommand (vlc_object_t *obj, char const *cmd,
                        vlc_value_t oldval, vlc_value_t newval, void *data)
{
    void *p;

    (void) cmd; (void) oldval; (void) data;

    if (sscanf (newval.psz_string, ""%p"", &p) == 1)
    {
        p = ObjectExists (obj, p);
        if (p == NULL)
        {
            msg_Err (obj, ""no such object: %s"", newval.psz_string);
            return VLC_ENOOBJ;
        }
        obj = p;
    }
    else
        vlc_object_hold (obj);

    PrintObject (obj, """");
    DumpVariables (obj);
    vlc_object_release (obj);

    return VLC_SUCCESS;
}",148.0,173.0,1.0,1.0,26.0,10,5,19,9,0,4,3,4,0,4,,0,1,10,5,5,int
1694,120254,vlc_object_create,1,vlc_object_create,"void* vlc_object_create (vlc_object_t*,size_t)",misc\objects.c,"void *vlc_object_create( vlc_object_t *p_this, size_t i_size )
{
    return vlc_custom_create( p_this, i_size, ""generic"" );
}",257.0,260.0,1.0,1.0,4.0,0,0,2,2,4,1,1,1,0,1,,0,0,4,2,2,void*
1695,120347,vlc_object_get_name,1,vlc_object_get_name,char* vlc_object_get_name (vlc_object_t*),misc\objects.c,"char *vlc_object_get_name(const vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    char *name;

    vlc_mutex_lock (&name_lock);
    name = priv->psz_name ? strdup (priv->psz_name) : NULL;
    vlc_mutex_unlock (&name_lock);

    return name;
}",298.0,308.0,1.0,35.0,11.0,9,6,10,5,0,4,1,1,0,2,,0,2,2,1,1,char*
1696,120384,vlc_object_destroy,1,vlc_object_destroy,void vlc_object_destroy (vlc_object_t*),misc\objects.c,"static void vlc_object_destroy( vlc_object_t *p_this )
{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    assert(p_priv->resources == NULL);

    /* Call the custom ""subclass"" destructor */
    if( p_priv->pf_destructor )
        p_priv->pf_destructor( p_this );

    if (unlikely(p_this->obj.parent == NULL))
    {
        /* TODO: should be in src/libvlc.c */
        var_DelCallback (p_this, ""vars"", VarsCommand, NULL);
        var_DelCallback (p_this, ""tree"", TreeCommand, NULL);
    }

    /* Destroy the associated variables. */
    var_DestroyAll( p_this );

    vlc_mutex_destroy (&p_priv->tree_lock);
    vlc_cond_destroy( &p_priv->var_wait );
    vlc_mutex_destroy( &p_priv->var_lock );
    free( p_this->obj.header );
    free( p_priv->psz_name );
    free( p_priv );
}",315.0,341.0,1.0,37.0,27.0,19,7,21,3,2,6,3,3,0,6,,0,0,2,1,1,void
1697,120466,FindName,1,FindName,"vlc_object_t FindName (vlc_object_t*,char*)",misc\objects.c,"static vlc_object_t *FindName (vlc_object_t *obj, const char *name)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    if (priv->psz_name != NULL && !strcmp (priv->psz_name, name))
        return vlc_object_hold (obj);

    vlc_object_t *found = NULL;
    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);

    for (priv = priv->first; priv != NULL && found == NULL; priv = priv->next)
        found = FindName (vlc_externals(priv), name);

    /* NOTE: nested locking here (due to recursive call) */
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return found;
}",343.0,360.0,1.0,35.0,18.0,22,9,21,5,1,3,3,3,0,3,,0,0,4,2,2,vlc_object_t
1698,120564,vlc_object_find_name,1,vlc_object_find_name,"vlc_object_t vlc_object_find_name (vlc_object_t*,char*)",misc\objects.c,"vlc_object_t *vlc_object_find_name( vlc_object_t *p_this, const char *psz_name )
{
    vlc_object_t *p_found;

    /* The object name is not thread-safe, provides no warranty that the
     * object is fully initialized and still active, and that its owner can
     * deal with asynchronous and external state changes. There may be multiple
     * objects with the same name, and the function may fail even if a matching
     * object exists. DO NOT USE THIS IN NEW CODE. */
#ifndef NDEBUG
    /* This was officially deprecated on August 19 2009. For the convenience of
     * wannabe code janitors, this is the list of names that remain used
     * and unfixed since then. */
    static const char bad[][11] = { ""adjust"", ""clone"", ""colorthres"",
        ""erase"", ""extract"", ""gradient"", ""logo"", ""marq"", ""motionblur"", ""puzzle"",
        ""rotate"", ""sharpen"", ""transform"", ""v4l2"", ""wall"" };
    static const char poor[][13] = { ""invert"", ""magnify"", ""motiondetect"",
        ""psychedelic"", ""ripple"", ""wave...",378.0,406.0,1.0,1.0,29.0,12,6,19,8,0,5,2,2,0,3,,0,3,4,2,2,vlc_object_t
1699,120642,vlc_object_hold,1,vlc_object_hold,void* vlc_object_hold (vlc_object_t*),misc\objects.c,"void * vlc_object_hold( vlc_object_t *p_this )
{
    vlc_object_internals_t *internals = vlc_internals( p_this );
#ifndef NDEBUG
    unsigned refs = atomic_fetch_add (&internals->refs, 1);
    assert (refs > 0); /* Avoid obvious freed object uses */
#else
    atomic_fetch_add (&internals->refs, 1);
#endif
    return p_this;
}",412.0,422.0,1.0,40.0,11.0,7,6,7,3,10,0,1,1,0,0,,0,0,2,1,1,void*
1700,120674,vlc_object_release,1,vlc_object_release,void vlc_object_release (vlc_object_t*),misc\objects.c,"void vlc_object_release (vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);
    unsigned refs = atomic_load (&priv->refs);

    /* Fast path */
    while (refs > 1)
    {
        if (atomic_compare_exchange_weak (&priv->refs, &refs, refs - 1))
            return; /* There are still other references to the object */

        assert (refs > 0);
    }

    vlc_object_t *parent = obj->obj.parent;

    if (unlikely(parent == NULL))
    {   /* Destroying the root object */
        refs = atomic_fetch_sub (&priv->refs, 1);
        assert (refs == 1); /* nobody to race against in this case */

        assert (priv->first == NULL); /* no children can be left */

        int canc = vlc_savecancel ();
        vlc_object_destroy (obj);
        vlc_restorecancel (canc);
        return;
    }

    /* Slow path */
    vlc_object_internals_t *papriv = vlc_internals (parent);

    vlc_mutex_lock (&papriv->tree_lock);
    refs = atomic_fetch_sub (&priv->refs, 1);
    assert (...",429.0,498.0,1.0,35.0,70.0,53,9,54,9,88,8,8,11,0,8,,0,2,2,1,1,void
1701,120881,vlc_list_children,1,vlc_list_children,vlc_list_t vlc_list_children (vlc_object_t*),misc\objects.c,"vlc_list_t *vlc_list_children( vlc_object_t *obj )
{
    vlc_list_t *l = malloc (sizeof (*l));
    if (unlikely(l == NULL))
        return NULL;

    l->i_count = 0;
    l->p_values = NULL;

    vlc_object_internals_t *priv;
    unsigned count = 0;

    vlc_mutex_lock (&vlc_internals(obj)->tree_lock);
    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
         count++;

    if (count > 0)
    {
        l->p_values = vlc_alloc (count, sizeof (vlc_value_t));
        if (unlikely(l->p_values == NULL))
        {
            vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
            free (l);
            return NULL;
        }
        l->i_count = count;
    }

    unsigned i = 0;

    for (priv = vlc_internals (obj)->first; priv; priv = priv->next)
        l->p_values[i++].p_address = vlc_object_hold (vlc_externals (priv));
    vlc_mutex_unlock (&vlc_internals(obj)->tree_lock);
    return l;
}",506.0,540.0,1.0,21.0,35.0,38,9,35,7,0,3,6,7,0,3,,0,0,2,1,1,vlc_list_t
1702,121120,vlc_obj_res,1,vlc_obj_res,struct vlc_res vlc_obj_res (vlc_object_t*),misc\objres.c,"static struct vlc_res **vlc_obj_res(vlc_object_t *obj)
{
    return &vlc_internals(obj)->resources;
}",42.0,45.0,1.0,12.0,4.0,4,4,2,1,1,0,1,1,0,0,,0,0,2,1,1,struct vlc_res
1703,121203,vlc_objres_pop,1,vlc_objres_pop,void* vlc_objres_pop (vlc_object_t*),misc\objres.c,"static void *vlc_objres_pop(vlc_object_t *obj)
{
    struct vlc_res **restrict pp = vlc_obj_res(obj);
    struct vlc_res *res = *pp;

    if (res == NULL)
        return NULL;
    *pp = res->prev;
    return res->payload;
}",72.0,81.0,1.0,1.0,10.0,8,4,10,4,0,3,2,2,0,1,,0,3,2,1,1,void*
1704,121331,vlc_obj_malloc,1,vlc_obj_malloc,"void* vlc_obj_malloc (vlc_object_t*,size_t)",misc\objres.c,"void *vlc_obj_malloc(vlc_object_t *obj, size_t size)
{
    void *ptr = vlc_objres_new(size, dummy_release);
    if (likely(ptr != NULL))
        vlc_objres_push(obj, ptr);
    return ptr;
}",136.0,142.0,1.0,1.0,7.0,2,2,7,4,0,2,2,2,0,2,,0,1,4,2,2,void*
1705,121354,vlc_obj_alloc_common,1,vlc_obj_alloc_common,"void* vlc_obj_alloc_common (vlc_object_t*,size_t,size_t,bool)",misc\objres.c,"static void *vlc_obj_alloc_common(vlc_object_t *obj, size_t nmemb, size_t size,
                                  bool do_memset)
{
    size_t tabsize;
    if (mul_overflow(nmemb, size, &tabsize))
    {
        errno = ENOMEM;
        return NULL;
    }

    void *ptr = vlc_objres_new(tabsize, dummy_release);
    if (likely(ptr != NULL))
    {
        if (do_memset)
            memset(ptr, 0, tabsize);
        vlc_objres_push(obj, ptr);
    }
    return ptr;
}",144.0,162.0,1.0,1.0,19.0,4,3,16,9,1,2,4,5,0,2,,0,1,8,4,4,void*
1706,121399,vlc_obj_calloc,1,vlc_obj_calloc,"void* vlc_obj_calloc (vlc_object_t*,size_t,size_t)",misc\objres.c,"void *vlc_obj_calloc(vlc_object_t *obj, size_t nmemb, size_t size)
{
    return vlc_obj_alloc_common(obj, nmemb, size, true);
}",164.0,167.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,6,3,3,void*
1707,121412,vlc_obj_free,1,vlc_obj_free,"void vlc_obj_free (vlc_object_t*,void*)",misc\objres.c,"void vlc_obj_free(vlc_object_t *obj, void *ptr)
{
    vlc_objres_remove(obj, ptr, ptrcmp);
}",169.0,172.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
1708,121623,PictureDestroyContext,1,PictureDestroyContext,void PictureDestroyContext (picture_t*),misc\picture.c,"static void PictureDestroyContext( picture_t *p_picture )
{
    picture_context_t *ctx = p_picture->context;
    if (ctx != NULL)
    {
        ctx->destroy(ctx);
        p_picture->context = NULL;
    }
}",96.0,104.0,1.0,1.0,9.0,6,3,8,3,2,0,2,2,0,0,,0,0,2,1,1,void
1709,121675,picture_Reset,1,picture_Reset,void picture_Reset (picture_t*),misc\picture.c,"void picture_Reset( picture_t *p_picture )
{
    /* */
    p_picture->date = VLC_TS_INVALID;
    p_picture->b_force = false;
    p_picture->b_progressive = false;
    p_picture->i_nb_fields = 2;
    p_picture->b_top_field_first = false;
    PictureDestroyContext( p_picture );
}",129.0,138.0,1.0,1.0,10.0,10,2,10,3,2,1,1,1,0,1,,0,0,2,1,1,void
1710,121707,LCM,1,LCM,"int LCM (int,int)",misc\picture.c,"static int LCM( int a, int b )
{
    return a * b / GCD( a, b );
}",143.0,146.0,1.0,1.0,4.0,2,2,4,2,3,0,1,1,0,0,,0,0,4,2,2,int
1711,121721,picture_Setup,1,picture_Setup,"int picture_Setup (picture_t*,video_format_t*)",misc\picture.c,"int picture_Setup( picture_t *p_picture, const video_format_t *restrict fmt )
{
    /* Store default values */
    p_picture->i_planes = 0;
    for( unsigned i = 0; i < VOUT_MAX_PLANES; i++ )
    {
        plane_t *p = &p_picture->p[i];
        p->p_pixels = NULL;
        p->i_pixel_pitch = 0;
    }

    p_picture->i_nb_fields = 2;

    video_format_Setup( &p_picture->format, fmt->i_chroma, fmt->i_width, fmt->i_height,
                        fmt->i_visible_width, fmt->i_visible_height,
                        fmt->i_sar_num, fmt->i_sar_den );

    const vlc_chroma_description_t *p_dsc =
        vlc_fourcc_GetChromaDescription( p_picture->format.i_chroma );
    if( !p_dsc )
        return VLC_EGENERIC;

    /* We want V (width/height) to respect:
        (V * p_dsc->p[i].w.i_num) % p_dsc->p[i].w.i_den == 0
        (V * p_dsc->p[i].w.i_num/p_dsc->p[i].w.i_den * p_dsc->i_pixel_size) % 16 == 0
       Which is respected if you have
       V % lcm( p_dsc->p[0..planes].w.i_den * 16) == 0
...",148.0,206.0,1.0,1.0,59.0,153,13,100,15,1,5,6,7,0,5,,0,4,4,2,2,int
1712,122113,picture_NewFromResource,1,picture_NewFromResource,"picture_t picture_NewFromResource (video_format_t*,picture_resource_t*)",misc\picture.c,"picture_t *picture_NewFromResource( const video_format_t *p_fmt, const picture_resource_t *p_resource )
{
    video_format_t fmt = *p_fmt;

    /* It is needed to be sure all information are filled */
    video_format_Setup( &fmt, p_fmt->i_chroma,
                              p_fmt->i_width, p_fmt->i_height,
                              p_fmt->i_visible_width, p_fmt->i_visible_height,
                              p_fmt->i_sar_num, p_fmt->i_sar_den );
    if( p_fmt->i_x_offset < p_fmt->i_width &&
        p_fmt->i_y_offset < p_fmt->i_height &&
        p_fmt->i_visible_width  > 0 && p_fmt->i_x_offset + p_fmt->i_visible_width  <= p_fmt->i_width &&
        p_fmt->i_visible_height > 0 && p_fmt->i_y_offset + p_fmt->i_visible_height <= p_fmt->i_height )
        video_format_CopyCrop( &fmt, p_fmt );

    /* */
    picture_priv_t *priv = malloc( sizeof (*priv) );
    if( unlikely(priv == NULL) )
        return NULL;

    picture_t *p_picture = &priv->picture;

    memset( p_picture, 0, siz...",211.0,273.0,1.0,1.0,63.0,87,14,65,7,3,7,7,9,1,3,,0,5,4,2,2,picture_t
1713,122376,picture_NewFromFormat,1,picture_NewFromFormat,picture_t picture_NewFromFormat (video_format_t*),misc\picture.c,"picture_t *picture_NewFromFormat( const video_format_t *p_fmt )
{
    return picture_NewFromResource( p_fmt, NULL );
}",275.0,278.0,1.0,1.0,4.0,0,0,2,2,10,1,1,1,0,1,,0,0,2,1,1,picture_t
1714,122385,picture_New,1,picture_New,"picture_t picture_New (vlc_fourcc_t,int,int,int,int)",misc\picture.c,"picture_t *picture_New( vlc_fourcc_t i_chroma, int i_width, int i_height, int i_sar_num, int i_sar_den )
{
    video_format_t fmt;

    video_format_Init( &fmt, 0 );
    video_format_Setup( &fmt, i_chroma, i_width, i_height,
                        i_width, i_height, i_sar_num, i_sar_den );

    return picture_NewFromFormat( &fmt );
}",280.0,289.0,1.0,1.0,10.0,3,1,10,6,0,2,1,1,0,2,,0,0,10,5,5,picture_t
1715,122413,picture_Hold,1,picture_Hold,picture_t picture_Hold (picture_t*),misc\picture.c,"picture_t *picture_Hold( picture_t *p_picture )
{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_add( &priv->gc.refs, 1 );
    assert( refs > 0 );
    return p_picture;
}",295.0,303.0,1.0,1.0,9.0,8,7,8,4,10,1,1,1,0,0,,0,1,2,1,1,picture_t
1716,122445,picture_Release,1,picture_Release,void picture_Release (picture_t*),misc\picture.c,"void picture_Release( picture_t *p_picture )
{
    assert( p_picture != NULL );

    picture_priv_t *priv = (picture_priv_t *)p_picture;
    uintptr_t refs = atomic_fetch_sub( &priv->gc.refs, 1 );
    assert( refs != 0 );
    if( refs > 1 )
        return;

    PictureDestroyContext( p_picture );
    assert( priv->gc.destroy != NULL );
    priv->gc.destroy( p_picture );
}",305.0,318.0,1.0,1.0,14.0,14,7,13,4,27,4,2,2,0,1,,0,3,2,1,1,void
1717,122596,picture_CopyProperties,1,picture_CopyProperties,"void picture_CopyProperties (picture_t*,picture_t*)",misc\picture.c,"void picture_CopyProperties( picture_t *p_dst, const picture_t *p_src )
{
    p_dst->date = p_src->date;
    p_dst->b_force = p_src->b_force;

    p_dst->b_progressive = p_src->b_progressive;
    p_dst->i_nb_fields = p_src->i_nb_fields;
    p_dst->b_top_field_first = p_src->b_top_field_first;
}",358.0,366.0,1.0,1.0,9.0,15,2,10,2,1,0,1,1,0,0,,0,0,4,2,2,void
1718,122637,picture_CopyPixels,1,picture_CopyPixels,"void picture_CopyPixels (picture_t*,picture_t*)",misc\picture.c,"void picture_CopyPixels( picture_t *p_dst, const picture_t *p_src )
{
    for( int i = 0; i < p_src->i_planes ; i++ )
        plane_CopyPixels( p_dst->p+i, p_src->p+i );

    assert( p_dst->context == NULL );

    if( p_src->context != NULL )
        p_dst->context = p_src->context->copy( p_src->context );
}",368.0,377.0,1.0,1.0,10.0,12,5,10,4,1,0,3,3,0,0,,0,0,4,2,2,void
1719,122693,picture_Copy,1,picture_Copy,"void picture_Copy (picture_t*,picture_t*)",misc\picture.c,"void picture_Copy( picture_t *p_dst, const picture_t *p_src )
{
    picture_CopyPixels( p_dst, p_src );
    picture_CopyProperties( p_dst, p_src );
}",379.0,383.0,1.0,1.0,5.0,0,0,4,2,2,2,1,1,0,2,,0,0,4,2,2,void
1720,122705,picture_DestroyClone,1,picture_DestroyClone,void picture_DestroyClone (picture_t*),misc\picture.c,"static void picture_DestroyClone(picture_t *clone)
{
    picture_t *picture = ((picture_priv_t *)clone)->gc.opaque;

    free(clone);
    picture_Release(picture);
}",385.0,391.0,1.0,1.0,7.0,4,4,4,2,0,1,1,1,0,1,,0,0,2,1,1,void
1721,122724,picture_Clone,1,picture_Clone,picture_t picture_Clone (picture_t*),misc\picture.c,"picture_t *picture_Clone(picture_t *picture)
{
    /* TODO: merge common code with picture_pool_ClonePicture(). */
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_DestroyClone,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = picture;
        picture_Hold(picture);

        if (picture->context != NULL)
            clone->context = picture->context->copy(picture->context);
    }
    return clone;
}",393.0,416.0,1.0,1.0,24.0,45,9,33,7,1,2,4,5,0,2,,0,1,2,1,1,picture_t
1722,122851,picture_Export,1,picture_Export,"int picture_Export (vlc_object_t*,block_t**,video_format_t*,picture_t*,vlc_fourcc_t,int,int)",misc\picture.c,"int picture_Export( vlc_object_t *p_obj,
                    block_t **pp_image,
                    video_format_t *p_fmt,
                    picture_t *p_picture,
                    vlc_fourcc_t i_format,
                    int i_override_width, int i_override_height )
{
    /* */
    video_format_t fmt_in = p_picture->format;
    if( fmt_in.i_sar_num <= 0 || fmt_in.i_sar_den <= 0 )
    {
        fmt_in.i_sar_num =
        fmt_in.i_sar_den = 1;
    }

    /* */
    video_format_t fmt_out;
    memset( &fmt_out, 0, sizeof(fmt_out) );
    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 1;
    fmt_out.i_chroma  = i_format;

    /* compute original width/height */
    unsigned int i_width, i_height, i_original_width, i_original_height;
    if( fmt_in.i_visible_width > 0 && fmt_in.i_visible_height > 0 )
    {
        i_width = fmt_in.i_visible_width;
        i_height = fmt_in.i_visible_height;
    }
    else
    {
        i_width = fmt_in.i_width;
        i_height = fmt_in.i_height;
    ...",421.0,503.0,1.0,1.0,83.0,78,18,63,18,1,2,8,8,0,2,,0,1,14,7,7,int
1723,123176,PictureFifoReset,1,PictureFifoReset,void PictureFifoReset (picture_fifo_t*),misc\picture_fifo.c,"static void PictureFifoReset(picture_fifo_t *fifo)
{
    fifo->first    = NULL;
    fifo->last_ptr = &fifo->first;
}",46.0,50.0,1.0,1.0,5.0,6,3,4,2,3,3,1,1,0,0,,0,3,2,1,1,void
1724,123194,PictureFifoPush,1,PictureFifoPush,"void PictureFifoPush (picture_fifo_t*,picture_t*)",misc\picture_fifo.c,"static void PictureFifoPush(picture_fifo_t *fifo, picture_t *picture)
{
    assert(!picture->p_next);
    *fifo->last_ptr = picture;
    fifo->last_ptr  = &picture->p_next;
}",51.0,56.0,1.0,1.0,6.0,9,5,5,2,2,2,1,1,0,0,,0,2,4,2,2,void
1725,123219,PictureFifoPop,1,PictureFifoPop,picture_t PictureFifoPop (picture_fifo_t*),misc\picture_fifo.c,"static picture_t *PictureFifoPop(picture_fifo_t *fifo)
{
    picture_t *picture = fifo->first;

    if (picture) {
        fifo->first = picture->p_next;
        if (!fifo->first)
            fifo->last_ptr = &fifo->first;
        picture->p_next = NULL;
    }
    return picture;
}",57.0,68.0,1.0,1.0,12.0,13,4,11,3,2,5,3,4,1,0,,0,5,2,1,1,picture_t
1726,123261,picture_fifo_New,1,picture_fifo_New,picture_fifo_t picture_fifo_New (void),misc\picture_fifo.c,"picture_fifo_t *picture_fifo_New(void)
{
    picture_fifo_t *fifo = malloc(sizeof(*fifo));
    if (!fifo)
        return NULL;

    vlc_mutex_init(&fifo->lock);
    PictureFifoReset(fifo);
    return fifo;
}",70.0,79.0,1.0,1.0,10.0,6,6,7,2,2,3,2,2,0,2,,0,1,2,1,1,picture_fifo_t
1727,123288,picture_fifo_Push,1,picture_fifo_Push,"void picture_fifo_Push (picture_fifo_t*,picture_t*)",misc\picture_fifo.c,"void picture_fifo_Push(picture_fifo_t *fifo, picture_t *picture)
{
    vlc_mutex_lock(&fifo->lock);
    PictureFifoPush(fifo, picture);
    vlc_mutex_unlock(&fifo->lock);
}",81.0,86.0,1.0,1.0,6.0,4,2,4,2,2,5,1,1,0,3,,0,2,4,2,2,void
1728,123307,picture_fifo_Pop,1,picture_fifo_Pop,picture_t picture_fifo_Pop (picture_fifo_t*),misc\picture_fifo.c,"picture_t *picture_fifo_Pop(picture_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = PictureFifoPop(fifo);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",87.0,94.0,1.0,1.0,8.0,5,3,5,2,0,5,1,1,0,3,,0,3,2,1,1,picture_t
1729,123329,picture_fifo_Peek,1,picture_fifo_Peek,picture_t picture_fifo_Peek (picture_fifo_t*),misc\picture_fifo.c,"picture_t *picture_fifo_Peek(picture_fifo_t *fifo)
{
    vlc_mutex_lock(&fifo->lock);
    picture_t *picture = fifo->first;
    if (picture)
        picture_Hold(picture);
    vlc_mutex_unlock(&fifo->lock);

    return picture;
}",95.0,104.0,1.0,1.0,10.0,6,3,7,2,1,6,2,2,0,3,,0,3,2,1,1,picture_t
1730,123357,picture_fifo_Flush,1,picture_fifo_Flush,"void picture_fifo_Flush (picture_fifo_t*,mtime_t,bool)",misc\picture_fifo.c,"void picture_fifo_Flush(picture_fifo_t *fifo, mtime_t date, bool flush_before)
{
    picture_t *picture;

    vlc_mutex_lock(&fifo->lock);

    picture = fifo->first;
    PictureFifoReset(fifo);

    picture_fifo_t tmp;
    PictureFifoReset(&tmp);

    while (picture) {
        picture_t *next = picture->p_next;

        picture->p_next = NULL;
        if (( flush_before && picture->date <= date) ||
            (!flush_before && picture->date >= date))
            PictureFifoPush(&tmp, picture);
        else
            PictureFifoPush(fifo, picture);
        picture = next;
    }
    vlc_mutex_unlock(&fifo->lock);

    while ((picture = PictureFifoPop(&tmp)) != NULL)
        picture_Release(picture);
}",105.0,132.0,1.0,1.0,28.0,24,9,24,7,2,9,4,5,1,6,,0,4,6,3,3,void
1731,123440,picture_fifo_OffsetDate,1,picture_fifo_OffsetDate,"void picture_fifo_OffsetDate (picture_fifo_t*,mtime_t)",misc\picture_fifo.c,"void picture_fifo_OffsetDate(picture_fifo_t *fifo, mtime_t delta)
{
    vlc_mutex_lock(&fifo->lock);
    for (picture_t *picture = fifo->first; picture != NULL;) {
        picture->date += delta;
        picture = picture->p_next;
    }
    vlc_mutex_unlock(&fifo->lock);
}",133.0,141.0,1.0,1.0,9.0,11,5,10,4,1,5,2,2,0,2,,0,3,4,2,2,void
1732,123478,picture_fifo_Delete,1,picture_fifo_Delete,void picture_fifo_Delete (picture_fifo_t*),misc\picture_fifo.c,"void picture_fifo_Delete(picture_fifo_t *fifo)
{
    picture_fifo_Flush(fifo, INT64_MAX, true);
    vlc_mutex_destroy(&fifo->lock);
    free(fifo);
}",142.0,147.0,1.0,1.0,6.0,2,2,5,3,3,3,1,1,0,2,,0,1,2,1,1,void
1733,123539,picture_pool_Destroy,1,picture_pool_Destroy,void picture_pool_Destroy (picture_pool_t*),misc\picture_pool.c,"static void picture_pool_Destroy(picture_pool_t *pool)
{
    if (atomic_fetch_sub(&pool->refs, 1) != 1)
        return;

    vlc_cond_destroy(&pool->wait);
    vlc_mutex_destroy(&pool->lock);
    aligned_free(pool);
}",54.0,62.0,1.0,1.0,9.0,7,3,4,1,2,5,2,2,1,2,,0,3,2,1,1,void
1734,123567,picture_pool_Release,1,picture_pool_Release,void picture_pool_Release (picture_pool_t*),misc\picture_pool.c,"void picture_pool_Release(picture_pool_t *pool)
{
    for (unsigned i = 0; i < pool->picture_count; i++)
        picture_Release(pool->picture[i]);
    picture_pool_Destroy(pool);
}",64.0,69.0,1.0,1.0,6.0,3,3,4,2,0,2,2,2,1,1,,0,1,2,1,1,void
1735,123593,picture_pool_ReleasePicture,1,picture_pool_ReleasePicture,void picture_pool_ReleasePicture (picture_t*),misc\picture_pool.c,"static void picture_pool_ReleasePicture(picture_t *clone)
{
    picture_priv_t *priv = (picture_priv_t *)clone;
    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *pool = (void *)(sys & ~(POOL_MAX - 1));
    unsigned offset = sys & (POOL_MAX - 1);
    picture_t *picture = pool->picture[offset];

    free(clone);

    if (pool->pic_unlock != NULL)
        pool->pic_unlock(picture);
    picture_Release(picture);

    vlc_mutex_lock(&pool->lock);
    assert(!(pool->available & (1ULL << offset)));
    pool->available |= 1ULL << offset;
    vlc_cond_signal(&pool->wait);
    vlc_mutex_unlock(&pool->lock);

    picture_pool_Destroy(pool);
}",71.0,92.0,1.0,44.0,22.0,36,14,29,9,0,12,2,2,0,5,,0,7,2,1,1,void
1736,123700,picture_pool_ClonePicture,1,picture_pool_ClonePicture,"picture_t picture_pool_ClonePicture (picture_pool_t*,unsigned)",misc\picture_pool.c,"static picture_t *picture_pool_ClonePicture(picture_pool_t *pool,
                                            unsigned offset)
{
    picture_t *picture = pool->picture[offset];
    uintptr_t sys = ((uintptr_t)pool) + offset;
    picture_resource_t res = {
        .p_sys = picture->p_sys,
        .pf_destroy = picture_pool_ReleasePicture,
    };

    for (int i = 0; i < picture->i_planes; i++) {
        res.p[i].p_pixels = picture->p[i].p_pixels;
        res.p[i].i_lines = picture->p[i].i_lines;
        res.p[i].i_pitch = picture->p[i].i_pitch;
    }

    picture_t *clone = picture_NewFromResource(&picture->format, &res);
    if (likely(clone != NULL)) {
        ((picture_priv_t *)clone)->gc.opaque = (void *)sys;
        picture_Hold(picture);
    }
    return clone;
}",94.0,116.0,1.0,1.0,23.0,45,10,34,10,2,3,3,3,0,2,,0,2,4,2,2,picture_t
1737,123826,picture_pool_NewExtended,1,picture_pool_NewExtended,picture_pool_t picture_pool_NewExtended (picture_pool_configuration_t*),misc\picture_pool.c,"picture_pool_t *picture_pool_NewExtended(const picture_pool_configuration_t *cfg)
{
    if (unlikely(cfg->picture_count > POOL_MAX))
        return NULL;

    picture_pool_t *pool;
    size_t size = sizeof (*pool) + cfg->picture_count * sizeof (picture_t *);

    size += (-size) & (POOL_MAX - 1);
    pool = aligned_alloc(POOL_MAX, size);
    if (unlikely(pool == NULL))
        return NULL;

    pool->pic_lock   = cfg->lock;
    pool->pic_unlock = cfg->unlock;
    vlc_mutex_init(&pool->lock);
    vlc_cond_init(&pool->wait);
    if (cfg->picture_count == POOL_MAX)
        pool->available = ~0ULL;
    else
        pool->available = (1ULL << cfg->picture_count) - 1;
    atomic_init(&pool->refs,  1);
    pool->picture_count = cfg->picture_count;
    memcpy(pool->picture, cfg->picture,
           cfg->picture_count * sizeof (picture_t *));
    pool->canceled = false;
    return pool;
}",118.0,145.0,1.0,38.0,28.0,50,14,39,8,1,9,4,4,0,2,,0,7,2,1,1,picture_pool_t
1738,123979,picture_pool_New,1,picture_pool_New,"picture_pool_t picture_pool_New (unsigned,picture_t**)",misc\picture_pool.c,"picture_pool_t *picture_pool_New(unsigned count, picture_t *const *tab)
{
    picture_pool_configuration_t cfg = {
        .picture_count = count,
        .picture = tab,
    };

    return picture_pool_NewExtended(&cfg);
}",147.0,155.0,1.0,1.0,9.0,5,3,6,5,2,1,1,1,0,1,,0,0,4,2,2,picture_pool_t
1739,124001,picture_pool_NewFromFormat,1,picture_pool_NewFromFormat,"picture_pool_t picture_pool_NewFromFormat (video_format_t*,unsigned)",misc\picture_pool.c,"picture_pool_t *picture_pool_NewFromFormat(const video_format_t *fmt,
                                           unsigned count)
{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_NewFromFormat(fmt);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",157.0,179.0,1.0,1.0,23.0,9,6,16,6,1,2,7,6,0,2,,0,2,4,2,2,picture_pool_t
1740,124059,picture_pool_Reserve,1,picture_pool_Reserve,"picture_pool_t picture_pool_Reserve (picture_pool_t*,unsigned)",misc\picture_pool.c,"picture_pool_t *picture_pool_Reserve(picture_pool_t *master, unsigned count)
{
    picture_t *picture[count ? count : 1];
    unsigned i;

    for (i = 0; i < count; i++) {
        picture[i] = picture_pool_Get(master);
        if (picture[i] == NULL)
            goto error;
    }

    picture_pool_t *pool = picture_pool_New(count, picture);
    if (!pool)
        goto error;

    return pool;

error:
    while (i > 0)
        picture_Release(picture[--i]);
    return NULL;
}",181.0,202.0,1.0,1.0,22.0,9,6,16,6,0,2,7,6,0,2,,0,2,4,2,2,picture_pool_t
1741,124143,picture_pool_Get,1,picture_pool_Get,picture_t picture_pool_Get (picture_pool_t*),misc\picture_pool.c,"picture_t *picture_pool_Get(picture_pool_t *pool)
{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    if (pool->canceled)
    {
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    for (unsigned i = ffsll(pool->available); i; i = fnsll(pool->available, i))
    {
        pool->available &= ~(1ULL << (i - 1));
        vlc_mutex_unlock(&pool->lock);

        picture_t *picture = pool->picture[i - 1];

        if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
            vlc_mutex_lock(&pool->lock);
            pool->available |= 1ULL << (i - 1);
            continue;
        }

        picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
        if (clone != NULL) {
            assert(clone->p_next == NULL);
            atomic_fetch_add(&pool->refs, 1);
        }
        return clone;
    }

    vlc_mutex_unlock(&pool->lock);
    return NULL;
}",212.0,246.0,1.0,1.0,35.0,38,11,33,6,5,18,6,7,1,6,,0,13,2,1,1,picture_t
1742,124278,picture_pool_Wait,1,picture_pool_Wait,picture_t picture_pool_Wait (picture_pool_t*),misc\picture_pool.c,"picture_t *picture_pool_Wait(picture_pool_t *pool)
{
    unsigned i;

    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    while (pool->available == 0)
    {
        if (pool->canceled)
        {
            vlc_mutex_unlock(&pool->lock);
            return NULL;
        }
        vlc_cond_wait(&pool->wait, &pool->lock);
    }

    i = ffsll(pool->available);
    assert(i > 0);
    pool->available &= ~(1ULL << (i - 1));
    vlc_mutex_unlock(&pool->lock);

    picture_t *picture = pool->picture[i - 1];

    if (pool->pic_lock != NULL && pool->pic_lock(picture) != VLC_SUCCESS) {
        vlc_mutex_lock(&pool->lock);
        pool->available |= 1ULL << (i - 1);
        vlc_cond_signal(&pool->wait);
        vlc_mutex_unlock(&pool->lock);
        return NULL;
    }

    picture_t *clone = picture_pool_ClonePicture(pool, i - 1);
    if (clone != NULL) {
        assert(clone->p_next == NULL);
        atomic_fetch_add(&pool->refs, 1);
    }
    return clone;
}",248.0,286.0,1.0,1.0,39.0,47,11,37,6,1,24,5,6,2,8,,0,17,2,1,1,picture_t
1743,124426,picture_pool_Cancel,1,picture_pool_Cancel,"void picture_pool_Cancel (picture_pool_t*,bool)",misc\picture_pool.c,"void picture_pool_Cancel(picture_pool_t *pool, bool canceled)
{
    vlc_mutex_lock(&pool->lock);
    assert(pool->refs > 0);

    pool->canceled = canceled;
    if (canceled)
        vlc_cond_broadcast(&pool->wait);
    vlc_mutex_unlock(&pool->lock);
}",288.0,297.0,1.0,1.0,10.0,10,4,7,2,1,8,2,2,0,3,,0,5,4,2,2,void
1744,124461,picture_pool_OwnsPic,1,picture_pool_OwnsPic,"bool picture_pool_OwnsPic (picture_pool_t*,picture_t*)",misc\picture_pool.c,"bool picture_pool_OwnsPic(picture_pool_t *pool, picture_t *pic)
{
    picture_priv_t *priv = (picture_priv_t *)pic;

    while (priv->gc.destroy != picture_pool_ReleasePicture) {
        pic = priv->gc.opaque;
        priv = (picture_priv_t *)pic;
    }

    uintptr_t sys = (uintptr_t)priv->gc.opaque;
    picture_pool_t *picpool = (void *)(sys & ~(POOL_MAX - 1));
    return pool == picpool;
}",299.0,311.0,1.0,47.0,13.0,22,11,15,7,1,3,2,2,1,0,,0,3,4,2,2,bool
1745,124524,picture_pool_GetSize,1,picture_pool_GetSize,unsigned picture_pool_GetSize (picture_pool_t*),misc\picture_pool.c,"unsigned picture_pool_GetSize(const picture_pool_t *pool)
{
    return pool->picture_count;
}",313.0,316.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned
1746,124533,picture_pool_Enum,1,picture_pool_Enum,"void picture_pool_Enum (picture_pool_t*,void,void*)",misc\picture_pool.c,"void picture_pool_Enum(picture_pool_t *pool, void (*cb)(void *, picture_t *),
                       void *opaque)
{
    /* NOTE: So far, the pictures table cannot change after the pool is created
     * so there is no need to lock the pool mutex here. */
    for (unsigned i = 0; i < pool->picture_count; i++)
        cb(opaque, pool->picture[i]);
}",318.0,325.0,1.0,1.0,8.0,3,3,3,2,0,1,2,2,1,0,,0,1,6,3,3,void
1747,124575,vlc_probe,1,vlc_probe,"void* vlc_probe (vlc_object_t*,char*,size_t*)",misc\probe.c,"void *vlc_probe (vlc_object_t *obj,
                 const char *capability, size_t *restrict pcount)
{
    vlc_probe_t *probe = vlc_custom_create (obj, sizeof(*probe), ""probe"");
    if (unlikely(probe == NULL))
    {
        *pcount = 0;
        return NULL;
    }
    probe->list = NULL;
    probe->count = 0;

    module_t *mod = module_need (probe, capability, NULL, false);
    if (mod != NULL)
    {
        msg_Warn (probe, ""probing halted"");
        module_unneed (probe, mod);
    }

    void *ret = probe->list;
    *pcount = probe->count;
    vlc_object_release (probe);
    return ret;
}",31.0,54.0,1.0,25.0,24.0,17,6,27,8,2,4,3,3,0,4,,0,2,6,3,3,void*
1748,124684,init_rand48,1,init_rand48,void init_rand48 (void),misc\rand.c,"static void init_rand48 (void)
{
    if (!rand48.init)
    {
        vlc_rand_bytes (rand48.subi, sizeof (rand48.subi));
        rand48.init = true;
#if 0 // short would be more than 16-bits ?
        for (unsigned i = 0; i < 3; i++)
            subi[i] &= 0xffff;
#endif
    }
}",36.0,47.0,1.0,1.0,12.0,7,4,5,2,3,5,2,2,1,1,,0,4,2,1,1,void
1749,124708,vlc_drand48,1,vlc_drand48,double vlc_drand48 (void),misc\rand.c,"double vlc_drand48 (void)
{
    double ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = erand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",58.0,67.0,1.0,1.0,10.0,6,3,5,2,0,6,1,1,0,3,,0,3,2,1,1,double
1750,124733,vlc_lrand48,1,vlc_lrand48,long vlc_lrand48 (void),misc\rand.c,"long vlc_lrand48 (void)
{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = nrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",78.0,87.0,1.0,1.0,10.0,6,3,5,2,0,6,1,1,0,3,,0,3,2,1,1,long
1751,124758,vlc_mrand48,1,vlc_mrand48,long vlc_mrand48 (void),misc\rand.c,"long vlc_mrand48 (void)
{
    long ret;

    vlc_mutex_lock (&rand48.lock);
    init_rand48 ();
    ret = jrand48 (rand48.subi);
    vlc_mutex_unlock (&rand48.lock);
    return ret;
}",98.0,107.0,1.0,1.0,10.0,6,3,5,2,0,6,1,1,0,3,,0,3,2,1,1,long
1752,124812,item_free,1,item_free,void item_free (vlc_renderer_item_t*),misc\renderer_discovery.c,"static void
item_free(vlc_renderer_item_t *p_item)
{
    free(p_item->psz_name);
    free(p_item->psz_type);
    free(p_item->psz_sout);
    free(p_item->psz_icon_uri);
    free(p_item->psz_demux_filter);
    free(p_item);
}",45.0,54.0,1.0,1.0,10.0,5,1,6,1,2,5,1,1,0,0,,0,5,2,1,1,void
1753,124839,vlc_renderer_item_new,1,vlc_renderer_item_new,"vlc_renderer_item_t vlc_renderer_item_new (char*,char*,char*,char*,char*,char*,int)",misc\renderer_discovery.c,"vlc_renderer_item_t *
vlc_renderer_item_new(const char *psz_type, const char *psz_name,
                      const char *psz_uri, const char *psz_extra_sout,
                      const char *psz_demux_filter, const char *psz_icon_uri,
                      int i_flags)
{
    assert(psz_uri != NULL);
    vlc_renderer_item_t *p_item = NULL;
    vlc_url_t url;
    vlc_UrlParse(&url, psz_uri);

    if (url.psz_protocol == NULL || url.psz_host == NULL)
        goto error;

    p_item = calloc(1, sizeof(vlc_renderer_item_t));
    if (unlikely(p_item == NULL))
        goto error;

    if ((p_item->psz_type = strdup(psz_type)) == NULL)
        goto error;

    if (psz_name != NULL)
        p_item->psz_name = strdup(psz_name);
    else if (asprintf(&p_item->psz_name, ""%s (%s)"", url.psz_protocol,
                      url.psz_host) == -1)
        p_item->psz_name = NULL;
    if (p_item->psz_name == NULL)
        goto error;

    if (asprintf(&p_item->psz_sout, ""%s{ip=%s,port=%d%s%s}"",
     ...",56.0,107.0,1.0,1.0,52.0,45,11,50,11,0,12,17,10,5,4,,0,8,14,7,7,vlc_renderer_item_t
1754,125032,vlc_renderer_item_name,1,vlc_renderer_item_name,const char* vlc_renderer_item_name (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_name(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_name;
}",109.0,115.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
1755,125045,vlc_renderer_item_type,1,vlc_renderer_item_type,const char* vlc_renderer_item_type (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_type(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_type;
}",117.0,123.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
1756,125058,vlc_renderer_item_sout,1,vlc_renderer_item_sout,const char* vlc_renderer_item_sout (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_sout(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_sout;
}",125.0,131.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
1757,125071,vlc_renderer_item_icon_uri,1,vlc_renderer_item_icon_uri,const char* vlc_renderer_item_icon_uri (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_icon_uri(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_icon_uri;
}",133.0,139.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
1758,125084,vlc_renderer_item_demux_filter,1,vlc_renderer_item_demux_filter,const char* vlc_renderer_item_demux_filter (vlc_renderer_item_t*),misc\renderer_discovery.c,"const char *
vlc_renderer_item_demux_filter(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->psz_demux_filter;
}",141.0,147.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,const char*
1759,125097,vlc_renderer_item_flags,1,vlc_renderer_item_flags,int vlc_renderer_item_flags (vlc_renderer_item_t*),misc\renderer_discovery.c,"int
vlc_renderer_item_flags(const vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    return p_item->i_flags;
}",149.0,155.0,1.0,1.0,7.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,int
1760,125110,vlc_renderer_item_hold,1,vlc_renderer_item_hold,vlc_renderer_item_t vlc_renderer_item_hold (vlc_renderer_item_t*),misc\renderer_discovery.c,"vlc_renderer_item_t *
vlc_renderer_item_hold(vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    atomic_fetch_add(&p_item->refs, 1);
    return p_item;
}",157.0,164.0,1.0,1.0,8.0,3,3,4,2,3,1,1,1,0,0,,0,1,2,1,1,vlc_renderer_item_t
1761,125127,vlc_renderer_item_release,1,vlc_renderer_item_release,void vlc_renderer_item_release (vlc_renderer_item_t*),misc\renderer_discovery.c,"void
vlc_renderer_item_release(vlc_renderer_item_t *p_item)
{
    assert(p_item != NULL);

    int refs = atomic_fetch_sub(&p_item->refs, 1);
    assert(refs != 0 );
    if( refs != 1 )
        return;
    item_free(p_item);
}",166.0,176.0,1.0,1.0,11.0,6,4,7,3,4,2,2,2,0,1,,0,1,2,1,1,void
1762,125160,vlc_rd_probe_add,1,vlc_rd_probe_add,"int vlc_rd_probe_add (vlc_probe_t*,char*,char*)",misc\renderer_discovery.c,"int
vlc_rd_probe_add(vlc_probe_t *probe, const char *psz_name,
                 const char *psz_longname)
{
    struct vlc_rd_probe names = { strdup(psz_name), strdup(psz_longname) };

    if (unlikely(names.psz_name == NULL || names.psz_longname == NULL
                 || vlc_probe_add(probe, &names, sizeof(names))))
    {
        free(names.psz_name);
        free(names.psz_longname);
        return VLC_ENOMEM;
    }
    return VLC_PROBE_CONTINUE;
}",184.0,198.0,1.0,1.0,15.0,12,7,14,7,0,4,2,2,2,0,,0,4,6,3,3,int
1763,125208,vlc_rd_get_names,1,vlc_rd_get_names,"int vlc_rd_get_names (vlc_object_t*,char***,char***)",misc\renderer_discovery.c,"int
vlc_rd_get_names(vlc_object_t *p_obj, char ***pppsz_names,
                 char ***pppsz_longnames)
{
    size_t i_count;
    struct vlc_rd_probe *p_tab = vlc_probe(p_obj, ""renderer probe"", &i_count);

    if (i_count == 0)
    {
        free(p_tab);
        return VLC_EGENERIC;
    }

    char **ppsz_names = vlc_alloc(i_count + 1, sizeof(char *));
    char **ppsz_longnames = vlc_alloc(i_count + 1, sizeof(char *));

    if (unlikely(ppsz_names == NULL || ppsz_longnames == NULL))
    {
        free(ppsz_names);
        free(ppsz_longnames);
        free(p_tab);
        return VLC_EGENERIC;
    }

    for (size_t i = 0; i < i_count; i++)
    {
        ppsz_names[i] = p_tab[i].psz_name;
        ppsz_longnames[i] = p_tab[i].psz_longname;
    }
    ppsz_names[i_count] = ppsz_longnames[i_count] = NULL;
    free(p_tab);
    *pppsz_names = ppsz_names;
    *pppsz_longnames = ppsz_longnames;
    return VLC_SUCCESS;
}",201.0,235.0,1.0,1.0,35.0,30,10,42,12,0,1,4,4,0,1,,0,1,6,3,3,int
1764,125320,vlc_rd_release,1,vlc_rd_release,void vlc_rd_release (vlc_renderer_discovery_t*),misc\renderer_discovery.c,"void vlc_rd_release(vlc_renderer_discovery_t *p_rd)
{
    module_unneed(p_rd, p_rd->p_module);
    config_ChainDestroy(p_rd->p_cfg);
    free(p_rd->psz_name);
    vlc_object_release(p_rd);
}",237.0,243.0,1.0,1.0,7.0,3,1,5,1,0,3,1,1,0,3,,0,0,2,1,1,void
1765,125340,vlc_rd_new,1,vlc_rd_new,"vlc_renderer_discovery_t vlc_rd_new (vlc_object_t*,char*,vlc_renderer_discovery_owner*)",misc\renderer_discovery.c,"vlc_renderer_discovery_t *
vlc_rd_new(vlc_object_t *p_obj, const char *psz_name,
           const struct vlc_renderer_discovery_owner *restrict owner)
{
    vlc_renderer_discovery_t *p_rd;

    p_rd = vlc_custom_create(p_obj, sizeof(*p_rd), ""renderer discovery"");
    if(!p_rd)
        return NULL;
    free(config_ChainCreate(&p_rd->psz_name, &p_rd->p_cfg, psz_name));

    p_rd->owner = *owner;
    p_rd->p_module = module_need(p_rd, ""renderer_discovery"",
                                 p_rd->psz_name, true);
    if (p_rd->p_module == NULL)
    {
        msg_Err(p_rd, ""no suitable renderer discovery module for '%s'"",
            psz_name);
        free(p_rd->psz_name);
        config_ChainDestroy(p_rd->p_cfg);
        vlc_object_release(p_rd);
        p_rd = NULL;
    }

    return p_rd;
}",245.0,270.0,1.0,1.0,26.0,19,7,24,6,0,5,3,3,0,5,,0,2,6,3,3,vlc_renderer_discovery_t
1766,125438,subpicture_New,1,subpicture_New,subpicture_t subpicture_New (subpicture_updater_t*),misc\subpicture.c,"subpicture_t *subpicture_New( const subpicture_updater_t *p_upd )
{
    subpicture_t *p_subpic = calloc( 1, sizeof(*p_subpic) );
    if( !p_subpic )
        return NULL;

    p_subpic->i_order    = 0;
    p_subpic->b_absolute = true;
    p_subpic->b_fade     = false;
    p_subpic->b_subtitle = false;
    p_subpic->i_alpha    = 0xFF;
    p_subpic->p_region   = NULL;

    if( p_upd )
    {
        subpicture_private_t *p_private = malloc( sizeof(*p_private) );
        if( !p_private )
        {
            free( p_subpic );
            return NULL;
        }
        video_format_Init( &p_private->src, 0 );
        video_format_Init( &p_private->dst, 0 );

        p_subpic->updater   = *p_upd;
        p_subpic->p_private = p_private;
    }
    else
    {
        p_subpic->p_private = NULL;

        p_subpic->updater.pf_validate = NULL;
        p_subpic->updater.pf_update   = NULL;
        p_subpic->updater.pf_destroy  = NULL;
        p_subpic->updater.p_sys       = NULL;
    }
    retu...",44.0,81.0,1.0,1.0,38.0,29,6,27,6,7,2,4,5,0,0,,0,2,2,1,1,subpicture_t
1767,125565,subpicture_Delete,1,subpicture_Delete,void subpicture_Delete (subpicture_t*),misc\subpicture.c,"void subpicture_Delete( subpicture_t *p_subpic )
{
    subpicture_region_ChainDelete( p_subpic->p_region );
    p_subpic->p_region = NULL;

    if( p_subpic->updater.pf_destroy )
        p_subpic->updater.pf_destroy( p_subpic );

    if( p_subpic->p_private )
    {
        video_format_Clean( &p_subpic->p_private->src );
        video_format_Clean( &p_subpic->p_private->dst );
    }

    free( p_subpic->p_private );
    free( p_subpic );
}",83.0,99.0,1.0,1.0,17.0,15,4,11,2,10,1,3,3,0,1,,0,0,2,1,1,void
1768,125618,subpicture_NewFromPicture,1,subpicture_NewFromPicture,"subpicture_t subpicture_NewFromPicture (vlc_object_t*,picture_t*,vlc_fourcc_t)",misc\subpicture.c,"subpicture_t *subpicture_NewFromPicture( vlc_object_t *p_obj,
                                         picture_t *p_picture, vlc_fourcc_t i_chroma )
{
    /* */
    video_format_t fmt_in = p_picture->format;

    /* */
    video_format_t fmt_out;
    fmt_out = fmt_in;
    fmt_out.i_chroma = i_chroma;

    /* */
    image_handler_t *p_image = image_HandlerCreate( p_obj );
    if( !p_image )
        return NULL;

    picture_t *p_pip = image_Convert( p_image, p_picture, &fmt_in, &fmt_out );

    image_HandlerDelete( p_image );

    if( !p_pip )
        return NULL;

    subpicture_t *p_subpic = subpicture_New( NULL );
    if( !p_subpic )
    {
         picture_Release( p_pip );
         return NULL;
    }

    p_subpic->i_original_picture_width  = fmt_out.i_visible_width;
    p_subpic->i_original_picture_height = fmt_out.i_visible_height;

    fmt_out.i_sar_num =
    fmt_out.i_sar_den = 0;

    p_subpic->p_region = subpicture_region_New( &fmt_out );
    if( p_subpic->p_region )
    {
...",101.0,148.0,1.0,1.0,48.0,32,5,36,9,1,6,5,5,0,6,,0,3,6,3,3,subpicture_t
1769,125736,subpicture_Update,1,subpicture_Update,"void subpicture_Update (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",misc\subpicture.c,"void subpicture_Update( subpicture_t *p_subpicture,
                        const video_format_t *p_fmt_src,
                        const video_format_t *p_fmt_dst,
                        mtime_t i_ts )
{
    subpicture_updater_t *p_upd = &p_subpicture->updater;
    subpicture_private_t *p_private = p_subpicture->p_private;

    if( !p_upd->pf_validate )
        return;
    if( !p_upd->pf_validate( p_subpicture,
                          !video_format_IsSimilar( p_fmt_src,
                                                   &p_private->src ), p_fmt_src,
                          !video_format_IsSimilar( p_fmt_dst,
                                                   &p_private->dst ), p_fmt_dst,
                          i_ts ) )
        return;

    subpicture_region_ChainDelete( p_subpicture->p_region );
    p_subpicture->p_region = NULL;

    p_upd->pf_update( p_subpicture, p_fmt_src, p_fmt_dst, i_ts );

    video_format_Clean( &p_private->src );
    video_format_Clean( &p_private...",150.0,178.0,1.0,1.0,29.0,27,4,28,7,1,9,3,3,4,3,,0,8,8,4,4,void
1770,125829,subpicture_region_private_New,1,subpicture_region_private_New,subpicture_region_private_t subpicture_region_private_New (video_format_t*),misc\subpicture.c,"subpicture_region_private_t *subpicture_region_private_New( video_format_t *p_fmt )
{
    subpicture_region_private_t *p_private = malloc( sizeof(*p_private) );

    if( !p_private )
        return NULL;

    if ( video_format_Copy( &p_private->fmt, p_fmt ) != VLC_SUCCESS )
    {
        free( p_private );
        return NULL;
    }

    p_private->p_picture = NULL;
    return p_private;
}",181.0,196.0,1.0,1.0,16.0,9,7,12,4,1,2,3,3,1,0,,0,2,2,1,1,subpicture_region_private_t
1771,125868,subpicture_region_private_Delete,1,subpicture_region_private_Delete,void subpicture_region_private_Delete (subpicture_region_private_t*),misc\subpicture.c,"void subpicture_region_private_Delete( subpicture_region_private_t *p_private )
{
    if( p_private->p_picture )
        picture_Release( p_private->p_picture );
    video_format_Clean( &p_private->fmt );
    free( p_private );
}",198.0,204.0,1.0,1.0,7.0,4,2,4,1,4,4,2,2,1,1,,0,3,2,1,1,void
1772,125889,subpicture_region_New,1,subpicture_region_New,subpicture_region_t subpicture_region_New (video_format_t*),misc\subpicture.c,"subpicture_region_t *subpicture_region_New( const video_format_t *p_fmt )
{
    subpicture_region_t *p_region = calloc( 1, sizeof(*p_region ) );
    if( !p_region )
        return NULL;

    if ( p_fmt->i_chroma == VLC_CODEC_YUVP )
    {
        video_format_Copy( &p_region->fmt, p_fmt );
        /* YUVP should have a palette */
        if( p_region->fmt.p_palette == NULL )
        {
            p_region->fmt.p_palette = calloc( 1, sizeof(*p_region->fmt.p_palette) );
            if( p_region->fmt.p_palette == NULL )
            {
                free( p_region );
                return NULL;
            }
        }
    }
    else
    {
        p_region->fmt = *p_fmt;
        p_region->fmt.p_palette = NULL;
    }

    p_region->i_alpha = 0xff;
    p_region->b_balanced_text = true;

    if( p_fmt->i_chroma == VLC_CODEC_TEXT )
        return p_region;

    p_region->p_picture = picture_NewFromFormat( p_fmt );
    if( !p_region->p_picture )
    {
        video_format_Clean( &p_region->f...",206.0,247.0,1.0,1.0,42.0,33,8,29,6,9,1,7,10,0,1,,0,1,2,1,1,subpicture_region_t
1773,126015,subpicture_region_Delete,1,subpicture_region_Delete,void subpicture_region_Delete (subpicture_region_t*),misc\subpicture.c,"void subpicture_region_Delete( subpicture_region_t *p_region )
{
    if( !p_region )
        return;

    if( p_region->p_private )
        subpicture_region_private_Delete( p_region->p_private );

    if( p_region->p_picture )
        picture_Release( p_region->p_picture );

    text_segment_ChainDelete( p_region->p_text );
    video_format_Clean( &p_region->fmt );
    free( p_region );
}",249.0,263.0,1.0,1.0,15.0,8,3,8,1,1,3,4,4,0,3,,0,0,2,1,1,void
1774,126054,subpicture_region_ChainDelete,1,subpicture_region_ChainDelete,void subpicture_region_ChainDelete (subpicture_region_t*),misc\subpicture.c,"void subpicture_region_ChainDelete( subpicture_region_t *p_head )
{
    while( p_head )
    {
        subpicture_region_t *p_next = p_head->p_next;

        subpicture_region_Delete( p_head );

        p_head = p_next;
    }
}",265.0,275.0,1.0,1.0,11.0,3,2,6,2,2,1,2,2,0,1,,0,0,2,1,1,void
1775,126073,picture_BlendSubpicture,1,picture_BlendSubpicture,"unsigned picture_BlendSubpicture (picture_t*,filter_t*,subpicture_t*)",misc\subpicture.c,"unsigned picture_BlendSubpicture(picture_t *dst,
                                 filter_t *blend, subpicture_t *src)
{
    unsigned done = 0;

    assert(src && !src->b_fade && src->b_absolute);

    for (subpicture_region_t *r = src->p_region; r != NULL; r = r->p_next) {
        assert(r->p_picture && r->i_align == 0);
        if (filter_ConfigureBlend(blend, dst->format.i_width,
                                  dst->format.i_height,  &r->fmt)
         || filter_Blend(blend, dst, r->i_x, r->i_y, r->p_picture,
                         src->i_alpha * r->i_alpha / 255))
            msg_Err(blend, ""blending %4.4s to %4.4s failed"",
                    (char *)&blend->fmt_in.video.i_chroma,
                    (char *)&blend->fmt_out.video.i_chroma );
        else
            done++;
    }
    return done;
}",279.0,299.0,1.0,1.0,21.0,37,12,25,6,2,2,3,4,2,2,,0,2,6,3,3,unsigned
1776,126191,subpicture_region_Copy,1,subpicture_region_Copy,subpicture_region_t subpicture_region_Copy (subpicture_region_t*),misc\subpicture.c,"subpicture_region_t* subpicture_region_Copy( subpicture_region_t *p_region_src )
{
    if (!p_region_src)
        return NULL;
    subpicture_region_t *p_region_dst = subpicture_region_New(&p_region_src->fmt);
    if (unlikely(!p_region_dst))
        return NULL;

    p_region_dst->i_x      = p_region_src->i_x;
    p_region_dst->i_y      = p_region_src->i_y;
    p_region_dst->i_align  = p_region_src->i_align;
    p_region_dst->i_alpha  = p_region_src->i_alpha;

    p_region_dst->p_text = text_segment_Copy( p_region_src->p_text );

    //Palette is already copied by subpicture_region_New, we just have to duplicate p_pixels
    for (int i = 0; i < p_region_src->p_picture->i_planes; i++)
        memcpy(p_region_dst->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].p_pixels,
               p_region_src->p_picture->p[i].i_lines * p_region_src->p_picture->p[i].i_pitch);
    return p_region_dst;
}",301.0,322.0,1.0,1.0,22.0,24,5,20,4,0,2,4,4,0,2,,0,2,2,1,1,subpicture_region_t
1777,126339,text_style_New,1,text_style_New,text_style_t text_style_New (void),misc\text_style.c,"text_style_t *text_style_New( void )
{
    return text_style_Create( STYLE_FULLY_SET );
}",34.0,37.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,text_style_t
1778,126347,text_style_Create,1,text_style_Create,text_style_t text_style_Create (int),misc\text_style.c,"text_style_t *text_style_Create( int i_defaults )
{
    text_style_t *p_style = calloc( 1, sizeof(*p_style) );
    if( !p_style )
        return NULL;

    if( i_defaults == STYLE_NO_DEFAULTS )
        return p_style;

    /* initialize to default text style (FIXME: by flag) */
    p_style->psz_fontname = NULL;
    p_style->psz_monofontname = NULL;
    p_style->i_features = STYLE_FULLY_SET;
    p_style->i_style_flags = STYLE_OUTLINE;
    p_style->f_font_relsize = STYLE_DEFAULT_REL_FONT_SIZE;
    p_style->i_font_size = STYLE_DEFAULT_FONT_SIZE;
    p_style->i_font_color = 0xffffff;
    p_style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_outline_color = 0x000000;
    p_style->i_outline_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_shadow_color = 0x808080;
    p_style->i_shadow_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_background_color = 0x000000;
    p_style->i_background_alpha = STYLE_ALPHA_OPAQUE;
    p_style->i_karaoke_background_color = 0xffffff;
    p_style->i_karaoke_backgro...",39.0,71.0,1.0,1.0,33.0,46,7,40,10,2,0,3,3,0,0,,0,0,2,1,1,text_style_t
1779,126476,text_style_Copy,1,text_style_Copy,"text_style_t text_style_Copy (text_style_t*,text_style_t*)",misc\text_style.c,"text_style_t *text_style_Copy( text_style_t *p_dst, const text_style_t *p_src )
{
    if( !p_src )
        return p_dst;

    /* */
    *p_dst = *p_src;

    if( p_src->psz_fontname )
        p_dst->psz_fontname = strdup( p_src->psz_fontname );

    if( p_src->psz_monofontname )
        p_dst->psz_monofontname = strdup( p_src->psz_monofontname );

    return p_dst;
}",73.0,88.0,1.0,1.0,16.0,12,4,11,2,1,0,4,4,0,0,,0,0,4,2,2,text_style_t
1780,127003,text_style_Duplicate,1,text_style_Duplicate,text_style_t text_style_Duplicate (text_style_t*),misc\text_style.c,"text_style_t *text_style_Duplicate( const text_style_t *p_src )
{
    if( !p_src )
        return NULL;

    text_style_t *p_dst = calloc( 1, sizeof(*p_dst) );
    if( p_dst )
        text_style_Copy( p_dst, p_src );
    return p_dst;
}",139.0,148.0,1.0,1.0,10.0,4,4,8,3,3,1,3,3,0,1,,0,0,2,1,1,text_style_t
1781,127030,text_style_Delete,1,text_style_Delete,void text_style_Delete (text_style_t*),misc\text_style.c,"void text_style_Delete( text_style_t *p_style )
{
    if( p_style )
        free( p_style->psz_fontname );
    if( p_style )
        free( p_style->psz_monofontname );
    free( p_style );
}",150.0,157.0,1.0,1.0,8.0,2,1,5,1,2,0,3,3,0,0,,0,0,2,1,1,void
1782,127051,text_segment_New,1,text_segment_New,text_segment_t text_segment_New (char*),misc\text_style.c,"text_segment_t *text_segment_New( const char *psz_text )
{
    text_segment_t* segment = calloc( 1, sizeof(*segment) );
    if( !segment )
        return NULL;

    if ( psz_text )
        segment->psz_text = strdup( psz_text );

    return segment;
}",159.0,169.0,1.0,1.0,11.0,6,5,8,3,4,0,3,3,0,0,,0,0,2,1,1,text_segment_t
1783,127081,text_segment_NewInheritStyle,1,text_segment_NewInheritStyle,text_segment_t text_segment_NewInheritStyle (text_style_t*),misc\text_style.c,"text_segment_t *text_segment_NewInheritStyle( const text_style_t* p_style )
{
    if ( !p_style )
        return NULL; //FIXME: Allow this, even if it is an alias to text_segment_New( NULL ) ?
    text_segment_t* p_segment = text_segment_New( NULL );
    if ( unlikely( !p_segment ) )
        return NULL;
    p_segment->style = text_style_Duplicate( p_style );
    if ( unlikely( !p_segment->style ) )
    {
        text_segment_Delete( p_segment );
        return NULL;
    }
    return p_segment;
}",171.0,185.0,1.0,1.0,15.0,7,3,12,3,0,3,4,4,0,3,,0,2,2,1,1,text_segment_t
1784,127123,text_segment_Delete,1,text_segment_Delete,void text_segment_Delete (text_segment_t*),misc\text_style.c,"void text_segment_Delete( text_segment_t* segment )
{
    if ( segment != NULL )
    {
        free( segment->psz_text );
        text_style_Delete( segment->style );
        free( segment );
    }
}",187.0,195.0,1.0,1.0,9.0,3,2,5,2,3,1,2,2,0,1,,0,0,2,1,1,void
1785,127143,text_segment_ChainDelete,1,text_segment_ChainDelete,void text_segment_ChainDelete (text_segment_t*),misc\text_style.c,"void text_segment_ChainDelete( text_segment_t *segment )
{
    while( segment != NULL )
    {
        text_segment_t *p_next = segment->p_next;

        text_segment_Delete( segment );

        segment = p_next;
    }
}",197.0,207.0,1.0,1.0,11.0,4,3,7,3,1,1,2,2,0,1,,0,0,2,1,1,void
1786,127164,text_segment_Copy,1,text_segment_Copy,text_segment_t text_segment_Copy (text_segment_t*),misc\text_style.c,"text_segment_t *text_segment_Copy( text_segment_t *p_src )
{
    text_segment_t *p_dst = NULL, *p_dst0 = NULL;

    while( p_src ) {
        text_segment_t *p_new = text_segment_New( p_src->psz_text );

        if( unlikely( !p_new ) )
            break;

        p_new->style = text_style_Duplicate( p_src->style );

        if( p_dst == NULL )
        {
            p_dst = p_dst0 = p_new;
        }
        else
        {
            p_dst->p_next = p_new;
            p_dst = p_dst->p_next;
        }

        p_src = p_src->p_next;
    }

    return p_dst0;
}",209.0,235.0,1.0,1.0,27.0,13,4,18,5,1,2,5,6,0,2,,0,2,2,1,1,text_segment_t
1787,127489,vlc_global_mutex,1,vlc_global_mutex,"void vlc_global_mutex (unsigned,bool)",misc\threads.c,"void vlc_global_mutex (unsigned n, bool acquire)
{
    static vlc_mutex_t locks[] = {
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
        VLC_STATIC_MUTEX,
#ifdef _WIN32
        VLC_STATIC_MUTEX, // For MTA holder
#endif
    };
    static_assert (VLC_MAX_MUTEX == (sizeof (locks) / sizeof (locks[0])),
                   ""Wrong number of global mutexes"");
    assert (n < (sizeof (locks) / sizeof (locks[0])));

    vlc_mutex_t *lock = locks + n;
    if (acquire)
        vlc_mutex_lock (lock);
    else
        vlc_mutex_unlock (lock);
}",32.0,53.0,1.0,1.0,22.0,14,8,17,6,0,1,2,2,0,1,,0,0,4,2,2,void
1788,127575,update_New,1,update_New,update_t update_New (vlc_object_t*),misc\update.c,"update_t *update_New( vlc_object_t *p_this )
{
    update_t *p_update;
    assert( p_this );

    p_update = (update_t *)malloc( sizeof( update_t ) );
    if( !p_update ) return NULL;

    vlc_mutex_init( &p_update->lock );

    p_update->p_libvlc = p_this->obj.libvlc;

    p_update->release.psz_url = NULL;
    p_update->release.psz_desc = NULL;

    p_update->p_download = NULL;
    p_update->p_check = NULL;

    p_update->p_pkey = NULL;
    vlc_gcrypt_init();

    return p_update;
}",104.0,126.0,1.0,1.0,23.0,22,7,19,4,0,8,2,2,0,1,,0,7,2,1,1,update_t
1789,127642,update_Delete,1,update_Delete,void update_Delete (update_t*),missing.c,"void update_Delete(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",260.0,264.0,1.0,1.0,5.0,18,3,16,3,0,15,3,3,2,4,,0,11,2,1,1,void
1790,127712,EmptyRelease,1,EmptyRelease,void EmptyRelease (update_t*),misc\update.c,"static void EmptyRelease( update_t *p_update )
{
    p_update->release.i_major = 0;
    p_update->release.i_minor = 0;
    p_update->release.i_revision = 0;

    FREENULL( p_update->release.psz_url );
    FREENULL( p_update->release.psz_desc );
}",166.0,174.0,1.0,1.0,9.0,13,3,5,1,0,5,1,1,0,0,,0,5,2,1,1,void
1791,127750,GetUpdateFile,1,GetUpdateFile,bool GetUpdateFile (update_t*),misc\update.c,"static bool GetUpdateFile( update_t *p_update )
{
    stream_t *p_stream = NULL;
    char *psz_version_line = NULL;
    char *psz_update_data = NULL;

    p_stream = vlc_stream_NewURL( p_update->p_libvlc, UPDATE_VLC_STATUS_URL );
    if( !p_stream )
    {
        msg_Err( p_update->p_libvlc, ""Failed to open %s for reading"",
                 UPDATE_VLC_STATUS_URL );
        goto error;
    }

    uint64_t i_read;
    if( vlc_stream_GetSize( p_stream, &i_read ) || i_read >= UINT16_MAX )
    {
        msg_Err(p_update->p_libvlc, ""Status file too large"");
        goto error;
    }

    psz_update_data = malloc( i_read + 1 ); /* terminating '\0' */
    if( !psz_update_data )
        goto error;

    if( vlc_stream_Read( p_stream, psz_update_data,
                         i_read ) != (ssize_t)i_read )
    {
        msg_Err( p_update->p_libvlc, ""Couldn't download update file %s"",
                UPDATE_VLC_STATUS_URL );
        goto error;
    }
    psz_update_data[i_read] = '\0';

    vlc...",183.0,382.0,1.0,54.0,200.0,139,16,135,20,0,53,40,26,15,9,,0,51,2,1,1,bool
1792,128354,update_Check,1,update_Check,"void update_Check (update_t*,void,void*)",missing.c,"void update_Check(update_t *u, void (*cb)(void *, bool), void *opaque)
{
    (void) u; (void) cb; (void) opaque;
    vlc_assert_unreachable();
}",266.0,270.0,1.0,1.0,5.0,18,6,20,7,0,9,3,3,1,2,,0,7,6,3,3,void
1793,128477,update_NeedUpgrade,1,update_NeedUpgrade,bool update_NeedUpgrade (update_t*),missing.c,"bool update_NeedUpgrade(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",272.0,276.0,1.0,1.0,5.0,25,10,28,11,0,4,5,7,0,0,,0,4,2,1,1,bool
1794,128590,update_Download,1,update_Download,"void update_Download (update_t*,char*)",missing.c,"void update_Download(update_t *u, const char *dir)
{
    (void) u; (void) dir;
    vlc_assert_unreachable();
}",278.0,282.0,1.0,1.0,5.0,24,7,26,8,0,15,3,3,1,4,,0,12,4,2,2,void
1795,129249,update_GetRelease,1,update_GetRelease,update_release_t update_GetRelease (update_t*),missing.c,"update_release_t *update_GetRelease(update_t *u)
{
    (void) u;
    vlc_assert_unreachable();
}",284.0,288.0,1.0,1.0,5.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,update_release_t
1796,129509,download_key,1,download_key,"public_key_t* download_key (vlc_object_t*,uint8_t*,uint8_t*)",misc\update_crypto.c,"public_key_t *download_key( vlc_object_t *p_this,
                    const uint8_t *p_longid, const uint8_t *p_signature_issuer )
{
    char *psz_url;
    if( asprintf( &psz_url, ""http://download.videolan.org/pub/keys/%.2X%.2X%.2X%.2X%.2X%.2X%.2X%.2X.asc"",
                    p_longid[0], p_longid[1], p_longid[2], p_longid[3],
                    p_longid[4], p_longid[5], p_longid[6], p_longid[7] ) == -1 )
        return NULL;

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_url );
    free( psz_url );
    if( !p_stream )
        return NULL;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return NULL;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );
    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
 ...",932.0,990.0,1.0,1.0,59.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,public_key_t
1797,129516,parse_public_key,1,parse_public_key,"int parse_public_key (uint8_t*,size_t,public_key_t*,uint8_t*)",misc\update_crypto.c,"int parse_public_key( const uint8_t *p_key_data, size_t i_key_len,
                      public_key_t *p_key, const uint8_t *p_sig_issuer )
{
    const uint8_t *pos = p_key_data;
    const uint8_t *max_pos = pos + i_key_len;

    int i_status = 0;
#define PUBLIC_KEY_FOUND    0x01
#define USER_ID_FOUND       0x02
#define SIGNATURE_FOUND     0X04

    uint8_t *p_key_unarmored = NULL;

    p_key->psz_username = NULL;
    p_key->sig.specific.v4.hashed_data = NULL;
    p_key->sig.specific.v4.unhashed_data = NULL;

    if( !( *pos & 0x80 ) )
    {   /* first byte is ASCII, unarmoring */
        p_key_unarmored = (uint8_t*)malloc( i_key_len );
        if( !p_key_unarmored )
            return VLC_ENOMEM;
        int i_len = pgp_unarmor( (char*)p_key_data, i_key_len,
                                 p_key_unarmored, i_key_len );

        if( i_len == 0 )
            goto error;

        pos = p_key_unarmored;
        max_pos = pos + i_len;
    }

    while( pos < max_pos )
    {
        if(...",607.0,722.0,1.0,21.0,116.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
1798,129524,verify_signature,1,verify_signature,"int verify_signature (signature_packet_t*,public_key_packet_t*,uint8_t*)",misc\update_crypto.c,"int verify_signature( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    if (sign->public_key_algo == GCRY_PK_DSA)
        return verify_signature_dsa(sign, p_key, p_hash);
    else if (sign->public_key_algo == GCRY_PK_RSA)
        return verify_signature_rsa(sign, p_key, p_hash);
    else
        return VLC_EGENERIC;
}",589.0,598.0,1.0,1.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
1799,129531,download_signature,1,download_signature,"int download_signature (vlc_object_t*,signature_packet_t*,char*)",misc\update_crypto.c,"int download_signature( vlc_object_t *p_this, signature_packet_t *p_sig,
                        const char *psz_url )
{
    char *psz_sig = (char*) malloc( strlen( psz_url ) + 4 + 1 ); /* "".asc"" + \0 */
    if( !psz_sig )
        return VLC_ENOMEM;

    strcpy( psz_sig, psz_url );
    strcat( psz_sig, "".asc"" );

    stream_t *p_stream = vlc_stream_NewURL( p_this, psz_sig );
    free( psz_sig );

    if( !p_stream )
        return VLC_ENOMEM;

    uint64_t i_size;
    if( vlc_stream_GetSize( p_stream, &i_size ) || i_size > INT_MAX )
    {
        vlc_stream_Delete( p_stream );
        return VLC_EGENERIC;
    }

    msg_Dbg( p_this, ""Downloading signature (%""PRIu64"" bytes)"", i_size );
    uint8_t *p_buf = (uint8_t*)malloc( i_size );
    if( !p_buf )
    {
        vlc_stream_Delete( p_stream );
        return VLC_ENOMEM;
    }

    int i_read = vlc_stream_Read( p_stream, p_buf, (int)i_size );

    vlc_stream_Delete( p_stream );

    if( i_read != (int)i_size )
    {
        msg_Dbg( ...",997.0,1109.0,1.0,8.0,113.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
1800,129538,hash_from_text,1,hash_from_text,"uint8_t* hash_from_text (char*,signature_packet_t*)",misc\update_crypto.c,"uint8_t *hash_from_text( const char *psz_string,
        signature_packet_t *p_sig )
{
    gcry_md_hd_t hd;
    if( gcry_md_open( &hd, p_sig->digest_algo, 0 ) )
        return NULL;

    if( p_sig->type == TEXT_SIGNATURE )
    while( *psz_string )
    {
        size_t i_len = strcspn( psz_string, ""\r\n"" );

        if( i_len )
        {
            gcry_md_write( hd, psz_string, i_len );
            psz_string += i_len;
        }
        gcry_md_putc( hd, '\r' );
        gcry_md_putc( hd, '\n' );

        if( *psz_string == '\r' )
            psz_string++;
        if( *psz_string == '\n' )
            psz_string++;
    }
    else
        gcry_md_write( hd, psz_string, strlen( psz_string ) );

    return hash_finish( hd, p_sig );
}",792.0,821.0,1.0,1.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,uint8_t
1801,129550,hash_from_public_key,1,hash_from_public_key,uint8_t* hash_from_public_key (public_key_t*),misc\update_crypto.c,"uint8_t *hash_from_public_key( public_key_t *p_pkey )
{
    const uint8_t pk_algo = p_pkey->key.algo;
    size_t i_size;
    size_t i_p_len, i_g_len, i_q_len, i_y_len;
    size_t i_n_len, i_e_len;

    if( p_pkey->sig.version != 4 )
        return NULL;

    if( p_pkey->sig.type < GENERIC_KEY_SIGNATURE ||
        p_pkey->sig.type > POSITIVE_KEY_SIGNATURE )
        return NULL;

    if( p_pkey->psz_username == NULL )
        return NULL;

    gcry_error_t error = 0;
    gcry_md_hd_t hd;

    if (pk_algo == GCRY_PK_DSA) {
        i_p_len = mpi_len( p_pkey->key.sig.dsa.p );
        i_g_len = mpi_len( p_pkey->key.sig.dsa.g );
        i_q_len = mpi_len( p_pkey->key.sig.dsa.q );
        i_y_len = mpi_len( p_pkey->key.sig.dsa.y );

        i_size = 6 + 2*4 + i_p_len + i_g_len + i_q_len + i_y_len;
    } else if (pk_algo == GCRY_PK_RSA) {
        i_n_len = mpi_len( p_pkey->key.sig.rsa.n );
        i_e_len = mpi_len( p_pkey->key.sig.rsa.e );

        i_size = 6 + 2*2 + i_n_len + i_e_len;
    ...",847.0,926.0,1.0,1.0,80.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint8_t
1802,129578,scalar_number,1,scalar_number,"uint32_t scalar_number (uint8_t*,int)",misc\update_crypto.c,"static inline uint32_t scalar_number( const uint8_t *p, int header_len )
{
    assert( header_len == 1 || header_len == 2 || header_len == 4 );

    if( header_len == 1 )
        return( p[0] );
    else if( header_len == 2 )
        return( (p[0] << 8) + p[1] );
    else if( header_len == 4 )
        return( ((uint32_t)p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3] );
    else
        abort();
}",57.0,69.0,1.0,1.0,13.0,7,3,5,2,4,0,2,2,0,0,,0,0,4,2,2,uint32_t
1803,129656,mpi_len,1,mpi_len,uint32_t mpi_len (uint8_t*),misc\update_crypto.c,"static uint32_t mpi_len(const uint8_t *mpi)
{
    return (scalar_number(mpi, 2) + 7) / 8;
}",73.0,76.0,1.0,1.0,4.0,2,2,1,1,10,1,1,1,0,1,,0,0,2,1,1,uint32_t
1804,129669,read_mpi,1,read_mpi,"size_t read_mpi (uint8_t*,uint8_t*,size_t,size_t)",misc\update_crypto.c,"static size_t read_mpi(uint8_t *dst, const uint8_t *buf, size_t buflen, size_t bits)
{
    if (buflen < 2)
        return 0;

    size_t n = mpi_len(buf);

    if (n * 8 > bits)
        return 0;

    n += 2;

    if (buflen < n)
        return 0;

    memcpy(dst, buf, n);
    return n;
}",78.0,95.0,1.0,1.0,18.0,6,5,12,5,6,1,4,4,0,1,,0,1,8,4,4,size_t
1805,129714,parse_public_key_packet,1,parse_public_key_packet,"int parse_public_key_packet (public_key_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static int parse_public_key_packet( public_key_packet_t *p_key,
                                    const uint8_t *p_buf, size_t i_packet_len )
{
    if( i_packet_len < 6 )
        return VLC_EGENERIC;

    size_t i_read = 0;

    p_key->version   = *p_buf++; i_read++;
    if( p_key->version != 4 )
        return VLC_EGENERIC;

    /* XXX: warn when timestamp is > date ? */
    memcpy( p_key->timestamp, p_buf, 4 ); p_buf += 4; i_read += 4;

    p_key->algo      = *p_buf++; i_read++;
    if( p_key->algo == GCRY_PK_DSA ) {
        READ_MPI(p_key->sig.dsa.p, 3072);
        READ_MPI(p_key->sig.dsa.q, 256);
        READ_MPI(p_key->sig.dsa.g, 3072);
        READ_MPI(p_key->sig.dsa.y, 3072);
    } else if ( p_key->algo == GCRY_PK_RSA ) {
        READ_MPI(p_key->sig.rsa.n, 4096);
        READ_MPI(p_key->sig.rsa.e, 4096);
    } else
        return VLC_EGENERIC;

    if( i_read == i_packet_len )
        return VLC_SUCCESS;

    /* some extra data eh ? */

error:
    return VLC_EGENERIC;
}",108.0,142.0,1.0,8.0,35.0,64,11,65,12,0,17,5,5,2,4,,0,17,6,3,3,int
1806,130047,parse_signature_v3_packet,1,parse_signature_v3_packet,"size_t parse_signature_v3_packet (signature_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static size_t parse_signature_v3_packet( signature_packet_t *p_sig,
                                      const uint8_t *p_buf, size_t i_sig_len )
{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 19 ) /* signature is at least 19 bytes + the 2 MPIs */
        return 0;

    p_sig->specific.v3.hashed_data_len = *p_buf++; i_read++;
    if( p_sig->specific.v3.hashed_data_len != 5 )
        return 0;

    p_sig->type = *p_buf++; i_read++;

    memcpy( p_sig->specific.v3.timestamp, p_buf, 4 );
    p_buf += 4; i_read += 4;

    memcpy( p_sig->issuer_longid, p_buf, 8 );
    p_buf += 8; i_read += 8;

    p_sig->public_key_algo = *p_buf++; i_read++;

    p_sig->digest_algo = *p_buf++; i_read++;

    p_sig->hash_verification[0] = *p_buf++; i_read++;
    p_sig->hash_verification[1] = *p_buf++; i_read++;

    assert( i_read == 19 );

    return i_read;
}",145.0,175.0,1.0,1.0,31.0,49,10,31,4,1,9,3,3,1,0,,0,9,6,3,3,size_t
1807,130174,parse_signature_v4_packet,1,parse_signature_v4_packet,"size_t parse_signature_v4_packet (signature_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static size_t parse_signature_v4_packet( signature_packet_t *p_sig,
                                      const uint8_t *p_buf, size_t i_sig_len )
{
    size_t i_read = 1; /* we already read the version byte */

    if( i_sig_len < 10 ) /* signature is at least 10 bytes + the 2 MPIs */
        return 0;

    p_sig->type = *p_buf++; i_read++;

    p_sig->public_key_algo = *p_buf++; i_read++;
    if (p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
            return 0;

    p_sig->digest_algo = *p_buf++; i_read++;

    memcpy( p_sig->specific.v4.hashed_data_len, p_buf, 2 );
    p_buf += 2; i_read += 2;

    size_t i_hashed_data_len =
        scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
    i_read += i_hashed_data_len;
    if( i_read + 4 > i_sig_len )
        return 0;

    p_sig->specific.v4.hashed_data = (uint8_t*) malloc( i_hashed_data_len );
    if( !p_sig->specific.v4.hashed_data )
        return 0;
    memcpy( p_sig->specific.v4.hashed_...",182.0,275.0,1.0,1.0,94.0,100,15,76,12,1,22,13,20,4,3,,0,22,6,3,3,size_t
1808,130536,parse_signature_packet,1,parse_signature_packet,"int parse_signature_packet (signature_packet_t*,uint8_t*,size_t)",misc\update_crypto.c,"static int parse_signature_packet( signature_packet_t *p_sig,
                                   const uint8_t *p_buf, size_t i_packet_len )
{
    if( !i_packet_len ) /* 1st sanity check, we need at least the version */
        return VLC_EGENERIC;

    p_sig->version = *p_buf++;

    size_t i_read;
    switch( p_sig->version )
    {
        case 3:
            i_read = parse_signature_v3_packet( p_sig, p_buf, i_packet_len );
            break;
        case 4:
            p_sig->specific.v4.hashed_data = NULL;
            p_sig->specific.v4.unhashed_data = NULL;
            i_read = parse_signature_v4_packet( p_sig, p_buf, i_packet_len );
            break;
        default:
            return VLC_EGENERIC;
    }

    if( i_read == 0 ) /* signature packet parsing has failed */
        goto error;

    if( p_sig->public_key_algo != GCRY_PK_DSA && p_sig->public_key_algo != GCRY_PK_RSA )
        goto error;

    switch( p_sig->type )
    {
        case BINARY_SIGNATURE:
        case TEX...",278.0,346.0,1.0,8.0,69.0,59,13,66,18,0,15,16,9,6,4,,0,15,6,3,3,int
1809,130826,crc_octets,1,crc_octets,"long crc_octets (uint8_t*,size_t)",misc\update_crypto.c,"static long crc_octets( uint8_t *octets, size_t len )
{
    long crc = CRC24_INIT;
    int i;
    while (len--)
    {
        crc ^= (*octets++) << 16;
        for (i = 0; i < 8; i++)
        {
            crc <<= 1;
            if (crc & 0x1000000)
                crc ^= CRC24_POLY;
        }
    }
    return crc & 0xFFFFFFL;
}",356.0,371.0,1.0,15.0,16.0,9,7,10,4,1,0,4,7,0,0,,0,0,4,2,2,long
1810,130878,pgp_unarmor,1,pgp_unarmor,"int pgp_unarmor (char*,size_t,uint8_t*,size_t)",misc\update_crypto.c,"static int pgp_unarmor( const char *p_ibuf, size_t i_ibuf_len,
                        uint8_t *p_obuf, size_t i_obuf_len )
{
    const char *p_ipos = p_ibuf;
    uint8_t *p_opos = p_obuf;
    int i_end = 0;
    int i_header_skipped = 0;

    while( !i_end && p_ipos < p_ibuf + i_ibuf_len && *p_ipos != '=' )
    {
        if( *p_ipos == '\r' || *p_ipos == '\n' )
        {
            p_ipos++;
            continue;
        }

        size_t i_line_len = strcspn( p_ipos, ""\r\n"" );
        if( i_line_len == 0 )
            continue;

        if( !i_header_skipped )
        {
            if( !strncmp( p_ipos, ""-----BEGIN PGP"", 14 ) )
                i_header_skipped = 1;

            p_ipos += i_line_len + 1;
            continue;
        }

        if( !strncmp( p_ipos, ""Version:"", 8 ) )
        {
            p_ipos += i_line_len + 1;
            continue;
        }

        if( p_ipos[i_line_len - 1] == '=' )
        {
            i_end = 1;
        }

        p_opos += vlc_b64_decode...",378.0,435.0,1.0,1.0,58.0,59,16,54,12,0,3,14,17,1,3,,0,2,8,4,4,int
1811,131070,rsa_pkcs1_encode_sig,1,rsa_pkcs1_encode_sig,"int rsa_pkcs1_encode_sig (gcry_mpi_t*,size_t,uint8_t*,int)",misc\update_crypto.c,"static int rsa_pkcs1_encode_sig(gcry_mpi_t *r_result, size_t size,
                                const uint8_t *hash, int algo)
{
    uint8_t asn[100];
    uint8_t frame[4096/8];

    size_t asnlen = sizeof(asn);
    size_t hashlen = gcry_md_get_algo_dlen(algo);

    if (gcry_md_algo_info(algo, GCRYCTL_GET_ASNOID, asn, &asnlen))
        return VLC_EGENERIC;

    if (!hashlen || hashlen + asnlen + 4 > size)
        return VLC_EGENERIC;

    frame[0] = 0;
    frame[1] = 1; /* block type */
    int pad = size - hashlen - asnlen - 3 ;
    memset (&frame[2], 0xff, pad );
    frame[2+pad] = 0;
    memcpy(&frame[3+pad], asn, asnlen);
    memcpy(&frame[3+pad+asnlen], hash, hashlen);

    if (gcry_mpi_scan(r_result, GCRYMPI_FMT_USG, frame, size, &size))
        return VLC_EGENERIC;
    return VLC_SUCCESS;
}",437.0,463.0,1.0,1.0,27.0,30,9,40,13,1,0,4,4,0,0,,0,0,8,4,4,int
1812,131181,verify_signature_rsa,1,verify_signature_rsa,"int verify_signature_rsa (signature_packet_t*,public_key_packet_t*,uint8_t*)",misc\update_crypto.c,"static int verify_signature_rsa( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    int ret = VLC_EGENERIC;
    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(rsa(n %m)(e %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(rsa(s%m)))"";

    size_t erroff;
    gcry_mpi_t n, e, s, hash;
    n = e = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_e_len = mpi_len( p_key->sig.rsa.e );
    size_t i_n_len = mpi_len( p_key->sig.rsa.n );
    if( gcry_mpi_scan( &n, GCRYMPI_FMT_USG, p_key->sig.rsa.n + 2, i_n_len, NULL ) ||
        gcry_mpi_scan( &e, GCRYMPI_FMT_USG, p_key->sig.rsa.e + 2, i_e_len, NULL ) ||
        gcry_sexp_build( &key_sexp, &erroff, key_sexp_s, n, e ) )
        goto out;

    uint8_t *p_s = sign->algo_specific.rsa.s;
 ...",468.0,516.0,1.0,1.0,49.0,49,6,74,23,0,9,16,12,4,4,,0,9,6,3,3,int
1813,131395,verify_signature_dsa,1,verify_signature_dsa,"int verify_signature_dsa (signature_packet_t*,public_key_packet_t*,uint8_t*)",misc\update_crypto.c,"static int verify_signature_dsa( signature_packet_t *sign, public_key_packet_t *p_key,
                      uint8_t *p_hash )
{
    int ret = VLC_EGENERIC;

    /* the data to be verified (a hash) */
    const char *hash_sexp_s = ""(data(flags raw)(value %m))"";
    /* the public key */
    const char *key_sexp_s = ""(public-key(dsa(p %m)(q %m)(g %m)(y %m)))"";
    /* the signature */
    const char *sig_sexp_s = ""(sig-val(dsa(r %m )(s %m )))"";

    size_t erroff;
    gcry_mpi_t p, q, g, y, r, s, hash;
    p = q = g = y = r = s = hash = NULL;
    gcry_sexp_t key_sexp, hash_sexp, sig_sexp;
    key_sexp = hash_sexp = sig_sexp = NULL;

    size_t i_p_len = mpi_len( p_key->sig.dsa.p );
    size_t i_q_len = mpi_len( p_key->sig.dsa.q );
    size_t i_g_len = mpi_len( p_key->sig.dsa.g );
    size_t i_y_len = mpi_len( p_key->sig.dsa.y );
    if( gcry_mpi_scan( &p, GCRYMPI_FMT_USG, p_key->sig.dsa.p + 2, i_p_len, NULL ) ||
        gcry_mpi_scan( &q, GCRYMPI_FMT_USG, p_key->sig.dsa.q + 2, i_q_len,...",521.0,584.0,1.0,1.0,64.0,83,7,116,31,0,15,20,16,4,6,,0,15,6,3,3,int
1814,132182,hash_from_binary_file,1,hash_from_binary_file,"int hash_from_binary_file (char*,gcry_md_hd_t)",misc\update_crypto.c,"static int hash_from_binary_file( const char *psz_file, gcry_md_hd_t hd )
{
    uint8_t buffer[4096];
    size_t i_read;

    FILE *f = vlc_fopen( psz_file, ""r"" );
    if( !f )
        return -1;

    while( ( i_read = fread( buffer, 1, sizeof(buffer), f ) ) > 0 )
        gcry_md_write( hd, buffer, i_read );

    fclose( f );

    return 0;
}",726.0,741.0,1.0,1.0,16.0,6,5,8,4,0,1,3,3,0,1,,0,1,4,2,2,int
1815,132222,hash_finish,1,hash_finish,"uint8_t hash_finish (gcry_md_hd_t,signature_packet_t*)",misc\update_crypto.c,"static uint8_t *hash_finish( gcry_md_hd_t hd, signature_packet_t *p_sig )
{
    if( p_sig->version == 3 )
    {
        gcry_md_putc( hd, p_sig->type );
        gcry_md_write( hd, &p_sig->specific.v3.timestamp, 4 );
    }
    else if( p_sig->version == 4 )
    {
        gcry_md_putc( hd, p_sig->version );
        gcry_md_putc( hd, p_sig->type );
        gcry_md_putc( hd, p_sig->public_key_algo );
        gcry_md_putc( hd, p_sig->digest_algo );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data_len, 2 );
        size_t i_len = scalar_number( p_sig->specific.v4.hashed_data_len, 2 );
        gcry_md_write( hd, p_sig->specific.v4.hashed_data, i_len );

        gcry_md_putc( hd, 0x04 );
        gcry_md_putc( hd, 0xFF );

        i_len += 6; /* hashed data + 6 bytes header */

        gcry_md_putc( hd, (i_len >> 24) & 0xff );
        gcry_md_putc( hd, (i_len >> 16) & 0xff );
        gcry_md_putc( hd, (i_len >> 8) & 0xff );
        gcry_md_putc( hd, (i_len) & 0xff );
    }
    else
...",745.0,786.0,1.0,1.0,42.0,13,6,19,5,0,5,3,3,1,0,,0,5,4,2,2,uint8_t
1816,133452,pf_dup,1,variable_ops_t.pf_dup,void variable_ops_t.pf_dup (vlc_value_t*),misc\variables.c,void (*pf_dup) ( vlc_value_t * );,60.0,60.0,10.0,36.0,1.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
1817,133457,pf_free,1,variable_ops_t.pf_free,void variable_ops_t.pf_free (vlc_value_t*),misc\variables.c,void (*pf_free) ( vlc_value_t * );,61.0,61.0,10.0,37.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1818,133717,varcmp,1,varcmp,"int varcmp (void*,void*)",misc\variables.c,"static int varcmp( const void *a, const void *b )
{
    const variable_t *va = a, *vb = b;

    /* psz_name must be first */
    assert( va == (const void *)&va->psz_name );
    return strcmp( va->psz_name, vb->psz_name );
}",144.0,151.0,1.0,1.0,8.0,8,5,8,4,0,3,1,1,0,0,,0,3,4,2,2,int
1819,133880,CheckValue,1,CheckValue,"void CheckValue (variable_t*,vlc_value_t*)",misc\variables.c,"static void CheckValue(variable_t *var, vlc_value_t *val)
{
    /* Check that our variable is within the bounds */
    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_INTEGER:
            if (val->i_int < var->min.i_int)
               val->i_int = var->min.i_int;
            if (val->i_int > var->max.i_int)
                val->i_int = var->max.i_int;
            if (var->step.i_int != 0 && (val->i_int % var->step.i_int))
            {
                if (val->i_int > 0)
                    val->i_int = (val->i_int + (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
                else
                    val->i_int = (val->i_int - (var->step.i_int / 2))
                                 / var->step.i_int * var->step.i_int;
            }
            break;

        case VLC_VAR_FLOAT:
            if (isless(val->f_float, var->min.f_float))
                val->f_float = var->min.f_float;
            if (isgreater(val->f_floa...",189.0,220.0,1.0,1.0,32.0,67,12,34,5,4,17,11,17,8,0,,0,17,4,2,2,void
1820,134090,WaitUnused,1,WaitUnused,"void WaitUnused (vlc_object_t*,variable_t*)",misc\variables.c,"static void WaitUnused(vlc_object_t *obj, variable_t *var)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    mutex_cleanup_push(&priv->var_lock);
    while (var->b_incallback)
        vlc_cond_wait(&priv->var_wait, &priv->var_lock);
    vlc_cleanup_pop();
}",225.0,233.0,1.0,35.0,9.0,6,5,5,3,5,1,2,2,1,0,,0,1,4,2,2,void
1821,134127,TriggerCallback,1,TriggerCallback,"void TriggerCallback (vlc_object_t*,variable_t*,char*,vlc_value_t)",misc\variables.c,"static void TriggerCallback(vlc_object_t *obj, variable_t *var,
                            const char *name, vlc_value_t prev)
{
    assert(obj != NULL);

    size_t count = var->value_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->value_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_value_callback(obj, name, prev, var->val,
                                     entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",235.0,258.0,1.0,35.0,24.0,25,10,21,9,3,8,3,3,0,3,,0,5,8,4,4,void
1822,134231,TriggerListCallback,1,TriggerListCallback,"void TriggerListCallback (vlc_object_t*,variable_t*,char*,int,vlc_value_t*)",misc\variables.c,"static void TriggerListCallback(vlc_object_t *obj, variable_t *var,
                                const char *name, int action, vlc_value_t *val)
{
    assert(obj != NULL);

    size_t count = var->list_callbacks.i_entries;
    if (count == 0)
        return;

    callback_entry_t *entries = var->list_callbacks.p_entries;
    vlc_object_internals_t *priv = vlc_internals(obj);

    assert(!var->b_incallback);
    var->b_incallback = true;
    vlc_mutex_unlock(&priv->var_lock);

    for (size_t i = 0; i < count; i++)
        entries[i].pf_list_callback(obj, name, action, val,
                                      entries[i].p_data);

    vlc_mutex_lock(&priv->var_lock);
    var->b_incallback = false;
    vlc_cond_broadcast(&priv->var_wait);
}",260.0,283.0,1.0,35.0,24.0,25,10,21,9,3,8,3,3,0,3,,0,5,10,5,5,void
1823,134334,var_Create,1,var_Create,"int var_Create (vlc_object_t*,char*,int)",misc\variables.c,"int var_Create( vlc_object_t *p_this, const char *psz_name, int i_type )
{
    assert( p_this );

    variable_t *p_var = calloc( 1, sizeof( *p_var ) );
    if( p_var == NULL )
        return VLC_ENOMEM;

    p_var->psz_name = strdup( psz_name );
    p_var->psz_text = NULL;

    p_var->i_type = i_type & ~VLC_VAR_DOINHERIT;

    p_var->i_usage = 1;

    p_var->choices.i_count = 0;
    p_var->choices.p_values = NULL;
    p_var->choices_text.i_count = 0;
    p_var->choices_text.p_values = NULL;

    p_var->b_incallback = false;
    p_var->value_callbacks = (callback_table_t){ 0, NULL };

    /* Always initialize the variable, even if it is a list variable; this
     * will lead to errors if the variable is not initialized, but it will
     * not cause crashes in the variable handling. */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_BOOL:
            p_var->ops = &bool_ops;
            p_var->val.b_bool = false;
            break;
        case VLC_VAR_INTEGER:
       ...",298.0,387.0,1.0,37.0,90.0,107,14,89,30,43,40,13,6,0,4,,0,36,6,3,3,int
1824,134679,var_Destroy,1,,"void (vlc_object_t*,char*)",misc\variables.c,"void (var_Destroy)(vlc_object_t *p_this, const char *psz_name)
{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
        msg_Dbg( p_this, ""attempt to destroy nonexistent variable \""%s\"""",
                 psz_name );
    else if( --p_var->i_usage == 0 )
    {
        assert(!p_var->b_incallback);
        tdelete( p_var, &p_priv->var_root, varcmp );
    }
    else
    {
        assert(p_var->i_usage != -1u);
        p_var = NULL;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    if( p_var != NULL )
        Destroy( p_var );
}",398.0,424.0,1.0,37.0,27.0,8,7,15,5,0,3,3,3,0,3,,0,1,4,2,2,void
1825,134760,CleanupVar,1,CleanupVar,void CleanupVar (void*),misc\variables.c,"static void CleanupVar( void *var )
{
    Destroy( var );
}",426.0,429.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1826,134767,var_DestroyAll,1,var_DestroyAll,void var_DestroyAll (vlc_object_t*),misc\variables.c,"void var_DestroyAll( vlc_object_t *obj )
{
    vlc_object_internals_t *priv = vlc_internals( obj );

    tdestroy( priv->var_root, CleanupVar );
    priv->var_root = NULL;
}",431.0,437.0,1.0,35.0,7.0,6,4,6,3,1,0,1,1,0,0,,0,0,2,1,1,void
1827,134794,var_Change,1,var_Change,"int var_Change (vlc_object_t*,char*,int,vlc_value_t*,vlc_value_t*)",misc\variables.c,"int var_Change( vlc_object_t *p_this, const char *psz_name,
                int i_action, vlc_value_t *p_val, vlc_value_t *p_val2 )
{
    int ret = VLC_SUCCESS;
    variable_t *p_var;
    vlc_value_t oldval;
    vlc_value_t newval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    switch( i_action )
    {
        case VLC_VAR_GETMIN:
            *p_val = p_var->min;
            break;
        case VLC_VAR_GETMAX:
            *p_val = p_var->max;
            break;
        case VLC_VAR_SETMINMAX:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->min = *p_val;
            p_var->max = *p_val2;
            break;
        case VLC_VAR_SETSTEP:
            assert(p_var->ops->pf_free == FreeDummy);
            p_var->step = *p_val;
            CheckValue( p_var, &p_var->val );
...",449.0,619.0,1.0,37.0,171.0,230,15,187,34,47,73,33,34,10,14,,0,60,10,5,5,int
1828,135546,var_GetAndSet,1,var_GetAndSet,"int var_GetAndSet (vlc_object_t*,char*,int,vlc_value_t*)",misc\variables.c,"int var_GetAndSet( vlc_object_t *p_this, const char *psz_name, int i_action,
                   vlc_value_t *p_val )
{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );
    assert( p_val );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    WaitUnused( p_this, p_var );

    /* Duplicated data if needed */
    //p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* depending of the action requiered */
    switch( i_action )
    {
    case VLC_VAR_BOOL_TOGGLE:
        assert( ( p_var->i_type & VLC_VAR_BOOL ) == VLC_VAR_BOOL );
        p_var->val.b_bool = !p_var->val.b_bool;
        break;
    case VLC_VAR_INTEGER_ADD:
        assert( ( p_var->i_type & VLC_VAR_INTEGER ) == VLC_VAR_INTEGER );
        p_var->val.i_int += p_val->i_int;
        break;
    case VLC_VAR...",631.0,690.0,1.0,37.0,60.0,47,12,53,17,0,19,7,3,0,7,,0,13,8,4,4,int
1829,135716,var_Type,1,var_Type,"int var_Type (vlc_object_t*,char*)",misc\variables.c,"int var_Type( vlc_object_t *p_this, const char *psz_name )
{
    variable_t *p_var;
    int i_type = 0;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        i_type = p_var->i_type;
        if( p_var->choices.i_count > 0 )
            i_type |= VLC_VAR_HASCHOICE;
    }
    vlc_mutex_unlock( &p_priv->var_lock );

    return i_type;
}",700.0,719.0,1.0,37.0,20.0,13,8,17,7,4,4,3,4,1,2,,0,3,4,2,2,int
1830,135775,var_SetChecked,1,var_SetChecked,"int var_SetChecked (vlc_object_t*,char*,int,vlc_value_t)",misc\variables.c,"int var_SetChecked( vlc_object_t *p_this, const char *psz_name,
                    int expected_type, vlc_value_t val )
{
    variable_t *p_var;
    vlc_value_t oldval;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        return VLC_ENOVAR;
    }

    assert( expected_type == 0 ||
            (p_var->i_type & VLC_VAR_CLASS) == expected_type );
    assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

    WaitUnused( p_this, p_var );

    /* Duplicate data if needed */
    p_var->ops->pf_dup( &val );

    /* Backup needed stuff */
    oldval = p_var->val;

    /* Check boundaries and list */
    CheckValue( p_var, &val );

    /* Set the variable */
    p_var->val = val;

    /* Deal with callbacks */
    TriggerCallback( p_this, p_var, psz_name, oldval );

    /* Free data if needed */
    p_var->ops->pf_free( &oldval );...",722.0,765.0,1.0,37.0,44.0,28,9,36,12,2,14,2,2,0,8,,0,7,8,4,4,int
1831,135881,var_Set,1,var_Set,"int var_Set (vlc_object_t*,char*,vlc_value_t)",misc\variables.c,"int var_Set( vlc_object_t *p_this, const char *psz_name, vlc_value_t val )
{
    return var_SetChecked( p_this, psz_name, 0, val );
}",775.0,778.0,1.0,1.0,4.0,0,0,3,3,4,1,1,1,0,1,,0,0,6,3,3,int
1832,135894,var_GetChecked,1,var_GetChecked,"int var_GetChecked (vlc_object_t*,char*,int,vlc_value_t*)",misc\variables.c,"int var_GetChecked( vlc_object_t *p_this, const char *psz_name,
                    int expected_type, vlc_value_t *p_val )
{
    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var;
    int err = VLC_SUCCESS;

    p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        assert( expected_type == 0 ||
                (p_var->i_type & VLC_VAR_CLASS) == expected_type );
        assert ((p_var->i_type & VLC_VAR_CLASS) != VLC_VAR_VOID);

        /* Really get the variable */
        *p_val = p_var->val;

        /* Duplicate value if needed */
        p_var->ops->pf_dup( p_val );
    }
    else
        err = VLC_ENOVAR;

    vlc_mutex_unlock( &p_priv->var_lock );
    return err;
}",781.0,808.0,1.0,37.0,28.0,21,10,24,11,2,7,2,2,0,3,,0,5,8,4,4,int
1833,135976,var_Get,1,var_Get,"int var_Get (vlc_object_t*,char*,vlc_value_t*)",misc\variables.c,"int var_Get( vlc_object_t *p_this, const char *psz_name, vlc_value_t *p_val )
{
    return var_GetChecked( p_this, psz_name, 0, p_val );
}",819.0,822.0,1.0,1.0,4.0,0,0,3,3,3,1,1,1,0,1,,0,0,6,3,3,int
1834,135993,AddCallback,1,AddCallback,"void AddCallback (vlc_object_t*,char*,callback_entry_t,vlc_callback_type_t)",misc\variables.c,"static void AddCallback( vlc_object_t *p_this, const char *psz_name,
                        callback_entry_t entry, vlc_callback_type_t i_type )
{
    variable_t *p_var;

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot add callback %p to nonexistent variable '%s'"",
                 entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;
    TAB_APPEND(p_table->i_entries, p_table->p_entries, entry);

    vlc_mutex_unlock( &p_priv->var_lock );
}",830.0,858.0,1.0,37.0,29.0,16,7,23,9,2,8,3,3,0,4,,0,5,8,4,4,void
1835,136075,var_AddCallback,1,var_AddCallback,"void var_AddCallback (vlc_object_t*,char*,vlc_callback_t,void*)",misc\variables.c,"void var_AddCallback( vlc_object_t *p_this, const char *psz_name,
                      vlc_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_value_callback);
}",877.0,885.0,1.0,1.0,9.0,4,2,8,6,11,3,1,1,0,1,,0,2,8,4,4,void
1836,136099,DelCallback,1,DelCallback,"void DelCallback (vlc_object_t*,char*,callback_entry_t,vlc_callback_type_t)",misc\variables.c,"static void DelCallback( vlc_object_t *p_this, const char *psz_name,
                         callback_entry_t entry, vlc_callback_type_t i_type )
{
    int i_entry;
    variable_t *p_var;
#ifndef NDEBUG
    bool b_found_similar = false;
#endif

    assert( p_this );

    vlc_object_internals_t *p_priv = vlc_internals( p_this );

    p_var = Lookup( p_this, psz_name );
    if( p_var == NULL )
    {
        vlc_mutex_unlock( &p_priv->var_lock );
        msg_Err( p_this, ""cannot delete callback %p from nonexistent ""
                 ""variable '%s'"", entry.p_callback, psz_name );
        return;
    }

    WaitUnused( p_this, p_var );

    callback_table_t *p_table;
    if (i_type == vlc_value_callback)
        p_table = &p_var->value_callbacks;
    else
        p_table = &p_var->list_callbacks;

    for( i_entry = p_table->i_entries ; i_entry-- ; )
    {
        if( p_table->p_entries[i_entry].p_callback == entry.p_callback
            && p_table->p_entries[i_entry].p_data == entry.p_...",887.0,945.0,1.0,37.0,59.0,34,11,39,13,2,14,8,9,4,5,,0,10,8,4,4,void
1837,136259,var_DelCallback,1,var_DelCallback,"void var_DelCallback (vlc_object_t*,char*,vlc_callback_t,void*)",misc\variables.c,"void var_DelCallback( vlc_object_t *p_this, const char *psz_name,
                      vlc_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_value_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_value_callback);
}",954.0,962.0,1.0,1.0,9.0,4,2,8,6,13,3,1,1,0,1,,0,2,8,4,4,void
1838,136283,var_TriggerCallback,1,var_TriggerCallback,"void var_TriggerCallback (vlc_object_t*,char*)",misc\variables.c,"void var_TriggerCallback( vlc_object_t *p_this, const char *psz_name )
{
    vlc_object_internals_t *p_priv = vlc_internals( p_this );
    variable_t *p_var = Lookup( p_this, psz_name );
    if( p_var != NULL )
    {
        WaitUnused( p_this, p_var );

        /* Deal with callbacks. Tell we're in a callback, release the lock,
         * call stored functions, retake the lock. */
        TriggerCallback( p_this, p_var, psz_name, p_var->val );
    }
    vlc_mutex_unlock( &p_priv->var_lock );
}",971.0,984.0,1.0,37.0,14.0,8,6,15,5,1,5,2,2,0,4,,0,2,4,2,2,void
1839,136327,var_AddListCallback,1,var_AddListCallback,"void var_AddListCallback (vlc_object_t*,char*,vlc_list_callback_t,void*)",misc\variables.c,"void var_AddListCallback( vlc_object_t *p_this, const char *psz_name,
                          vlc_list_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    AddCallback(p_this, psz_name, entry, vlc_list_callback);
}",995.0,1003.0,1.0,1.0,9.0,4,2,8,6,0,3,1,1,0,1,,0,2,8,4,4,void
1840,136351,var_DelListCallback,1,var_DelListCallback,"void var_DelListCallback (vlc_object_t*,char*,vlc_list_callback_t,void*)",misc\variables.c,"void var_DelListCallback( vlc_object_t *p_this, const char *psz_name,
                          vlc_list_callback_t pf_callback, void *p_data )
{
    callback_entry_t entry;
    entry.pf_list_callback = pf_callback;
    entry.p_data = p_data;

    DelCallback(p_this, psz_name, entry, vlc_list_callback);
}",1011.0,1019.0,1.0,1.0,9.0,4,2,8,6,0,3,1,1,0,1,,0,2,8,4,4,void
1841,136581,var_LocationParse,1,var_LocationParse,"int var_LocationParse (vlc_object_t*,char*,char*)",misc\variables.c,"int var_LocationParse (vlc_object_t *obj, const char *mrl, const char *pref)
{
    int ret = VLC_SUCCESS;
    size_t preflen = strlen (pref) + 1;

    assert(mrl != NULL);
    while (*mrl != '\0')
    {
        mrl += strspn (mrl, "":;""); /* skip leading colon(s) */

        size_t len = strcspn (mrl, "":;"");
        char *buf = malloc (preflen + len);

        if (likely(buf != NULL))
        {
            /* NOTE: this does not support the ""no-<varname>"" bool syntax. */
            /* DO NOT use asprintf() here; it won't work! Think again. */
            snprintf (buf, preflen + len, ""%s%s"", pref, mrl);
            var_OptionParse (obj, buf, false);
            free (buf);
        }
        else
            ret = VLC_ENOMEM;
        mrl += len;
    }

    return ret;
}",1138.0,1165.0,1.0,1.0,28.0,13,5,28,10,0,1,3,4,0,1,,0,0,6,3,3,int
1842,136657,var_Inherit,1,var_Inherit,"int var_Inherit (vlc_object_t*,char*,int,vlc_value_t*)",misc\variables.c,"int var_Inherit( vlc_object_t *p_this, const char *psz_name, int i_type,
                 vlc_value_t *p_val )
{
    i_type &= VLC_VAR_CLASS;
    for( vlc_object_t *obj = p_this; obj != NULL; obj = obj->obj.parent )
    {
        if( var_GetChecked( obj, psz_name, i_type, p_val ) == VLC_SUCCESS )
            return VLC_SUCCESS;
    }

    /* else take value from config */
    switch( i_type & VLC_VAR_CLASS )
    {
        case VLC_VAR_STRING:
            p_val->psz_string = config_GetPsz( p_this, psz_name );
            if( !p_val->psz_string ) p_val->psz_string = strdup("""");
            break;
        case VLC_VAR_FLOAT:
            p_val->f_float = config_GetFloat( p_this, psz_name );
            break;
        case VLC_VAR_INTEGER:
            p_val->i_int = config_GetInt( p_this, psz_name );
            break;
        case VLC_VAR_BOOL:
            p_val->b_bool = config_GetInt( p_this, psz_name ) > 0;
            break;
        default:
            vlc_assert_unreachable();
   ...",1173.0,1205.0,1.0,1.0,33.0,17,7,35,14,1,5,9,7,1,5,,0,5,8,4,4,int
1843,137025,DumpVariable,1,DumpVariable,"void DumpVariable (void*,VISIT,int)",misc\variables.c,"static void DumpVariable(const void *data, const VISIT which, const int depth)
{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    const char *typename = ""unknown"";

    switch (var->i_type & VLC_VAR_TYPE)
    {
        case VLC_VAR_VOID:     typename = ""void"";        break;
        case VLC_VAR_BOOL:     typename = ""bool"";        break;
        case VLC_VAR_INTEGER:  typename = ""integer"";     break;
        case VLC_VAR_STRING:   typename = ""string"";      break;
        case VLC_VAR_FLOAT:    typename = ""float"";       break;
        case VLC_VAR_COORDS:   typename = ""coordinates""; break;
        case VLC_VAR_ADDRESS:  typename = ""address"";     break;
        default:               typename = ""unknown"";     break;
    }

    printf("" *-o \""%s\"" (%s"", var->psz_name, typename);
    if (var->psz_text != NULL)
        printf("", %s"", var->psz_text);
    putchar(')');
    if (var->i_type & VLC_VAR_HA...",1312.0,1369.0,1.0,1.0,58.0,41,9,51,20,0,13,23,8,6,0,,0,13,6,3,3,void
1844,137227,DumpVariables,1,DumpVariables,void DumpVariables (vlc_object_t*),misc\variables.c,"void DumpVariables(vlc_object_t *obj)
{
    vlc_mutex_lock(&vlc_internals(obj)->var_lock);
    if (vlc_internals(obj)->var_root == NULL)
        puts("" `-o No variables"");
    else
        twalk(vlc_internals(obj)->var_root, DumpVariable);
    vlc_mutex_unlock(&vlc_internals(obj)->var_lock);
}",1371.0,1379.0,1.0,20.0,9.0,12,5,7,2,1,2,2,2,0,2,,0,0,2,1,1,void
1845,137291,TwalkGetNames,1,TwalkGetNames,"void TwalkGetNames (void*,VISIT,int)",misc\variables.c,"static void TwalkGetNames(const void *data, const VISIT which, const int depth)
{
    if (which != postorder && which != leaf)
        return;
    (void) depth;

    const variable_t *var = *(const variable_t **)data;
    DECL_ARRAY(char *) *names = twalk_ctx;
    char *dup = strdup(var->psz_name);
    if (dup != NULL)
        ARRAY_APPEND(*names, dup);
}",1383.0,1394.0,1.0,1.0,12.0,11,6,13,9,0,1,3,3,0,0,,0,1,6,3,3,void
1846,137335,var_GetAllNames,1,var_GetAllNames,char** var_GetAllNames (vlc_object_t*),misc\variables.c,"char **var_GetAllNames(vlc_object_t *obj)
{
    vlc_object_internals_t *priv = vlc_internals(obj);

    DECL_ARRAY(char *) names;
    ARRAY_INIT(names);

    twalk_ctx = &names;
    vlc_mutex_lock(&priv->var_lock);
    twalk(priv->var_root, TwalkGetNames);
    vlc_mutex_unlock(&priv->var_lock);

    if (names.i_size == 0)
        return NULL;
    ARRAY_APPEND(names, NULL);
    return names.p_elems;
}",1396.0,1412.0,1.0,35.0,17.0,13,7,14,5,2,2,2,2,0,2,,0,0,2,1,1,char**
1847,137447,xml_Create,1,xml_Create,xml_t xml_Create (vlc_object_t*),misc\xml.c,"xml_t *xml_Create( vlc_object_t *p_this )
{
    xml_t *p_xml;

    p_xml = vlc_custom_create( p_this, sizeof( *p_xml ), ""xml"" );

    p_xml->p_module = module_need( p_xml, ""xml"", NULL, false );
    if( !p_xml->p_module )
    {
        vlc_object_release( p_xml );
        msg_Err( p_this, ""XML provider not found"" );
        return NULL;
    }

    return p_xml;
}",39.0,54.0,1.0,12.0,16.0,7,5,13,4,0,3,2,2,0,3,,0,2,2,1,1,xml_t
1848,137490,xml_Delete,1,xml_Delete,void xml_Delete (xml_t*),misc\xml.c,"void xml_Delete( xml_t *p_xml )
{
    module_unneed( p_xml, p_xml->p_module );
    vlc_object_release( p_xml );
}",59.0,63.0,1.0,1.0,5.0,1,1,3,1,0,2,1,1,0,2,,0,0,2,1,1,void
1849,137502,xml_ReaderCreate,1,xml_ReaderCreate,"xml_reader_t xml_ReaderCreate (vlc_object_t*,stream_t*)",misc\xml.c,"xml_reader_t *xml_ReaderCreate(vlc_object_t *obj, stream_t *stream)
{
    xml_reader_t *reader;

    reader = vlc_custom_create(obj, sizeof(*reader), ""xml reader"");

    reader->p_stream = stream;
    reader->p_module = module_need(reader, ""xml reader"", NULL, false);
    if (unlikely(reader->p_module == NULL))
    {
        msg_Err(reader, ""XML reader not found"");
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",73.0,88.0,1.0,13.0,16.0,9,5,16,5,0,3,2,2,0,3,,0,2,4,2,2,xml_reader_t
1850,137552,xml_ReaderDelete,1,xml_ReaderDelete,void xml_ReaderDelete (xml_reader_t*),misc\xml.c,"void xml_ReaderDelete(xml_reader_t *reader)
{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);
    vlc_object_release(reader);
}",95.0,100.0,1.0,1.0,6.0,2,1,4,1,0,2,2,2,0,2,,0,0,2,1,1,void
1851,137569,xml_ReaderReset,1,xml_ReaderReset,"xml_reader_t xml_ReaderReset (xml_reader_t*,stream_t*)",misc\xml.c,"xml_reader_t *xml_ReaderReset(xml_reader_t *reader, stream_t *stream)
{
    if (reader->p_stream)
        module_stop(reader, reader->p_module);

    reader->p_stream = stream;
    if ((stream != NULL) && module_start(reader, reader->p_module))
    {
        vlc_object_release(reader);
        return NULL;
    }
    return reader;
}",115.0,127.0,1.0,1.0,13.0,7,4,12,3,0,3,3,3,1,3,,0,1,4,2,2,xml_reader_t
1852,137870,sout_StreamChainDelete,1,sout_StreamChainDelete,"void sout_StreamChainDelete (sout_stream_t*,sout_stream_t*)",stream_output\stream_output.c,"void sout_StreamChainDelete(sout_stream_t *p_first, sout_stream_t *p_last)
{
    while(p_first != NULL)
    {
        sout_stream_t *p_next = p_first->p_next;

        sout_StreamDelete(p_first);
        if(p_first == p_last)
           break;
        p_first = p_next;
    }
}",762.0,773.0,1.0,1.0,12.0,0,0,2,2,1,0,1,1,0,0,,0,0,4,2,2,void
1853,137881,sout_StreamChainNew,1,sout_StreamChainNew,"sout_stream_t sout_StreamChainNew (sout_instance_t*,char*,sout_stream_t*,sout_stream_t**)",stream_output\stream_output.c,"sout_stream_t *sout_StreamChainNew(sout_instance_t *p_sout, const char *psz_chain,
                                sout_stream_t *p_next, sout_stream_t **pp_last)
{
    if(!psz_chain || !*psz_chain)
    {
        if(pp_last) *pp_last = NULL;
        return p_next;
    }

    char *psz_parser = strdup(psz_chain);
    if(!psz_parser)
        return NULL;

    vlc_array_t cfg, name;
    vlc_array_init(&cfg);
    vlc_array_init(&name);

    /* parse chain */
    while(psz_parser)
    {
        config_chain_t *p_cfg;
        char *psz_name;
        char *psz_rest_chain = config_ChainCreate( &psz_name, &p_cfg, psz_parser );
        free( psz_parser );
        psz_parser = psz_rest_chain;

        vlc_array_append_or_abort(&cfg, p_cfg);
        vlc_array_append_or_abort(&name, psz_name);
    }

    size_t i = vlc_array_count(&name);
    vlc_array_t module;
    vlc_array_init(&module);
    while(i--)
    {
        p_next = sout_StreamNew( p_sout, vlc_array_item_at_index(&name, i),
         ...",829.0,903.0,1.0,1.0,75.0,0,0,4,4,1,0,1,1,0,0,,0,0,8,4,4,sout_stream_t
1854,137967,vlm_MessageDelete,1,vlm_MessageDelete,void vlm_MessageDelete (vlm_message_t*),missing.c,"void vlm_MessageDelete (vlm_message_t *m)
{
    VLC_UNUSED (m);
    vlc_assert_unreachable ();
}",224.0,228.0,1.0,1.0,5.0,0,0,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
1855,137975,vlm_MessageSimpleNew,1,vlm_MessageSimpleNew,vlm_message_t vlm_MessageSimpleNew (char*),missing.c,"vlm_message_t *vlm_MessageSimpleNew (const char *a)
{
    VLC_UNUSED (a);
    return NULL;
}",230.0,234.0,1.0,1.0,5.0,0,0,2,2,1,0,1,1,0,0,,0,0,2,1,1,vlm_message_t
1856,137984,vlm_MessageNew,1,vlm_MessageNew,"vlm_message_t vlm_MessageNew (char*,char*...)",missing.c,"vlm_message_t *vlm_MessageNew (const char *a, const char *fmt, ...)
{
    VLC_UNUSED (a);
    VLC_UNUSED (fmt);
    return vlm_MessageSimpleNew (a);
}",236.0,241.0,1.0,1.0,6.0,0,0,3,2,0,1,1,1,0,1,,0,0,4,2,2,vlm_message_t
1857,138140,vlc_modcap_free,1,vlc_modcap_free,void vlc_modcap_free (void*),modules\bank.c,"static void vlc_modcap_free(void *data)
{
    vlc_modcap_t *cap = data;

    free(cap->modv);
    free(cap->name);
    free(cap);
}",65.0,72.0,1.0,1.0,8.0,3,2,5,2,2,0,1,1,0,0,,0,0,2,1,1,void
1858,138242,vlc_module_store,1,vlc_module_store,int vlc_module_store (module_t*),modules\bank.c,"static int vlc_module_store(module_t *mod)
{
    const char *name = module_get_capability(mod);
    vlc_modcap_t *cap = malloc(sizeof (*cap));
    if (unlikely(cap == NULL))
        return -1;

    cap->name = strdup(name);
    cap->modv = NULL;
    cap->modc = 0;

    if (unlikely(cap->name == NULL))
        goto error;

    vlc_modcap_t **cp = tsearch(cap, &modules.caps_tree, vlc_modcap_cmp);
    if (unlikely(cp == NULL))
        goto error;

    if (*cp != cap)
    {
        vlc_modcap_free(cap);
        cap = *cp;
    }

    module_t **modv = realloc(cap->modv, sizeof (*modv) * (cap->modc + 1));
    if (unlikely(modv == NULL))
        return -1;

    cap->modv = modv;
    cap->modv[cap->modc] = mod;
    cap->modc++;
    return 0;
error:
    vlc_modcap_free(cap);
    return -1;
}",107.0,142.0,1.0,1.0,36.0,40,13,36,7,0,4,8,6,0,3,,0,2,2,1,1,int
1859,138373,vlc_plugin_store,1,vlc_plugin_store,void vlc_plugin_store (vlc_plugin_t*),modules\bank.c,"static void vlc_plugin_store(vlc_plugin_t *lib)
{
    /*vlc_assert_locked (&modules.lock);*/

    lib->next = vlc_plugins;
    vlc_plugins = lib;

    for (module_t *m = lib->module; m != NULL; m = m->next)
        vlc_module_store(m);
}",147.0,156.0,1.0,1.0,10.0,6,3,8,4,2,4,2,2,0,0,,0,4,2,1,1,void
1860,138404,module_InitStatic,1,module_InitStatic,vlc_plugin_t module_InitStatic (vlc_plugin_cb),modules\bank.c,"static vlc_plugin_t *module_InitStatic(vlc_plugin_cb entry)
{
    /* Initializes the statically-linked library */
    vlc_plugin_t *lib = vlc_plugin_describe (entry);
    if (unlikely(lib == NULL))
        return NULL;

#ifdef HAVE_DYNAMIC_PLUGINS
    atomic_init(&lib->loaded, true);
    lib->unloadable = false;
#endif
    return lib;
}",161.0,173.0,1.0,1.0,13.0,2,2,6,3,2,1,2,2,0,1,,0,1,2,1,1,vlc_plugin_t
1861,138426,module_InitStaticModules,1,module_InitStaticModules,void module_InitStaticModules (void),modules\bank.c,"static void module_InitStaticModules(void)
{
    if (!vlc_static_modules)
        return;

    for (unsigned i = 0; vlc_static_modules[i]; i++)
    {
        vlc_plugin_t *lib = module_InitStatic(vlc_static_modules[i]);
        if (likely(lib != NULL))
            vlc_plugin_store(lib);
    }
}",183.0,194.0,1.0,1.0,12.0,6,4,10,4,1,5,4,5,2,2,,0,4,2,1,1,void
1862,138463,module_Map,1,module_Map,"int module_Map (vlc_object_t*,vlc_plugin_t*)",modules\bank.c,"int module_Map(vlc_object_t *obj, vlc_plugin_t *plugin)
{
    (void) obj; (void) plugin;
    return 0;
}",560.0,564.0,1.0,1.0,5.0,2,1,2,2,3,0,1,1,0,0,,0,0,4,2,2,int
1863,138477,module_Unmap,1,module_Unmap,void module_Unmap (vlc_plugin_t*),modules\bank.c,"static void module_Unmap(vlc_plugin_t *plugin)
{
    (void) plugin;
}",566.0,569.0,1.0,1.0,4.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
1864,138485,module_InitBank,1,module_InitBank,void module_InitBank (void),modules\bank.c,"void module_InitBank (void)
{
    vlc_mutex_lock (&modules.lock);

    if (modules.usage == 0)
    {
        /* Fills the module bank structure with the core module infos.
         * This is very useful as it will allow us to consider the core
         * library just as another module, and for instance the configuration
         * options of core will be available in the module bank structure just
         * as for every other module. */
        vlc_plugin_t *plugin = module_InitStatic(vlc_entry__core);
        if (likely(plugin != NULL))
            vlc_plugin_store(plugin);
        config_SortConfig ();
    }
    modules.usage++;

    /* We do retain the module bank lock until the plugins are loaded as well.
     * This is ugly, this staged loading approach is needed: LibVLC gets
     * some configuration parameters relevant to loading the plugins from
     * the core (builtin) module. The module bank becomes shared read-only data
     * once it is ready, so we need to fully seria...",578.0,604.0,1.0,1.0,27.0,8,6,8,4,1,7,3,4,1,4,,0,4,2,1,1,void
1865,138520,module_EndBank,1,module_EndBank,void module_EndBank (bool),modules\bank.c,"void module_EndBank (bool b_plugins)
{
    vlc_plugin_t *libs = NULL;
    block_t *caches = NULL;
    void *caps_tree = NULL;

    /* If plugins were _not_ loaded, then the caller still has the bank lock
     * from module_InitBank(). */
    if( b_plugins )
        vlc_mutex_lock (&modules.lock);
    /*else
        vlc_assert_locked (&modules.lock); not for static mutexes :( */

    assert (modules.usage > 0);
    if (--modules.usage == 0)
    {
        config_UnsortConfig ();
        libs = vlc_plugins;
        caches = modules.caches;
        caps_tree = modules.caps_tree;
        vlc_plugins = NULL;
        modules.caches = NULL;
        modules.caps_tree = NULL;
    }
    vlc_mutex_unlock (&modules.lock);

    tdestroy(caps_tree, vlc_modcap_free);

    while (libs != NULL)
    {
        vlc_plugin_t *lib = libs;

        libs = lib->next;
        module_Unmap(lib);
        vlc_plugin_destroy(lib);
    }

    block_ChainRelease(caches);
}",610.0,648.0,1.0,1.0,39.0,26,8,33,8,2,16,4,4,1,5,,0,11,2,1,1,void
1866,138614,module_LoadPlugins,1,module_LoadPlugins,size_t module_LoadPlugins (vlc_object_t*),modules\bank.c,"size_t module_LoadPlugins (vlc_object_t *obj)
{
    /*vlc_assert_locked (&modules.lock); not for static mutexes :( */

    if (modules.usage == 1)
    {
        module_InitStaticModules ();
#ifdef HAVE_DYNAMIC_PLUGINS
        msg_Dbg (obj, ""searching plug-in modules"");
        AllocateAllPlugins (obj);
#endif
        config_UnsortConfig ();
        config_SortConfig ();

        twalk(modules.caps_tree, vlc_modcap_sort);
    }
    vlc_mutex_unlock (&modules.lock);

    size_t count;
    module_t **list = module_list_get (&count);
    module_list_free (list);
    msg_Dbg (obj, ""plug-ins loaded: %zu modules"", count);
    return count;
}",658.0,681.0,1.0,1.0,24.0,7,4,9,4,1,9,2,2,1,6,,0,4,2,1,1,size_t
1867,138654,module_list_free,1,module_list_free,void module_list_free (module_t**),modules\bank.c,"void module_list_free (module_t **list)
{
    free (list);
}",689.0,692.0,1.0,1.0,4.0,0,0,1,1,6,0,1,1,0,0,,0,0,2,1,1,void
1868,138661,module_list_get,1,module_list_get,module_t module_list_get (size_t*),modules\bank.c,"module_t **module_list_get (size_t *n)
{
    module_t **tab = NULL;
    size_t i = 0;

    assert (n != NULL);

    for (vlc_plugin_t *lib = vlc_plugins; lib != NULL; lib = lib->next)
    {
        module_t **nt = realloc(tab, (i + lib->modules_count) * sizeof (*tab));
        if (unlikely(nt == NULL))
        {
            free (tab);
            *n = 0;
            return NULL;
        }

        tab = nt;
        for (module_t *m = lib->module; m != NULL; m = m->next)
            tab[i++] = m;
    }
    *n = i;
    return tab;
}",700.0,723.0,1.0,1.0,24.0,20,8,28,8,2,1,4,6,0,0,,0,1,2,1,1,module_t
1869,138752,module_list_cap,1,module_list_cap,"ssize_t module_list_cap (module_t***,char*)",modules\bank.c,"ssize_t module_list_cap (module_t ***restrict list, const char *name)
{
    const vlc_modcap_t **cp = tfind(&name, &modules.caps_tree, vlc_modcap_cmp);
    if (cp == NULL)
    {
        *list = NULL;
        return 0;
    }

    const vlc_modcap_t *cap = *cp;
    size_t n = cap->modc;
    module_t **tab = vlc_alloc (n, sizeof (*tab));
    *list = tab;
    if (unlikely(tab == NULL))
        return -1;

    memcpy(tab, cap->modv, sizeof (*tab) * n);
    return n;
}",733.0,751.0,1.0,1.0,19.0,22,9,23,8,2,1,3,3,0,0,,0,1,4,2,2,ssize_t
1870,138892,vlc_module_create,1,vlc_module_create,module_t vlc_module_create (vlc_plugin_t*),modules\entry.c,"module_t *vlc_module_create(vlc_plugin_t *plugin)
{
    module_t *module = malloc (sizeof (*module));
    if (module == NULL)
        return NULL;

    /* NOTE XXX: For backward compatibility with preferences UIs, the first
     * module must stay first. That defines under which module, the
     * configuration items of the plugin belong. The order of the following
     * entries is irrelevant. */
    module_t *parent = plugin->module;
    if (parent == NULL)
    {
        module->next = NULL;
        plugin->module = module;
    }
    else
    {
        module->next = parent->next;
        parent->next = module;
    }

    plugin->modules_count++;
    module->plugin = plugin;

    module->psz_shortname = NULL;
    module->psz_longname = NULL;
    module->psz_help = NULL;
    module->pp_shortcuts = NULL;
    module->i_shortcuts = 0;
    module->psz_capability = NULL;
    module->i_score = (parent != NULL) ? parent->i_score : 1;
    module->activate_name = NULL;
    module->deactivat...",41.0,78.0,1.0,1.0,38.0,40,8,40,4,1,17,3,3,0,0,,0,17,2,1,1,module_t
1871,139019,vlc_module_destroy,1,vlc_module_destroy,void vlc_module_destroy (module_t*),modules\entry.c,"void vlc_module_destroy (module_t *module)
{
    while (module != NULL)
    {
        module_t *next = module->next;

        free(module->pp_shortcuts);
        free(module);
        module = next;
    }
}",83.0,93.0,1.0,1.0,11.0,5,3,8,3,1,2,2,2,0,0,,0,2,2,1,1,void
1872,139044,vlc_plugin_create,1,vlc_plugin_create,vlc_plugin_t vlc_plugin_create (void),modules\entry.c,"vlc_plugin_t *vlc_plugin_create(void)
{
    vlc_plugin_t *plugin = malloc(sizeof (*plugin));
    if (unlikely(plugin == NULL))
        return NULL;

    plugin->modules_count = 0;
    plugin->textdomain = NULL;
    plugin->conf.items = NULL;
    plugin->conf.size = 0;
    plugin->conf.count = 0;
    plugin->conf.booleans = 0;
#ifdef HAVE_DYNAMIC_PLUGINS
    plugin->abspath = NULL;
    atomic_init(&plugin->loaded, false);
    plugin->unloadable = true;
    plugin->handle = NULL;
    plugin->abspath = NULL;
    plugin->path = NULL;
#endif
    plugin->module = NULL;

    return plugin;
}",95.0,118.0,1.0,1.0,24.0,22,6,16,2,1,7,2,2,0,0,,0,7,2,1,1,vlc_plugin_t
1873,139109,vlc_plugin_destroy,1,vlc_plugin_destroy,void vlc_plugin_destroy (vlc_plugin_t*),modules\entry.c,"void vlc_plugin_destroy(vlc_plugin_t *plugin)
{
    assert(plugin != NULL);
#ifdef HAVE_DYNAMIC_PLUGINS
    assert(!plugin->unloadable || !atomic_load(&plugin->loaded));
#endif

    if (plugin->module != NULL)
        vlc_module_destroy(plugin->module);

    config_Free(plugin->conf.items, plugin->conf.size);
#ifdef HAVE_DYNAMIC_PLUGINS
    free(plugin->abspath);
    free(plugin->path);
#endif
    free(plugin);
}",125.0,141.0,1.0,1.0,17.0,8,3,8,2,2,6,2,2,1,2,,0,4,2,1,1,void
1874,139142,vlc_config_create,1,vlc_config_create,"module_config_t vlc_config_create (vlc_plugin_t*,int)",modules\entry.c,"static module_config_t *vlc_config_create(vlc_plugin_t *plugin, int type)
{
    unsigned confsize = plugin->conf.size;
    module_config_t *tab = plugin->conf.items;

    if ((confsize & 0xf) == 0)
    {
        tab = realloc_or_free (tab, (confsize + 17) * sizeof (*tab));
        if (tab == NULL)
            return NULL;

        plugin->conf.items = tab;
    }

    memset (tab + confsize, 0, sizeof (tab[confsize]));
    tab += confsize;
    tab->owner = plugin;

    if (IsConfigIntegerType (type))
    {
        tab->max.i = INT64_MAX;
        tab->min.i = INT64_MIN;
    }
    else if( IsConfigFloatType (type))
    {
        tab->max.f = FLT_MAX;
        tab->min.f = -FLT_MAX;
    }
    tab->i_type = type;

    if (CONFIG_ITEM(type))
    {
        plugin->conf.count++;
        if (type == CONFIG_ITEM_BOOL)
            plugin->conf.booleans++;
    }
    plugin->conf.size++;

    return tab;
}",143.0,182.0,1.0,8.0,40.0,43,13,38,9,1,6,6,8,0,0,,0,6,4,2,2,module_config_t
1875,139296,vlc_plugin_desc_cb,1,vlc_plugin_desc_cb,"int vlc_plugin_desc_cb (void*,void*,int...)",modules\entry.c,"static int vlc_plugin_desc_cb(void *ctx, void *tgt, int propid, ...)
{
    vlc_plugin_t *plugin = ctx;
    module_t *module = tgt;
    module_config_t *item = tgt;
    va_list ap;
    int ret = 0;

    va_start (ap, propid);
    switch (propid)
    {
        case VLC_MODULE_CREATE:
        {
            module_t *super = plugin->module;
            module_t *submodule = vlc_module_create(plugin);
            if (unlikely(submodule == NULL))
            {
                ret = -1;
                break;
            }

            *(va_arg (ap, module_t **)) = submodule;
            if (super == NULL)
                break;

            /* Inheritance. Ugly!! */
            submodule->pp_shortcuts = xmalloc (sizeof ( *submodule->pp_shortcuts ));
            submodule->pp_shortcuts[0] = super->pp_shortcuts[0];
            submodule->i_shortcuts = 1; /* object name */

            submodule->psz_shortname = super->psz_shortname;
            submodule->psz_longname = super->psz_longname;...",190.0,460.0,1.0,42.0,271.0,130,17,150,55,0,25,43,20,0,2,,0,25,6,3,3,int
1876,139920,vlc_plugin_describe,1,vlc_plugin_describe,vlc_plugin_t vlc_plugin_describe (vlc_plugin_cb),modules\entry.c,"vlc_plugin_t *vlc_plugin_describe(vlc_plugin_cb entry)
{
    vlc_plugin_t *plugin = vlc_plugin_create();
    if (unlikely(plugin == NULL))
        return NULL;

    if (entry(vlc_plugin_desc_cb, plugin) != 0)
    {
        vlc_plugin_destroy(plugin); /* partially initialized plug-in... */
        plugin = NULL;
    }
    return plugin;
}",467.0,479.0,1.0,1.0,13.0,4,3,9,2,1,2,3,3,0,2,,0,1,2,1,1,vlc_plugin_t
1877,139954,vlc_plugin_symbol_compare,1,vlc_plugin_symbol_compare,"int vlc_plugin_symbol_compare (void*,void*)",modules\entry.c,"static int vlc_plugin_symbol_compare(const void *a, const void *b)
{
    const struct vlc_plugin_symbol *sa = a , *sb = b;

    return strcmp(sa->name, sb->name);
}",487.0,492.0,1.0,1.0,6.0,4,2,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
1878,139976,vlc_plugin_gpa_cb,1,vlc_plugin_gpa_cb,"int vlc_plugin_gpa_cb (void*,void*,int...)",modules\entry.c,"static int vlc_plugin_gpa_cb(void *ctx, void *tgt, int propid, ...)
{
    void **rootp = ctx;
    const char *name;
    void *addr;

    (void) tgt;

    switch (propid)
    {
        case VLC_MODULE_CB_OPEN:
        case VLC_MODULE_CB_CLOSE:
        case VLC_CONFIG_LIST_CB:
        {
            va_list ap;

            va_start(ap, propid);
            name = va_arg(ap, const char *);
            addr = va_arg(ap, void *);
            va_end (ap);
            break;
        }
        default:
            return 0;
    }

    struct vlc_plugin_symbol *sym = malloc(sizeof (*sym));

    sym->name = name;
    sym->addr = addr;

    struct vlc_plugin_symbol **symp = tsearch(sym, rootp,
                                              vlc_plugin_symbol_compare);
    if (unlikely(symp == NULL))
    {   /* Memory error */
        free(sym);
        return -1;
    }

    if (*symp != sym)
    {   /* Duplicate symbol */
        assert((*symp)->addr == sym->addr);
        free(sym);
    }
    r...",500.0,545.0,1.0,1.0,46.0,18,8,27,13,0,3,5,4,0,0,,0,3,6,3,3,int
1879,140068,vlc_plugin_get_symbols,1,vlc_plugin_get_symbols,void* vlc_plugin_get_symbols (vlc_plugin_cb),modules\entry.c,"static void *vlc_plugin_get_symbols(vlc_plugin_cb entry)
{
    void *root = NULL;

    if (entry(vlc_plugin_gpa_cb, &root))
    {
        tdestroy(root, free);
        return NULL;
    }

    return root;
}",557.0,568.0,1.0,1.0,12.0,2,2,7,3,1,0,2,2,0,0,,0,0,2,1,1,void*
1880,140090,vlc_plugin_free_symbols,1,vlc_plugin_free_symbols,void vlc_plugin_free_symbols (void*),modules\entry.c,"static void vlc_plugin_free_symbols(void *root)
{
    tdestroy(root, free);
}",570.0,573.0,1.0,1.0,4.0,0,0,2,2,1,0,1,1,0,0,,0,0,2,1,1,void
1881,140098,vlc_plugin_get_symbol,1,vlc_plugin_get_symbol,"int vlc_plugin_get_symbol (void*,char*,void**)",modules\entry.c,"static int vlc_plugin_get_symbol(void *root, const char *name,
                                 void **restrict addrp)
{
    if (name == NULL)
    {   /* TODO: use this; do not define ""NULL"" as a name for NULL? */
        *addrp = NULL;
        return 0;
    }

    const struct vlc_plugin_symbol **symp = tfind(&name, &root,
                                                  vlc_plugin_symbol_compare);

    if (symp == NULL)
        return -1;

    *addrp = (*symp)->addr;
    return 0;
}",575.0,592.0,1.0,1.0,18.0,12,6,11,5,3,0,3,3,0,0,,0,0,6,3,3,int
1882,140142,vlc_plugin_resolve,1,vlc_plugin_resolve,"int vlc_plugin_resolve (vlc_plugin_t*,vlc_plugin_cb)",modules\entry.c,"int vlc_plugin_resolve(vlc_plugin_t *plugin, vlc_plugin_cb entry)
{
    void *syms = vlc_plugin_get_symbols(entry);
    int ret = -1;

    /* Resolve modules activate/deactivate callbacks */
    for (module_t *module = plugin->module;
         module != NULL;
         module = module->next)
    {
        if (vlc_plugin_get_symbol(syms, module->activate_name,
                                  &module->pf_activate)
         || vlc_plugin_get_symbol(syms, module->deactivate_name,
                                  &module->pf_deactivate))
            goto error;
    }

    /* Resolve configuration callbacks */
    for (size_t i = 0; i < plugin->conf.size; i++)
    {
        module_config_t *item = plugin->conf.items + i;
        void *cb;

        if (item->list_cb_name == NULL)
            continue;
        if (vlc_plugin_get_symbol(syms, item->list_cb_name, &cb))
            goto error;

        if (IsConfigIntegerType (item->i_type))
            item->list.i_cb = cb;
        else
   ...",594.0,633.0,1.0,12.0,40.0,33,11,32,10,0,8,10,11,4,5,,0,7,4,2,2,int
1883,140321,module_provides,1,module_provides,"bool module_provides (module_t*,char*)",modules\modules.c,"bool module_provides (const module_t *m, const char *cap)
{
    return !strcmp (module_get_capability (m), cap);
}",53.0,56.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,bool
1884,140333,module_get_object,1,module_get_object,const char* module_get_object (module_t*),modules\modules.c,"const char *module_get_object( const module_t *m )
{
    if (unlikely(m->i_shortcuts == 0))
        return ""unnamed"";
    return m->pp_shortcuts[0];
}",64.0,69.0,1.0,1.0,6.0,4,3,2,1,8,2,2,2,1,0,,0,2,2,1,1,const char*
1885,140354,module_get_name,1,module_get_name,"const char* module_get_name (module_t*,bool)",modules\modules.c,"const char *module_get_name( const module_t *m, bool long_name )
{
    if( long_name && ( m->psz_longname != NULL) )
        return m->psz_longname;

    if (m->psz_shortname != NULL)
        return m->psz_shortname;
    return module_get_object (m);
}",78.0,86.0,1.0,1.0,9.0,7,3,8,3,5,5,3,3,2,1,,0,4,4,2,2,const char*
1886,140387,module_get_help,1,module_get_help,const char* module_get_help (module_t*),modules\modules.c,"const char *module_get_help( const module_t *m )
{
    return m->psz_help;
}",94.0,97.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,const char*
1887,140396,module_get_capability,1,module_get_capability,const char* module_get_capability (module_t*),modules\modules.c,"const char *module_get_capability (const module_t *m)
{
    return (m->psz_capability != NULL) ? m->psz_capability : ""none"";
}",105.0,108.0,1.0,1.0,4.0,4,3,3,2,2,2,1,1,0,0,,0,2,2,1,1,const char*
1888,140412,module_get_score,1,module_get_score,int module_get_score (module_t*),modules\modules.c,"int module_get_score( const module_t *m )
{
    return m->i_score;
}",116.0,119.0,1.0,1.0,4.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
1889,140421,module_gettext,1,module_gettext,"const char* module_gettext (module_t*,char*)",modules\modules.c,"const char *module_gettext (const module_t *m, const char *str)
{
    if (unlikely(str == NULL || *str == '\0'))
        return """";
#ifdef ENABLE_NLS
    const char *domain = m->plugin->textdomain;
    return dgettext ((domain != NULL) ? domain : PACKAGE_NAME, str);
#else
    (void)m;
    return str;
#endif
}",128.0,139.0,1.0,1.0,12.0,5,4,5,3,7,0,2,2,0,0,,0,0,4,2,2,const char*
1890,140445,module_start,1,module_start,"int module_start (vlc_object_t*,module_t*)",modules\modules.c,"int module_start (vlc_object_t *obj, const module_t *m)
{
   int (*activate) (vlc_object_t *) = m->pf_activate;

   return (activate != NULL) ? activate (obj) : VLC_SUCCESS;
}",142.0,147.0,1.0,1.0,6.0,2,2,4,4,1,0,1,1,0,0,,0,0,4,2,2,int
1891,140464,module_stop,1,module_stop,"void module_stop (vlc_object_t*,module_t*)",modules\modules.c,"void module_stop (vlc_object_t *obj, const module_t *m)
{
   void (*deactivate) (vlc_object_t *) = m->pf_deactivate;

    if (deactivate != NULL)
        deactivate (obj);
}",150.0,156.0,1.0,1.0,7.0,1,1,3,3,2,0,2,2,0,0,,0,0,4,2,2,void
1892,140482,module_match_name,1,module_match_name,"bool module_match_name (module_t*,char*)",modules\modules.c,"static bool module_match_name (const module_t *m, const char *name)
{
     /* Plugins with zero score must be matched explicitly. */
     if (!strcasecmp (""any"", name))
         return m->i_score > 0;

     for (unsigned i = 0; i < m->i_shortcuts; i++)
          if (!strcasecmp (m->pp_shortcuts[i], name))
              return true;
     return false;
}",158.0,168.0,1.0,1.0,11.0,6,5,6,4,1,2,3,3,1,0,,0,2,4,2,2,bool
1893,140527,module_load,1,module_load,"int module_load (vlc_object_t*,module_t*,vlc_activate_t,va_list)",modules\modules.c,"static int module_load (vlc_object_t *obj, module_t *m,
                        vlc_activate_t init, va_list args)
{
    int ret = VLC_SUCCESS;

    if (module_Map(obj, m->plugin))
        return VLC_EGENERIC;

    if (m->pf_activate != NULL)
    {
        va_list ap;

        va_copy (ap, args);
        ret = init (m->pf_activate, ap);
        va_end (ap);
    }

    if (ret != VLC_SUCCESS)
        vlc_objres_clear(obj);

    return ret;
}",170.0,191.0,1.0,1.0,22.0,7,3,17,8,2,5,4,4,3,2,,0,4,8,4,4,int
1894,140577,vlc_module_load,1,vlc_module_load,"module_t vlc_module_load (vlc_object_t*,char*,char*,bool,vlc_activate_t...)",modules\modules.c,"module_t *vlc_module_load(vlc_object_t *obj, const char *capability,
                          const char *name, bool strict,
                          vlc_activate_t probe, ...)
{
    char *var = NULL;

    if (name == NULL || name[0] == '\0')
        name = ""any"";

    /* Deal with variables */
    if (name[0] == '$')
    {
        var = var_InheritString (obj, name + 1);
        name = (var != NULL) ? var : ""any"";
    }

    /* Find matching modules */
    module_t **mods;
    ssize_t total = module_list_cap (&mods, capability);

    msg_Dbg (obj, ""looking for %s module matching \""%s\"": %zd candidates"",
             capability, name, total);
    if (total <= 0)
    {
        module_list_free (mods);
        msg_Dbg (obj, ""no %s modules"", capability);
        return NULL;
    }

    module_t *module = NULL;
    const bool b_force_backup = obj->obj.force; /* FIXME: remove this */
    va_list args;

    va_start(args, probe);
    while (*name)
    {
        char buf[32];
        siz...",214.0,327.0,1.0,8.0,114.0,64,18,116,21,5,11,24,32,2,11,,0,6,10,5,5,module_t
1895,140895,vlc_module_unload,1,vlc_module_unload,"void vlc_module_unload (vlc_object_t*,module_t*,vlc_deactivate_t...)",modules\modules.c,"void vlc_module_unload(vlc_object_t *obj, module_t *module,
                       vlc_deactivate_t deinit, ...)
{
    if (module->pf_deactivate != NULL)
    {
        va_list ap;

        va_start(ap, deinit);
        deinit(module->pf_deactivate, ap);
        va_end(ap);
    }

    vlc_objres_clear(obj);
}",335.0,348.0,1.0,1.0,14.0,3,2,8,5,4,3,2,2,1,1,,0,2,6,3,3,void
1896,140951,module_need,1,module_need,"module_t module_need (vlc_object_t*,char*,char*,bool)",modules\modules.c,"module_t *module_need(vlc_object_t *obj, const char *cap, const char *name,
                      bool strict)
{
    return vlc_module_load(obj, cap, name, strict, generic_start, obj);
}",368.0,372.0,1.0,1.0,5.0,0,0,5,4,30,1,1,1,0,1,,0,0,8,4,4,module_t
1897,140967,module_unneed,1,module_unneed,"void module_unneed (vlc_object_t*,module_t*)",modules\modules.c,"void module_unneed(vlc_object_t *obj, module_t *module)
{
    msg_Dbg(obj, ""removing module \""%s\"""", module_get_object(module));
    vlc_module_unload(obj, module, generic_stop, obj);
}",375.0,379.0,1.0,1.0,5.0,0,0,5,2,30,2,1,1,0,2,,0,0,4,2,2,void
1898,140983,module_find,1,module_find,module_t module_find (char*),modules\modules.c,"module_t *module_find (const char *name)
{
    size_t count;
    module_t **list = module_list_get (&count);

    assert (name != NULL);

    for (size_t i = 0; i < count; i++)
    {
        module_t *module = list[i];

        if (unlikely(module->i_shortcuts == 0))
            continue;
        if (!strcmp (module->pp_shortcuts[0], name))
        {
            module_list_free (list);
            return module;
        }
    }
    module_list_free (list);
    return NULL;
}",387.0,408.0,1.0,1.0,22.0,12,8,17,6,1,5,5,6,2,3,,0,3,2,1,1,module_t
1899,141044,module_exists,1,module_exists,bool module_exists (char*),modules\modules.c,"bool module_exists (const char * psz_name)
{
    return module_find (psz_name) != NULL;
}",416.0,419.0,1.0,1.0,4.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,bool
1900,141054,module_config_get,1,module_config_get,"module_config_t module_config_get (module_t*,unsigned*)",modules\modules.c,"module_config_t *module_config_get( const module_t *module, unsigned *restrict psize )
{
    const vlc_plugin_t *plugin = module->plugin;

    if (plugin->module != module)
    {   /* For backward compatibility, pretend non-first modules have no
         * configuration items. */
        *psize = 0;
        return NULL;
    }

    unsigned i,j;
    size_t size = plugin->conf.size;
    module_config_t *config = vlc_alloc( size, sizeof( *config ) );

    assert( psize != NULL );
    *psize = 0;

    if( !config )
        return NULL;

    for( i = 0, j = 0; i < size; i++ )
    {
        const module_config_t *item = plugin->conf.items + i;
        if( item->b_internal /* internal option */
         || item->b_removed /* removed option */ )
            continue;

        memcpy( config + j, item, sizeof( *config ) );
        j++;
    }
    *psize = j;

    return config;
}",428.0,462.0,1.0,1.0,35.0,33,12,33,9,0,4,6,6,1,0,,0,4,4,2,2,module_config_t
1901,141353,vlc_gettext,1,vlc_gettext,char* vlc_gettext (char*),modules\textdomain.c,"char *vlc_gettext (const char *msgid)
{
#ifdef ENABLE_NLS
    if (likely(*msgid))
        return dgettext (PACKAGE_NAME, msgid);
#endif
    return (char *)msgid;
}",90.0,97.0,1.0,1.0,8.0,1,1,1,1,10,0,1,1,0,0,,0,0,2,1,1,char*
1902,141401,vlc_getnameinfo,1,vlc_getnameinfo,"int vlc_getnameinfo (sockaddr*,int,char*,int,int*,int)",network\getaddrinfo.c,"int vlc_getnameinfo( const struct sockaddr *sa, int salen,
                     char *host, int hostlen, int *portnum, int flags )
{
    char psz_servbuf[6], *psz_serv;
    int i_servlen, i_val;

    flags |= NI_NUMERICSERV;
    if( portnum != NULL )
    {
        psz_serv = psz_servbuf;
        i_servlen = sizeof( psz_servbuf );
    }
    else
    {
        psz_serv = NULL;
        i_servlen = 0;
    }

    i_val = getnameinfo(sa, salen, host, hostlen, psz_serv, i_servlen, flags);

    if( portnum != NULL )
        *portnum = atoi( psz_serv );

    return i_val;
}",40.0,64.0,1.0,1.0,25.0,8,4,21,12,1,1,3,3,0,1,,0,1,12,6,6,int
1903,141460,vlc_getaddrinfo,1,vlc_getaddrinfo,"int vlc_getaddrinfo (char*,unsigned,addrinfo*,addrinfo**)",network\getaddrinfo.c,"int vlc_getaddrinfo (const char *node, unsigned port,
                     const struct addrinfo *hints, struct addrinfo **res)
{
    char hostbuf[NI_MAXHOST], portbuf[6], *servname;

    /*
     * In VLC, we always use port number as integer rather than strings
     * for historical reasons (and portability).
     */
    if (port != 0)
    {
        if (port > 65535)
            return EAI_SERVICE;
        /* cannot overflow */
        snprintf (portbuf, sizeof (portbuf), ""%u"", port);
        servname = portbuf;
    }
    else
        servname = NULL;

    /*
     * VLC extensions :
     * - accept the empty string as unspecified host (i.e. NULL)
     * - ignore square brackets (for IPv6 numerals)
     */
    if (node != NULL)
    {
        if (node[0] == '[')
        {
            size_t len = strlen (node + 1);
            if ((len <= sizeof (hostbuf)) && (node[len] == ']'))
            {
                assert (len > 0);
                memcpy (hostbuf, node + 1, len - 1);
     ...",78.0,121.0,1.0,1.0,44.0,24,10,32,10,5,1,7,12,0,1,,0,0,8,4,4,int
1904,141585,AuthGetParam,1,AuthGetParam,"char* AuthGetParam (char*,char*)",network\http_auth.c,"static char *AuthGetParam( const char *psz_header, const char *psz_param )
{
    char psz_what[strlen(psz_param)+3];
    sprintf( psz_what, ""%s=\"""", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, '""' );
        if ( !psz_end ) /* Invalid since we should have a closing quote */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",46.0,64.0,1.0,1.0,19.0,5,4,15,4,4,0,3,4,0,0,,0,0,4,2,2,char*
1905,141631,AuthGetParamNoQuotes,1,AuthGetParamNoQuotes,"char* AuthGetParamNoQuotes (char*,char*)",network\http_auth.c,"static char *AuthGetParamNoQuotes( const char *psz_header, const char *psz_param )
{
    char psz_what[strlen(psz_param)+2];
    sprintf( psz_what, ""%s="", psz_param );
    psz_header = strstr( psz_header, psz_what );
    if ( psz_header )
    {
        const char *psz_end;
        psz_header += strlen( psz_what );
        psz_end = strchr( psz_header, ',' );
        /* XXX: Do we need to filter out trailing space between the value and
         * the comma/end of line? */
        if ( !psz_end ) /* Can be valid if this is the last parameter */
            return strdup( psz_header );
        return strndup( psz_header, psz_end - psz_header );
    }
    else
    {
        return NULL;
    }
}",66.0,86.0,1.0,1.0,21.0,5,4,15,4,2,0,3,4,0,0,,0,0,4,2,2,char*
1906,141677,GenerateCnonce,1,GenerateCnonce,char* GenerateCnonce (),network\http_auth.c,"static char *GenerateCnonce()
{
    char ps_random[32];
    struct md5_s md5;

    vlc_rand_bytes( ps_random, sizeof( ps_random ) );

    InitMD5( &md5 );
    AddMD5( &md5, ps_random, sizeof( ps_random ) );
    EndMD5( &md5 );

    return psz_md5_hash( &md5 );
}",88.0,100.0,1.0,1.0,13.0,6,2,8,2,1,4,1,1,0,4,,0,0,0,0,0,char*
1907,141703,AuthDigest,1,AuthDigest,"char* AuthDigest (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*)",network\http_auth.c,"static char *AuthDigest( vlc_object_t *p_this, vlc_http_auth_t *p_auth,
                         const char *psz_method, const char *psz_path,
                         const char *psz_username, const char *psz_password )
{
    char *psz_HA1 = NULL;
    char *psz_HA2 = NULL;
    char *psz_ent = NULL;
    char *psz_result = NULL;
    char psz_inonce[9];
    struct md5_s md5;
    struct md5_s ent;

    if ( p_auth->psz_realm == NULL )
    {
        msg_Warn( p_this, ""Digest Authentication: ""
                  ""Mandatory 'realm' value not available"" );
        goto error;
    }

    /* H(A1) */
    if ( p_auth->psz_HA1 )
    {
        psz_HA1 = strdup( p_auth->psz_HA1 );
        if ( psz_HA1 == NULL )
            goto error;
    }
    else
    {
        InitMD5( &md5 );
        AddMD5( &md5, psz_username, strlen( psz_username ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, p_auth->psz_realm, strlen( p_auth->psz_realm ) );
        AddMD5( &md5, "":"", 1 );
        AddMD5( &md5, ...",102.0,223.0,1.0,1.0,122.0,61,8,77,12,2,23,14,12,0,23,,0,0,12,6,6,char*
1908,142104,vlc_http_auth_ParseWwwAuthenticateHeader,1,vlc_http_auth_ParseWwwAuthenticateHeader,"void vlc_http_auth_ParseWwwAuthenticateHeader (vlc_object_t*,vlc_http_auth_t*,char*)",network\http_auth.c,"void vlc_http_auth_ParseWwwAuthenticateHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_header )
{
    static const char psz_basic_prefix[] = ""Basic "";
    static const char psz_digest_prefix[] = ""Digest "";

    /* FIXME: multiple auth methods can be listed (comma separated) */

    if ( strncasecmp( psz_header, psz_basic_prefix,
                      sizeof( psz_basic_prefix ) - 1 ) == 0 )
    {
        /* 2 Basic Authentication Scheme */
        msg_Dbg( p_this, ""Using Basic Authentication"" );
        psz_header += sizeof( psz_basic_prefix ) - 1;
        p_auth->psz_realm = AuthGetParam( psz_header, ""realm"" );
        if ( p_auth->psz_realm == NULL )
            msg_Warn( p_this, ""Basic Authentication: ""
                      ""Mandatory 'realm' parameter is missing"" );
    }
    else if ( strncasecmp( psz_header, psz_digest_prefix,
                           sizeof( psz_digest_prefix ) - 1 ) == 0 )
    {
        /* 3 Digest Access Authenticati...",231.0,302.0,1.0,1.0,72.0,12,6,13,6,0,1,3,4,0,1,,0,1,6,3,3,void
1909,142304,vlc_http_auth_ParseAuthenticationInfoHeader,1,vlc_http_auth_ParseAuthenticationInfoHeader,"int vlc_http_auth_ParseAuthenticationInfoHeader (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*,char*)",network\http_auth.c,"int vlc_http_auth_ParseAuthenticationInfoHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_header, const char *psz_method, const char *psz_path,
        const char *psz_username, const char *psz_password )
{
    char *psz_nextnonce = AuthGetParam( psz_header, ""nextnonce"" );
    char *psz_qop = AuthGetParamNoQuotes( psz_header, ""qop"" );
    char *psz_rspauth = AuthGetParam( psz_header, ""rspauth"" );
    char *psz_cnonce = AuthGetParam( psz_header, ""cnonce"" );
    char *psz_nc = AuthGetParamNoQuotes( psz_header, ""nc"" );
    char *psz_digest = NULL;
    int i_err = VLC_SUCCESS;
    int i_nonce;

    if ( psz_cnonce )
    {
        if ( strcmp( psz_cnonce, p_auth->psz_cnonce ) != 0 )
        {
            msg_Err( p_this, ""HTTP Digest Access Authentication: server ""
                             ""replied with a different client nonce value."" );
            i_err = VLC_EGENERIC;
            goto error;
        }

        if ( psz_nc )
        {
        ...",309.0,386.0,1.0,1.0,78.0,28,6,62,18,0,6,11,14,0,6,,0,6,14,7,7,int
1910,142472,vlc_http_auth_FormatAuthorizationHeader,1,vlc_http_auth_FormatAuthorizationHeader,"char* vlc_http_auth_FormatAuthorizationHeader (vlc_object_t*,vlc_http_auth_t*,char*,char*,char*,char*)",network\http_auth.c,"char *vlc_http_auth_FormatAuthorizationHeader(
        vlc_object_t *p_this, vlc_http_auth_t *p_auth,
        const char *psz_method, const char *psz_path,
        const char *psz_username, const char *psz_password )
{
    char *psz_result = NULL;
    char *psz_buffer = NULL;
    char *psz_base64 = NULL;
    int i_rc;

    if ( p_auth->psz_nonce )
    {
        /* Digest Access Authentication */
        if ( p_auth->psz_algorithm &&
             strcmp( p_auth->psz_algorithm, ""MD5"" ) != 0 &&
             strcmp( p_auth->psz_algorithm, ""MD5-sess"" ) != 0 )
        {
            msg_Err( p_this, ""Digest Access Authentication: ""
                     ""Unknown algorithm '%s'"", p_auth->psz_algorithm );
            goto error;
        }

        if ( p_auth->psz_qop != NULL || p_auth->psz_cnonce == NULL )
        {
            free( p_auth->psz_cnonce );

            p_auth->psz_cnonce = GenerateCnonce();
            if ( p_auth->psz_cnonce == NULL )
                goto error;
        }

 ...",388.0,487.0,1.0,1.0,100.0,63,10,60,11,0,2,11,13,0,1,,0,2,12,6,6,char*
1911,142833,httpd_ClientDestroy,1,httpd_ClientDestroy,void httpd_ClientDestroy (httpd_client_t*),network\httpd.c,"static void httpd_ClientDestroy(httpd_client_t *cl)
{
    vlc_tls_Close(cl->sock);
    httpd_MsgClean(&cl->answer);
    httpd_MsgClean(&cl->query);

    free(cl->p_buffer);
    free(cl);
}",1214.0,1222.0,1.0,1.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1912,142838,httpd_AppendData,1,httpd_AppendData,"void httpd_AppendData (httpd_stream_t*,uint8_t*,int)",network\httpd.c,"static void httpd_AppendData(httpd_stream_t *stream, uint8_t *p_data, int i_data)
{
    int i_pos = stream->i_buffer_pos % stream->i_buffer_size;
    int i_count = i_data;
    while (i_count > 0) {
        int i_copy = __MIN(i_count, stream->i_buffer_size - i_pos);

        /* Ok, we can't go past the end of our buffer */
        memcpy(&stream->p_buffer[i_pos], p_data, i_copy);

        i_pos = (i_pos + i_copy) % stream->i_buffer_size;
        i_count -= i_copy;
        p_data  += i_copy;
    }

    stream->i_buffer_pos += i_data;
}",804.0,820.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1913,142900,httpd_ReasonFromCode,1,httpd_ReasonFromCode,const char* httpd_ReasonFromCode (unsigned),network\httpd.c,"static const char *httpd_ReasonFromCode(unsigned i_code)
{
    typedef struct
    {
        unsigned   i_code;
        const char psz_reason[36];
    } http_status_info;

    static const http_status_info http_reason[] =
    {
        /*{ 100, ""Continue"" },
          { 101, ""Switching Protocols"" },*/
        { 200, ""OK"" },
        /*{ 201, ""Created"" },
          { 202, ""Accepted"" },
          { 203, ""Non-authoritative information"" },
          { 204, ""No content"" },
          { 205, ""Reset content"" },
          { 206, ""Partial content"" },
          { 250, ""Low on storage space"" },
          { 300, ""Multiple choices"" },*/
        { 301, ""Moved permanently"" },
        /*{ 302, ""Moved temporarily"" },
          { 303, ""See other"" },
          { 304, ""Not modified"" },
          { 305, ""Use proxy"" },
          { 307, ""Temporary redirect"" },
          { 400, ""Bad request"" },*/
        { 401, ""Unauthorized"" },
        /*{ 402, ""Payment Required"" },*/
        { 403, ""Forbidden"" },
        { ...",174.0,255.0,1.0,1.0,82.0,35,11,13,4,3,0,3,3,0,0,,0,0,2,1,1,const char*
1914,143015,httpd_HtmlError,1,httpd_HtmlError,"size_t httpd_HtmlError (char**,int,char*)",network\httpd.c,"static size_t httpd_HtmlError (char **body, int code, const char *url)
{
    const char *errname = httpd_ReasonFromCode (code);
    assert (errname);

    char *url_Encoded = vlc_xml_encode (url ? url : """");

    int res = asprintf (body,
        ""<?xml version=\""1.0\"" encoding=\""ascii\"" ?>\n""
        ""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Strict//EN\""""
        "" \""http://www.w3.org/TR/xhtml10/DTD/xhtml10strict.dtd\"">\n""
        ""<html lang=\""en\"">\n""
        ""<head>\n""
        ""<title>%s</title>\n""
        ""</head>\n""
        ""<body>\n""
        ""<h1>%d %s%s%s%s</h1>\n""
        ""<hr />\n""
        ""<a href=\""http://www.videolan.org\"">VideoLAN</a>\n""
        ""</body>\n""
        ""</html>\n"", errname, code, errname,
        (url_Encoded ? "" ("" : """"), (url_Encoded ? url_Encoded : """"), (url_Encoded ? "")"" : """"));

    free (url_Encoded);

    if (res == -1) {
        *body = NULL;
        return 0;
    }

    return (size_t)res;
}",257.0,288.0,1.0,1.0,32.0,12,6,20,7,2,2,2,2,0,2,,0,2,6,3,3,size_t
1915,143087,httpd_FileCallBack,1,httpd_FileCallBack,"int httpd_FileCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int
httpd_FileCallBack(httpd_callback_sys_t *p_sys, httpd_client_t *cl,
                    httpd_message_t *answer, const httpd_message_t *query)
{
    httpd_file_t *file = (httpd_file_t*)p_sys;
    uint8_t **pp_body, *p_body;
    int *pi_body, i_body;

    if (!answer || !query )
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;

    answer->i_status = 200;

    httpd_MsgAdd(answer, ""Content-type"",  ""%s"", file->mime);
    httpd_MsgAdd(answer, ""Cache-Control"", ""%s"", ""no-cache"");

    if (query->i_type != HTTPD_MSG_HEAD) {
        pp_body = &answer->p_body;
        pi_body = &answer->i_body;
    } else {
        /* The file still needs to be executed. */
        p_body = NULL;
        i_body = 0;
        pp_body = &p_body;
        pi_body = &i_body;
    }

    if (query->i_type == HTTPD_MSG_POST) {
        /* msg_Warn not supported */
    }

    uint8_t *psz_args = query->psz_args;
    file...",302.0,350.0,1.0,1.0,49.0,34,8,39,15,0,9,6,6,2,5,,0,5,8,4,4,int
1916,143237,httpd_FileNew,1,httpd_FileNew,"httpd_file_t httpd_FileNew (httpd_host_t*,char*,char*,char*,char*,httpd_file_callback_t,httpd_file_sys_t*)",network\httpd.c,"httpd_file_t *httpd_FileNew(httpd_host_t *host,
                             const char *psz_url, const char *psz_mime,
                             const char *psz_user, const char *psz_password,
                             httpd_file_callback_t pf_fill,
                             httpd_file_sys_t *p_sys)
{
    const char *mime = psz_mime;
    if (mime == NULL || mime[0] == '\0')
        mime = vlc_mime_Ext2Mime(psz_url);

    size_t mimelen = strlen(mime);
    httpd_file_t *file = malloc(sizeof(*file) + mimelen);
    if (unlikely(file == NULL))
        return NULL;

    file->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!file->url) {
        free(file);
        return NULL;
    }

    file->pf_fill = pf_fill;
    file->p_sys   = p_sys;
    memcpy(file->mime, mime, mimelen + 1);

    httpd_UrlCatch(file->url, HTTPD_MSG_HEAD, httpd_FileCallBack,
                    (httpd_callback_sys_t*)file);
    httpd_UrlCatch(file->url, HTTPD_MSG_GET,  httpd_FileCallBack...",352.0,385.0,1.0,1.0,34.0,28,10,40,14,0,13,4,4,1,5,,0,10,14,7,7,httpd_file_t
1917,143355,httpd_FileDelete,1,httpd_FileDelete,httpd_file_sys_t httpd_FileDelete (httpd_file_t*),network\httpd.c,"httpd_file_sys_t *httpd_FileDelete(httpd_file_t *file)
{
    httpd_file_sys_t *p_sys = file->p_sys;

    httpd_UrlDelete(file->url);
    free(file);
    return p_sys;
}",387.0,394.0,1.0,1.0,8.0,3,2,5,2,0,3,1,1,0,1,,0,2,2,1,1,httpd_file_sys_t
1918,143378,httpd_HandlerCallBack,1,httpd_HandlerCallBack,"int httpd_HandlerCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int
httpd_HandlerCallBack(httpd_callback_sys_t *p_sys, httpd_client_t *cl,
                       httpd_message_t *answer, const httpd_message_t *query)
{
    httpd_handler_t *handler = (httpd_handler_t*)p_sys;
    char psz_remote_addr[NI_MAXNUMERICHOST];

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_NONE;
    answer->i_type   = HTTPD_MSG_ANSWER;

    /* We do it ourselves, thanks */
    answer->i_status = 0;

    if (!httpd_ClientIP(cl, psz_remote_addr, NULL))
        *psz_remote_addr = '\0';

    uint8_t *psz_args = query->psz_args;
    handler->pf_fill(handler->p_sys, handler, query->psz_url, psz_args,
                      query->i_type, query->p_body, query->i_body,
                      psz_remote_addr, NULL,
                      &answer->p_body, &answer->i_body);

    if (query->i_type == HTTPD_MSG_HEAD) {
        char *p = (char *)answer->p_body;

        /* Looks for end of header (i.e. one empty line) */
        while (...",408.0,476.0,1.0,1.0,69.0,86,13,73,18,0,4,10,17,1,2,,0,4,8,4,4,int
1919,143681,httpd_HandlerNew,1,httpd_HandlerNew,"httpd_handler_t httpd_HandlerNew (httpd_host_t*,char*,char*,char*,httpd_handler_callback_t,void*)",network\httpd.c,"httpd_handler_t *httpd_HandlerNew(httpd_host_t *host, const char *psz_url,
                                  const char *psz_user,
                                  const char *psz_password,
                                  httpd_handler_callback_t pf_fill,
                                  void *p_sys)
{
    httpd_handler_t *handler = malloc(sizeof(*handler));
    if (!handler)
        return NULL;

    handler->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!handler->url) {
        free(handler);
        return NULL;
    }

    handler->pf_fill = pf_fill;
    handler->p_sys   = p_sys;

    httpd_UrlCatch(handler->url, HTTPD_MSG_HEAD, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_GET,  httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);
    httpd_UrlCatch(handler->url, HTTPD_MSG_POST, httpd_HandlerCallBack,
                    (httpd_callback_sys_t*)handler);

    r...",478.0,505.0,1.0,1.0,28.0,18,6,26,11,0,11,3,3,1,4,,0,8,12,6,6,httpd_handler_t
1920,143762,httpd_HandlerDelete,1,httpd_HandlerDelete,void* httpd_HandlerDelete (httpd_handler_t*),network\httpd.c,"void *httpd_HandlerDelete(httpd_handler_t *handler)
{
    void *p_sys = handler->p_sys;
    httpd_UrlDelete(handler->url);
    free(handler);
    return p_sys;
}",507.0,513.0,1.0,1.0,7.0,3,2,5,2,0,3,1,1,0,1,,0,2,2,1,1,void*
1921,143790,httpd_RedirectCallBack,1,httpd_RedirectCallBack,"int httpd_RedirectCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int httpd_RedirectCallBack(httpd_callback_sys_t *p_sys,
                                   httpd_client_t *cl, httpd_message_t *answer,
                                   const httpd_message_t *query)
{
    httpd_redirect_t *rdir = (httpd_redirect_t*)p_sys;
    char *p_body;
    (void)cl;

    if (!answer || !query)
        return VLC_SUCCESS;

    answer->i_proto  = HTTPD_PROTO_HTTP;
    answer->i_version= 1;
    answer->i_type   = HTTPD_MSG_ANSWER;
    answer->i_status = 301;

    answer->i_body = httpd_HtmlError (&p_body, 301, rdir->dst);
    answer->p_body = (unsigned char *)p_body;

    /* XXX check if it's ok or we need to set an absolute url */
    httpd_MsgAdd(answer, ""Location"",  ""%s"", rdir->dst);

    httpd_MsgAdd(answer, ""Content-Length"", ""%d"", answer->i_body);

    if (httpd_MsgGet(&cl->query, ""Connection"") != NULL)
        httpd_MsgAdd(answer, ""Connection"", ""close"");

    return VLC_SUCCESS;
}",524.0,552.0,1.0,1.0,29.0,26,7,25,10,0,8,3,3,2,5,,0,5,8,4,4,int
1922,143885,httpd_RedirectNew,1,httpd_RedirectNew,"httpd_redirect_t httpd_RedirectNew (httpd_host_t*,char*,char*)",network\httpd.c,"httpd_redirect_t *httpd_RedirectNew(httpd_host_t *host, const char *psz_url_dst,
                                     const char *psz_url_src)
{
    size_t dstlen = strlen(psz_url_dst);

    httpd_redirect_t *rdir = malloc(sizeof(*rdir) + dstlen);
    if (unlikely(rdir == NULL))
        return NULL;

    rdir->url = httpd_UrlNew(host, psz_url_src, NULL, NULL);
    if (!rdir->url) {
        free(rdir);
        return NULL;
    }
    memcpy(rdir->dst, psz_url_dst, dstlen + 1);

    /* Redirect apply for all HTTP request and RTSP DESCRIBE resquest */
    httpd_UrlCatch(rdir->url, HTTPD_MSG_HEAD, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_GET, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_POST, httpd_RedirectCallBack,
                    (httpd_callback_sys_t*)rdir);
    httpd_UrlCatch(rdir->url, HTTPD_MSG_DESCRIBE, httpd_RedirectCallBack,
          ...",554.0,581.0,1.0,1.0,28.0,20,8,32,10,0,12,3,3,1,5,,0,8,6,3,3,httpd_redirect_t
1923,143979,httpd_RedirectDelete,1,httpd_RedirectDelete,void httpd_RedirectDelete (httpd_redirect_t*),network\httpd.c,"void httpd_RedirectDelete(httpd_redirect_t *rdir)
{
    httpd_UrlDelete(rdir->url);
    free(rdir);
}",582.0,586.0,1.0,1.0,5.0,1,1,2,1,0,2,1,1,0,1,,0,1,2,1,1,void
1924,144004,httpd_StreamCallBack,1,httpd_StreamCallBack,"int httpd_StreamCallBack (httpd_callback_sys_t*,httpd_client_t*,httpd_message_t*,httpd_message_t*)",network\httpd.c,"static int httpd_StreamCallBack(httpd_callback_sys_t *p_sys,
                                 httpd_client_t *cl, httpd_message_t *answer,
                                 const httpd_message_t *query)
{
    httpd_stream_t *stream = (httpd_stream_t*)p_sys;

    if (!answer || !query || !cl)
        return VLC_SUCCESS;

    if (answer->i_body_offset > 0) {
        int     i_pos;

        if (answer->i_body_offset >= stream->i_buffer_pos)
            return VLC_EGENERIC;    /* wait, no data available */

        if (cl->i_keyframe_wait_to_pass >= 0) {
            if (stream->i_last_keyframe_seen_pos <= cl->i_keyframe_wait_to_pass)
                /* still waiting for the next keyframe */
                return VLC_EGENERIC;

            /* seek to the new keyframe */
            answer->i_body_offset = stream->i_last_keyframe_seen_pos;
            cl->i_keyframe_wait_to_pass = -1;
        }

        if (answer->i_body_offset + stream->i_buffer_size < stream->i_buffer_pos)
            ...",621.0,744.0,1.0,22.0,124.0,60,16,50,11,0,13,8,14,6,0,,0,13,8,4,4,int
1925,144510,httpd_StreamNew,1,httpd_StreamNew,"httpd_stream_t httpd_StreamNew (httpd_host_t*,char*,char*,char*,char*)",network\httpd.c,"httpd_stream_t *httpd_StreamNew(httpd_host_t *host,
                                 const char *psz_url, const char *psz_mime,
                                 const char *psz_user, const char *psz_password)
{
    httpd_stream_t *stream = malloc(sizeof(*stream));
    if (!stream)
        return NULL;

    stream->url = httpd_UrlNew(host, psz_url, psz_user, psz_password);
    if (!stream->url) {
        free(stream);
        return NULL;
    }

    vlc_mutex_init(&stream->lock);
    if (psz_mime == NULL || psz_mime[0] == '\0')
        psz_mime = vlc_mime_Ext2Mime(psz_url);
    stream->psz_mime = xstrdup(psz_mime);

    stream->i_header = 0;
    stream->p_header = NULL;
    stream->i_buffer_size = 5000000;    /* 5 Mo per stream */
    stream->p_buffer = xmalloc(stream->i_buffer_size);
    /* We set to 1 to make life simpler
     * (this way i_body_offset can never be 0) */
    stream->i_buffer_pos = 1;
    stream->i_buffer_last_pos = 1;
    stream->b_has_keyframes = false;
    stream...",746.0,786.0,1.0,1.0,41.0,44,10,44,11,0,24,4,4,1,6,,0,20,10,5,5,httpd_stream_t
1926,144659,httpd_StreamHeader,1,httpd_StreamHeader,"int httpd_StreamHeader (httpd_stream_t*,uint8_t*,int)",network\httpd.c,"int httpd_StreamHeader(httpd_stream_t *stream, uint8_t *p_data, int i_data)
{
    vlc_mutex_lock(&stream->lock);
    free(stream->p_header);
    stream->p_header = NULL;

    stream->i_header = i_data;
    if (i_data > 0) {
        stream->p_header = xmalloc(i_data);
        memcpy(stream->p_header, p_data, i_data);
    }
    vlc_mutex_unlock(&stream->lock);

    return VLC_SUCCESS;
}",788.0,802.0,1.0,1.0,15.0,13,4,14,5,0,9,2,2,0,2,,0,7,6,3,3,int
1927,144774,httpd_StreamSend,1,httpd_StreamSend,"int httpd_StreamSend (httpd_stream_t*,block_t*)",network\httpd.c,"int httpd_StreamSend(httpd_stream_t *stream, const block_t *p_block)
{
    if (!p_block || !p_block->p_buffer)
        return VLC_SUCCESS;

    vlc_mutex_lock(&stream->lock);

    /* save this pointer (to be used by new connection) */
    stream->i_buffer_last_pos = stream->i_buffer_pos;

    if (p_block->i_flags & BLOCK_FLAG_TYPE_I) {
        stream->b_has_keyframes = true;
        stream->i_last_keyframe_seen_pos = stream->i_buffer_pos;
    }

    httpd_AppendData(stream, p_block->p_buffer, p_block->i_buffer);

    vlc_mutex_unlock(&stream->lock);
    return VLC_SUCCESS;
}",822.0,841.0,1.0,1.0,20.0,20,6,17,5,0,10,3,3,0,3,,0,7,4,2,2,int
1928,144837,httpd_StreamDelete,1,httpd_StreamDelete,void httpd_StreamDelete (httpd_stream_t*),network\httpd.c,"void httpd_StreamDelete(httpd_stream_t *stream)
{
    httpd_UrlDelete(stream->url);
    for (size_t i = 0; i < stream->i_http_headers; i++) {
        free(stream->p_http_headers[i].name);
        free(stream->p_http_headers[i].value);
    }
    free(stream->p_http_headers);
    vlc_mutex_destroy(&stream->lock);
    free(stream->psz_mime);
    free(stream->p_header);
    free(stream->p_buffer);
    free(stream);
}",843.0,856.0,1.0,1.0,14.0,16,6,14,2,0,11,2,2,1,2,,0,9,2,1,1,void
1929,144904,httpd_HostCreate,1,httpd_HostCreate,"httpd_host_t* httpd_HostCreate (vlc_object_t*,char*,char*,vlc_tls_creds_t*,unsigned)",network\httpd.c,"static httpd_host_t *httpd_HostCreate(vlc_object_t *p_this,
                                       const char *hostvar,
                                       const char *portvar,
                                       vlc_tls_creds_t *p_tls,
                                       unsigned timeout_sec)
{
    httpd_host_t *host;
    unsigned port = var_InheritInteger(p_this, portvar);

    /* to be sure to avoid multiple creation */
    vlc_mutex_lock(&httpd.mutex);

    /* verify if it already exist */
    for (int i = 0; i < httpd.i_host; i++) {
        host = httpd.host[i];

        /* cannot mix TLS and non-TLS hosts */
        if (host->port != port
         || (host->p_tls != NULL) != (p_tls != NULL))
            continue;

        /* Increase existing matching host reference count.
         * The reference count is written under both the global httpd and the
         * host lock. It is read with either or both locks held. The global
         * lock is always acquired first. */...",910.0,1002.0,1.0,27.0,93.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,httpd_host_t
1930,144913,vlc_http_HostNew,1,vlc_http_HostNew,httpd_host_t vlc_http_HostNew (vlc_object_t*),network\httpd.c,"httpd_host_t *vlc_http_HostNew(vlc_object_t *p_this)
{
    return httpd_HostCreate(p_this, ""http-host"", ""http-port"", NULL, 10);
}",867.0,870.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,httpd_host_t
1931,144925,vlc_https_HostNew,1,vlc_https_HostNew,httpd_host_t vlc_https_HostNew (vlc_object_t*),network\httpd.c,"httpd_host_t *vlc_https_HostNew(vlc_object_t *obj)
{
    char *cert = var_InheritString(obj, ""http-cert"");
    if (!cert) {
        msg_Err(obj, ""HTTP/TLS certificate not specified!"");
        return NULL;
    }

    char *key = var_InheritString(obj, ""http-key"");
    vlc_tls_creds_t *tls = vlc_tls_ServerCreate(obj, cert, key);

    if (!tls) {
        msg_Err(obj, ""HTTP/TLS certificate error (%s and %s)"",
                 cert, key ? key : cert);
        free(key);
        free(cert);
        return NULL;
    }
    free(key);
    free(cert);

    return httpd_HostCreate(obj, ""http-host"", ""https-port"", tls, 10);
}",872.0,894.0,1.0,1.0,23.0,6,3,24,5,0,2,3,3,0,2,,0,1,2,1,1,httpd_host_t
1932,144987,vlc_rtsp_HostNew,1,vlc_rtsp_HostNew,httpd_host_t vlc_rtsp_HostNew (vlc_object_t*),network\httpd.c,"httpd_host_t *vlc_rtsp_HostNew(vlc_object_t *p_this)
{
    unsigned timeout = var_InheritInteger(p_this, ""rtsp-timeout"");
    return httpd_HostCreate(p_this, ""rtsp-host"", ""rtsp-port"", NULL, timeout);
}",896.0,900.0,1.0,1.0,5.0,1,1,5,3,0,1,1,1,0,1,,0,0,2,1,1,httpd_host_t
1933,145290,httpd_HostDelete,1,httpd_HostDelete,void httpd_HostDelete (httpd_host_t*),network\httpd.c,"void httpd_HostDelete(httpd_host_t *host)
{
    bool delete = false;

    vlc_mutex_lock(&httpd.mutex);

    vlc_mutex_lock(&host->lock);
    host->i_ref--;
    if (host->i_ref == 0)
        delete = true;
    vlc_mutex_unlock(&host->lock);
    if (!delete) {
        /* still used */
        vlc_mutex_unlock(&httpd.mutex);
        msg_Dbg(host, ""httpd_HostDelete: host still in use"");
        return;
    }
    TAB_REMOVE(httpd.i_host, httpd.host, host);

    vlc_cancel(host->thread);
    vlc_join(host->thread, NULL);

    msg_Dbg(host, ""HTTP host removed"");

    for (int i = 0; i < host->i_url; i++)
        msg_Err(host, ""url still registered: %s"", host->url[i]->psz_url);

    for (int i = 0; i < host->i_client; i++) {
        msg_Warn(host, ""client still connected"");
        httpd_ClientDestroy(host->client[i]);
    }
    TAB_CLEAN(host->i_client, host->client);

    vlc_tls_Delete(host->p_tls);
    net_ListenClose(host->fds);
    vlc_cond_destroy(&host->wait);
    vlc_mutex_destroy...",1005.0,1044.0,1.0,1.0,40.0,37,9,36,7,0,38,5,5,3,13,,0,25,2,1,1,void
1934,145439,httpd_UrlNew,1,httpd_UrlNew,"httpd_url_t httpd_UrlNew (httpd_host_t*,char*,char*,char*)",network\httpd.c,"httpd_url_t *httpd_UrlNew(httpd_host_t *host, const char *psz_url,
                           const char *psz_user, const char *psz_password)
{
    httpd_url_t *url;

    assert(psz_url);

    vlc_mutex_lock(&host->lock);
    for (int i = 0; i < host->i_url; i++)
        if (!strcmp(psz_url, host->url[i]->psz_url)) {
            msg_Warn(host, ""cannot add '%s' (url already defined)"", psz_url);
            vlc_mutex_unlock(&host->lock);
            return NULL;
        }

    url = xmalloc(sizeof(httpd_url_t));
    url->host = host;

    vlc_mutex_init(&url->lock);
    url->psz_url = xstrdup(psz_url);
    url->psz_user = xstrdup(psz_user ? psz_user : """");
    url->psz_password = xstrdup(psz_password ? psz_password : """");
    for (int i = 0; i < HTTPD_MSG_MAX; i++) {
        url->catch[i].cb = NULL;
        url->catch[i].p_sys = NULL;
    }

    TAB_APPEND(host->i_url, host->url, url);
    vlc_cond_signal(&host->wait);
    vlc_mutex_unlock(&host->lock);

    return url;
}",1047.0,1079.0,1.0,1.0,33.0,35,8,33,9,4,15,3,3,1,4,,0,11,8,4,4,httpd_url_t
1935,145580,httpd_UrlCatch,1,httpd_UrlCatch,"int httpd_UrlCatch (httpd_url_t*,int,httpd_callback_t,httpd_callback_sys_t*)",network\httpd.c,"int httpd_UrlCatch(httpd_url_t *url, int i_msg, httpd_callback_t cb,
                    httpd_callback_sys_t *p_sys)
{
    vlc_mutex_lock(&url->lock);
    url->catch[i_msg].cb   = cb;
    url->catch[i_msg].p_sys= p_sys;
    vlc_mutex_unlock(&url->lock);

    return VLC_SUCCESS;
}",1082.0,1091.0,1.0,1.0,10.0,12,5,9,5,13,4,1,1,0,2,,0,2,8,4,4,int
1936,145618,httpd_UrlDelete,1,httpd_UrlDelete,void httpd_UrlDelete (httpd_url_t*),network\httpd.c,"void httpd_UrlDelete(httpd_url_t *url)
{
    httpd_host_t *host = url->host;

    vlc_mutex_lock(&host->lock);
    TAB_REMOVE(host->i_url, host->url, url);

    vlc_mutex_destroy(&url->lock);
    free(url->psz_url);
    free(url->psz_user);
    free(url->psz_password);

    for (int i = 0; i < host->i_client; i++) {
        httpd_client_t *client = host->client[i];

        if (client->url != url)
            continue;

        /* TODO complete it */
        msg_Warn(host, ""force closing connections"");
        TAB_REMOVE(host->i_client, host->client, client);
        httpd_ClientDestroy(client);
        i--;
    }
    free(url);
    vlc_mutex_unlock(&host->lock);
}",1094.0,1120.0,1.0,1.0,27.0,24,7,26,4,4,18,4,4,2,4,,0,14,2,1,1,void
1937,145711,httpd_MsgInit,1,httpd_MsgInit,void httpd_MsgInit (httpd_message_t*),network\httpd.c,"static void httpd_MsgInit(httpd_message_t *msg)
{
    msg->cl         = NULL;
    msg->i_type     = HTTPD_MSG_NONE;
    msg->i_proto    = HTTPD_PROTO_NONE;
    msg->i_version  = -1; /* FIXME */

    msg->i_status   = 0;

    msg->psz_url    = NULL;
    msg->psz_args   = NULL;

    msg->i_headers  = 0;
    msg->p_headers  = NULL;

    msg->i_body_offset = 0;
    msg->i_body        = 0;
    msg->p_body        = NULL;
}",1122.0,1140.0,1.0,1.0,19.0,25,3,19,4,6,0,1,1,0,0,,0,0,2,1,1,void
1938,145777,httpd_MsgClean,1,httpd_MsgClean,void httpd_MsgClean (httpd_message_t*),network\httpd.c,"static void httpd_MsgClean(httpd_message_t *msg)
{
    free(msg->psz_url);
    free(msg->psz_args);
    for (size_t i = 0; i < msg->i_headers; i++) {
        free(msg->p_headers[i].name);
        free(msg->p_headers[i].value);
    }
    free(msg->p_headers);
    free(msg->p_body);
    httpd_MsgInit(msg);
}",1142.0,1153.0,1.0,1.0,12.0,13,5,12,2,3,1,2,2,0,1,,0,0,2,1,1,void
1939,145830,httpd_MsgGet,1,httpd_MsgGet,"const char* httpd_MsgGet (httpd_message_t*,char*)",network\httpd.c,"const char *httpd_MsgGet(const httpd_message_t *msg, const char *name)
{
    for (size_t i = 0; i < msg->i_headers; i++)
        if (!strcasecmp(msg->p_headers[i].name, name))
            return msg->p_headers[i].value;
    return NULL;
}",1155.0,1161.0,1.0,1.0,7.0,3,3,4,3,9,0,2,2,0,0,,0,0,4,2,2,const char*
1940,145871,httpd_MsgAdd,1,httpd_MsgAdd,"void httpd_MsgAdd (httpd_message_t*,char*,char*...)",network\httpd.c,"void httpd_MsgAdd(httpd_message_t *msg, const char *name, const char *psz_value, ...)
{
    httpd_header *p_tmp = realloc(msg->p_headers, sizeof(httpd_header) * (msg->i_headers + 1));
    if (!p_tmp)
        return;

    msg->p_headers = p_tmp;

    httpd_header *h = &msg->p_headers[msg->i_headers];
    h->name = strdup(name);
    if (!h->name)
        return;

    h->value = NULL;

    va_list args;
    va_start(args, psz_value);
    int ret = us_vasprintf(&h->value, psz_value, args);
    va_end(args);

    if (ret == -1) {
        free(h->name);
        return;
    }

    msg->i_headers++;
}",1163.0,1189.0,1.0,1.0,27.0,28,11,25,9,19,1,4,4,0,1,,0,1,6,3,3,void
1941,145963,httpd_ClientInit,1,httpd_ClientInit,void httpd_ClientInit (httpd_client_t*),network\httpd.c,"static void httpd_ClientInit(httpd_client_t *cl)
{
    cl->i_state = HTTPD_CLIENT_RECEIVING;
    cl->i_buffer_size = HTTPD_CL_BUFSIZE;
    cl->i_buffer = 0;
    cl->p_buffer = xmalloc(cl->i_buffer_size);
    cl->i_keyframe_wait_to_pass = -1;
    cl->b_stream_mode = false;

    httpd_MsgInit(&cl->query);
    httpd_MsgInit(&cl->answer);
}",1191.0,1202.0,1.0,24.0,12.0,18,4,11,3,1,11,1,1,0,2,,0,9,2,1,1,void
1942,146014,httpd_ClientIP,1,httpd_ClientIP,"char* httpd_ClientIP (httpd_client_t*,char*,int*)",network\httpd.c,"char* httpd_ClientIP(const httpd_client_t *cl, char *ip, int *port)
{
    return net_GetPeerAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1204.0,1207.0,1.0,1.0,4.0,2,2,5,4,1,1,1,1,0,0,,0,1,6,3,3,char*
1943,146032,httpd_ServerIP,1,httpd_ServerIP,"char* httpd_ServerIP (httpd_client_t*,char*,int*)",network\httpd.c,"char* httpd_ServerIP(const httpd_client_t *cl, char *ip, int *port)
{
    return net_GetSockAddress(vlc_tls_GetFD(cl->sock), ip, port) ? NULL : ip;
}",1209.0,1212.0,1.0,1.0,4.0,2,2,5,4,0,1,1,1,0,0,,0,1,6,3,3,char*
1944,146075,httpd_ClientNew,1,httpd_ClientNew,httpd_client_t httpd_ClientNew (vlc_tls_t*),network\httpd.c,"static httpd_client_t *httpd_ClientNew(vlc_tls_t *sock)
{
    httpd_client_t *cl = malloc(sizeof(httpd_client_t));

    if (!cl) return NULL;

    cl->i_ref   = 0;
    cl->sock    = sock;
    cl->url     = NULL;

    httpd_ClientInit(cl);
    return cl;
}",1224.0,1236.0,1.0,1.0,13.0,9,4,11,4,1,4,2,2,0,1,,0,3,2,1,1,httpd_client_t
1945,146111,httpd_NetRecv,1,httpd_NetRecv,"ssize_t httpd_NetRecv (httpd_client_t*,uint8_t*,size_t)",network\httpd.c,"static
ssize_t httpd_NetRecv (httpd_client_t *cl, uint8_t *p, size_t i_len)
{
    vlc_tls_t *sock = cl->sock;
    struct iovec iov = { .iov_base = p, .iov_len = i_len };
    return sock->readv(sock, &iov, 1);
}",1238.0,1244.0,1.0,1.0,7.0,8,4,10,7,1,1,1,1,0,0,,0,1,6,3,3,ssize_t
1946,146145,httpd_NetSend,1,httpd_NetSend,"ssize_t httpd_NetSend (httpd_client_t*,uint8_t*,size_t)",network\httpd.c,"static
ssize_t httpd_NetSend (httpd_client_t *cl, const uint8_t *p, size_t i_len)
{
    vlc_tls_t *sock = cl->sock;
    const struct iovec iov = { .iov_base = (void *)p, .iov_len = i_len };
    return sock->writev(sock, &iov, 1);
}",1246.0,1252.0,1.0,1.0,7.0,9,5,10,7,1,1,1,1,0,0,,0,1,6,3,3,ssize_t
1947,146239,httpd_ClientRecv,1,httpd_ClientRecv,int httpd_ClientRecv (httpd_client_t*),network\httpd.c,"static int httpd_ClientRecv(httpd_client_t *cl)
{
    int i_len;

    /* ignore leading whites */
    if (cl->query.i_proto == HTTPD_PROTO_NONE && cl->i_buffer == 0) {
        unsigned char c;

        i_len = httpd_NetRecv(cl, &c, 1);

        if (i_len > 0 && !strchr(""\r\n\t "", c)) {
            cl->p_buffer[0] = c;
            cl->i_buffer++;
        }
    } else if (cl->query.i_proto == HTTPD_PROTO_NONE) {
        /* enough to see if it's Interleaved RTP over RTSP or RTSP/HTTP */
        i_len = httpd_NetRecv(cl, &cl->p_buffer[cl->i_buffer],
                               7 - cl->i_buffer);
        if (i_len > 0)
            cl->i_buffer += i_len;

        /* The smallest legal request is 7 bytes (""GET /\r\n""),
         * this is the maximum we can ask at this point. */
        if (cl->i_buffer >= 7) {
            if (!memcmp(cl->p_buffer, ""HTTP/1."", 7)) {
                cl->query.i_proto = HTTPD_PROTO_HTTP;
                cl->query.i_type  = HTTPD_MSG_ANSWER;
            } el...",1277.0,1565.0,1.0,1.0,289.0,38,13,26,9,1,12,8,13,5,1,,0,12,2,1,1,int
1948,147420,httpd_ClientSend,1,httpd_ClientSend,int httpd_ClientSend (httpd_client_t*),network\httpd.c,"static int httpd_ClientSend(httpd_client_t *cl)
{
    int i_len;

    if (cl->i_buffer < 0) {
        /* We need to create the header */
        int i_size = 0;
        char *p;
        const char *psz_status = httpd_ReasonFromCode(cl->answer.i_status);

        i_size = strlen(""HTTP/1."") + 10 + 10 + strlen(psz_status) + 5;
        for (size_t i = 0; i < cl->answer.i_headers; i++)
            i_size += strlen(cl->answer.p_headers[i].name) + 2 +
                      strlen(cl->answer.p_headers[i].value) + 2;

        if (cl->i_buffer_size < i_size) {
            cl->i_buffer_size = i_size;
            free(cl->p_buffer);
            cl->p_buffer = xmalloc(i_size);
        }
        p = (char *)cl->p_buffer;

        p += sprintf(p, ""%s.%u %d %s\r\n"",
                      cl->answer.i_proto ==  HTTPD_PROTO_HTTP ? ""HTTP/1"" : ""RTSP/1"",
                      cl->answer.i_version,
                      cl->answer.i_status, psz_status);
        for (size_t i = 0; i < cl->answer.i_headers...",1567.0,1646.0,1.0,1.0,80.0,114,16,75,13,1,45,10,16,9,3,,0,44,2,1,1,int
1949,147801,httpd_ClientTlsHandshake,1,httpd_ClientTlsHandshake,"void httpd_ClientTlsHandshake (httpd_host_t*,httpd_client_t*)",network\httpd.c,"static void httpd_ClientTlsHandshake(httpd_host_t *host, httpd_client_t *cl)
{
    switch (vlc_tls_SessionHandshake(host->p_tls, cl->sock))
    {
        case -1: cl->i_state = HTTPD_CLIENT_DEAD;       break;
        case 0:  cl->i_state = HTTPD_CLIENT_RECEIVING;  break;
        case 1:  cl->i_state = HTTPD_CLIENT_TLS_HS_IN;  break;
        case 2:  cl->i_state = HTTPD_CLIENT_TLS_HS_OUT; break;
    }
}",1648.0,1657.0,1.0,1.0,10.0,11,3,10,6,1,6,6,2,2,0,,0,6,4,2,2,void
1950,147849,httpdAuthOk,1,httpdAuthOk,"bool httpdAuthOk (char*,char*,char*)",network\httpd.c,"static bool httpdAuthOk(const char *user, const char *pass, const char *b64)
{
    if (!*user && !*pass)
        return true;

    if (!b64)
        return false;

    if (strncasecmp(b64, ""BASIC"", 5))
        return false;

    b64 += 5;
    while (*b64 == ' ')
        b64++;

    char *given_user = vlc_b64_decode(b64);
    if (!given_user)
        return false;

    char *given_pass = NULL;
    given_pass = strchr (given_user, ':');
    if (!given_pass)
        goto auth_failed;

    *given_pass++ = '\0';

    if (strcmp (given_user, user))
        goto auth_failed;

    if (strcmp (given_pass, pass))
        goto auth_failed;

    free(given_user);
    return true;

auth_failed:
    free(given_user);
    return false;
}",1659.0,1697.0,1.0,1.0,39.0,17,7,27,8,1,1,12,9,0,1,,0,1,6,3,3,bool
1951,147942,httpdLoop,1,httpdLoop,void httpdLoop (httpd_host_t*),network\httpd.c,"static void httpdLoop(httpd_host_t *host)
{
    struct pollfd ufd[host->nfd + host->i_client];
    unsigned nfd;
    for (nfd = 0; nfd < host->nfd; nfd++) {
        ufd[nfd].fd = host->fds[nfd];
        ufd[nfd].events = POLLIN;
        ufd[nfd].revents = 0;
    }

    /* add all socket that should be read/write and close dead connection */
    while (host->i_url <= 0) {
        mutex_cleanup_push(&host->lock);
        vlc_cond_wait(&host->wait, &host->lock);
        vlc_cleanup_pop();
    }

    mtime_t now = mdate();
    int delay = -1;
    int canc = vlc_savecancel();
    for (int i_client = 0; i_client < host->i_client; i_client++) {
        httpd_client_t *cl = host->client[i_client];
        int val = -1;

        switch (cl->i_state) {
            case HTTPD_CLIENT_RECEIVING:
                val = httpd_ClientRecv(cl);
                break;
            case HTTPD_CLIENT_SENDING:
                val = httpd_ClientSend(cl);
                break;
            case HTTPD_CLIENT_...",1699.0,2048.0,1.0,1.0,350.0,329,22,316,49,0,133,63,136,26,46,,0,106,2,1,1,void
1952,149213,httpd_StreamSetHTTPHeaders,1,httpd_StreamSetHTTPHeaders,"int httpd_StreamSetHTTPHeaders (httpd_stream_t*,httpd_header*,size_t)",network\httpd.c,"int httpd_StreamSetHTTPHeaders(httpd_stream_t * p_stream,
                               const httpd_header *p_headers, size_t i_headers)
{
    if (!p_stream)
        return VLC_EGENERIC;

    vlc_mutex_lock(&p_stream->lock);
    if (p_stream->p_http_headers) {
        for (size_t i = 0; i < p_stream->i_http_headers; i++) {
            free(p_stream->p_http_headers[i].name);
            free(p_stream->p_http_headers[i].value);
        }
        free(p_stream->p_http_headers);
        p_stream->p_http_headers = NULL;
        p_stream->i_http_headers = 0;
    }

    if (!p_headers || !i_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_SUCCESS;
    }

    p_stream->p_http_headers = vlc_alloc(i_headers, sizeof(httpd_header));
    if (!p_stream->p_http_headers) {
        vlc_mutex_unlock(&p_stream->lock);
        return VLC_ENOMEM;
    }

    size_t j = 0;
    for (size_t i = 0; i < i_headers; i++) {
        if (unlikely(!p_headers[i].name || !p_headers[i].value))...",2061.0,2108.0,1.0,1.0,48.0,72,10,54,10,0,24,11,12,5,4,,0,20,6,3,3,int
1953,149454,rootwrap_bind,1,rootwrap_bind,"int rootwrap_bind (int,int,int,sockaddr*,size_t)",network\rootbind.c,"int rootwrap_bind (int family, int socktype, int protocol,
                   const struct sockaddr *addr, size_t alen)
{
    /* can't use libvlc */
    static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    struct sockaddr_storage ss;
    int fd, sock = -1;

    const char *sockenv = getenv (""VLC_ROOTWRAP_SOCK"");
    if (sockenv != NULL)
        sock = atoi (sockenv);
    if (sock == -1)
    {
        errno = EACCES;
        return -1;
    }

    switch (family)
    {
        case AF_INET:
            if (alen < sizeof (struct sockaddr_in))
            {
                errno = EINVAL;
                return -1;
            }
            break;

#ifdef AF_INET6
        case AF_INET6:
            if (alen < sizeof (struct sockaddr_in6))
            {
                errno = EINVAL;
                return -1;
            }
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            return -1;
    }

    if (family != addr->sa_family)
    {
       ...",115.0,184.0,1.0,38.0,70.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
1954,149463,net_Socket,1,net_Socket,"int net_Socket (vlc_object_t*,int,int,int)",network\io.c,"int net_Socket (vlc_object_t *p_this, int family, int socktype,
                int protocol)
{
    int fd = vlc_socket (family, socktype, protocol, true);
    if (fd == -1)
    {
        if (net_errno != EAFNOSUPPORT)
            msg_Err (p_this, ""cannot create socket: %s"",
                     vlc_strerror_c(net_errno));
        return -1;
    }

    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

#ifdef IPV6_V6ONLY
    /*
     * Accepts only IPv6 connections on IPv6 sockets.
     * If possible, we should open two sockets, but it is not always possible.
     */
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_V6ONLY, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)
# ifndef IPV6_PROTECTION_LEVEL
#  warning Please update your C library headers.
#  define IPV6_PROTECTION_LEVEL 23
#  define PROTECTION_LEVEL_UNRESTRICTED 10
# endif
    if (family == AF_INET6)
        setsockopt (fd, IPPROTO_IPV6, IPV6_PROTECTION_LEVEL,
             ...",55.0,103.0,1.0,1.0,49.0,9,8,15,11,5,2,3,4,0,2,,0,1,8,4,4,int
1955,149511,net_Listen,1,net_Listen,"int* net_Listen (vlc_object_t*,char*,int,int,int)",network\io.c,"int *net_Listen (vlc_object_t *p_this, const char *psz_host,
                 int i_port, int type, int protocol)
{
    struct addrinfo hints = {
        .ai_socktype = type,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    msg_Dbg (p_this, ""net: listening to %s port %d"",
             (psz_host != NULL) ? psz_host : ""*"", i_port);

    int i_val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (i_val)
    {
        msg_Err (p_this, ""Cannot resolve %s port %d : %s"",
                 (psz_host != NULL) ? psz_host : """", i_port,
                 gai_strerror (i_val));
        return NULL;
    }

    int *sockv = NULL;
    unsigned sockc = 0;

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (p_this, ""socket error: %s"", vlc_s...",106.0,225.0,1.0,1.0,120.0,54,15,90,27,0,6,15,23,1,6,,0,4,10,5,5,int*
1956,149772,net_Read,1,,"ssize_t (vlc_object_t*,int,void*,size_t)",network\io.c,"ssize_t (net_Read)(vlc_object_t *restrict obj, int fd,
                   void *restrict buf, size_t len)
{
    size_t rd = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_recv_i11e(fd, buf, len, 0);
        if (val < 0)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;
#ifdef _WIN32
            else if (WSAGetLastError() == WSAEMSGSIZE) /* datagram too big */
            {
                msg_Warn(obj, ""read truncated to %zu bytes"", len);
                val = len;
            }
#endif
            else
            {
                msg_Err(obj, ""read error: %s"", vlc_strerror_c(errno));
                return rd ? (ssize_t)rd : -1;
            }
        }

        rd += val;

        if (val == 0)
            break;

        assert(len >= (size_t)val);
        len -= val;
        buf = ((char *)buf) + val;
    }
    while (len...",233.0,278.0,1.0,1.0,46.0,17,11,24,8,0,2,8,11,1,2,,0,1,8,4,4,ssize_t
1957,149864,net_Write,1,,"ssize_t (vlc_object_t*,int,void*,size_t)",network\io.c,"ssize_t (net_Write)(vlc_object_t *obj, int fd, const void *buf, size_t len)
{
    size_t written = 0;

    do
    {
        if (vlc_killed())
        {
            vlc_testcancel();
            errno = EINTR;
            return -1;
        }

        ssize_t val = vlc_send_i11e (fd, buf, len, MSG_NOSIGNAL);
        if (val == -1)
        {
            if (errno == EINTR || errno == EAGAIN)
                continue;

            msg_Err(obj, ""write error: %s"", vlc_strerror_c(errno));
            return written ? (ssize_t)written : -1;
        }

        if (val == 0)
            break;

        written += val;
        assert(len >= (size_t)val);
        len -= val;
        buf = ((const char *)buf) + val;
    }
    while (len > 0);

    return written;
}",289.0,323.0,1.0,1.0,35.0,21,11,29,10,0,3,8,11,1,3,,0,1,8,4,4,ssize_t
1958,149955,net_Gets,1,net_Gets,"char* net_Gets (vlc_object_t*,int)",network\io.c,"char *net_Gets(vlc_object_t *obj, int fd)
{
    char *buf = NULL;
    size_t size = 0, len = 0;

    for (;;)
    {
        if (len == size)
        {
            if (unlikely(size >= (1 << 16)))
            {
                errno = EMSGSIZE;
                goto error; /* put sane buffer size limit */
            }

            char *newbuf = realloc(buf, size + 1024);
            if (unlikely(newbuf == NULL))
                goto error;
            buf = newbuf;
            size += 1024;
        }
        assert(len < size);

        ssize_t val = vlc_recv_i11e(fd, buf + len, size - len, MSG_PEEK);
        if (val <= 0)
            goto error;

        char *end = memchr(buf + len, '\n', val);
        if (end != NULL)
            val = (end + 1) - (buf + len);
        if (recv(fd, buf + len, val, 0) != val)
            goto error;
        len += val;
        if (end != NULL)
            break;
    }

    assert(len > 0);
    buf[--len] = '\0';
    if (len > 0 && buf[--len] == '\r...",336.0,382.0,1.0,1.0,47.0,39,14,59,12,0,1,15,19,0,1,,0,0,4,2,2,char*
1959,150119,net_Printf,1,net_Printf,"ssize_t net_Printf (vlc_object_t*,int,char*...)",network\io.c,"ssize_t net_Printf( vlc_object_t *p_this, int fd, const char *psz_fmt, ... )
{
    int i_ret;
    va_list args;
    va_start( args, psz_fmt );
    i_ret = net_vaPrintf( p_this, fd, psz_fmt, args );
    va_end( args );

    return i_ret;
}",385.0,394.0,1.0,1.0,10.0,1,1,9,5,0,1,1,1,0,1,,0,1,6,3,3,ssize_t
1960,150142,net_vaPrintf,1,net_vaPrintf,"ssize_t net_vaPrintf (vlc_object_t*,int,char*,va_list)",network\io.c,"ssize_t net_vaPrintf( vlc_object_t *p_this, int fd,
                      const char *psz_fmt, va_list args )
{
    char    *psz;
    int      i_ret;

    int i_size = vasprintf( &psz, psz_fmt, args );
    if( i_size == -1 )
        return -1;
    i_ret = net_Write( p_this, fd, psz, i_size ) < i_size
        ? -1 : i_size;
    free( psz );

    return i_ret;
}",397.0,411.0,1.0,1.0,15.0,9,6,14,7,1,0,2,2,0,0,,0,0,8,4,4,ssize_t
1961,150544,SocksHandshakeTCP,1,SocksHandshakeTCP,"int SocksHandshakeTCP (vlc_object_t*,int,int,char*,char*,char*,int)",network\tcp.c,"static int SocksHandshakeTCP( vlc_object_t *p_obj,
                              int fd,
                              int i_socks_version,
                              const char *psz_user, const char *psz_passwd,
                              const char *psz_host, int i_port )
{
    uint8_t buffer[128+2*256];

    if( i_socks_version != 4 && i_socks_version != 5 )
    {
        msg_Warn( p_obj, ""invalid socks protocol version %d"", i_socks_version );
        i_socks_version = 5;
    }

    if( i_socks_version == 5 &&
        SocksNegotiate( p_obj, fd, i_socks_version,
                        psz_user, psz_passwd ) )
        return VLC_EGENERIC;

    if( i_socks_version == 4 )
    {
        /* v4 only support ipv4 */
        static const struct addrinfo hints = {
            .ai_family = AF_INET,
            .ai_socktype = SOCK_STREAM,
            .ai_protocol = IPPROTO_TCP,
            .ai_flags = AI_IDN,
        };
        struct addrinfo *res;

        if (vlc_getaddrinfo_i11e(p...",429.0,530.0,1.0,1.0,102.0,0,0,0,0,1,0,1,1,0,0,,0,0,14,7,7,int
1962,150563,net_Connect,1,net_Connect,"int net_Connect (vlc_object_t*,char*,int,int,int)",network\tcp.c,"int net_Connect( vlc_object_t *p_this, const char *psz_host, int i_port,
                 int type, int proto )
{
    const char      *psz_realhost;
    char            *psz_socks;
    int             i_realport, i_handle = -1;

    psz_socks = var_InheritString( p_this, ""socks"" );
    if( psz_socks != NULL )
    {
        char *psz = strchr( psz_socks, ':' );

        if( psz )
            *psz++ = '\0';

        psz_realhost = psz_socks;
        i_realport = ( psz != NULL ) ? atoi( psz ) : 1080;

        msg_Dbg( p_this, ""net: connecting to %s port %d (SOCKS) ""
                 ""for %s port %d"", psz_realhost, i_realport,
                 psz_host, i_port );

        /* We only implement TCP with SOCKS */
        switch( type )
        {
            case 0:
                type = SOCK_STREAM;
            case SOCK_STREAM:
                break;
            default:
                msg_Err( p_this, ""Socket type not supported through SOCKS"" );
                free( psz_socks );
     ...",70.0,239.0,1.0,1.0,170.0,76,21,133,38,0,11,27,38,2,11,,0,7,10,5,5,int
1963,150959,net_AcceptSingle,1,net_AcceptSingle,"int net_AcceptSingle (vlc_object_t*,int)",network\tcp.c,"int net_AcceptSingle (vlc_object_t *obj, int lfd)
{
    int fd = vlc_accept (lfd, NULL, NULL, true);
    if (fd == -1)
    {
        if (net_errno != EAGAIN)
#if (EAGAIN != EWOULDBLOCK)
          if (net_errno != EWOULDBLOCK)
#endif
            msg_Err (obj, ""accept failed (from socket %d): %s"", lfd,
                     vlc_strerror_c(net_errno));
        return -1;
    }

    msg_Dbg (obj, ""accepted socket %d (from socket %d)"", fd, lfd);
    setsockopt (fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof(int));
    return fd;
}",242.0,259.0,1.0,1.0,18.0,9,8,19,10,1,2,3,4,0,2,,0,1,4,2,2,int
1964,151011,net_Accept,1,net_Accept,"int net_Accept (vlc_object_t*,int*)",network\tcp.c,"int net_Accept (vlc_object_t *p_this, int *pi_fd)
{
    assert (pi_fd != NULL);

    unsigned n = 0;
    while (pi_fd[n] != -1)
        n++;

    struct pollfd ufd[n];
    /* Initialize file descriptor set */
    for (unsigned i = 0; i < n; i++)
    {
        ufd[i].fd = pi_fd[i];
        ufd[i].events = POLLIN;
    }

    for (;;)
    {
        while (poll (ufd, n, -1) == -1)
        {
            if (net_errno != EINTR)
            {
                msg_Err (p_this, ""poll error: %s"", vlc_strerror_c(net_errno));
                return -1;
            }
        }

        for (unsigned i = 0; i < n; i++)
        {
            if (ufd[i].revents == 0)
                continue;

            int sfd = ufd[i].fd;
            int fd = net_AcceptSingle (p_this, sfd);
            if (fd == -1)
                continue;

            /*
             * Move listening socket to the end to let the others in the
             * set a chance next time.
             */
            memmove (pi_fd + ...",274.0,321.0,1.0,1.0,48.0,39,9,43,11,0,2,11,17,0,2,,0,1,4,2,2,int
1965,151753,net_ListenClose,1,net_ListenClose,void net_ListenClose (int*),network\tcp.c,"void net_ListenClose( int *pi_fd )
{
    if( pi_fd != NULL )
    {
        int *pi;

        for( pi = pi_fd; *pi != -1; pi++ )
            net_Close( *pi );
        free( pi_fd );
    }
}",532.0,542.0,1.0,1.0,11.0,5,4,6,3,1,0,3,4,0,0,,0,0,2,1,1,void
1966,151864,vlc_tls_ServerCreate,1,vlc_tls_ServerCreate,"vlc_tls_creds_t vlc_tls_ServerCreate (vlc_object_t*,char*,char*)",network\tls.c,"vlc_tls_creds_t *
vlc_tls_ServerCreate (vlc_object_t *obj, const char *cert_path,
                      const char *key_path)
{
    vlc_tls_creds_t *srv = vlc_custom_create (obj, sizeof (*srv),
                                              ""tls server"");
    if (unlikely(srv == NULL))
        return NULL;

    if (key_path == NULL)
        key_path = cert_path;

    srv->module = vlc_module_load (srv, ""tls server"", NULL, false,
                                   tls_server_load, srv, cert_path, key_path);
    if (srv->module == NULL)
    {
        msg_Err (srv, ""TLS server plugin not available"");
        vlc_object_release (srv);
        return NULL;
    }

    return srv;
}",86.0,108.0,1.0,27.0,23.0,10,5,24,6,1,3,4,4,0,3,,0,2,6,3,3,vlc_tls_creds_t
1967,151929,vlc_tls_ClientCreate,1,vlc_tls_ClientCreate,vlc_tls_creds_t vlc_tls_ClientCreate (vlc_object_t*),network\tls.c,"vlc_tls_creds_t *vlc_tls_ClientCreate (vlc_object_t *obj)
{
    vlc_tls_creds_t *crd = vlc_custom_create (obj, sizeof (*crd),
                                              ""tls client"");
    if (unlikely(crd == NULL))
        return NULL;

    crd->module = vlc_module_load (crd, ""tls client"", NULL, false,
                                   tls_client_load, crd);
    if (crd->module == NULL)
    {
        msg_Err (crd, ""TLS client plugin not available"");
        vlc_object_release (crd);
        return NULL;
    }

    return crd;
}",110.0,127.0,1.0,27.0,18.0,8,5,18,4,0,3,3,3,0,3,,0,2,2,1,1,vlc_tls_creds_t
1968,151982,vlc_tls_Delete,1,vlc_tls_Delete,void vlc_tls_Delete (vlc_tls_creds_t*),network\tls.c,"void vlc_tls_Delete (vlc_tls_creds_t *crd)
{
    if (crd == NULL)
        return;

    vlc_module_unload(crd, crd->module, tls_unload, crd);
    vlc_object_release (crd);
}",129.0,136.0,1.0,1.0,8.0,2,2,6,2,1,2,2,2,0,2,,0,0,2,1,1,void
1969,152002,vlc_tls_SessionCreate,1,vlc_tls_SessionCreate,"vlc_tls_t vlc_tls_SessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char*,char**)",network\tls.c,"static vlc_tls_t *vlc_tls_SessionCreate(vlc_tls_creds_t *crd,
                                        vlc_tls_t *sock,
                                        const char *host,
                                        const char *const *alpn)
{
    vlc_tls_t *session;
    int canc = vlc_savecancel();
    session = crd->open(crd, sock, host, alpn);
    vlc_restorecancel(canc);
    if (session != NULL)
        session->p = sock;
    return session;
}",141.0,153.0,1.0,1.0,13.0,6,3,13,7,2,2,2,2,0,2,,0,1,8,4,4,vlc_tls_t
1970,152039,vlc_tls_SessionDelete,1,vlc_tls_SessionDelete,void vlc_tls_SessionDelete (vlc_tls_t*),network\tls.c,"void vlc_tls_SessionDelete (vlc_tls_t *session)
{
    int canc = vlc_savecancel();
    session->close(session);
    vlc_restorecancel(canc);
}",155.0,160.0,1.0,1.0,6.0,2,2,4,2,5,2,1,1,0,2,,0,1,2,1,1,void
1971,152055,cleanup_tls,1,cleanup_tls,void cleanup_tls (void*),network\tls.c,"static void cleanup_tls(void *data)
{
    vlc_tls_t *session = data;

    vlc_tls_SessionDelete (session);
}",162.0,167.0,1.0,1.0,6.0,1,1,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
1972,152066,vlc_tls_ClientSessionCreate,1,vlc_tls_ClientSessionCreate,"vlc_tls_t vlc_tls_ClientSessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char*,char*,char**,char**)",network\tls.c,"vlc_tls_t *vlc_tls_ClientSessionCreate(vlc_tls_creds_t *crd, vlc_tls_t *sock,
                                       const char *host, const char *service,
                                       const char *const *alpn, char **alp)
{
    int val;

    vlc_tls_t *session = vlc_tls_SessionCreate(crd, sock, host, alpn);
    if (session == NULL)
        return NULL;

    int canc = vlc_savecancel();
    mtime_t deadline = mdate ();
    deadline += var_InheritInteger (crd, ""ipv4-timeout"") * 1000;

    struct pollfd ufd[1];
    ufd[0].fd = vlc_tls_GetFD(sock);

    vlc_cleanup_push (cleanup_tls, session);
    while ((val = crd->handshake(crd, session, host, service, alp)) != 0)
    {
        if (val < 0 || vlc_killed() )
        {
            if (val < 0)
                msg_Err(crd, ""TLS session handshake error"");
error:
            vlc_tls_SessionDelete (session);
            session = NULL;
            break;
        }

        mtime_t now = mdate ();
        if (now > deadline)
      ...",170.0,219.0,1.0,1.0,50.0,30,15,48,15,1,10,9,12,1,10,,0,7,12,6,6,vlc_tls_t
1973,152213,vlc_tls_ServerSessionCreate,1,vlc_tls_ServerSessionCreate,"vlc_tls_t vlc_tls_ServerSessionCreate (vlc_tls_creds_t*,vlc_tls_t*,char**)",network\tls.c,"vlc_tls_t *vlc_tls_ServerSessionCreate(vlc_tls_creds_t *crd,
                                       vlc_tls_t *sock,
                                       const char *const *alpn)
{
    return vlc_tls_SessionCreate(crd, sock, NULL, alpn);
}",221.0,226.0,1.0,1.0,6.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,vlc_tls_t
1974,152226,vlc_tls_Read,1,vlc_tls_Read,"ssize_t vlc_tls_Read (vlc_tls_t*,void*,size_t,bool)",network\tls.c,"ssize_t vlc_tls_Read(vlc_tls_t *session, void *buf, size_t len, bool waitall)
{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLIN;
    iov.iov_base = buf;
    iov.iov_len = len;

    for (size_t rcvd = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->readv(session, &iov, 1);
        if (val > 0)
        {
            if (!waitall)
                return val;
            iov.iov_base = (char *)iov.iov_base + val;
            iov.iov_len -= val;
            rcvd += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return rcvd;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return rcvd ? (ssize_t)rcvd : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",228.0,267.0,1.0,1.0,40.0,39,16,36,12,1,3,9,19,2,3,,0,2,8,4,4,ssize_t
1975,152362,vlc_tls_Write,1,vlc_tls_Write,"ssize_t vlc_tls_Write (vlc_tls_t*,void*,size_t)",network\tls.c,"ssize_t vlc_tls_Write(vlc_tls_t *session, const void *buf, size_t len)
{
    struct pollfd ufd;
    struct iovec iov;

    ufd.fd = vlc_tls_GetFD(session);
    ufd.events = POLLOUT;
    iov.iov_base = (void *)buf;
    iov.iov_len = len;

    for (size_t sent = 0;;)
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }

        ssize_t val = session->writev(session, &iov, 1);
        if (val > 0)
        {
            iov.iov_base = ((char *)iov.iov_base) + val;
            iov.iov_len -= val;
            sent += val;
        }
        if (iov.iov_len == 0 || val == 0)
            return sent;
        if (val == -1)
        {
            if (vlc_killed())
                return -1;
            if (errno != EINTR && errno != EAGAIN)
                return sent ? (ssize_t)sent : -1;
        }

        vlc_poll_i11e(&ufd, 1, -1);
    }
}",269.0,306.0,1.0,1.0,38.0,39,15,34,11,0,3,8,16,2,3,,0,2,6,3,3,ssize_t
1976,152493,vlc_tls_GetLine,1,vlc_tls_GetLine,char* vlc_tls_GetLine (vlc_tls_t*),network\tls.c,"char *vlc_tls_GetLine(vlc_tls_t *session)
{
    char *line = NULL;
    size_t linelen = 0, linesize = 0;

    do
    {
        if (linelen == linesize)
        {
            linesize += 1024;

            char *newline = realloc(line, linesize);
            if (unlikely(newline == NULL))
                goto error;
            line = newline;
        }

        if (vlc_tls_Read(session, line + linelen, 1, false) <= 0)
            goto error;
    }
    while (line[linelen++] != '\n');

    if (linelen >= 2 && line[linelen - 2] == '\r')
        line[linelen - 2] = '\0';
    else
        line[linelen - 1] = '\0';
    return line;

error:
    free(line);
    return NULL;
}",308.0,339.0,1.0,1.0,32.0,21,11,28,7,0,1,8,10,1,1,,0,1,2,1,1,char*
1977,152603,vlc_tls_SocketGetFD,1,vlc_tls_SocketGetFD,int vlc_tls_SocketGetFD (vlc_tls_t*),network\tls.c,"static int vlc_tls_SocketGetFD(vlc_tls_t *tls)
{
    vlc_tls_socket_t *sock = (struct vlc_tls_socket *)tls;

    return sock->fd;
}",349.0,354.0,1.0,1.0,6.0,3,3,3,2,4,0,1,1,0,0,,0,0,2,1,1,int
1978,152618,vlc_tls_SocketRead,1,vlc_tls_SocketRead,"ssize_t vlc_tls_SocketRead (vlc_tls_t*,iovec*,unsigned)",network\tls.c,"static ssize_t vlc_tls_SocketRead(vlc_tls_t *tls, struct iovec *iov,
                                  unsigned count)
{
    struct msghdr msg =
    {
        .msg_iov = iov,
        .msg_iovlen = count,
    };

    return recvmsg(vlc_tls_SocketGetFD(tls), &msg, 0);
}",356.0,366.0,1.0,1.0,11.0,5,3,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
1979,152644,vlc_tls_SocketWrite,1,vlc_tls_SocketWrite,"ssize_t vlc_tls_SocketWrite (vlc_tls_t*,iovec*,unsigned)",network\tls.c,"static ssize_t vlc_tls_SocketWrite(vlc_tls_t *tls, const struct iovec *iov,
                                   unsigned count)
{
    const struct msghdr msg =
    {
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };

    return sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL);
}",368.0,378.0,1.0,1.0,11.0,6,4,8,7,1,1,1,1,0,1,,0,0,6,3,3,ssize_t
1980,152672,vlc_tls_SocketShutdown,1,vlc_tls_SocketShutdown,"int vlc_tls_SocketShutdown (vlc_tls_t*,bool)",network\tls.c,"static int vlc_tls_SocketShutdown(vlc_tls_t *tls, bool duplex)
{
    return shutdown(vlc_tls_SocketGetFD(tls), duplex ? SHUT_RDWR : SHUT_WR);
}",380.0,383.0,1.0,1.0,4.0,1,1,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
1981,152686,vlc_tls_SocketClose,1,vlc_tls_SocketClose,void vlc_tls_SocketClose (vlc_tls_t*),network\tls.c,"static void vlc_tls_SocketClose(vlc_tls_t *tls)
{
    net_Close(vlc_tls_SocketGetFD(tls));
    free(tls);
}",385.0,389.0,1.0,1.0,5.0,0,0,2,1,0,1,1,1,0,1,,0,0,2,1,1,void
1982,152696,vlc_tls_SocketAlloc,1,vlc_tls_SocketAlloc,"vlc_tls_t vlc_tls_SocketAlloc (int,sockaddr*,socklen_t)",network\tls.c,"static vlc_tls_t *vlc_tls_SocketAlloc(int fd,
                                      const struct sockaddr *restrict peer,
                                      socklen_t peerlen)
{
    vlc_tls_socket_t *sock = malloc(sizeof (*sock) + peerlen);
    if (unlikely(sock == NULL))
        return NULL;

    vlc_tls_t *tls = &sock->tls;

    tls->get_fd = vlc_tls_SocketGetFD;
    tls->readv = vlc_tls_SocketRead;
    tls->writev = vlc_tls_SocketWrite;
    tls->shutdown = vlc_tls_SocketShutdown;
    tls->close = vlc_tls_SocketClose;
    tls->p = NULL;

    sock->fd = fd;
    sock->peerlen = peerlen;
    if (peerlen > 0)
        memcpy(sock->peer, peer, peerlen);
    return tls;
}",391.0,413.0,1.0,1.0,23.0,26,8,24,6,3,0,3,3,0,0,,0,0,6,3,3,vlc_tls_t
1983,152780,vlc_tls_SocketOpen,1,vlc_tls_SocketOpen,vlc_tls_t vlc_tls_SocketOpen (int),network\tls.c,"vlc_tls_t *vlc_tls_SocketOpen(int fd)
{
    return vlc_tls_SocketAlloc(fd, NULL, 0);
}",415.0,418.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,vlc_tls_t
1984,152790,vlc_tls_SocketPair,1,vlc_tls_SocketPair,"int vlc_tls_SocketPair (int,int,vlc_tls_t[2]*)",network\tls.c,"int vlc_tls_SocketPair(int family, int protocol, vlc_tls_t *pair[2])
{
    int fds[2];

    if (vlc_socketpair(family, SOCK_STREAM, protocol, fds, true))
        return -1;

    for (size_t i = 0; i < 2; i++)
    {
        setsockopt(fds[i], SOL_SOCKET, SO_REUSEADDR,
                   &(int){ 1 }, sizeof (int));

        pair[i] = vlc_tls_SocketAlloc(fds[i], NULL, 0);
        if (unlikely(pair[i] == NULL))
        {
            net_Close(fds[i]);
            if (i)
                vlc_tls_SessionDelete(pair[0]);
            else
                net_Close(fds[1]);
            return -1;
        }
    }
    return 0;
}",420.0,444.0,1.0,1.0,25.0,16,9,24,11,0,3,5,8,1,3,,0,2,6,3,3,int
1985,152874,vlc_tls_SocketAddrInfo,1,vlc_tls_SocketAddrInfo,vlc_tls_t vlc_tls_SocketAddrInfo (addrinfo*),network\tls.c,"static vlc_tls_t *vlc_tls_SocketAddrInfo(const struct addrinfo *restrict info)
{
    int fd = vlc_socket(info->ai_family, info->ai_socktype, info->ai_protocol,
                        true /* nonblocking */);
    if (fd == -1)
        return NULL;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &(int){ 1 }, sizeof (int));

    if (info->ai_socktype == SOCK_STREAM && info->ai_protocol == IPPROTO_TCP)
        setsockopt(fd, SOL_TCP, TCP_NODELAY, &(int){ 1 }, sizeof (int));

    vlc_tls_t *sk = vlc_tls_SocketAlloc(fd, info->ai_addr, info->ai_addrlen);
    if (unlikely(sk == NULL))
        net_Close(fd);
    return sk;
}",449.0,465.0,1.0,23.0,17.0,23,9,27,11,1,2,4,4,0,2,,0,2,2,1,1,vlc_tls_t
1986,152959,vlc_tls_WaitConnect,1,vlc_tls_WaitConnect,int vlc_tls_WaitConnect (vlc_tls_t*),network\tls.c,"static int vlc_tls_WaitConnect(vlc_tls_t *tls)
{
    const int fd = vlc_tls_GetFD(tls);
    struct pollfd ufd;

    ufd.fd = fd;
    ufd.events = POLLOUT;

    do
    {
        if (vlc_killed())
        {
            errno = EINTR;
            return -1;
        }
    }
    while (vlc_poll_i11e(&ufd, 1, -1) <= 0);

    int val;
    socklen_t len = sizeof (val);

    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &val, &len))
        return -1;

    if (val != 0)
    {
        errno = val;
        return -1;
    }
    return 0;
}",470.0,500.0,1.0,1.0,31.0,18,7,19,10,1,2,5,6,2,2,,0,2,2,1,1,int
1987,153031,vlc_tls_Connect,1,vlc_tls_Connect,ssize_t vlc_tls_Connect (vlc_tls_t*),network\tls.c,"static ssize_t vlc_tls_Connect(vlc_tls_t *tls)
{
    const vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;

    if (connect(sock->fd, sock->peer, sock->peerlen) == 0)
        return 0;
#ifndef _WIN32
    if (errno != EINPROGRESS)
        return -1;
#else
    if (WSAGetLastError() != WSAEWOULDBLOCK)
        return -1;
#endif
    return vlc_tls_WaitConnect(tls);
}",505.0,519.0,1.0,1.0,15.0,8,6,8,4,1,1,3,3,0,1,,0,0,2,1,1,ssize_t
1988,153069,vlc_tls_ConnectWrite,1,vlc_tls_ConnectWrite,"ssize_t vlc_tls_ConnectWrite (vlc_tls_t*,iovec*,unsigned)",network\tls.c,"static ssize_t vlc_tls_ConnectWrite(vlc_tls_t *tls,
                                    const struct iovec *iov,unsigned count)
{
#ifdef MSG_FASTOPEN
    vlc_tls_socket_t *sock = (vlc_tls_socket_t *)tls;
    const struct msghdr msg =
    {
        .msg_name = sock->peer,
        .msg_namelen = sock->peerlen,
        .msg_iov = (struct iovec *)iov,
        .msg_iovlen = count,
    };
    ssize_t ret;

    /* Next time, write directly. Do not retry to connect. */
    tls->writev = vlc_tls_SocketWrite;

    ret = sendmsg(vlc_tls_SocketGetFD(tls), &msg, MSG_NOSIGNAL|MSG_FASTOPEN);
    if (ret >= 0)
    {   /* Fast open in progress */
        return ret;
    }

    if (errno == EINPROGRESS)
    {
        if (vlc_tls_WaitConnect(tls))
            return -1;
    }
    else
    if (errno != EOPNOTSUPP)
        return -1;
    /* Fast open not supported or disabled... fallback to normal mode */
#else
    tls->writev = vlc_tls_SocketWrite;
#endif

    if (vlc_tls_Connect(tls))
        return -...",522.0,562.0,1.0,1.0,41.0,3,3,5,3,0,2,2,2,1,2,,0,1,6,3,3,ssize_t
1989,153093,vlc_tls_SocketOpenAddrInfo,1,vlc_tls_SocketOpenAddrInfo,"vlc_tls_t vlc_tls_SocketOpenAddrInfo (addrinfo*,bool)",network\tls.c,"vlc_tls_t *vlc_tls_SocketOpenAddrInfo(const struct addrinfo *restrict info,
                                      bool defer_connect)
{
    vlc_tls_t *sock = vlc_tls_SocketAddrInfo(info);
    if (sock == NULL)
        return NULL;

    if (defer_connect)
    {   /* The socket is not connected yet.
         * The connection will be triggered on the first send. */
        sock->writev = vlc_tls_ConnectWrite;
    }
    else
    {
        if (vlc_tls_Connect(sock))
        {
            vlc_tls_SessionDelete(sock);
            sock = NULL;
        }
    }
    return sock;
}",564.0,585.0,1.0,1.0,22.0,4,3,8,4,2,1,3,3,0,1,,0,1,4,2,2,vlc_tls_t
1990,153132,vlc_tls_SocketOpenTCP,1,vlc_tls_SocketOpenTCP,"vlc_tls_t vlc_tls_SocketOpenTCP (vlc_object_t*,char*,unsigned)",network\tls.c,"vlc_tls_t *vlc_tls_SocketOpenTCP(vlc_object_t *obj, const char *name,
                                 unsigned port)
{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    assert(name != NULL);
    msg_Dbg(obj, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(obj, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    msg_Dbg(obj, ""connecting to %s port %u ..."", name, port);

    /* TODO: implement RFC6555 */
    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tls = vlc_tls_SocketOpenAddrInfo(p, false);
        if (tls == NULL)
        {
            msg_Err(obj, ""connection error: %s"", vlc_strerror_c(errno));
            continue;
        }

        freeaddrinfo(res);
        return tls;
    }
...",587.0,625.0,1.0,1.0,39.0,13,5,38,15,0,3,5,5,0,3,,0,2,6,3,3,vlc_tls_t
1991,153229,vlc_tls_SocketOpenTLS,1,vlc_tls_SocketOpenTLS,"vlc_tls_t vlc_tls_SocketOpenTLS (vlc_tls_creds_t*,char*,unsigned,char*,char**,char**)",network\tls.c,"vlc_tls_t *vlc_tls_SocketOpenTLS(vlc_tls_creds_t *creds, const char *name,
                                 unsigned port, const char *service,
                                 const char *const *alpn, char **alp)
{
    struct addrinfo hints =
    {
        .ai_socktype = SOCK_STREAM,
        .ai_protocol = IPPROTO_TCP,
    }, *res;

    msg_Dbg(creds, ""resolving %s ..."", name);

    int val = vlc_getaddrinfo_i11e(name, port, &hints, &res);
    if (val != 0)
    {   /* TODO: C locale for gai_strerror() */
        msg_Err(creds, ""cannot resolve %s port %u: %s"", name, port,
                gai_strerror(val));
        return NULL;
    }

    for (const struct addrinfo *p = res; p != NULL; p = p->ai_next)
    {
        vlc_tls_t *tcp = vlc_tls_SocketOpenAddrInfo(p, true);
        if (tcp == NULL)
        {
            msg_Err(creds, ""socket error: %s"", vlc_strerror_c(errno));
            continue;
        }

        vlc_tls_t *tls = vlc_tls_ClientSessionCreate(creds, tcp, name, service,...",627.0,671.0,1.0,1.0,45.0,14,5,45,19,0,6,6,7,0,6,,0,3,12,6,6,vlc_tls_t
1992,153375,net_SetupDgramSocket,1,net_SetupDgramSocket,"int net_SetupDgramSocket (vlc_object_t*,int,addrinfo*)",network\udp.c,"static int net_SetupDgramSocket (vlc_object_t *p_obj, int fd,
                                 const struct addrinfo *ptr)
{
#if defined (SO_REUSEPORT) && !defined (__linux__)
    setsockopt (fd, SOL_SOCKET, SO_REUSEPORT, &(int){ 1 }, sizeof (int));
#endif

#if defined (_WIN32)

    /* Check windows version so we know if we need to increase receive buffers
     * for Windows 7 and earlier

     * SetSocketMediaStreamingMode is present in win 8 and later, so we set
     * receive buffer if that isn't present
     */
#if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
    HINSTANCE h_Network = LoadLibrary(TEXT(""Windows.Networking.dll""));
    if( (h_Network == NULL) ||
        (GetProcAddress( h_Network, ""SetSocketMediaStreamingMode"" ) == NULL ) )
    {
        setsockopt (fd, SOL_SOCKET, SO_RCVBUF,
                         (void *)&(int){ 0x80000 }, sizeof (int));
    }
    if( h_Network )
        FreeLibrary( h_Network );
#endif

    if (net_SockAddrIsMulticast (ptr->ai_addr, ptr->ai_addrlen)
   ...",93.0,141.0,1.0,1.0,49.0,3,2,7,4,2,1,2,2,0,1,,0,0,6,3,3,int
1993,153404,net_ListenSingle,1,net_ListenSingle,"int net_ListenSingle (vlc_object_t*,char*,int,int)",network\udp.c,"static int net_ListenSingle (vlc_object_t *obj, const char *host, int port,
                             int protocol)
{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_PASSIVE | AI_NUMERICSERV | AI_IDN,
    }, *res;

    if (host && !*host)
        host = NULL;

    msg_Dbg (obj, ""net: opening %s datagram port %d"",
             host ? host : ""any"", port);

    int val = vlc_getaddrinfo (host, port, &hints, &res);
    if (val)
    {
        msg_Err (obj, ""Cannot resolve %s port %d : %s"", host, port,
                 gai_strerror (val));
        return -1;
    }

    val = -1;

    for (const struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        int fd = net_Socket (obj, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
        {
            msg_Dbg (obj, ""socket error: %s"", vlc_strerror_c(net_errno));
            continue;
        }

#if...",144.0,201.0,1.0,1.0,58.0,35,12,56,18,1,5,11,10,1,5,,0,4,8,4,4,int
1994,153562,net_SetMcastHopLimit,1,net_SetMcastHopLimit,"int net_SetMcastHopLimit (vlc_object_t*,int,int,int)",network\udp.c,"static int net_SetMcastHopLimit( vlc_object_t *p_this,
                                 int fd, int family, int hlim )
{
    int proto, cmd;

    /* There is some confusion in the world whether IP_MULTICAST_TTL
     * takes a byte or an int as an argument.
     * BSD seems to indicate byte so we are going with that and use
     * int as a fallback to be safe */
    switch( family )
    {
#ifdef IP_MULTICAST_TTL
        case AF_INET:
            proto = SOL_IP;
            cmd = IP_MULTICAST_TTL;
            break;
#endif

#ifdef IPV6_MULTICAST_HOPS
        case AF_INET6:
            proto = SOL_IPV6;
            cmd = IPV6_MULTICAST_HOPS;
            break;
#endif

        default:
            errno = EAFNOSUPPORT;
            msg_Warn( p_this, ""%s"", vlc_strerror_c(EAFNOSUPPORT) );
            return VLC_EGENERIC;
    }

    if( setsockopt( fd, proto, cmd, &hlim, sizeof( hlim ) ) < 0 )
    {
        /* BSD compatibility */
        unsigned char buf;

        msg_Dbg( p_this, ""cannot...",204.0,252.0,1.0,1.0,49.0,10,7,27,12,1,3,4,5,0,3,,0,0,8,4,4,int
1995,153635,net_SetMcastOut,1,net_SetMcastOut,"int net_SetMcastOut (vlc_object_t*,int,int,char*)",network\udp.c,"static int net_SetMcastOut (vlc_object_t *p_this, int fd, int family,
                            const char *iface)
{
    int scope = if_nametoindex (iface);
    if (scope == 0)
    {
        msg_Err (p_this, ""invalid multicast interface: %s"", iface);
        return -1;
    }

    switch (family)
    {
#ifdef IPV6_MULTICAST_IF
        case AF_INET6:
            if (setsockopt (fd, SOL_IPV6, IPV6_MULTICAST_IF,
                            &scope, sizeof (scope)) == 0)
                return 0;
            break;
#endif

#ifdef __linux__
        case AF_INET:
        {
            struct ip_mreqn req = { .imr_ifindex = scope };
            if (setsockopt (fd, SOL_IP, IP_MULTICAST_IF,
                            &req, sizeof (req)) == 0)
                return 0;
            break;
        }
#endif
        default:
            errno = EAFNOSUPPORT;
    }
    msg_Err (p_this, ""cannot force multicast interface %s: %s"", iface,
             vlc_strerror_c(errno));
    return -1;
}",255.0,291.0,1.0,1.0,37.0,5,3,11,6,1,1,3,3,0,1,,0,0,8,4,4,int
1996,153712,net_SourceSubscribe,1,net_SourceSubscribe,"int net_SourceSubscribe (vlc_object_t*,int,sockaddr*,socklen_t,sockaddr*,socklen_t)",network\udp.c,"static int
net_SourceSubscribe (vlc_object_t *obj, int fd,
                     const struct sockaddr *src, socklen_t srclen,
                     const struct sockaddr *grp, socklen_t grplen)
{
/* MCAST_JOIN_SOURCE_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code path as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_SOURCE_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Source-Specific Multicast join */
    int level;
    struct group_source_req gsr;

    memset (&gsr, 0, sizeof (gsr));
    gsr.gsr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gsr.gsr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
...",312.0,392.0,1.0,1.0,81.0,7,4,14,8,1,2,3,3,0,2,,0,0,12,6,6,int
1997,153760,net_Subscribe,1,net_Subscribe,"int net_Subscribe (vlc_object_t*,int,sockaddr*,socklen_t)",network\udp.c,"int net_Subscribe (vlc_object_t *obj, int fd,
                   const struct sockaddr *grp, socklen_t grplen)
{
/* MCAST_JOIN_GROUP was introduced to OS X in v10.7, but it doesn't work,
 * so ignore it to use the same code as on 10.5 or 10.6 */
#if defined (MCAST_JOIN_GROUP) && !defined (__APPLE__)
    /* Family-agnostic Any-Source Multicast join */
    int level;
    struct group_req gr;

    memset (&gr, 0, sizeof (gr));
    gr.gr_interface = var_GetIfIndex (obj);

    switch (grp->sa_family)
    {
#ifdef AF_INET6
        case AF_INET6:
        {
            const struct sockaddr_in6 *g6 = (const struct sockaddr_in6 *)grp;

            level = SOL_IPV6;
            assert (grplen >= sizeof (struct sockaddr_in6));
            if (g6->sin6_scope_id != 0)
                gr.gr_interface = g6->sin6_scope_id;
            break;
        }
#endif
        case AF_INET:
            level = SOL_IP;
            break;
        default:
            errno = EAFNOSUPPORT;
            return -1;...",395.0,476.0,1.0,1.0,82.0,3,3,5,5,3,1,2,2,0,1,,0,0,8,4,4,int
1998,153785,net_SetDSCP,1,net_SetDSCP,"int net_SetDSCP (int,uint8_t)",network\udp.c,"static int net_SetDSCP( int fd, uint8_t dscp )
{
    struct sockaddr_storage addr;
    if( getsockname( fd, (struct sockaddr *)&addr, &(socklen_t){ sizeof (addr) }) )
        return -1;

    int level, cmd;

    switch( addr.ss_family )
    {
#ifdef IPV6_TCLASS
        case AF_INET6:
            level = SOL_IPV6;
            cmd = IPV6_TCLASS;
            break;
#endif

        case AF_INET:
            level = SOL_IP;
            cmd = IP_TOS;
            break;

        default:
#ifdef ENOPROTOOPT
            errno = ENOPROTOOPT;
#endif
            return -1;
    }

    return setsockopt( fd, level, cmd, &(int){ dscp }, sizeof (int));
}",479.0,509.0,1.0,20.0,31.0,15,7,14,9,1,0,4,3,0,0,,0,0,4,2,2,int
1999,153843,net_ConnectDgram,1,net_ConnectDgram,"int net_ConnectDgram (vlc_object_t*,char*,int,int,int)",network\udp.c,"int net_ConnectDgram( vlc_object_t *p_this, const char *psz_host, int i_port,
                      int i_hlim, int proto )
{
    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = proto,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *res;
    int       i_handle = -1;
    bool      b_unreach = false;

    if( i_hlim < 0 )
        i_hlim = var_InheritInteger( p_this, ""ttl"" );

    msg_Dbg( p_this, ""net: connecting to [%s]:%d"", psz_host, i_port );

    int val = vlc_getaddrinfo (psz_host, i_port, &hints, &res);
    if (val)
    {
        msg_Err (p_this, ""cannot resolve [%s]:%d : %s"", psz_host, i_port,
                 gai_strerror (val));
        return -1;
    }

    for (struct addrinfo *ptr = res; ptr != NULL; ptr = ptr->ai_next)
    {
        char *str;
        int fd = net_Socket (p_this, ptr->ai_family, ptr->ai_socktype,
                             ptr->ai_protocol);
        if (fd == -1)
            continue;

        /* Allow broadcast ...",518.0,595.0,1.0,1.0,78.0,41,12,74,27,0,5,13,17,0,5,,0,2,10,5,5,int
2000,154058,net_OpenDgram,1,net_OpenDgram,"int net_OpenDgram (vlc_object_t*,char*,int,char*,int,int)",network\udp.c,"int net_OpenDgram( vlc_object_t *obj, const char *psz_bind, int i_bind,
                   const char *psz_server, int i_server, int protocol )
{
    if ((psz_server == NULL) || (psz_server[0] == '\0'))
        return net_ListenSingle (obj, psz_bind, i_bind, protocol);

    msg_Dbg (obj, ""net: connecting to [%s]:%d from [%s]:%d"",
             psz_server, i_server, psz_bind, i_bind);

    struct addrinfo hints = {
        .ai_socktype = SOCK_DGRAM,
        .ai_protocol = protocol,
        .ai_flags = AI_NUMERICSERV | AI_IDN,
    }, *loc, *rem;

    int val = vlc_getaddrinfo (psz_server, i_server, &hints, &rem);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_server, i_server,
                 gai_strerror (val));
        return -1;
    }

    hints.ai_flags |= AI_PASSIVE;
    val = vlc_getaddrinfo (psz_bind, i_bind, &hints, &loc);
    if (val)
    {
        msg_Err (obj, ""cannot resolve %s port %d : %s"", psz_bind, i_bind,
                 gai_strerror (...",603.0,678.0,1.0,1.0,76.0,57,12,91,22,0,7,17,19,1,7,,0,5,12,6,6,int
2001,154535,vlc_open,1,vlc_open,"int vlc_open (char*,int...)",win32\filesystem.c,"int vlc_open (const char *filename, int flags, ...)
{
    int mode = 0;
    va_list ap;

    flags |= O_NOINHERIT; /* O_CLOEXEC */
    /* Defaults to binary mode */
    if ((flags & O_TEXT) == 0)
        flags |= O_BINARY;

    va_start (ap, flags);
    if (flags & O_CREAT)
    {
        int unixmode = va_arg(ap, int);
        if (unixmode & 0444)
            mode |= _S_IREAD;
        if (unixmode & 0222)
            mode |= _S_IWRITE;
    }
    va_end (ap);

    /*
     * open() cannot open files with non-“ANSI” characters on Windows.
     * We use _wopen() instead. Same thing for mkdir() and stat().
     */
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int fd = _wopen (wpath, flags, mode);
    free (wpath);
    return fd;
}",72.0,104.0,1.0,1.0,33.0,8,4,20,11,4,0,3,3,0,0,,0,0,4,2,2,int
2002,154613,vlc_close,1,vlc_close,int vlc_close (int),win32\filesystem.c,"int vlc_close (int fd)
{
    return close (fd);
}",133.0,136.0,1.0,1.0,4.0,0,0,1,1,9,0,1,1,0,0,,0,0,2,1,1,int
2003,154621,vlc_mkdir,1,vlc_mkdir,"int vlc_mkdir (char*,mode_t)",win32\filesystem.c,"int vlc_mkdir( const char *dirname, mode_t mode )
{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return -1;

    int ret = _wmkdir (wpath);
    free (wpath);
    (void) mode;
    return ret;
}",138.0,148.0,1.0,1.0,11.0,5,3,11,7,3,0,2,2,0,0,,0,0,4,2,2,int
2004,154654,vlc_opendir,1,vlc_opendir,DIR vlc_opendir (char*),win32\filesystem.c,"DIR *vlc_opendir (const char *dirname)
{
    wchar_t *wpath = widen_path (dirname);
    if (wpath == NULL)
        return NULL;

    vlc_DIR *p_dir = malloc (sizeof (*p_dir));
    if (unlikely(p_dir == NULL))
    {
        free(wpath);
        return NULL;
    }

#if !VLC_WINSTORE_APP
    /* Special mode to list drive letters */
    if (wpath[0] == L'\0' || (wcscmp (wpath, L""\\"") == 0))
    {
        free (wpath);
        p_dir->wdir = NULL;
        p_dir->u.drives = GetLogicalDrives ();
        p_dir->entry = NULL;
        return (void *)p_dir;
    }
#endif

    assert (wpath[0]); // wpath[1] is defined
    p_dir->u.insert_dot_dot = !wcscmp (wpath + 1, L"":\\"");

    _WDIR *wdir = _wopendir (wpath);
    free (wpath);
    if (wdir == NULL)
    {
        free (p_dir);
        return NULL;
    }
    p_dir->wdir = wdir;
    p_dir->entry = NULL;
    return (void *)p_dir;
}",167.0,205.0,1.0,1.0,39.0,4,2,11,6,2,0,2,2,0,0,,0,0,2,1,1,DIR
2005,154684,vlc_readdir,1,vlc_readdir,const char* vlc_readdir (DIR*),win32\filesystem.c,"const char *vlc_readdir (DIR *dir)
{
    vlc_DIR *p_dir = (vlc_DIR *)dir;

    free(p_dir->entry);

#if !VLC_WINSTORE_APP
    /* Drive letters mode */
    if (p_dir->wdir == NULL)
    {
        DWORD drives = p_dir->u.drives;
        if (drives == 0)
        {
            p_dir->entry = NULL;
            return NULL; /* end */
        }

        unsigned int i;
        for (i = 0; !(drives & 1); i++)
            drives >>= 1;
        p_dir->u.drives &= ~(1UL << i);
        assert (i < 26);

        if (asprintf (&p_dir->entry, ""%c:\\"", 'A' + i) == -1)
            p_dir->entry = NULL;
    }
    else
#endif
    if (p_dir->u.insert_dot_dot)
    {
        /* Adds "".."", gruik! */
        p_dir->u.insert_dot_dot = false;
        p_dir->entry = strdup ("".."");
    }
    else
    {
        struct _wdirent *ent = _wreaddir (p_dir->wdir);
        p_dir->entry = (ent != NULL) ? FromWide (ent->d_name) : NULL;
    }
    return p_dir->entry;
}",207.0,247.0,1.0,1.0,41.0,9,5,18,9,2,0,3,3,0,0,,0,0,2,1,1,const char*
2006,154750,vlc_statEx,1,vlc_statEx,"int vlc_statEx (char*,stat*,bool)",os2\filesystem.c,"static int vlc_statEx (const char *filename, struct stat *buf, bool deref)
{
    const char *local_name = ToLocaleDup (filename);
    if (unlikely(local_name == NULL))
    {
        errno = ENOENT;
        return -1;
    }

    int res = deref ? stat (local_name, buf)
                    : lstat (local_name, buf);
    free (local_name);
    return res;
}",156.0,169.0,1.0,1.0,14.0,6,4,14,8,2,0,2,2,0,0,,0,0,6,3,3,int
2007,154789,vlc_stat,1,vlc_stat,"int vlc_stat (char*,stat*)",win32\filesystem.c,"int vlc_stat (const char *filename, struct stat *buf)
{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    static_assert (sizeof (*buf) == sizeof (struct _stati64),
                   ""Mismatched struct stat definition."");

    int ret = _wstati64 (wpath, buf);
    free (wpath);
    return ret;
}",249.0,261.0,1.0,1.0,13.0,0,0,3,3,5,1,1,1,0,1,,0,0,4,2,2,int
2008,154800,vlc_lstat,1,vlc_lstat,"int vlc_lstat (char*,stat*)",win32\filesystem.c,"int vlc_lstat (const char *filename, struct stat *buf)
{
    return vlc_stat (filename, buf);
}",263.0,266.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
2009,154811,vlc_unlink,1,vlc_unlink,int vlc_unlink (char*),win32\filesystem.c,"int vlc_unlink (const char *filename)
{
    wchar_t *wpath = widen_path (filename);
    if (wpath == NULL)
        return -1;

    int ret = _wunlink (wpath);
    free (wpath);
    return ret;
}",268.0,277.0,1.0,1.0,10.0,5,3,10,6,3,0,2,2,0,0,,0,0,2,1,1,int
2010,154842,vlc_rename,1,vlc_rename,"int vlc_rename (char*,char*)",win32\filesystem.c,"int vlc_rename (const char *oldpath, const char *newpath)
{
    int ret = -1;

    wchar_t *wold = widen_path (oldpath), *wnew = widen_path (newpath);
    if (wold == NULL || wnew == NULL)
        goto out;

    if (_wrename (wold, wnew) && (errno == EACCES || errno == EEXIST))
    {   /* Windows does not allow atomic file replacement */
        if (_wremove (wnew))
        {
            errno = EACCES; /* restore errno */
            goto out;
        }
        if (_wrename (wold, wnew))
            goto out;
    }
    ret = 0;
out:
    free (wnew);
    free (wold);
    return ret;
}",279.0,302.0,1.0,1.0,24.0,7,3,17,8,2,0,4,3,0,0,,0,0,4,2,2,int
2011,154890,vlc_getcwd,1,vlc_getcwd,char* vlc_getcwd (void),win32\filesystem.c,"char *vlc_getcwd (void)
{
#if VLC_WINSTORE_APP
    return NULL;
#else
    wchar_t *wdir = _wgetcwd (NULL, 0);
    if (wdir == NULL)
        return NULL;

    char *dir = FromWide (wdir);
    free (wdir);
    return dir;
#endif
}",150.0,163.0,1.0,1.0,14.0,28,11,33,11,1,0,9,11,0,0,,0,0,2,1,1,char*
2012,155028,vlc_pipe,1,vlc_pipe,int vlc_pipe (int[2]),win32\filesystem.c,"int vlc_pipe (int fds[2])
{
#if VLC_WINSTORE_APP
    _set_errno(EPERM);
    return -1;
#else
    return _pipe (fds, 32768, O_NOINHERIT | O_BINARY);
#endif
}",312.0,320.0,1.0,1.0,9.0,5,2,12,7,1,1,2,2,1,1,,0,1,2,1,1,int
2013,155066,vlc_write,1,vlc_write,"ssize_t vlc_write (int,void*,size_t)",win32\filesystem.c,"ssize_t vlc_write(int fd, const void *buf, size_t len)
{
    return write(fd, buf, len);
}",322.0,325.0,1.0,1.0,4.0,6,4,7,6,0,1,1,1,0,1,,0,0,6,3,3,ssize_t
2014,155093,vlc_writev,1,vlc_writev,"ssize_t vlc_writev (int,iovec*,int)",win32\filesystem.c,"ssize_t vlc_writev(int fd, const struct iovec *iov, int count)
{
    vlc_assert_unreachable();
}",327.0,330.0,1.0,1.0,4.0,19,10,25,15,1,0,4,5,0,0,,0,0,6,3,3,ssize_t
2015,155166,vlc_socket_setup,1,vlc_socket_setup,"void vlc_socket_setup (int,bool)",posix\filesystem.c,"static void vlc_socket_setup(int fd, bool nonblock)
{
    vlc_cloexec(fd);

    if (nonblock)
        fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);

#ifdef SO_NOSIGPIPE
    setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &(int){ 1 }, sizeof (int));
#endif
}",283.0,293.0,1.0,1.0,11.0,1,1,9,7,3,0,2,2,0,0,,0,0,4,2,2,void
2016,155188,vlc_socket,1,vlc_socket,"int vlc_socket (int,int,int,bool)",win32\filesystem.c,"int vlc_socket (int pf, int type, int proto, bool nonblock)
{
    int fd = socket (pf, type, proto);
    if (fd == -1)
        return -1;

    if (nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",334.0,343.0,1.0,1.0,10.0,3,3,8,5,2,1,2,2,0,1,,0,0,8,4,4,int
2017,155214,vlc_socketpair,1,vlc_socketpair,"int vlc_socketpair (int,int,int,int[2],bool)",win32\filesystem.c,"int vlc_socketpair(int pf, int type, int proto, int fds[2], bool nonblock)
{
    (void) pf; (void) type; (void) proto; (void) fds; (void) nonblock;
    errno = ENOSYS;
    return -1;
}",345.0,350.0,1.0,1.0,6.0,3,2,8,5,2,2,2,2,0,2,,0,0,10,5,5,int
2018,155245,vlc_accept,1,vlc_accept,"int vlc_accept (int,sockaddr*,socklen_t*,bool)",win32\filesystem.c,"int vlc_accept (int lfd, struct sockaddr *addr, socklen_t *alen, bool nonblock)
{
    int fd = accept (lfd, addr, alen);
    if (fd != -1 && nonblock)
        ioctlsocket (fd, FIONBIO, &(unsigned long){ 1 });
    return fd;
}",352.0,358.0,1.0,1.0,7.0,6,5,17,12,3,0,4,7,0,0,,0,0,8,4,4,int
2019,155305,getnameinfo,1,getnameinfo,"int getnameinfo (sockaddr*,socklen_t,char*,int,char*,int,int)",os2\getaddrinfo.c,"int
getnameinfo (const struct sockaddr *sa, socklen_t salen,
                 char *host, int hostlen, char *serv, int servlen, int flags)
{
    if (((size_t)salen < sizeof (struct sockaddr_in))
     || (sa->sa_family != AF_INET))
        return EAI_FAMILY;
    else if (flags & (~_NI_MASK))
        return EAI_BADFLAGS;
    else
    {
        const struct sockaddr_in *addr;

        addr = (const struct sockaddr_in *)sa;

        if (host != NULL)
        {
            /* host name resolution */
            if (!(flags & NI_NUMERICHOST))
            {
                if (flags & NI_NAMEREQD)
                    return EAI_NONAME;
            }

            /* inet_ntoa() is not thread-safe, do not use it */
            uint32_t ipv4 = ntohl (addr->sin_addr.s_addr);

            if (snprintf (host, hostlen, ""%u.%u.%u.%u"", ipv4 >> 24,
                          (ipv4 >> 16) & 0xff, (ipv4 >> 8) & 0xff,
                          ipv4 & 0xff) >= (int)hostlen)
                return EAI_OVE...",46.0,87.0,1.0,23.0,42.0,6,6,5,5,1,0,2,2,0,0,,0,0,14,7,7,int
2020,155466,makeaddrinfo,1,makeaddrinfo,"struct addrinfo makeaddrinfo (int,int,int,sockaddr*,size_t,char*)",os2\getaddrinfo.c,"static struct addrinfo *
makeaddrinfo (int af, int type, int proto,
              const struct sockaddr *addr, size_t addrlen,
              const char *canonname)
{
    struct addrinfo *res;

    res = (struct addrinfo *)malloc (sizeof (struct addrinfo));
    if (res != NULL)
    {
        res->ai_flags = 0;
        res->ai_family = af;
        res->ai_socktype = type;
        res->ai_protocol = proto;
        res->ai_addrlen = addrlen;
        res->ai_addr = malloc (addrlen);
        res->ai_canonname = NULL;
        res->ai_next = NULL;

        if (res->ai_addr != NULL)
        {
            memcpy (res->ai_addr, addr, addrlen);

            if (canonname != NULL)
            {
                res->ai_canonname = strdup (canonname);
                if (res->ai_canonname != NULL)
                    return res; /* success ! */
            }
            else
                return res;
        }
    }
    /* failsafe */
    freeaddrinfo (res);
    return NULL;
}",120.0,156.0,1.0,1.0,37.0,28,5,33,9,1,0,5,11,0,0,,0,0,12,6,6,struct addrinfo
2021,155571,makeipv4info,1,makeipv4info,"struct addrinfo makeipv4info (int,int,u_long,u_short,char*)",os2\getaddrinfo.c,"static struct addrinfo *
makeipv4info (int type, int proto, u_long ip, u_short port, const char *name)
{
    struct sockaddr_in addr;

    memset (&addr, 0, sizeof (addr));
    addr.sin_family = AF_INET;
# ifdef HAVE_SA_LEN
    addr.sin_len = sizeof (addr);
# endif
    addr.sin_port = port;
    addr.sin_addr.s_addr = ip;

    return makeaddrinfo (AF_INET, type, proto,
                         (struct sockaddr*)&addr, sizeof (addr), name);
}",158.0,173.0,1.0,1.0,16.0,12,5,14,7,2,1,1,1,0,1,,0,0,10,5,5,struct addrinfo
2022,155616,getaddrinfo,1,getaddrinfo,"int getaddrinfo (char*,char*,addrinfo*,addrinfo**)",os2\getaddrinfo.c,"int
getaddrinfo (const char *node, const char *service,
             const struct addrinfo *hints, struct addrinfo **res)
{
    struct addrinfo *info;
    u_long ip;
    u_short port;
    int protocol = 0, flags = 0;
    const char *name = NULL;

    if (hints != NULL)
    {
        flags = hints->ai_flags;

        if (flags & ~_AI_MASK)
            return EAI_BADFLAGS;
        /* only accept AF_INET and AF_UNSPEC */
        if (hints->ai_family && (hints->ai_family != AF_INET))
            return EAI_FAMILY;

        /* protocol sanity check */
        switch (hints->ai_socktype)
        {
            case SOCK_STREAM:
                protocol = IPPROTO_TCP;
                break;

            case SOCK_DGRAM:
                protocol = IPPROTO_UDP;
                break;

#ifdef SOCK_RAW
            case SOCK_RAW:
#endif
            case 0:
                break;

            default:
                return EAI_SOCKTYPE;
        }
        if (hints->ai_protocol && protocol
      ...",184.0,305.0,1.0,21.0,122.0,56,11,89,27,2,2,19,25,0,2,,0,2,8,4,4,int
2023,156065,vlc_rand_bytes,1,vlc_rand_bytes,"void vlc_rand_bytes (void*,size_t)",win32\rand.c,"void vlc_rand_bytes (void *buf, size_t len)
{
    size_t count = len;
    uint8_t *p_buf = (uint8_t *)buf;

    /* fill buffer with pseudo-random data */
    while (count > 0)
    {
        unsigned int val;
        val = rand();
        if (count < sizeof (val))
        {
            memcpy (p_buf, &val, count);
            break;
        }

        memcpy (p_buf, &val, sizeof (val));
        count -= sizeof (val);
        p_buf += sizeof (val);
    }

#if VLC_WINSTORE_APP
    static const WCHAR *className = L""Windows.Security.Cryptography.CryptographicBuffer"";
    const UINT32 clen = wcslen(className);

    HSTRING hClassName = NULL;
    HSTRING_HEADER header;
    HRESULT hr = WindowsCreateStringReference(className, clen, &header, &hClassName);
    if (hr) {
        WindowsDeleteString(hClassName);
        return;
    }

    ICryptographicBufferStatics *cryptoStatics = NULL;
    hr = RoGetActivationFactory(hClassName, &IID_ICryptographicBufferStatics, (void**)&cryptoStatics);
    ...",39.0,109.0,1.0,1.0,71.0,10,9,7,4,2,0,2,2,0,0,,0,0,4,2,2,void
2024,156136,IPCHelperThread,1,IPCHelperThread,void IPCHelperThread (void*),os2\specific.c,"static void IPCHelperThread( void *arg )
{
    libvlc_int_t *libvlc = arg;

    ULONG  ulCmd;
    int    i_argc;
    char **ppsz_argv;
    size_t i_len;
    ULONG  cbActual;
    int    i_options;

    /* Add files to the playlist */
    playlist_t *p_playlist;

    do
    {
        DosConnectNPipe( hpipeIPC );

        /* Read command */
        DosRead( hpipeIPC, &ulCmd, sizeof( ulCmd ), &cbActual );
        if( ulCmd == IPC_CMD_QUIT )
            continue;

        /* Read a count of arguments */
        DosRead( hpipeIPC, &i_argc, sizeof( i_argc ), &cbActual );

        ppsz_argv = vlc_alloc( i_argc, sizeof( *ppsz_argv ));

        for( int i_opt = 0; i_opt < i_argc; i_opt++ )
        {
            /* Read a length of argv */
            DosRead( hpipeIPC, &i_len, sizeof( i_len ), &cbActual );

            ppsz_argv[ i_opt ] = malloc( i_len );

            /* Read argv */
            DosRead( hpipeIPC, ppsz_argv[ i_opt ], i_len, &cbActual );
        }

        p_playlist = libvlc...",47.0,122.0,1.0,21.0,76.0,52,16,65,17,0,12,9,17,1,2,,0,11,2,1,1,void
2025,156541,system_End,1,system_End,void system_End (void),win32\specific.c,"void system_End(void)
{
    /* XXX: In theory, we should not call this if WSAStartup() failed. */
    WSACleanup();
}",187.0,191.0,1.0,1.0,5.0,7,4,12,8,0,2,3,4,1,0,,0,2,2,1,1,void
2026,156634,vlc_cancel_self,1,vlc_cancel_self,void vlc_cancel_self (PVOID),os2\thread.c,"static void vlc_cancel_self (PVOID self)
{
    struct vlc_thread *th = self;

    if (likely(th != NULL))
        th->killed = true;
}",654.0,660.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2027,156639,vlc_DosWaitEventSemEx,1,vlc_DosWaitEventSemEx,"ULONG vlc_DosWaitEventSemEx (HEV,ULONG)",os2\thread.c,"static ULONG vlc_DosWaitEventSemEx( HEV hev, ULONG ulTimeout )
{
    HMUX      hmux;
    SEMRECORD asr[ 2 ];
    ULONG     ulUser;
    int       n;
    ULONG     rc;

    struct vlc_thread *th = vlc_thread_self ();
    if( th == NULL || !th->killable )
    {
        /* Main thread - cannot be cancelled anyway
         * Alien thread - out of our control
         * Cancel disabled thread - ignore cancel
         */
        if( hev != NULLHANDLE )
            return DosWaitEventSem( hev, ulTimeout );

        return DosSleep( ulTimeout );
    }

    n = 0;
    if( hev != NULLHANDLE )
    {
        asr[ n ].hsemCur = ( HSEM )hev;
        asr[ n ].ulUser  = 0;
        n++;
    }
    asr[ n ].hsemCur = ( HSEM )th->cancel_event;
    asr[ n ].ulUser  = 0xFFFF;
    n++;

    DosCreateMuxWaitSem( NULL, &hmux, n, asr, DCMW_WAIT_ANY );
    rc = DosWaitMuxWaitSem( hmux, ulTimeout, &ulUser );
    DosCloseMuxWaitSem( hmux );
    if( rc )
        return rc;

    if( ulUser == 0xFFFF )
    {
      ...",72.0,117.0,1.0,1.0,46.0,29,11,40,13,2,4,6,7,1,2,,0,3,4,2,2,ULONG
2028,156754,vlc_WaitForSingleObject,1,vlc_WaitForSingleObject,"ULONG vlc_WaitForSingleObject (HEV,ULONG)",os2\thread.c,"static ULONG vlc_WaitForSingleObject (HEV hev, ULONG ulTimeout)
{
    return vlc_DosWaitEventSemEx( hev, ulTimeout );
}",119.0,122.0,1.0,1.0,4.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,ULONG
2029,156764,vlc_Sleep,1,vlc_Sleep,ULONG vlc_Sleep (ULONG),os2\thread.c,"static ULONG vlc_Sleep (ULONG ulTimeout)
{
    ULONG rc = vlc_DosWaitEventSemEx( NULLHANDLE, ulTimeout );

    return ( rc != ERROR_TIMEOUT ) ? rc : 0;
}",124.0,129.0,1.0,1.0,6.0,3,3,6,4,0,1,1,1,0,1,,0,1,2,1,1,ULONG
2030,157012,vlc_static_cond_init,1,vlc_static_cond_init,void vlc_static_cond_init (vlc_cond_t*),os2\thread.c,"static void vlc_static_cond_init (vlc_cond_t *p_condvar)
{
    vlc_mutex_lock (&super_mutex);

    if (p_condvar->hev == NULLHANDLE)
    {
        vlc_cond_init (p_condvar);

        vlc_static_cond_t *new_static_condvar;

        new_static_condvar = malloc (sizeof (*new_static_condvar));
        if (unlikely (!new_static_condvar))
            abort();

        memcpy (&new_static_condvar->condvar, p_condvar, sizeof (*p_condvar));
        new_static_condvar->next = static_condvar_start;
        static_condvar_start = new_static_condvar;
    }

    vlc_mutex_unlock (&super_mutex);
}",269.0,289.0,1.0,1.0,21.0,15,7,15,5,0,9,3,4,0,3,,0,6,2,1,1,void
2031,157217,vlc_cond_wait_common,1,vlc_cond_wait_common,"int vlc_cond_wait_common (vlc_cond_t*,vlc_mutex_t*,ULONG)",os2\thread.c,"static int vlc_cond_wait_common (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                                 ULONG ulTimeout)
{
    ULONG ulPost;
    ULONG rc;

    assert(p_condvar->hev != NULLHANDLE);

    do
    {
        vlc_testcancel();

        __atomic_increment (&p_condvar->waiters);

        vlc_mutex_unlock (p_mutex);

        do
        {
            rc = vlc_WaitForSingleObject( p_condvar->hev, ulTimeout );
            if (rc == NO_ERROR)
                DosResetEventSem (p_condvar->hev, &ulPost);
        } while (rc == NO_ERROR &&
                 __atomic_cmpxchg32 (&p_condvar->signaled, 0, 1) == 0);

        __atomic_decrement (&p_condvar->waiters);

        DosPostEventSem (p_condvar->hevAck);

        vlc_mutex_lock (p_mutex);
    } while( rc == ERROR_INTERRUPT );

    return rc ? ETIMEDOUT : 0;
}",354.0,386.0,1.0,1.0,33.0,19,7,21,9,0,4,4,7,0,4,,0,1,6,3,3,int
2032,157601,vlc_thread_cleanup,1,vlc_thread_cleanup,void vlc_thread_cleanup (vlc_thread*),os2\thread.c,"static void vlc_thread_cleanup (struct vlc_thread *th)
{
    vlc_threadvar_t key;

retry:
    /* TODO: use RW lock or something similar */
    vlc_mutex_lock (&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get (key);
        if (value != NULL && key->destroy != NULL)
        {
            vlc_mutex_unlock (&super_mutex);
            vlc_threadvar_set (key, NULL);
            key->destroy (value);
            goto retry;
        }
    }
    vlc_mutex_unlock (&super_mutex);

    if (th->detached)
    {
        DosCloseEventSem (th->cancel_event);
        DosCloseEventSem (th->done_event );

        soclose (th->cancel_sock);

        free (th);
    }
}",506.0,535.0,1.0,1.0,30.0,15,5,22,6,1,13,5,5,1,5,,0,9,2,1,1,void
2033,157675,vlc_entry,1,vlc_entry,void vlc_entry (void*),win32\thread.c,"static
#if VLC_WINSTORE_APP
DWORD
#else // !VLC_WINSTORE_APP
unsigned
#endif // !VLC_WINSTORE_APP
__stdcall vlc_entry (void *p)
{
    struct vlc_thread *th = p;

    TlsSetValue(thread_key, th);
    th->killable = true;
    th->data = th->entry (th->data);
    TlsSetValue(thread_key, NULL);

    if (th->id == NULL) /* Detached thread */
        vlc_thread_destroy(th);
    return 0;
}",464.0,482.0,1.0,28.0,19.0,8,2,11,4,0,8,1,1,0,3,,0,6,2,1,1,unsigned
2034,158205,vlc_select,1,vlc_select,"int vlc_select (int,fd_set*,fd_set*,fd_set*,timeval*)",os2\thread.c,"static int vlc_select( int nfds, fd_set *rdset, fd_set *wrset, fd_set *exset,
                       struct timeval *timeout )
{
    struct vlc_thread *th = vlc_thread_self( );

    int rc;

    if( th )
    {
        FD_SET( th->cancel_sock, rdset );

        nfds = MAX( nfds, th->cancel_sock + 1 );
    }

    rc = select( nfds, rdset, wrset, exset, timeout );

    vlc_testcancel();

    return rc;

}",748.0,768.0,1.0,1.0,21.0,6,3,14,7,0,4,2,2,0,2,,0,3,10,5,5,int
2035,158666,func,1,vlc_timer.func,void vlc_timer.func (void*),os2\thread.c,void (*func) (void *);,917.0,917.0,10.0,25.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
2036,158672,vlc_timer_do,1,vlc_timer_do,void vlc_timer_do (void*),os2\thread.c,"static void vlc_timer_do (void *arg)
{
    struct vlc_timer *timer = arg;

    while (1)
    {
        ULONG count;

        DosWaitEventSem (timer->hev, SEM_INDEFINITE_WAIT);
        DosResetEventSem (timer->hev, &count);

        if (timer->quit)
            break;

        timer->func (timer->data);

        if (timer->interval)
            DosAsyncTimer (timer->interval, (HSEM)timer->hev, &timer->htimer);
    }
}",921.0,940.0,1.0,1.0,20.0,13,4,13,4,0,9,5,6,2,1,,0,8,2,1,1,void
2037,158727,vlc_timer_create,1,vlc_timer_create,"int vlc_timer_create (vlc_timer_t*,void,void*)",win32\timer.c,"int vlc_timer_create (vlc_timer_t *id, void (*func) (void *), void *data)
{
    struct vlc_timer *timer = malloc (sizeof (*timer));

    if (timer == NULL)
        return ENOMEM;
    timer->func = func;
    timer->data = data;
    timer->handle = INVALID_HANDLE_VALUE;
    *id = timer;
    return 0;
}",45.0,56.0,1.0,1.0,12.0,21,7,23,10,0,6,2,2,0,0,,0,6,6,3,3,int
2038,158835,vlc_timer_schedule,1,vlc_timer_schedule,"void vlc_timer_schedule (vlc_timer_t,bool,mtime_t,mtime_t)",win32\timer.c,"void vlc_timer_schedule (vlc_timer_t timer, bool absolute,
                         mtime_t value, mtime_t interval)
{
    if (timer->handle != INVALID_HANDLE_VALUE)
    {
        DeleteTimerQueueTimer (NULL, timer->handle, INVALID_HANDLE_VALUE);
        timer->handle = INVALID_HANDLE_VALUE;
    }
    if (value == 0)
        return; /* Disarm */

    if (absolute)
    {
        value -= mdate ();
        if (value < 0)
            value = 0;
    }
    value = (value + 999) / 1000;
    interval = (interval + 999) / 1000;

    if (!CreateTimerQueueTimer (&timer->handle, NULL, vlc_timer_do, timer,
                                value, interval, WT_EXECUTEDEFAULT))
        abort ();
}",65.0,88.0,1.0,1.0,24.0,21,9,18,5,0,1,5,5,0,1,,0,0,8,4,4,void
2039,158956,playlist_GetAout,1,playlist_GetAout,audio_output_t playlist_GetAout (playlist_t*),playlist\aout.c,"audio_output_t *playlist_GetAout(playlist_t *pl)
{
    /* NOTE: it is assumed that the input resource exists. In practice,
     * the playlist must have been activated. This is automatic when calling
     * pl_Get(). FIXME: input resources are deleted at deactivation, this can
     * be too early. */
    playlist_private_t *sys = pl_priv(pl);
    return input_resource_HoldAout(sys->p_input_resource);
}",36.0,44.0,1.0,30.0,9.0,2,2,6,4,6,2,1,1,0,1,,0,1,2,1,1,audio_output_t
2040,158976,playlist_VolumeGet,1,playlist_VolumeGet,float playlist_VolumeGet (playlist_t*),playlist\aout.c,"float playlist_VolumeGet (playlist_t *pl)
{
    float volume = -1.f;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        volume = aout_VolumeGet (aout);
        vlc_object_release (aout);
    }
    return volume;
}",46.0,57.0,1.0,1.0,12.0,5,3,9,4,0,3,2,2,0,3,,0,2,2,1,1,float
2041,159004,playlist_VolumeSet,1,playlist_VolumeSet,"int playlist_VolumeSet (playlist_t*,float)",playlist\aout.c,"int playlist_VolumeSet (playlist_t *pl, float vol)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeSet (aout, vol);
        vlc_object_release (aout);
    }
    return ret;
}",59.0,70.0,1.0,1.0,12.0,5,3,10,5,0,3,2,2,0,3,,0,2,4,2,2,int
2042,159034,playlist_VolumeUp,1,playlist_VolumeUp,"int playlist_VolumeUp (playlist_t*,int,float*)",playlist\aout.c,"int playlist_VolumeUp (playlist_t *pl, int value, float *volp)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_VolumeUpdate (aout, value, volp);
        vlc_object_release (aout);
    }
    return ret;
}",77.0,88.0,1.0,1.0,12.0,5,3,11,6,0,3,2,2,0,3,,0,2,6,3,3,int
2043,159066,playlist_MuteGet,1,playlist_MuteGet,int playlist_MuteGet (playlist_t*),playlist\aout.c,"int playlist_MuteGet (playlist_t *pl)
{
    int mute = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        mute = aout_MuteGet (aout);
        vlc_object_release (aout);
    }
    return mute;
}",90.0,101.0,1.0,1.0,12.0,5,3,9,4,0,3,2,2,0,3,,0,2,2,1,1,int
2044,159094,playlist_MuteSet,1,playlist_MuteSet,"int playlist_MuteSet (playlist_t*,bool)",playlist\aout.c,"int playlist_MuteSet (playlist_t *pl, bool mute)
{
    int ret = -1;

    audio_output_t *aout = playlist_GetAout (pl);
    if (aout != NULL)
    {
        ret = aout_MuteSet (aout, mute);
        vlc_object_release (aout);
    }
    return ret;
}",103.0,114.0,1.0,1.0,12.0,5,3,10,5,0,3,2,2,0,3,,0,2,4,2,2,int
2045,159124,playlist_EnableAudioFilter,1,playlist_EnableAudioFilter,"void playlist_EnableAudioFilter (playlist_t*,char*,bool)",playlist\aout.c,"void playlist_EnableAudioFilter (playlist_t *pl, const char *name, bool add)
{
    audio_output_t *aout = playlist_GetAout (pl);

    aout_ChangeFilterString (VLC_OBJECT(pl), aout ? VLC_OBJECT(aout) : NULL,
                             ""audio-filter"", name, add);
    if (aout != NULL)
        vlc_object_release (aout);
}",116.0,124.0,1.0,1.0,9.0,3,3,11,5,0,3,2,2,0,3,,0,1,6,3,3,void
2046,159179,ArtCacheCreateDir,1,ArtCacheCreateDir,void ArtCacheCreateDir (char*),playlist\art.c,"static void ArtCacheCreateDir( const char *psz_dir )
{
    char newdir[strlen( psz_dir ) + 1];
    strcpy( newdir, psz_dir );
    char * psz_newdir = newdir;
    char * psz = psz_newdir;

    while( *psz )
    {
        while( *psz && *psz != DIR_SEP_CHAR) psz++;
        if( !*psz ) break;
        *psz = 0;
        if( !EMPTY_STR( psz_newdir ) )
            vlc_mkdir( psz_newdir, 0700 );
        *psz = DIR_SEP_CHAR;
        psz++;
    }
    vlc_mkdir( psz_dir, 0700 );
}",41.0,59.0,1.0,1.0,19.0,15,6,18,5,2,2,6,8,0,2,,0,0,2,1,1,void
2047,159237,ArtCacheGetDirPath,1,ArtCacheGetDirPath,"char* ArtCacheGetDirPath (char*,char*,char*,char*)",playlist\art.c,"static char* ArtCacheGetDirPath( const char *psz_arturl, const char *psz_artist,
                                 const char *psz_album,  const char *psz_title )
{
    char *psz_dir;
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);

    if( !EMPTY_STR(psz_artist) && !EMPTY_STR(psz_album) )
    {
        char *psz_album_sanitized = strdup( psz_album );
        filename_sanitize( psz_album_sanitized );
        char *psz_artist_sanitized = strdup( psz_artist );
        filename_sanitize( psz_artist_sanitized );
        if( asprintf( &psz_dir, ""%s"" DIR_SEP ""art"" DIR_SEP ""artistalbum""
                      DIR_SEP ""%s"" DIR_SEP ""%s"", psz_cachedir,
                      psz_artist_sanitized, psz_album_sanitized ) == -1 )
            psz_dir = NULL;
        free( psz_album_sanitized );
        free( psz_artist_sanitized );
    }
    else
    {
        /* If artist or album are missing, cache by art download URL.
         * If the URL is an attachment://, add the title to the cache...",61.0,104.0,1.0,1.0,44.0,7,3,16,8,1,3,3,4,0,3,,0,1,8,4,4,char*
2048,159330,ArtCachePath,1,ArtCachePath,char* ArtCachePath (input_item_t*),playlist\art.c,"static char *ArtCachePath( input_item_t *p_item )
{
    char* psz_path = NULL;
    const char *psz_artist;
    const char *psz_album;
    const char *psz_arturl;
    const char *psz_title;

    vlc_mutex_lock( &p_item->lock );

    if( !p_item->p_meta )
        p_item->p_meta = vlc_meta_New();
    if( !p_item->p_meta )
        goto end;

    psz_artist = vlc_meta_Get( p_item->p_meta, vlc_meta_Artist );
    psz_album = vlc_meta_Get( p_item->p_meta, vlc_meta_Album );
    psz_arturl = vlc_meta_Get( p_item->p_meta, vlc_meta_ArtworkURL );
    psz_title = vlc_meta_Get( p_item->p_meta, vlc_meta_Title );
    if( !psz_title )
        psz_title = p_item->psz_name;


    if( (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album) ) && !psz_arturl )
        goto end;

    psz_path = ArtCacheGetDirPath( psz_arturl, psz_artist, psz_album, psz_title );

end:
    vlc_mutex_unlock( &p_item->lock );
    return psz_path;
}",106.0,137.0,1.0,1.0,32.0,26,6,31,11,2,8,7,5,0,8,,0,6,2,1,1,char*
2049,159429,ArtCacheName,1,ArtCacheName,"char* ArtCacheName (input_item_t*,char*)",playlist\art.c,"static char *ArtCacheName( input_item_t *p_item, const char *psz_type )
{
    char *psz_path = ArtCachePath( p_item );
    char *psz_ext = strdup( psz_type ? psz_type : """" );
    char *psz_filename = NULL;

    if( unlikely( !psz_path || !psz_ext ) )
        goto end;

    ArtCacheCreateDir( psz_path );
    filename_sanitize( psz_ext );

    if( asprintf( &psz_filename, ""%s"" DIR_SEP ""art%s"", psz_path, psz_ext ) < 0 )
        psz_filename = NULL;

end:
    free( psz_ext );
    free( psz_path );

    return psz_filename;
}",139.0,159.0,1.0,1.0,21.0,8,4,16,6,1,3,4,3,0,3,,0,1,4,2,2,char*
2050,159478,playlist_FindArtInCache,1,playlist_FindArtInCache,int playlist_FindArtInCache (input_item_t*),playlist\art.c,"int playlist_FindArtInCache( input_item_t *p_item )
{
    char *psz_path = ArtCachePath( p_item );

    if( !psz_path )
        return VLC_EGENERIC;

    /* Check if file exists */
    DIR *p_dir = vlc_opendir( psz_path );
    if( !p_dir )
    {
        free( psz_path );
        return VLC_EGENERIC;
    }

    bool b_found = false;
    const char *psz_filename;
    while( !b_found && (psz_filename = vlc_readdir( p_dir )) )
    {
        if( !strncmp( psz_filename, ""art"", 3 ) )
        {
            char *psz_file;
            if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"",
                          psz_path, psz_filename ) != -1 )
            {
                char *psz_uri = vlc_path2uri( psz_file, ""file"" );
                if( psz_uri )
                {
                    input_item_SetArtURL( p_item, psz_uri );
                    free( psz_uri );
                }
                free( psz_file );
            }

            b_found = true;
        }
    }

    /* */
    closedir( ...",162.0,204.0,1.0,1.0,43.0,12,4,29,11,1,4,7,13,1,4,,0,4,2,1,1,int
2051,159560,GetDirByItemUIDs,1,GetDirByItemUIDs,char* GetDirByItemUIDs (char*),playlist\art.c,"static char * GetDirByItemUIDs( char *psz_uid )
{
    char *psz_cachedir = config_GetUserDir(VLC_CACHE_DIR);
    char *psz_dir;
    if( asprintf( &psz_dir, ""%s"" DIR_SEP
                  ""by-iiuid"" DIR_SEP
                  ""%s"",
                  psz_cachedir, psz_uid ) == -1 )
    {
        psz_dir = NULL;
    }
    free( psz_cachedir );
    return psz_dir;
}",206.0,219.0,1.0,1.0,14.0,2,1,6,4,2,1,2,2,0,1,,0,1,2,1,1,char*
2052,159581,GetFileByItemUID,1,GetFileByItemUID,"char* GetFileByItemUID (char*,char*)",playlist\art.c,"static char * GetFileByItemUID( char *psz_dir, const char *psz_type )
{
    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""%s"", psz_dir, psz_type ) == -1 )
    {
        psz_file = NULL;
    }
    return psz_file;
}",221.0,229.0,1.0,1.0,9.0,1,1,3,2,2,0,2,2,0,0,,0,0,4,2,2,char*
2053,159596,playlist_FindArtInCacheUsingItemUID,1,playlist_FindArtInCacheUsingItemUID,int playlist_FindArtInCacheUsingItemUID (input_item_t*),playlist\art.c,"int playlist_FindArtInCacheUsingItemUID( input_item_t *p_item )
{
    char *uid = input_item_GetInfo( p_item, ""uid"", ""md5"" );
    if ( ! *uid )
    {
        free( uid );
        return VLC_EGENERIC;
    }

    /* we have an input item uid set */
    bool b_done = false;
    char *psz_byuiddir = GetDirByItemUIDs( uid );
    char *psz_byuidfile = GetFileByItemUID( psz_byuiddir, ""arturl"" );
    free( psz_byuiddir );
    if( psz_byuidfile )
    {
        FILE *fd = vlc_fopen( psz_byuidfile, ""rb"" );
        if ( fd )
        {
            char sz_cachefile[2049];
            /* read the cache hash url */
            if ( fgets( sz_cachefile, 2048, fd ) != NULL )
            {
                input_item_SetArtURL( p_item, sz_cachefile );
                b_done = true;
            }
            fclose( fd );
        }
        free( psz_byuidfile );
    }
    free( uid );
    if ( b_done ) return VLC_SUCCESS;

    return VLC_EGENERIC;
}",231.0,265.0,1.0,1.0,35.0,9,4,29,12,1,4,6,9,0,4,,0,4,2,1,1,int
2054,159674,playlist_SaveArt,1,playlist_SaveArt,"int playlist_SaveArt (vlc_object_t*,input_item_t*,void*,size_t,char*)",playlist\art.c,"int playlist_SaveArt( vlc_object_t *obj, input_item_t *p_item,
                      const void *data, size_t length, const char *psz_type )
{
    char *psz_filename = ArtCacheName( p_item, psz_type );

    if( !psz_filename )
        return VLC_EGENERIC;

    char *psz_uri = vlc_path2uri( psz_filename, ""file"" );
    if( !psz_uri )
    {
        free( psz_filename );
        return VLC_EGENERIC;
    }

    /* Check if we already dumped it */
    struct stat s;
    if( !vlc_stat( psz_filename, &s ) )
    {
        input_item_SetArtURL( p_item, psz_uri );
        free( psz_filename );
        free( psz_uri );
        return VLC_SUCCESS;
    }

    /* Dump it otherwise */
    FILE *f = vlc_fopen( psz_filename, ""wb"" );
    if( f )
    {
        if( fwrite( data, 1, length, f ) != length )
        {
            msg_Err( obj, ""%s: %s"", psz_filename, vlc_strerror_c(errno) );
        }
        else
        {
            msg_Dbg( obj, ""album art saved to %s"", psz_filename );
            inpu...",268.0,340.0,1.0,1.0,73.0,17,7,54,15,1,11,11,14,1,11,,0,8,10,5,5,int
2055,159873,playlist_Lock,1,playlist_Lock,void playlist_Lock (playlist_t*),playlist\control.c,"void playlist_Lock( playlist_t *pl )
{
    vlc_mutex_lock( &pl_priv(pl)->lock );
}",37.0,40.0,1.0,21.0,4.0,2,2,4,3,10,1,1,1,0,1,,0,0,2,1,1,void
2056,159889,playlist_Unlock,1,playlist_Unlock,void playlist_Unlock (playlist_t*),playlist\control.c,"void playlist_Unlock( playlist_t *pl )
{
    vlc_mutex_unlock( &pl_priv(pl)->lock );
}",42.0,45.0,1.0,23.0,4.0,2,2,4,3,12,1,1,1,0,1,,0,0,2,1,1,void
2057,159921,playlist_vaControl,1,playlist_vaControl,"void playlist_vaControl (playlist_t*,int,bool,va_list)",playlist\control.c,"static void playlist_vaControl( playlist_t *p_playlist, int i_query,
                                bool locked, va_list args )
{
    PL_LOCK_IF( !locked );

    if( pl_priv(p_playlist)->killed )
        ;
    else
    switch( i_query )
    {
    case PLAYLIST_STOP:
        pl_priv(p_playlist)->request.b_request = true;
        pl_priv(p_playlist)->request.p_item = NULL;
        pl_priv(p_playlist)->request.p_node = NULL;
        break;

    // Node can be null, it will keep the same. Use with care ...
    // Item null = take the first child of node
    case PLAYLIST_VIEWPLAY:
    {
        playlist_item_t *p_node = va_arg( args, playlist_item_t * );
        playlist_item_t *p_item = va_arg( args, playlist_item_t * );

        assert( locked || (p_item == NULL && p_node == NULL) );

        if ( p_node == NULL )
        {
            p_node = get_current_status_node( p_playlist );
            assert( p_node );
        }
        pl_priv(p_playlist)->request.i_skip = 0;
        pl_pr...",52.0,139.0,1.0,4.0,88.0,7,3,14,4,1,3,2,2,0,3,,0,0,8,4,4,void
2058,160413,playlist_Control,1,playlist_Control,"void playlist_Control (playlist_t*,int,int...)",playlist\control.c,"void playlist_Control( playlist_t *p_playlist, int query, int locked, ... )
{
    va_list args;

    va_start( args, locked );
    playlist_vaControl( p_playlist, query, (bool)locked, args );
    va_end( args );
}",141.0,148.0,1.0,1.0,8.0,1,1,7,4,3,1,1,1,0,1,,0,0,6,3,3,void
2059,160462,VariablesInit,1,VariablesInit,void VariablesInit (playlist_t*),playlist\engine.c,"static void VariablesInit( playlist_t *p_playlist )
{
    /* These variables control updates */
    var_Create( p_playlist, ""item-change"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""leaf-to-parent"", VLC_VAR_INTEGER );

    var_Create( p_playlist, ""playlist-item-append"", VLC_VAR_ADDRESS );
    var_Create( p_playlist, ""playlist-item-deleted"", VLC_VAR_ADDRESS );

    var_Create( p_playlist, ""input-current"", VLC_VAR_ADDRESS );

    /* Variables to control playback */
    var_Create( p_playlist, ""playlist-autostart"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""random"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_AddCallback( p_playlist, ""random"", RandomCallback, NULL );
    var_Create( p_playlist, ""repeat"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""loop"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT );
    var_Create( p_playlist, ""corks"", VLC_VAR_INTEGER );
    var_AddCallback( p_playlist, ""corks"", CorksCallback, NULL );

    var_Create( p_playlist, ""...",428.0,483.0,1.0,1.0,56.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2060,160467,RandomCallback,1,RandomCallback,"int RandomCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int RandomCallback( vlc_object_t *p_this, char const *psz_cmd,
                           vlc_value_t oldval, vlc_value_t newval, void *a )
{
    (void)psz_cmd; (void)oldval; (void)newval; (void)a;
    playlist_t *p_playlist = (playlist_t*)p_this;
    bool random = newval.b_bool;

    PL_LOCK;

    if( !random ) {
        pl_priv(p_playlist)->b_reset_currently_playing = true;
        vlc_cond_signal( &pl_priv(p_playlist)->signal );
    } else {
        /* Shuffle and sync the playlist on activation of random mode.
         * This preserves the current playing item, so that the user
         * can return to it if needed. (See #4472)
         */
        playlist_private_t *p_sys = pl_priv(p_playlist);
        playlist_item_t *p_new = p_sys->status.p_item;
        ResetCurrentlyPlaying( p_playlist, NULL );
        if( p_new )
            ResyncCurrentIndex( p_playlist, p_new );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",46.0,72.0,1.0,8.0,27.0,13,6,21,13,0,1,2,2,0,1,,0,0,10,5,5,int
2061,160559,CorksCallback,1,CorksCallback,"int CorksCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int CorksCallback( vlc_object_t *obj, char const *var,
                          vlc_value_t old, vlc_value_t cur, void *dummy )
{
    playlist_t *pl = (playlist_t *)obj;

    msg_Dbg( obj, ""corks count: %""PRId64"" -> %""PRId64, old.i_int, cur.i_int );
    if( !old.i_int == !cur.i_int )
        return VLC_SUCCESS; /* nothing to do */

    if( !var_InheritBool( obj, ""playlist-cork"" ) )
        return VLC_SUCCESS;

    playlist_Lock(pl);

    if( cur.i_int )
    {
        bool effective = playlist_Status(pl) == PLAYLIST_RUNNING;

        msg_Dbg(obj, ""corked (%seffective)"", effective ? """" : ""in"");
        pl_priv(pl)->cork_effective = effective;
        playlist_Control(pl, PLAYLIST_PAUSE, pl_Locked);
    }
    else
    {
        bool effective = pl_priv(pl)->cork_effective;

        msg_Dbg(obj, ""uncorked (%seffective)"", effective ? """" : ""in"");

        if (effective)
            playlist_Control(pl, PLAYLIST_RESUME, pl_Locked);
    }

    playlist_Unlock(pl);
    (void) var; (v...",80.0,115.0,1.0,8.0,36.0,16,7,26,13,0,4,4,4,0,4,,0,1,10,5,5,int
2062,160899,VideoSplitterCallback,1,VideoSplitterCallback,"int VideoSplitterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",playlist\engine.c,"static int VideoSplitterCallback( vlc_object_t *p_this, char const *psz_cmd,
                                  vlc_value_t oldval, vlc_value_t newval, void *p_data )
{
    playlist_t *p_playlist = (playlist_t*)p_this;
    VLC_UNUSED(psz_cmd); VLC_UNUSED(oldval); VLC_UNUSED(p_data); VLC_UNUSED(newval);

    PL_LOCK;

    /* Force the input to restart the video ES to force a vout recreation */
    input_thread_t *p_input = pl_priv( p_playlist )->p_input;
    if( p_input )
    {
        const double f_position = var_GetFloat( p_input, ""position"" );
        input_Control( p_input, INPUT_RESTART_ES, -VIDEO_ES );
        var_SetFloat( p_input, ""position"", f_position );
    }

    PL_UNLOCK;
    return VLC_SUCCESS;
}",169.0,188.0,1.0,30.0,20.0,6,4,22,15,0,1,2,2,0,1,,0,0,10,5,5,int
2063,160956,playlist_Create,1,playlist_Create,playlist_t playlist_Create (vlc_object_t*),playlist\engine.c,"playlist_t *playlist_Create( vlc_object_t *p_parent )
{
    playlist_t *p_playlist;
    playlist_private_t *p;

    /* Allocate structure */
    p = vlc_custom_create( p_parent, sizeof( *p ), ""playlist"" );
    if( !p )
        return NULL;

    p_playlist = &p->public_data;

    p->input_tree = NULL;
    p->id_tree = NULL;

    TAB_INIT( pl_priv(p_playlist)->i_sds, pl_priv(p_playlist)->pp_sds );

    VariablesInit( p_playlist );
    vlc_mutex_init( &p->lock );
    vlc_cond_init( &p->signal );
    p->killed = false;

    /* Initialise data structures */
    pl_priv(p_playlist)->i_last_playlist_id = 0;
    pl_priv(p_playlist)->p_input = NULL;

    ARRAY_INIT( p_playlist->items );
    ARRAY_INIT( p_playlist->current );

    p_playlist->i_current_index = 0;
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    pl_priv(p_playlist)->b_tree = var_InheritBool( p_parent, ""playlist-tree"" );
    pl_priv(p_playlist)->b_preparse = var_InheritBool( p_parent, ""auto-preparse"" );

    p_pl...",197.0,303.0,1.0,14.0,107.0,97,10,133,21,1,24,10,11,1,14,,0,16,2,1,1,playlist_t
2064,161356,playlist_Destroy,1,playlist_Destroy,void playlist_Destroy (playlist_t*),playlist\engine.c,"void playlist_Destroy( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    /* Remove all services discovery */
    playlist_ServicesDiscoveryKillAll( p_playlist );

    msg_Dbg( p_playlist, ""destroying"" );

    playlist_Deactivate( p_playlist );

    /* Release input resources */
    assert( p_sys->p_input == NULL );
    input_resource_Release( p_sys->p_input_resource );
    if( p_sys->p_renderer )
        vlc_renderer_item_release( p_sys->p_renderer );

    if( p_playlist->p_media_library != NULL )
        playlist_MLDump( p_playlist );

    PL_LOCK;
    /* Release the current node */
    set_current_status_node( p_playlist, NULL );
    /* Release the current item */
    set_current_status_item( p_playlist, NULL );

    /* Destroy arrays completely - faster than one item at a time */
    ARRAY_RESET( p_playlist->items );
    ARRAY_RESET( p_playlist->current );

    /* Remove all remaining items */
    if( p_playlist->p_media_library != NULL )
    {
...",312.0,366.0,1.0,32.0,55.0,22,7,39,8,1,19,5,5,1,13,,0,6,2,1,1,void
2065,161479,playlist_CurrentInputLocked,1,playlist_CurrentInputLocked,input_thread_t playlist_CurrentInputLocked (playlist_t*),playlist\engine.c,"input_thread_t *playlist_CurrentInputLocked( playlist_t *p_playlist )
{
    PL_ASSERT_LOCKED;

    input_thread_t *p_input = pl_priv(p_playlist)->p_input;
    if( p_input != NULL )
        vlc_object_hold( p_input );
    return p_input;
}",370.0,378.0,1.0,30.0,9.0,3,3,10,6,1,1,2,2,0,1,,0,0,2,1,1,input_thread_t
2066,161506,playlist_CurrentInput,1,playlist_CurrentInput,input_thread_t playlist_CurrentInput (playlist_t*),playlist\engine.c,"input_thread_t * playlist_CurrentInput( playlist_t * p_playlist )
{
    input_thread_t * p_input;
    PL_LOCK;
    p_input = playlist_CurrentInputLocked( p_playlist );
    PL_UNLOCK;
    return p_input;
}",383.0,390.0,1.0,1.0,8.0,1,1,5,4,0,1,1,1,0,1,,0,1,2,1,1,input_thread_t
2067,161520,get_current_status_item,1,get_current_status_item,playlist_item_t get_current_status_item (playlist_t*),playlist\engine.c,"playlist_item_t * get_current_status_item( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_item;
}",398.0,403.0,1.0,11.0,6.0,2,2,5,4,2,0,1,1,0,0,,0,0,2,1,1,playlist_item_t
2068,161538,get_current_status_node,1,get_current_status_node,playlist_item_t get_current_status_node (playlist_t*),playlist\engine.c,"playlist_item_t * get_current_status_node( playlist_t * p_playlist )
{
    PL_ASSERT_LOCKED;

    return pl_priv(p_playlist)->status.p_node;
}",405.0,410.0,1.0,11.0,6.0,2,2,5,4,1,0,1,1,0,0,,0,0,2,1,1,playlist_item_t
2069,161556,set_current_status_item,1,set_current_status_item,"void set_current_status_item (playlist_t*,playlist_item_t*)",playlist\engine.c,"void set_current_status_item( playlist_t * p_playlist,
    playlist_item_t * p_item )
{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_item = p_item;
}",412.0,418.0,1.0,4.0,7.0,3,3,6,5,2,0,1,1,0,0,,0,0,4,2,2,void
2070,161576,set_current_status_node,1,set_current_status_node,"void set_current_status_node (playlist_t*,playlist_item_t*)",playlist\engine.c,"void set_current_status_node( playlist_t * p_playlist,
    playlist_item_t * p_node )
{
    PL_ASSERT_LOCKED;

    pl_priv(p_playlist)->status.p_node = p_node;
}",420.0,426.0,1.0,4.0,7.0,3,3,6,5,2,0,1,1,0,0,,0,0,4,2,2,void
2071,161802,playlist_Status,1,playlist_Status,int playlist_Status (playlist_t*),playlist\engine.c,"int playlist_Status( playlist_t * p_playlist )
{
    input_thread_t *p_input = pl_priv(p_playlist)->p_input;

    PL_ASSERT_LOCKED;

    if( p_input == NULL )
        return PLAYLIST_STOPPED;
    if( var_GetInteger( p_input, ""state"" ) == PAUSE_S )
        return PLAYLIST_PAUSED;
    return PLAYLIST_RUNNING;
}",492.0,503.0,1.0,30.0,12.0,4,3,13,10,1,0,3,3,0,0,,0,0,2,1,1,int
2072,161891,pf_worker,1,fetcher_thread.pf_worker,"void fetcher_thread.pf_worker (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"void (*pf_worker)( playlist_fetcher_t*, struct fetcher_request* );",61.0,61.0,10.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2073,161905,CreateCacheKey,1,CreateCacheKey,char* CreateCacheKey (input_item_t*),playlist\fetcher.c,"static char* CreateCacheKey( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );

    if( !item->p_meta )
    {
        vlc_mutex_unlock( &item->lock );
        return NULL;
    }

    char const* artist = vlc_meta_Get( item->p_meta, vlc_meta_Artist );
    char const* album = vlc_meta_Get( item->p_meta, vlc_meta_Album );
    char* key;

    /**
     * Simple concatenation of artist and album can lead to the same key
     * for entities that should not have such. Imagine { dogs, tick } and
     * { dog, stick } */
    if( !artist || !album || asprintf( &key, ""%s:%zu:%s:%zu"",
          artist, strlen( artist ), album, strlen( album ) ) < 0 )
    {
        key = NULL;
    }
    vlc_mutex_unlock( &item->lock );

    return key;
}",72.0,98.0,1.0,1.0,27.0,19,6,21,7,2,5,3,3,0,5,,0,2,2,1,1,char*
2074,161985,ReadAlbumCache,1,ReadAlbumCache,"int ReadAlbumCache (playlist_fetcher_t*,input_item_t*)",playlist\fetcher.c,"static int ReadAlbumCache( playlist_fetcher_t* fetcher, input_item_t* item )
{
    char* key = CreateCacheKey( item );

    if( key == NULL )
        return VLC_EGENERIC;

    vlc_mutex_lock( &fetcher->lock );
    char const* art = vlc_dictionary_value_for_key( &fetcher->album_cache,
                                                    key );
    if( art )
        input_item_SetArtURL( item, art );
    vlc_mutex_unlock( &fetcher->lock );

    free( key );
    return art ? VLC_SUCCESS : VLC_EGENERIC;
}",106.0,122.0,1.0,1.0,17.0,10,5,17,7,2,6,3,3,0,3,,0,4,4,2,2,int
2075,162035,AddAlbumCache,1,AddAlbumCache,"void AddAlbumCache (playlist_fetcher_t*,input_item_t*,bool)",playlist\fetcher.c,"static void AddAlbumCache( playlist_fetcher_t* fetcher, input_item_t* item,
                          bool overwrite )
{
    char* art = input_item_GetArtURL( item );
    char* key = CreateCacheKey( item );

    if( key && art && strncasecmp( art, ""attachment://"", 13 ) )
    {
        vlc_mutex_lock( &fetcher->lock );
        if( overwrite || !vlc_dictionary_has_key( &fetcher->album_cache, key ) )
        {
            vlc_dictionary_insert( &fetcher->album_cache, key, art );
            art = NULL;
        }
        vlc_mutex_unlock( &fetcher->lock );
    }

    free( art );
    free( key );
}",124.0,143.0,1.0,1.0,20.0,15,6,19,6,2,7,3,4,1,3,,0,5,6,3,3,void
2076,162097,InvokeModule,1,InvokeModule,"int InvokeModule (playlist_fetcher_t*,input_item_t*,int,char*)",playlist\fetcher.c,"static int InvokeModule( playlist_fetcher_t* fetcher, input_item_t* item,
                         int scope, char const* type )
{
    meta_fetcher_t* mf = vlc_custom_create( fetcher->owner,
                                            sizeof( *mf ), type );
    if( unlikely( !mf ) )
        return VLC_ENOMEM;

    mf->e_scope = scope;
    mf->p_item = item;

    module_t* mf_module = module_need( mf, type, NULL, false );

    if( mf_module )
        module_unneed( mf, mf_module );

    vlc_object_release( mf );

    return VLC_SUCCESS;
}",145.0,164.0,1.0,25.0,20.0,11,5,22,10,2,6,3,3,0,4,,0,4,8,4,4,int
2077,162158,CheckMeta,1,CheckMeta,int CheckMeta (input_item_t*),playlist\fetcher.c,"static int CheckMeta( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Title ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Artist ) ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_Album );
    vlc_mutex_unlock( &item->lock );
    return error;
}",166.0,175.0,1.0,1.0,10.0,16,5,11,5,1,5,1,1,0,5,,0,3,2,1,1,int
2078,162203,CheckArt,1,CheckArt,int CheckArt (input_item_t*),playlist\fetcher.c,"static int CheckArt( input_item_t* item )
{
    vlc_mutex_lock( &item->lock );
    bool error = !item->p_meta ||
                 !vlc_meta_Get( item->p_meta, vlc_meta_ArtworkURL );
    vlc_mutex_unlock( &item->lock );
    return error;
}",177.0,184.0,1.0,1.0,8.0,10,5,7,3,2,3,1,1,0,3,,0,1,2,1,1,int
2079,162234,SearchArt,1,SearchArt,"int SearchArt (playlist_fetcher_t*,input_item_t*,int)",playlist\fetcher.c,"static int SearchArt( playlist_fetcher_t* fetcher, input_item_t* item, int scope)
{
    InvokeModule( fetcher, item, scope, ""art finder"" );
    return CheckArt( item );
}",186.0,190.0,1.0,1.0,5.0,0,0,4,3,1,2,1,1,0,2,,0,0,6,3,3,int
2080,162249,SearchByScope,1,SearchByScope,"int SearchByScope (playlist_fetcher_t*,fetcher_request*,int)",playlist\fetcher.c,"static int SearchByScope( playlist_fetcher_t* fetcher,
    struct fetcher_request* req, int scope )
{
    input_item_t* item = req->item;

    if( CheckMeta( item ) &&
        InvokeModule( fetcher, req->item, scope, ""meta fetcher"" ) )
    {
        return VLC_EGENERIC;
    }

    if( ! CheckArt( item )                            ||
        ! ReadAlbumCache( fetcher, item )             ||
        ! playlist_FindArtInCacheUsingItemUID( item ) ||
        ! playlist_FindArtInCache( item )             ||
        ! SearchArt( fetcher, item, scope ) )
    {
        AddAlbumCache( fetcher, req->item, false );
        if( !background_worker_Push( fetcher->downloader, req, NULL, 0 ) )
            return VLC_SUCCESS;
    }

    return VLC_EGENERIC;
}",192.0,215.0,1.0,1.0,24.0,16,5,23,8,2,13,4,5,10,9,,0,12,6,3,3,int
2081,162320,SetPreparsed,1,SetPreparsed,void SetPreparsed (fetcher_request*),playlist\fetcher.c,"static void SetPreparsed( struct fetcher_request* req )
{
    if( req->preparse_status != -1 )
    {
        input_item_SetPreparsed( req->item, true );
        input_item_SignalPreparseEnded( req->item, req->preparse_status );
    }
}",217.0,224.0,1.0,1.0,8.0,6,3,5,2,4,6,2,2,1,2,,0,4,2,1,1,void
2082,162345,Downloader,1,Downloader,"void Downloader (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"static void Downloader( playlist_fetcher_t* fetcher,
    struct fetcher_request* req )
{
    ReadAlbumCache( fetcher, req->item );

    char *psz_arturl = input_item_GetArtURL( req->item );
    if( !psz_arturl )
        goto error;

    if( !strncasecmp( psz_arturl, ""file://"", 7 ) ||
        !strncasecmp( psz_arturl, ""attachment://"", 13 ) )
        goto out; /* no fetch required */

    stream_t* source = vlc_stream_NewURL( fetcher->owner, psz_arturl );

    if( !source )
        goto error;

    struct vlc_memstream output_stream;
    vlc_memstream_open( &output_stream );

    for( ;; )
    {
        char buffer[2048];

        int read = vlc_stream_Read( source, buffer, sizeof( buffer ) );
        if( read <= 0 )
            break;

        if( (int)vlc_memstream_write( &output_stream, buffer, read ) < read )
            break;
    }

    vlc_stream_Delete( source );

    if( vlc_memstream_close( &output_stream ) )
        goto error;

    if( vlc_killed() )
    {
        free( ou...",226.0,290.0,1.0,1.0,65.0,28,10,41,9,0,20,18,12,3,11,,0,13,4,2,2,void
2083,162495,SearchLocal,1,SearchLocal,"void SearchLocal (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"static void SearchLocal( playlist_fetcher_t* fetcher, struct fetcher_request* req )
{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_LOCAL ) == VLC_SUCCESS )
        return; /* done */

    if( var_InheritBool( fetcher->owner, ""metadata-network-access"" ) ||
        req->options & META_REQUEST_OPTION_SCOPE_NETWORK )
    {
        if( background_worker_Push( fetcher->network, req, NULL, 0 ) )
            SetPreparsed( req );
    }
    else
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",292.0,308.0,1.0,1.0,17.0,6,4,11,6,0,6,4,5,5,3,,0,5,4,2,2,void
2084,162543,SearchNetwork,1,SearchNetwork,"void SearchNetwork (playlist_fetcher_t*,fetcher_request*)",playlist\fetcher.c,"static void SearchNetwork( playlist_fetcher_t* fetcher, struct fetcher_request* req )
{
    if( SearchByScope( fetcher, req, FETCHER_SCOPE_NETWORK ) )
    {
        input_item_SetArtNotFound( req->item, true );
        SetPreparsed( req );
    }
}",310.0,317.0,1.0,1.0,8.0,1,1,6,4,0,4,2,2,1,3,,0,2,4,2,2,void
2085,162562,RequestRelease,1,RequestRelease,void RequestRelease (void*),playlist\fetcher.c,"static void RequestRelease( void* req_ )
{
    struct fetcher_request* req = req_;

    if( atomic_fetch_sub( &req->refs, 1 ) != 1 )
        return;

    input_item_Release( req->item );
    free( req );
}",319.0,328.0,1.0,1.0,10.0,5,4,5,2,1,3,2,2,1,1,,0,2,2,1,1,void
2086,162588,RequestHold,1,RequestHold,void RequestHold (void*),playlist\fetcher.c,"static void RequestHold( void* req_ )
{
    struct fetcher_request* req = req_;
    atomic_fetch_add_explicit( &req->refs, 1, memory_order_relaxed );
}",330.0,334.0,1.0,1.0,5.0,3,3,4,3,0,1,1,1,0,0,,0,1,2,1,1,void
2087,162604,FetcherThread,1,FetcherThread,void* FetcherThread (void*),playlist\fetcher.c,"static void* FetcherThread( void* handle )
{
    struct fetcher_thread* th = handle;
    vlc_interrupt_set( &th->interrupt );

    th->pf_worker( th->fetcher, th->req );

    atomic_store( &th->active, false );
    background_worker_RequestProbe( th->worker );
    return NULL;
}",336.0,346.0,1.0,1.0,11.0,9,3,10,4,0,8,1,1,0,3,,0,5,2,1,1,void*
2088,162640,StartWorker,1,StartWorker,"int StartWorker (playlist_fetcher_t*,void,background_worker*,fetcher_request*,void**)",playlist\fetcher.c,"static int StartWorker( playlist_fetcher_t* fetcher,
    void( *pf_worker )( playlist_fetcher_t*, struct fetcher_request* ),
    struct background_worker* bg, struct fetcher_request* req, void** handle )
{
    struct fetcher_thread* th = malloc( sizeof *th );

    if( unlikely( !th ) )
        return VLC_ENOMEM;

    th->req = req;
    th->worker = bg;
    th->fetcher = fetcher;
    th->pf_worker = pf_worker;

    vlc_interrupt_init( &th->interrupt );
    atomic_init( &th->active, true );

    if( !vlc_clone( &th->thread, FetcherThread, th, VLC_THREAD_PRIORITY_LOW ) )
    {
        *handle = th;
        return VLC_SUCCESS;
    }

    vlc_interrupt_deinit( &th->interrupt );
    free( th );
    return VLC_EGENERIC;
}",348.0,374.0,1.0,1.0,27.0,23,6,24,11,3,10,3,3,2,3,,0,8,10,5,5,int
2089,162737,CloseWorker,1,CloseWorker,"void CloseWorker (void*,void*)",playlist\fetcher.c,"static void CloseWorker( void* fetcher_, void* th_ )
{
    struct fetcher_thread* th = th_;
    VLC_UNUSED( fetcher_ );

    vlc_interrupt_kill( &th->interrupt );
    vlc_join( th->thread, NULL );
    vlc_interrupt_deinit( &th->interrupt );
    free( th );
}",382.0,391.0,1.0,1.0,10.0,6,3,8,4,0,6,1,1,0,3,,0,3,4,2,2,void
2090,162766,StartSearchLocal,1,StartSearchLocal,"int StartSearchLocal (void*,void*,void**)",playlist\fetcher.c,"DEF_STARTER(  SearchLocal, fetcher->local )",398.0,398.0,1.0,43.0,1.0,2,2,6,5,0,2,1,1,0,1,,0,1,6,3,3,int
2091,162786,StartSearchNetwork,1,StartSearchNetwork,"int StartSearchNetwork (void*,void*,void**)",playlist\fetcher.c,"DEF_STARTER(SearchNetwork, fetcher->network )",399.0,399.0,1.0,45.0,1.0,2,2,6,5,0,2,1,1,0,1,,0,1,6,3,3,int
2092,162806,StartDownloader,1,StartDownloader,"int StartDownloader (void*,void*,void**)",playlist\fetcher.c,"DEF_STARTER(   Downloader, fetcher->downloader )",400.0,400.0,1.0,48.0,1.0,2,2,6,5,0,2,1,1,0,1,,0,1,6,3,3,int
2093,162826,WorkerInit,1,WorkerInit,"void WorkerInit (playlist_fetcher_t*,background_worker**,int)",playlist\fetcher.c,"static void WorkerInit( playlist_fetcher_t* fetcher,
    struct background_worker** worker, int( *starter )( void*, void*, void** ) )
{
    struct background_worker_config conf = {
        .default_timeout = 0,
        .pf_start = starter,
        .pf_probe = ProbeWorker,
        .pf_stop = CloseWorker,
        .pf_release = RequestRelease,
        .pf_hold = RequestHold };

    *worker = background_worker_New( fetcher, &conf );
}",402.0,414.0,1.0,1.0,13.0,11,4,11,10,3,1,1,1,0,1,,0,1,6,3,3,void
2094,162868,playlist_fetcher_New,1,playlist_fetcher_New,playlist_fetcher_t playlist_fetcher_New (vlc_object_t*),playlist\fetcher.c,"playlist_fetcher_t* playlist_fetcher_New( vlc_object_t* owner )
{
    playlist_fetcher_t* fetcher = malloc( sizeof( *fetcher ) );

    if( unlikely( !fetcher ) )
        return NULL;

    fetcher->owner = owner;

    WorkerInit( fetcher, &fetcher->local, StartSearchLocal );
    WorkerInit( fetcher, &fetcher->network, StartSearchNetwork );
    WorkerInit( fetcher, &fetcher->downloader, StartDownloader );

    if( unlikely( !fetcher->local || !fetcher->network || !fetcher->downloader ) )
    {
        if( fetcher->local )
            background_worker_Delete( fetcher->local );

        if( fetcher->network )
            background_worker_Delete( fetcher->network );

        if( fetcher->downloader )
            background_worker_Delete( fetcher->downloader );

        free( fetcher );
        return NULL;
    }

    vlc_mutex_init( &fetcher->lock );
    vlc_dictionary_init( &fetcher->album_cache, 0 );

    return fetcher;
}",416.0,448.0,1.0,1.0,33.0,30,7,26,3,1,22,6,9,6,7,,0,15,2,1,1,playlist_fetcher_t
2095,162974,playlist_fetcher_Push,1,playlist_fetcher_Push,"int playlist_fetcher_Push (playlist_fetcher_t*,input_item_t*,input_item_meta_request_option_t,int)",playlist\fetcher.c,"int playlist_fetcher_Push( playlist_fetcher_t* fetcher, input_item_t* item,
    input_item_meta_request_option_t options, int preparse_status )
{
    struct fetcher_request* req = malloc( sizeof *req );

    if( unlikely( !req ) )
        return VLC_ENOMEM;

    req->item = item;
    req->options = options;
    req->preparse_status = preparse_status;

    atomic_init( &req->refs, 1 );
    input_item_Hold( item );

    if( background_worker_Push( fetcher->local, req, NULL, 0 ) )
        SetPreparsed( req );

    RequestRelease( req );
    return VLC_SUCCESS;
}",450.0,470.0,1.0,1.0,21.0,13,6,18,8,2,9,3,3,2,4,,0,6,8,4,4,int
2096,163034,playlist_fetcher_Delete,1,playlist_fetcher_Delete,void playlist_fetcher_Delete (playlist_fetcher_t*),playlist\fetcher.c,"void playlist_fetcher_Delete( playlist_fetcher_t* fetcher )
{
    background_worker_Delete( fetcher->local );
    background_worker_Delete( fetcher->network );
    background_worker_Delete( fetcher->downloader );

    vlc_dictionary_clear( &fetcher->album_cache, FreeCacheEntry, NULL );
    vlc_mutex_destroy( &fetcher->lock );

    free( fetcher );
}",472.0,482.0,1.0,1.0,11.0,7,2,7,2,1,9,1,1,0,4,,0,5,2,1,1,void
2097,163115,playlist_Preparse,1,playlist_Preparse,"void playlist_Preparse (playlist_t*,playlist_item_t*)",playlist\item.c,"static void playlist_Preparse( playlist_t *p_playlist,
                               playlist_item_t *p_item )
{
    playlist_private_t *sys = pl_priv(p_playlist);
    input_item_t *input = p_item->p_input;

    PL_ASSERT_LOCKED;
    /* Preparse if no artist/album info, and hasn't been preparsed already
       and if user has some preparsing option (auto-preparse variable)
       enabled*/
    char *psz_artist = input_item_GetArtist( input );
    char *psz_album = input_item_GetAlbum( input );

    if( sys->b_preparse && !input_item_IsPreparsed( input )
     && (EMPTY_STR(psz_artist) || EMPTY_STR(psz_album)) )
        vlc_MetadataRequest( p_playlist->obj.libvlc, input, 0, -1, p_item );
    free( psz_artist );
    free( psz_album );
}",735.0,753.0,1.0,30.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2098,163121,RecursiveAddIntoParent,1,RecursiveAddIntoParent,"int RecursiveAddIntoParent (playlist_t*,playlist_item_t*,input_item_node_t*,int,bool,playlist_item_t**)",playlist\item.c,"static int RecursiveAddIntoParent (
    playlist_t *p_playlist, playlist_item_t *p_parent,
    input_item_node_t *p_node, int i_pos, bool b_flat,
    playlist_item_t **pp_first_leaf )
{
    *pp_first_leaf = NULL;

    if( p_parent->i_children == -1 ) ChangeToNode( p_playlist, p_parent );

    if( i_pos == PLAYLIST_END ) i_pos = p_parent->i_children;

    for( int i = 0; i < p_node->i_children; i++ )
    {
        input_item_node_t *p_child_node = p_node->pp_children[i];

        playlist_item_t *p_new_item = NULL;
        bool b_children = p_child_node->i_children > 0;

        //Create the playlist item represented by input node, if allowed.
        if( !(b_flat && b_children) )
        {
            p_new_item = playlist_NodeAddInput( p_playlist,
                                                p_child_node->p_item,
                                                p_parent, i_pos );
            if( !p_new_item ) return i_pos;

            i_pos++;
        }
        //Recurse if any ...",776.0,824.0,1.0,1.0,49.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
2099,163131,RecursiveInsertCopy,1,RecursiveInsertCopy,"int RecursiveInsertCopy (playlist_t*,playlist_item_t*,playlist_item_t*,int,bool)",playlist\item.c,"static int RecursiveInsertCopy (
    playlist_t *p_playlist, playlist_item_t *p_item,
    playlist_item_t *p_parent, int i_pos, bool b_flat )
{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );

    if( p_item == p_parent ) return i_pos;

    input_item_t *p_input = p_item->p_input;

    if( p_item->i_children == -1 || !b_flat )
    {
        playlist_item_t *p_new_item = NULL;

        if( p_item->i_children == -1 )
        {
            input_item_t *p_new_input = input_item_Copy( p_input );

            if( likely(p_new_input != NULL) )
            {
                p_new_item = playlist_NodeAddInput( p_playlist, p_new_input,
                                                    p_parent, i_pos );
                input_item_Release( p_new_input );
            }
        }
        else
        {
            vlc_mutex_lock( &p_input->lock );
            p_new_item = playlist_NodeCreate( p_playlist, p_input->psz_name,
                                              ...",826.0,879.0,1.0,1.0,54.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
2100,163140,input_item_add_subitem_tree,1,input_item_add_subitem_tree,"void input_item_add_subitem_tree (vlc_event_t*,void*)",playlist\item.c,"static void input_item_add_subitem_tree ( const vlc_event_t * p_event,
                                          void * user_data )
{
    input_item_t *p_input = p_event->p_obj;
    playlist_t *p_playlist = user_data;
    playlist_private_t *p_sys = pl_priv( p_playlist );
    input_item_node_t *p_new_root = p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;

    playlist_item_t *p_item =
        playlist_ItemGetByInput( p_playlist, p_input );

    assert( p_item != NULL );

    bool b_current = get_current_status_item( p_playlist ) == p_item;
    bool b_autostart = var_GetBool( p_playlist, ""playlist-autostart"" );
    bool b_stop = p_item->i_flags & PLAYLIST_SUBITEM_STOP_FLAG;
    bool b_flat = false;

    p_item->i_flags &= ~PLAYLIST_SUBITEM_STOP_FLAG;

    /* We will have to flatten the tree out if we are in ""the playlist"" node and
    the user setting demands flat playlist */

    if( !pl_priv(p_playlist)->b_tree ) {
        playlist_item_t *p_up = p_item;
        whil...",54.0,224.0,1.0,32.0,171.0,74,13,101,28,0,5,15,22,0,5,,0,3,4,2,2,void
2101,163588,playlist_ItemNewFromInput,1,playlist_ItemNewFromInput,"playlist_item_t playlist_ItemNewFromInput (playlist_t*,input_item_t*)",playlist\item.c,"playlist_item_t *playlist_ItemNewFromInput( playlist_t *p_playlist,
                                              input_item_t *p_input )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t **pp, *p_item;

    p_item = malloc( sizeof( playlist_item_t ) );
    if( unlikely(p_item == NULL) )
        return NULL;

    assert( p_input );

    p_item->p_input = p_input;
    p_item->i_id = p->i_last_playlist_id;
    p_item->p_parent = NULL;
    p_item->i_children = (p_input->i_type == ITEM_TYPE_NODE) ? 0 : -1;
    p_item->pp_children = NULL;
    p_item->i_nb_played = 0;
    p_item->i_flags = 0;

    PL_ASSERT_LOCKED;

    do  /* Find an unused ID for the item */
    {
        if( unlikely(p_item->i_id == INT_MAX) )
            p_item->i_id = 0;

        p_item->i_id++;

        if( unlikely(p_item->i_id == p->i_last_playlist_id) )
            goto error; /* All IDs taken */

        pp = tsearch( p_item, &p->id_tree, playlist_ItemCmpId );
        if( unlikely(pp == NULL...",257.0,330.0,1.0,28.0,74.0,64,11,79,19,2,13,10,10,1,7,,0,6,4,2,2,playlist_item_t
2102,163823,playlist_ItemRelease,1,playlist_ItemRelease,"void playlist_ItemRelease (playlist_t*,playlist_item_t*)",playlist\item.c,"void playlist_ItemRelease( playlist_t *p_playlist, playlist_item_t *p_item )
{
    playlist_private_t *p = pl_priv(p_playlist);

    PL_ASSERT_LOCKED;

    vlc_event_manager_t *p_em = &p_item->p_input->event_manager;

    vlc_event_detach( p_em, vlc_InputItemSubItemTreeAdded,
                      input_item_add_subitem_tree, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemMetaChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemDurationChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemNameChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemInfoChanged,
                      input_item_changed, p_playlist );
    vlc_event_detach( p_em, vlc_InputItemErrorWhenReadingChanged,
                      input_item_changed, p_playlist );

    input_item_Release( p_item->p_input );

    tdelete( p_item, &p->input_tree, playlis...",341.0,368.0,1.0,28.0,28.0,11,3,33,13,0,9,1,1,0,7,,0,2,4,2,2,void
2103,163903,playlist_ItemGetById,1,playlist_ItemGetById,"playlist_item_t playlist_ItemGetById (playlist_t*,int)",playlist\item.c,"playlist_item_t *playlist_ItemGetById( playlist_t *p_playlist , int id )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.i_id = id;
    pp = tfind( &key, &p->id_tree, playlist_ItemCmpId );
    return (pp != NULL) ? *pp : NULL;
}",388.0,397.0,1.0,28.0,10.0,10,7,15,9,0,1,1,1,0,0,,0,1,4,2,2,playlist_item_t
2104,163945,playlist_ItemGetByInput,1,playlist_ItemGetByInput,"playlist_item_t playlist_ItemGetByInput (playlist_t*,input_item_t*)",playlist\item.c,"playlist_item_t *playlist_ItemGetByInput( playlist_t * p_playlist,
                                          const input_item_t *item )
{
    playlist_private_t *p = pl_priv(p_playlist);
    playlist_item_t key, **pp;

    PL_ASSERT_LOCKED;
    key.p_input = (input_item_t *)item;
    pp = tfind( &key, &p->input_tree, playlist_ItemCmpInput );
    return (pp != NULL) ? *pp : NULL;
}",411.0,421.0,1.0,28.0,11.0,11,8,15,9,3,1,1,1,0,0,,0,1,4,2,2,playlist_item_t
2105,163989,playlist_Clear,1,playlist_Clear,"void playlist_Clear (playlist_t*,bool)",playlist\item.c,"void playlist_Clear( playlist_t * p_playlist, bool b_locked )
{
    playlist_item_t *p_root = p_playlist->p_playing;

    PL_LOCK_IF( !b_locked );

    for( int i = p_root->i_children - 1; i >= 0 ;i-- )
        playlist_NodeDelete( p_playlist, p_root->pp_children[i] );

    PL_UNLOCK_IF( !b_locked );
}",430.0,440.0,1.0,4.0,11.0,10,5,11,4,0,2,2,2,0,2,,0,0,4,2,2,void
2106,164039,playlist_Add,1,playlist_Add,"int playlist_Add (playlist_t*,char*,bool)",playlist\item.c,"int playlist_Add( playlist_t *p_playlist, const char *psz_uri, bool play_now )
{
    return playlist_AddExt( p_playlist, psz_uri, NULL, play_now,
                            0, NULL, 0, true );
}",454.0,458.0,1.0,1.0,5.0,0,0,6,5,0,1,1,1,0,1,,0,0,6,3,3,int
2107,164056,playlist_AddExt,1,playlist_AddExt,"int playlist_AddExt (playlist_t*,char*,char*,bool,int,char**,unsigned,bool)",playlist\item.c,"int playlist_AddExt( playlist_t *p_playlist, const char * psz_uri,
                     const char *psz_name, bool play_now,
                     int i_options, const char *const *ppsz_options,
                     unsigned i_option_flags,
                     bool b_playlist )
{
    input_item_t *p_input = input_item_New( psz_uri, psz_name );
    if( !p_input )
        return VLC_ENOMEM;
    input_item_AddOptions( p_input, i_options, ppsz_options, i_option_flags );
    int i_ret = playlist_AddInput( p_playlist, p_input, play_now, b_playlist );
    input_item_Release( p_input );
    return i_ret;
}",473.0,486.0,1.0,1.0,14.0,3,2,16,11,2,3,2,2,0,3,,0,1,16,8,8,int
2108,164097,playlist_AddInput,1,playlist_AddInput,"int playlist_AddInput (playlist_t*,input_item_t*,bool,bool)",playlist\item.c,"int playlist_AddInput( playlist_t* p_playlist, input_item_t *p_input,
                       bool play_now, bool b_playlist )
{
    PL_LOCK;
    playlist_item_t *item = b_playlist ? p_playlist->p_playing
                                       : p_playlist->p_media_library;

    item = playlist_NodeAddInput( p_playlist, p_input, item, PLAYLIST_END );

    if( likely(item != NULL) && play_now )
        playlist_ViewPlay( p_playlist, NULL, item );
    PL_UNLOCK;
    return (item != NULL) ? VLC_SUCCESS : VLC_ENOMEM;
}",497.0,510.0,1.0,1.0,14.0,9,5,21,11,2,1,2,2,0,1,,0,1,8,4,4,int
2109,164144,playlist_NodeAddInput,1,playlist_NodeAddInput,"playlist_item_t playlist_NodeAddInput (playlist_t*,input_item_t*,playlist_item_t*,int)",playlist\item.c,"playlist_item_t * playlist_NodeAddInput( playlist_t *p_playlist,
                                         input_item_t *p_input,
                                         playlist_item_t *p_parent, int i_pos )
{
    PL_ASSERT_LOCKED;

    assert( p_input );
    assert( p_parent && p_parent->i_children != -1 );

    playlist_item_t *p_item = playlist_ItemNewFromInput( p_playlist, p_input );
    if( unlikely(p_item == NULL) )
        return NULL;

    if( p_input->i_type != ITEM_TYPE_NODE )
        ARRAY_APPEND(p_playlist->items, p_item);

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );
    playlist_Preparse( p_playlist, p_item );

    return p_item;
}",523.0,544.0,1.0,1.0,22.0,9,6,22,8,3,4,3,3,0,4,,0,1,8,4,4,playlist_item_t
2110,164202,playlist_NodeAddCopy,1,playlist_NodeAddCopy,"int playlist_NodeAddCopy (playlist_t*,playlist_item_t*,playlist_item_t*,int)",playlist\item.c,"int playlist_NodeAddCopy( playlist_t *p_playlist, playlist_item_t *p_item,
    playlist_item_t *p_parent, int i_pos )
{
    PL_ASSERT_LOCKED;
    assert( p_parent != NULL && p_item != NULL );
    assert( p_parent->i_children > -1 );

    if( i_pos == PLAYLIST_END )
        i_pos = p_parent->i_children;

    bool b_flat = false;

    for( playlist_item_t* p_up = p_parent; p_up; p_up = p_up->p_parent )
    {
        if( p_up == p_playlist->p_playing && !pl_priv(p_playlist)->b_tree )
            b_flat = true;

        if( p_up == p_item )
            /* TODO: We don't support copying a node into itself (yet),
            because we insert items as we copy. Instead, we should copy
            all items first and then insert. */
            return i_pos;
    }

    return RecursiveInsertCopy( p_playlist, p_item, p_parent, i_pos, b_flat );
}",557.0,582.0,1.0,46.0,26.0,18,8,31,13,0,1,5,7,0,1,,0,0,8,4,4,int
2111,164288,playlist_InsertInputItemTree,1,playlist_InsertInputItemTree,"int playlist_InsertInputItemTree (playlist_t*,playlist_item_t*,input_item_node_t*,int,bool)",playlist\item.c,"int playlist_InsertInputItemTree (
    playlist_t *p_playlist, playlist_item_t *p_parent,
    input_item_node_t *p_node, int i_pos, bool b_flat )
{
    return RecursiveAddIntoParent( p_playlist, p_parent, p_node, i_pos, b_flat,
                                   &(playlist_item_t*){ NULL } );
}",597.0,603.0,1.0,1.0,7.0,3,3,6,6,2,1,1,1,0,1,,0,0,10,5,5,int
2112,164309,ItemIndex,1,ItemIndex,int ItemIndex (playlist_item_t*),playlist\item.c,"static int ItemIndex ( playlist_item_t *p_item )
{
    int idx;

    TAB_FIND( p_item->p_parent->i_children,
              p_item->p_parent->pp_children,
              p_item,
              idx );

    return idx;
}",610.0,620.0,1.0,1.0,11.0,4,1,5,2,2,0,1,1,0,0,,0,0,2,1,1,int
2113,164330,playlist_TreeMove,1,playlist_TreeMove,"int playlist_TreeMove (playlist_t*,playlist_item_t*,playlist_item_t*,int)",playlist\item.c,"int playlist_TreeMove( playlist_t * p_playlist, playlist_item_t *p_item,
                       playlist_item_t *p_node, int i_newpos )
{
    PL_ASSERT_LOCKED;

    if( p_node->i_children == -1 ) return VLC_EGENERIC;

    playlist_item_t *p_detach = p_item->p_parent;
    int i_index = ItemIndex( p_item );

    TAB_ERASE(p_detach->i_children, p_detach->pp_children, i_index);

    if( p_detach == p_node && i_index < i_newpos )
        i_newpos--;

    TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
    p_item->p_parent = p_node;

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",633.0,654.0,1.0,4.0,22.0,20,8,31,12,0,2,3,3,0,2,,0,1,8,4,4,int
2114,164417,playlist_TreeMoveMany,1,playlist_TreeMoveMany,"int playlist_TreeMoveMany (playlist_t*,int,playlist_item_t**,playlist_item_t*,int)",playlist\item.c,"int playlist_TreeMoveMany( playlist_t *p_playlist,
                            int i_items, playlist_item_t **pp_items,
                            playlist_item_t *p_node, int i_newpos )
{
    PL_ASSERT_LOCKED;

    if ( p_node->i_children == -1 ) return VLC_EGENERIC;

    for( int i = 0; i < i_items; i++ )
    {
        playlist_item_t *p_item = pp_items[i];
        int i_index = ItemIndex( p_item );
        playlist_item_t *p_parent = p_item->p_parent;
        TAB_ERASE(p_parent->i_children, p_parent->pp_children, i_index);
        if ( p_parent == p_node && i_index < i_newpos ) i_newpos--;
    }
    for( int i = i_items - 1; i >= 0; i-- )
    {
        playlist_item_t *p_item = pp_items[i];
        TAB_INSERT(p_node->i_children, p_node->pp_children, p_item, i_newpos);
        p_item->p_parent = p_node;
    }

    pl_priv( p_playlist )->b_reset_currently_playing = true;
    vlc_cond_signal( &pl_priv( p_playlist )->signal );
    return VLC_SUCCESS;
}",668.0,694.0,1.0,4.0,27.0,29,11,43,15,0,2,5,6,0,2,,0,1,10,5,5,int
2115,164543,playlist_SendAddNotify,1,playlist_SendAddNotify,"void playlist_SendAddNotify (playlist_t*,playlist_item_t*)",playlist\item.c,"void playlist_SendAddNotify( playlist_t *p_playlist, playlist_item_t *item )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    PL_ASSERT_LOCKED;

    p_sys->b_reset_currently_playing = true;
    vlc_cond_signal( &p_sys->signal );

    var_SetAddress( p_playlist, ""playlist-item-append"", item );
}",704.0,713.0,1.0,32.0,10.0,5,3,11,7,2,3,1,1,0,1,,0,2,4,2,2,void
2116,164574,playlist_GetNodeDuration,1,playlist_GetNodeDuration,mtime_t playlist_GetNodeDuration (playlist_item_t*),playlist\item.c,"mtime_t playlist_GetNodeDuration( playlist_item_t* node )
{
    mtime_t duration = input_item_GetDuration( node->p_input );
    if( duration == -1 )
        duration = 0;

    for( int i = 0; i < node->i_children; i++ )
        duration += playlist_GetNodeDuration( node->pp_children[i] );

    return duration;
}",718.0,728.0,1.0,1.0,11.0,8,5,8,3,0,1,3,3,0,1,,0,1,2,1,1,mtime_t
2117,164681,ChangeToNode,1,ChangeToNode,"void ChangeToNode (playlist_t*,playlist_item_t*)",playlist\item.c,"static void ChangeToNode( playlist_t *p_playlist, playlist_item_t *p_item )
{
    int i;
    if( p_item->i_children != -1 ) return;

    p_item->i_children = 0;

    input_item_t *p_input = p_item->p_input;
    vlc_mutex_lock( &p_input->lock );
    p_input->i_type = ITEM_TYPE_NODE;
    vlc_mutex_unlock( &p_input->lock );

    var_SetAddress( p_playlist, ""item-change"", p_item->p_input );

    /* Remove it from the array of available items */
    ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_item->i_id, i );
    if( i != -1 )
        ARRAY_REMOVE( p_playlist->items, i );
}",756.0,774.0,1.0,1.0,19.0,17,5,13,5,0,2,3,3,0,2,,0,0,4,2,2,void
2118,165067,playlist_Export,1,playlist_Export,"int playlist_Export (playlist_t*,char*,bool,char*)",playlist\loadsave.c,"int playlist_Export( playlist_t * p_playlist, const char *psz_filename,
                     bool b_playlist, const char *psz_type )
{
    playlist_export_t *p_export =
        vlc_custom_create( p_playlist, sizeof( *p_export ), ""playlist export"" );
    if( unlikely(p_export == NULL) )
        return VLC_ENOMEM;

    msg_Dbg( p_export, ""saving %s to file %s"",
             b_playlist ? ""playlist"" : ""media library"", psz_filename );

    int ret = VLC_EGENERIC;

    /* Prepare the playlist_export_t structure */
    p_export->base_url = vlc_path2uri( psz_filename, NULL );
    p_export->p_file = vlc_fopen( psz_filename, ""wt"" );
    if( p_export->p_file == NULL )
    {
        msg_Err( p_export, ""could not create playlist file %s: %s"",
                 psz_filename, vlc_strerror_c(errno) );
        goto out;
    }

    module_t *p_module;

    /* And call the module ! All work is done now */
    playlist_Lock( p_playlist );
    p_export->p_root = b_playlist ? p_playlist->p_playing
       ...",41.0,90.0,1.0,1.0,50.0,24,8,42,13,1,9,6,6,0,9,,0,4,8,4,4,int
2119,165199,playlist_Import,1,playlist_Import,"int playlist_Import (playlist_t*,char*)",playlist\loadsave.c,"int playlist_Import( playlist_t *p_playlist, const char *psz_file )
{
    input_item_t *p_input;
    char *psz_uri = vlc_path2uri( psz_file, NULL );

    if( psz_uri == NULL )
        return VLC_EGENERIC;

    p_input = input_item_New( psz_uri, psz_file );
    free( psz_uri );

    playlist_AddInput( p_playlist, p_input, false, true );

    vlc_object_t *dummy = vlc_object_create( p_playlist, sizeof (*dummy) );
    var_Create( dummy, ""meta-file"", VLC_VAR_VOID );

    int ret = input_Read( dummy, p_input );

    vlc_object_release( dummy );
    return ret;
}",92.0,112.0,1.0,1.0,21.0,7,4,24,11,0,6,2,2,0,6,,0,3,4,2,2,int
2120,165253,input_item_subitem_tree_added,1,input_item_subitem_tree_added,"void input_item_subitem_tree_added (vlc_event_t*,void*)",playlist\loadsave.c,"static void input_item_subitem_tree_added( const vlc_event_t * p_event,
                                      void * user_data )
{
    playlist_t *p_playlist = user_data;
    input_item_node_t *p_root =
        p_event->u.input_item_subitem_tree_added.p_root;

    PL_LOCK;
    playlist_InsertInputItemTree ( p_playlist, p_playlist->p_media_library,
                                   p_root, 0, false );
    PL_UNLOCK;
}",117.0,128.0,1.0,1.0,12.0,6,3,10,7,0,1,1,1,0,1,,0,0,4,2,2,void
2121,165283,playlist_MLLoad,1,playlist_MLLoad,int playlist_MLLoad (playlist_t*),playlist\loadsave.c,"int playlist_MLLoad( playlist_t *p_playlist )
{
    char *psz_datadir = config_GetUserDir( VLC_DATA_DIR );
    if( !psz_datadir ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot load media library"") ;
        return VLC_EGENERIC;
    }

    char *psz_file;
    if( asprintf( &psz_file, ""%s"" DIR_SEP ""ml.xspf"", psz_datadir ) == -1 )
        psz_file = NULL;
    free( psz_datadir );
    if( psz_file == NULL )
        return VLC_ENOMEM;

    /* lousy check for media library file */
    struct stat st;
    if( vlc_stat( psz_file, &st ) )
    {
        free( psz_file );
        return VLC_EGENERIC;
    }

    char *psz_uri = vlc_path2uri( psz_file, ""file/directory"" );
    free( psz_file );
    if( psz_uri == NULL )
        return VLC_ENOMEM;

    input_item_t *p_input = input_item_New( psz_uri, _(""Media Library"") );
    free( psz_uri );
    if( p_input == NULL )
        return VLC_EGENERIC;

    vlc_event_attach( &p_input->event_manager, vl...",130.0,177.0,1.0,1.0,48.0,16,7,43,14,1,10,7,7,1,10,,0,4,2,1,1,int
2122,165397,playlist_MLDump,1,playlist_MLDump,int playlist_MLDump (playlist_t*),playlist\loadsave.c,"int playlist_MLDump( playlist_t *p_playlist )
{
    char *psz_temp;

    psz_temp = config_GetUserDir( VLC_DATA_DIR );

    if( !psz_temp ) /* XXX: This should never happen */
    {
        msg_Err( p_playlist, ""no data directory, cannot save media library"") ;
        return VLC_EGENERIC;
    }

    char psz_dirname[ strlen( psz_temp ) + sizeof( DIR_SEP ""ml.xspf"")];
    strcpy( psz_dirname, psz_temp );
    free( psz_temp );
    if( config_CreateDir( (vlc_object_t *)p_playlist, psz_dirname ) )
    {
        return VLC_EGENERIC;
    }

    strcat( psz_dirname, DIR_SEP ""ml.xspf"" );

    if ( asprintf( &psz_temp, ""%s.tmp%""PRIu32, psz_dirname, (uint32_t)getpid() ) < 1 )
        return VLC_EGENERIC;

    int i_ret = playlist_Export( p_playlist, psz_temp, false, ""export-xspf"" );
    if ( i_ret != VLC_SUCCESS )
    {
        vlc_unlink( psz_temp );
        free( psz_temp );
        return i_ret;
    }

    i_ret = vlc_rename( psz_temp, psz_dirname );
    free( psz_temp );
    if( i_ret == -...",179.0,221.0,1.0,1.0,43.0,8,6,31,9,1,6,6,6,1,6,,0,4,2,1,1,int
2123,165494,playlist_ServicesDiscoveryKillAll,1,playlist_ServicesDiscoveryKillAll,void playlist_ServicesDiscoveryKillAll (playlist_t*),playlist\services_discovery.c,"void playlist_ServicesDiscoveryKillAll(playlist_t *playlist)
{
    playlist_private_t *priv = pl_priv(playlist);

    playlist_Lock(playlist);
    while (priv->i_sds > 0)
    {
        vlc_sd_internal_t *sds = priv->pp_sds[priv->i_sds - 1];
        TAB_ERASE(priv->i_sds, priv->pp_sds, priv->i_sds - 1);

        playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);
    }

    playlist_Unlock(playlist);
}",247.0,261.0,1.0,31.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2124,165542,playlist_Activate,1,playlist_Activate,void playlist_Activate (playlist_t*),playlist\thread.c,"void playlist_Activate( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    if( vlc_clone( &p_sys->thread, Thread, p_playlist,
                   VLC_THREAD_PRIORITY_LOW ) )
    {
        msg_Err( p_playlist, ""cannot spawn playlist thread"" );
        abort();
    }
}",51.0,61.0,1.0,32.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2125,165600,playlist_NodeInsert,1,playlist_NodeInsert,"int playlist_NodeInsert (playlist_item_t*,playlist_item_t*,int)",playlist\tree.c,"int playlist_NodeInsert( playlist_item_t *p_parent, playlist_item_t *p_item,
                         int i_position )
{
    assert( p_parent && p_parent->i_children != -1 );
    if( i_position == -1 ) i_position = p_parent->i_children ;
    assert( i_position <= p_parent->i_children);

    TAB_INSERT(p_parent->i_children, p_parent->pp_children,
               p_item, i_position);
    p_item->p_parent = p_parent;

    /* Inherit special flags from parent (sd cases) */
    if( ( p_parent->i_flags & PLAYLIST_NO_INHERIT_FLAG ) == 0 )
        p_item->i_flags |= (p_parent->i_flags & PLAYLIST_RO_FLAG);

    return VLC_SUCCESS;
}",149.0,165.0,1.0,1.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
2126,165607,playlist_NodeDeleteExplicit,1,playlist_NodeDeleteExplicit,"void playlist_NodeDeleteExplicit (playlist_t*,playlist_item_t*,int)",playlist\tree.c,"void playlist_NodeDeleteExplicit( playlist_t *p_playlist,
    playlist_item_t *p_root, int flags )
{
    PL_ASSERT_LOCKED;

    /* Delete the node */
    if( p_root->i_flags & PLAYLIST_RO_FLAG &&
        !( flags & PLAYLIST_DELETE_FORCE ) )
        return;

    /* Delete the children */
    for( int i = p_root->i_children - 1 ; i >= 0; i-- )
        playlist_NodeDeleteExplicit( p_playlist,
            p_root->pp_children[i], flags | PLAYLIST_DELETE_FORCE );

    pl_priv(p_playlist)->b_reset_currently_playing = true;

    int i;
    var_SetAddress( p_playlist, ""playlist-item-deleted"", p_root );

    if( p_root->i_children == -1 ) {
        ARRAY_BSEARCH( p_playlist->items,->i_id, int, p_root->i_id, i );
        if( i != -1 )
            ARRAY_REMOVE( p_playlist->items, i );
    }

    if( get_current_status_item( p_playlist ) == p_root )
    {
        /* a deleted item cannot be currently playing */
        set_current_status_item( p_playlist, NULL );

        if( flags & PLAYLIST_DE...",98.0,147.0,1.0,19.0,50.0,0,0,0,0,6,0,1,1,0,0,,0,0,6,3,3,void
2127,165620,ResetCurrentlyPlaying,1,ResetCurrentlyPlaying,"void ResetCurrentlyPlaying (playlist_t*,playlist_item_t*)",playlist\thread.c,"void ResetCurrentlyPlaying( playlist_t *p_playlist,
                                   playlist_item_t *p_cur )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_DEBUG( ""rebuilding array of current - root %s"",
              PLI_NAME( p_sys->status.p_node ) );
    ARRAY_RESET( p_playlist->current );
    p_playlist->i_current_index = -1;
    for( playlist_item_t *p_next = NULL; ; )
    {
        /** FIXME: this is *slow* */
        p_next = playlist_GetNextLeaf( p_playlist,
                                       p_sys->status.p_node,
                                       p_next, true, false );
        if( !p_next )
            break;

        if( p_next == p_cur )
            p_playlist->i_current_index = p_playlist->current.i_size;
        ARRAY_APPEND( p_playlist->current, p_next);
    }
    PL_DEBUG(""rebuild done - %i items, index %i"", p_playlist->current.i_size,
                                                  p_playlist->i_current_index);

    if( var_GetBool( p_pl...",146.0,185.0,1.0,32.0,40.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
2128,165626,ResyncCurrentIndex,1,ResyncCurrentIndex,"void ResyncCurrentIndex (playlist_t*,playlist_item_t*)",playlist\thread.c,"void ResyncCurrentIndex( playlist_t *p_playlist, playlist_item_t *p_cur )
{
    PL_ASSERT_LOCKED;

    PL_DEBUG( ""resyncing on %s"", PLI_NAME( p_cur ) );
    /* Simply resync index */
    int i;
    p_playlist->i_current_index = -1;
    for( i = 0 ; i< p_playlist->current.i_size; i++ )
    {
        if( ARRAY_VAL( p_playlist->current, i ) == p_cur )
        {
            p_playlist->i_current_index = i;
            break;
        }
    }
    PL_DEBUG( ""%s is at %i"", PLI_NAME( p_cur ), p_playlist->i_current_index );
}",120.0,137.0,1.0,4.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2129,165632,playlist_GetNextLeaf,1,playlist_GetNextLeaf,"playlist_item_t* playlist_GetNextLeaf (playlist_t*,playlist_item_t*,playlist_item_t*,bool,bool)",playlist\tree.c,"playlist_item_t *playlist_GetNextLeaf( playlist_t *p_playlist,
                                       playlist_item_t *p_root,
                                       playlist_item_t *p_item,
                                       bool b_ena, bool b_unplayed )
{
    PL_ASSERT_LOCKED;
    playlist_item_t *p_next;

    assert( p_root && p_root->i_children != -1 );

    PL_DEBUG2( ""finding next of %s within %s"",
               PLI_NAME( p_item ), PLI_NAME( p_root ) );

    /* Now, walk the tree until we find a suitable next item */
    p_next = p_item;
    while( 1 )
    {
        bool b_ena_ok = true, b_unplayed_ok = true;
        p_next = GetNextItem( p_playlist, p_root, p_next );
        if( !p_next || p_next == p_root )
            break;
        if( p_next->i_children == -1 )
        {
            if( b_ena && p_next->i_flags & PLAYLIST_DBL_FLAG )
                b_ena_ok = false;
            if( b_unplayed && p_next->i_nb_played != 0 )
                b_unplayed_ok = false;
      ...",207.0,239.0,1.0,4.0,33.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,playlist_item_t
2130,165643,pl_lock_if,1,pl_lock_if,"void pl_lock_if (playlist_t*,bool)",playlist\playlist_internal.h,"static inline void pl_lock_if( playlist_t * p_playlist, bool cond )
{
    if( cond ) PL_LOCK; else PL_ASSERT_LOCKED;
}",183.0,186.0,1.0,1.0,4.0,0,0,2,2,2,0,2,2,0,0,,0,0,4,2,2,void
2131,165656,pl_unlock_if,1,pl_unlock_if,"void pl_unlock_if (playlist_t*,bool)",playlist\playlist_internal.h,"static inline void pl_unlock_if( playlist_t * p_playlist, bool cond )
{
    if( cond ) PL_UNLOCK;
}",189.0,192.0,1.0,1.0,4.0,0,0,2,2,2,0,2,2,0,0,,0,0,4,2,2,void
2132,165717,PreparserOpenInput,1,PreparserOpenInput,"int PreparserOpenInput (void*,void*,void**)",playlist\preparser.c,"static int PreparserOpenInput( void* preparser_, void* item_, void** out )
{
    playlist_preparser_t* preparser = preparser_;

    input_thread_t* input = input_CreatePreparser( preparser->owner, item_ );
    if( !input )
    {
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    var_AddCallback( input, ""intf-event"", InputEvent, preparser->worker );
    if( input_Start( input ) )
    {
        var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );
        input_Close( input );
        input_item_SignalPreparseEnded( item_, ITEM_PREPARSE_FAILED );
        return VLC_EGENERIC;
    }

    *out = input;
    return VLC_SUCCESS;
}",53.0,75.0,1.0,1.0,23.0,8,4,21,8,0,10,3,3,1,7,,0,5,6,3,3,int
2133,165797,PreparserCloseInput,1,PreparserCloseInput,"void PreparserCloseInput (void*,void*)",playlist\preparser.c,"static void PreparserCloseInput( void* preparser_, void* input_ )
{
    playlist_preparser_t* preparser = preparser_;
    input_thread_t* input = input_;
    input_item_t* item = input_priv(input)->p_item;

    var_DelCallback( input, ""intf-event"", InputEvent, preparser->worker );

    int status;
    switch( input_GetState( input ) )
    {
        case END_S:
            status = ITEM_PREPARSE_DONE;
            break;
        case ERROR_S:
            status = ITEM_PREPARSE_FAILED;
            break;
        default:
            status = ITEM_PREPARSE_TIMEOUT;
    }

    input_Stop( input );
    input_Close( input );

    if( preparser->fetcher )
    {
        if( !playlist_fetcher_Push( preparser->fetcher, item, 0, status ) )
            return;
    }

    input_item_SetPreparsed( item, true );
    input_item_SignalPreparseEnded( item, status );
}",84.0,116.0,1.0,1.0,33.0,11,3,27,12,0,10,6,5,3,7,,0,5,4,2,2,void
2134,165872,InputItemRelease,1,InputItemRelease,void InputItemRelease (void*),playlist\preparser.c,static void InputItemRelease( void* item ) { input_item_Release( item ); },118.0,118.0,1.0,74.0,1.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2135,165879,InputItemHold,1,InputItemHold,void InputItemHold (void*),playlist\preparser.c,static void InputItemHold( void* item ) { input_item_Hold( item ); },119.0,119.0,1.0,68.0,1.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2136,165886,playlist_preparser_New,1,playlist_preparser_New,playlist_preparser_t playlist_preparser_New (vlc_object_t*),playlist\preparser.c,"playlist_preparser_t* playlist_preparser_New( vlc_object_t *parent )
{
    playlist_preparser_t* preparser = malloc( sizeof *preparser );

    struct background_worker_config conf = {
        .default_timeout = var_InheritInteger( parent, ""preparse-timeout"" ),
        .pf_start = PreparserOpenInput,
        .pf_probe = PreparserProbeInput,
        .pf_stop = PreparserCloseInput,
        .pf_release = InputItemRelease,
        .pf_hold = InputItemHold };


    if( likely( preparser ) )
        preparser->worker = background_worker_New( preparser, &conf );

    if( unlikely( !preparser || !preparser->worker ) )
    {
        free( preparser );
        return NULL;
    }

    preparser->owner = parent;
    preparser->fetcher = playlist_fetcher_New( parent );
    atomic_init( &preparser->deactivated, false );

    if( unlikely( !preparser->fetcher ) )
        msg_Warn( parent, ""unable to create art fetcher"" );

    return preparser;
}",121.0,151.0,1.0,1.0,31.0,26,8,27,11,1,8,4,4,2,2,,0,8,2,1,1,playlist_preparser_t
2137,165983,playlist_preparser_Push,1,playlist_preparser_Push,"void playlist_preparser_Push (playlist_preparser_t*,input_item_t*,input_item_meta_request_option_t,int,void*)",playlist\preparser.c,"void playlist_preparser_Push( playlist_preparser_t *preparser,
    input_item_t *item, input_item_meta_request_option_t i_options,
    int timeout, void *id )
{
    if( atomic_load( &preparser->deactivated ) )
        return;

    vlc_mutex_lock( &item->lock );
    int i_type = item->i_type;
    int b_net = item->b_net;
    vlc_mutex_unlock( &item->lock );

    switch( i_type )
    {
        case ITEM_TYPE_NODE:
        case ITEM_TYPE_FILE:
        case ITEM_TYPE_DIRECTORY:
        case ITEM_TYPE_PLAYLIST:
            if( !b_net || i_options & META_REQUEST_OPTION_SCOPE_NETWORK )
                break;
        default:
            input_item_SignalPreparseEnded( item, ITEM_PREPARSE_SKIPPED );
            return;
    }

    if( background_worker_Push( preparser->worker, item, id, timeout ) )
        input_item_SignalPreparseEnded( item, ITEM_PREPARSE_FAILED );
}",153.0,180.0,1.0,1.0,28.0,14,6,23,14,2,7,6,6,3,5,,0,3,10,5,5,void
2138,166059,playlist_preparser_fetcher_Push,1,playlist_preparser_fetcher_Push,"void playlist_preparser_fetcher_Push (playlist_preparser_t*,input_item_t*,input_item_meta_request_option_t)",playlist\preparser.c,"void playlist_preparser_fetcher_Push( playlist_preparser_t *preparser,
    input_item_t *item, input_item_meta_request_option_t options )
{
    if( preparser->fetcher )
        playlist_fetcher_Push( preparser->fetcher, item, options, -1 );
}",182.0,187.0,1.0,1.0,6.0,3,2,4,3,1,3,2,2,1,1,,0,2,6,3,3,void
2139,166079,playlist_preparser_Cancel,1,playlist_preparser_Cancel,"void playlist_preparser_Cancel (playlist_preparser_t*,void*)",playlist\preparser.c,"void playlist_preparser_Cancel( playlist_preparser_t *preparser, void *id )
{
    background_worker_Cancel( preparser->worker, id );
}",189.0,192.0,1.0,1.0,4.0,1,1,2,2,1,2,1,1,0,1,,0,1,4,2,2,void
2140,166090,playlist_preparser_Deactivate,1,playlist_preparser_Deactivate,void playlist_preparser_Deactivate (playlist_preparser_t*),playlist\preparser.c,"void playlist_preparser_Deactivate( playlist_preparser_t* preparser )
{
    atomic_store( &preparser->deactivated, true );
    background_worker_Cancel( preparser->worker, NULL );
}",194.0,198.0,1.0,1.0,5.0,3,2,4,3,1,3,1,1,0,1,,0,2,2,1,1,void
2141,166106,playlist_preparser_Delete,1,playlist_preparser_Delete,void playlist_preparser_Delete (playlist_preparser_t*),playlist\preparser.c,"void playlist_preparser_Delete( playlist_preparser_t *preparser )
{
    background_worker_Delete( preparser->worker );

    if( preparser->fetcher )
        playlist_fetcher_Delete( preparser->fetcher );

    free( preparser );
}",200.0,208.0,1.0,1.0,9.0,3,1,4,1,1,5,2,2,1,2,,0,3,2,1,1,void
2142,166187,playlist_SetRenderer,1,playlist_SetRenderer,"int playlist_SetRenderer (playlist_t*,vlc_renderer_item_t*)",playlist\renderer.c,"int playlist_SetRenderer( playlist_t* p_playlist, vlc_renderer_item_t* p_item )
{
    if( p_item )
        vlc_renderer_item_hold( p_item );

    PL_LOCK;

    playlist_private_t *p_priv = pl_priv( p_playlist );
    vlc_renderer_item_t *p_prev_renderer = p_priv->p_renderer;
    p_priv->p_renderer = p_item;
    if( p_priv->p_input )
        input_Control( p_priv->p_input, INPUT_SET_RENDERER, p_item );

    PL_UNLOCK;

    if( p_prev_renderer )
        vlc_renderer_item_release( p_prev_renderer );
    return VLC_SUCCESS;
}",33.0,51.0,1.0,33.0,19.0,7,2,20,10,0,7,4,4,1,3,,0,4,4,2,2,int
2143,166298,playlist_LiveSearchUpdateInternal,1,playlist_LiveSearchUpdateInternal,"bool playlist_LiveSearchUpdateInternal (playlist_item_t*,char*,bool)",playlist\search.c,"static bool playlist_LiveSearchUpdateInternal( playlist_item_t *p_root,
                                               const char *psz_string, bool b_recursive )
{
    int i;
    bool b_match = false;
    for( i = 0 ; i < p_root->i_children ; i ++ )
    {
        bool b_enable = false;
        playlist_item_t *p_item = p_root->pp_children[i];
        // Go recurssively if their is some children
        if( b_recursive && p_item->i_children >= 0 &&
            playlist_LiveSearchUpdateInternal( p_item, psz_string, true ) )
        {
            b_enable = true;
        }

        if( !b_enable )
        {
            vlc_mutex_lock( &p_item->p_input->lock );
            // Do we have some meta ?
            if( p_item->p_input->p_meta )
            {
                // Use Title or fall back to psz_name
                const char *psz_title = vlc_meta_Get( p_item->p_input->p_meta, vlc_meta_Title );
                if( !psz_title )
                    psz_title = p_item->p_input->psz_...",63.0,108.0,1.0,1.0,46.0,43,10,49,16,1,8,7,15,0,8,,0,6,6,3,3,bool
2144,166475,playlist_LiveSearchUpdate,1,playlist_LiveSearchUpdate,"int playlist_LiveSearchUpdate (playlist_t*,playlist_item_t*,char*,bool)",playlist\search.c,"int playlist_LiveSearchUpdate( playlist_t *p_playlist, playlist_item_t *p_root,
                               const char *psz_string, bool b_recursive )
{
    PL_ASSERT_LOCKED;
    pl_priv(p_playlist)->b_reset_currently_playing = true;
    if( *psz_string )
        playlist_LiveSearchUpdateInternal( p_root, psz_string, b_recursive );
    else
        playlist_LiveSearchClean( p_root );
    vlc_cond_signal( &pl_priv(p_playlist)->signal );
    return VLC_SUCCESS;
}",119.0,130.0,1.0,4.0,12.0,5,4,15,9,0,2,2,2,0,2,,0,0,8,4,4,int
2145,166546,playlist_sd_item_added,1,playlist_sd_item_added,"void playlist_sd_item_added (services_discovery_t*,input_item_t*,input_item_t*,char*)",playlist\services_discovery.c,"static void playlist_sd_item_added(services_discovery_t *sd,
                                   input_item_t *parent, input_item_t *p_input,
                                   const char *psz_cat)
{
    assert(parent == NULL || psz_cat == NULL);

    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node;
    const char *longname = (sd->description != NULL) ? sd->description : ""?"";

    msg_Dbg(sd, ""adding: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    if (sds->node == NULL)
        sds->node = playlist_NodeCreate(playlist, longname, &playlist->root,
                                        PLAYLIST_END, PLAYLIST_RO_FLAG);

    if (parent != NULL)
        node = playlist_ItemGetByInput(playlist, parent);
    else
    if (psz_cat == NULL)
        node = sds->node;
    else
    {   /* Parent is NULL (root) and category is specified.
         * This is clearly a hack. TODO: re...",42.0,76.0,1.0,1.0,35.0,26,9,34,11,0,7,3,3,1,5,,0,4,8,4,4,void
2146,166680,playlist_sd_item_removed,1,playlist_sd_item_removed,"void playlist_sd_item_removed (services_discovery_t*,input_item_t*)",playlist\services_discovery.c,"static void playlist_sd_item_removed(services_discovery_t *sd,
                                     input_item_t *p_input)
{
    vlc_sd_internal_t *sds = sd->owner.sys;
    playlist_t *playlist = (playlist_t *)sd->obj.parent;
    playlist_item_t *node, *item;

    msg_Dbg(sd, ""removing: %s"", p_input->psz_name ? p_input->psz_name : ""(null)"");

    playlist_Lock(playlist);
    item = playlist_ItemGetByInput(playlist, p_input);
    if (unlikely(item == NULL))
    {
        msg_Err(sd, ""removing item not added""); /* SD plugin bug */
        playlist_Unlock(playlist);
        return;
    }

#ifndef NDEBUG
    /* Check that the item belonged to the SD */
    for (playlist_item_t *i = item->p_parent; i != sds->node; i = i->p_parent)
        assert(i != NULL);
#endif

    node = item->p_parent;
    /* if the item was added under a category and the category node
       becomes empty, delete that node as well */
    if (node != sds->node && node->i_children == 1)
        item = node;
    play...",79.0,111.0,1.0,8.0,33.0,25,9,29,8,0,7,4,4,2,5,,0,3,4,2,2,void
2147,166791,playlist_ServicesDiscoveryAdd,1,playlist_ServicesDiscoveryAdd,"int playlist_ServicesDiscoveryAdd (playlist_t*,char*)",playlist\services_discovery.c,"int playlist_ServicesDiscoveryAdd(playlist_t *playlist, const char *chain)
{
    vlc_sd_internal_t *sds = malloc(sizeof (*sds) + strlen(chain) + 1);
    if (unlikely(sds == NULL))
        return VLC_ENOMEM;

    sds->node = NULL;

    struct services_discovery_owner_t owner = {
        sds,
        playlist_sd_item_added,
        playlist_sd_item_removed,
    };

    /* Perform the addition */
    sds->sd = vlc_sd_Create(VLC_OBJECT(playlist), chain, &owner);
    if (unlikely(sds->sd == NULL))
    {
        free(sds);
        return VLC_ENOMEM;
    }

    strcpy(sds->name, chain);

    playlist_Lock(playlist);
    /* Backward compatibility with Qt UI: create the node even if the SD
     * has not discovered any item. */
    if (sds->node == NULL && sds->sd->description != NULL)
        sds->node = playlist_NodeCreate(playlist, sds->sd->description,
                                        &playlist->root, PLAYLIST_END,
                                        PLAYLIST_RO_FLAG);

    TA...",113.0,148.0,1.0,15.0,36.0,30,10,42,11,0,12,4,4,3,4,,0,10,4,2,2,int
2148,166914,playlist_ServicesDiscoveryInternalRemoveLocked,1,playlist_ServicesDiscoveryInternalRemoveLocked,"void playlist_ServicesDiscoveryInternalRemoveLocked (playlist_t*,vlc_sd_internal_t*)",playlist\services_discovery.c,"static void playlist_ServicesDiscoveryInternalRemoveLocked(playlist_t *playlist,
                                                           vlc_sd_internal_t *sds)
{
    assert(sds->sd != NULL);

    playlist_Unlock(playlist);

    vlc_sd_Destroy(sds->sd);
    /* Remove the sd playlist node if it exists */
    playlist_Lock(playlist);

    if (sds->node != NULL)
        playlist_NodeDeleteExplicit(playlist, sds->node,
            PLAYLIST_DELETE_FORCE | PLAYLIST_DELETE_STOP_IF_CURRENT );

    free(sds);
}",150.0,166.0,1.0,12.0,17.0,7,3,10,3,1,8,2,2,1,4,,0,4,4,2,2,void
2149,166955,playlist_ServicesDiscoveryRemove,1,playlist_ServicesDiscoveryRemove,"int playlist_ServicesDiscoveryRemove (playlist_t*,char*)",playlist\services_discovery.c,"int playlist_ServicesDiscoveryRemove(playlist_t *playlist, const char *name)
{
    playlist_private_t *priv = pl_priv(playlist);
    vlc_sd_internal_t *sds = NULL;

    playlist_Lock(playlist);
    for (int i = 0; i < priv->i_sds; i++)
    {
        vlc_sd_internal_t *entry = priv->pp_sds[i];

        if (!strcmp(name, entry->name))
        {
            TAB_ERASE(priv->i_sds, priv->pp_sds, i);
            sds = entry;
            break;
        }
    }

    if (sds == NULL)
    {
        msg_Warn(playlist, ""discovery %s is not loaded"", name);
        playlist_Unlock(playlist);
        return VLC_EGENERIC;
    }

    playlist_ServicesDiscoveryInternalRemoveLocked(playlist, sds);

    playlist_Unlock(playlist);

    return VLC_SUCCESS;
}",168.0,198.0,1.0,31.0,31.0,14,6,31,11,0,9,5,5,2,4,,0,5,4,2,2,int
2150,167039,playlist_IsServicesDiscoveryLoaded,1,playlist_IsServicesDiscoveryLoaded,"bool playlist_IsServicesDiscoveryLoaded (playlist_t*,char*)",playlist\services_discovery.c,"bool playlist_IsServicesDiscoveryLoaded( playlist_t * playlist,
                                         const char *psz_name )
{
    playlist_private_t *priv = pl_priv( playlist );
    bool found = false;
    playlist_Lock(playlist);

    for( int i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];

        if (!strcmp(psz_name, sds->name))
        {
            found = true;
            break;
        }
    }
    playlist_Unlock(playlist);
    return found;
}",200.0,219.0,1.0,31.0,20.0,11,5,20,10,0,5,4,4,2,2,,0,3,4,2,2,bool
2151,167099,playlist_ServicesDiscoveryControl,1,playlist_ServicesDiscoveryControl,"int playlist_ServicesDiscoveryControl (playlist_t*,char*,int...)",playlist\services_discovery.c,"int playlist_ServicesDiscoveryControl( playlist_t *playlist, const char *psz_name, int i_control, ... )
{
    playlist_private_t *priv = pl_priv( playlist );
    int i_ret = VLC_EGENERIC;
    int i;

    playlist_Lock(playlist);
    for( i = 0; i < priv->i_sds; i++ )
    {
        vlc_sd_internal_t *sds = priv->pp_sds[i];
        if (!strcmp(psz_name, sds->name))
        {
            va_list args;
            va_start( args, i_control );
            i_ret = vlc_sd_control(sds->sd, i_control, args );
            va_end( args );
            break;
        }
    }

    assert( i != priv->i_sds );
    playlist_Unlock(playlist);

    return i_ret;
}",221.0,245.0,1.0,31.0,25.0,14,6,27,11,0,7,4,4,2,2,,0,5,6,3,3,int
2152,167245,meta_strcasecmp_title,1,meta_strcasecmp_title,"int meta_strcasecmp_title (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"static inline int meta_strcasecmp_title( const playlist_item_t *first,
                              const playlist_item_t *second )
{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;
    free( psz_first );
    free( psz_second );

    return i_ret;
}",43.0,62.0,1.0,1.0,20.0,6,3,12,5,1,2,2,2,0,2,,0,2,4,2,2,int
2153,167310,meta_sort,1,meta_sort,"int meta_sort (playlist_item_t*,playlist_item_t*,vlc_meta_type_t,bool)",playlist\sort.c,"static inline int meta_sort( const playlist_item_t *first,
                             const playlist_item_t *second,
                             vlc_meta_type_t meta, bool b_integer )
{
    int i_ret;
    char *psz_first = input_item_GetMeta( first->p_input, meta );
    char *psz_second = input_item_GetMeta( second->p_input, meta );

    /* Nodes go first */
    if( first->i_children == -1 && second->i_children >= 0 )
        i_ret = 1;
    else if( first->i_children >= 0 && second->i_children == -1 )
       i_ret = -1;
    /* Both are nodes, sort by name */
    else if( first->i_children >= 0 && second->i_children >= 0 )
        i_ret = meta_strcasecmp_title( first, second );
    /* Both are items */
    else if( !psz_first && !psz_second )
        i_ret = 0;
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
    {
        if( b_integer )
            i_ret = atoi( psz_first ) - atoi( psz_second );
     ...",72.0,106.0,1.0,1.0,35.0,11,6,12,6,8,2,2,2,0,2,,0,2,8,4,4,int
2154,167462,find_sorting_fn,1,find_sorting_fn,"sortfn_t find_sorting_fn (unsigned,unsigned)",playlist\sort.c,"static inline sortfn_t find_sorting_fn( unsigned i_mode, unsigned i_type )
{
    if( i_mode>=NUM_SORT_FNS || i_type>1 )
        return 0;
    return sorting_fns[i_mode][i_type];
}",119.0,124.0,1.0,1.0,6.0,5,4,6,4,1,1,2,2,0,0,,0,1,4,2,2,sortfn_t
2155,167485,playlist_ItemArraySort,1,playlist_ItemArraySort,"void playlist_ItemArraySort (unsigned,playlist_item_t**,sortfn_t)",playlist\sort.c,"static inline
void playlist_ItemArraySort( unsigned i_items, playlist_item_t **pp_items,
                             sortfn_t p_sortfn )
{
    if( p_sortfn )
    {
        qsort( pp_items, i_items, sizeof( pp_items[0] ), p_sortfn );
    }
    else /* Randomise */
    {
        unsigned i_position;
        unsigned i_new;
        playlist_item_t *p_temp;

        for( i_position = i_items - 1; i_position > 0; i_position-- )
        {
            i_new = ((unsigned)vlc_mrand48()) % (i_position+1);
            p_temp = pp_items[i_position];
            pp_items[i_position] = pp_items[i_new];
            pp_items[i_new] = p_temp;
        }
    }
}",133.0,155.0,1.0,1.0,23.0,2,2,5,3,1,0,2,2,0,0,,0,0,6,3,3,void
2156,167547,recursiveNodeSort,1,recursiveNodeSort,"int recursiveNodeSort (playlist_t*,playlist_item_t*,sortfn_t)",playlist\sort.c,"static int recursiveNodeSort( playlist_t *p_playlist, playlist_item_t *p_node,
                              sortfn_t p_sortfn )
{
    int i;
    playlist_ItemArraySort(p_node->i_children,p_node->pp_children,p_sortfn);
    for( i = 0 ; i< p_node->i_children; i++ )
    {
        if( p_node->pp_children[i]->i_children != -1 )
        {
            recursiveNodeSort( p_playlist, p_node->pp_children[i], p_sortfn );
        }
    }
    return VLC_SUCCESS;
}",166.0,179.0,1.0,1.0,14.0,12,6,13,5,1,1,3,4,0,1,,0,0,6,3,3,int
2157,167598,playlist_RecursiveNodeSort,1,playlist_RecursiveNodeSort,"int playlist_RecursiveNodeSort (playlist_t*,playlist_item_t*,int,int)",playlist\sort.c,"int playlist_RecursiveNodeSort( playlist_t *p_playlist, playlist_item_t *p_node,
                                int i_mode, int i_type )
{
    PL_ASSERT_LOCKED;

    /* Ask the playlist to reset as we are changing the order */
    pl_priv(p_playlist)->b_reset_currently_playing = true;

    /* Do the real job recursively */
    return recursiveNodeSort(p_playlist,p_node,find_sorting_fn(i_mode,i_type));
}",192.0,202.0,1.0,4.0,11.0,2,2,10,8,0,2,1,1,0,2,,0,1,8,4,4,int
2158,167625,proto_SORT_TRACK_NUMBER,1,proto_SORT_TRACK_NUMBER,"int proto_SORT_TRACK_NUMBER (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_TRACK_NUMBER, first, second )
{
    return meta_sort( first, second, vlc_meta_TrackNumber, true );
}",218.0,221.0,1.0,42.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,4,2,2,int
2159,167637,proto_SORT_DISC_NUMBER,1,proto_SORT_DISC_NUMBER,"int proto_SORT_DISC_NUMBER (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DISC_NUMBER, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_DiscNumber, true );
    /* Items came from the same disc: compare the track numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_TRACK_NUMBER( first, second );

    return i_ret;
}",223.0,231.0,1.0,41.0,9.0,3,2,10,5,1,2,2,2,0,2,,0,2,4,2,2,int
2160,167663,proto_SORT_ALBUM,1,proto_SORT_ALBUM,"int proto_SORT_ALBUM (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_ALBUM, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Album, false );
    /* Items came from the same album: compare the disc numbers */
    if( i_ret == 0 )
        i_ret = proto_SORT_DISC_NUMBER( first, second );

    return i_ret;
}",233.0,241.0,1.0,35.0,9.0,3,2,10,5,1,2,2,2,0,2,,0,2,4,2,2,int
2161,167689,proto_SORT_DATE,1,proto_SORT_DATE,"int proto_SORT_DATE (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DATE, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Date, true );
    /* Items came from the same date: compare the albums */
    if( i_ret == 0 )
        i_ret = proto_SORT_ALBUM( first, second );

    return i_ret;
}",243.0,251.0,1.0,34.0,9.0,3,2,10,5,1,2,2,2,0,2,,0,2,4,2,2,int
2162,167715,proto_SORT_ARTIST,1,proto_SORT_ARTIST,"int proto_SORT_ARTIST (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_ARTIST, first, second )
{
    int i_ret = meta_sort( first, second, vlc_meta_Artist, false );
    /* Items came from the same artist: compare the dates */
    if( i_ret == 0 )
        i_ret = proto_SORT_DATE( first, second );

    return i_ret;
}",253.0,261.0,1.0,36.0,9.0,3,2,10,5,0,2,2,2,0,2,,0,2,4,2,2,int
2163,167741,proto_SORT_DESCRIPTION,1,proto_SORT_DESCRIPTION,"int proto_SORT_DESCRIPTION (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DESCRIPTION, first, second )
{
    return meta_sort( first, second, vlc_meta_Description, false );
}",263.0,266.0,1.0,41.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
2164,167753,proto_SORT_DURATION,1,proto_SORT_DURATION,"int proto_SORT_DURATION (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_DURATION, first, second )
{
    mtime_t time1 = input_item_GetDuration( first->p_input );
    mtime_t time2 = input_item_GetDuration( second->p_input );
    int i_ret = time1 > time2 ? 1 :
                    ( time1 == time2 ? 0 : -1 );
    return i_ret;
}",268.0,275.0,1.0,38.0,8.0,10,6,10,5,0,2,1,1,0,2,,0,2,4,2,2,int
2165,167790,proto_SORT_GENRE,1,proto_SORT_GENRE,"int proto_SORT_GENRE (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_GENRE, first, second )
{
    return meta_sort( first, second, vlc_meta_Genre, false );
}",277.0,280.0,1.0,35.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
2166,167816,proto_SORT_RATING,1,proto_SORT_RATING,"int proto_SORT_RATING (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_RATING, first, second )
{
    return meta_sort( first, second, vlc_meta_Rating, true );
}",287.0,290.0,1.0,36.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,4,2,2,int
2167,167828,proto_SORT_TITLE,1,proto_SORT_TITLE,"int proto_SORT_TITLE (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_TITLE, first, second )
{
    return meta_strcasecmp_title( first, second );
}",292.0,295.0,1.0,35.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2168,167885,proto_SORT_TITLE_NUMERIC,1,proto_SORT_TITLE_NUMERIC,"int proto_SORT_TITLE_NUMERIC (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_TITLE_NUMERIC, first, second )
{
    int i_ret;
    char *psz_first = input_item_GetTitleFbName( first->p_input );
    char *psz_second = input_item_GetTitleFbName( second->p_input );

    if( psz_first && psz_second )
        i_ret = atoi( psz_first ) - atoi( psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",310.0,328.0,1.0,43.0,19.0,7,4,12,5,0,2,2,2,0,2,,0,2,4,2,2,int
2169,167952,proto_SORT_URI,1,proto_SORT_URI,"int proto_SORT_URI (playlist_item_t*,playlist_item_t*)",playlist\sort.c,"SORTFN( SORT_URI, first, second )
{
    int i_ret;
    char *psz_first = input_item_GetURI( first->p_input );
    char *psz_second = input_item_GetURI( second->p_input );

    if( psz_first && psz_second )
        i_ret = strcasecmp( psz_first, psz_second );
    else if( !psz_first && psz_second )
        i_ret = 1;
    else if( psz_first && !psz_second )
        i_ret = -1;
    else
        i_ret = 0;

    free( psz_first );
    free( psz_second );
    return i_ret;
}",330.0,348.0,1.0,33.0,19.0,6,3,12,5,0,2,2,2,0,2,,0,2,4,2,2,int
2170,168082,playlist_Deactivate,1,playlist_Deactivate,void playlist_Deactivate (playlist_t*),playlist\thread.c,"void playlist_Deactivate( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);

    PL_LOCK;
    /* WARNING: There is a latent bug. It is assumed that only one thread will
     * be waiting for playlist deactivation at a time. So far, that works
     * as playlist_Deactivate() is only ever called while closing an
     * interface and interfaces are shut down serially by intf_DestroyAll(). */
    if( p_sys->killed )
    {
        PL_UNLOCK;
        return;
    }

    msg_Dbg( p_playlist, ""deactivating the playlist"" );
    p_sys->killed = true;
    vlc_cond_signal( &p_sys->signal );
    PL_UNLOCK;

    vlc_join( p_sys->thread, NULL );
}",68.0,89.0,1.0,32.0,22.0,7,3,15,8,1,6,2,2,1,2,,0,4,2,1,1,void
2171,168438,PlayItem,1,PlayItem,"bool PlayItem (playlist_t*,playlist_item_t*)",playlist\thread.c,"static bool PlayItem( playlist_t *p_playlist, playlist_item_t *p_item )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_item_t *p_input = p_item->p_input;
    vlc_renderer_item_t *p_renderer;

    PL_ASSERT_LOCKED;

    msg_Dbg( p_playlist, ""creating new input thread"" );

    p_item->i_nb_played++;
    set_current_status_item( p_playlist, p_item );
    p_renderer = p_sys->p_renderer;
    /* Retain the renderer now to avoid it to be released by
     * playlist_SetRenderer when we exit the locked scope. If the last reference
     * was to be released, we would use a dangling pointer */
    if( p_renderer )
        vlc_renderer_item_hold( p_renderer );
    assert( p_sys->p_input == NULL );
    PL_UNLOCK;

    libvlc_MetadataCancel( p_playlist->obj.libvlc, p_item );

    input_thread_t *p_input_thread = input_Create( p_playlist, p_input, NULL,
                                                   p_sys->p_input_resource,
                                                   p...",194.0,256.0,1.0,32.0,63.0,25,8,59,15,1,14,6,7,1,10,,0,6,4,2,2,bool
2172,168588,NextItem,1,NextItem,playlist_item_t NextItem (playlist_t*),playlist\thread.c,"static playlist_item_t *NextItem( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    playlist_item_t *p_new = NULL;
    bool requested = p_sys->request.b_request;

    /* Clear the request */
    p_sys->request.b_request = false;

    /* Handle quickly a few special cases */
    /* No items to play */
    if( p_playlist->items.i_size == 0 )
    {
        msg_Info( p_playlist, ""playlist is empty"" );
        return NULL;
    }

    /* Start the real work */
    if( requested )
    {
        p_new = p_sys->request.p_item;

        if( p_new == NULL && p_sys->request.p_node == NULL )
            return NULL; /* Stop request! */

        int i_skip = p_sys->request.i_skip;
        PL_DEBUG( ""processing request item: %s, node: %s, skip: %i"",
                        PLI_NAME( p_sys->request.p_item ),
                        PLI_NAME( p_sys->request.p_node ), i_skip );

        if( p_sys->request.p_node &&
            p_sys->request.p_node != get_current_sta...",265.0,422.0,1.0,32.0,158.0,100,13,86,11,1,8,15,40,2,6,,0,5,2,1,1,playlist_item_t
2173,169160,LoopInput,1,LoopInput,bool LoopInput (playlist_t*),playlist\thread.c,"static bool LoopInput( playlist_t *p_playlist )
{
    playlist_private_t *p_sys = pl_priv(p_playlist);
    input_thread_t *p_input = p_sys->p_input;

    assert( p_input != NULL );

    /* Wait for input to end or be stopped */
    while( !p_sys->request.input_dead )
    {
        if( p_sys->request.b_request || p_sys->killed )
        {
            PL_DEBUG( ""incoming request - stopping current input"" );
            input_Stop( p_input );
        }
        vlc_cond_wait( &p_sys->signal, &p_sys->lock );
    }

    input_item_t *item = input_GetItem(p_input);
    assert(item);
    bool ok = !input_item_HasErrorWhenReading(item);

    /* This input is dead. Remove it ! */
    PL_DEBUG( ""dead input"" );
    p_sys->p_input = NULL;
    p_sys->request.input_dead = false;
    PL_UNLOCK;

    var_SetAddress( p_playlist, ""input-current"", NULL );

    /* WARNING: Input resource manipulation and callback deletion are
     * incompatible with the playlist lock. */
    if( !var_InheritBool( p_inp...",424.0,464.0,1.0,32.0,41.0,25,7,36,11,0,13,4,5,1,7,,0,8,2,1,1,bool
2174,169275,Next,1,Next,bool Next (playlist_t*),playlist\thread.c,"static bool Next( playlist_t *p_playlist )
{
    playlist_item_t *p_item = NextItem( p_playlist );
    if( p_item == NULL )
        return false;

    msg_Dbg( p_playlist, ""starting playback of new item"" );
    ResyncCurrentIndex( p_playlist, p_item );
    return PlayItem( p_playlist, p_item );
}",466.0,475.0,1.0,1.0,10.0,2,2,10,4,0,3,2,2,0,3,,0,1,2,1,1,bool
2175,169503,playlist_NodeCreate,1,playlist_NodeCreate,"playlist_item_t playlist_NodeCreate (playlist_t*,char*,playlist_item_t*,int,int)",playlist\tree.c,"playlist_item_t * playlist_NodeCreate( playlist_t *p_playlist,
                                       const char *psz_name,
                                       playlist_item_t *p_parent, int i_pos,
                                       int i_flags )
{
    input_item_t *p_new_input;
    playlist_item_t *p_item;

    PL_ASSERT_LOCKED;
    if( !psz_name ) psz_name = _(""Undefined"");

    p_new_input = input_item_NewExt( NULL, psz_name, -1, ITEM_TYPE_NODE,
                                     ITEM_NET_UNKNOWN );
    if( !p_new_input )
        return NULL;
    p_item = playlist_ItemNewFromInput( p_playlist, p_new_input );
    input_item_Release( p_new_input );

    if( p_item == NULL )  return NULL;

    playlist_NodeInsert( p_parent, p_item, i_pos );
    playlist_SendAddNotify( p_playlist, p_item );

    p_item->i_flags |= i_flags;

    return p_item;
}",58.0,84.0,1.0,1.0,27.0,8,5,25,11,4,5,4,4,0,5,,0,2,10,5,5,playlist_item_t
2176,169566,playlist_NodeDelete,1,playlist_NodeDelete,"void playlist_NodeDelete (playlist_t*,playlist_item_t*)",playlist\tree.c,"void playlist_NodeDelete( playlist_t *p_playlist, playlist_item_t *p_root )
{
    playlist_NodeDeleteExplicit( p_playlist, p_root,
        PLAYLIST_DELETE_STOP_IF_CURRENT );
}",92.0,96.0,1.0,8.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
2177,170464,config_GetAppDir,1,config_GetAppDir,"char* config_GetAppDir (char*,char*)",win32\dirs.c,"static char *config_GetAppDir (void)
{
#if !VLC_WINSTORE_APP
    /* if portable directory exists, use it */
    TCHAR path[MAX_PATH];
    if (GetModuleFileName (NULL, path, MAX_PATH))
    {
        TCHAR *lastDir = _tcsrchr (path, '\\');
        if (lastDir)
        {
            _tcscpy (lastDir + 1, TEXT(""portable""));
            DWORD attrib = GetFileAttributes (path);
            if (attrib != INVALID_FILE_ATTRIBUTES &&
                    (attrib & FILE_ATTRIBUTE_DIRECTORY))
                return FromT (path);
        }
    }
#endif

    char *psz_dir;
    char *psz_parent = config_GetShellDir (CSIDL_APPDATA);

    if (psz_parent == NULL
     ||  asprintf (&psz_dir, ""%s\\vlc"", psz_parent) == -1)
        psz_dir = NULL;
    free (psz_parent);
    return psz_dir;
}",225.0,252.0,1.0,1.0,28.0,14,7,22,7,0,1,4,5,0,1,,0,1,2,1,1,char*
2178,171041,vlc_cloexec,1,vlc_cloexec,void vlc_cloexec (int),posix\filesystem.c,"static inline void vlc_cloexec(int fd)
{
    fcntl(fd, F_SETFD, FD_CLOEXEC | fcntl(fd, F_GETFD));
}",53.0,56.0,1.0,1.0,4.0,1,1,5,4,1,0,1,1,0,0,,0,0,2,1,1,void
2179,171119,vlc_mkstemp,1,vlc_mkstemp,int vlc_mkstemp (char*),posix\filesystem.c,"int vlc_mkstemp (char *template)
{
#if defined (HAVE_MKOSTEMP) && defined (O_CLOEXEC)
    return mkostemp(template, O_CLOEXEC);
#else
    int fd = mkstemp(template);
    if (fd != -1)
        vlc_cloexec(fd);
    return fd;
#endif
}",100.0,110.0,1.0,1.0,11.0,3,3,5,2,0,1,2,2,0,1,,0,0,2,1,1,int
2180,171625,vlc_gai_thread,1,vlc_gai_thread,void* vlc_gai_thread (void*),posix\getaddrinfo.c,"static void *vlc_gai_thread(void *data)
{
    struct vlc_gai_req *req = data;

    req->error = EAI_SYSTEM;
    req->error = getaddrinfo(req->name, req->service, req->hints,
                             &req->result);
    vlc_sem_post(&req->done);
    return NULL;
}",43.0,52.0,1.0,1.0,10.0,12,3,11,4,0,9,1,1,0,2,,0,8,2,1,1,void*
2181,172121,vlc_rand_init,1,vlc_rand_init,void vlc_rand_init (void),posix\rand.c,"static void vlc_rand_init (void)
{
    uint8_t key[BLOCK_SIZE];

    /* Get non-predictible value as key for HMAC */
    int fd = vlc_open (""/dev/urandom"", O_RDONLY);
    if (fd == -1)
        return; /* Uho! */

    for (size_t i = 0; i < sizeof (key);)
    {
         ssize_t val = read (fd, key + i, sizeof (key) - i);
         if (val > 0)
             i += val;
    }

    /* Precompute outer and inner keys for HMAC */
    for (size_t i = 0; i < sizeof (key); i++)
    {
        okey[i] = key[i] ^ 0x5c;
        ikey[i] = key[i] ^ 0x36;
    }

    vlc_close (fd);
}",50.0,74.0,1.0,16.0,25.0,23,11,27,7,0,4,5,6,0,2,,0,3,2,1,1,void
2182,173509,vlc_timer_thread,1,vlc_timer_thread,void* vlc_timer_thread (void*),posix\timer.c,"static void *vlc_timer_thread (void *data)
{
    struct vlc_timer *timer = data;

    vlc_mutex_lock (&timer->lock);
    mutex_cleanup_push (&timer->lock);

    for (;;)
    {
        while (timer->value == 0)
        {
            assert(timer->interval == 0);
            vlc_cond_wait (&timer->reschedule, &timer->lock);
        }

        if (timer->interval != 0)
        {
            mtime_t now = mdate();

            if (now > timer->value)
            {   /* Update overrun counter */
                unsigned misses = (now - timer->value) / timer->interval;

                timer->value += misses * timer->interval;
                assert(timer->value <= now);
                atomic_fetch_add_explicit(&timer->overruns, misses,
                                          memory_order_relaxed);
            }
        }

        mtime_t value = timer->value;

        if (vlc_cond_timedwait(&timer->reschedule, &timer->lock, value) == 0)
            continue;

        if (likely(timer-...",53.0,107.0,10.0,1.0,55.0,54,11,41,7,0,34,9,16,8,9,,0,28,2,1,1,void*
2183,173926,AddressCreate,1,AddressCreate,"sap_address_t AddressCreate (vlc_object_t*,char*)",stream_output\sap.c,"static sap_address_t *AddressCreate (vlc_object_t *obj, const char *group)
{
    int fd = net_ConnectUDP (obj, group, IPPORT_SAP, 255);
    if (fd == -1)
        return NULL;

    sap_address_t *addr = malloc (sizeof (*addr));
    if (addr == NULL)
    {
        net_Close (fd);
        return NULL;
    }

    strlcpy (addr->group, group, sizeof (addr->group));
    addr->fd = fd;
    addr->origlen = sizeof (addr->orig);
    getsockname (fd, (struct sockaddr *)&addr->orig, &addr->origlen);

    addr->interval = var_CreateGetInteger (obj, ""sap-interval"");
    vlc_mutex_init (&addr->lock);
    vlc_cond_init (&addr->wait);
    addr->session_count = 0;
    addr->first = NULL;

    if (vlc_clone (&addr->thread, RunThread, addr, VLC_THREAD_PRIORITY_LOW))
    {
        msg_Err (obj, ""unable to spawn SAP announce thread"");
        net_Close (fd);
        free (addr);
        return NULL;
    }
    return addr;
}",84.0,116.0,1.0,41.0,33.0,33,8,37,7,0,16,4,4,2,3,,0,14,4,2,2,sap_address_t
2184,174048,AddressDestroy,1,AddressDestroy,void AddressDestroy (sap_address_t*),stream_output\sap.c,"static void AddressDestroy (sap_address_t *addr)
{
    assert (addr->first == NULL);

    vlc_cancel (addr->thread);
    vlc_join (addr->thread, NULL);
    vlc_cond_destroy (&addr->wait);
    vlc_mutex_destroy (&addr->lock);
    net_Close (addr->fd);
    free (addr);
}",118.0,128.0,1.0,1.0,11.0,9,3,9,2,0,10,1,1,0,4,,0,6,2,1,1,void
2185,174748,AddressToSDP,1,AddressToSDP,"char* AddressToSDP (sockaddr*,socklen_t,char*)",stream_output\sdp.c,"static
char *AddressToSDP (const struct sockaddr *addr, socklen_t addrlen, char *buf)
{
    if (addrlen < offsetof (struct sockaddr, sa_family)
                 + sizeof (addr->sa_family))
        return NULL;

    strcpy (buf, ""IN IP* "");

    if (vlc_getnameinfo (addr, addrlen, buf + 7, MAXSDPADDRESS - 7, NULL,
                         NI_NUMERICHOST))
        return NULL;

    switch (addr->sa_family)
    {
        case AF_INET:
        {
            if (net_SockAddrIsMulticast (addr, addrlen))
                strcat (buf, ""/255""); // obsolete in RFC4566, dummy value
            buf[5] = '4';
            break;
        }

#ifdef AF_INET6
        case AF_INET6:
        {
            char *ptr = strchr (buf, '%');
            if (ptr != NULL)
                *ptr = '\0'; // remove scope ID
            buf[5] = '6';
            break;
        }
#endif

        default:
            return NULL;
    }

    return buf;
}",41.0,80.0,1.0,49.0,40.0,5,5,16,6,0,1,6,6,1,1,,0,1,6,3,3,char*
2186,174839,vsdp_AddAttribute,1,vsdp_AddAttribute,"void vsdp_AddAttribute (vlc_memstream*,char*,char*,va_list)",stream_output\sdp.c,"static void vsdp_AddAttribute(struct vlc_memstream *restrict stream,
                              const char *name, const char *fmt, va_list ap)
{
    vlc_memstream_printf(stream, ""a=%s:"", name);
    vlc_memstream_vprintf(stream, fmt, ap);
    vlc_memstream_puts(stream, ""\r\n"");
}",94.0,100.0,1.0,1.0,7.0,0,0,6,4,0,2,1,1,0,2,,0,0,8,4,4,void
2187,175293,sout_NewInstance,1,sout_NewInstance,"sout_instance_t sout_NewInstance (vlc_object_t*,char*)",stream_output\stream_output.c,"sout_instance_t *sout_NewInstance( vlc_object_t *p_parent, const char *psz_dest )
{
    sout_instance_t *p_sout;
    char *psz_chain;

    assert( psz_dest != NULL );

    if( psz_dest[0] == '#' )
    {
        psz_chain = strdup( &psz_dest[1] );
    }
    else
    {
        psz_chain = sout_stream_url_to_chain(
            var_InheritBool(p_parent, ""sout-display""), psz_dest );
    }
    if(!psz_chain)
        return NULL;

    /* *** Allocate descriptor *** */
    p_sout = vlc_custom_create( p_parent, sizeof( *p_sout ), ""stream output"" );
    if( p_sout == NULL )
    {
        free( psz_chain );
        return NULL;
    }

    msg_Dbg( p_sout, ""using sout chain=`%s'"", psz_chain );

    /* *** init descriptor *** */
    p_sout->psz_sout    = strdup( psz_dest );
    p_sout->i_out_pace_nocontrol = 0;

    vlc_mutex_init( &p_sout->lock );
    p_sout->p_stream = NULL;

    var_Create( p_sout, ""sout-mux-caching"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    p_sout->p_stream = sout_StreamC...",81.0,134.0,1.0,1.0,54.0,26,10,40,7,0,6,5,5,0,6,,0,2,4,2,2,sout_instance_t
2188,175419,sout_DeleteInstance,1,sout_DeleteInstance,void sout_DeleteInstance (sout_instance_t*),stream_output\stream_output.c,"void sout_DeleteInstance( sout_instance_t * p_sout )
{
    /* remove the stream out chain */
    sout_StreamChainDelete( p_sout->p_stream, NULL );

    /* *** free all string *** */
    FREENULL( p_sout->psz_sout );

    vlc_mutex_destroy( &p_sout->lock );

    /* *** free structure *** */
    vlc_object_release( p_sout );
}",139.0,151.0,1.0,1.0,13.0,4,2,5,2,0,3,1,1,0,3,,0,0,2,1,1,void
2189,175440,sout_InputNew,1,sout_InputNew,"sout_packetizer_input_t sout_InputNew (sout_instance_t*,es_format_t*)",stream_output\stream_output.c,"sout_packetizer_input_t *sout_InputNew( sout_instance_t *p_sout,
                                        const es_format_t *p_fmt )
{
    sout_packetizer_input_t *p_input;

    /* *** create a packetizer input *** */
    if( !p_fmt->i_codec || !(p_input = malloc(sizeof(sout_packetizer_input_t))) )
        return NULL;

    p_input->p_sout = p_sout;

    msg_Dbg( p_sout, ""adding a new sout input for `%4.4s` (sout_input: %p)"",
             (char*) &p_fmt->i_codec, (void *)p_input );

    /* *** add it to the stream chain */
    vlc_mutex_lock( &p_sout->lock );
    p_input->id = p_sout->p_stream->pf_add( p_sout->p_stream, p_fmt );
    vlc_mutex_unlock( &p_sout->lock );

    if( p_input->id == NULL )
    {
        msg_Warn( p_sout, ""new sout input failed (sout_input: %p)"",
                 (void *)p_input );
        free( p_input );
        p_input = NULL;
    }

    return( p_input );
}",156.0,184.0,1.0,1.0,29.0,25,8,23,5,0,5,3,3,1,2,,0,3,4,2,2,sout_packetizer_input_t
2190,175523,sout_InputDelete,1,sout_InputDelete,int sout_InputDelete (sout_packetizer_input_t*),stream_output\stream_output.c,"int sout_InputDelete( sout_packetizer_input_t *p_input )
{
    sout_instance_t     *p_sout = p_input->p_sout;

    msg_Dbg( p_sout, ""removing a sout input (sout_input: %p)"",
             (void *)p_input );

    vlc_mutex_lock( &p_sout->lock );
    p_sout->p_stream->pf_del( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );

    free( p_input );

    return( VLC_SUCCESS);
}",189.0,203.0,1.0,1.0,15.0,11,4,11,3,0,4,1,1,0,2,,0,2,2,1,1,int
2191,175566,sout_InputIsEmpty,1,sout_InputIsEmpty,bool sout_InputIsEmpty (sout_packetizer_input_t*),stream_output\stream_output.c,"bool sout_InputIsEmpty( sout_packetizer_input_t *p_input )
{
    sout_instance_t *p_sout = p_input->p_sout;
    bool b;

    vlc_mutex_lock( &p_sout->lock );
    if( sout_StreamControl( p_sout->p_stream, SOUT_STREAM_EMPTY, &b ) != VLC_SUCCESS )
        b = true;
    vlc_mutex_unlock( &p_sout->lock );
    return b;
}",205.0,215.0,1.0,1.0,11.0,10,4,11,6,0,3,2,2,0,2,,0,1,2,1,1,bool
2192,175604,sout_InputFlush,1,sout_InputFlush,void sout_InputFlush (sout_packetizer_input_t*),stream_output\stream_output.c,"void sout_InputFlush( sout_packetizer_input_t *p_input )
{
    sout_instance_t     *p_sout = p_input->p_sout;

    vlc_mutex_lock( &p_sout->lock );
    sout_StreamFlush( p_sout->p_stream, p_input->id );
    vlc_mutex_unlock( &p_sout->lock );
}",217.0,224.0,1.0,1.0,8.0,8,3,6,2,0,4,1,1,0,2,,0,2,2,1,1,void
2193,175632,sout_InputSendBuffer,1,sout_InputSendBuffer,"int sout_InputSendBuffer (sout_packetizer_input_t*,block_t*)",stream_output\stream_output.c,"int sout_InputSendBuffer( sout_packetizer_input_t *p_input,
                          block_t *p_buffer )
{
    sout_instance_t     *p_sout = p_input->p_sout;
    int                 i_ret;

    vlc_mutex_lock( &p_sout->lock );
    i_ret = p_sout->p_stream->pf_send( p_sout->p_stream,
                                       p_input->id, p_buffer );
    vlc_mutex_unlock( &p_sout->lock );

    return i_ret;
}",229.0,241.0,1.0,1.0,13.0,11,3,10,4,0,4,1,1,0,2,,0,2,4,2,2,int
2194,176724,sout_StreamDelete,1,sout_StreamDelete,void sout_StreamDelete (sout_stream_t*),stream_output\stream_output.c,"static void sout_StreamDelete( sout_stream_t *p_stream )
{
    sout_instance_t *p_sout = (sout_instance_t *)(p_stream->obj.parent);

    msg_Dbg( p_stream, ""destroying chain... (name=%s)"", p_stream->psz_name );

    p_sout->i_out_pace_nocontrol -= p_stream->pace_nocontrol;

    if( p_stream->p_module != NULL )
        module_unneed( p_stream, p_stream->p_module );

    FREENULL( p_stream->psz_name );

    config_ChainDestroy( p_stream->p_cfg );

    msg_Dbg( p_stream, ""destroying chain done"" );
    vlc_object_release( p_stream );
}",736.0,753.0,1.0,1.0,18.0,13,6,14,3,1,3,2,2,0,3,,0,0,2,1,1,void
2195,176805,sout_StreamNew,1,sout_StreamNew,"sout_stream_t sout_StreamNew (sout_instance_t*,char*,config_chain_t*,sout_stream_t*)",stream_output\stream_output.c,"static sout_stream_t *sout_StreamNew( sout_instance_t *p_sout, char *psz_name,
                               config_chain_t *p_cfg, sout_stream_t *p_next)
{
    sout_stream_t *p_stream;

    assert(psz_name);

    p_stream = vlc_custom_create( p_sout, sizeof( *p_stream ), ""stream out"" );
    if( !p_stream )
        return NULL;

    p_stream->p_sout   = p_sout;
    p_stream->psz_name = psz_name;
    p_stream->p_cfg    = p_cfg;
    p_stream->p_next   = p_next;
    p_stream->pf_flush = NULL;
    p_stream->pf_control = NULL;
    p_stream->pace_nocontrol = false;
    p_stream->p_sys = NULL;

    msg_Dbg( p_sout, ""stream=`%s'"", p_stream->psz_name );

    p_stream->p_module =
        module_need( p_stream, ""sout stream"", p_stream->psz_name, true );

    if( !p_stream->p_module )
    {
        /* those must be freed by the caller if creation failed */
        p_stream->psz_name = NULL;
        p_stream->p_cfg = NULL;

        sout_StreamDelete( p_stream );
        return NULL;
    }

    ...",779.0,816.0,1.0,1.0,38.0,33,6,38,8,0,3,3,3,0,3,,0,2,8,4,4,sout_stream_t
2196,177352,us_strtod,1,us_strtod,"double us_strtod (char*,char**)",text\charset.c,"double us_strtod( const char *str, char **end )
{
    locale_t loc = newlocale (LC_NUMERIC_MASK, ""C"", NULL);
    locale_t oldloc = uselocale (loc);
    double res = strtod (str, end);

    if (loc != (locale_t)0)
    {
        uselocale (oldloc);
        freelocale (loc);
    }
    return res;
}",50.0,62.0,1.0,1.0,13.0,5,3,12,7,1,0,2,2,0,0,,0,0,4,2,2,double
2197,177426,us_atof,1,us_atof,double us_atof (char*),text\charset.c,"double us_atof( const char *str )
{
    return us_strtod( str, NULL );
}",88.0,91.0,1.0,1.0,4.0,0,0,2,2,2,1,1,1,0,1,,0,0,2,1,1,double
2198,177435,us_vasprintf,1,us_vasprintf,"int us_vasprintf (char**,char*,va_list)",text\charset.c,"int us_vasprintf( char **ret, const char *format, va_list ap )
{
    locale_t loc = newlocale( LC_NUMERIC_MASK, ""C"", NULL );
    locale_t oldloc = uselocale( loc );

    int i_rc = vasprintf( ret, format, ap );

    if ( loc != (locale_t)0 )
    {
        uselocale( oldloc );
        freelocale( loc );
    }

    return i_rc;
}",98.0,112.0,1.0,1.0,15.0,5,3,13,8,2,0,2,2,0,0,,0,0,6,3,3,int
2199,177474,us_asprintf,1,us_asprintf,"int us_asprintf (char**,char*...)",text\charset.c,"int us_asprintf( char **ret, const char *format, ... )
{
    va_list ap;
    int i_rc;

    va_start( ap, format );
    i_rc = us_vasprintf( ret, format, ap );
    va_end( ap );

    return i_rc;
}",119.0,129.0,1.0,1.0,11.0,1,1,8,4,0,1,1,1,0,1,,0,1,4,2,2,int
2200,177520,vlc_fopen,1,vlc_fopen,"FILE vlc_fopen (char*,char*)",text\filesystem.c,"FILE *vlc_fopen (const char *filename, const char *mode)
{
    int rwflags = 0, oflags = 0;

    for (const char *ptr = mode; *ptr; ptr++)
    {
        switch (*ptr)
        {
            case 'r':
                rwflags = O_RDONLY;
                break;

            case 'a':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_APPEND;
                break;

            case 'w':
                rwflags = O_WRONLY;
                oflags |= O_CREAT | O_TRUNC;
                break;

            case 'x':
                oflags |= O_EXCL;
                break;

            case '+':
                rwflags = O_RDWR;
                break;

#ifdef O_BINARY
            case 'b':
                oflags = (oflags & ~O_TEXT) | O_BINARY;
                break;

            case 't':
                oflags = (oflags & ~O_BINARY) | O_TEXT;
                break;
#endif
        }
    }

    int fd = vlc_open (filename, rwflags | oflags, 0666);
    if (fd == -1)
    ...",48.0,99.0,1.0,1.0,52.0,17,5,35,15,7,2,10,6,0,2,,0,1,4,2,2,FILE
2201,177631,vlc_loaddir,1,vlc_loaddir,"int vlc_loaddir (DIR*,char***,int,int)",text\filesystem.c,"int vlc_loaddir( DIR *dir, char ***namelist,
                  int (*select)( const char * ),
                  int (*compar)( const char **, const char ** ) )
{
    assert (dir);

    if (select == NULL)
        select = dummy_select;

    char **tab = NULL;
    unsigned num = 0;

    rewinddir (dir);

    for (unsigned size = 0;;)
    {
        errno = 0;
        const char *entry = vlc_readdir (dir);
        if (entry == NULL)
        {
            if (errno)
                goto error;
            break;
        }

        if (!select (entry))
            continue;

        if (num >= size)
        {
            size = size ? (2 * size) : 16;
            char **newtab = realloc (tab, sizeof (*tab) * (size));

            if (unlikely(newtab == NULL))
                goto error;
            tab = newtab;
        }

        tab[num] = strdup(entry);
        if (likely(tab[num] != NULL))
            num++;
    }

    if (compar != NULL && num > 0)
        qsort (tab, num, sizeof (*...",112.0,166.0,1.0,1.0,55.0,35,16,50,12,1,1,15,19,0,1,,0,1,8,4,4,int
2202,177784,vlc_scandir,1,vlc_scandir,"int vlc_scandir (char*,char***,int,int)",text\filesystem.c,"int vlc_scandir( const char *dirname, char ***namelist,
                  int (*select)( const char * ),
                  int (*compar)( const char **, const char ** ) )
{
    DIR *dir = vlc_opendir (dirname);
    int val = -1;

    if (dir != NULL)
    {
        val = vlc_loaddir (dir, namelist, select, compar);
        closedir (dir);
    }
    return val;
}",179.0,192.0,1.0,1.0,14.0,5,3,12,7,0,2,2,2,0,2,,0,2,8,4,4,int
2203,178857,GetLang_1,1,GetLang_1,iso639_lang_t GetLang_1 (char*),text\iso_lang.c,"const iso639_lang_t * GetLang_1( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_1, psz_code, 2 ) )
            return p_lang;

    return &unknown_language;
}",47.0,56.0,1.0,1.0,10.0,3,3,4,3,0,1,2,2,0,0,,0,1,2,1,1,iso639_lang_t
2204,178887,GetLang_2T,1,GetLang_2T,iso639_lang_t GetLang_2T (char*),text\iso_lang.c,"const iso639_lang_t * GetLang_2T( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2T, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",58.0,67.0,1.0,1.0,10.0,3,3,4,3,0,1,2,2,0,0,,0,1,2,1,1,iso639_lang_t
2205,178917,GetLang_2B,1,GetLang_2B,iso639_lang_t GetLang_2B (char*),text\iso_lang.c,"const iso639_lang_t * GetLang_2B( const char * psz_code )
{
    const iso639_lang_t *p_lang;

    for( p_lang = p_languages; p_lang->psz_eng_name; p_lang++ )
        if( !strncasecmp( p_lang->psz_iso639_2B, psz_code, 3 ) )
            return p_lang;

    return &unknown_language;
}",69.0,78.0,1.0,1.0,10.0,3,3,4,3,0,1,2,2,0,0,,0,1,2,1,1,iso639_lang_t
2206,178960,vlc_memstream_open,1,vlc_memstream_open,int vlc_memstream_open (vlc_memstream*),text\memstream.c,"int vlc_memstream_open(struct vlc_memstream *ms)
{
    ms->error = 0;
    ms->ptr = calloc(1, 1);
    if (unlikely(ms->ptr == NULL))
        ms->error = EOF;
    ms->length = 0;
    return ms->error;
}",105.0,113.0,1.0,1.0,9.0,11,3,8,3,6,0,2,2,0,0,,0,0,2,1,1,int
2207,179008,vlc_memstream_close,1,vlc_memstream_close,int vlc_memstream_close (vlc_memstream*),text\memstream.c,"int vlc_memstream_close(struct vlc_memstream *ms)
{
    if (ms->error)
        free(ms->ptr);
    return ms->error;
}",120.0,125.0,1.0,1.0,6.0,3,1,3,1,8,0,2,2,0,0,,0,0,2,1,1,int
2208,179026,vlc_memstream_write,1,vlc_memstream_write,"size_t vlc_memstream_write (vlc_memstream*,void*,size_t)",text\memstream.c,"size_t vlc_memstream_write(struct vlc_memstream *ms, const void *ptr,
                           size_t len)
{
    char *base = realloc(ms->ptr, ms->length + len + 1u);
    if (unlikely(base == NULL))
        goto error;

    memcpy(base + ms->length, ptr, len);
    ms->ptr = base;
    ms->length += len;
    base[ms->length] = '\0';
    return len;

error:
    ms->error = EOF;
    return 0;
}",127.0,143.0,1.0,1.0,17.0,17,6,19,6,5,0,3,2,0,0,,0,0,6,3,3,size_t
2209,179089,vlc_memstream_putc,1,vlc_memstream_putc,"int vlc_memstream_putc (vlc_memstream*,int)",text\memstream.c,"int vlc_memstream_putc(struct vlc_memstream *ms, int c)
{
    return (vlc_memstream_write(ms, &(unsigned char){ c }, 1u) == 1) ? c : EOF;
}",145.0,148.0,1.0,1.0,4.0,5,5,4,3,5,1,1,1,0,1,,0,0,4,2,2,int
2210,179109,vlc_memstream_puts,1,,"int (vlc_memstream*,char*)",text\memstream.c,"int (vlc_memstream_puts)(struct vlc_memstream *ms, const char *str)
{
    size_t len = strlen(str);
    return (vlc_memstream_write(ms, str, len) == len) ? 0 : EOF;
}",150.0,154.0,1.0,1.0,5.0,3,3,7,4,0,1,1,1,0,1,,0,0,4,2,2,int
2211,179130,vlc_memstream_vprintf,1,vlc_memstream_vprintf,"int vlc_memstream_vprintf (vlc_memstream*,char*,va_list)",text\memstream.c,"int vlc_memstream_vprintf(struct vlc_memstream *ms, const char *fmt,
                          va_list args)
{
    va_list ap;
    char *ptr;
    int len;

    va_copy(ap, args);
    len = vsnprintf(NULL, 0, fmt, ap);
    va_end(ap);

    if (len < 0)
        goto error;

    ptr = realloc(ms->ptr, ms->length + len + 1);
    if (ptr == NULL)
        goto error;

    vsnprintf(ptr + ms->length, len + 1, fmt, args);
    ms->ptr = ptr;
    ms->length += len;
    return len;

error:
    ms->error = EOF;
    return EOF;
}",156.0,182.0,1.0,1.0,27.0,17,6,27,8,2,0,5,3,0,0,,0,0,6,3,3,int
2212,179208,vlc_memstream_printf,1,vlc_memstream_printf,"int vlc_memstream_printf (vlc_memstream*,char*...)",text\memstream.c,"int vlc_memstream_printf(struct vlc_memstream *ms, const char *fmt, ...)
{
    va_list ap;
    int ret;

    va_start(ap, fmt);
    ret = vlc_memstream_vprintf(ms, fmt, ap);
    va_end(ap);
    return ret;
}",185.0,194.0,1.0,1.0,10.0,1,1,8,4,12,1,1,1,0,1,,0,1,4,2,2,int
2213,179653,cmp_entity,1,cmp_entity,"int cmp_entity (void*,void*)",text\strings.c,"static int cmp_entity (const void *key, const void *elem)
{
    const struct xml_entity_s *ent = elem;
    const char *name = key;

    return strncmp (name, ent->psz_entity, strlen (ent->psz_entity));
}",190.0,196.0,1.0,1.0,7.0,4,2,7,4,0,2,1,1,0,0,,0,2,4,2,2,int
2214,179947,vlc_xml_encode,1,vlc_xml_encode,char* vlc_xml_encode (char*),text\strings.c,"char *vlc_xml_encode (const char *str)
{
    struct vlc_memstream stream;
    size_t n;
    uint32_t cp;

    assert(str != NULL);
    vlc_memstream_open(&stream);

    while ((n = vlc_towc (str, &cp)) != 0)
    {
        if (unlikely(n == (size_t)-1))
        {
            if (vlc_memstream_close(&stream) == 0)
                free(stream.ptr);
            errno = EILSEQ;
            return NULL;
        }

        switch (cp)
        {
            case '\""':
                vlc_memstream_puts(&stream, ""&quot;"");
                break;
            case '&':
                vlc_memstream_puts(&stream, ""&amp;"");
                break;
            case '\'':
                vlc_memstream_puts(&stream, ""&#39;"");
                break;
            case '<':
                vlc_memstream_puts(&stream, ""&lt;"");
                break;
            case '>':
                vlc_memstream_puts(&stream, ""&gt;"");
                break;
            default:
                if (cp < 32) /* C0 cod...",290.0,348.0,1.0,1.0,59.0,24,10,30,8,1,5,16,16,3,5,,0,3,2,1,1,char*
2215,180080,vlc_b64_encode_binary,1,vlc_b64_encode_binary,"char* vlc_b64_encode_binary (uint8_t*,size_t)",text\strings.c,"char *vlc_b64_encode_binary( const uint8_t *src, size_t i_src )
{
    static const char b64[] =
           ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"";

    char *ret = malloc( ( i_src + 4 ) * 4 / 3 );
    char *dst = ret;

    if( dst == NULL )
        return NULL;

    while( i_src > 0 )
    {
        /* pops (up to) 3 bytes of input, push 4 bytes */
        uint32_t v;

        /* 1/3 -> 1/4 */
        v = ((unsigned)*src++) << 24;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 2/3 -> 2/4 */
        if( i_src >= 2 )
            v |= *src++ << 22;
        *dst++ = b64[v >> 26];
        v = v << 6;

        /* 3/3 -> 3/4 */
        if( i_src >= 3 )
            v |= *src++ << 20; // 3/3
        *dst++ = ( i_src >= 2 ) ? b64[v >> 26] : '='; // 3/4
        v = v << 6;

        /* -> 4/4 */
        *dst++ = ( i_src >= 3 ) ? b64[v >> 26] : '='; // 4/4

        if( i_src <= 3 )
            break;
        i_src -= 3;
    }

    *dst = '\0';

    retu...",351.0,395.0,1.0,1.0,45.0,55,16,41,7,1,0,7,9,0,0,,0,0,4,2,2,char*
2216,180227,vlc_b64_encode,1,vlc_b64_encode,char* vlc_b64_encode (char*),text\strings.c,"char *vlc_b64_encode( const char *src )
{
    if( src )
        return vlc_b64_encode_binary( (const uint8_t*)src, strlen(src) );
    else
        return vlc_b64_encode_binary( (const uint8_t*)"""", 0 );
}",397.0,403.0,1.0,1.0,7.0,1,1,3,1,0,1,2,2,0,1,,0,0,2,1,1,char*
2217,180250,vlc_b64_decode_binary_to_buffer,1,vlc_b64_decode_binary_to_buffer,"size_t vlc_b64_decode_binary_to_buffer (uint8_t*,size_t,char*)",text\strings.c,"size_t vlc_b64_decode_binary_to_buffer( uint8_t *p_dst, size_t i_dst, const char *p_src )
{
    static const int b64[256] = {
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 00-0F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 10-1F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,  /* 20-2F */
        52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,  /* 30-3F */
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,  /* 40-4F */
        15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,  /* 50-5F */
        -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,  /* 60-6F */
        41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,  /* 70-7F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 80-8F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* 90-9F */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* A0-AF */
        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,  /* B0-BF */
        -1,-1,-1,-1,-1,-1,-1,-1...",406.0,459.0,1.0,1.0,54.0,238,17,33,9,4,0,8,6,0,0,,0,0,6,3,3,size_t
2218,180829,vlc_b64_decode_binary,1,vlc_b64_decode_binary,"size_t vlc_b64_decode_binary (uint8_t**,char*)",text\strings.c,"size_t vlc_b64_decode_binary( uint8_t **pp_dst, const char *psz_src )
{
    const int i_src = strlen( psz_src );
    uint8_t   *p_dst;

    *pp_dst = p_dst = malloc( i_src );
    if( !p_dst )
        return 0;
    return  vlc_b64_decode_binary_to_buffer( p_dst, i_src, psz_src );
}",460.0,469.0,1.0,1.0,10.0,5,3,9,4,0,1,2,2,0,1,,0,0,4,2,2,size_t
2219,180859,vlc_b64_decode,1,vlc_b64_decode,char* vlc_b64_decode (char*),text\strings.c,"char *vlc_b64_decode( const char *psz_src )
{
    const int i_src = strlen( psz_src );
    char *p_dst = malloc( i_src + 1 );
    size_t i_dst;
    if( !p_dst )
        return NULL;

    i_dst = vlc_b64_decode_binary_to_buffer( (uint8_t*)p_dst, i_src, psz_src );
    p_dst[i_dst] = '\0';

    return p_dst;
}",470.0,482.0,1.0,1.0,13.0,8,5,13,5,1,1,2,2,0,1,,0,1,2,1,1,char*
2220,180978,write_duration,1,write_duration,"void write_duration (vlc_memstream*,int64_t)",text\strings.c,"static void write_duration(struct vlc_memstream *stream, int64_t duration)
{
    lldiv_t d;
    long long sec;

    duration /= CLOCK_FREQ;
    d = lldiv(duration, 60);
    sec = d.rem;
    d = lldiv(d.quot, 60);
    vlc_memstream_printf(stream, ""%02lld:%02lld:%02lld"", d.quot, d.rem, sec);
}",514.0,524.0,1.0,1.0,11.0,8,3,12,5,3,1,1,1,0,1,,0,0,4,2,2,void
2221,181016,write_meta,1,write_meta,"int write_meta (vlc_memstream*,input_item_t*,vlc_meta_type_t)",text\strings.c,"static int write_meta(struct vlc_memstream *stream, input_item_t *item,
                      vlc_meta_type_t type)
{
    if (item == NULL)
        return EOF;

    char *value = input_item_GetMeta(item, type);
    if (value == NULL)
        return EOF;

    vlc_memstream_puts(stream, value);
    free(value);
    return 0;
}",526.0,539.0,1.0,1.0,14.0,3,2,12,6,14,1,3,3,0,1,,0,1,6,3,3,int
2222,181050,vlc_strfinput,1,vlc_strfinput,"char* vlc_strfinput (input_thread_t*,char*)",text\strings.c,"char *vlc_strfinput(input_thread_t *input, const char *s)
{
    struct vlc_memstream stream[1];

    input_item_t *item = (input != NULL) ? input_GetItem(input) : NULL;

    char c;
    bool b_is_format = false;
    bool b_empty_if_na = false;

    assert(s != NULL);

    vlc_memstream_open(stream);

    while ((c = *s) != '\0')
    {
        s++;

        if (!b_is_format)
        {
            if (c == '$')
            {
                b_is_format = true;
                b_empty_if_na = false;
                continue;
            }

            vlc_memstream_putc(stream, c);
            continue;
        }

        b_is_format = false;

        switch (c)
        {
            case 'a':
                write_meta(stream, item, vlc_meta_Artist);
                break;
            case 'b':
                write_meta(stream, item, vlc_meta_Album);
                break;
            case 'c':
                write_meta(stream, item, vlc_meta_Copyright);
                break;
     ...",541.0,829.0,1.0,1.0,289.0,73,15,189,32,0,39,68,83,1,39,,0,9,4,2,2,char*
2223,181734,vlc_filenamecmp,1,vlc_filenamecmp,"int vlc_filenamecmp (char*,char*)",text\strings.c,"int vlc_filenamecmp(const char *a, const char *b)
{
    size_t i;
    char ca, cb;

    /* Attempt to guess if the sorting algorithm should be alphabetic
     * (i.e. collation) or numeric:
     * - If the first mismatching characters are not both digits,
     *   then collation is the only option.
     * - If one of the first mismatching characters is 0 and the other is also
     *   a digit, the comparands are probably left-padded numerical values.
     *   It does not matter which algorithm is used: the zero will be smaller
     *   than non-zero either way.
     * - Otherwise, the comparands are numerical values, and might not be
     *   aligned (i.e. not same order of magnitude). If so, collation would
     *   fail. So numerical comparison is performed. */
    for (i = 0; (ca = a[i]) == (cb = b[i]); i++)
        if (ca == '\0')
            return 0; /* strings are exactly identical */

    if ((unsigned)(ca - '0') > 9 || (unsigned)(cb - '0') > 9)
        return strcoll(a, b);...",831.0,864.0,1.0,15.0,34.0,22,11,25,8,1,0,4,4,0,0,,0,0,4,2,2,int
2224,181829,filename_sanitize,1,filename_sanitize,void filename_sanitize (char*),text\strings.c,"void filename_sanitize( char *str )
{
    unsigned char c;

    /* Special file names, not allowed */
    if( !strcmp( str, ""."" ) || !strcmp( str, "".."" ) )
    {
        while( *str )
            *(str++) = '_';
        return;
    }

    /* On platforms not using UTF-8, VLC cannot access non-Unicode paths.
     * Also, some file systems require Unicode file names.
     * NOTE: This may inserts '?' thus is done replacing '?' with '_'. */
    EnsureUTF8( str );

    /* Avoid leading spaces to please Windows. */
    while( (c = *str) != '\0' )
    {
        if( c != ' ' )
            break;
        *(str++) = '_';
    }

    char *start = str;

    while( (c = *str) != '\0' )
    {
        /* Non-printable characters are not a good idea */
        if( c < 32 )
            *str = '_';
        /* This is the list of characters not allowed by Microsoft.
         * We also black-list them on Unix as they may be confusing, and are
         * not supported by some file system types (notably...",877.0,924.0,1.0,1.0,48.0,25,9,19,3,5,0,11,13,0,0,,0,0,2,1,1,void
2225,181958,utf8_vfprintf,1,utf8_vfprintf,"int utf8_vfprintf (FILE*,char*,va_list)",text\unicode.c,"int utf8_vfprintf( FILE *stream, const char *fmt, va_list ap )
{
#ifndef _WIN32
    return vfprintf (stream, fmt, ap);
#else
    char *str;
    int res = vasprintf (&str, fmt, ap);
    if (unlikely(res == -1))
        return -1;

#if !VLC_WINSTORE_APP
    /* Writing to the console is a lot of fun on Microsoft Windows.
     * If you use the standard I/O functions, you must use the OEM code page,
     * which is different from the usual ANSI code page. Or maybe not, if the
     * user called ""chcp"". Anyway, we prefer Unicode. */
    int fd = _fileno (stream);
    if (likely(fd != -1) && _isatty (fd))
    {
        wchar_t *wide = ToWide (str);
        if (likely(wide != NULL))
        {
            HANDLE h = (HANDLE)((uintptr_t)_get_osfhandle (fd));
            DWORD out;
            /* XXX: It is not clear whether WriteConsole() wants the number of
             * Unicode characters or the size of the wchar_t array. */
            BOOL ok = WriteConsoleW (h, wide, wcslen (wide), &out...",52.0,96.0,1.0,1.0,45.0,0,0,3,3,1,0,1,1,0,0,,0,0,6,3,3,int
2226,181970,utf8_fprintf,1,utf8_fprintf,"int utf8_fprintf (FILE*,char*...)",text\unicode.c,"int utf8_fprintf( FILE *stream, const char *fmt, ... )
{
    va_list ap;
    int res;

    va_start( ap, fmt );
    res = utf8_vfprintf( stream, fmt, ap );
    va_end( ap );
    return res;
}",102.0,111.0,1.0,1.0,10.0,1,1,8,4,0,1,1,1,0,1,,0,1,4,2,2,int
2227,181991,vlc_towc,1,vlc_towc,"size_t vlc_towc (char*,uint32_t*)",text\unicode.c,"size_t vlc_towc (const char *str, uint32_t *restrict pwc)
{
    uint8_t *ptr = (uint8_t *)str, c;
    uint32_t cp;

    assert (str != NULL);

    c = *ptr;
    if (unlikely(c > 0xF4))
        return -1;

    int charlen = clz8 (c ^ 0xFF);
    switch (charlen)
    {
        case 0: // 7-bit ASCII character -> short cut
            *pwc = c;
            return c != '\0';

        case 1: // continuation byte -> error
            return -1;

        case 2:
            if (unlikely(c < 0xC2)) // ASCII overlong
                return -1;
            cp = (c & 0x1F) << 6;
            break;

        case 3:
            cp = (c & 0x0F) << 12;
            break;

        case 4:
            cp = (c & 0x07) << 18;
            break;

        default:
            vlc_assert_unreachable ();
    }

    /* Unrolled continuation bytes decoding */
    switch (charlen)
    {
        case 4:
            c = *++ptr;
            if (unlikely((c & 0xC0) != 0x80)) // not a continuation byte
          ...",113.0,185.0,1.0,1.0,73.0,60,15,44,7,6,0,15,18,0,0,,0,0,4,2,2,size_t
2228,182208,vlc_strcasestr,1,vlc_strcasestr,"char* vlc_strcasestr (char*,char*)",text\unicode.c,"char *vlc_strcasestr (const char *haystack, const char *needle)
{
    ssize_t s;

    do
    {
        const char *h = haystack, *n = needle;

        for (;;)
        {
            uint32_t cph, cpn;

            s = vlc_towc (n, &cpn);
            if (s == 0)
                return (char *)haystack;
            if (unlikely(s < 0))
                return NULL;
            n += s;

            s = vlc_towc (h, &cph);
            if (s <= 0 || towlower (cph) != towlower (cpn))
                break;
            h += s;
        }

        s = vlc_towc (haystack, &(uint32_t) { 0 });
        haystack += s;
    }
    while (s > 0);

    return NULL;
}",198.0,229.0,1.0,1.0,32.0,20,11,27,8,3,3,7,13,0,3,,0,3,4,2,2,char*
2229,182294,FromCharset,1,FromCharset,"char* FromCharset (char*,void*,size_t)",text\unicode.c,"char *FromCharset(const char *charset, const void *data, size_t data_size)
{
    vlc_iconv_t handle = vlc_iconv_open (""UTF-8"", charset);
    if (handle == (vlc_iconv_t)(-1))
        return NULL;

    char *out = NULL;
    for(unsigned mul = 4; mul < 8; mul++ )
    {
        size_t in_size = data_size;
        const char *in = data;
        size_t out_max = mul * data_size;
        char *tmp = out = malloc (1 + out_max);
        if (!out)
            break;

        if (vlc_iconv (handle, &in, &in_size, &tmp, &out_max) != (size_t)(-1)) {
            *tmp = '\0';
            break;
        }
        free(out);
        out = NULL;

        if (errno != E2BIG)
            break;
    }
    vlc_iconv_close(handle);
    return out;
}",237.0,265.0,1.0,1.0,29.0,24,10,32,13,0,3,9,9,1,3,,0,2,6,3,3,char*
2230,182396,ToCharset,1,ToCharset,"void* ToCharset (char*,char*,size_t*)",text\unicode.c,"void *ToCharset(const char *charset, const char *in, size_t *outsize)
{
    vlc_iconv_t hd = vlc_iconv_open (charset, ""UTF-8"");
    if (hd == (vlc_iconv_t)(-1))
        return NULL;

    const size_t inlen = strlen (in);
    void *res;

    for (unsigned mul = 4; mul < 16; mul++)
    {
        size_t outlen = mul * (inlen + 1);
        res = malloc (outlen);
        if (unlikely(res == NULL))
            break;

        const char *inp = in;
        char *outp = res;
        size_t inb = inlen;
        size_t outb = outlen - mul;

        if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
        {
            *outsize = outlen - mul - outb;
            outb += mul;
            inb = 1; /* append nul terminator if possible */
            if (vlc_iconv (hd, &inp, &inb, &outp, &outb) != (size_t)(-1))
                break;
            if (errno == EILSEQ) /* cannot translate nul terminator!? */
                break;
        }

        free (res);
        res = NULL;
      ...",279.0,318.0,1.0,1.0,40.0,37,11,50,16,0,4,12,15,2,4,,0,3,6,3,3,void*
2231,182580,vlc_uri_decode_duplicate,1,vlc_uri_decode_duplicate,char* vlc_uri_decode_duplicate (char*),text\url.c,"char *vlc_uri_decode_duplicate (const char *str)
{
    char *buf = strdup (str);
    if (vlc_uri_decode (buf) == NULL)
    {
        free (buf);
        buf = NULL;
    }
    return buf;
}",43.0,52.0,1.0,1.0,10.0,3,2,8,3,2,1,2,2,1,1,,0,1,2,1,1,char*
2232,182603,vlc_uri_decode,1,vlc_uri_decode,char* vlc_uri_decode (char*),text\url.c,"char *vlc_uri_decode (char *str)
{
    char *in = str, *out = str;
    if (in == NULL)
        return NULL;

    char c;
    while ((c = *(in++)) != '\0')
    {
        if (c == '%')
        {
            char hex[3];

            if (!(hex[0] = *(in++)) || !(hex[1] = *(in++)))
                return NULL;
            hex[2] = '\0';
            *(out++) = strtoul (hex, NULL, 0x10);
        }
        else
            *(out++) = c;
    }
    *out = '\0';
    return str;
}",54.0,77.0,1.0,1.0,24.0,26,8,21,6,5,0,5,8,0,0,,0,0,2,1,1,char*
2233,182686,isurisafe,1,isurisafe,bool isurisafe (int),text\url.c,"static bool isurisafe (int c)
{
    /* These are the _unreserved_ URI characters (RFC3986 §2.3) */
    return ((unsigned char)(c - 'a') < 26)
        || ((unsigned char)(c - 'A') < 26)
        || ((unsigned char)(c - '0') < 10)
        || (strchr (""-._~"", c) != NULL);
}",79.0,86.0,1.0,1.0,8.0,13,5,5,2,2,0,1,1,0,0,,0,0,2,1,1,bool
2234,182721,isurisubdelim,1,isurisubdelim,bool isurisubdelim (int),text\url.c,"static bool isurisubdelim(int c)
{
    return strchr(""!$&'()*+,;="", c) != NULL;
}",88.0,91.0,1.0,1.0,4.0,1,1,2,2,1,0,1,1,0,0,,0,0,2,1,1,bool
2235,182732,isurihex,1,isurihex,bool isurihex (int),text\url.c,"static bool isurihex(int c)
{   /* Same as isxdigit() but does not depend on locale and unsignedness */
    return ((unsigned char)(c - '0') < 10)
        || ((unsigned char)(c - 'A') < 6)
        || ((unsigned char)(c - 'a') < 6);
}",93.0,98.0,1.0,1.0,6.0,11,4,3,1,2,0,1,1,0,0,,0,0,2,1,1,bool
2236,182765,encode_URI_bytes,1,encode_URI_bytes,"char* encode_URI_bytes (char*,size_t*)",text\url.c,"static char *encode_URI_bytes (const char *str, size_t *restrict lenp)
{
    char *buf = malloc (3 * *lenp + 1);
    if (unlikely(buf == NULL))
        return NULL;

    char *out = buf;
    for (size_t i = 0; i < *lenp; i++)
    {
        unsigned char c = str[i];

        if (isurisafe (c))
            *(out++) = c;
        /* This is URI encoding, not HTTP forms:
         * Space is encoded as '%20', not '+'. */
        else
        {
            *(out++) = '%';
            *(out++) = urihex[c >> 4];
            *(out++) = urihex[c & 0xf];
        }
    }

    *lenp = out - buf;
    out = realloc (buf, *lenp + 1);
    return likely(out != NULL) ? out : buf;
}",102.0,128.0,1.0,1.0,27.0,22,11,26,7,2,1,4,5,1,1,,0,1,4,2,2,char*
2237,182868,vlc_uri_encode,1,vlc_uri_encode,char* vlc_uri_encode (char*),text\url.c,"char *vlc_uri_encode (const char *str)
{
    size_t len = strlen (str);
    char *ret = encode_URI_bytes (str, &len);
    if (likely(ret != NULL))
        ret[len] = '\0';
    return ret;
}",130.0,137.0,1.0,1.0,8.0,6,4,10,4,2,1,2,2,0,1,,0,1,2,1,1,char*
2238,182898,vlc_path2uri,1,vlc_path2uri,"char* vlc_path2uri (char*,char*)",text\url.c,"char *vlc_path2uri (const char *path, const char *scheme)
{
    if (path == NULL)
    {
        errno = EINVAL;
        return NULL;
    }
    if (scheme == NULL && !strcmp (path, ""-""))
        return strdup (""fd://0""); // standard input
    /* Note: VLC cannot handle URI schemes without double slash after the
     * scheme name (such as mailto: or news:). */

    char *buf;

#ifdef __OS2__
    char p[strlen (path) + 1];

    for (buf = p; *path; buf++, path++)
        *buf = (*path == '/') ? DIR_SEP_CHAR : *path;
    *buf = '\0';

    path = p;
#endif

#if defined (_WIN32) || defined (__OS2__)
    /* Drive letter */
    if (isalpha ((unsigned char)path[0]) && (path[1] == ':'))
    {
        if (asprintf (&buf, ""%s:///%c:"", scheme ? scheme : ""file"",
                      path[0]) == -1)
            buf = NULL;
        path += 2;
# warning Drive letter-relative path not implemented!
        if (path[0] != DIR_SEP_CHAR)
        {
            errno = ENOTSUP;
            return NULL;
 ...",139.0,239.0,1.0,1.0,101.0,31,13,56,14,9,2,10,14,1,2,,0,2,4,2,2,char*
2239,183065,vlc_uri2path,1,vlc_uri2path,char* vlc_uri2path (char*),text\url.c,"char *vlc_uri2path (const char *url)
{
    char *ret = NULL;
    char *end;

    char *path = strstr (url, ""://"");
    if (path == NULL)
        return NULL; /* unsupported scheme or invalid syntax */

    end = memchr (url, '/', path - url);
    size_t schemelen = ((end != NULL) ? end : path) - url;
    path += 3; /* skip ""://"" */

    /* Remove request parameters and/or HTML anchor if present */
    end = path + strcspn (path, ""?#"");
    path = strndup (path, end - path);
    if (unlikely(path == NULL))
        return NULL; /* boom! */

    /* Decode path */
    vlc_uri_decode (path);

    if (schemelen == 4 && !strncasecmp (url, ""file"", 4))
    {
#if !defined (_WIN32) && !defined (__OS2__)
        /* Leading slash => local path */
        if (*path == '/')
            return path;
        /* Local path disguised as a remote one */
        if (!strncasecmp (path, ""localhost/"", 10))
            return memmove (path, path + 9, strlen (path + 9) + 1);
#else
        /* cannot start wi...",241.0,325.0,1.0,1.0,85.0,24,10,39,6,2,1,6,8,0,1,,0,0,2,1,1,char*
2240,183246,vlc_iri2uri,1,vlc_iri2uri,char* vlc_iri2uri (char*),text\url.c,"static char *vlc_iri2uri(const char *iri)
{
    size_t a = 0, u = 0;

    for (size_t i = 0; iri[i] != '\0'; i++)
    {
        unsigned char c = iri[i];

        if (c < 128)
            a++;
        else
            u++;
    }

    if (unlikely((a + u) > (SIZE_MAX / 4)))
    {
        errno = ENOMEM;
        return NULL;
    }

    char *uri = malloc(a + 3 * u + 1), *p;
    if (unlikely(uri == NULL))
        return NULL;

    for (p = uri; *iri != '\0'; iri++)
    {
        unsigned char c = *iri;

        if (c < 128)
            *(p++) = c;
        else
        {
            *(p++) = '%';
            *(p++) = urihex[c >> 4];
            *(p++) = urihex[c & 0xf];
        }
    }

    *p = '\0';
    return uri;
}",330.0,370.0,1.0,1.0,41.0,29,11,32,11,1,0,7,9,0,0,,0,0,2,1,1,char*
2241,183383,vlc_uri_component_validate,1,vlc_uri_component_validate,"bool vlc_uri_component_validate (char*,char*)",text\url.c,"static bool vlc_uri_component_validate(const char *str, const char *extras)
{
    assert(str != NULL);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        int c = str[i];

        if (isurisafe(c) || isurisubdelim(c))
            continue;
        if (strchr(extras, c) != NULL)
            continue;
        if (c == '%' && isurihex(str[i + 1]) && isurihex(str[i + 2]))
        {
            i += 2;
            continue;
        }
        return false;
    }
    return true;
}",372.0,392.0,1.0,1.0,21.0,16,8,21,7,4,4,8,8,4,4,,0,4,4,2,2,bool
2242,183456,vlc_uri_host_validate,1,vlc_uri_host_validate,bool vlc_uri_host_validate (char*),text\url.c,"static bool vlc_uri_host_validate(const char *str)
{
    return vlc_uri_component_validate(str, "":"");
}",394.0,397.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,bool
2243,183465,vlc_uri_path_validate,1,vlc_uri_path_validate,bool vlc_uri_path_validate (char*),text\url.c,"static bool vlc_uri_path_validate(const char *str)
{
    return vlc_uri_component_validate(str, ""/@:[]"");
}",399.0,402.0,1.0,1.0,4.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,bool
2244,183474,vlc_UrlParseInner,1,vlc_UrlParseInner,"int vlc_UrlParseInner (vlc_url_t*,char*)",text\url.c,"static int vlc_UrlParseInner(vlc_url_t *restrict url, const char *str)
{
    url->psz_protocol = NULL;
    url->psz_username = NULL;
    url->psz_password = NULL;
    url->psz_host = NULL;
    url->i_port = 0;
    url->psz_path = NULL;
    url->psz_option = NULL;
    url->psz_buffer = NULL;
    url->psz_pathbuffer = NULL;

    if (str == NULL)
    {
        errno = EINVAL;
        return -1;
    }

    char *buf = vlc_iri2uri(str);
    if (unlikely(buf == NULL))
        return -1;
    url->psz_buffer = buf;

    char *cur = buf, *next;
    int ret = 0;

    /* URI scheme */
    next = buf;
    while ((*next >= 'A' && *next <= 'Z') || (*next >= 'a' && *next <= 'z')
        || (*next >= '0' && *next <= '9') || memchr (""+-."", *next, 3) != NULL)
        next++;

    if (*next == ':')
    {
        *(next++) = '\0';
        url->psz_protocol = cur;
        cur = next;
    }

    /* Fragment */
    next = strchr(cur, '#');
    if (next != NULL)
    {
#if 0  /* TODO */
       *(next++) = '...",404.0,553.0,1.0,1.0,150.0,133,15,117,12,2,3,17,29,0,3,,0,1,4,2,2,int
2245,183918,vlc_UrlParse,1,vlc_UrlParse,"int vlc_UrlParse (vlc_url_t*,char*)",text\url.c,"int vlc_UrlParse(vlc_url_t *url, const char *str)
{
    int ret = vlc_UrlParseInner(url, str);

    if (url->psz_path != NULL && !vlc_uri_path_validate(url->psz_path))
    {
        url->psz_path = NULL;
        errno = EINVAL;
        ret = -1;
    }
    return ret;
}",555.0,566.0,1.0,1.0,12.0,11,6,12,6,4,2,2,2,1,2,,0,2,4,2,2,int
2246,183957,vlc_uri_fixup_inner,1,vlc_uri_fixup_inner,"char* vlc_uri_fixup_inner (char*,char*)",text\url.c,"static char *vlc_uri_fixup_inner(const char *str, const char *extras)
{
    assert(str && extras);

    bool encode_percent = false;
    for (size_t i = 0; str[i] != '\0'; i++)
        if (str[i] == '%' && !(isurihex(str[i+1]) && isurihex(str[i+2])))
        {
            encode_percent = true;
            break;
        }

    struct vlc_memstream stream;

    vlc_memstream_open(&stream);

    for (size_t i = 0; str[i] != '\0'; i++)
    {
        unsigned char c = str[i];

        if (isurisafe(c) || isurisubdelim(c) || (strchr(extras, c) != NULL)
         || (c == '%' && !encode_percent))
            vlc_memstream_putc(&stream, c);
        else
            vlc_memstream_printf(&stream, ""%%%02hhX"", c);
    }

    if (vlc_memstream_close(&stream))
        return NULL;
    return stream.ptr;
}",832.0,862.0,1.0,1.0,31.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,char*
2247,183963,vlc_UrlParseFixup,1,vlc_UrlParseFixup,"int vlc_UrlParseFixup (vlc_url_t*,char*)",text\url.c,"int vlc_UrlParseFixup(vlc_url_t *url, const char *str)
{
    int ret = vlc_UrlParseInner(url, str);

    static const char pathextras[] = ""/@:"";

    if (url->psz_path != NULL
     && !vlc_uri_component_validate(url->psz_path, pathextras))
    {
        url->psz_pathbuffer = vlc_uri_fixup_inner(url->psz_path, pathextras);
        if (url->psz_pathbuffer == NULL)
        {
            url->psz_path = NULL;
            errno = ENOMEM;
            ret = -1;
        }
        else
        {
            url->psz_path = url->psz_pathbuffer;
            assert(vlc_uri_path_validate(url->psz_path));
        }
    }
    return ret;
}",570.0,593.0,1.0,1.0,24.0,17,7,19,7,0,3,3,4,1,3,,0,3,4,2,2,int
2248,184037,vlc_UrlClean,1,vlc_UrlClean,void vlc_UrlClean (vlc_url_t*),text\url.c,"void vlc_UrlClean (vlc_url_t *restrict url)
{
    free (url->psz_host);
    free (url->psz_buffer);
    free (url->psz_pathbuffer);
}",595.0,600.0,1.0,1.0,6.0,3,1,3,1,8,0,1,1,0,0,,0,0,2,1,1,void
2249,184054,vlc_uri_merge_paths,1,vlc_uri_merge_paths,"char* vlc_uri_merge_paths (char*,char*)",text\url.c,"static char *vlc_uri_merge_paths(const char *base, const char *ref)
{
    char *str;
    int len;

    if (base == NULL)
        len = asprintf(&str, ""/%s"", ref);
    else
    {
        const char *end = strrchr(base, '/');

        if (end != NULL)
            end++;
        else
            end = base;

        len = asprintf(&str, ""%.*s%s"", (int)(end - base), base, ref);
    }

    if (unlikely(len == -1))
        str = NULL;
    return str;
}",607.0,629.0,1.0,1.0,23.0,6,4,9,5,1,0,3,3,0,0,,0,0,4,2,2,char*
2250,184119,vlc_uri_remove_dot_segments,1,vlc_uri_remove_dot_segments,char* vlc_uri_remove_dot_segments (char*),text\url.c,"static char *vlc_uri_remove_dot_segments(char *str)
{
    char *input = str, *output = str;

    while (input[0] != '\0')
    {
        assert(output <= input);

        if (strncmp(input, ""../"", 3) == 0)
        {
            input += 3;
            continue;
        }
        if (strncmp(input, ""./"", 2) == 0)
        {
            input += 2;
            continue;
        }
        if (strncmp(input, ""/./"", 3) == 0)
        {
            input += 2;
            continue;
        }
        if (strcmp(input, ""/."") == 0)
        {
            input[1] = '\0';
            continue;
        }
        if (strncmp(input, ""/../"", 4) == 0)
        {
            input += 3;
            output = memrchr(str, '/', output - str);
            if (output == NULL)
                output = str;
            continue;
        }
        if (strcmp(input, ""/.."") == 0)
        {
            input[1] = '\0';
            output = memrchr(str, '/', output - str);
            if (output == NULL)
          ...",636.0,705.0,1.0,1.0,70.0,44,9,55,5,1,0,22,28,0,0,,0,0,2,1,1,char*
2251,184312,vlc_uri_compose,1,vlc_uri_compose,char* vlc_uri_compose (vlc_url_t*),text\url.c,"char *vlc_uri_compose(const vlc_url_t *uri)
{
    struct vlc_memstream stream;
    char *enc;

    vlc_memstream_open(&stream);

    if (uri->psz_protocol != NULL)
        vlc_memstream_printf(&stream, ""%s:"", uri->psz_protocol);

    if (uri->psz_host != NULL)
    {
        vlc_memstream_write(&stream, ""//"", 2);

        if (uri->psz_username != NULL)
        {
            enc = vlc_uri_encode(uri->psz_username);
            if (enc == NULL)
                goto error;

            vlc_memstream_puts(&stream, enc);
            free(enc);

            if (uri->psz_password != NULL)
            {
                enc = vlc_uri_encode(uri->psz_password);
                if (unlikely(enc == NULL))
                    goto error;

                vlc_memstream_printf(&stream, "":%s"", enc);
                free(enc);
            }
            vlc_memstream_putc(&stream, '@');
        }

        const char *fmt;

        if (strchr(uri->psz_host, ':') != NULL)
            fmt = (uri->i_port ...",707.0,766.0,1.0,1.0,60.0,43,7,49,5,1,11,14,21,2,11,,0,4,2,1,1,char*
2252,184498,vlc_uri_resolve,1,vlc_uri_resolve,"char* vlc_uri_resolve (char*,char*)",text\url.c,"char *vlc_uri_resolve(const char *base, const char *ref)
{
    vlc_url_t base_uri, rel_uri;
    vlc_url_t tgt_uri;
    char *pathbuf = NULL, *ret = NULL;

    if (vlc_UrlParse(&rel_uri, ref))
    {
        vlc_UrlClean(&rel_uri);
        return NULL;
    }

    if (rel_uri.psz_protocol != NULL)
    {   /* Short circuit in case of absolute URI */
        vlc_UrlClean(&rel_uri);
        return strdup(ref);
    }

    vlc_UrlParse(&base_uri, base);

    /* RFC3986 section 5.2.2 */
    do
    {
        tgt_uri = rel_uri;
        tgt_uri.psz_protocol = base_uri.psz_protocol;

        if (rel_uri.psz_host != NULL)
            break;

        tgt_uri.psz_username = base_uri.psz_username;
        tgt_uri.psz_password = base_uri.psz_password;
        tgt_uri.psz_host = base_uri.psz_host;
        tgt_uri.i_port = base_uri.i_port;

        if (rel_uri.psz_path == NULL || rel_uri.psz_path[0] == '\0')
        {
            tgt_uri.psz_path = base_uri.psz_path;
            if (rel_uri.psz_option ...",768.0,830.0,1.0,1.0,63.0,56,7,54,8,0,9,14,16,1,9,,0,3,4,2,2,char*
2253,184806,vlc_uri_fixup,1,vlc_uri_fixup,char* vlc_uri_fixup (char*),text\url.c,"char *vlc_uri_fixup(const char *str)
{
    static const char extras[] = "":/?#[]@"";

    /* Rule number one is do not change a (potentially) valid URI */
    if (vlc_uri_component_validate(str, extras))
        return strdup(str);

    return vlc_uri_fixup_inner(str, extras);
}",864.0,873.0,1.0,1.0,10.0,1,1,6,2,0,2,2,2,1,2,,0,1,2,1,1,char*
2254,184903,vout_chrono_Init,1,vout_chrono_Init,"void vout_chrono_Init (vout_chrono_t*,int,mtime_t)",video_output\chrono.h,"static inline void vout_chrono_Init(vout_chrono_t *chrono, int shift, mtime_t avg_initial)
{
    chrono->shift       = shift;
    chrono->avg_initial =
    chrono->avg         = avg_initial;

    chrono->shift_var   = shift+1;
    chrono->var         = avg_initial / 2;

    chrono->start = VLC_TS_INVALID;
}",40.0,50.0,1.0,1.0,11.0,14,4,11,4,2,6,1,1,0,0,,0,6,6,3,3,void
2255,184943,vout_chrono_Clean,1,vout_chrono_Clean,void vout_chrono_Clean (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Clean(vout_chrono_t *chrono)
{
    VLC_UNUSED(chrono);
}",51.0,54.0,1.0,1.0,4.0,0,0,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
2256,184950,vout_chrono_Start,1,vout_chrono_Start,void vout_chrono_Start (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Start(vout_chrono_t *chrono)
{
    chrono->start = mdate();
}",55.0,58.0,1.0,1.0,4.0,2,2,1,1,1,2,1,1,0,1,,0,2,2,1,1,void
2257,184960,vout_chrono_GetHigh,1,vout_chrono_GetHigh,mtime_t vout_chrono_GetHigh (vout_chrono_t*),video_output\chrono.h,"static inline mtime_t vout_chrono_GetHigh(vout_chrono_t *chrono)
{
    return chrono->avg + 2 * chrono->var;
}",59.0,62.0,1.0,1.0,4.0,4,3,2,1,2,2,1,1,0,0,,0,2,2,1,1,mtime_t
2258,184975,vout_chrono_GetLow,1,vout_chrono_GetLow,mtime_t vout_chrono_GetLow (vout_chrono_t*),video_output\chrono.h,"static inline mtime_t vout_chrono_GetLow(vout_chrono_t *chrono)
{
    return __MAX(chrono->avg - 2 * chrono->var, 0);
}",63.0,66.0,1.0,1.0,4.0,4,3,2,1,0,2,1,1,0,0,,0,2,2,1,1,mtime_t
2259,184992,vout_chrono_Stop,1,vout_chrono_Stop,void vout_chrono_Stop (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Stop(vout_chrono_t *chrono)
{
    assert(chrono->start != VLC_TS_INVALID);

    /* */
    const mtime_t duration = mdate() - chrono->start;
    const mtime_t var = llabs( duration - chrono->avg );

    /* Update average only if the current point is 'valid' */
    if( duration < vout_chrono_GetHigh( chrono ) )
        chrono->avg = (((1 << chrono->shift) - 1) * chrono->avg + duration) >> chrono->shift;
    /* Always update the variance */
    chrono->var = (((1 << chrono->shift_var) - 1) * chrono->var + var) >> chrono->shift_var;

    /* For assert */
    chrono->start = VLC_TS_INVALID;
}",68.0,84.0,1.0,1.0,17.0,31,9,21,4,1,14,2,2,1,2,,0,14,2,1,1,void
2260,185073,vout_chrono_Reset,1,vout_chrono_Reset,void vout_chrono_Reset (vout_chrono_t*),video_output\chrono.h,"static inline void vout_chrono_Reset(vout_chrono_t *chrono)
{
    vout_chrono_t ch = *chrono;
    vout_chrono_Clean(chrono);
    vout_chrono_Init(chrono, ch.shift, ch.avg_initial);
}",85.0,90.0,1.0,1.0,6.0,4,3,6,2,0,4,1,1,0,2,,0,2,2,1,1,void
2261,185106,vout_control_cmd_Init,1,vout_control_cmd_Init,"void vout_control_cmd_Init (vout_control_cmd_t*,int)",video_output\control.c,"void vout_control_cmd_Init(vout_control_cmd_t *cmd, int type)
{
    memset(cmd, 0, sizeof(*cmd));
    cmd->type = type;
}",33.0,37.0,1.0,1.0,5.0,4,4,4,2,15,1,1,1,0,0,,0,1,4,2,2,void
2262,185123,vout_control_cmd_Clean,1,vout_control_cmd_Clean,void vout_control_cmd_Clean (vout_control_cmd_t*),video_output\control.c,"void vout_control_cmd_Clean(vout_control_cmd_t *cmd)
{
    switch (cmd->type) {
    case VOUT_CONTROL_SUBPICTURE:
        if (cmd->u.subpicture)
            subpicture_Delete(cmd->u.subpicture);
        break;
    case VOUT_CONTROL_OSD_TITLE:
    case VOUT_CONTROL_CHANGE_FILTERS:
    case VOUT_CONTROL_CHANGE_SUB_SOURCES:
    case VOUT_CONTROL_CHANGE_SUB_FILTERS:
        free(cmd->u.string);
        break;
    default:
        break;
    }
}",39.0,55.0,1.0,1.0,17.0,7,2,9,6,2,5,6,4,2,1,,0,4,2,1,1,void
2263,185166,vout_control_Init,1,vout_control_Init,void vout_control_Init (vout_control_t*),video_output\control.c,"void vout_control_Init(vout_control_t *ctrl)
{
    vlc_mutex_init(&ctrl->lock);
    vlc_cond_init(&ctrl->wait_request);
    vlc_cond_init(&ctrl->wait_acknowledge);

    ctrl->is_dead = false;
    ctrl->can_sleep = true;
    ctrl->is_processing = false;
    ARRAY_INIT(ctrl->cmd);
}",58.0,68.0,1.0,1.0,11.0,13,3,10,3,1,9,1,1,0,3,,0,6,2,1,1,void
2264,185205,vout_control_Clean,1,vout_control_Clean,void vout_control_Clean (vout_control_t*),video_output\control.c,"void vout_control_Clean(vout_control_t *ctrl)
{
    /* */
    for (int i = 0; i < ctrl->cmd.i_size; i++) {
        vout_control_cmd_t cmd = ARRAY_VAL(ctrl->cmd, i);
        vout_control_cmd_Clean(&cmd);
    }
    ARRAY_RESET(ctrl->cmd);

    vlc_mutex_destroy(&ctrl->lock);
    vlc_cond_destroy(&ctrl->wait_request);
    vlc_cond_destroy(&ctrl->wait_acknowledge);
}",70.0,82.0,1.0,1.0,13.0,14,5,11,3,0,7,2,2,0,4,,0,3,2,1,1,void
2265,185256,vout_control_Dead,1,vout_control_Dead,void vout_control_Dead (vout_control_t*),video_output\control.c,"void vout_control_Dead(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->is_dead = true;
    vlc_cond_broadcast(&ctrl->wait_acknowledge);
    vlc_mutex_unlock(&ctrl->lock);

}",84.0,91.0,1.0,1.0,8.0,8,3,5,2,1,7,1,1,0,3,,0,4,2,1,1,void
2266,185281,vout_control_WaitEmpty,1,vout_control_WaitEmpty,void vout_control_WaitEmpty (vout_control_t*),video_output\control.c,"void vout_control_WaitEmpty(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    while ((ctrl->cmd.i_size > 0 || ctrl->is_processing) && !ctrl->is_dead)
        vlc_cond_wait(&ctrl->wait_acknowledge, &ctrl->lock);
    vlc_mutex_unlock(&ctrl->lock);
}",93.0,99.0,1.0,1.0,7.0,12,7,5,1,6,6,2,2,2,2,,0,4,2,1,1,void
2267,185322,vout_control_Push,1,vout_control_Push,"void vout_control_Push (vout_control_t*,vout_control_cmd_t*)",video_output\control.c,"void vout_control_Push(vout_control_t *ctrl, vout_control_cmd_t *cmd)
{
    vlc_mutex_lock(&ctrl->lock);
    if (!ctrl->is_dead) {
        ARRAY_APPEND(ctrl->cmd, *cmd);
        vlc_cond_signal(&ctrl->wait_request);
    } else {
        vout_control_cmd_Clean(cmd);
    }
    vlc_mutex_unlock(&ctrl->lock);
}",101.0,111.0,1.0,1.0,11.0,10,4,6,2,15,7,2,2,1,3,,0,4,4,2,2,void
2268,185359,vout_control_Wake,1,vout_control_Wake,void vout_control_Wake (vout_control_t*),video_output\control.c,"void vout_control_Wake(vout_control_t *ctrl)
{
    vlc_mutex_lock(&ctrl->lock);
    ctrl->can_sleep = false;
    vlc_cond_signal(&ctrl->wait_request);
    vlc_mutex_unlock(&ctrl->lock);
}",113.0,119.0,1.0,1.0,7.0,8,3,5,2,1,7,1,1,0,3,,0,4,2,1,1,void
2269,185384,vout_control_PushVoid,1,vout_control_PushVoid,"void vout_control_PushVoid (vout_control_t*,int)",video_output\control.c,"void vout_control_PushVoid(vout_control_t *ctrl, int type)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    vout_control_Push(ctrl, &cmd);
}",121.0,127.0,1.0,1.0,7.0,2,1,4,3,2,2,1,1,0,2,,0,0,4,2,2,void
2270,185399,vout_control_PushBool,1,vout_control_PushBool,"void vout_control_PushBool (vout_control_t*,int,bool)",video_output\control.c,"void vout_control_PushBool(vout_control_t *ctrl, int type, bool boolean)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.boolean = boolean;
    vout_control_Push(ctrl, &cmd);
}",128.0,135.0,1.0,1.0,8.0,5,3,6,4,4,3,1,1,0,2,,0,1,6,3,3,void
2271,185422,vout_control_PushInteger,1,vout_control_PushInteger,"void vout_control_PushInteger (vout_control_t*,int,int)",video_output\control.c,"void vout_control_PushInteger(vout_control_t *ctrl, int type, int integer)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.integer = integer;
    vout_control_Push(ctrl, &cmd);
}",136.0,143.0,1.0,1.0,8.0,5,3,6,4,3,3,1,1,0,2,,0,1,6,3,3,void
2272,185445,vout_control_PushTime,1,vout_control_PushTime,"void vout_control_PushTime (vout_control_t*,int,mtime_t)",video_output\control.c,"void vout_control_PushTime(vout_control_t *ctrl, int type, mtime_t time)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.time = time;
    vout_control_Push(ctrl, &cmd);
}",144.0,151.0,1.0,1.0,8.0,5,3,6,4,1,3,1,1,0,2,,0,1,6,3,3,void
2273,185468,vout_control_PushMessage,1,vout_control_PushMessage,"void vout_control_PushMessage (vout_control_t*,int,int,char*)",video_output\control.c,"void vout_control_PushMessage(vout_control_t *ctrl, int type, int channel, const char *string)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.message.channel = channel;
    cmd.u.message.string = strdup(string);
    vout_control_Push(ctrl, &cmd);
}",152.0,160.0,1.0,1.0,9.0,10,3,8,5,0,4,1,1,0,2,,0,2,8,4,4,void
2274,185504,vout_control_PushPair,1,vout_control_PushPair,"void vout_control_PushPair (vout_control_t*,int,int,int)",video_output\control.c,"void vout_control_PushPair(vout_control_t *ctrl, int type, int a, int b)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.pair.a = a;
    cmd.u.pair.b = b;
    vout_control_Push(ctrl, &cmd);
}",161.0,169.0,1.0,1.0,9.0,10,3,8,5,3,4,1,1,0,2,,0,2,8,4,4,void
2275,185539,vout_control_PushString,1,vout_control_PushString,"void vout_control_PushString (vout_control_t*,int,char*)",video_output\control.c,"void vout_control_PushString(vout_control_t *ctrl, int type, const char *string)
{
    vout_control_cmd_t cmd;

    vout_control_cmd_Init(&cmd, type);
    cmd.u.string = string ? strdup(string) : NULL;
    vout_control_Push(ctrl, &cmd);
}",170.0,177.0,1.0,1.0,8.0,6,4,8,5,4,3,1,1,0,2,,0,1,6,3,3,void
2276,185566,vout_control_Pop,1,vout_control_Pop,"int vout_control_Pop (vout_control_t*,vout_control_cmd_t*,mtime_t)",video_output\control.c,"int vout_control_Pop(vout_control_t *ctrl, vout_control_cmd_t *cmd,
                     mtime_t deadline)
{
    vlc_mutex_lock(&ctrl->lock);
    if (ctrl->cmd.i_size <= 0) {
        ctrl->is_processing = false;
        vlc_cond_broadcast(&ctrl->wait_acknowledge);

        /* Spurious wakeups are perfectly fine */
        if (deadline > VLC_TS_INVALID && ctrl->can_sleep)
            vlc_cond_timedwait(&ctrl->wait_request, &ctrl->lock, deadline);
    }

    bool has_cmd;
    if (ctrl->cmd.i_size > 0) {
        has_cmd = true;
        *cmd = ARRAY_VAL(ctrl->cmd, 0);
        ARRAY_REMOVE(ctrl->cmd, 0);

        ctrl->is_processing = true;
    } else {
        has_cmd = false;
        ctrl->can_sleep = true;
    }
    vlc_mutex_unlock(&ctrl->lock);

    return has_cmd ? VLC_SUCCESS : VLC_EGENERIC;
}",179.0,206.0,1.0,1.0,28.0,29,9,23,9,0,12,4,5,1,4,,0,8,6,3,3,int
2277,185883,SplitterClose,1,SplitterClose,void SplitterClose (vout_display_t*),video_output\display.c,"static void SplitterClose(vout_display_t *vd)
{
    vout_display_sys_t *sys = vd->sys;

    /* */
    video_splitter_t *splitter = sys->splitter;
    free(splitter->p_owner);
    video_splitter_Delete(splitter);

    if (sys->pool)
        picture_pool_Release(sys->pool);

    /* */
    for (int i = 0; i < sys->count; i++)
        vout_DeleteDisplay(sys->display[i], NULL);
    TAB_CLEAN(sys->count, sys->display);
    free(sys->picture);

    free(sys);
}",1409.0,1428.0,1.0,1.0,20.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2278,185888,VideoBufferNew,1,VideoBufferNew,picture_t VideoBufferNew (filter_t*),video_output\display.c,"static picture_t *VideoBufferNew(filter_t *filter)
{
    vout_display_t *vd = filter->owner.sys;
    const video_format_t *fmt = &filter->fmt_out.video;

    assert(vd->fmt.i_chroma == fmt->i_chroma &&
           vd->fmt.i_width  == fmt->i_width  &&
           vd->fmt.i_height == fmt->i_height);

    picture_pool_t *pool = vout_display_Pool(vd, 3);
    if (!pool)
        return NULL;
    return picture_pool_Get(pool);
}",53.0,66.0,1.0,1.0,14.0,23,7,15,5,0,1,2,2,0,1,,0,0,2,1,1,picture_t
2279,185955,vout_display_New,1,vout_display_New,"vout_display_t vout_display_New (vlc_object_t*,char*,bool,video_format_t*,vout_display_cfg_t*,vout_display_owner_t*)",video_output\display.c,"static vout_display_t *vout_display_New(vlc_object_t *obj,
                                        const char *module, bool load_module,
                                        const video_format_t *fmt,
                                        const vout_display_cfg_t *cfg,
                                        vout_display_owner_t *owner)
{
    /* */
    vout_display_t *vd = vlc_custom_create(obj, sizeof(*vd), ""vout display"" );

    /* */
    video_format_Copy(&vd->source, fmt);

    /* Picture buffer does not have the concept of aspect ratio */
    video_format_Copy(&vd->fmt, fmt);
    vd->fmt.i_sar_num = 0;
    vd->fmt.i_sar_den = 0;

    vd->info.is_slow = false;
    vd->info.has_double_click = false;
    vd->info.needs_hide_mouse = false;
    vd->info.has_pictures_invalid = false;
    vd->info.subpicture_chromas = NULL;

    vd->cfg = cfg;
    vd->pool = NULL;
    vd->prepare = NULL;
    vd->display = NULL;
    vd->control = NULL;
    vd->manage = NULL;
    vd->sys = NULL;

 ...",75.0,118.0,1.0,1.0,44.0,52,9,45,9,1,3,3,4,0,3,,0,2,12,6,6,vout_display_t
2280,186112,vout_display_Delete,1,vout_display_Delete,void vout_display_Delete (vout_display_t*),video_output\display.c,"static void vout_display_Delete(vout_display_t *vd)
{
    if (vd->module)
        module_unneed(vd, vd->module);

    video_format_Clean(&vd->source);
    video_format_Clean(&vd->fmt);

    vlc_object_release(vd);
}",123.0,132.0,1.0,1.0,10.0,6,2,6,1,2,2,2,2,0,2,,0,0,2,1,1,void
2281,186139,vout_display_Control,1,vout_display_Control,"int vout_display_Control (vout_display_t*,int...)",video_output\display.c,"static int vout_display_Control(vout_display_t *vd, int query, ...)
{
    va_list args;
    int result;

    va_start(args, query);
    result = vd->control(vd, query, args);
    va_end(args);

    return result;
}",137.0,147.0,1.0,1.0,11.0,2,2,9,4,8,0,1,1,0,0,,0,0,4,2,2,int
2282,186163,vout_display_Manage,1,vout_display_Manage,void vout_display_Manage (vout_display_t*),video_output\display.c,"static void vout_display_Manage(vout_display_t *vd)
{
    if (vd->manage)
        vd->manage(vd);
}",149.0,153.0,1.0,1.0,5.0,2,1,3,1,1,0,2,2,0,0,,0,0,2,1,1,void
2283,186178,vout_display_GetDefaultDisplaySize,1,vout_display_GetDefaultDisplaySize,"void vout_display_GetDefaultDisplaySize (unsigned*,unsigned*,video_format_t*,vout_display_cfg_t*)",video_output\display.c,"void vout_display_GetDefaultDisplaySize(unsigned *width, unsigned *height,
                                        const video_format_t *source,
                                        const vout_display_cfg_t *cfg)
{
    if (cfg->display.width != 0 && cfg->display.height != 0) {
        *width  = cfg->display.width;
        *height = cfg->display.height;
    } else if (cfg->display.width != 0) {
        *width  = cfg->display.width;
        *height = (int64_t)source->i_visible_height * source->i_sar_den * cfg->display.width * cfg->display.sar.num /
            source->i_visible_width / source->i_sar_num / cfg->display.sar.den;
    } else if (cfg->display.height != 0) {
        *width  = (int64_t)source->i_visible_width * source->i_sar_num * cfg->display.height * cfg->display.sar.den /
            source->i_visible_height / source->i_sar_den / cfg->display.sar.num;
        *height = cfg->display.height;
    } else if (source->i_sar_num >= source->i_sar_den) {
        *width  = (int6...",156.0,188.0,1.0,1.0,33.0,41,8,21,5,2,0,3,3,0,0,,0,0,8,4,4,void
2284,186484,vout_display_PlacePicture,1,vout_display_PlacePicture,"void vout_display_PlacePicture (vout_display_place_t*,video_format_t*,vout_display_cfg_t*,bool)",video_output\display.c,"void vout_display_PlacePicture(vout_display_place_t *place,
                               const video_format_t *source,
                               const vout_display_cfg_t *cfg,
                               bool do_clipping)
{
    /* */
    memset(place, 0, sizeof(*place));
    if (cfg->display.width == 0 || cfg->display.height == 0)
        return;

    /* */
    unsigned display_width;
    unsigned display_height;

    video_format_t source_rot;
    video_format_ApplyRotation(&source_rot, source);
    source = &source_rot;

    if (cfg->is_display_filled) {
        display_width  = cfg->display.width;
        display_height = cfg->display.height;
    } else {
        vout_display_cfg_t cfg_tmp = *cfg;

        cfg_tmp.display.width  = 0;
        cfg_tmp.display.height = 0;
        vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                           source, &cfg_tmp);

        if (do_clipping) {
            display_width  = __MIN(dis...",191.0,273.0,1.0,1.0,83.0,102,13,61,15,2,1,13,8,0,1,,0,0,8,4,4,void
2285,186830,vout_display_SendMouseMovedDisplayCoordinates,1,vout_display_SendMouseMovedDisplayCoordinates,"void vout_display_SendMouseMovedDisplayCoordinates (vout_display_t*,video_orientation_t,int,int,vout_display_place_t*)",video_output\display.c,"void vout_display_SendMouseMovedDisplayCoordinates(vout_display_t *vd, video_orientation_t orient_display, int m_x, int m_y, vout_display_place_t *place)
{
    video_format_t source_rot = vd->source;
    video_format_TransformTo(&source_rot, orient_display);

    if (place->width > 0 && place->height > 0) {

        int x = (int)(source_rot.i_x_offset +
                            (int64_t)(m_x - place->x) * source_rot.i_visible_width / place->width);
        int y = (int)(source_rot.i_y_offset +
                            (int64_t)(m_y - place->y) * source_rot.i_visible_height/ place->height);

        video_transform_t transform = video_format_GetTransform(vd->source.orientation, orient_display);

        int store;

        switch (transform) {

            case TRANSFORM_R90:
                store = x;
                x = y;
                y = vd->source.i_visible_height - store;
                break;
            case TRANSFORM_R180:
                x = vd->source.i_visible_w...",275.0,329.0,1.0,1.0,55.0,71,11,72,17,0,2,11,4,0,2,,0,1,10,5,5,void
2286,187093,VoutDisplayCreateRender,1,VoutDisplayCreateRender,int VoutDisplayCreateRender (vout_display_t*),video_output\display.c,"static int VoutDisplayCreateRender(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    filter_owner_t owner = {
        .sys = vd,
        .video = {
            .buffer_new = VideoBufferNew,
        },
    };

    osys->filters = filter_chain_NewVideo(vd, false, &owner);
    if (unlikely(osys->filters == NULL))
        return -1;

    video_format_t v_src = vd->source;
    v_src.i_sar_num = 0;
    v_src.i_sar_den = 0;

    video_format_t v_dst = vd->fmt;
    v_dst.i_sar_num = 0;
    v_dst.i_sar_den = 0;

    video_format_t v_dst_cmp = v_dst;
    if ((v_src.i_chroma == VLC_CODEC_J420 && v_dst.i_chroma == VLC_CODEC_I420) ||
        (v_src.i_chroma == VLC_CODEC_J422 && v_dst.i_chroma == VLC_CODEC_I422) ||
        (v_src.i_chroma == VLC_CODEC_J440 && v_dst.i_chroma == VLC_CODEC_I440) ||
        (v_src.i_chroma == VLC_CODEC_J444 && v_dst.i_chroma == VLC_CODEC_I444))
        v_dst_cmp.i_chroma = v_src.i_chroma;

    const bool convert = memcmp(&v_src, &v_dst_cmp...",402.0,464.0,1.0,1.0,63.0,93,16,75,24,2,14,8,8,1,8,,0,8,2,1,1,int
2287,187355,VoutDisplayDestroyRender,1,VoutDisplayDestroyRender,void VoutDisplayDestroyRender (vout_display_t*),video_output\display.c,"static void VoutDisplayDestroyRender(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters)
        filter_chain_Delete(osys->filters);
}",466.0,472.0,1.0,1.0,7.0,5,3,4,2,2,3,2,2,1,1,,0,2,2,1,1,void
2288,187377,VoutDisplayResetRender,1,VoutDisplayResetRender,int VoutDisplayResetRender (vout_display_t*),video_output\display.c,"static int VoutDisplayResetRender(vout_display_t *vd)
{
    VoutDisplayDestroyRender(vd);
    return VoutDisplayCreateRender(vd);
}",474.0,478.0,1.0,1.0,5.0,0,0,2,1,1,2,1,1,0,2,,0,0,2,1,1,int
2289,187387,VoutDisplayEventMouse,1,VoutDisplayEventMouse,"void VoutDisplayEventMouse (vout_display_t*,int,va_list)",video_output\display.c,"static void VoutDisplayEventMouse(vout_display_t *vd, int event, va_list args)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);

    /* */
    vlc_mouse_t m = osys->mouse.state;
    bool is_ignored = false;

    switch (event) {
    case VOUT_DISPLAY_EVENT_MOUSE_STATE: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);
        const int button_mask = (int)va_arg(args, int);

        vlc_mouse_Init(&m);
        m.i_x = x;
        m.i_y = y;
        m.i_pressed = button_mask;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED: {
        const int x = (int)va_arg(args, int);
        const int y = (int)va_arg(args, int);

        //msg_Dbg(vd, ""VoutDisplayEvent 'mouse' @%d,%d"", x, y);

        m.i_x = x;
        m.i_y = y;
        m.b_double_click = false;
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED: {
        const int button = (int)...",480.0,572.0,1.0,1.0,93.0,80,12,71,18,1,10,12,10,0,6,,0,6,6,3,3,void
2290,187656,VoutDisplayEvent,1,VoutDisplayEvent,"void VoutDisplayEvent (vout_display_t*,int,va_list)",video_output\display.c,"static void VoutDisplayEvent(vout_display_t *vd, int event, va_list args)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
    case VOUT_DISPLAY_EVENT_CLOSE: {
        msg_Dbg(vd, ""VoutDisplayEvent 'close'"");
        vout_SendEventClose(osys->vout);
        break;
    }
    case VOUT_DISPLAY_EVENT_KEY: {
        const int key = (int)va_arg(args, int);
        msg_Dbg(vd, ""VoutDisplayEvent 'key' 0x%2.2x"", key);
        vout_SendEventKey(osys->vout, key);
        break;
    }
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
        VoutDisplayEventMouse(vd, event, args);
        break;

    case VOUT_DISPLAY_EVENT_VIEWPOINT_MOVED:
        vout_SendEventViewpointMoved(osys->vout,
                                     va_arg(args, const vlc_viewpoint_t *));
        break;

#if defined(_WIN32) || ...",574.0,666.0,1.0,1.0,93.0,23,4,41,18,1,17,9,2,0,7,,0,10,6,3,3,void
2291,187788,VoutDisplayNewWindow,1,VoutDisplayNewWindow,"vout_window_t VoutDisplayNewWindow (vout_display_t*,unsigned)",video_output\display.c,"static vout_window_t *VoutDisplayNewWindow(vout_display_t *vd, unsigned type)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window = vout_NewDisplayWindow(osys->vout, type);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",668.0,675.0,1.0,1.0,8.0,6,4,10,5,0,3,2,2,0,2,,0,2,4,2,2,vout_window_t
2292,187820,VoutDisplayDelWindow,1,VoutDisplayDelWindow,"void VoutDisplayDelWindow (vout_display_t*,vout_window_t*)",video_output\display.c,"static void VoutDisplayDelWindow(vout_display_t *vd, vout_window_t *window)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (window != NULL)
        vout_display_window_Detach(window);
    vout_DeleteDisplayWindow(osys->vout, window);
}",677.0,684.0,1.0,1.0,8.0,5,4,7,4,0,3,2,2,0,2,,0,1,4,2,2,void
2293,187846,VoutDisplayFitWindow,1,VoutDisplayFitWindow,"void VoutDisplayFitWindow (vout_display_t*,bool)",video_output\display.c,"static void VoutDisplayFitWindow(vout_display_t *vd, bool default_size)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_display_cfg_t cfg = osys->cfg;

    if (!cfg.is_display_filled)
        return;

    cfg.display.width = 0;
    if (default_size) {
        cfg.display.height = 0;
    } else {
        cfg.zoom.num = 1;
        cfg.zoom.den = 1;
    }

    unsigned display_width;
    unsigned display_height;
    vout_display_GetDefaultDisplaySize(&display_width, &display_height,
                                       &vd->source, &cfg);
    vout_SetDisplayWindowSize(osys->vout, display_width, display_height);
}",686.0,707.0,1.0,1.0,22.0,19,5,15,6,1,4,3,3,0,2,,0,2,4,2,2,void
2294,187925,VoutDisplayCropRatio,1,VoutDisplayCropRatio,"void VoutDisplayCropRatio (int*,int*,int*,int*,video_format_t*,unsigned,unsigned)",video_output\display.c,"static void VoutDisplayCropRatio(int *left, int *top, int *right, int *bottom,
                                 const video_format_t *source,
                                 unsigned num, unsigned den)
{
    unsigned scaled_width  = (uint64_t)source->i_visible_height * num * source->i_sar_den / den / source->i_sar_num;
    unsigned scaled_height = (uint64_t)source->i_visible_width  * den * source->i_sar_num / num / source->i_sar_den;

    if (scaled_width < source->i_visible_width) {
        *left   = (source->i_visible_width - scaled_width) / 2;
        *top    = 0;
        *right  = *left + scaled_width;
        *bottom = *top  + source->i_visible_height;
    } else {
        *left   = 0;
        *top    = (source->i_visible_height - scaled_height) / 2;
        *right  = *left + source->i_visible_width;
        *bottom = *top  + scaled_height;
    }
}",709.0,727.0,1.0,1.0,19.0,36,9,24,9,1,0,2,2,0,0,,0,0,14,7,7,void
2295,188045,vout_ManageDisplay,1,vout_ManageDisplay,"bool vout_ManageDisplay (vout_display_t*,bool)",video_output\display.c,"bool vout_ManageDisplay(vout_display_t *vd, bool allow_reset_pictures)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vout_display_Manage(vd);

    /* Handle mouse timeout */
    const mtime_t date = mdate();
    bool  hide_mouse = false;

    vlc_mutex_lock(&osys->lock);

    if (!osys->mouse.is_hidden &&
        osys->mouse.last_moved + osys->mouse.hide_timeout < date) {
        osys->mouse.is_hidden = hide_mouse = true;
    } else if (osys->mouse.ch_activity) {
        if (osys->mouse.is_hidden)
            vout_HideWindowMouse(osys->vout, false);
        osys->mouse.is_hidden = false;
    }
    osys->mouse.ch_activity = false;
    vlc_mutex_unlock(&osys->lock);

    if (hide_mouse) {
        msg_Dbg(vd, ""auto hiding mouse cursor"");
        if (vout_HideWindowMouse(osys->vout, true) != VLC_SUCCESS
         && vd->info.needs_hide_mouse)
            vout_display_Control(vd, VOUT_DISPLAY_HIDE_MOUSE);
    }

    bool reset_render = false;
    for (;;) {

        vlc_mutex...",729.0,963.0,1.0,1.0,235.0,341,15,217,31,0,97,27,55,21,20,,0,81,4,2,2,bool
2296,189032,vout_AreDisplayPicturesInvalid,1,vout_AreDisplayPicturesInvalid,bool vout_AreDisplayPicturesInvalid (vout_display_t*),video_output\display.c,"bool vout_AreDisplayPicturesInvalid(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    vlc_mutex_lock(&osys->lock);
    const bool reset_pictures = osys->reset_pictures;
    vlc_mutex_unlock(&osys->lock);

    return reset_pictures;
}",965.0,974.0,1.0,1.0,10.0,9,4,7,3,0,5,1,1,0,2,,0,3,2,1,1,bool
2297,189063,vout_IsDisplayFiltered,1,vout_IsDisplayFiltered,bool vout_IsDisplayFiltered (vout_display_t*),video_output\display.c,"bool vout_IsDisplayFiltered(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    return osys->filters == NULL || !filter_chain_IsEmpty(osys->filters);
}",976.0,981.0,1.0,1.0,6.0,8,6,5,3,2,3,1,1,0,1,,0,2,2,1,1,bool
2298,189088,vout_FilterDisplay,1,vout_FilterDisplay,"picture_t vout_FilterDisplay (vout_display_t*,picture_t*)",video_output\display.c,"picture_t *vout_FilterDisplay(vout_display_t *vd, picture_t *picture)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters == NULL) {
        picture_Release(picture);
        return NULL;
    }

    return filter_chain_VideoFilter(osys->filters, picture);
}",983.0,993.0,1.0,1.0,11.0,6,4,8,4,2,4,2,2,1,2,,0,2,4,2,2,picture_t
2299,189119,vout_FilterFlush,1,vout_FilterFlush,void vout_FilterFlush (vout_display_t*),video_output\display.c,"void vout_FilterFlush(vout_display_t *vd)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->filters != NULL)
        filter_chain_VideoFlush(osys->filters);
}",995.0,1001.0,1.0,1.0,7.0,6,4,5,3,1,3,2,2,1,1,,0,2,2,1,1,void
2300,189143,vout_UpdateDisplaySourceProperties,1,vout_UpdateDisplaySourceProperties,"void vout_UpdateDisplaySourceProperties (vout_display_t*,video_format_t*)",video_output\display.c,"void vout_UpdateDisplaySourceProperties(vout_display_t *vd, const video_format_t *source)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (source->i_sar_num * osys->source.i_sar_den !=
        source->i_sar_den * osys->source.i_sar_num) {

        osys->source.i_sar_num = source->i_sar_num;
        osys->source.i_sar_den = source->i_sar_den;
        vlc_ureduce(&osys->source.i_sar_num, &osys->source.i_sar_den,
                    osys->source.i_sar_num, osys->source.i_sar_den, 0);

        /* FIXME it will override any AR that the user would have forced */
        osys->ch_sar = true;
        osys->sar.num = osys->source.i_sar_num;
        osys->sar.den = osys->source.i_sar_den;
    }
    if (source->i_x_offset       != osys->source.i_x_offset ||
        source->i_y_offset       != osys->source.i_y_offset ||
        source->i_visible_width  != osys->source.i_visible_width ||
        source->i_visible_height != osys->source.i_visible_height) {

        video_format_Copy...",1003.0,1031.0,1.0,1.0,29.0,65,7,32,4,1,21,3,3,6,2,,0,19,4,2,2,void
2301,189299,vout_SetDisplayFilled,1,vout_SetDisplayFilled,"void vout_SetDisplayFilled (vout_display_t*,bool)",video_output\display.c,"void vout_SetDisplayFilled(vout_display_t *vd, bool is_filled)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    osys->is_display_filled = is_filled;
}",1033.0,1038.0,1.0,1.0,6.0,5,3,4,3,1,1,1,1,0,0,,0,1,4,2,2,void
2302,189318,vout_SetDisplayZoom,1,vout_SetDisplayZoom,"void vout_SetDisplayZoom (vout_display_t*,unsigned,unsigned)",video_output\display.c,"void vout_SetDisplayZoom(vout_display_t *vd, unsigned num, unsigned den)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (num != 0 && den != 0) {
        vlc_ureduce(&num, &den, num, den, 0);
    } else {
        num = 1;
        den = 1;
    }

    if (10 * num <= den) {
        num = 1;
        den = 10;
    } else if (num >= 10 * den) {
        num = 10;
        den = 1;
    }

    if (osys->is_display_filled ||
        osys->zoom.num != num || osys->zoom.den != den) {
        osys->ch_zoom = true;
        osys->zoom.num = num;
        osys->zoom.den = den;
    }
}",1040.0,1065.0,1.0,1.0,26.0,29,9,23,5,1,7,4,4,3,1,,0,6,6,3,3,void
2303,189426,vout_SetDisplayAspect,1,vout_SetDisplayAspect,"void vout_SetDisplayAspect (vout_display_t*,unsigned,unsigned)",video_output\display.c,"void vout_SetDisplayAspect(vout_display_t *vd, unsigned dar_num, unsigned dar_den)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    unsigned sar_num, sar_den;
    if (dar_num > 0 && dar_den > 0) {
        sar_num = dar_num * osys->source.i_visible_height;
        sar_den = dar_den * osys->source.i_visible_width;
        vlc_ureduce(&sar_num, &sar_den, sar_num, sar_den, 0);
    } else {
        sar_num = 0;
        sar_den = 0;
    }

    if (osys->sar.num != sar_num || osys->sar.den != sar_den) {
        osys->ch_sar = true;
        osys->sar.num = sar_num;
        osys->sar.den = sar_den;
    }
}",1067.0,1086.0,1.0,1.0,20.0,31,9,24,7,1,8,3,3,2,1,,0,7,6,3,3,void
2304,189522,vout_SetDisplayCrop,1,vout_SetDisplayCrop,"void vout_SetDisplayCrop (vout_display_t*,unsigned,unsigned,unsigned,unsigned,int,int)",video_output\display.c,"void vout_SetDisplayCrop(vout_display_t *vd,
                         unsigned crop_num, unsigned crop_den,
                         unsigned left, unsigned top, int right, int bottom)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->crop.left  != (int)left  || osys->crop.top != (int)top ||
        osys->crop.right != right || osys->crop.bottom != bottom ||
        (crop_num != 0 && crop_den != 0 &&
         (crop_num != osys->crop.num || crop_den != osys->crop.den))) {

        osys->crop.left   = left;
        osys->crop.top    = top;
        osys->crop.right  = right;
        osys->crop.bottom = bottom;
        osys->crop.num    = crop_num;
        osys->crop.den    = crop_den;

        osys->ch_crop = true;
    }
}",1087.0,1107.0,1.0,1.0,21.0,52,7,30,9,3,1,2,2,0,0,,0,1,14,7,7,void
2305,189649,vout_SetDisplayViewpoint,1,vout_SetDisplayViewpoint,"void vout_SetDisplayViewpoint (vout_display_t*,vlc_viewpoint_t*)",video_output\display.c,"void vout_SetDisplayViewpoint(vout_display_t *vd,
                              const vlc_viewpoint_t *p_viewpoint)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (osys->viewpoint.yaw   != p_viewpoint->yaw ||
        osys->viewpoint.pitch != p_viewpoint->pitch ||
        osys->viewpoint.roll  != p_viewpoint->roll ||
        osys->viewpoint.fov   != p_viewpoint->fov) {
        osys->viewpoint = *p_viewpoint;

        osys->ch_viewpoint = true;
    }
}",1109.0,1122.0,1.0,1.0,14.0,27,6,14,4,1,6,2,2,4,0,,0,6,4,2,2,void
2306,189715,DisplayNew,1,DisplayNew,"vout_display_t DisplayNew (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,bool,mtime_t,mtime_t,vout_display_owner_t*)",video_output\display.c,"static vout_display_t *DisplayNew(vout_thread_t *vout,
                                  const video_format_t *source,
                                  const vout_display_state_t *state,
                                  const char *module, bool is_splitter,
                                  mtime_t double_click_timeout,
                                  mtime_t hide_timeout,
                                  const vout_display_owner_t *owner_ptr)
{
    /* */
    vout_display_owner_sys_t *osys = calloc(1, sizeof(*osys));
    vout_display_cfg_t *cfg = &osys->cfg;

    *cfg = state->cfg;
    osys->sar_initial = state->sar;
    vout_display_GetDefaultDisplaySize(&cfg->display.width, &cfg->display.height,
                                       source, cfg);

    osys->vout = vout;
    osys->is_splitter = is_splitter;

    vlc_mutex_init(&osys->lock);

    vlc_mouse_Init(&osys->mouse.state);
    osys->mouse.last_moved = mdate();
    osys->mouse.double_click_timeout = double_click_timeou...",1124.0,1222.0,1.0,1.0,99.0,126,10,80,15,3,32,7,5,3,8,,0,27,16,8,8,vout_display_t
2307,190064,vout_DeleteDisplay,1,vout_DeleteDisplay,"void vout_DeleteDisplay (vout_display_t*,vout_display_state_t*)",video_output\display.c,"void vout_DeleteDisplay(vout_display_t *vd, vout_display_state_t *state)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;

    if (state) {
        if (!osys->is_splitter)
            state->cfg = osys->cfg;
#if defined(_WIN32) || defined(__OS2__)
        state->wm_state = osys->wm_state;
#endif
        state->sar = osys->sar_initial;
    }

    VoutDisplayDestroyRender(vd);
    if (osys->is_splitter)
        SplitterClose(vd);
    vout_display_Delete(vd);
    vlc_mutex_destroy(&osys->lock);
    free(osys);
}",1224.0,1243.0,1.0,1.0,20.0,14,5,14,3,1,9,4,5,2,4,,0,5,4,2,2,void
2308,190119,vout_NewDisplay,1,vout_NewDisplay,"vout_display_t vout_NewDisplay (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,mtime_t,mtime_t)",video_output\display.c,"vout_display_t *vout_NewDisplay(vout_thread_t *vout,
                                const video_format_t *source,
                                const vout_display_state_t *state,
                                const char *module,
                                mtime_t double_click_timeout,
                                mtime_t hide_timeout)
{
    return DisplayNew(vout, source, state, module, false,
                      double_click_timeout, hide_timeout, NULL);
}",1248.0,1257.0,1.0,1.0,10.0,0,0,8,8,0,1,1,1,0,1,,0,0,12,6,6,vout_display_t
2309,190147,SplitterNewWindow,1,SplitterNewWindow,"vout_window_t SplitterNewWindow (vout_display_t*,unsigned)",video_output\display.c,"static vout_window_t *SplitterNewWindow(vout_display_t *vd, unsigned type)
{
    vout_display_owner_sys_t *osys = vd->owner.sys;
    vout_window_t *window;
    vout_window_cfg_t cfg = {
        .type = type,
        .width = vd->cfg->display.width,
        .height = vd->cfg->display.height,
        .is_standalone = true,
    };

    window = vout_display_window_New(osys->vout, &cfg);
    if (window != NULL)
        vout_display_window_Attach(window, vd);
    return window;
}",1275.0,1290.0,1.0,1.0,16.0,19,6,19,10,0,3,2,2,0,2,,0,2,4,2,2,vout_window_t
2310,190212,SplitterDelWindow,1,SplitterDelWindow,"void SplitterDelWindow (vout_display_t*,vout_window_t*)",video_output\display.c,"static void SplitterDelWindow(vout_display_t *vd, vout_window_t *window)
{
    if (window != NULL) {
        vout_display_window_Detach(window);
        vout_display_window_Delete(window);
    }
    (void) vd;
}",1292.0,1299.0,1.0,1.0,8.0,2,2,5,3,0,2,2,2,0,2,,0,0,4,2,2,void
2311,190230,SplitterEvent,1,SplitterEvent,"void SplitterEvent (vout_display_t*,int,va_list)",video_output\display.c,"static void SplitterEvent(vout_display_t *vd, int event, va_list args)
{
    //vout_display_owner_sys_t *osys = vd->owner.sys;

    switch (event) {
#if 0
    case VOUT_DISPLAY_EVENT_MOUSE_STATE:
    case VOUT_DISPLAY_EVENT_MOUSE_MOVED:
    case VOUT_DISPLAY_EVENT_MOUSE_PRESSED:
    case VOUT_DISPLAY_EVENT_MOUSE_RELEASED:
        /* TODO */
        break;
#endif
    case VOUT_DISPLAY_EVENT_MOUSE_DOUBLE_CLICK:
    case VOUT_DISPLAY_EVENT_KEY:
    case VOUT_DISPLAY_EVENT_CLOSE:
    case VOUT_DISPLAY_EVENT_DISPLAY_SIZE:
    case VOUT_DISPLAY_EVENT_PICTURES_INVALID:
        VoutDisplayEvent(vd, event, args);
        break;

    default:
        msg_Err(vd, ""splitter event not implemented: %d"", event);
        break;
    }
}",1301.0,1326.0,1.0,1.0,26.0,0,0,11,8,0,1,4,2,0,1,,0,0,6,3,3,void
2312,190261,SplitterPool,1,SplitterPool,"picture_pool_t SplitterPool (vout_display_t*,unsigned)",video_output\display.c,"static picture_pool_t *SplitterPool(vout_display_t *vd, unsigned count)
{
    vout_display_sys_t *sys = vd->sys;
    if (!sys->pool)
        sys->pool = picture_pool_NewFromFormat(&vd->fmt, count);
    return sys->pool;
}",1328.0,1334.0,1.0,1.0,7.0,9,4,7,3,0,4,2,2,1,1,,0,4,4,2,2,picture_pool_t
2313,190293,SplitterPrepare,1,SplitterPrepare,"void SplitterPrepare (vout_display_t*,picture_t*,subpicture_t*)",video_output\display.c,"static void SplitterPrepare(vout_display_t *vd,
                            picture_t *picture,
                            subpicture_t *subpicture)
{
    vout_display_sys_t *sys = vd->sys;

    picture_Hold(picture);
    assert(!subpicture);

    if (video_splitter_Filter(sys->splitter, sys->picture, picture)) {
        for (int i = 0; i < sys->count; i++)
            sys->picture[i] = NULL;
        return;
    }

    for (int i = 0; i < sys->count; i++) {
        sys->picture[i] = vout_FilterDisplay(sys->display[i], sys->picture[i]);
        if (sys->picture[i])
            vout_display_Prepare(sys->display[i], sys->picture[i], NULL);
    }
}",1335.0,1355.0,1.0,1.0,21.0,24,5,26,6,0,12,5,7,5,2,,0,11,6,3,3,void
2314,190392,SplitterDisplay,1,SplitterDisplay,"void SplitterDisplay (vout_display_t*,picture_t*,subpicture_t*)",video_output\display.c,"static void SplitterDisplay(vout_display_t *vd,
                            picture_t *picture,
                            subpicture_t *subpicture)
{
    vout_display_sys_t *sys = vd->sys;

    assert(!subpicture);
    for (int i = 0; i < sys->count; i++) {
        if (sys->picture[i])
            vout_display_Display(sys->display[i], sys->picture[i], NULL);
    }
    picture_Release(picture);
}",1356.0,1368.0,1.0,1.0,13.0,12,5,14,6,0,5,3,4,2,1,,0,4,6,3,3,void
2315,190461,SplitterManage,1,SplitterManage,void SplitterManage (vout_display_t*),video_output\display.c,"static void SplitterManage(vout_display_t *vd)
{
    vout_display_sys_t *sys = vd->sys;

    for (int i = 0; i < sys->count; i++)
        vout_ManageDisplay(sys->display[i], true);
}",1374.0,1380.0,1.0,1.0,7.0,5,3,5,3,0,1,2,2,1,0,,0,1,2,1,1,void
2316,190492,SplitterPictureNew,1,SplitterPictureNew,"int SplitterPictureNew (video_splitter_t*,picture_t[]*)",video_output\display.c,"static int SplitterPictureNew(video_splitter_t *splitter, picture_t *picture[])
{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++) {
        if (vout_IsDisplayFiltered(wsys->display[i])) {
            /* TODO use a pool ? */
            picture[i] = picture_NewFromFormat(&wsys->display[i]->source);
        } else {
            picture_pool_t *pool = vout_display_Pool(wsys->display[i], 3);
            picture[i] = pool ? picture_pool_Get(pool) : NULL;
        }
        if (!picture[i]) {
            for (int j = 0; j < i; j++)
                picture_Release(picture[j]);
            return VLC_EGENERIC;
        }
    }
    return VLC_SUCCESS;
}",1382.0,1401.0,1.0,1.0,20.0,19,6,18,7,0,5,5,9,3,2,,0,5,4,2,2,int
2317,190589,SplitterPictureDel,1,SplitterPictureDel,"void SplitterPictureDel (video_splitter_t*,picture_t[]*)",video_output\display.c,"static void SplitterPictureDel(video_splitter_t *splitter, picture_t *picture[])
{
    vout_display_sys_t *wsys = splitter->p_owner->wrapper->sys;

    for (int i = 0; i < wsys->count; i++)
        picture_Release(picture[i]);
}",1402.0,1408.0,1.0,1.0,7.0,7,3,5,3,0,1,2,2,1,0,,0,1,4,2,2,void
2318,190687,vout_NewSplitter,1,vout_NewSplitter,"vout_display_t vout_NewSplitter (vout_thread_t*,video_format_t*,vout_display_state_t*,char*,char*,mtime_t,mtime_t)",video_output\display.c,"vout_display_t *vout_NewSplitter(vout_thread_t *vout,
                                 const video_format_t *source,
                                 const vout_display_state_t *state,
                                 const char *module,
                                 const char *splitter_module,
                                 mtime_t double_click_timeout,
                                 mtime_t hide_timeout)
{
    video_splitter_t *splitter =
        video_splitter_New(VLC_OBJECT(vout), splitter_module, source);
    if (!splitter)
        return NULL;

    /* */
    vout_display_t *wrapper =
        DisplayNew(vout, source, state, module, true,
                    double_click_timeout, hide_timeout, NULL);
    if (!wrapper) {
        video_splitter_Delete(splitter);
        return NULL;
    }
    vout_display_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        abort();
    sys->picture = calloc(splitter->i_output, sizeof(*sys->picture));
    if (!sys->picture )
        ab...",1430.0,1505.0,1.0,1.0,76.0,94,11,85,22,0,15,7,8,1,5,,0,13,14,7,7,vout_display_t
2319,190981,vout_SendDisplayEventMouse,1,vout_SendDisplayEventMouse,"void vout_SendDisplayEventMouse (vout_thread_t*,vlc_mouse_t*)",video_output\display.c,"void vout_SendDisplayEventMouse(vout_thread_t *vout, const vlc_mouse_t *m)
{
    vlc_mouse_t tmp1, tmp2;

    /* The check on spu is needed as long as ALLOW_DUMMY_VOUT is defined */
    if (vout->p->spu && spu_ProcessMouse( vout->p->spu, m, &vout->p->display.vd->source))
        return;

    vlc_mutex_lock( &vout->p->filter.lock );
    if (vout->p->filter.chain_static && vout->p->filter.chain_interactive) {
        if (!filter_chain_MouseFilter(vout->p->filter.chain_interactive, &tmp1, m))
            m = &tmp1;
        if (!filter_chain_MouseFilter(vout->p->filter.chain_static,      &tmp2, m))
            m = &tmp2;
    }
    vlc_mutex_unlock( &vout->p->filter.lock );

    if (vlc_mouse_HasMoved(&vout->p->mouse, m)) {
        vout_SendEventMouseMoved(vout, m->i_x, m->i_y);
    }
    if (vlc_mouse_HasButton(&vout->p->mouse, m)) {
        for (unsigned button = 0; button < MOUSE_BUTTON_MAX; button++) {
            if (vlc_mouse_HasPressed(&vout->p->mouse, m, button))
                ...",1511.0,1542.0,1.0,1.0,32.0,57,8,37,6,1,8,10,15,3,8,,0,3,4,2,2,void
2320,191195,vout_NewDisplayWindow,1,vout_NewDisplayWindow,"vout_window_t* vout_NewDisplayWindow (vout_thread_t*,unsigned)",video_output\video_output.c,"vout_window_t *vout_NewDisplayWindow(vout_thread_t *vout, unsigned type)
{
    vout_window_t *window = vout->p->window;

    assert(vout->p->splitter_name == NULL);

    if (window == NULL)
        return NULL;
    if (type != VOUT_WINDOW_TYPE_INVALID && type != window->type)
        return NULL;
    return window;
}",611.0,622.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,vout_window_t
2321,191201,vout_DeleteDisplayWindow,1,vout_DeleteDisplayWindow,"void vout_DeleteDisplayWindow (vout_thread_t*,vout_window_t*)",video_output\video_output.c,"void vout_DeleteDisplayWindow(vout_thread_t *vout, vout_window_t *window)
{
    if (window == NULL && vout->p->window != NULL) {
        vout_display_window_Delete(vout->p->window);
        vout->p->window = NULL;
    }
    assert(vout->p->window == window);
}",624.0,631.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2322,191207,vout_SetDisplayWindowSize,1,vout_SetDisplayWindowSize,"void vout_SetDisplayWindowSize (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"void vout_SetDisplayWindowSize(vout_thread_t *vout,
                               unsigned width, unsigned height)
{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
    /* Request a resize of the window. If it fails, there is nothing to do.
     * If it succeeds, the window will emit a resize event later. */
        vout_window_SetSize(window, width, height);
    else
    if (vout->p->display.vd != NULL)
    /* Force a resize of window-less display. This is not allowed to fail,
     * although the display is allowed to ignore the size anyway. */
        /* FIXME: remove this, fix MSW and OS/2 window providers */
        vout_display_SendEventDisplaySize(vout->p->display.vd, width, height);
}",633.0,648.0,1.0,1.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
2323,191214,vout_HideWindowMouse,1,vout_HideWindowMouse,"int vout_HideWindowMouse (vout_thread_t*,ANY)",video_output\video_output.c,"int vout_HideWindowMouse(vout_thread_t *vout, bool hide)
{
    vout_window_t *window = vout->p->window;

    return window != NULL ? vout_window_HideMouse(window, hide) : VLC_EGENERIC;
}",650.0,655.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2324,191237,vout_SendEventClose,1,vout_SendEventClose,void vout_SendEventClose (vout_thread_t*),video_output\event.h,"static inline void vout_SendEventClose(vout_thread_t *vout)
{
#warning FIXME: implement video close event
    /* FIXME: this code is disabled as it breaks the non-playlist cases */
    //playlist_Stop(pl_Get(vout));
    (void) vout;
}",40.0,46.0,1.0,1.0,7.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
2325,191245,vout_SendEventKey,1,vout_SendEventKey,"void vout_SendEventKey (vout_thread_t*,int)",video_output\event.h,"static inline void vout_SendEventKey(vout_thread_t *vout, int key)
{
    var_SetInteger(vout->obj.libvlc, ""key-pressed"", key);
}",47.0,50.0,1.0,1.0,4.0,2,2,2,2,2,0,1,1,0,0,,0,0,4,2,2,void
2326,191259,vout_SendEventMouseMoved,1,vout_SendEventMouseMoved,"void vout_SendEventMouseMoved (vout_thread_t*,int,int)",video_output\event.h,"static inline void vout_SendEventMouseMoved(vout_thread_t *vout, int x, int y)
{
    var_SetCoords(vout, ""mouse-moved"", x, y);
}",51.0,54.0,1.0,1.0,4.0,0,0,3,3,1,0,1,1,0,0,,0,0,6,3,3,void
2327,191271,vout_SendEventViewpointMoved,1,vout_SendEventViewpointMoved,"void vout_SendEventViewpointMoved (vout_thread_t*,vlc_viewpoint_t*)",video_output\event.h,"static inline void vout_SendEventViewpointMoved(vout_thread_t *vout,
                                                const vlc_viewpoint_t *p_viewpoint)
{
    var_SetAddress(vout, ""viewpoint-moved"", (void *) p_viewpoint);
    /* This variable can only be read from callbacks */
    var_Change(vout, ""viewpoint-moved"", VLC_VAR_SETVALUE,
               &(vlc_value_t) { .p_address = NULL }, NULL);
}",55.0,62.0,1.0,1.0,8.0,5,4,7,5,0,1,1,1,0,1,,0,0,4,2,2,void
2328,191296,vout_SendEventMousePressed,1,vout_SendEventMousePressed,"void vout_SendEventMousePressed (vout_thread_t*,int)",video_output\event.h,"static inline void vout_SendEventMousePressed(vout_thread_t *vout, int button)
{
    int key = KEY_UNSET;
    var_OrInteger(vout, ""mouse-button-down"", 1 << button);

    switch (button)
    {
    case MOUSE_BUTTON_LEFT:
    {
        /* FIXME? */
        int x, y;
        var_GetCoords(vout, ""mouse-moved"", &x, &y);
        var_SetCoords(vout, ""mouse-clicked"", x, y);
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", false);
        return;
    }
    case MOUSE_BUTTON_CENTER:
        var_ToggleBool(vout->obj.libvlc, ""intf-toggle-fscontrol"");
        return;
    case MOUSE_BUTTON_RIGHT:
#if !defined(_WIN32)
        var_SetBool(vout->obj.libvlc, ""intf-popupmenu"", true);
#endif
        return;
    case MOUSE_BUTTON_WHEEL_UP:    key = KEY_MOUSEWHEELUP;    break;
    case MOUSE_BUTTON_WHEEL_DOWN:  key = KEY_MOUSEWHEELDOWN;  break;
    case MOUSE_BUTTON_WHEEL_LEFT:  key = KEY_MOUSEWHEELLEFT;  break;
    case MOUSE_BUTTON_WHEEL_RIGHT: key = KEY_MOUSEWHEELRIGHT; break;
    }
    vout_Se...",63.0,93.0,1.0,1.0,31.0,14,5,33,19,1,1,6,2,0,1,,0,0,4,2,2,void
2329,191401,vout_SendEventMouseDoubleClick,1,vout_SendEventMouseDoubleClick,void vout_SendEventMouseDoubleClick (vout_thread_t*),video_output\event.h,"static inline void vout_SendEventMouseDoubleClick(vout_thread_t *vout)
{
    //vout_ControlSetFullscreen(vout, !var_GetBool(vout, ""fullscreen""));
    var_ToggleBool(vout, ""fullscreen"");
}",106.0,110.0,1.0,1.0,5.0,0,0,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
2330,191409,vout_SendEventViewpointChangeable,1,vout_SendEventViewpointChangeable,"void vout_SendEventViewpointChangeable (vout_thread_t*,bool)",video_output\event.h,"static inline void vout_SendEventViewpointChangeable(vout_thread_t *vout,
                                                     bool b_can_change)
{
    var_SetBool(vout, ""viewpoint-changeable"", b_can_change);
}",111.0,115.0,1.0,1.0,5.0,0,0,2,2,1,0,1,1,0,0,,0,0,4,2,2,void
2331,191440,vlc_inhibit_Create,1,vlc_inhibit_Create,vlc_inhibit_t vlc_inhibit_Create (vlc_object_t*),video_output\inhibit.c,"vlc_inhibit_t *vlc_inhibit_Create (vlc_object_t *parent)
{
    inhibit_t *priv = vlc_custom_create (parent, sizeof (*priv), ""inhibit"" );
    if (priv == NULL)
        return NULL;

    vlc_inhibit_t *ih = &priv->ih;
    ih->p_sys = NULL;
    ih->inhibit = NULL;

    priv->module = module_need (ih, ""inhibit"", NULL, false);
    if (priv->module == NULL)
    {
        vlc_object_release (ih);
        ih = NULL;
    }
    return ih;
}",37.0,54.0,1.0,1.0,18.0,16,6,22,5,1,6,3,3,1,3,,0,5,2,1,1,vlc_inhibit_t
2332,191501,vlc_inhibit_Destroy,1,vlc_inhibit_Destroy,void vlc_inhibit_Destroy (vlc_inhibit_t*),video_output\inhibit.c,"void vlc_inhibit_Destroy (vlc_inhibit_t *ih)
{
    assert (ih != NULL);

    module_unneed (ih, ((inhibit_t *)ih)->module);
    vlc_object_release (ih);
}",56.0,62.0,1.0,1.0,7.0,3,3,5,2,1,2,1,1,0,2,,0,0,2,1,1,void
2333,191568,DeinterlaceIsModeValid,1,DeinterlaceIsModeValid,bool DeinterlaceIsModeValid (char*),video_output\interlacing.c,"static bool DeinterlaceIsModeValid(const char *mode)
{
    for (unsigned i = 0; i < ARRAY_SIZE(deinterlace_modes); i++) {
        if (!strcmp(deinterlace_modes[i], mode))
            return true;
    }
    return false;
}",56.0,63.0,1.0,1.0,8.0,4,4,8,5,2,2,3,4,2,0,,0,2,2,1,1,bool
2334,191598,DeinterlaceCallback,1,DeinterlaceCallback,"int DeinterlaceCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\interlacing.c,"static int DeinterlaceCallback(vlc_object_t *object, char const *cmd,
                               vlc_value_t oldval, vlc_value_t newval, void *data)
{
    VLC_UNUSED(cmd); VLC_UNUSED(oldval); VLC_UNUSED(newval); VLC_UNUSED(data);
    vout_thread_t *vout = (vout_thread_t *)object;

    /* */
    const int  deinterlace_state = var_GetInteger(vout, ""deinterlace"");
    char       *mode             = var_GetString(vout,  ""deinterlace-mode"");
    const bool is_needed         = var_GetBool(vout,    ""deinterlace-needed"");
    if (!mode || !DeinterlaceIsModeValid(mode))
    {
        free(mode);
        return VLC_EGENERIC;
    }

    /* */
    char *old = var_CreateGetString(vout, ""sout-deinterlace-mode"");
    var_SetString(vout, ""sout-deinterlace-mode"", mode);

    msg_Dbg(vout, ""deinterlace %d, mode %s, is_needed %d"", deinterlace_state, mode, is_needed);
    if (deinterlace_state == 0 || (deinterlace_state < 0 && !is_needed))
        vout_control_PushBool(&vout->p->control,
          ...",65.0,97.0,1.0,1.0,33.0,17,9,33,14,0,2,3,3,1,2,,0,1,10,5,5,int
2335,191705,vout_InitInterlacingSupport,1,vout_InitInterlacingSupport,"void vout_InitInterlacingSupport (vout_thread_t*,bool)",video_output\interlacing.c,"void vout_InitInterlacingSupport(vout_thread_t *vout, bool is_interlaced)
{
    vlc_value_t val, text;

    msg_Dbg(vout, ""Deinterlacing available"");

    vout->p->filter.has_deint = false;

    /* Create the configuration variables */
    /* */
    var_Create(vout, ""deinterlace"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    int deinterlace_state = var_GetInteger(vout, ""deinterlace"");

    text.psz_string = _(""Deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_SETTEXT, &text, NULL);

    const module_config_t *optd = config_FindConfig(""deinterlace"");
    var_Change(vout, ""deinterlace"", VLC_VAR_CLEARCHOICES, NULL, NULL);
    if (likely(optd != NULL))
        for (unsigned i = 0; i < optd->list_count; i++) {
            val.i_int = optd->list.i[i];
            text.psz_string = vlc_gettext(optd->list_text[i]);
            var_Change(vout, ""deinterlace"", VLC_VAR_ADDCHOICE, &val, &text);
        }
    var_AddCallback(vout, ""deinterlace"", DeinterlaceCallback, NULL);
    /* */
    v...",99.0,170.0,1.0,1.0,72.0,75,11,104,20,1,20,10,13,1,20,,0,6,4,2,2,void
2336,192015,vout_ReinitInterlacingSupport,1,vout_ReinitInterlacingSupport,void vout_ReinitInterlacingSupport (vout_thread_t*),video_output\interlacing.c,"void vout_ReinitInterlacingSupport(vout_thread_t *vout)
{
    vout->p->interlacing.is_interlaced = false;
    var_SetBool(vout, ""deinterlace-needed"", false);
}",172.0,176.0,1.0,1.0,5.0,4,3,4,2,1,0,1,1,0,0,,0,0,2,1,1,void
2337,192033,vout_SetInterlacingState,1,vout_SetInterlacingState,"void vout_SetInterlacingState (vout_thread_t*,bool)",video_output\interlacing.c,"void vout_SetInterlacingState(vout_thread_t *vout, bool is_interlaced)
{
     /* Wait 30s before quiting interlacing mode */
    const int interlacing_change = (!!is_interlaced)
                                 - (!!vout->p->interlacing.is_interlaced);
    if (interlacing_change == 1 ||
        (interlacing_change == -1 &&
        vout->p->interlacing.date + 30000000 < mdate()))
    {
        msg_Dbg(vout, ""Detected %s video"",
                 is_interlaced ? ""interlaced"" : ""progressive"");
        var_SetBool(vout, ""deinterlace-needed"", is_interlaced);
        vout->p->interlacing.is_interlaced = is_interlaced;
    }
    if (is_interlaced)
        vout->p->interlacing.date = mdate();
}",178.0,194.0,1.0,1.0,17.0,28,12,14,3,0,2,3,3,1,2,,0,2,4,2,2,void
2338,192157,vlc_gl_Create,1,vlc_gl_Create,"vlc_gl_t vlc_gl_Create (vout_window_t*,unsigned,char*)",video_output\opengl.c,"vlc_gl_t *vlc_gl_Create(struct vout_window_t *wnd, unsigned flags,
                        const char *name)
{
    vlc_object_t *parent = (vlc_object_t *)wnd;
    struct vlc_gl_priv_t *glpriv;
    const char *type;

    switch (flags /*& VLC_OPENGL_API_MASK*/)
    {
        case VLC_OPENGL:
            type = ""opengl"";
            break;
        case VLC_OPENGL_ES2:
            type = ""opengl es2"";
            break;
        default:
            return NULL;
    }

    glpriv = vlc_custom_create(parent, sizeof (*glpriv), ""gl"");
    if (unlikely(glpriv == NULL))
        return NULL;

    glpriv->gl.surface = wnd;
    glpriv->gl.module = module_need(&glpriv->gl, type, name, true);
    if (glpriv->gl.module == NULL)
    {
        vlc_object_release(&glpriv->gl);
        return NULL;
    }
    atomic_init(&glpriv->ref_count, 1);

    return &glpriv->gl;
}",50.0,83.0,1.0,13.0,34.0,25,8,28,10,1,10,6,4,1,3,,0,9,6,3,3,vlc_gl_t
2339,192259,vlc_gl_Hold,1,vlc_gl_Hold,void vlc_gl_Hold (vlc_gl_t*),video_output\opengl.c,"void vlc_gl_Hold(vlc_gl_t *gl)
{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    atomic_fetch_add(&glpriv->ref_count, 1);
}",85.0,89.0,1.0,1.0,5.0,4,4,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
2340,192276,vlc_gl_Release,1,vlc_gl_Release,void vlc_gl_Release (vlc_gl_t*),video_output\opengl.c,"void vlc_gl_Release(vlc_gl_t *gl)
{
    struct vlc_gl_priv_t *glpriv = (struct vlc_gl_priv_t *)gl;
    if (atomic_fetch_sub(&glpriv->ref_count, 1) != 1)
        return;
    module_unneed(gl, gl->module);
    vlc_object_release(gl);
}",91.0,98.0,1.0,1.0,8.0,6,5,6,2,1,3,2,2,1,2,,0,1,2,1,1,void
2341,192310,vlc_gl_surface_ResizeNotify,1,vlc_gl_surface_ResizeNotify,"void vlc_gl_surface_ResizeNotify (vout_window_t*,unsigned,unsigned)",video_output\opengl.c,"static void vlc_gl_surface_ResizeNotify(vout_window_t *surface,
                                        unsigned width, unsigned height)
{
    vlc_gl_surface_t *sys = surface->owner.sys;

    msg_Dbg(surface, ""resized to %ux%u"", width, height);

    vlc_mutex_lock(&sys->lock);
    sys->width = width;
    sys->height = height;
    vlc_mutex_unlock(&sys->lock);
}",109.0,120.0,1.0,1.0,12.0,11,4,11,4,0,2,1,1,0,2,,0,0,6,3,3,void
2342,192350,vlc_gl_surface_Create,1,vlc_gl_surface_Create,"vlc_gl_t vlc_gl_surface_Create (vlc_object_t*,vout_window_cfg_t*,vout_window_t**)",video_output\opengl.c,"vlc_gl_t *vlc_gl_surface_Create(vlc_object_t *obj,
                                const vout_window_cfg_t *cfg,
                                struct vout_window_t **restrict wp)
{
    vlc_gl_surface_t *sys = malloc(sizeof (*sys));
    if (unlikely(sys == NULL))
        return NULL;

    sys->width = cfg->width;
    sys->height = cfg->height;
    vlc_mutex_init(&sys->lock);

    vout_window_owner_t owner = {
        .sys = sys,
        .resized = vlc_gl_surface_ResizeNotify,
    };

    vout_window_t *surface = vout_window_New(obj, ""$window"", cfg, &owner);
    if (surface == NULL)
        goto error;
    if (wp != NULL)
        *wp = surface;

    /* TODO: support ES? */
    vlc_gl_t *gl = vlc_gl_Create(surface, VLC_OPENGL, NULL);
    if (gl == NULL) {
        vout_window_Delete(surface);
        return NULL;
    }

    vlc_gl_Resize(gl, cfg->width, cfg->height);
    return gl;

error:
    vlc_mutex_destroy(&sys->lock);
    free(sys);
    return NULL;
}",122.0,159.0,1.0,1.0,38.0,28,8,39,10,0,5,6,5,0,5,,0,2,6,3,3,vlc_gl_t
2343,192463,vlc_gl_surface_CheckSize,1,vlc_gl_surface_CheckSize,"bool vlc_gl_surface_CheckSize (vlc_gl_t*,unsigned*,unsigned*)",video_output\opengl.c,"bool vlc_gl_surface_CheckSize(vlc_gl_t *gl, unsigned *restrict width,
                              unsigned *restrict height)
{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;
    bool ret = false;

    vlc_mutex_lock(&sys->lock);
    if (sys->width >= 0 && sys->height >= 0)
    {
        *width = sys->width;
        *height = sys->height;
        sys->width = -1;
        sys->height = -1;

        vlc_gl_Resize(gl, *width, *height);
        ret = true;
    }
    vlc_mutex_unlock(&sys->lock);
    return ret;
}",169.0,189.0,1.0,1.0,21.0,30,8,22,8,0,2,2,2,0,2,,0,0,6,3,3,bool
2344,192546,vlc_gl_surface_Destroy,1,vlc_gl_surface_Destroy,void vlc_gl_surface_Destroy (vlc_gl_t*),video_output\opengl.c,"void vlc_gl_surface_Destroy(vlc_gl_t *gl)
{
    vout_window_t *surface = gl->surface;
    vlc_gl_surface_t *sys = surface->owner.sys;

    vlc_gl_Release(gl);
    vout_window_Delete(surface);
    vlc_mutex_destroy(&sys->lock);
    free(sys);
}",191.0,200.0,1.0,1.0,10.0,7,4,8,3,0,3,1,1,0,3,,0,0,2,1,1,void
2345,192607,vout_snapshot_Init,1,vout_snapshot_Init,void vout_snapshot_Init (vout_snapshot_t*),video_output\snapshot.c,"void vout_snapshot_Init(vout_snapshot_t *snap)
{
    vlc_mutex_init(&snap->lock);
    vlc_cond_init(&snap->wait);

    snap->is_available = true;
    snap->request_count = 0;
    snap->picture = NULL;
}",45.0,53.0,1.0,1.0,9.0,10,3,7,3,1,7,1,1,0,2,,0,5,2,1,1,void
2346,192637,vout_snapshot_Clean,1,vout_snapshot_Clean,void vout_snapshot_Clean (vout_snapshot_t*),video_output\snapshot.c,"void vout_snapshot_Clean(vout_snapshot_t *snap)
{
    picture_t *picture = snap->picture;
    while (picture) {
        picture_t *next = picture->p_next;
        picture_Release(picture);
        picture = next;
    }

    vlc_cond_destroy(&snap->wait);
    vlc_mutex_destroy(&snap->lock);
}",54.0,65.0,1.0,1.0,12.0,9,3,10,3,0,6,2,2,0,3,,0,3,2,1,1,void
2347,192672,vout_snapshot_End,1,vout_snapshot_End,void vout_snapshot_End (vout_snapshot_t*),video_output\snapshot.c,"void vout_snapshot_End(vout_snapshot_t *snap)
{
    vlc_mutex_lock(&snap->lock);

    snap->is_available = false;

    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",67.0,75.0,1.0,1.0,9.0,8,3,5,2,1,7,1,1,0,3,,0,4,2,1,1,void
2348,192697,vout_snapshot_Get,1,vout_snapshot_Get,"picture_t vout_snapshot_Get (vout_snapshot_t*,mtime_t)",video_output\snapshot.c,"picture_t *vout_snapshot_Get(vout_snapshot_t *snap, mtime_t timeout)
{
    const mtime_t deadline = mdate() + timeout;

    vlc_mutex_lock(&snap->lock);

    /* */
    snap->request_count++;

    /* */
    while (snap->is_available && !snap->picture &&
        vlc_cond_timedwait(&snap->wait, &snap->lock, deadline) == 0);

    /* */
    picture_t *picture = snap->picture;
    if (picture)
        snap->picture = picture->p_next;
    else if (snap->request_count > 0)
        snap->request_count--;

    vlc_mutex_unlock(&snap->lock);

    return picture;
}",78.0,101.0,1.0,1.0,24.0,23,8,16,4,1,13,3,3,5,4,,0,11,4,2,2,picture_t
2349,192776,vout_snapshot_IsRequested,1,vout_snapshot_IsRequested,bool vout_snapshot_IsRequested (vout_snapshot_t*),video_output\snapshot.c,"bool vout_snapshot_IsRequested(vout_snapshot_t *snap)
{
    bool has_request = false;
    if (!vlc_mutex_trylock(&snap->lock)) {
        has_request = snap->request_count > 0;
        vlc_mutex_unlock(&snap->lock);
    }
    return has_request;
}",104.0,112.0,1.0,1.0,9.0,9,5,7,3,1,5,2,2,2,2,,0,4,2,1,1,bool
2350,192807,vout_snapshot_Set,1,vout_snapshot_Set,"void vout_snapshot_Set (vout_snapshot_t*,video_format_t*,picture_t*)",video_output\snapshot.c,"void vout_snapshot_Set(vout_snapshot_t *snap,
                       const video_format_t *fmt,
                       picture_t *picture)
{
    if (!fmt)
        fmt = &picture->format;

    vlc_mutex_lock(&snap->lock);
    while (snap->request_count > 0) {
        picture_t *dup = picture_Clone(picture);
        if (!dup)
            break;

        video_format_CopyCrop( &dup->format, fmt );

        dup->p_next = snap->picture;
        snap->picture = dup;
        snap->request_count--;
    }
    vlc_cond_broadcast(&snap->wait);
    vlc_mutex_unlock(&snap->lock);
}",113.0,134.0,1.0,1.0,22.0,23,6,17,4,1,12,5,5,1,5,,0,8,6,3,3,void
2351,192878,vout_snapshot_GetDirectory,1,vout_snapshot_GetDirectory,char* vout_snapshot_GetDirectory (void),video_output\snapshot.c,"char *vout_snapshot_GetDirectory(void)
{
    return config_GetUserDir(VLC_PICTURES_DIR);
}",136.0,139.0,1.0,1.0,4.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,char*
2352,192886,vout_snapshot_SaveImage,1,vout_snapshot_SaveImage,"int vout_snapshot_SaveImage (char**,int*,block_t*,vout_thread_t*,vout_snapshot_save_cfg_t*)",video_output\snapshot.c,"int vout_snapshot_SaveImage(char **name, int *sequential,
                             const block_t *image,
                             vout_thread_t *p_vout,
                             const vout_snapshot_save_cfg_t *cfg)
{
    /* */
    char *filename;
    input_thread_t *input = (input_thread_t*)p_vout->p->input;

    /* */
    char *prefix = NULL;
    if (cfg->prefix_fmt)
        prefix = str_format(input, cfg->prefix_fmt);
    if (prefix)
        filename_sanitize(prefix);
    else {
        prefix = strdup(""vlcsnap-"");
        if (prefix == NULL)
            goto error;
    }

    struct stat st;
    bool b_is_folder = false;

    if ( vlc_stat( cfg->path, &st ) == 0 )
        b_is_folder = S_ISDIR( st.st_mode );
    if ( b_is_folder ) {
        if (cfg->is_sequential) {
            for (int num = cfg->sequence; ; num++) {
                if (asprintf(&filename, ""%s"" DIR_SEP ""%s%05d.%s"",
                             cfg->path, prefix, num, cfg->format) < 0) {
             ...",141.0,232.0,1.0,1.0,92.0,29,10,49,16,1,9,18,22,5,4,,0,8,10,5,5,int
2353,193199,vout_statistic_Init,1,vout_statistic_Init,void vout_statistic_Init (vout_statistic_t*),video_output\statistic.h,"static inline void vout_statistic_Init(vout_statistic_t *stat)
{
    atomic_init(&stat->displayed, 0);
    atomic_init(&stat->lost, 0);
}",36.0,40.0,1.0,1.0,5.0,4,2,2,1,1,2,1,1,0,0,,0,2,2,1,1,void
2354,193224,vout_statistic_GetReset,1,vout_statistic_GetReset,"void vout_statistic_GetReset (vout_statistic_t*,unsigned*,unsigned*)",video_output\statistic.h,"static inline void vout_statistic_GetReset(vout_statistic_t *stat,
                                           unsigned *restrict displayed,
                                           unsigned *restrict lost)
{
    *displayed = atomic_exchange(&stat->displayed, 0);
    *lost      = atomic_exchange(&stat->lost, 0);
}",47.0,53.0,1.0,1.0,7.0,8,4,4,3,1,2,1,1,0,0,,0,2,6,3,3,void
2355,193249,vout_statistic_AddDisplayed,1,vout_statistic_AddDisplayed,"void vout_statistic_AddDisplayed (vout_statistic_t*,int)",video_output\statistic.h,"static inline void vout_statistic_AddDisplayed(vout_statistic_t *stat,
                                               int displayed)
{
    atomic_fetch_add(&stat->displayed, displayed);
}",55.0,59.0,1.0,1.0,5.0,2,2,2,2,1,1,1,1,0,0,,0,1,4,2,2,void
2356,193261,vout_statistic_AddLost,1,vout_statistic_AddLost,"void vout_statistic_AddLost (vout_statistic_t*,int)",video_output\statistic.h,"static inline void vout_statistic_AddLost(vout_statistic_t *stat, int lost)
{
    atomic_fetch_add(&stat->lost, lost);
}",61.0,64.0,1.0,1.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
2357,193303,GetDefaultArtUri,1,GetDefaultArtUri,char* GetDefaultArtUri (void),video_output\video_epg.c,"static char * GetDefaultArtUri( void )
{
    char *psz_uri = NULL;
    char *psz_path;
    char *psz_datadir = config_GetDataDir();
    if( asprintf( &psz_path, ""%s/icons/128x128/vlc.png"", psz_datadir ) >= 0 )
    {
        psz_uri = vlc_path2uri( psz_path, NULL );
        free( psz_path );
    }
    free( psz_datadir );
    return psz_uri;
}",77.0,89.0,1.0,1.0,13.0,5,3,11,4,1,2,2,2,0,2,,0,2,2,1,1,char*
2358,193337,vout_OSDBackground,1,vout_OSDBackground,"subpicture_region_t vout_OSDBackground (int,int,int,int,uint32_t)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDBackground(int x, int y,
                                                int width, int height,
                                                uint32_t i_argb)
{
    /* Create a new subpicture region */
    video_palette_t palette;
    spuregion_CreateVGradientPalette( &palette, GRADIENT_COLORS, i_argb, 0xFF000000 );

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x = x;
    region->i_y = y;

    spuregion_CreateVGradientFill( region->p_picture->p, palette.i_entries );

    return region;
}",93.0,120.0,1.0,48.0,28.0,30,6,28,12,2,3,2,2,0,3,,0,1,10,5,5,subpicture_region_t
2359,193434,vout_OSDEpgSlider,1,vout_OSDEpgSlider,"subpicture_region_t vout_OSDEpgSlider (int,int,int,int,float)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDEpgSlider(int x, int y,
                                               int width, int height,
                                               float ratio)
{
    /* Create a new subpicture region */
    video_palette_t palette = {
        .i_entries = 4,
        .palette = {
            [0] = { HEX2YUV(RGB_COLOR1), 0x20 }, /* Bar fill remain/background */
            [1] = { HEX2YUV(0x00ff00), 0xff },
            [2] = { HEX2YUV(RGB_COLOR1), 0xC0 }, /* Bar fill */
            [3] = { HEX2YUV(0xffffff), 0xff }, /* Bar outline */
        },
    };

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width  = fmt.i_visible_width  = width;
    fmt.i_height = fmt.i_visible_height = height;
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;
    fmt.p_palette = &palette;

    subpicture_region_t *region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->i_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN...",122.0,189.0,1.0,20.0,68.0,226,20,81,20,1,1,7,16,0,1,,0,1,10,5,5,subpicture_region_t
2360,194004,vout_OSDSegmentSetNoWrap,1,vout_OSDSegmentSetNoWrap,void vout_OSDSegmentSetNoWrap (text_segment_t*),video_output\video_epg.c,"static void vout_OSDSegmentSetNoWrap(text_segment_t *p_segment)
{
    for( ; p_segment; p_segment = p_segment->p_next )
    {
        p_segment->style->e_wrapinfo = STYLE_WRAP_NONE;
        p_segment->style->i_features |= STYLE_HAS_WRAP_INFO;
    }
}",191.0,198.0,1.0,1.0,8.0,5,2,5,3,1,0,2,2,0,0,,0,0,2,1,1,void
2361,194032,vout_OSDSegment,1,vout_OSDSegment,"text_segment_t vout_OSDSegment (char*,int,uint32_t)",video_output\video_epg.c,"static text_segment_t * vout_OSDSegment(const char *psz_text, int size, uint32_t color)
{
    text_segment_t *p_segment = text_segment_New(psz_text);
    if(unlikely(!p_segment))
        return NULL;

    /* Set text style */
    p_segment->style = text_style_Create(STYLE_NO_DEFAULTS);
    if (unlikely(!p_segment->style))
    {
        text_segment_Delete(p_segment);
        return NULL;
    }

    p_segment->style->i_font_size  = __MAX(size ,1 );
    p_segment->style->i_font_color = color;
    p_segment->style->i_font_alpha = STYLE_ALPHA_OPAQUE;
    p_segment->style->i_outline_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_shadow_alpha = STYLE_ALPHA_TRANSPARENT;
    p_segment->style->i_features |= STYLE_HAS_FONT_ALPHA | STYLE_HAS_FONT_COLOR |
                                    STYLE_HAS_OUTLINE_ALPHA | STYLE_HAS_SHADOW_ALPHA;

    return p_segment;
}",200.0,223.0,1.0,1.0,24.0,26,4,25,12,3,3,3,3,0,3,,0,2,6,3,3,text_segment_t
2362,194120,vout_OSDImage,1,vout_OSDImage,"subpicture_region_t vout_OSDImage (vlc_object_t*,int,int,int,int,char*)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDImage( vlc_object_t *p_obj,
                                            int x, int y, int w, int h,
                                            const char *psz_uri )
{
    video_format_t fmt_out;
    video_format_Init( &fmt_out, VLC_CODEC_YUVA );
    fmt_out.i_width = fmt_out.i_visible_width = w;
    fmt_out.i_height = fmt_out.i_visible_height = h;

    subpicture_region_t *image =
            spuregion_CreateFromPicture( p_obj, &fmt_out, psz_uri );
    if( image )
    {
        image->i_x = x;
        image->i_y = y;
        image->i_align = SUBPICTURE_ALIGN_LEFT|SUBPICTURE_ALIGN_TOP;
    }
    return image;
}",225.0,243.0,1.0,1.0,19.0,18,5,21,11,1,1,2,2,0,1,,0,1,12,6,6,subpicture_region_t
2363,194183,vout_OSDRegionConstrain,1,vout_OSDRegionConstrain,"void vout_OSDRegionConstrain (subpicture_region_t*,int,int)",video_output\video_epg.c,"static void vout_OSDRegionConstrain(subpicture_region_t *p_region, int w, int h)
{
    if( p_region )
    {
        p_region->i_max_width = w;
        p_region->i_max_height = h;
    }
}",245.0,252.0,1.0,1.0,8.0,4,2,5,3,2,0,2,2,0,0,,0,0,6,3,3,void
2364,194203,vout_OSDTextRegion,1,vout_OSDTextRegion,"subpicture_region_t vout_OSDTextRegion (text_segment_t*,int,int)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDTextRegion(text_segment_t *p_segment,
                                                int x, int y )
{
    video_format_t fmt;
    subpicture_region_t *region;

    if (!p_segment)
        return NULL;

    /* Create a new subpicture region */
    video_format_Init(&fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    region = subpicture_region_New(&fmt);
    if (!region)
        return NULL;

    region->p_text   = p_segment;
    region->i_align  = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_text_align = SUBPICTURE_ALIGN_LEFT | SUBPICTURE_ALIGN_TOP;
    region->i_x      = x;
    region->i_y      = y;
    region->b_balanced_text = false;

    return region;
}",254.0,280.0,1.0,1.0,27.0,23,6,25,10,2,1,3,3,0,1,,0,1,6,3,3,subpicture_region_t
2365,194279,vout_OSDEpgText,1,vout_OSDEpgText,"subpicture_region_t vout_OSDEpgText (char*,int,int,int,uint32_t)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDEpgText(const char *text,
                                             int x, int y,
                                             int size, uint32_t color)
{
    return vout_OSDTextRegion(vout_OSDSegment(text, size, color), x, y);
}",282.0,287.0,1.0,1.0,6.0,0,0,5,5,2,2,1,1,0,2,,0,1,10,5,5,subpicture_region_t
2366,194296,vout_OSDPrintTime,1,vout_OSDPrintTime,char* vout_OSDPrintTime (time_t),video_output\video_epg.c,"static char * vout_OSDPrintTime(time_t t)
{
    char *psz;
    struct tm tms;
    localtime_r(&t, &tms);
    if(asprintf(&psz, ""%2.2d:%2.2d"", tms.tm_hour, tms.tm_min) < 0)
       psz = NULL;
    return psz;
}",289.0,297.0,1.0,1.0,9.0,7,4,8,4,3,0,2,2,0,0,,0,0,2,1,1,char*
2367,194327,vout_OSDEpgEvent,1,vout_OSDEpgEvent,"subpicture_region_t vout_OSDEpgEvent (vlc_epg_event_t*,int,int,int)",video_output\video_epg.c,"static subpicture_region_t * vout_OSDEpgEvent(const vlc_epg_event_t *p_evt,
                                              int x, int y, int size)
{
    text_segment_t *p_segment = NULL;
    char *psz_start = vout_OSDPrintTime(p_evt->i_start);
    char *psz_end = vout_OSDPrintTime(p_evt->i_start + p_evt->i_duration);
    char *psz_text;
    if( -1 < asprintf(&psz_text, ""%s-%s "", psz_start, psz_end))
    {
        p_segment = vout_OSDSegment(psz_text, size, RGB_COLOR1);
        if( p_segment )
            p_segment->p_next = vout_OSDSegment(p_evt->psz_name, size, 0xffffff);
        vout_OSDSegmentSetNoWrap( p_segment );
    }
    free( psz_start );
    free( psz_end );
    if(!p_segment)
        return NULL;
    return vout_OSDTextRegion(p_segment, x, y);
}",299.0,318.0,1.0,52.0,20.0,15,7,25,9,2,6,4,5,0,6,,0,4,8,4,4,subpicture_region_t
2368,194407,vout_FillRightPanel,1,vout_FillRightPanel,"void vout_FillRightPanel (subpicture_updater_sys_t*,int,int,int,int,int,int,subpicture_region_t**)",video_output\video_epg.c,"static void vout_FillRightPanel(subpicture_updater_sys_t *p_sys,
                                int x, int y,
                                int width, int height,
                                int rx, int ry,
                                subpicture_region_t **last_ptr)
{
    float f_progress = 0;
    VLC_UNUSED(ry);

    /* Display the name of the channel. */
    *last_ptr = vout_OSDEpgText(p_sys->epg->psz_name,
                                x,
                                y,
                                height * EPGOSD_TEXTSIZE_NAME,
                                0x00ffffff);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    const vlc_epg_event_t *p_current = p_sys->epg->p_current;
    vlc_epg_event_t *p_next = NULL;
    if(!p_sys->epg->p_current && p_sys->epg->i_event)
        p_current = p_sys->epg->pp_event[0];

    for(size_t i=0; i<p_sys->epg->i_event; i++)
    {
        if( p_sys->epg->pp_event[i]->i_id != p_current->i_id )
        {
          ...",320.0,412.0,1.0,41.0,93.0,121,15,84,16,1,22,15,20,6,8,,0,20,16,8,8,void
2369,194765,vout_BuildOSDEpg,1,vout_BuildOSDEpg,"subpicture_region_t vout_BuildOSDEpg (subpicture_updater_sys_t*,int,int,int,int)",video_output\video_epg.c,"static subpicture_region_t * vout_BuildOSDEpg(subpicture_updater_sys_t *p_sys,
                                              int x, int y,
                                              int visible_width,
                                              int visible_height)
{
    subpicture_region_t *head;
    subpicture_region_t **last_ptr = &head;

    const int i_padding = visible_height * (OSDEPG_HEIGHT * OSDEPG_PADDING);

    *last_ptr = vout_OSDBackground(x + visible_width * OSDEPG_LEFT,
                                   y + visible_height * OSDEPG_TOP,
                                   visible_width  * OSDEPG_WIDTH,
                                   visible_height * OSDEPG_HEIGHT,
                                   ARGB_BGCOLOR);
    if(*last_ptr)
        last_ptr = &(*last_ptr)->p_next;

    struct
    {
        int x;
        int y;
        int w;
        int h;
        int rx;
        int ry;
    } panel = {
        x + visible_width  * OSDEPG_LEFT + i_padding,
        y + v...",414.0,498.0,1.0,44.0,85.0,109,12,74,11,1,7,5,7,1,4,,0,6,10,5,5,subpicture_region_t
2370,195105,OSDEpgUpdate,1,OSDEpgUpdate,"void OSDEpgUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",video_output\video_epg.c,"static void OSDEpgUpdate(subpicture_t *subpic,
                         const video_format_t *fmt_src,
                         const video_format_t *fmt_dst,
                         mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;

    subpic->p_region = vout_BuildOSDEpg(sys,
                                        fmt.i_x_offset,
                                        fmt.i_y_offset,
                                        fmt.i_visible_width,
                                        fmt.i_visible_height);
}",514.0,535.0,1.0,1.0,22.0,38,6,28,6,0,1,1,1,0,1,,0,1,8,4,4,void
2371,195207,OSDEpgDestroy,1,OSDEpgDestroy,void OSDEpgDestroy (subpicture_t*),video_output\video_epg.c,"static void OSDEpgDestroy(subpicture_t *subpic)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    if( sys->epg )
        vlc_epg_Delete(sys->epg);
    free( sys->art );
    free(sys);
}",537.0,544.0,1.0,1.0,8.0,6,3,6,2,0,4,2,2,1,1,,0,3,2,1,1,void
2372,195235,vout_OSDEpg,1,vout_OSDEpg,"int vout_OSDEpg (vout_thread_t*,input_item_t*)",video_output\video_epg.c,"int vout_OSDEpg(vout_thread_t *vout, input_item_t *input )
{
    vlc_epg_t *epg = NULL;
    int64_t epg_time;

    /* Look for the current program EPG event */
    vlc_mutex_lock(&input->lock);

    const vlc_epg_t *tmp = input->p_epg_table;
    if ( tmp )
    {
        /* Pick table designated event, or first/next one */
        const vlc_epg_event_t *p_current_event = tmp->p_current;
        epg = vlc_epg_New(tmp->i_id, tmp->i_source_id);
        if(epg)
        {
            if( p_current_event )
            {
                vlc_epg_event_t *p_event = vlc_epg_event_Duplicate(p_current_event);
                if(p_event)
                {
                    if(!vlc_epg_AddEvent(epg, p_event))
                        vlc_epg_event_Delete(p_event);
                    else
                        vlc_epg_SetCurrent(epg, p_event->i_start);
                }
            }

            /* Add next event if any */
            vlc_epg_event_t *p_next = NULL;
            for(size_t i=0;...",552.0,659.0,1.0,1.0,108.0,98,17,105,26,0,24,16,38,3,17,,0,17,4,2,2,int
2373,195626,VoutValidateFormat,1,VoutValidateFormat,"int VoutValidateFormat (video_format_t*,video_format_t*)",video_output\video_output.c,"static int VoutValidateFormat(video_format_t *dst,
                              const video_format_t *src)
{
    if (src->i_width == 0  || src->i_width  > 8192 ||
        src->i_height == 0 || src->i_height > 8192)
        return VLC_EGENERIC;
    if (src->i_sar_num <= 0 || src->i_sar_den <= 0)
        return VLC_EGENERIC;

    /* */
    video_format_Copy(dst, src);
    dst->i_chroma = vlc_fourcc_GetCodec(VIDEO_ES, src->i_chroma);
    vlc_ureduce( &dst->i_sar_num, &dst->i_sar_den,
                 src->i_sar_num,  src->i_sar_den, 50000 );
    if (dst->i_sar_num <= 0 || dst->i_sar_den <= 0) {
        dst->i_sar_num = 1;
        dst->i_sar_den = 1;
    }
    video_format_FixRgb(dst);
    return VLC_SUCCESS;
}",78.0,98.0,1.0,1.0,21.0,34,7,23,5,2,3,4,4,0,3,,0,1,4,2,2,int
2374,195729,VideoFormatCopyCropAr,1,VideoFormatCopyCropAr,"void VideoFormatCopyCropAr (video_format_t*,video_format_t*)",video_output\video_output.c,"static void VideoFormatCopyCropAr(video_format_t *dst,
                                  const video_format_t *src)
{
    video_format_CopyCrop(dst, src);
    dst->i_sar_num = src->i_sar_num;
    dst->i_sar_den = src->i_sar_den;
}",99.0,105.0,1.0,1.0,7.0,6,2,6,2,4,1,1,1,0,1,,0,0,4,2,2,void
2375,195806,VoutCreate,1,VoutCreate,"vout_thread_t VoutCreate (vlc_object_t*,vout_configuration_t*)",video_output\video_output.c,"static vout_thread_t *VoutCreate(vlc_object_t *object,
                                 const vout_configuration_t *cfg)
{
    video_format_t original;
    if (VoutValidateFormat(&original, cfg->fmt))
        return NULL;

    /* Allocate descriptor */
    vout_thread_t *vout = vlc_custom_create(object,
                                            sizeof(*vout) + sizeof(*vout->p),
                                            ""video output"");
    if (!vout) {
        video_format_Clean(&original);
        return NULL;
    }

    /* */
    vout->p = (vout_thread_sys_t*)&vout[1];

    vout->p->original = original;
    vout->p->dpb_size = cfg->dpb_size;

    vout_control_Init(&vout->p->control);
    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_INIT);

    vout_statistic_Init(&vout->p->statistic);

    vout_snapshot_Init(&vout->p->snapshot);

    /* Initialize locks */
    vlc_mutex_init(&vout->p->filter.lock);
    vlc_mutex_init(&vout->p->spu_lock);

    /* Take care of some ""int...",116.0,218.0,1.0,1.0,103.0,109,13,84,19,1,19,10,14,2,19,,0,5,4,2,2,vout_thread_t
2376,196163,vout_Request,1,vout_Request,"vout_thread_t vout_Request (vlc_object_t*,vout_configuration_t*)",video_output\video_output.c,"vout_thread_t *vout_Request(vlc_object_t *object,
                              const vout_configuration_t *cfg)
{
    vout_thread_t *vout = cfg->vout;
    if (cfg->change_fmt && !cfg->fmt) {
        if (vout)
            vout_CloseAndRelease(vout);
        return NULL;
    }

    /* If a vout is provided, try reusing it */
    if (vout) {
        if (vout->p->input != cfg->input) {
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, false);
            vout->p->input = cfg->input;
            if (vout->p->input)
                spu_Attach(vout->p->spu, vout->p->input, true);
        }

        if (cfg->change_fmt) {
            vout_control_cmd_t cmd;
            vout_control_cmd_Init(&cmd, VOUT_CONTROL_REINIT);
            cmd.u.cfg = cfg;

            vout_control_Push(&vout->p->control, &cmd);
            vout_control_WaitEmpty(&vout->p->control);
            vout_IntfReinit(vout);
        }

        if (!vout->p->dead) {
            msg_Dbg(...",221.0,260.0,1.0,1.0,40.0,41,7,36,8,1,8,9,17,0,7,,0,1,4,2,2,vout_thread_t
2377,196310,vout_Close,1,vout_Close,void vout_Close (vout_thread_t*),video_output\video_output.c,"void vout_Close(vout_thread_t *vout)
{
    assert(vout);

    if (vout->p->input)
        spu_Attach(vout->p->spu, vout->p->input, false);

    vout_snapshot_End(&vout->p->snapshot);

    vout_control_PushVoid(&vout->p->control, VOUT_CONTROL_CLEAN);
    vlc_join(vout->p->thread, NULL);

    if (vout->p->window != NULL)
        vout_display_window_Delete(vout->p->window);

    vlc_mutex_lock(&vout->p->spu_lock);
    spu_Destroy(vout->p->spu);
    vout->p->spu = NULL;
    vlc_mutex_unlock(&vout->p->spu_lock);
}",262.0,281.0,1.0,1.0,20.0,30,4,18,4,0,8,3,3,0,8,,0,0,2,1,1,void
2378,196461,vout_Cancel,1,vout_Cancel,"void vout_Cancel (vout_thread_t*,bool)",video_output\video_output.c,"void vout_Cancel(vout_thread_t *vout, bool canceled)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_CANCEL, canceled);
    vout_control_WaitEmpty(&vout->p->control);
}",308.0,312.0,1.0,1.0,5.0,6,2,4,3,3,2,1,1,0,2,,0,0,4,2,2,void
2379,196483,vout_ChangePause,1,vout_ChangePause,"void vout_ChangePause (vout_thread_t*,bool,mtime_t)",video_output\video_output.c,"void vout_ChangePause(vout_thread_t *vout, bool is_paused, mtime_t date)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_PAUSE);
    cmd.u.pause.is_on = is_paused;
    cmd.u.pause.date  = date;
    vout_control_Push(&vout->p->control, &cmd);

    vout_control_WaitEmpty(&vout->p->control);
}",314.0,323.0,1.0,1.0,10.0,16,4,9,5,1,5,1,1,0,3,,0,2,6,3,3,void
2380,196529,vout_GetResetStatistic,1,vout_GetResetStatistic,"void vout_GetResetStatistic (vout_thread_t*,unsigned*,unsigned*)",video_output\video_output.c,"void vout_GetResetStatistic(vout_thread_t *vout, unsigned *restrict displayed,
                            unsigned *restrict lost)
{
    vout_statistic_GetReset( &vout->p->statistic, displayed, lost );
}",325.0,329.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,void
2381,196545,vout_Flush,1,vout_Flush,"void vout_Flush (vout_thread_t*,mtime_t)",video_output\video_output.c,"void vout_Flush(vout_thread_t *vout, mtime_t date)
{
    vout_control_PushTime(&vout->p->control, VOUT_CONTROL_FLUSH, date);
    vout_control_WaitEmpty(&vout->p->control);
}",331.0,335.0,1.0,1.0,5.0,6,2,4,3,2,2,1,1,0,2,,0,0,4,2,2,void
2382,196567,vout_IsEmpty,1,vout_IsEmpty,bool vout_IsEmpty (vout_thread_t*),video_output\video_output.c,"bool vout_IsEmpty(vout_thread_t *vout)
{
    picture_t *picture = picture_fifo_Peek(vout->p->decoder_fifo);
    if (picture)
        picture_Release(picture);

    return !picture;
}",337.0,344.0,1.0,1.0,8.0,4,3,5,2,1,2,2,2,0,2,,0,1,2,1,1,bool
2383,196589,vout_NextPicture,1,vout_NextPicture,"void vout_NextPicture (vout_thread_t*,mtime_t*)",video_output\video_output.c,"void vout_NextPicture(vout_thread_t *vout, mtime_t *duration)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_STEP);
    cmd.u.time_ptr = duration;

    vout_control_Push(&vout->p->control, &cmd);
    vout_control_WaitEmpty(&vout->p->control);
}",346.0,354.0,1.0,1.0,9.0,11,4,7,4,1,4,1,1,0,3,,0,1,4,2,2,void
2384,196623,vout_DisplayTitle,1,vout_DisplayTitle,"void vout_DisplayTitle (vout_thread_t*,char*)",video_output\video_output.c,"void vout_DisplayTitle(vout_thread_t *vout, const char *title)
{
    assert(title);
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_OSD_TITLE, title);
}",356.0,360.0,1.0,1.0,5.0,3,2,4,3,1,1,1,1,0,1,,0,0,4,2,2,void
2385,196640,vout_WindowMouseEvent,1,vout_WindowMouseEvent,"void vout_WindowMouseEvent (vout_thread_t*,vout_window_mouse_event_t*)",video_output\video_output.c,"void vout_WindowMouseEvent(vout_thread_t *vout,
                           const vout_window_mouse_event_t *mouse)
{
    assert(mouse);
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_WINDOW_MOUSE);
    cmd.u.window_mouse = *mouse;

    vout_control_Push(&vout->p->control, &cmd);
}",362.0,371.0,1.0,1.0,10.0,9,5,7,4,1,3,1,1,0,2,,0,1,4,2,2,void
2386,196670,vout_PutSubpicture,1,vout_PutSubpicture,"void vout_PutSubpicture (vout_thread_t*,subpicture_t*)",video_output\video_output.c,"void vout_PutSubpicture( vout_thread_t *vout, subpicture_t *subpic )
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_SUBPICTURE);
    cmd.u.subpicture = subpic;

    vout_control_Push(&vout->p->control, &cmd);
}",373.0,380.0,1.0,1.0,8.0,8,4,6,4,5,3,1,1,0,2,,0,1,4,2,2,void
2387,196697,vout_RegisterSubpictureChannel,1,vout_RegisterSubpictureChannel,int vout_RegisterSubpictureChannel (vout_thread_t*),video_output\video_output.c,"int vout_RegisterSubpictureChannel( vout_thread_t *vout )
{
    int channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    vlc_mutex_lock(&vout->p->spu_lock);
    if (vout->p->spu)
        channel = spu_RegisterChannel(vout->p->spu);
    vlc_mutex_unlock(&vout->p->spu_lock);

    return channel;
}",381.0,391.0,1.0,1.0,11.0,12,3,8,3,1,3,2,2,0,3,,0,1,2,1,1,int
2388,196737,vout_FlushSubpictureChannel,1,vout_FlushSubpictureChannel,"void vout_FlushSubpictureChannel (vout_thread_t*,int)",video_output\video_output.c,"void vout_FlushSubpictureChannel( vout_thread_t *vout, int channel )
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_FLUSH_SUBPICTURE,
                             channel);
}",392.0,396.0,1.0,1.0,5.0,3,2,3,3,3,1,1,1,0,1,,0,0,4,2,2,void
2389,196752,vout_GetPicture,1,vout_GetPicture,picture_t vout_GetPicture (vout_thread_t*),video_output\video_output.c,"picture_t *vout_GetPicture(vout_thread_t *vout)
{
    picture_t *picture = picture_pool_Wait(vout->p->decoder_pool);
    if (likely(picture != NULL)) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &vout->p->original);
    }
    return picture;
}",407.0,415.0,1.0,1.0,9.0,9,4,8,3,1,3,2,2,0,3,,0,1,2,1,1,picture_t
2390,196787,vout_PutPicture,1,vout_PutPicture,"void vout_PutPicture (vout_thread_t*,picture_t*)",video_output\video_output.c,"void vout_PutPicture(vout_thread_t *vout, picture_t *picture)
{
    picture->p_next = NULL;
    if (picture_pool_OwnsPic(vout->p->decoder_pool, picture))
    {
        picture_fifo_Push(vout->p->decoder_fifo, picture);

        vout_control_Wake(&vout->p->control);
    }
    else
    {
        /* FIXME: HACK: Drop this picture because the vout changed. The old
         * picture pool need to be kept by the new vout. This requires a major
         * ""vout display"" API change. */
        picture_Release(picture);
    }
}",425.0,441.0,1.0,1.0,17.0,9,3,7,3,1,3,2,2,1,3,,0,1,4,2,2,void
2391,196825,vout_GetSnapshot,1,vout_GetSnapshot,"int vout_GetSnapshot (vout_thread_t*,block_t**,picture_t**,video_format_t*,char*,mtime_t)",video_output\video_output.c,"int vout_GetSnapshot(vout_thread_t *vout,
                     block_t **image_dst, picture_t **picture_dst,
                     video_format_t *fmt,
                     const char *type, mtime_t timeout)
{
    picture_t *picture = vout_snapshot_Get(&vout->p->snapshot, timeout);
    if (!picture) {
        msg_Err(vout, ""Failed to grab a snapshot"");
        return VLC_EGENERIC;
    }

    if (image_dst) {
        vlc_fourcc_t codec = VLC_CODEC_PNG;
        if (type && image_Type2Fourcc(type))
            codec = image_Type2Fourcc(type);

        const int override_width  = var_InheritInteger(vout, ""snapshot-width"");
        const int override_height = var_InheritInteger(vout, ""snapshot-height"");

        if (picture_Export(VLC_OBJECT(vout), image_dst, fmt,
                           picture, codec, override_width, override_height)) {
            msg_Err(vout, ""Failed to convert image for snapshot"");
            picture_Release(picture);
            return VLC_EGENERIC;
        }
 ...",444.0,475.0,1.0,1.0,32.0,12,6,31,13,1,5,6,8,2,5,,0,4,12,6,6,int
2392,196915,vout_ChangeAspectRatio,1,vout_ChangeAspectRatio,"void vout_ChangeAspectRatio (vout_thread_t*,unsigned int,unsigned int)",video_output\video_output.c,"void vout_ChangeAspectRatio( vout_thread_t *p_vout,
                             unsigned int i_num, unsigned int i_den )
{
    vout_ControlChangeSampleAspectRatio( p_vout, i_num, i_den );
}",477.0,481.0,1.0,1.0,5.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
2393,196926,vout_ControlChangeFullscreen,1,vout_ControlChangeFullscreen,"void vout_ControlChangeFullscreen (vout_thread_t*,bool)",video_output\video_output.c,"void vout_ControlChangeFullscreen(vout_thread_t *vout, bool fullscreen)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_FULLSCREEN,
                          fullscreen);
}",484.0,488.0,1.0,1.0,5.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
2394,196941,vout_ControlChangeWindowState,1,vout_ControlChangeWindowState,"void vout_ControlChangeWindowState (vout_thread_t*,unsigned)",video_output\video_output.c,"void vout_ControlChangeWindowState(vout_thread_t *vout, unsigned st)
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_WINDOW_STATE, st);
}",489.0,492.0,1.0,1.0,4.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
2395,196956,vout_ControlChangeDisplayFilled,1,vout_ControlChangeDisplayFilled,"void vout_ControlChangeDisplayFilled (vout_thread_t*,bool)",video_output\video_output.c,"void vout_ControlChangeDisplayFilled(vout_thread_t *vout, bool is_filled)
{
    vout_control_PushBool(&vout->p->control, VOUT_CONTROL_DISPLAY_FILLED,
                          is_filled);
}",493.0,497.0,1.0,1.0,5.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
2396,196971,vout_ControlChangeZoom,1,vout_ControlChangeZoom,"void vout_ControlChangeZoom (vout_thread_t*,int,int)",video_output\video_output.c,"void vout_ControlChangeZoom(vout_thread_t *vout, int num, int den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ZOOM,
                          num, den);
}",498.0,502.0,1.0,1.0,5.0,3,2,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
2397,196988,vout_ControlChangeSampleAspectRatio,1,vout_ControlChangeSampleAspectRatio,"void vout_ControlChangeSampleAspectRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"void vout_ControlChangeSampleAspectRatio(vout_thread_t *vout,
                                         unsigned num, unsigned den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_ASPECT_RATIO,
                          num, den);
}",503.0,508.0,1.0,1.0,6.0,3,2,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
2398,197005,vout_ControlChangeCropRatio,1,vout_ControlChangeCropRatio,"void vout_ControlChangeCropRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"void vout_ControlChangeCropRatio(vout_thread_t *vout,
                                 unsigned num, unsigned den)
{
    vout_control_PushPair(&vout->p->control, VOUT_CONTROL_CROP_RATIO,
                          num, den);
}",509.0,514.0,1.0,1.0,6.0,3,2,4,4,0,1,1,1,0,1,,0,0,6,3,3,void
2399,197022,vout_ControlChangeCropWindow,1,vout_ControlChangeCropWindow,"void vout_ControlChangeCropWindow (vout_thread_t*,int,int,int,int)",video_output\video_output.c,"void vout_ControlChangeCropWindow(vout_thread_t *vout,
                                  int x, int y, int width, int height)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_WINDOW);
    cmd.u.window.x      = __MAX(x, 0);
    cmd.u.window.y      = __MAX(y, 0);
    cmd.u.window.width  = __MAX(width, 0);
    cmd.u.window.height = __MAX(height, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",515.0,526.0,1.0,1.0,12.0,21,4,12,7,0,6,1,1,0,2,,0,4,10,5,5,void
2400,197089,vout_ControlChangeCropBorder,1,vout_ControlChangeCropBorder,"void vout_ControlChangeCropBorder (vout_thread_t*,int,int,int,int)",video_output\video_output.c,"void vout_ControlChangeCropBorder(vout_thread_t *vout,
                                  int left, int top, int right, int bottom)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_CROP_BORDER);
    cmd.u.border.left   = __MAX(left, 0);
    cmd.u.border.top    = __MAX(top, 0);
    cmd.u.border.right  = __MAX(right, 0);
    cmd.u.border.bottom = __MAX(bottom, 0);

    vout_control_Push(&vout->p->control, &cmd);
}",527.0,538.0,1.0,1.0,12.0,21,4,12,7,0,6,1,1,0,2,,0,4,10,5,5,void
2401,197156,vout_ControlChangeFilters,1,vout_ControlChangeFilters,"void vout_ControlChangeFilters (vout_thread_t*,char*)",video_output\video_output.c,"void vout_ControlChangeFilters(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_FILTERS,
                            filters);
}",539.0,543.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,4,2,2,void
2402,197171,vout_ControlChangeSubSources,1,vout_ControlChangeSubSources,"void vout_ControlChangeSubSources (vout_thread_t*,char*)",video_output\video_output.c,"void vout_ControlChangeSubSources(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_SOURCES,
                            filters);
}",544.0,548.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,4,2,2,void
2403,197186,vout_ControlChangeSubFilters,1,vout_ControlChangeSubFilters,"void vout_ControlChangeSubFilters (vout_thread_t*,char*)",video_output\video_output.c,"void vout_ControlChangeSubFilters(vout_thread_t *vout, const char *filters)
{
    vout_control_PushString(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_FILTERS,
                            filters);
}",549.0,553.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,4,2,2,void
2404,197201,vout_ControlChangeSubMargin,1,vout_ControlChangeSubMargin,"void vout_ControlChangeSubMargin (vout_thread_t*,int)",video_output\video_output.c,"void vout_ControlChangeSubMargin(vout_thread_t *vout, int margin)
{
    vout_control_PushInteger(&vout->p->control, VOUT_CONTROL_CHANGE_SUB_MARGIN,
                             margin);
}",554.0,558.0,1.0,1.0,5.0,3,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
2405,197216,vout_ControlChangeViewpoint,1,vout_ControlChangeViewpoint,"void vout_ControlChangeViewpoint (vout_thread_t*,vlc_viewpoint_t*)",video_output\video_output.c,"void vout_ControlChangeViewpoint(vout_thread_t *vout,
                                 const vlc_viewpoint_t *p_viewpoint)
{
    vout_control_cmd_t cmd;
    vout_control_cmd_Init(&cmd, VOUT_CONTROL_VIEWPOINT);
    cmd.u.viewpoint = *p_viewpoint;
    vout_control_Push(&vout->p->control, &cmd);
}",560.0,567.0,1.0,1.0,8.0,9,5,6,4,0,3,1,1,0,2,,0,1,4,2,2,void
2406,197244,VoutGetDisplayCfg,1,VoutGetDisplayCfg,"void VoutGetDisplayCfg (vout_thread_t*,vout_display_cfg_t*,char*)",video_output\video_output.c,"static void VoutGetDisplayCfg(vout_thread_t *vout, vout_display_cfg_t *cfg, const char *title)
{
    /* Load configuration */
#if defined(_WIN32) || defined(__OS2__)
    cfg->is_fullscreen = var_GetBool(vout, ""fullscreen"")
                         || var_GetBool(vout, ""video-wallpaper"");
#endif
    cfg->viewpoint = vout->p->original.pose;

    cfg->display.title = title;
    const int display_width = var_GetInteger(vout, ""width"");
    const int display_height = var_GetInteger(vout, ""height"");
    cfg->display.width   = display_width > 0  ? display_width  : 0;
    cfg->display.height  = display_height > 0 ? display_height : 0;
    cfg->is_display_filled  = var_GetBool(vout, ""autoscale"");
    unsigned msar_num, msar_den;
    if (var_InheritURational(vout, &msar_num, &msar_den, ""monitor-par"") ||
        msar_num <= 0 || msar_den <= 0) {
        msar_num = 1;
        msar_den = 1;
    }
    cfg->display.sar.num = msar_num;
    cfg->display.sar.den = msar_den;
    unsigned zoom_den = 100...",570.0,609.0,1.0,1.0,40.0,64,10,51,13,1,1,4,4,0,1,,0,0,6,3,3,void
2407,197615,FilterRestartCallback,1,FilterRestartCallback,"int FilterRestartCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\video_output.c,"static int FilterRestartCallback(vlc_object_t *p_this, char const *psz_var,
                                 vlc_value_t oldval, vlc_value_t newval,
                                 void *p_data)
{
    (void) p_this; (void) psz_var; (void) oldval; (void) newval;
    vout_ControlChangeFilters((vout_thread_t *)p_data, NULL);
    return 0;
}",658.0,665.0,1.0,1.0,8.0,5,1,6,6,0,1,1,1,0,1,,0,0,10,5,5,int
2408,197643,ThreadDelFilterCallbacks,1,ThreadDelFilterCallbacks,"int ThreadDelFilterCallbacks (filter_t*,void*)",video_output\video_output.c,"static int ThreadDelFilterCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             FilterRestartCallback);
    return VLC_SUCCESS;
}",667.0,672.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
2409,197657,ThreadDelAllFilterCallbacks,1,ThreadDelAllFilterCallbacks,void ThreadDelAllFilterCallbacks (vout_thread_t*),video_output\video_output.c,"static void ThreadDelAllFilterCallbacks(vout_thread_t *vout)
{
    assert(vout->p->filter.chain_interactive != NULL);
    filter_chain_ForEach(vout->p->filter.chain_interactive,
                         ThreadDelFilterCallbacks, vout);
}",674.0,679.0,1.0,1.0,6.0,7,3,4,2,4,1,1,1,0,1,,0,0,2,1,1,void
2410,197682,VoutVideoFilterInteractiveNewPicture,1,VoutVideoFilterInteractiveNewPicture,picture_t VoutVideoFilterInteractiveNewPicture (filter_t*),video_output\video_output.c,"static picture_t *VoutVideoFilterInteractiveNewPicture(filter_t *filter)
{
    vout_thread_t *vout = filter->owner.sys;

    picture_t *picture = picture_pool_Get(vout->p->private_pool);
    if (picture) {
        picture_Reset(picture);
        VideoFormatCopyCropAr(&picture->format, &filter->fmt_out.video);
    }
    return picture;
}",681.0,691.0,1.0,1.0,11.0,11,4,9,3,1,3,2,2,0,3,,0,1,2,1,1,picture_t
2411,197722,VoutVideoFilterStaticNewPicture,1,VoutVideoFilterStaticNewPicture,picture_t VoutVideoFilterStaticNewPicture (filter_t*),video_output\video_output.c,"static picture_t *VoutVideoFilterStaticNewPicture(filter_t *filter)
{
    vout_thread_t *vout = filter->owner.sys;

    vlc_assert_locked(&vout->p->filter.lock);
    if (filter_chain_IsEmpty(vout->p->filter.chain_interactive))
        return VoutVideoFilterInteractiveNewPicture(filter);

    return picture_NewFromFormat(&filter->fmt_out.video);
}",693.0,702.0,1.0,1.0,10.0,13,4,6,2,0,3,2,2,1,3,,0,1,2,1,1,picture_t
2412,197765,ThreadFilterFlush,1,ThreadFilterFlush,"void ThreadFilterFlush (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadFilterFlush(vout_thread_t *vout, bool is_locked)
{
    if (vout->p->displayed.current)
        picture_Release( vout->p->displayed.current );
    vout->p->displayed.current = NULL;

    if (vout->p->displayed.next)
        picture_Release( vout->p->displayed.next );
    vout->p->displayed.next = NULL;

    if (!is_locked)
        vlc_mutex_lock(&vout->p->filter.lock);
    filter_chain_VideoFlush(vout->p->filter.chain_static);
    filter_chain_VideoFlush(vout->p->filter.chain_interactive);
    if (!is_locked)
        vlc_mutex_unlock(&vout->p->filter.lock);
}",704.0,720.0,1.0,1.0,17.0,36,5,14,3,3,6,5,5,0,6,,0,0,4,2,2,void
2413,197869,ThreadChangeFilters,1,ThreadChangeFilters,"void ThreadChangeFilters (vout_thread_t*,video_format_t*,char*,int,bool)",video_output\video_output.c,"static void ThreadChangeFilters(vout_thread_t *vout,
                                const video_format_t *source,
                                const char *filters,
                                int deinterlace,
                                bool is_locked)
{
    ThreadFilterFlush(vout, is_locked);
    ThreadDelAllFilterCallbacks(vout);

    vlc_array_t array_static;
    vlc_array_t array_interactive;

    vlc_array_init(&array_static);
    vlc_array_init(&array_interactive);

    if ((vout->p->filter.has_deint =
         deinterlace == 1 || (deinterlace == -1 && vout->p->filter.has_deint)))
    {
        vout_filter_t *e = malloc(sizeof(*e));

        if (likely(e))
        {
            free(config_ChainCreate(&e->name, &e->cfg, ""deinterlace""));
            vlc_array_append_or_abort(&array_static, e);
        }
    }

    char *current = filters ? strdup(filters) : NULL;
    while (current) {
        config_chain_t *cfg;
        char *name;
        char *next = config_Chain...",727.0,844.0,1.0,1.0,118.0,126,14,113,20,2,28,16,27,3,17,,0,16,10,5,5,void
2414,198319,ThreadDisplayPreparePicture,1,ThreadDisplayPreparePicture,"int ThreadDisplayPreparePicture (vout_thread_t*,bool,bool)",video_output\video_output.c,"static int ThreadDisplayPreparePicture(vout_thread_t *vout, bool reuse, bool frame_by_frame)
{
    bool is_late_dropped = vout->p->is_late_dropped && !vout->p->pause.is_on && !frame_by_frame;

    vlc_mutex_lock(&vout->p->filter.lock);

    picture_t *picture = filter_chain_VideoFilter(vout->p->filter.chain_static, NULL);
    assert(!reuse || !picture);

    while (!picture) {
        picture_t *decoded;
        if (reuse && vout->p->displayed.decoded) {
            decoded = picture_Hold(vout->p->displayed.decoded);
        } else {
            decoded = picture_fifo_Pop(vout->p->decoder_fifo);
            if (decoded) {
                if (is_late_dropped && !decoded->b_force) {
                    mtime_t late_threshold;
                    if (decoded->format.i_frame_rate && decoded->format.i_frame_rate_base)
                        late_threshold = ((CLOCK_FREQ/2) * decoded->format.i_frame_rate_base) / decoded->format.i_frame_rate;
                    else
                     ...",848.0,911.0,1.0,41.0,64.0,74,7,37,10,2,7,8,10,0,7,,0,4,6,3,3,int
2415,198655,ConvertRGB32AndBlendBufferNew,1,ConvertRGB32AndBlendBufferNew,picture_t ConvertRGB32AndBlendBufferNew (filter_t*),video_output\video_output.c,"static picture_t *ConvertRGB32AndBlendBufferNew(filter_t *filter)
{
    return picture_NewFromFormat(&filter->fmt_out.video);
}",913.0,916.0,1.0,1.0,4.0,3,3,1,1,0,1,1,1,0,1,,0,0,2,1,1,picture_t
2416,198668,ConvertRGB32AndBlend,1,ConvertRGB32AndBlend,"picture_t ConvertRGB32AndBlend (vout_thread_t*,picture_t*,subpicture_t*)",video_output\video_output.c,"static picture_t *ConvertRGB32AndBlend(vout_thread_t *vout, picture_t *pic,
                                     subpicture_t *subpic)
{
    /* This function will convert the pic to RGB32 and blend the subpic to it.
     * The returned pic can't be used to display since the chroma will be
     * different than the ""vout display"" one, but it can be used for snapshots.
     * */

    assert(vout->p->spu_blend);

    filter_owner_t owner = {
        .video = {
            .buffer_new = ConvertRGB32AndBlendBufferNew,
        },
    };
    filter_chain_t *filterc = filter_chain_NewVideo(vout, false, &owner);
    if (!filterc)
        return NULL;

    es_format_t src = vout->p->spu_blend->fmt_out;
    es_format_t dst = src;
    dst.video.i_chroma = VLC_CODEC_RGB32;
    video_format_FixRgb(&dst.video);

    if (filter_chain_AppendConverter(filterc, &src, &dst) != 0)
    {
        filter_chain_Delete(filterc);
        return NULL;
    }

    picture_Hold(pic);
    pic = filter_chain_VideoF...",918.0,965.0,1.0,1.0,48.0,29,8,41,14,0,11,6,9,1,11,,0,5,6,3,3,picture_t
2417,198792,ThreadDisplayRenderPicture,1,ThreadDisplayRenderPicture,"int ThreadDisplayRenderPicture (vout_thread_t*,bool)",video_output\video_output.c,"static int ThreadDisplayRenderPicture(vout_thread_t *vout, bool is_forced)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = vout->p->display.vd;

    picture_t *torender = picture_Hold(vout->p->displayed.current);

    vout_chrono_Start(&vout->p->render);

    vlc_mutex_lock(&vout->p->filter.lock);
    picture_t *filtered = filter_chain_VideoFilter(vout->p->filter.chain_interactive, torender);
    vlc_mutex_unlock(&vout->p->filter.lock);

    if (!filtered)
        return VLC_EGENERIC;

    if (filtered->date != vout->p->displayed.current->date)
        msg_Warn(vout, ""Unsupported timestamp modifications done by chain_interactive"");

    /*
     * Get the subpicture to be displayed
     */
    const bool do_snapshot = vout_snapshot_IsRequested(&vout->p->snapshot);
    mtime_t render_subtitle_date;
    if (vout->p->pause.is_on)
        render_subtitle_date = vout->p->pause.date;
    else
        render_subtitle_date = filtered->date > 1 ? filtered->date : mdate();
   ...",967.0,1183.0,1.0,1.0,217.0,195,13,153,26,1,32,20,33,1,32,,0,10,4,2,2,int
2418,199576,ThreadDisplayPicture,1,ThreadDisplayPicture,"int ThreadDisplayPicture (vout_thread_t*,mtime_t*)",video_output\video_output.c,"static int ThreadDisplayPicture(vout_thread_t *vout, mtime_t *deadline)
{
    bool frame_by_frame = !deadline;
    bool paused = vout->p->pause.is_on;
    bool first = !vout->p->displayed.current;

    if (first)
        if (ThreadDisplayPreparePicture(vout, true, frame_by_frame)) /* FIXME not sure it is ok */
            return VLC_EGENERIC;

    if (!paused || frame_by_frame)
        while (!vout->p->displayed.next && !ThreadDisplayPreparePicture(vout, false, frame_by_frame))
            ;

    const mtime_t date = mdate();
    const mtime_t render_delay = vout_chrono_GetHigh(&vout->p->render) + VOUT_MWAIT_TOLERANCE;

    bool drop_next_frame = frame_by_frame;
    mtime_t date_next = VLC_TS_INVALID;
    if (!paused && vout->p->displayed.next) {
        date_next = vout->p->displayed.next->date - render_delay;
        if (date_next /* + 0 FIXME */ <= date)
            drop_next_frame = true;
    }

    /* FIXME/XXX we must redisplay the last decoded picture (because
     * of poten...",1185.0,1252.0,1.0,73.0,68.0,99,15,81,19,1,6,14,19,2,6,,0,5,4,2,2,int
2419,199860,ThreadDisplaySubpicture,1,ThreadDisplaySubpicture,"void ThreadDisplaySubpicture (vout_thread_t*,subpicture_t*)",video_output\video_output.c,"static void ThreadDisplaySubpicture(vout_thread_t *vout,
                                    subpicture_t *subpicture)
{
    spu_PutSubpicture(vout->p->spu, subpicture);
}",1254.0,1258.0,1.0,1.0,5.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2420,199873,ThreadFlushSubpicture,1,ThreadFlushSubpicture,"void ThreadFlushSubpicture (vout_thread_t*,int)",video_output\video_output.c,"static void ThreadFlushSubpicture(vout_thread_t *vout, int channel)
{
    spu_ClearChannel(vout->p->spu, channel);
}",1260.0,1263.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2421,199886,ThreadDisplayOsdTitle,1,ThreadDisplayOsdTitle,"void ThreadDisplayOsdTitle (vout_thread_t*,char*)",video_output\video_output.c,"static void ThreadDisplayOsdTitle(vout_thread_t *vout, const char *string)
{
    if (!vout->p->title.show)
        return;

    vout_OSDText(vout, VOUT_SPU_CHANNEL_OSD,
                 vout->p->title.position, INT64_C(1000) * vout->p->title.timeout,
                 string);
}",1265.0,1273.0,1.0,1.0,9.0,11,4,6,3,1,1,2,2,0,1,,0,0,4,2,2,void
2422,199924,ThreadChangeSubSources,1,ThreadChangeSubSources,"void ThreadChangeSubSources (vout_thread_t*,char*)",video_output\video_output.c,"static void ThreadChangeSubSources(vout_thread_t *vout, const char *filters)
{
    spu_ChangeSources(vout->p->spu, filters);
}",1275.0,1278.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2423,199937,ThreadChangeSubFilters,1,ThreadChangeSubFilters,"void ThreadChangeSubFilters (vout_thread_t*,char*)",video_output\video_output.c,"static void ThreadChangeSubFilters(vout_thread_t *vout, const char *filters)
{
    spu_ChangeFilters(vout->p->spu, filters);
}",1280.0,1283.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2424,199950,ThreadChangeSubMargin,1,ThreadChangeSubMargin,"void ThreadChangeSubMargin (vout_thread_t*,int)",video_output\video_output.c,"static void ThreadChangeSubMargin(vout_thread_t *vout, int margin)
{
    spu_ChangeMargin(vout->p->spu, margin);
}",1285.0,1288.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2425,199963,ThreadChangePause,1,ThreadChangePause,"void ThreadChangePause (vout_thread_t*,bool,mtime_t)",video_output\video_output.c,"static void ThreadChangePause(vout_thread_t *vout, bool is_paused, mtime_t date)
{
    assert(!vout->p->pause.is_on || !is_paused);

    if (vout->p->pause.is_on) {
        const mtime_t duration = date - vout->p->pause.date;

        if (vout->p->step.timestamp > VLC_TS_INVALID)
            vout->p->step.timestamp += duration;
        if (vout->p->step.last > VLC_TS_INVALID)
            vout->p->step.last += duration;
        picture_fifo_OffsetDate(vout->p->decoder_fifo, duration);
        if (vout->p->displayed.decoded)
            vout->p->displayed.decoded->date += duration;
        spu_OffsetSubtitleDate(vout->p->spu, duration);

        ThreadFilterFlush(vout, false);
    } else {
        vout->p->step.timestamp = VLC_TS_INVALID;
        vout->p->step.last      = VLC_TS_INVALID;
    }
    vout->p->pause.is_on = is_paused;
    vout->p->pause.date  = date;

    vout_window_t *window = vout->p->window;
    if (window != NULL)
        vout_window_SetInhibition(window, !is_paused);
}",1290.0,1317.0,1.0,1.0,28.0,55,9,33,8,1,4,6,9,0,4,,0,0,6,3,3,void
2426,200135,ThreadFlush,1,ThreadFlush,"void ThreadFlush (vout_thread_t*,bool,mtime_t)",video_output\video_output.c,"static void ThreadFlush(vout_thread_t *vout, bool below, mtime_t date)
{
    vout->p->step.timestamp = VLC_TS_INVALID;
    vout->p->step.last      = VLC_TS_INVALID;

    ThreadFilterFlush(vout, false); /* FIXME too much */

    picture_t *last = vout->p->displayed.decoded;
    if (last) {
        if (( below && last->date <= date) ||
            (!below && last->date >= date)) {
            picture_Release(last);

            vout->p->displayed.decoded   = NULL;
            vout->p->displayed.date      = VLC_TS_INVALID;
            vout->p->displayed.timestamp = VLC_TS_INVALID;
        }
    }

    picture_fifo_Flush(vout->p->decoder_fifo, date, below);
    vout_FilterFlush(vout->p->display.vd);
}",1319.0,1340.0,1.0,1.0,22.0,37,8,26,7,2,4,3,4,0,4,,0,0,6,3,3,void
2427,200239,ThreadStep,1,ThreadStep,"void ThreadStep (vout_thread_t*,mtime_t*)",video_output\video_output.c,"static void ThreadStep(vout_thread_t *vout, mtime_t *duration)
{
    *duration = 0;

    if (vout->p->step.last <= VLC_TS_INVALID)
        vout->p->step.last = vout->p->displayed.timestamp;

    if (ThreadDisplayPicture(vout, NULL))
        return;

    vout->p->step.timestamp = vout->p->displayed.timestamp;

    if (vout->p->step.last > VLC_TS_INVALID &&
        vout->p->step.timestamp > vout->p->step.last) {
        *duration = vout->p->step.timestamp - vout->p->step.last;
        vout->p->step.last = vout->p->step.timestamp;
        /* TODO advance subpicture by the duration ... */
    }
}",1342.0,1360.0,1.0,1.0,19.0,48,8,18,4,1,1,4,4,1,1,,0,1,4,2,2,void
2428,200356,ThreadChangeFullscreen,1,ThreadChangeFullscreen,"void ThreadChangeFullscreen (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadChangeFullscreen(vout_thread_t *vout, bool fullscreen)
{
    vout_window_t *window = vout->p->window;

#if !defined(_WIN32) && !defined(__OS2__)
    if (window != NULL)
        vout_window_SetFullScreen(window, fullscreen);
#else
    bool window_fullscreen = false;
    if (window != NULL
     && vout_window_SetFullScreen(window, fullscreen) == VLC_SUCCESS)
        window_fullscreen = true;
    /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendEventFullscreen(vout->p->display.vd, fullscreen, window_fullscreen);
#endif
}",1362.0,1378.0,1.0,1.0,17.0,4,3,6,4,1,0,2,2,0,0,,0,0,4,2,2,void
2429,200378,ThreadChangeWindowState,1,ThreadChangeWindowState,"void ThreadChangeWindowState (vout_thread_t*,unsigned)",video_output\video_output.c,"static void ThreadChangeWindowState(vout_thread_t *vout, unsigned state)
{
    vout_window_t *window = vout->p->window;

    if (window != NULL)
        vout_window_SetState(window, state);
#if defined(_WIN32) || defined(__OS2__)
    else /* FIXME: remove this event */
    if (vout->p->display.vd != NULL)
        vout_display_SendWindowState(vout->p->display.vd, state);
#endif
}",1380.0,1391.0,1.0,1.0,12.0,4,3,6,4,1,0,2,2,0,0,,0,0,4,2,2,void
2430,200400,ThreadChangeWindowMouse,1,ThreadChangeWindowMouse,"void ThreadChangeWindowMouse (vout_thread_t*,vout_window_mouse_event_t*)",video_output\video_output.c,"static void ThreadChangeWindowMouse(vout_thread_t *vout,
                                    const vout_window_mouse_event_t *mouse)
{
    vout_display_t *vd = vout->p->display.vd;
    switch (mouse->type)
    {
        case VOUT_WINDOW_MOUSE_STATE:
        case VOUT_WINDOW_MOUSE_MOVED:
        {
            vout_display_place_t place;
            vout_display_PlacePicture(&place, &vd->source, vd->cfg, false);

            if (place.width <= 0 || place.height <= 0)
                return;

            const int x = vd->source.i_x_offset +
                (int64_t)(mouse->x - place.x) *
                vd->source.i_visible_width / place.width;
            const int y = vd->source.i_y_offset +
                (int64_t)(mouse->y - place.y) *
                vd->source.i_visible_height/ place.height;

            if (mouse->type == VOUT_WINDOW_MOUSE_STATE)
                vout_display_SendEventMouseState(vd, x, y, mouse->button_mask);
            else
                vout_display_SendEv...",1393.0,1434.0,1.0,1.0,42.0,45,11,38,12,1,1,10,8,0,1,,0,0,4,2,2,void
2431,200558,ThreadChangeDisplayFilled,1,ThreadChangeDisplayFilled,"void ThreadChangeDisplayFilled (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadChangeDisplayFilled(vout_thread_t *vout, bool is_filled)
{
    vout_SetDisplayFilled(vout->p->display.vd, is_filled);
}",1436.0,1439.0,1.0,1.0,4.0,3,2,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2432,200573,ThreadChangeZoom,1,ThreadChangeZoom,"void ThreadChangeZoom (vout_thread_t*,int,int)",video_output\video_output.c,"static void ThreadChangeZoom(vout_thread_t *vout, int num, int den)
{
    if (num * 10 < den) {
        num = den;
        den *= 10;
    } else if (num > den * 10) {
        num = den * 10;
    }

    vout_SetDisplayZoom(vout->p->display.vd, num, den);
}",1441.0,1451.0,1.0,1.0,11.0,7,6,8,3,1,1,2,2,0,1,,0,0,6,3,3,void
2433,200617,ThreadChangeAspectRatio,1,ThreadChangeAspectRatio,"void ThreadChangeAspectRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"static void ThreadChangeAspectRatio(vout_thread_t *vout,
                                    unsigned num, unsigned den)
{
    vout_SetDisplayAspect(vout->p->display.vd, num, den);
}",1453.0,1457.0,1.0,1.0,5.0,3,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,void
2434,200634,ThreadExecuteCropWindow,1,ThreadExecuteCropWindow,"void ThreadExecuteCropWindow (vout_thread_t*,unsigned,unsigned,unsigned,unsigned)",video_output\video_output.c,"static void ThreadExecuteCropWindow(vout_thread_t *vout,
                                    unsigned x, unsigned y,
                                    unsigned width, unsigned height)
{
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        x, y, width, height);
}",1460.0,1466.0,1.0,1.0,7.0,3,2,5,5,1,1,1,1,0,1,,0,0,10,5,5,void
2435,200657,ThreadExecuteCropBorder,1,ThreadExecuteCropBorder,"void ThreadExecuteCropBorder (vout_thread_t*,unsigned,unsigned,unsigned,unsigned)",video_output\video_output.c,"static void ThreadExecuteCropBorder(vout_thread_t *vout,
                                    unsigned left, unsigned top,
                                    unsigned right, unsigned bottom)
{
    msg_Dbg(vout, ""ThreadExecuteCropBorder %d.%d %dx%d"", left, top, right, bottom);
    vout_SetDisplayCrop(vout->p->display.vd, 0, 0,
                        left, top, -(int)right, -(int)bottom);
}",1467.0,1474.0,1.0,1.0,8.0,7,4,10,5,1,1,1,1,0,1,,0,0,10,5,5,void
2436,200693,ThreadExecuteCropRatio,1,ThreadExecuteCropRatio,"void ThreadExecuteCropRatio (vout_thread_t*,unsigned,unsigned)",video_output\video_output.c,"static void ThreadExecuteCropRatio(vout_thread_t *vout,
                                   unsigned num, unsigned den)
{
    vout_SetDisplayCrop(vout->p->display.vd, num, den,
                        0, 0, 0, 0);
}",1476.0,1481.0,1.0,1.0,6.0,3,2,3,3,1,1,1,1,0,1,,0,0,6,3,3,void
2437,200714,ThreadExecuteViewpoint,1,ThreadExecuteViewpoint,"void ThreadExecuteViewpoint (vout_thread_t*,vlc_viewpoint_t*)",video_output\video_output.c,"static void ThreadExecuteViewpoint(vout_thread_t *vout,
                                   const vlc_viewpoint_t *p_viewpoint)
{
    vout_SetDisplayViewpoint(vout->p->display.vd, p_viewpoint);
}",1483.0,1487.0,1.0,1.0,5.0,3,2,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2438,200729,ThreadStart,1,ThreadStart,"int ThreadStart (vout_thread_t*,vout_display_state_t*)",video_output\video_output.c,"static int ThreadStart(vout_thread_t *vout, vout_display_state_t *state)
{
    vlc_mouse_Init(&vout->p->mouse);
    vout->p->decoder_fifo = picture_fifo_New();
    vout->p->decoder_pool = NULL;
    vout->p->display_pool = NULL;
    vout->p->private_pool = NULL;

    vout->p->filter.configuration = NULL;
    video_format_Copy(&vout->p->filter.format, &vout->p->original);

    filter_owner_t owner = {
        .sys = vout,
        .video = {
            .buffer_new = VoutVideoFilterStaticNewPicture,
        },
    };
    vout->p->filter.chain_static =
        filter_chain_NewVideo( vout, true, &owner );

    owner.video.buffer_new = VoutVideoFilterInteractiveNewPicture;
    vout->p->filter.chain_interactive =
        filter_chain_NewVideo( vout, true, &owner );

    vout_display_state_t state_default;
    if (!state) {
        VoutGetDisplayCfg(vout, &state_default.cfg, vout->p->display.title);

#if defined(_WIN32) || defined(__OS2__)
        bool below = var_InheritBool(vout, ""video-w...",1489.0,1567.0,1.0,1.0,79.0,130,8,76,13,2,12,9,7,2,12,,0,5,4,2,2,int
2439,201075,ThreadStop,1,ThreadStop,"void ThreadStop (vout_thread_t*,vout_display_state_t*)",video_output\video_output.c,"static void ThreadStop(vout_thread_t *vout, vout_display_state_t *state)
{
    if (vout->p->spu_blend)
        filter_DeleteBlend(vout->p->spu_blend);

    /* Destroy translation tables */
    if (vout->p->display.vd) {
        if (vout->p->decoder_pool) {
            ThreadFlush(vout, true, INT64_MAX);
            vout_EndWrapper(vout);
        }
        vout_CloseWrapper(vout, state);
    }

    /* Destroy the video filters */
    ThreadDelAllFilterCallbacks(vout);
    filter_chain_Delete(vout->p->filter.chain_interactive);
    filter_chain_Delete(vout->p->filter.chain_static);
    video_format_Clean(&vout->p->filter.format);
    free(vout->p->filter.configuration);

    if (vout->p->decoder_fifo)
        picture_fifo_Delete(vout->p->decoder_fifo);
    assert(!vout->p->decoder_pool);
}",1569.0,1593.0,1.0,1.0,25.0,29,4,18,4,3,8,5,6,0,8,,0,0,4,2,2,void
2440,201174,ThreadInit,1,ThreadInit,void ThreadInit (vout_thread_t*),video_output\video_output.c,"static void ThreadInit(vout_thread_t *vout)
{
    vout->p->dead            = false;
    vout->p->is_late_dropped = var_InheritBool(vout, ""drop-late-frames"");
    vout->p->pause.is_on     = false;
    vout->p->pause.date      = VLC_TS_INVALID;

    vout_chrono_Init(&vout->p->render, 5, 10000); /* Arbitrary initial time */
}",1595.0,1603.0,1.0,1.0,9.0,17,4,9,3,1,1,1,1,0,1,,0,0,2,1,1,void
2441,201222,ThreadClean,1,ThreadClean,void ThreadClean (vout_thread_t*),video_output\video_output.c,"static void ThreadClean(vout_thread_t *vout)
{
    vout_chrono_Clean(&vout->p->render);
    vout->p->dead = true;
    vout_control_Dead(&vout->p->control);
}",1605.0,1610.0,1.0,1.0,6.0,9,3,4,2,4,2,1,1,0,2,,0,0,2,1,1,void
2442,201248,ThreadReinit,1,ThreadReinit,"int ThreadReinit (vout_thread_t*,vout_configuration_t*)",video_output\video_output.c,"static int ThreadReinit(vout_thread_t *vout,
                        const vout_configuration_t *cfg)
{
    video_format_t original;

    vout->p->pause.is_on = false;
    vout->p->pause.date  = VLC_TS_INVALID;

    if (VoutValidateFormat(&original, cfg->fmt)) {
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return VLC_EGENERIC;
    }

    /* We ignore ar changes at this point, they are dynamically supported.
     * #19268: don't ignore crop changes (fix vouts using the crop size of the
     * previous format). */
    vout->p->original.i_sar_num = original.i_sar_num;
    vout->p->original.i_sar_den = original.i_sar_den;
    if (video_format_IsSimilar(&original, &vout->p->original)) {
        if (cfg->dpb_size <= vout->p->dpb_size) {
            video_format_Clean(&original);
            return VLC_SUCCESS;
        }
        msg_Warn(vout, ""DPB need to be increased"");
    }

    vout_display_state_t state;
    memset(&state, 0, sizeof(state));

    ThreadStop(vout...",1612.0,1674.0,1.0,1.0,63.0,92,7,47,9,1,8,7,8,3,8,,0,3,4,2,2,int
2443,201500,ThreadCancel,1,ThreadCancel,"void ThreadCancel (vout_thread_t*,bool)",video_output\video_output.c,"static void ThreadCancel(vout_thread_t *vout, bool canceled)
{
    picture_pool_Cancel(vout->p->decoder_pool, canceled);
}",1676.0,1679.0,1.0,1.0,4.0,2,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,void
2444,201513,ThreadControl,1,ThreadControl,"int ThreadControl (vout_thread_t*,vout_control_cmd_t)",video_output\video_output.c,"static int ThreadControl(vout_thread_t *vout, vout_control_cmd_t cmd)
{
    switch(cmd.type) {
    case VOUT_CONTROL_INIT:
        ThreadInit(vout);
        if (ThreadStart(vout, NULL))
        {
            ThreadClean(vout);
            return 1;
        }
        break;
    case VOUT_CONTROL_CLEAN:
        ThreadStop(vout, NULL);
        ThreadClean(vout);
        return 1;
    case VOUT_CONTROL_REINIT:
        if (ThreadReinit(vout, cmd.u.cfg))
            return 1;
        break;
    case VOUT_CONTROL_CANCEL:
        ThreadCancel(vout, cmd.u.boolean);
        break;
    case VOUT_CONTROL_SUBPICTURE:
        ThreadDisplaySubpicture(vout, cmd.u.subpicture);
        cmd.u.subpicture = NULL;
        break;
    case VOUT_CONTROL_FLUSH_SUBPICTURE:
        ThreadFlushSubpicture(vout, cmd.u.integer);
        break;
    case VOUT_CONTROL_OSD_TITLE:
        ThreadDisplayOsdTitle(vout, cmd.u.string);
        break;
    case VOUT_CONTROL_CHANGE_FILTERS:
        ThreadChangeFilters(vout, NU...",1681.0,1780.0,1.0,1.0,100.0,101,7,101,29,0,65,29,6,4,29,,0,38,4,2,2,int
2445,202049,OSDTextUpdate,1,OSDTextUpdate,"void OSDTextUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",video_output\video_text.c,"static void OSDTextUpdate(subpicture_t *subpic,
                          const video_format_t *fmt_src,
                          const video_format_t *fmt_dst,
                          mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    if( fmt_dst->i_sar_num <= 0 || fmt_dst->i_sar_den <= 0 )
        return;

    subpic->b_absolute = false;
    subpic->i_original_picture_width  = fmt_dst->i_visible_width * fmt_dst->i_sar_num / fmt_dst->i_sar_den;
    subpic->i_original_picture_height = fmt_dst->i_visible_height;

    video_format_t fmt;
    video_format_Init( &fmt, VLC_CODEC_TEXT);
    fmt.i_sar_num = 1;
    fmt.i_sar_den = 1;

    subpicture_region_t *r = subpic->p_region = subpicture_region_New(&fmt);
    if (!r)
        return;

    r->p_text = text_segment_New( sys->text );

    const float margin_ratio = 0.04;
    const int   margin_h     = margin_ratio * fmt_dst->i_visible_width;
    const int   margin_v    ...",53.0,96.0,1.0,1.0,44.0,62,12,47,14,0,5,5,5,0,2,,0,5,8,4,4,void
2446,202260,OSDTextDestroy,1,OSDTextDestroy,void OSDTextDestroy (subpicture_t*),video_output\video_text.c,"static void OSDTextDestroy(subpicture_t *subpic)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;

    free(sys->text);
    free(sys);
}",98.0,104.0,1.0,1.0,7.0,4,3,4,2,0,1,1,1,0,0,,0,1,2,1,1,void
2447,202279,vout_OSDText,1,vout_OSDText,"void vout_OSDText (vout_thread_t*,int,int,mtime_t,char*)",video_output\video_text.c,"void vout_OSDText(vout_thread_t *vout, int channel,
                   int position, mtime_t duration, const char *text)
{
    assert( (position & ~SUBPICTURE_ALIGN_MASK) == 0);
    if (!var_InheritBool(vout, ""osd"") || duration <= 0)
        return;

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->position = position;
    sys->text     = strdup(text);

    subpicture_updater_t updater = {
        .pf_validate = OSDTextValidate,
        .pf_update   = OSDTextUpdate,
        .pf_destroy  = OSDTextDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys->text);
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + duration;
    subpic->b_ephemer  = true;
    subpic->b_absolute = false;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",106.0,140.0,1.0,1.0,35.0,38,13,36,15,2,6,4,4,0,3,,0,5,10,5,5,void
2448,202403,vout_OSDMessage,1,vout_OSDMessage,"void vout_OSDMessage (vout_thread_t*,int,char*...)",video_output\video_text.c,"void vout_OSDMessage(vout_thread_t *vout, int channel, const char *format, ...)
{
    va_list args;
    va_start(args, format);

    char *string;
    if (vasprintf(&string, format, args) != -1) {
        vout_OSDText(vout, channel,
                     SUBPICTURE_ALIGN_TOP|SUBPICTURE_ALIGN_RIGHT, 1000000,
                     string);
        free(string);
    }
    va_end(args);
}",142.0,155.0,1.0,1.0,14.0,4,4,12,7,5,1,2,2,0,1,,0,0,6,3,3,void
2449,202456,DrawRect,1,DrawRect,"void DrawRect (subpicture_region_t*,int,uint8_t,int,int,int,int)",video_output\video_widgets.c,"static void DrawRect(subpicture_region_t *r, int fill, uint8_t color,
                     int x1, int y1, int x2, int y2)
{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    if( x1 > x2 || y1 > y2 )
        return;

    if (fill == STYLE_FILLED) {
        if(x1 == 0 && x2 + 1 == r->p_picture->p->i_visible_pitch) {
            memset(&p[pitch * y1], color, pitch * (y2 - y1 + 1));
        } else {
            for (int y = y1; y <= y2; y++)
                memset(&p[x1 + pitch * y], color, x2 - x1 + 1);
        }
    } else {
        DrawRect(r, STYLE_FILLED, color, x1, y1, x1, y2);
        DrawRect(r, STYLE_FILLED, color, x2, y1, x2, y2);
        DrawRect(r, STYLE_FILLED, color, x1, y1, x2, y1);
        DrawRect(r, STYLE_FILLED, color, x1, y2, x2, y2);
    }
}",63.0,84.0,1.0,16.0,22.0,25,11,19,9,7,0,4,5,0,0,,0,0,14,7,7,void
2450,202606,DrawTriangle,1,DrawTriangle,"void DrawTriangle (subpicture_region_t*,int,uint8_t,int,int,int,int)",video_output\video_widgets.c,"static void DrawTriangle(subpicture_region_t *r, int fill, uint8_t color,
                         int x1, int y1, int x2, int y2)
{
    uint8_t *p    = r->p_picture->p->p_pixels;
    int     pitch = r->p_picture->p->i_pitch;
    const int mid = y1 + (y2 - y1) / 2;
    const bool b_swap = (x1 > x2);

    for (int y = y1; y <= mid; y++) {
        const int h = y - y1;
        if (fill == STYLE_FILLED) {
            const int w = b_swap ? __MAX(x1 - h, x2) : __MIN(x1 + h, x2);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y, (b_swap) ? x1 : w, y);
            DrawRect(r, STYLE_FILLED, color,
                     (b_swap) ? w : x1, y2 - h, (b_swap) ? x1 : w, y2 - h);
        } else {
            p[x1 +                     pitch * y       ] = color;
            p[x1 + (b_swap ? -h : h) + pitch * y       ] = color;
            p[x1 +                     pitch * (y2 - h)] = color;
            p[x1 + (b_swap ? -h : h) + pitch * (y2 - h)] = color;
    ...",90.0,113.0,1.0,20.0,24.0,29,9,49,14,0,2,3,4,0,2,,0,0,14,7,7,void
2451,202783,OSDRegion,1,OSDRegion,"subpicture_region_t OSDRegion (int,int,int,int)",video_output\video_widgets.c,"static subpicture_region_t *OSDRegion(int x, int y, int width, int height)
{
    if( width == 0 || height == 0 )
        return NULL;

    video_palette_t palette;
    SET_PALETTE_COLOR(COL_WHITE,       0xffffff, STYLE_ALPHA_OPAQUE)
    SET_PALETTE_COLOR(COL_TRANSPARENT, 0xffffff, STYLE_ALPHA_TRANSPARENT)
    SET_PALETTE_COLOR(COL_FILL,        RGB_FILL, 0xA0)
    SET_PALETTE_COLOR(COL_FILL_SHADE,  RGB_FILL, 0x25)
    palette.i_entries = 4;

    video_format_t fmt;
    video_format_Init(&fmt, VLC_CODEC_YUVP);
    fmt.i_width          =
    fmt.i_visible_width  = width;
    fmt.i_height         =
    fmt.i_visible_height = height;
    fmt.i_sar_num        = 1;
    fmt.i_sar_den        = 1;
    fmt.p_palette        = &palette;

    subpicture_region_t *r = subpicture_region_New(&fmt);
    if (!r)
        return NULL;
    r->i_x = x;
    r->i_y = y;

    return r;
}",118.0,147.0,1.0,4.0,30.0,176,15,41,16,2,1,3,3,0,1,,0,1,8,4,4,subpicture_region_t
2452,203205,OSDSlider,1,OSDSlider,"subpicture_region_t OSDSlider (int,int,video_format_t*)",video_output\video_widgets.c,"static subpicture_region_t *OSDSlider(int type, int position,
                                      const video_format_t *fmt)
{
    const int size = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int margin = size * SLIDER_MARGIN_BASE;
    const int marginbottom = margin * 0.2;
    const int marginright = margin * 0.5;
    uint8_t i_padding = __MIN(1, size * 0.25); /* small sizes */

    int x, y;
    int width, height;
    if (type == OSD_HOR_SLIDER) {
        width  = __MAX(fmt->i_visible_width - 2 * margin, 1);
        height = __MAX(fmt->i_visible_height * 0.01,      1);
        x      = __MIN(fmt->i_x_offset + margin, fmt->i_visible_width - width);
        y      = __MAX(fmt->i_y_offset + fmt->i_visible_height - marginbottom, 0);
    } else {
        width  = __MAX(fmt->i_visible_width * 0.010,       1);
        height = __MAX(fmt->i_visible_height - 2 * margin, 1);
        x      = __MAX(fmt->i_x_offset + fmt->i_visible_width - marginright, 0);
        y      =...",154.0,201.0,1.0,30.0,48.0,52,10,62,19,1,3,5,5,0,3,,0,1,6,3,3,subpicture_region_t
2453,203473,OSDIcon,1,OSDIcon,"subpicture_region_t OSDIcon (int,video_format_t*)",video_output\video_widgets.c,"static subpicture_region_t *OSDIcon(int type, const video_format_t *fmt)
{
    const float size_ratio   = 0.05;
    const float margin_ratio = 0.07;

    const int size   = __MAX(fmt->i_visible_width, fmt->i_visible_height);
    const int width  = size * size_ratio;
    const int height = size * size_ratio;
    const int x      = fmt->i_x_offset + fmt->i_visible_width - margin_ratio * size - width;
    const int y      = fmt->i_y_offset                        + margin_ratio * size;

    if( width < 1 || height < 1 )
        return NULL;

    subpicture_region_t *r = OSDRegion(__MAX(x, 0),
                                       __MIN(y, (int)fmt->i_visible_height - height),
                                       width, height);
    if (!r)
        return NULL;

    DrawRect(r, STYLE_FILLED, COL_TRANSPARENT, 0, 0, width - 1, height - 1);

    if (type == OSD_PAUSE_ICON) {
        int bar_width = width / 3;
        DrawRect(r, STYLE_FILLED, COL_WHITE, 0, 0, bar_width - 1, height -1);
 ...",207.0,250.0,1.0,16.0,44.0,38,11,49,13,0,4,4,4,0,4,,0,1,4,2,2,subpicture_region_t
2454,203807,OSDWidgetUpdate,1,OSDWidgetUpdate,"void OSDWidgetUpdate (subpicture_t*,video_format_t*,video_format_t*,mtime_t)",video_output\video_widgets.c,"static void OSDWidgetUpdate(subpicture_t *subpic,
                          const video_format_t *fmt_src,
                          const video_format_t *fmt_dst,
                          mtime_t ts)
{
    subpicture_updater_sys_t *sys = subpic->updater.p_sys;
    VLC_UNUSED(fmt_src); VLC_UNUSED(ts);

    video_format_t fmt = *fmt_dst;
    fmt.i_width         = fmt.i_width         * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_visible_width = fmt.i_visible_width * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_x_offset      = fmt.i_x_offset      * fmt.i_sar_num / fmt.i_sar_den;
    fmt.i_sar_num       = 1;
    fmt.i_sar_den       = 1;

    subpic->i_original_picture_width  = fmt.i_visible_width;
    subpic->i_original_picture_height = fmt.i_visible_height;
    if (sys->type == OSD_HOR_SLIDER || sys->type == OSD_VERT_SLIDER)
        subpic->p_region = OSDSlider(sys->type, sys->position, &fmt);
    else
        subpic->p_region = OSDIcon(sys->type, &fmt);
}",271.0,292.0,1.0,1.0,22.0,46,9,32,8,0,5,2,2,2,1,,0,5,8,4,4,void
2455,203950,OSDWidget,1,OSDWidget,"void OSDWidget (vout_thread_t*,int,int,int)",video_output\video_widgets.c,"static void OSDWidget(vout_thread_t *vout, int channel, int type, int position)
{
    if (!var_InheritBool(vout, ""osd""))
        return;
    if (type == OSD_HOR_SLIDER || type == OSD_VERT_SLIDER)
        position = VLC_CLIP(position, 0, 100);

    subpicture_updater_sys_t *sys = malloc(sizeof(*sys));
    if (!sys)
        return;
    sys->type     = type;
    sys->position = position;

    subpicture_updater_t updater = {
        .pf_validate = OSDWidgetValidate,
        .pf_update   = OSDWidgetUpdate,
        .pf_destroy  = OSDWidgetDestroy,
        .p_sys       = sys,
    };
    subpicture_t *subpic = subpicture_New(&updater);
    if (!subpic) {
        free(sys);
        return;
    }

    subpic->i_channel  = channel;
    subpic->i_start    = mdate();
    subpic->i_stop     = subpic->i_start + 1200000;
    subpic->b_ephemer  = true;
    subpic->b_absolute = true;
    subpic->b_fade     = true;

    vout_PutSubpicture(vout, subpic);
}",299.0,332.0,1.0,1.0,34.0,36,10,37,14,2,5,5,5,0,3,,0,4,8,4,4,void
2456,204072,vout_OSDSlider,1,vout_OSDSlider,"void vout_OSDSlider (vout_thread_t*,int,int,short)",video_output\video_widgets.c,"void vout_OSDSlider(vout_thread_t *vout, int channel, int position, short type)
{
    OSDWidget(vout, channel, type, position);
}",334.0,337.0,1.0,1.0,4.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
2457,204085,vout_OSDIcon,1,vout_OSDIcon,"void vout_OSDIcon (vout_thread_t*,int,short)",video_output\video_widgets.c,"void vout_OSDIcon(vout_thread_t *vout, int channel, short type )
{
    OSDWidget(vout, channel, type, 0);
}",339.0,342.0,1.0,1.0,4.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
2458,204111,spu_OffsetSubtitleDate,1,spu_OffsetSubtitleDate,"void spu_OffsetSubtitleDate (spu_t*,mtime_t)",video_output\vout_subpictures.c,"void spu_OffsetSubtitleDate(spu_t *spu, mtime_t duration)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *current = entry->subpicture;

        if (current && current->b_subtitle) {
            if (current->i_start > 0)
                current->i_start += duration;
            if (current->i_stop > 0)
                current->i_stop  += duration;
        }
    }
    vlc_mutex_unlock(&sys->lock);
}",1622.0,1639.0,1.0,24.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2459,204331,vout_IntfInit,1,vout_IntfInit,void vout_IntfInit (vout_thread_t*),video_output\vout_intf.c,"void vout_IntfInit( vout_thread_t *p_vout )
{
    vlc_value_t val, text;
    char *psz_buf;

    /* Create a few object variables we'll need later on */
    var_Create( p_vout, ""snapshot-num"", VLC_VAR_INTEGER );
    var_SetInteger( p_vout, ""snapshot-num"", 1 );

    var_Create( p_vout, ""width"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""height"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );
    var_Create( p_vout, ""align"", VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    var_Create( p_vout, ""mouse-hide-timeout"",
                VLC_VAR_INTEGER | VLC_VAR_DOINHERIT );

    /* Add variables to manage scaling video */
    var_Create( p_vout, ""autoscale"", VLC_VAR_BOOL | VLC_VAR_DOINHERIT
                | VLC_VAR_ISCOMMAND );
    text.psz_string = _(""Autoscale video"");
    var_Change( p_vout, ""autoscale"", VLC_VAR_SETTEXT, &text, NULL );
    var_AddCallback( p_vout, ""autoscale"", AutoScaleCallback, NULL );

    var_Create( p_vout, ""zoom"", VLC_VAR_FLOAT | VLC_VAR_ISCOMMAND |
       ...",150.0,312.0,1.0,1.0,163.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2460,204336,vout_IntfReinit,1,vout_IntfReinit,void vout_IntfReinit (vout_thread_t*),video_output\vout_intf.c,"void vout_IntfReinit( vout_thread_t *p_vout )
{
    var_TriggerCallback( p_vout, ""zoom"" );
    var_TriggerCallback( p_vout, ""crop"" );
    var_TriggerCallback( p_vout, ""aspect-ratio"" );

    var_TriggerCallback( p_vout, ""video-on-top"" );
    var_TriggerCallback( p_vout, ""video-wallpaper"" );

    var_TriggerCallback( p_vout, ""video-filter"" );
    var_TriggerCallback( p_vout, ""sub-source"" );
    var_TriggerCallback( p_vout, ""sub-filter"" );
    var_TriggerCallback( p_vout, ""sub-margin"" );
}",314.0,327.0,1.0,1.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2461,204341,vout_OpenWrapper,1,vout_OpenWrapper,"int vout_OpenWrapper (vout_thread_t*,char*,vout_display_state_t*)",video_output\vout_wrapper.c,"int vout_OpenWrapper(vout_thread_t *vout,
                     const char *splitter_name, const vout_display_state_t *state)
{
    vout_thread_sys_t *sys = vout->p;
    msg_Dbg(vout, ""Opening vout display wrapper"");

    /* */
    sys->display.title = var_InheritString(vout, ""video-title"");

    /* */
    const mtime_t double_click_timeout = 300000;
    const mtime_t hide_timeout = var_CreateGetInteger(vout, ""mouse-hide-timeout"") * 1000;

    if (splitter_name) {
        sys->display.vd = vout_NewSplitter(vout, &vout->p->original, state, ""$vout"", splitter_name,
                                           double_click_timeout, hide_timeout);
    } else {
        sys->display.vd = vout_NewDisplay(vout, &vout->p->original, state, ""$vout"",
                                          double_click_timeout, hide_timeout);
    }
    if (!sys->display.vd) {
        free(sys->display.title);
        return VLC_EGENERIC;
    }

    /* */
#ifdef _WIN32
    var_Create(vout, ""video-wallpaper"", VLC_V...",50.0,85.0,1.0,1.0,36.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
2462,204348,vout_CloseWrapper,1,vout_CloseWrapper,"void vout_CloseWrapper (vout_thread_t*,vout_display_state_t*)",video_output\vout_wrapper.c,"void vout_CloseWrapper(vout_thread_t *vout, vout_display_state_t *state)
{
    vout_thread_sys_t *sys = vout->p;

#ifdef _WIN32
    var_DelCallback(vout, ""video-wallpaper"", Forward, NULL);
#endif
    sys->decoder_pool = NULL; /* FIXME remove */

    vout_DeleteDisplay(sys->display.vd, state);
    free(sys->display.title);
}",90.0,101.0,1.0,1.0,12.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
2463,204354,vout_InitWrapper,1,vout_InitWrapper,int vout_InitWrapper (vout_thread_t*),video_output\vout_wrapper.c,"int vout_InitWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;
    vout_display_t *vd = sys->display.vd;

    sys->display.use_dr = !vout_IsDisplayFiltered(vd);
    const bool allow_dr = !vd->info.has_pictures_invalid && !vd->info.is_slow && sys->display.use_dr;
    const unsigned private_picture  = 4; /* XXX 3 for filter, 1 for SPU */
    const unsigned decoder_picture  = 1 + sys->dpb_size;
    const unsigned kept_picture     = 1; /* last displayed picture */
    const unsigned reserved_picture = DISPLAY_PICTURE_COUNT +
                                      private_picture +
                                      kept_picture;
    const unsigned display_pool_size = allow_dr ? __MAX(VOUT_MAX_PICTURES,
                                                        reserved_picture + decoder_picture) : 3;
    picture_pool_t *display_pool = vout_display_Pool(vd, display_pool_size);
    if (display_pool == NULL)
        return VLC_EGENERIC;

#ifndef NDEBUG
    if ( picture_po...",119.0,173.0,1.0,38.0,55.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2464,204359,vout_EndWrapper,1,vout_EndWrapper,void vout_EndWrapper (vout_thread_t*),video_output\vout_wrapper.c,"void vout_EndWrapper(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;

    assert(vout->p->decoder_pool && vout->p->private_pool);

    picture_pool_Release(sys->private_pool);

    if (sys->decoder_pool != sys->display_pool)
        picture_pool_Release(sys->decoder_pool);
}",178.0,188.0,1.0,1.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2465,204369,spu_ProcessMouse,1,spu_ProcessMouse,"int spu_ProcessMouse (spu_t*,vlc_mouse_t*,video_format_t*)",video_output\vout_subpictures.c,"int spu_ProcessMouse(spu_t *spu,
                     const vlc_mouse_t *mouse,
                     const video_format_t *fmt)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->source_chain_lock);
    filter_chain_MouseEvent(sys->source_chain, mouse, fmt);
    vlc_mutex_unlock(&sys->source_chain_lock);

    return VLC_SUCCESS;
}",1423.0,1434.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
2466,204376,spu_Attach,1,spu_Attach,"void spu_Attach (spu_t*,vlc_object_t*,ANY)",video_output\vout_subpictures.c,"void spu_Attach(spu_t *spu, vlc_object_t *input, bool attach)
{
    if (attach) {
        UpdateSPU(spu, input);
        var_Create(input, ""highlight"", VLC_VAR_BOOL);
        var_AddCallback(input, ""highlight"", CropCallback, spu);

        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = input;

        if (spu->p->text)
            FilterRelease(spu->p->text);
        spu->p->text = SpuRenderCreateAndLoadText(spu);

        vlc_mutex_unlock(&spu->p->lock);
    } else {
        vlc_mutex_lock(&spu->p->lock);
        spu->p->input = NULL;
        vlc_mutex_unlock(&spu->p->lock);

        /* Delete callbacks */
        var_DelCallback(input, ""highlight"", CropCallback, spu);
        var_Destroy(input, ""highlight"");
    }
}",1394.0,1418.0,1.0,1.0,25.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,void
2467,204383,spu_ChangeMargin,1,spu_ChangeMargin,"void spu_ChangeMargin (spu_t*,int)",video_output\vout_subpictures.c,"void spu_ChangeMargin(spu_t *spu, int margin)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    sys->margin = margin;
    vlc_mutex_unlock(&sys->lock);
}",1712.0,1719.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2468,204665,AddCustomRatios,1,AddCustomRatios,"void AddCustomRatios (vout_thread_t*,char*,char*)",video_output\vout_intf.c,"static void AddCustomRatios( vout_thread_t *p_vout, const char *psz_var,
                             char *psz_list )
{
    assert( psz_list );

    char *psz_cur = psz_list;
    char *psz_next;
    while( psz_cur && *psz_cur )
    {
        vlc_value_t val, text;
        psz_next = strchr( psz_cur, ',' );
        if( psz_next )
        {
            *psz_next = '\0';
            psz_next++;
        }
        val.psz_string = psz_cur;
        text.psz_string = psz_cur;
        var_Change( p_vout, psz_var, VLC_VAR_ADDCHOICE, &val, &text);
        psz_cur = psz_next;
    }
}",127.0,148.0,1.0,1.0,22.0,14,6,21,8,0,1,3,4,0,1,,0,0,6,3,3,void
2469,205280,VoutSnapshotPip,1,VoutSnapshotPip,"int VoutSnapshotPip (vout_thread_t*,picture_t*)",video_output\vout_intf.c,"static int VoutSnapshotPip( vout_thread_t *p_vout, picture_t *p_pic )
{
    subpicture_t *p_subpic = subpicture_NewFromPicture( VLC_OBJECT(p_vout),
                                                        p_pic, VLC_CODEC_YUVA );
    if( !p_subpic )
        return VLC_EGENERIC;

    /* FIXME SPU_DEFAULT_CHANNEL is not good (used by the text) but
     * hardcoded 0 doesn't seem right */
    p_subpic->i_channel = 0;
    p_subpic->i_start = mdate();
    p_subpic->i_stop  = p_subpic->i_start + 4000000;
    p_subpic->b_ephemer = true;
    p_subpic->b_fade = true;

    /* Reduce the picture to 1/4^2 of the screen */
    p_subpic->i_original_picture_width  *= 4;
    p_subpic->i_original_picture_height *= 4;

    vout_PutSubpicture( p_vout, p_subpic );
    return VLC_SUCCESS;
}",336.0,357.0,1.0,1.0,22.0,18,5,19,7,1,3,2,2,0,3,,0,2,4,2,2,int
2470,205344,VoutOsdSnapshot,1,VoutOsdSnapshot,"void VoutOsdSnapshot (vout_thread_t*,picture_t*,char*)",video_output\vout_intf.c,"static void VoutOsdSnapshot( vout_thread_t *p_vout, picture_t *p_pic, const char *psz_filename )
{
    msg_Dbg( p_vout, ""snapshot taken (%s)"", psz_filename );
    vout_OSDMessage( p_vout, VOUT_SPU_CHANNEL_OSD, ""%s"", psz_filename );

    if( var_InheritBool( p_vout, ""snapshot-preview"" ) )
    {
        if( VoutSnapshotPip( p_vout, p_pic ) )
            msg_Warn( p_vout, ""Failed to display snapshot"" );
    }
}",362.0,372.0,1.0,1.0,11.0,0,0,9,4,1,2,3,4,1,2,,0,1,6,3,3,void
2471,205373,VoutSaveSnapshot,1,VoutSaveSnapshot,void VoutSaveSnapshot (vout_thread_t*),video_output\vout_intf.c,"static void VoutSaveSnapshot( vout_thread_t *p_vout )
{
    char *psz_path = var_InheritString( p_vout, ""snapshot-path"" );
    char *psz_format = var_InheritString( p_vout, ""snapshot-format"" );
    char *psz_prefix = var_InheritString( p_vout, ""snapshot-prefix"" );

    /* */
    picture_t *p_picture;
    block_t *p_image;

    /* 500ms timeout
     * XXX it will cause trouble with low fps video (< 2fps) */
    if( vout_GetSnapshot( p_vout, &p_image, &p_picture, NULL, psz_format, 500*1000 ) )
    {
        p_picture = NULL;
        p_image = NULL;
        goto exit;
    }

    if( !psz_path )
    {
        psz_path = vout_snapshot_GetDirectory();
        if( !psz_path )
        {
            msg_Err( p_vout, ""no path specified for snapshots"" );
            goto exit;
        }
    }

    vout_snapshot_save_cfg_t cfg;
    memset( &cfg, 0, sizeof(cfg) );
    cfg.is_sequential = var_InheritBool( p_vout, ""snapshot-sequential"" );
    cfg.sequence = var_GetInteger( p_vout, ""snapshot-num"" )...",377.0,437.0,1.0,1.0,61.0,30,8,52,10,0,11,11,9,3,5,,0,9,2,1,1,void
2472,206094,spuregion_CreateVGradientPalette,1,spuregion_CreateVGradientPalette,"void spuregion_CreateVGradientPalette (video_palette_t*,uint8_t,uint32_t,uint32_t)",video_output\vout_spuregion_helper.h,"static inline void
spuregion_CreateVGradientPalette( video_palette_t *p_palette, uint8_t i_splits,
                                  uint32_t argb1, uint32_t argb2 )
{
    for( uint8_t i = 0; i<i_splits; i++ )
    {
        uint32_t rgb1 = argb1 & 0x00FFFFFF;
        uint32_t rgb2 = argb2 & 0x00FFFFFF;

        uint32_t r = ((((rgb1 >> 16) * (i_splits - i)) + (rgb2 >> 16) * i)) / i_splits;
        uint32_t g = (((((rgb1 >> 8) & 0xFF) * (i_splits - i)) + ((rgb2 >> 8) & 0xFF) * i)) / i_splits;
        uint32_t b = ((((rgb1 & 0xFF) * (i_splits - i)) + (rgb2 & 0xFF) * i)) / i_splits;
        uint8_t entry[4] = { RGB2YUV( r,g,b ), argb1 >> 24 };
        memcpy( p_palette->palette[i], entry, 4 );
    }
    p_palette->i_entries = i_splits;
}",30.0,46.0,1.0,29.0,17.0,58,12,47,11,1,0,2,2,0,0,,0,0,8,4,4,void
2473,206249,spuregion_CreateVGradientFill,1,spuregion_CreateVGradientFill,"void spuregion_CreateVGradientFill (plane_t*,uint8_t)",video_output\vout_spuregion_helper.h,"static inline void
spuregion_CreateVGradientFill( plane_t *p, uint8_t i_splits )
{
    const int i_split = p->i_visible_lines / i_splits;
    const int i_left = p->i_visible_lines % i_splits + p->i_lines - p->i_visible_lines;
    for( int i = 0; i<i_splits; i++ )
    {
        memset( &p->p_pixels[p->i_pitch * (i * i_split)],
                i,
                p->i_pitch * i_split );
    }
    memset( &p->p_pixels[p->i_pitch * (i_splits - 1) * i_split],
            i_splits - 1,
            p->i_pitch * i_left );
}",48.0,62.0,1.0,1.0,15.0,30,10,25,5,1,0,2,2,0,0,,0,0,4,2,2,void
2474,206333,spuregion_CreateFromPicture,1,spuregion_CreateFromPicture,"subpicture_region_t spuregion_CreateFromPicture (vlc_object_t*,video_format_t*,char*)",video_output\vout_spuregion_helper.h,"static inline subpicture_region_t *
spuregion_CreateFromPicture( vlc_object_t *p_this, video_format_t *p_fmt,
                             const char *psz_uri )
{
    video_format_t fmt_in;
    video_format_Init( &fmt_in, 0 );

    picture_t *p_pic = NULL;
    int i_flags = p_this->obj.flags;
    p_this->obj.flags |= OBJECT_FLAGS_NOINTERACT|OBJECT_FLAGS_QUIET;
    image_handler_t *p_image = image_HandlerCreate( p_this );
    if( p_image )
    {
        p_pic = image_ReadUrl( p_image, psz_uri, &fmt_in, p_fmt );
        image_HandlerDelete( p_image );
    }
    p_this->obj.flags = i_flags;

    if(!p_pic)
        return NULL;

    subpicture_region_t *region = subpicture_region_New(p_fmt);
    if (!region)
        return NULL;

    picture_Release( region->p_picture );
    region->p_picture = p_pic;

    return region;
}",65.0,94.0,1.0,1.0,30.0,20,6,29,11,1,4,4,4,0,4,,0,2,6,3,3,subpicture_region_t
2475,206502,SpuHeapInit,1,SpuHeapInit,void SpuHeapInit (spu_heap_t*),video_output\vout_subpictures.c,"static void SpuHeapInit(spu_heap_t *heap)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        e->subpicture = NULL;
        e->reject     = false;
    }
}",104.0,112.0,1.0,24.0,9.0,11,6,10,6,1,3,2,2,0,0,,0,3,2,1,1,void
2476,206544,SpuHeapPush,1,SpuHeapPush,"int SpuHeapPush (spu_heap_t*,subpicture_t*)",video_output\vout_subpictures.c,"static int SpuHeapPush(spu_heap_t *heap, subpicture_t *subpic)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture)
            continue;

        e->subpicture = subpic;
        e->reject     = false;
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",114.0,127.0,1.0,24.0,14.0,12,6,13,8,1,4,4,4,1,0,,0,4,4,2,2,int
2477,206597,SpuHeapDeleteAt,1,SpuHeapDeleteAt,"void SpuHeapDeleteAt (spu_heap_t*,int)",video_output\vout_subpictures.c,"static void SpuHeapDeleteAt(spu_heap_t *heap, int index)
{
    spu_heap_entry_t *e = &heap->entry[index];

    if (e->subpicture)
        subpicture_Delete(e->subpicture);

    e->subpicture = NULL;
}",129.0,137.0,1.0,1.0,9.0,8,4,7,4,2,5,2,2,1,1,,0,4,4,2,2,void
2478,206626,SpuHeapDeleteSubpicture,1,SpuHeapDeleteSubpicture,"int SpuHeapDeleteSubpicture (spu_heap_t*,subpicture_t*)",video_output\vout_subpictures.c,"static int SpuHeapDeleteSubpicture(spu_heap_t *heap, subpicture_t *subpic)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];

        if (e->subpicture != subpic)
            continue;

        SpuHeapDeleteAt(heap, i);
        return VLC_SUCCESS;
    }
    return VLC_EGENERIC;
}",139.0,151.0,1.0,24.0,13.0,9,7,12,7,1,3,4,4,1,1,,0,2,4,2,2,int
2479,206674,SpuHeapClean,1,SpuHeapClean,void SpuHeapClean (spu_heap_t*),video_output\vout_subpictures.c,"static void SpuHeapClean(spu_heap_t *heap)
{
    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *e = &heap->entry[i];
        if (e->subpicture)
            subpicture_Delete(e->subpicture);
    }
}",153.0,160.0,1.0,24.0,8.0,9,6,8,4,1,4,3,4,1,1,,0,3,2,1,1,void
2480,206715,FilterRelease,1,FilterRelease,void FilterRelease (filter_t*),video_output\vout_subpictures.c,"static void FilterRelease(filter_t *filter)
{
    if (filter->p_module)
        module_unneed(filter, filter->p_module);
    vlc_object_release(filter);
}",162.0,167.0,1.0,1.0,6.0,2,1,4,1,3,2,2,2,0,2,,0,0,2,1,1,void
2481,206732,spu_new_video_buffer,1,spu_new_video_buffer,picture_t spu_new_video_buffer (filter_t*),video_output\vout_subpictures.c,"static picture_t *spu_new_video_buffer(filter_t *filter)
{
    const video_format_t *fmt = &filter->fmt_out.video;

    return picture_NewFromFormat(fmt);
}",169.0,174.0,1.0,1.0,6.0,4,4,3,2,0,1,1,1,0,1,,0,0,2,1,1,picture_t
2482,206749,spu_get_attachments,1,spu_get_attachments,"int spu_get_attachments (filter_t*,input_attachment_t***,int*)",video_output\vout_subpictures.c,"static int spu_get_attachments(filter_t *filter,
                               input_attachment_t ***attachment_ptr,
                               int *attachment_count)
{
    spu_t *spu = filter->owner.sys;

    int ret = VLC_EGENERIC;
    if (spu->p->input)
        ret = input_Control((input_thread_t*)spu->p->input,
                            INPUT_GET_ATTACHMENTS,
                            attachment_ptr, attachment_count);
    return ret;
}",176.0,188.0,1.0,1.0,13.0,10,4,11,7,0,1,2,2,0,1,,0,1,6,3,3,int
2483,206790,SpuRenderCreateAndLoadText,1,SpuRenderCreateAndLoadText,filter_t SpuRenderCreateAndLoadText (spu_t*),video_output\vout_subpictures.c,"static filter_t *SpuRenderCreateAndLoadText(spu_t *spu)
{
    filter_t *text = vlc_custom_create(spu, sizeof(*text), ""spu text"");
    if (!text)
        return NULL;

    text->owner.sys = spu;

    es_format_Init(&text->fmt_in, VIDEO_ES, 0);

    es_format_Init(&text->fmt_out, VIDEO_ES, 0);
    text->fmt_out.video.i_width          =
    text->fmt_out.video.i_visible_width  = 32;
    text->fmt_out.video.i_height         =
    text->fmt_out.video.i_visible_height = 32;

    text->pf_get_attachments = spu_get_attachments;

    text->p_module = module_need(text, ""text renderer"", ""$text-renderer"", false);

    /* Create a few variables used for enhanced text rendering */
    var_Create(text, ""spu-elapsed"",   VLC_VAR_INTEGER);
    var_Create(text, ""text-rerender"", VLC_VAR_BOOL);

    return text;
}",190.0,215.0,1.0,21.0,26.0,31,7,25,7,1,6,2,2,0,6,,0,2,2,1,1,filter_t
2484,206893,SpuRenderCreateAndLoadScale,1,SpuRenderCreateAndLoadScale,"filter_t SpuRenderCreateAndLoadScale (vlc_object_t*,vlc_fourcc_t,vlc_fourcc_t,bool)",video_output\vout_subpictures.c,"static filter_t *SpuRenderCreateAndLoadScale(vlc_object_t *object,
                                             vlc_fourcc_t src_chroma,
                                             vlc_fourcc_t dst_chroma,
                                             bool require_resize)
{
    filter_t *scale = vlc_custom_create(object, sizeof(*scale), ""scale"");
    if (!scale)
        return NULL;

    es_format_Init(&scale->fmt_in, VIDEO_ES, 0);
    scale->fmt_in.video.i_chroma = src_chroma;
    scale->fmt_in.video.i_width =
    scale->fmt_in.video.i_visible_width =
    scale->fmt_in.video.i_height =
    scale->fmt_in.video.i_visible_height = 32;

    es_format_Init(&scale->fmt_out, VIDEO_ES, 0);
    scale->fmt_out.video.i_chroma = dst_chroma;
    scale->fmt_out.video.i_width =
    scale->fmt_out.video.i_visible_width =
    scale->fmt_out.video.i_height =
    scale->fmt_out.video.i_visible_height = require_resize ? 16 : 32;

    scale->owner.video.buffer_new = spu_new_video_buffer;

    scale->p_...",217.0,245.0,1.0,22.0,29.0,55,8,29,8,2,4,2,2,0,4,,0,2,8,4,4,filter_t
2485,207042,SpuRenderText,1,SpuRenderText,"void SpuRenderText (spu_t*,bool*,subpicture_region_t*,vlc_fourcc_t*,mtime_t)",video_output\vout_subpictures.c,"static void SpuRenderText(spu_t *spu, bool *rerender_text,
                          subpicture_region_t *region,
                          const vlc_fourcc_t *chroma_list,
                          mtime_t elapsed_time)
{
    filter_t *text = spu->p->text;

    assert(region->fmt.i_chroma == VLC_CODEC_TEXT);

    if (!text || !text->p_module)
        return;

    /* Setup 3 variables which can be used to render
     * time-dependent text (and effects). The first indicates
     * the total amount of time the text will be on screen,
     * the second the amount of time it has already been on
     * screen (can be a negative value as text is laid out
     * before it is rendered) and the third is a feedback
     * variable from the renderer - if the renderer sets it
     * then this particular text is time-dependent, eg. the
     * visual progress bar inside the text in karaoke and the
     * text needs to be rendered multiple times in order for
     * the effect to work - we therefor...",247.0,284.0,1.0,1.0,38.0,14,7,18,8,1,0,3,3,0,0,,0,0,10,5,5,void
2486,207108,spu_scale_create,1,spu_scale_create,"spu_scale_t spu_scale_create (int,int)",video_output\vout_subpictures.c,"static spu_scale_t spu_scale_create(int w, int h)
{
    spu_scale_t s = { .w = w, .h = h };
    if (s.w <= 0)
        s.w = SCALE_UNIT;
    if (s.h <= 0)
        s.h = SCALE_UNIT;
    return s;
}",296.0,304.0,1.0,14.0,9.0,12,4,10,3,2,4,3,3,2,0,,0,4,4,2,2,spu_scale_t
2487,207156,spu_scale_unit,1,spu_scale_unit,spu_scale_t spu_scale_unit (void),video_output\vout_subpictures.c,"static spu_scale_t spu_scale_unit(void)
{
    return spu_scale_create(SCALE_UNIT, SCALE_UNIT);
}",305.0,308.0,1.0,28.0,4.0,0,0,0,0,2,1,1,1,0,1,,0,0,2,1,1,spu_scale_t
2488,207169,spu_scale_createq,1,spu_scale_createq,"spu_scale_t spu_scale_createq (int64_t,int64_t,int64_t,int64_t)",video_output\vout_subpictures.c,"static spu_scale_t spu_scale_createq(int64_t wn, int64_t wd, int64_t hn, int64_t hd)
{
    return spu_scale_create(wn * SCALE_UNIT / wd,
                            hn * SCALE_UNIT / hd);
}",309.0,313.0,1.0,33.0,5.0,4,2,4,4,1,1,1,1,0,1,,0,0,8,4,4,spu_scale_t
2489,207193,spu_scale_w,1,spu_scale_w,"int spu_scale_w (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_scale_w(int v, const spu_scale_t s)
{
    return v * s.w / SCALE_UNIT;
}",314.0,317.0,1.0,21.0,4.0,3,3,2,2,9,1,1,1,0,0,,0,1,4,2,2,int
2490,207209,spu_scale_h,1,spu_scale_h,"int spu_scale_h (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_scale_h(int v, const spu_scale_t s)
{
    return v * s.h / SCALE_UNIT;
}",318.0,321.0,1.0,21.0,4.0,3,3,2,2,9,1,1,1,0,0,,0,1,4,2,2,int
2491,207225,spu_invscale_w,1,spu_invscale_w,"int spu_invscale_w (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_invscale_w(int v, const spu_scale_t s)
{
    return v * SCALE_UNIT / s.w;
}",322.0,325.0,1.0,15.0,4.0,3,3,2,2,2,1,1,1,0,0,,0,1,4,2,2,int
2492,207241,spu_invscale_h,1,spu_invscale_h,"int spu_invscale_h (int,spu_scale_t)",video_output\vout_subpictures.c,"static int spu_invscale_h(int v, const spu_scale_t s)
{
    return v * SCALE_UNIT / s.h;
}",326.0,329.0,1.0,15.0,4.0,3,3,2,2,3,1,1,1,0,0,,0,1,4,2,2,int
2493,207264,spu_area_create,1,spu_area_create,"spu_area_t spu_area_create (int,int,int,int,spu_scale_t)",video_output\vout_subpictures.c,"static spu_area_t spu_area_create(int x, int y, int w, int h, spu_scale_t s)
{
    spu_area_t a = { .x = x, .y = y, .width = w, .height = h, .scale = s };
    return a;
}",343.0,347.0,1.0,1.0,5.0,7,2,12,9,3,0,1,1,0,0,,0,0,10,5,5,spu_area_t
2494,207299,spu_area_scaled,1,spu_area_scaled,spu_area_t spu_area_scaled (spu_area_t),video_output\vout_subpictures.c,"static spu_area_t spu_area_scaled(spu_area_t a)
{
    if (a.scale.w == SCALE_UNIT && a.scale.h == SCALE_UNIT)
        return a;

    a.x      = spu_scale_w(a.x,      a.scale);
    a.y      = spu_scale_h(a.y,      a.scale);
    a.width  = spu_scale_w(a.width,  a.scale);
    a.height = spu_scale_h(a.height, a.scale);

    a.scale = spu_scale_unit();
    return a;
}",348.0,360.0,1.0,21.0,13.0,25,4,17,1,6,20,2,2,2,5,,0,20,2,1,1,spu_area_t
2495,207378,spu_area_unscaled,1,spu_area_unscaled,"spu_area_t spu_area_unscaled (spu_area_t,spu_scale_t)",video_output\vout_subpictures.c,"static spu_area_t spu_area_unscaled(spu_area_t a, spu_scale_t s)
{
    if (a.scale.w == s.w && a.scale.h == s.h)
        return a;

    a = spu_area_scaled(a);

    a.x      = spu_invscale_w(a.x,      s);
    a.y      = spu_invscale_h(a.y,      s);
    a.width  = spu_invscale_w(a.width,  s);
    a.height = spu_invscale_h(a.height, s);

    a.scale = s;
    return a;
}",361.0,375.0,1.0,1.0,15.0,24,4,22,2,3,18,2,2,4,5,,0,18,4,2,2,spu_area_t
2496,207454,spu_area_overlap,1,spu_area_overlap,"bool spu_area_overlap (spu_area_t,spu_area_t)",video_output\vout_subpictures.c,"static bool spu_area_overlap(spu_area_t a, spu_area_t b)
{
    a = spu_area_scaled(a);
    b = spu_area_scaled(b);

    return __MAX(a.x, b.x) < __MIN(a.x + a.width , b.x + b.width ) &&
           __MAX(a.y, b.y) < __MIN(a.y + a.height, b.y + b.height);
}",376.0,383.0,1.0,1.0,8.0,21,5,16,2,1,14,1,1,0,2,,0,14,4,2,2,bool
2497,207516,SpuAreaFixOverlap,1,SpuAreaFixOverlap,"void SpuAreaFixOverlap (spu_area_t*,spu_area_t*,int,int)",video_output\vout_subpictures.c,"static void SpuAreaFixOverlap(spu_area_t *dst,
                              const spu_area_t *sub_array, int sub_count, int align)
{
    spu_area_t a = spu_area_scaled(*dst);
    bool is_moved = false;
    bool is_ok;

    /* Check for overlap
     * XXX It is not fast O(n^2) but we should not have a lot of region */
    do {
        is_ok = true;
        for (int i = 0; i < sub_count; i++) {
            spu_area_t sub = spu_area_scaled(sub_array[i]);

            if (!spu_area_overlap(a, sub))
                continue;

            if (align & SUBPICTURE_ALIGN_TOP) {
                /* We go down */
                int i_y = sub.y + sub.height;
                a.y = i_y;
                is_moved = true;
            } else if (align & SUBPICTURE_ALIGN_BOTTOM) {
                /* We go up */
                int i_y = sub.y - a.height;
                a.y = i_y;
                is_moved = true;
            } else {
                /* TODO what to do in this case? */
                ...",388.0,428.0,1.0,1.0,41.0,22,9,30,13,1,8,8,11,1,4,,0,8,8,4,4,void
2498,207634,SpuAreaFitInside,1,SpuAreaFitInside,"void SpuAreaFitInside (spu_area_t*,spu_area_t*)",video_output\vout_subpictures.c,"static void SpuAreaFitInside(spu_area_t *area, const spu_area_t *boundary)
{
    spu_area_t a = spu_area_scaled(*area);

    const int i_error_x = (a.x + a.width) - boundary->width;
    if (i_error_x > 0)
        a.x -= i_error_x;
    if (a.x < 0)
        a.x = 0;

    const int i_error_y = (a.y + a.height) - boundary->height;
    if (i_error_y > 0)
        a.y -= i_error_y;
    if (a.y < 0)
        a.y = 0;

    *area = spu_area_unscaled(a, area->scale);
}",431.0,448.0,1.0,1.0,18.0,31,9,23,5,1,15,5,5,2,2,,0,15,4,2,2,void
2499,207726,SpuRegionPlace,1,SpuRegionPlace,"void SpuRegionPlace (int*,int*,subpicture_t*,subpicture_region_t*)",video_output\vout_subpictures.c,"static void SpuRegionPlace(int *x, int *y,
                           const subpicture_t *subpic,
                           const subpicture_region_t *region)
{
    assert(region->i_x != INT_MAX && region->i_y != INT_MAX);
    if (subpic->b_absolute) {
        *x = region->i_x;
        *y = region->i_y;
    } else {
        if (region->i_align & SUBPICTURE_ALIGN_TOP)
            *y = region->i_y;
        else if (region->i_align & SUBPICTURE_ALIGN_BOTTOM)
            *y = subpic->i_original_picture_height - region->fmt.i_visible_height - region->i_y;
        else
            *y = subpic->i_original_picture_height / 2 - region->fmt.i_visible_height / 2;

        if (region->i_align & SUBPICTURE_ALIGN_LEFT)
            *x = region->i_x;
        else if (region->i_align & SUBPICTURE_ALIGN_RIGHT)
            *x = subpic->i_original_picture_width - region->fmt.i_visible_width - region->i_x;
        else
            *x = subpic->i_original_picture_width / 2 - region->fmt.i_visible_width ...",453.0,476.0,1.0,1.0,24.0,12,5,9,5,1,0,2,2,0,0,,0,0,8,4,4,void
2500,207877,IntegerCmp,1,IntegerCmp,"int IntegerCmp (int64_t,int64_t)",video_output\vout_subpictures.c,"static int IntegerCmp(int64_t i0, int64_t i1)
{
    return i0 < i1 ? -1 : i0 > i1 ? 1 : 0;
}",482.0,485.0,1.0,1.0,4.0,5,4,4,2,4,0,1,1,0,0,,0,0,4,2,2,int
2501,207896,SubpictureCmp,1,SubpictureCmp,"int SubpictureCmp (void*,void*)",video_output\vout_subpictures.c,"static int SubpictureCmp(const void *s0, const void *s1)
{
    subpicture_t *subpic0 = *(subpicture_t**)s0;
    subpicture_t *subpic1 = *(subpicture_t**)s1;
    int r;

    r = IntegerCmp(!subpic0->b_absolute, !subpic1->b_absolute);
    if (!r)
        r = IntegerCmp(subpic0->i_start, subpic1->i_start);
    if (!r)
        r = IntegerCmp(subpic0->i_channel, subpic1->i_channel);
    if (!r)
        r = IntegerCmp(subpic0->i_order, subpic1->i_order);
    return r;
}",497.0,511.0,1.0,1.0,15.0,23,5,20,5,0,4,4,4,0,4,,0,4,4,2,2,int
2502,207969,SpuSelectSubpictures,1,SpuSelectSubpictures,"void SpuSelectSubpictures (spu_t*,unsigned int*,subpicture_t**,mtime_t,mtime_t,bool)",video_output\vout_subpictures.c,"static void SpuSelectSubpictures(spu_t *spu,
                                 unsigned int *subpicture_count,
                                 subpicture_t **subpicture_array,
                                 mtime_t render_subtitle_date,
                                 mtime_t render_osd_date,
                                 bool ignore_osd)
{
    spu_private_t *sys = spu->p;

    /* */
    *subpicture_count = 0;

    /* Create a list of channels */
    int channel[VOUT_MAX_SUBPICTURES];
    int channel_count = 0;

    for (int index = 0; index < VOUT_MAX_SUBPICTURES; index++) {
        spu_heap_entry_t *entry = &sys->heap.entry[index];
        if (!entry->subpicture || entry->reject)
            continue;
        const int i_channel = entry->subpicture->i_channel;
        int i;
        for (i = 0; i < channel_count; i++) {
            if (channel[i] == i_channel)
                break;
        }
        if (channel_count <= i)
            channel[channel_count++] = i_channel;
 ...",523.0,650.0,1.0,16.0,128.0,149,18,145,35,1,16,27,54,5,2,,0,14,12,6,6,void
2503,208459,SpuRenderRegion,1,SpuRenderRegion,"void SpuRenderRegion (spu_t*,subpicture_region_t**,spu_area_t*,subpicture_t*,subpicture_region_t*,spu_scale_t,vlc_fourcc_t*,video_format_t*,spu_area_t*,int,mtime_t)",video_output\vout_subpictures.c,"static void SpuRenderRegion(spu_t *spu,
                            subpicture_region_t **dst_ptr, spu_area_t *dst_area,
                            subpicture_t *subpic, subpicture_region_t *region,
                            const spu_scale_t scale_size,
                            const vlc_fourcc_t *chroma_list,
                            const video_format_t *fmt,
                            const spu_area_t *subtitle_area, int subtitle_area_count,
                            mtime_t render_date)
{
    spu_private_t *sys = spu->p;

    video_format_t fmt_original = region->fmt;
    bool restore_text = false;
    int x_offset;
    int y_offset;

    video_format_t region_fmt;
    picture_t *region_picture;

    /* Invalidate area by default */
    *dst_area = spu_area_create(0,0, 0,0, scale_size);
    *dst_ptr  = NULL;

    /* Render text region */
    if (region->fmt.i_chroma == VLC_CODEC_TEXT) {
        // assume rendered text is in sRGB if nothing is set
        if (region-...",657.0,1000.0,1.0,25.0,344.0,399,20,329,57,1,52,50,113,12,32,,0,42,22,11,11,void
2504,209780,SpuRenderSubpictures,1,SpuRenderSubpictures,"subpicture_t SpuRenderSubpictures (spu_t*,unsigned int,subpicture_t**,vlc_fourcc_t*,video_format_t*,video_format_t*,mtime_t,mtime_t)",video_output\vout_subpictures.c,"static subpicture_t *SpuRenderSubpictures(spu_t *spu,
                                          unsigned int i_subpicture,
                                          subpicture_t **pp_subpicture,
                                          const vlc_fourcc_t *chroma_list,
                                          const video_format_t *fmt_dst,
                                          const video_format_t *fmt_src,
                                          mtime_t render_subtitle_date,
                                          mtime_t render_osd_date)
{
    spu_private_t *sys = spu->p;

    /* Count the number of regions and subtitle regions */
    unsigned int subtitle_region_count = 0;
    unsigned int region_count          = 0;
    for (unsigned i = 0; i < i_subpicture; i++) {
        const subpicture_t *subpic = pp_subpicture[i];

        unsigned count = 0;
        for (subpicture_region_t *r = subpic->p_region; r != NULL; r = r->p_next)
            count++;

        if (subpic->b...",1005.0,1144.0,1.0,36.0,140.0,170,21,139,29,1,16,23,44,5,5,,0,14,16,8,8,subpicture_t
2505,210297,UpdateSPU,1,UpdateSPU,"void UpdateSPU (spu_t*,vlc_object_t*)",video_output\vout_subpictures.c,"static void UpdateSPU(spu_t *spu, vlc_object_t *object)
{
    spu_private_t *sys = spu->p;
    vlc_value_t val;

    vlc_mutex_lock(&sys->lock);

    sys->force_palette = false;
    sys->force_crop = false;

    if (var_Get(object, ""highlight"", &val) || !val.b_bool) {
        vlc_mutex_unlock(&sys->lock);
        return;
    }

    sys->force_crop = true;
    sys->crop.x      = var_GetInteger(object, ""x-start"");
    sys->crop.y      = var_GetInteger(object, ""y-start"");
    sys->crop.width  = var_GetInteger(object, ""x-end"") - sys->crop.x;
    sys->crop.height = var_GetInteger(object, ""y-end"") - sys->crop.y;

    if (var_Get(object, ""menu-palette"", &val) == VLC_SUCCESS) {
        memcpy(sys->palette, val.p_address, 16);
        sys->force_palette = true;
    }
    vlc_mutex_unlock(&sys->lock);

    msg_Dbg(object, ""crop: %i,%i,%i,%i, palette forced: %i"",
            sys->crop.x, sys->crop.y,
            sys->crop.width, sys->crop.height,
            sys->force_palette);
}",1156.0,1187.0,1.0,1.0,32.0,51,8,37,7,0,14,3,3,2,5,,0,11,4,2,2,void
2506,210471,sub_new_buffer,1,sub_new_buffer,subpicture_t sub_new_buffer (filter_t*),video_output\vout_subpictures.c,"static subpicture_t *sub_new_buffer(filter_t *filter)
{
    int channel = (intptr_t)filter->owner.sys;

    subpicture_t *subpicture = subpicture_New(NULL);
    if (subpicture)
        subpicture->i_channel = channel;
    return subpicture;
}",1207.0,1215.0,1.0,1.0,9.0,7,4,8,4,0,1,2,2,0,1,,0,1,2,1,1,subpicture_t
2507,210501,SubSourceInit,1,SubSourceInit,"int SubSourceInit (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceInit(filter_t *filter, void *data)
{
    spu_t *spu = data;
    int channel = spu_RegisterChannel(spu);

    filter->owner.sys = (void *)(intptr_t)channel;
    filter->owner.sub.buffer_new = sub_new_buffer;
    return VLC_SUCCESS;
}",1217.0,1225.0,1.0,1.0,9.0,11,4,8,5,0,1,1,1,0,1,,0,1,4,2,2,int
2508,210538,SubSourceClean,1,SubSourceClean,"int SubSourceClean (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceClean(filter_t *filter, void *data)
{
    spu_t *spu = data;
    int channel = (intptr_t)filter->owner.sys;

    spu_ClearChannel(spu, channel);
    return VLC_SUCCESS;
}",1227.0,1234.0,1.0,1.0,8.0,5,4,7,5,0,1,1,1,0,1,,0,0,4,2,2,int
2509,210563,RestartSubFilterCallback,1,RestartSubFilterCallback,"int RestartSubFilterCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\vout_subpictures.c,"static int RestartSubFilterCallback(vlc_object_t *obj, char const *psz_var,
                                    vlc_value_t oldval, vlc_value_t newval,
                                    void *p_data)
{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubFilters((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1240.0,1246.0,1.0,1.0,7.0,1,1,7,7,0,1,1,1,0,1,,0,0,10,5,5,int
2510,210587,SubFilterAddProxyCallbacks,1,SubFilterAddProxyCallbacks,"int SubFilterAddProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubFilterAddProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1248.0,1253.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
2511,210601,SubFilterDelProxyCallbacks,1,SubFilterDelProxyCallbacks,"int SubFilterDelProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubFilterDelProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubFilterCallback);
    return VLC_SUCCESS;
}",1255.0,1260.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
2512,210615,RestartSubSourceCallback,1,RestartSubSourceCallback,"int RestartSubSourceCallback (vlc_object_t*,char*,vlc_value_t,vlc_value_t,void*)",video_output\vout_subpictures.c,"static int RestartSubSourceCallback(vlc_object_t *obj, char const *psz_var,
                                    vlc_value_t oldval, vlc_value_t newval,
                                    void *p_data)
{ VLC_UNUSED(obj); VLC_UNUSED(psz_var); VLC_UNUSED(oldval); VLC_UNUSED(newval);
    vout_ControlChangeSubSources((vout_thread_t *)p_data, NULL);
    return VLC_SUCCESS;
}",1262.0,1268.0,1.0,1.0,7.0,1,1,7,7,0,1,1,1,0,1,,0,0,10,5,5,int
2513,210639,SubSourceAddProxyCallbacks,1,SubSourceAddProxyCallbacks,"int SubSourceAddProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceAddProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_AddProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1270.0,1275.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
2514,210653,SubSourceDelProxyCallbacks,1,SubSourceDelProxyCallbacks,"int SubSourceDelProxyCallbacks (filter_t*,void*)",video_output\vout_subpictures.c,"static int SubSourceDelProxyCallbacks(filter_t *filter, void *opaque)
{
    filter_DelProxyCallbacks((vlc_object_t *)opaque, filter,
                             RestartSubSourceCallback);
    return VLC_SUCCESS;
}",1277.0,1282.0,1.0,1.0,6.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
2515,210667,spu_Create,1,spu_Create,"spu_t spu_Create (vlc_object_t*,vout_thread_t*)",video_output\vout_subpictures.c,"spu_t *spu_Create(vlc_object_t *object, vout_thread_t *vout)
{
    spu_t *spu = vlc_custom_create(object,
                                   sizeof(spu_t) + sizeof(spu_private_t),
                                   ""subpicture"");
    if (!spu)
        return NULL;

    /* Initialize spu fields */
    spu_private_t *sys = spu->p = (spu_private_t*)&spu[1];

    /* Initialize private fields */
    vlc_mutex_init(&sys->lock);

    SpuHeapInit(&sys->heap);

    sys->text = NULL;
    sys->scale = NULL;
    sys->scale_yuvp = NULL;

    sys->margin = var_InheritInteger(spu, ""sub-margin"");

    /* Register the default subpicture channel */
    sys->channel = VOUT_SPU_CHANNEL_AVAIL_FIRST;

    sys->source_chain_update = NULL;
    sys->filter_chain_update = NULL;
    vlc_mutex_init(&sys->source_chain_lock);
    vlc_mutex_init(&sys->filter_chain_lock);
    sys->source_chain = filter_chain_New(spu, ""sub source"", SPU_ES);
    sys->filter_chain = filter_chain_New(spu, ""sub filter"", SPU_ES);

    /...",1294.0,1344.0,1.0,17.0,51.0,48,9,50,14,1,28,2,2,0,10,,0,24,4,2,2,spu_t
2516,210820,spu_Destroy,1,spu_Destroy,void spu_Destroy (spu_t*),video_output\vout_subpictures.c,"void spu_Destroy(spu_t *spu)
{
    spu_private_t *sys = spu->p;

    if (sys->text)
        FilterRelease(sys->text);

    if (sys->scale_yuvp)
        FilterRelease(sys->scale_yuvp);

    if (sys->scale)
        FilterRelease(sys->scale);

    filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
    if (sys->vout)
        filter_chain_ForEach(sys->source_chain,
                             SubSourceDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->source_chain);
    free(sys->source_chain_current);
    if (sys->vout)
        filter_chain_ForEach(sys->filter_chain,
                             SubFilterDelProxyCallbacks, sys->vout);
    filter_chain_Delete(sys->filter_chain);
    free(sys->filter_chain_current);
    vlc_mutex_destroy(&sys->source_chain_lock);
    vlc_mutex_destroy(&sys->filter_chain_lock);
    free(sys->source_chain_update);
    free(sys->filter_chain_update);

    /* Destroy all remaining subpictures */
    SpuHeapClean(&sys->heap);

    vlc_mute...",1351.0,1386.0,1.0,1.0,36.0,29,3,27,2,2,36,6,6,5,13,,0,23,2,1,1,void
2517,211062,spu_PutSubpicture,1,spu_PutSubpicture,"void spu_PutSubpicture (spu_t*,subpicture_t*)",video_output\vout_subpictures.c,"void spu_PutSubpicture(spu_t *spu, subpicture_t *subpic)
{
    spu_private_t *sys = spu->p;

    /* Update sub-filter chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->filter_chain_update;
    sys->filter_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    bool is_left_empty = false;

    vlc_mutex_lock(&sys->filter_chain_lock);
    if (chain_update) {
        if (*chain_update) {
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterDelProxyCallbacks,
                                     sys->vout);
            filter_chain_Reset(sys->filter_chain, NULL, NULL);

            filter_chain_AppendFromString(spu->p->filter_chain, chain_update);
            if (sys->vout)
                filter_chain_ForEach(sys->filter_chain,
                                     SubFilterAddProxyCallbacks,
                                     sys->vout);
        }
        else
            filter_chain...",1444.0,1524.0,1.0,1.0,81.0,68,9,64,9,2,47,13,24,7,20,,0,30,4,2,2,void
2518,211312,spu_Render,1,spu_Render,"subpicture_t spu_Render (spu_t*,vlc_fourcc_t*,video_format_t*,video_format_t*,mtime_t,mtime_t,bool)",video_output\vout_subpictures.c,"subpicture_t *spu_Render(spu_t *spu,
                         const vlc_fourcc_t *chroma_list,
                         const video_format_t *fmt_dst,
                         const video_format_t *fmt_src,
                         mtime_t render_subtitle_date,
                         mtime_t render_osd_date,
                         bool ignore_osd)
{
    spu_private_t *sys = spu->p;

    /* Update sub-source chain */
    vlc_mutex_lock(&sys->lock);
    char *chain_update = sys->source_chain_update;
    sys->source_chain_update = NULL;
    vlc_mutex_unlock(&sys->lock);

    vlc_mutex_lock(&sys->source_chain_lock);
    if (chain_update) {
        filter_chain_ForEach(sys->source_chain, SubSourceClean, spu);
            if (sys->vout)
                filter_chain_ForEach(sys->source_chain,
                                     SubSourceDelProxyCallbacks,
                                     sys->vout);
        filter_chain_Reset(sys->source_chain, NULL, NULL);

        filter_chain_A...",1526.0,1620.0,1.0,35.0,95.0,54,13,84,22,1,37,7,9,2,18,,0,21,14,7,7,subpicture_t
2519,211629,spu_RegisterChannel,1,spu_RegisterChannel,int spu_RegisterChannel (spu_t*),video_output\vout_subpictures.c,"int spu_RegisterChannel(spu_t *spu)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);
    int channel = sys->channel++;
    vlc_mutex_unlock(&sys->lock);

    return channel;
}",1641.0,1650.0,1.0,1.0,10.0,9,4,7,3,2,5,1,1,0,2,,0,3,2,1,1,int
2520,211659,spu_ClearChannel,1,spu_ClearChannel,"void spu_ClearChannel (spu_t*,int)",video_output\vout_subpictures.c,"void spu_ClearChannel(spu_t *spu, int channel)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    for (int i = 0; i < VOUT_MAX_SUBPICTURES; i++) {
        spu_heap_entry_t *entry = &sys->heap.entry[i];
        subpicture_t *subpic = entry->subpicture;

        if (!subpic)
            continue;
        if (subpic->i_channel != channel && (channel != -1 || subpic->i_channel == VOUT_SPU_CHANNEL_OSD))
            continue;

        /* You cannot delete subpicture outside of SpuSelectSubpictures */
        entry->reject = true;
    }

    vlc_mutex_unlock(&sys->lock);
}",1652.0,1672.0,1.0,24.0,21.0,27,13,20,9,3,7,6,6,0,2,,0,5,4,2,2,void
2521,211745,spu_ChangeSources,1,spu_ChangeSources,"void spu_ChangeSources (spu_t*,char*)",video_output\vout_subpictures.c,"void spu_ChangeSources(spu_t *spu, const char *filters)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->source_chain_update);
    if (filters)
    {
        sys->source_chain_update = strdup(filters);
        free(sys->source_chain_current);
        sys->source_chain_current = strdup(filters);
    }
    else if (sys->source_chain_current)
        sys->source_chain_update = strdup(sys->source_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1674.0,1691.0,1.0,1.0,18.0,12,3,11,3,1,8,2,2,0,2,,0,6,4,2,2,void
2522,211805,spu_ChangeFilters,1,spu_ChangeFilters,"void spu_ChangeFilters (spu_t*,char*)",video_output\vout_subpictures.c,"void spu_ChangeFilters(spu_t *spu, const char *filters)
{
    spu_private_t *sys = spu->p;

    vlc_mutex_lock(&sys->lock);

    free(sys->filter_chain_update);
    if (filters)
    {
        sys->filter_chain_update = strdup(filters);
        free(sys->filter_chain_current);
        sys->filter_chain_current = strdup(filters);
    }
    else if (sys->filter_chain_current)
        sys->filter_chain_update = strdup(sys->filter_chain_current);

    vlc_mutex_unlock(&sys->lock);
}",1693.0,1710.0,1.0,1.0,18.0,12,3,11,3,1,8,2,2,0,2,,0,6,4,2,2,void
2523,212045,NoDrInit,1,NoDrInit,void NoDrInit (vout_thread_t*),video_output\vout_wrapper.c,"static void NoDrInit(vout_thread_t *vout)
{
    vout_thread_sys_t *sys = vout->p;

    if (sys->display.use_dr)
        sys->display_pool = vout_display_Pool(sys->display.vd, 3);
    else
        sys->display_pool = NULL;
}",109.0,117.0,1.0,1.0,9.0,8,3,5,2,0,1,2,2,0,0,,0,1,2,1,1,void
2524,212467,vout_window_New,1,vout_window_New,"vout_window_t vout_window_New (vlc_object_t*,char*,vout_window_cfg_t*,vout_window_owner_t*)",video_output\window.c,"vout_window_t *vout_window_New(vlc_object_t *obj, const char *module,
                               const vout_window_cfg_t *cfg,
                               const vout_window_owner_t *owner)
{
    window_t *w = vlc_custom_create(obj, sizeof(*w), ""window"");
    vout_window_t *window = &w->wnd;

    memset(&window->handle, 0, sizeof(window->handle));
    window->info.has_double_click = false;
    window->control = NULL;
    window->sys = NULL;

    if (owner != NULL)
        window->owner = *owner;
    else
        window->owner.resized = NULL;

    w->module = vlc_module_load(window, ""vout window"", module,
                                module && *module,
                                vout_window_start, window, cfg);
    if (!w->module) {
        vlc_object_release(window);
        return NULL;
    }

    /* Hook for screensaver inhibition */
    if (var_InheritBool(obj, ""disable-screensaver"") &&
        (window->type == VOUT_WINDOW_TYPE_XID || window->type == VOUT_WINDOW_TYP...",54.0,91.0,1.0,1.0,38.0,41,11,41,12,2,10,5,6,2,4,,0,9,8,4,4,vout_window_t
2525,212628,vout_window_Delete,1,vout_window_Delete,void vout_window_Delete (vout_window_t*),video_output\window.c,"void vout_window_Delete(vout_window_t *window)
{
    if (!window)
        return;

    window_t *w = (window_t *)window;
    if (w->inhibit)
    {
        vlc_inhibit_Set (w->inhibit, VLC_INHIBIT_NONE);
        vlc_inhibit_Destroy (w->inhibit);
    }

    vlc_module_unload(window, w->module, vout_window_stop, window);
    vlc_object_release(window);
}",101.0,115.0,1.0,1.0,15.0,7,4,11,3,3,7,3,3,1,3,,0,4,2,1,1,void
2526,212667,vout_window_SetInhibition,1,vout_window_SetInhibition,"void vout_window_SetInhibition (vout_window_t*,bool)",video_output\window.c,"void vout_window_SetInhibition(vout_window_t *window, bool enabled)
{
    window_t *w = (window_t *)window;
    unsigned flags = enabled ? VLC_INHIBIT_VIDEO : VLC_INHIBIT_NONE;

    if (w->inhibit != NULL)
        vlc_inhibit_Set(w->inhibit, flags);
}",117.0,124.0,1.0,1.0,8.0,7,5,10,7,1,2,2,2,1,0,,0,2,4,2,2,void
2527,212704,vout_display_window_ResizeNotify,1,vout_display_window_ResizeNotify,"void vout_display_window_ResizeNotify (vout_window_t*,unsigned,unsigned)",video_output\window.c,"static void vout_display_window_ResizeNotify(vout_window_t *window,
                                             unsigned width, unsigned height)
{
    vout_display_window_t *state = window->owner.sys;

    msg_Dbg(window, ""resized to %ux%u"", width, height);
    vlc_mutex_lock(&state->lock);
    state->width = width;
    state->height = height;

    if (state->vd != NULL)
        vout_display_SendEventDisplaySize(state->vd, width, height);
    vlc_mutex_unlock(&state->lock);
}",141.0,154.0,1.0,1.0,14.0,14,5,16,5,0,2,2,2,0,2,,0,0,6,3,3,void
2528,212757,vout_display_window_CloseNotify,1,vout_display_window_CloseNotify,void vout_display_window_CloseNotify (vout_window_t*),video_output\window.c,"static void vout_display_window_CloseNotify(vout_window_t *window)
{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;

    vout_SendEventClose(vout);
}",156.0,161.0,1.0,1.0,6.0,4,4,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
2529,212774,vout_display_window_MouseEvent,1,vout_display_window_MouseEvent,"void vout_display_window_MouseEvent (vout_window_t*,vout_window_mouse_event_t*)",video_output\window.c,"static void vout_display_window_MouseEvent(vout_window_t *window,
                                           const vout_window_mouse_event_t *mouse)
{
    vout_thread_t *vout = (vout_thread_t *)window->obj.parent;
    vout_WindowMouseEvent(vout, mouse);
}",163.0,168.0,1.0,1.0,6.0,4,4,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
2530,212793,vout_display_window_New,1,vout_display_window_New,"vout_window_t vout_display_window_New (vout_thread_t*,vout_window_cfg_t*)",video_output\window.c,"vout_window_t *vout_display_window_New(vout_thread_t *vout,
                                       const vout_window_cfg_t *cfg)
{
    vout_display_window_t *state = malloc(sizeof (*state));
    if (state == NULL)
        return NULL;

    state->vd = NULL;
    state->width = cfg->width;
    state->height = cfg->height;
    vlc_mutex_init(&state->lock);

    vout_window_owner_t owner = {
        .sys = state,
        .resized = vout_display_window_ResizeNotify,
        .closed = vout_display_window_CloseNotify,
        .mouse_event = vout_display_window_MouseEvent,
    };
    vout_window_t *window;

    window = vout_window_New((vlc_object_t *)vout, ""$window"", cfg, &owner);
    if (window == NULL) {
        vlc_mutex_destroy(&state->lock);
        free(state);
    }
    return window;
}",173.0,199.0,1.0,1.0,27.0,26,8,27,10,2,3,3,3,0,3,,0,1,4,2,2,vout_window_t
2531,212882,vout_display_window_Attach,1,vout_display_window_Attach,"void vout_display_window_Attach (vout_window_t*,vout_display_t*)",video_output\window.c,"void vout_display_window_Attach(vout_window_t *window, vout_display_t *vd)
{
    vout_display_window_t *state = window->owner.sys;

    vout_window_SetSize(window,
                        vd->cfg->display.width, vd->cfg->display.height);

    vlc_mutex_lock(&state->lock);
    state->vd = vd;

    vout_display_SendEventDisplaySize(vd, state->width, state->height);
    vlc_mutex_unlock(&state->lock);
}",205.0,217.0,1.0,1.0,13.0,17,4,12,3,2,2,1,1,0,2,,0,0,4,2,2,void
2532,212935,vout_display_window_Detach,1,vout_display_window_Detach,void vout_display_window_Detach (vout_window_t*),video_output\window.c,"void vout_display_window_Detach(vout_window_t *window)
{
    vout_display_window_t *state = window->owner.sys;

    vlc_mutex_lock(&state->lock);
    state->vd = NULL;
    vlc_mutex_unlock(&state->lock);
}",223.0,230.0,1.0,1.0,8.0,9,4,6,3,2,2,1,1,0,2,,0,0,2,1,1,void
2533,212963,vout_display_window_Delete,1,vout_display_window_Delete,void vout_display_window_Delete (vout_window_t*),video_output\window.c,"void vout_display_window_Delete(vout_window_t *window)
{
    vout_display_window_t *state = window->owner.sys;

    vout_window_Delete(window);

    assert(state->vd == NULL);
    vlc_mutex_destroy(&state->lock);
    free(state);
}",236.0,245.0,1.0,1.0,10.0,7,5,7,3,3,2,1,1,0,2,,0,0,2,1,1,void
2534,214517,MtaMainLoop,1,MtaMainLoop,void* MtaMainLoop (void*),win32\mta_holder.h,"static inline void* MtaMainLoop( void* opaque )
{
    vlc_mta_holder* p_mta = (vlc_mta_holder*)opaque;
    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    vlc_sem_post( &p_mta->ready_sem );

    vlc_sem_wait( &p_mta->release_sem );

    CoUninitialize();
    return NULL;
}",40.0,51.0,1.0,1.0,12.0,6,4,7,4,0,4,1,1,0,2,,0,2,2,1,1,void*
2535,214544,vlc_mta_acquire,1,vlc_mta_acquire,bool vlc_mta_acquire (vlc_object_t*),win32\mta_holder.h,"static inline bool vlc_mta_acquire( vlc_object_t *p_parent )
{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder* p_mta = (vlc_mta_holder*)var_CreateGetAddress( p_parent->obj.libvlc, ""mta-holder"" );
    if ( p_mta == NULL )
    {
        p_mta = (vlc_mta_holder*)malloc( sizeof( *p_mta ) );
        if ( unlikely( p_mta == NULL ) )
        {
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        vlc_sem_init( &p_mta->ready_sem, 0 );
        vlc_sem_init( &p_mta->release_sem, 0 );
        p_mta->i_refcount = 1;
        if ( vlc_clone( &p_mta->thread, MtaMainLoop, p_mta, VLC_THREAD_PRIORITY_LOW ) )
        {
            vlc_sem_destroy( &p_mta->release_sem );
            vlc_sem_destroy( &p_mta->ready_sem );
            free( p_mta );
            p_mta = NULL;
            vlc_global_unlock( VLC_MTA_MUTEX );
            return false;
        }
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", p_mta );
        vlc_sem_wait( &p_mta->rea...",62.0,93.0,1.0,1.0,32.0,27,8,29,7,0,13,4,6,2,6,,0,8,2,1,1,bool
2536,214655,vlc_mta_release,1,vlc_mta_release,void vlc_mta_release (vlc_object_t*),win32\mta_holder.h,"static inline void vlc_mta_release( vlc_object_t* p_parent )
{
    vlc_global_lock( VLC_MTA_MUTEX );
    vlc_mta_holder *p_mta = (vlc_mta_holder*)var_InheritAddress( p_parent->obj.libvlc, ""mta-holder"" );
    assert( p_mta != NULL );
    int i_refcount = --p_mta->i_refcount;
    if ( i_refcount == 0 )
        var_SetAddress( p_parent->obj.libvlc, ""mta-holder"", NULL );
    vlc_global_unlock( VLC_MTA_MUTEX );
    if ( i_refcount == 0 )
    {
        vlc_sem_post( &p_mta->release_sem );

        vlc_join( p_mta->thread, NULL );

        vlc_sem_destroy( &p_mta->release_sem );
        vlc_sem_destroy( &p_mta->ready_sem );
        free( p_mta );
    }
}",100.0,119.0,1.0,1.0,20.0,19,8,18,5,0,9,3,3,0,4,,0,5,2,1,1,void
2537,215783,vlc_threadvars_cleanup,1,vlc_threadvars_cleanup,void vlc_threadvars_cleanup (void),win32\thread.c,"static void vlc_threadvars_cleanup(void)
{
    vlc_threadvar_t key;
retry:
    /* TODO: use RW lock or something similar */
    EnterCriticalSection(&super_mutex);
    for (key = vlc_threadvar_last; key != NULL; key = key->prev)
    {
        void *value = vlc_threadvar_get(key);
        if (value != NULL && key->destroy != NULL)
        {
            LeaveCriticalSection(&super_mutex);
            vlc_threadvar_set(key, NULL);
            key->destroy(value);
            goto retry;
        }
    }
    LeaveCriticalSection(&super_mutex);
}",300.0,318.0,1.0,1.0,19.0,11,5,17,5,0,6,4,4,0,2,,0,5,2,1,1,void
2538,216612,mdate_multimedia,1,mdate_multimedia,mtime_t mdate_multimedia (void),win32\thread.c,"static mtime_t mdate_multimedia (void)
{
    DWORD ts = clk.multimedia.timeGetTime ();

    /* milliseconds */
    static_assert ((CLOCK_FREQ % 1000) == 0, ""Broken frequencies ratio"");
    return ts * (CLOCK_FREQ / 1000);
}",771.0,778.0,1.0,1.0,8.0,7,6,5,3,0,1,1,1,0,0,,0,1,2,1,1,mtime_t
2539,216639,mdate_perf,1,mdate_perf,mtime_t mdate_perf (void),win32\thread.c,"static mtime_t mdate_perf (void)
{
    /* We don't need the real date, just the value of a high precision timer */
    LARGE_INTEGER counter;
    if (!QueryPerformanceCounter (&counter))
        abort ();

    /* Convert to from (1/freq) to microsecond resolution */
    /* We need to split the division to avoid 63-bits overflow */
    lldiv_t d = lldiv (counter.QuadPart, clk.perf.freq.QuadPart);

    return (d.quot * 1000000) + ((d.rem * 1000000) / clk.perf.freq.QuadPart);
}",781.0,793.0,1.0,1.0,13.0,16,7,7,3,1,2,2,2,0,0,,0,2,2,1,1,mtime_t
2540,216725,mdate_default,1,mdate_default,mtime_t mdate_default (void),win32\thread.c,"static mtime_t mdate_default(void)
{
    vlc_threads_setup(NULL);
    return mdate_perf();
}",812.0,816.0,1.0,1.0,5.0,0,0,1,1,0,2,1,1,0,2,,0,0,2,1,1,mtime_t
2541,101733,pp_YUV_fallback,2,misc\fourcc.c.pp_YUV_fallback,,misc\fourcc.c,ANY pp_YUV_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2542,101784,p_list_YUV,2,misc\fourcc.c.p_list_YUV,,misc\fourcc.c,ANY p_list_YUV,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2543,101879,p_RGB32_fallback,2,misc\fourcc.c.p_RGB32_fallback,,misc\fourcc.c,ANY p_RGB32_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2544,101929,pp_RGB_fallback,2,misc\fourcc.c.pp_RGB_fallback,,misc\fourcc.c,ANY pp_RGB_fallback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2545,102122,p_list_chroma_description,2,misc\fourcc.c.p_list_chroma_description,,misc\fourcc.c,static const[] p_list_chroma_description,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2546,111330,mime_table,2,misc\image.c.mime_table,,misc\image.c,static const[] mime_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2547,119019,ext_mime,2,misc\mime.c.ext_mime,,misc\mime.c,static const[] ext_mime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2548,120288,name_lock,2,misc\objects.c.name_lock,,misc\objects.c,vlc_mutex_t name_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2549,124674,rand48,2,misc\rand.c.rand48,,misc\rand.c,struct rand48,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
2550,133668,void_ops,2,misc\variables.c.void_ops,,misc\variables.c,const struct variable_ops_t void_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2551,133669,addr_ops,2,misc\variables.c.addr_ops,,misc\variables.c,const struct variable_ops_t addr_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2552,133670,bool_ops,2,misc\variables.c.bool_ops,,misc\variables.c,const struct variable_ops_t bool_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2553,133671,float_ops,2,misc\variables.c.float_ops,,misc\variables.c,const struct variable_ops_t float_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2554,133672,int_ops,2,misc\variables.c.int_ops,,misc\variables.c,const struct variable_ops_t int_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2555,133673,string_ops,2,misc\variables.c.string_ops,,misc\variables.c,const struct variable_ops_t string_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2556,133674,coords_ops,2,misc\variables.c.coords_ops,,misc\variables.c,const struct variable_ops_t coords_ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2557,138230,modules,2,modules\bank.c.modules,,modules\bank.c,struct modules,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
2558,138238,vlc_plugins,2,modules\bank.c.vlc_plugins,,modules\bank.c,vlc_plugin_t* vlc_plugins,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2559,138424,vlc_static_modules,2,modules\bank.c.vlc_static_modules,,modules\bank.c,"int(*[])(int(*)(void*,void*,int),void*) vlc_static_modules",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2560,145009,httpd,2,network\httpd.c.httpd,,network\httpd.c,struct httpd httpd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2561,156122,hpipeIPC,2,os2\specific.c.hpipeIPC,,os2\specific.c,HPIPE hpipeIPC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2562,156126,tidIPCFirst,2,os2\specific.c.tidIPCFirst,,os2\specific.c,static int tidIPCFirst,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2563,156131,tidIPCHelper,2,os2\specific.c.tidIPCHelper,,os2\specific.c,static int tidIPCHelper,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2564,156618,thread_key,2,os2\thread.c.thread_key,,os2\thread.c,vlc_threadvar_t thread_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2565,156782,super_mutex,2,os2\thread.c.super_mutex,,os2\thread.c,vlc_mutex_t super_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2566,157008,static_condvar_start,2,os2\thread.c.static_condvar_start,,os2\thread.c,vlc_static_cond_t* static_condvar_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2567,157421,vlc_threadvar_last,2,os2\thread.c.vlc_threadvar_last,,os2\thread.c,struct vlc_threadvar* vlc_threadvar_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2568,167458,sorting_fns,2,playlist\sort.c.sorting_fns,,playlist\sort.c,int  sorting_fns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2569,172111,okey,2,posix\rand.c.okey,,posix\rand.c,static uint8_t[64] okey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2570,172112,ikey,2,posix\rand.c.ikey,,posix\rand.c,static uint8_t[64] ikey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2571,178849,unknown_language,2,text\iso_lang.c.unknown_language,,text\iso_lang.c,const iso639_lang_t unknown_language,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2572,191553,deinterlace_modes,2,video_output\interlacing.c.deinterlace_modes,,video_output\interlacing.c,char[][9] deinterlace_modes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2573,215389,super_mutex,2,win32\thread.c.super_mutex,,win32\thread.c,CRITICAL_SECTION super_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2574,215595,vlc_threadvar_last,2,win32\thread.c.vlc_threadvar_last,,win32\thread.c,struct vlc_threadvar* vlc_threadvar_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2575,216558,clk,2,win32\thread.c.clk,,win32\thread.c,union clk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2576,56,s_jvm,2,android\specific.c.s_jvm,,android\specific.c,JavaVM* s_jvm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2577,60,ppsz_generic_names,2,android\specific.c.ppsz_generic_names,,android\specific.c,char*[] ppsz_generic_names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2578,76,fields,2,android\specific.c.fields,,android\specific.c,struct fields,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
2579,8306,unset_str,2,audio_output\output.c.unset_str,,audio_output\output.c,char[1] unset_str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2580,13538,config_lock,2,config\core.c.config_lock,,config\core.c,vlc_rwlock_t config_lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
2581,13542,config_dirty,2,config\core.c.config_dirty,,config\core.c,bool config_dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2582,14614,config,2,config\core.c.config,,config\core.c,struct config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2583,20211,vlc_clock_conversion_factor,2,darwin\thread.c.vlc_clock_conversion_factor,,darwin\thread.c,mach_timebase_info_data_t vlc_clock_conversion_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2584,21358,ISO6937toUCS4,2,extras\libc.c.ISO6937toUCS4,,extras\libc.c,ANY ISO6937toUCS4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2585,21618,ISO6937_2toUCS4,2,extras\libc.c.ISO6937_2toUCS4,,extras\libc.c,ANY ISO6937_2toUCS4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2586,21878,to_ucs4_comb,2,extras\libc.c.to_ucs4_comb,,extras\libc.c,ANY to_ucs4_comb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2587,36233,es_out_pgrm_t,2,input\es_out.c.es_out_pgrm_t,,input\es_out.c,struct es_out_pgrm_t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2588,37131,es_cat,2,input\es_out.c.es_cat,,input\es_out.c,static es_out_id_t[] es_cat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2589,79543,vlm_mutex,2,input\vlm.c.vlm_mutex,,input\vlm.c,vlc_mutex_t vlm_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2590,85977,lock,2,interface\interface.c.lock,,interface\interface.c,vlc_mutex_t lock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
2591,88750,s_keys,2,misc\actions.c.s_keys,,misc\actions.c,key_descriptor[] s_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2592,89508,s_names2actions,2,misc\actions.c.s_names2actions,,misc\actions.c,name2action[] s_names2actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
