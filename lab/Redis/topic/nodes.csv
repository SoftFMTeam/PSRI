,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,265,flags,3,aclSelector.flags,,acl.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1,266,allowed_commands,3,aclSelector.allowed_commands,,acl.c,allowed_commands[USER_COMMAND_BITS_COUNT/64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
2,267,allowed_firstargs,3,aclSelector.allowed_firstargs,,acl.c,**allowed_firstargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
3,268,patterns,3,aclSelector.patterns,,acl.c,*patterns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
4,269,channels,3,aclSelector.channels,,acl.c,*channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
5,270,command_rules,3,aclSelector.command_rules,,acl.c,command_rules,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
6,612,flags,3,keyPattern.flags,,acl.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7,613,pattern,3,keyPattern.pattern,,acl.c,pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8,5422,keys_init,3,aclKeyResultCache.keys_init,,acl.c,keys_init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
9,5423,keys,3,aclKeyResultCache.keys,,acl.c,keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
10,8189,count,3,ACLLogEntry.count,,acl.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
11,8190,reason,3,ACLLogEntry.reason,,acl.c,reason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
12,8191,context,3,ACLLogEntry.context,,acl.c,context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
13,8192,object,3,ACLLogEntry.object,,acl.c,object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
14,8193,username,3,ACLLogEntry.username,,acl.c,username,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
15,8194,ctime,3,ACLLogEntry.ctime,,acl.c,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
16,8195,cinfo,3,ACLLogEntry.cinfo,,acl.c,cinfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
17,8196,entry_id,3,ACLLogEntry.entry_id,,acl.c,entry_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
18,8197,timestamp_created,3,ACLLogEntry.timestamp_created,,acl.c,timestamp_created,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
19,11714,prev,3,listNode.prev,,adlist.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
20,11716,next,3,listNode.next,,adlist.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
21,11717,value,3,listNode.value,,adlist.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,173,0,1,1,0,0,,0,0,0,0,0,
22,11720,next,3,listIter.next,,adlist.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
23,11721,direction,3,listIter.direction,,adlist.h,direction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
24,11724,head,3,list.head,,adlist.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,
25,11725,tail,3,list.tail,,adlist.h,*tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
26,11742,len,3,list.len,,adlist.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,60,0,1,1,0,0,,0,0,0,0,0,
27,13516,mask,3,aeFileEvent.mask,,ae.h,mask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
28,13517,rfileProc,3,aeFileEvent.rfileProc,,ae.h,*rfileProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
29,13518,wfileProc,3,aeFileEvent.wfileProc,,ae.h,*wfileProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
30,13519,clientData,3,aeFileEvent.clientData,,ae.h,*clientData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
31,13522,id,3,aeTimeEvent.id,,ae.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
32,13523,when,3,aeTimeEvent.when,,ae.h,when,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
33,13524,timeProc,3,aeTimeEvent.timeProc,,ae.h,*timeProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
34,13525,finalizerProc,3,aeTimeEvent.finalizerProc,,ae.h,*finalizerProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
35,13526,clientData,3,aeTimeEvent.clientData,,ae.h,*clientData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
36,13528,prev,3,aeTimeEvent.prev,,ae.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
37,13530,next,3,aeTimeEvent.next,,ae.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
38,13531,refcount,3,aeTimeEvent.refcount,,ae.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
39,13538,maxfd,3,aeEventLoop.maxfd,,ae.h,maxfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
40,13539,setsize,3,aeEventLoop.setsize,,ae.h,setsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
41,13540,timeEventNextId,3,aeEventLoop.timeEventNextId,,ae.h,timeEventNextId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
42,13541,events,3,aeEventLoop.events,,ae.h,*events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
43,13542,fired,3,aeEventLoop.fired,,ae.h,*fired,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
44,13543,timeEventHead,3,aeEventLoop.timeEventHead,,ae.h,*timeEventHead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
45,13544,stop,3,aeEventLoop.stop,,ae.h,stop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
46,13545,apidata,3,aeEventLoop.apidata,,ae.h,*apidata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
47,13546,beforesleep,3,aeEventLoop.beforesleep,,ae.h,*beforesleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
48,13547,aftersleep,3,aeEventLoop.aftersleep,,ae.h,*aftersleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
49,13548,flags,3,aeEventLoop.flags,,ae.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
50,13668,epfd,3,aeApiState.epfd,,ae_epoll.c,epfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
51,13670,events,3,aeApiState.events,,ae_epoll.c,*events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
52,14163,npending,3,aeApiState.npending,,ae_evport.c,npending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
53,14164,pending_fds,3,aeApiState.pending_fds,,ae_evport.c,pending_fds[MAX_EVENT_BATCHSZ],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
54,33123,offset,3,bitfieldOp.offset,,bitops.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
55,33124,i64,3,bitfieldOp.i64,,bitops.c,i64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
56,33125,opcode,3,bitfieldOp.opcode,,bitops.c,opcode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
57,33126,owtype,3,bitfieldOp.owtype,,bitops.c,owtype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
58,33127,bits,3,bitfieldOp.bits,,bitops.c,bits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
59,33128,sign,3,bitfieldOp.sign,,bitops.c,sign,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
60,36206,private_data,3,CallReply.private_data,,call_reply.c,*private_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
61,36207,original_proto,3,CallReply.original_proto,,call_reply.c,original_proto,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
62,36208,proto,3,CallReply.proto,,call_reply.c,*proto,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
63,36209,proto_len,3,CallReply.proto_len,,call_reply.c,proto_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
64,36210,type,3,CallReply.type,,call_reply.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
65,36211,flags,3,CallReply.flags,,call_reply.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
66,36212,len,3,CallReply.len,,call_reply.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
67,36224,deferred_error_list,3,CallReply.deferred_error_list,,call_reply.c,*deferred_error_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
68,36226,attribute,3,CallReply.attribute,,call_reply.c,*attribute,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
69,38007,keys,3,child_info_data.keys,,childinfo.c,keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
70,38008,cow,3,child_info_data.cow,,childinfo.c,cow,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
71,38009,cow_updated,3,child_info_data.cow_updated,,childinfo.c,cow_updated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
72,38010,progress,3,child_info_data.progress,,childinfo.c,progress,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
73,38011,information_type,3,child_info_data.information_type,,childinfo.c,information_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
74,38559,name,3,cliCommandArg.name,,cli_commands.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
75,38560,type,3,cliCommandArg.type,,cli_commands.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
76,38561,token,3,cliCommandArg.token,,cli_commands.h,*token,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
77,38563,flags,3,cliCommandArg.flags,,cli_commands.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
78,38564,numsubargs,3,cliCommandArg.numsubargs,,cli_commands.h,numsubargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
79,38566,subargs,3,cliCommandArg.subargs,,cli_commands.h,*subargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
80,38567,display_text,3,cliCommandArg.display_text,,cli_commands.h,*display_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
81,38568,matched,3,cliCommandArg.matched,,cli_commands.h,matched,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
82,38569,matched_token,3,cliCommandArg.matched_token,,cli_commands.h,matched_token,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
83,38570,matched_name,3,cliCommandArg.matched_name,,cli_commands.h,matched_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
84,38571,matched_all,3,cliCommandArg.matched_all,,cli_commands.h,matched_all,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
85,38574,name,3,commandDocs.name,,cli_commands.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
86,38575,summary,3,commandDocs.summary,,cli_commands.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
87,38576,group,3,commandDocs.group,,cli_commands.h,*group,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
88,38577,since,3,commandDocs.since,,cli_commands.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
89,38578,numargs,3,commandDocs.numargs,,cli_commands.h,numargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
90,38579,args,3,commandDocs.args,,cli_commands.h,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
91,38581,subcommands,3,commandDocs.subcommands,,cli_commands.h,*subcommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
92,38582,params,3,commandDocs.params,,cli_commands.h,*params,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
93,39457,hostip,3,cliConnInfo.hostip,,cli_common.h,*hostip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
94,39458,hostport,3,cliConnInfo.hostport,,cli_common.h,hostport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
95,39459,input_dbnum,3,cliConnInfo.input_dbnum,,cli_common.h,input_dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
96,39460,auth,3,cliConnInfo.auth,,cli_common.h,*auth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
97,39461,user,3,cliConnInfo.user,,cli_common.h,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
98,40441,totlen,3,clusterMsgSendBlock.totlen,,cluster.c,totlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
99,40442,refcount,3,clusterMsgSendBlock.refcount,,cluster.c,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
100,40443,msg,3,clusterMsgSendBlock.msg,,cluster.c,msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
101,63291,conn,3,migrateCachedSocket.conn,,cluster.c,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
102,63292,last_dbid,3,migrateCachedSocket.last_dbid,,cluster.c,last_dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
103,63293,last_use_time,3,migrateCachedSocket.last_use_time,,cluster.c,last_use_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
104,66721,ctime,3,clusterLink.ctime,,cluster.h,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
105,66722,conn,3,clusterLink.conn,,cluster.h,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
106,66723,send_msg_queue,3,clusterLink.send_msg_queue,,cluster.h,*send_msg_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
107,66724,head_msg_send_offset,3,clusterLink.head_msg_send_offset,,cluster.h,head_msg_send_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
108,66725,send_msg_queue_mem,3,clusterLink.send_msg_queue_mem,,cluster.h,send_msg_queue_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
109,66726,rcvbuf,3,clusterLink.rcvbuf,,cluster.h,*rcvbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
110,66727,rcvbuf_len,3,clusterLink.rcvbuf_len,,cluster.h,rcvbuf_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
111,66728,rcvbuf_alloc,3,clusterLink.rcvbuf_alloc,,cluster.h,rcvbuf_alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
112,66730,node,3,clusterLink.node,,cluster.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,35,0,1,1,0,0,,0,0,0,0,0,
113,66731,inbound,3,clusterLink.inbound,,cluster.h,inbound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
114,66735,node,3,clusterNodeFailReport.node,,cluster.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
115,66736,time,3,clusterNodeFailReport.time,,cluster.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
116,66739,ctime,3,clusterNode.ctime,,cluster.h,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
117,66741,shard_id,3,clusterNode.shard_id,,cluster.h,shard_id[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
118,66743,configEpoch,3,clusterNode.configEpoch,,cluster.h,configEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
119,66745,slot_info_pairs,3,clusterNode.slot_info_pairs,,cluster.h,*slot_info_pairs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
120,66746,slot_info_pairs_count,3,clusterNode.slot_info_pairs_count,,cluster.h,slot_info_pairs_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
121,66747,numslots,3,clusterNode.numslots,,cluster.h,numslots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
122,66748,numslaves,3,clusterNode.numslaves,,cluster.h,numslaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
123,66750,slaves,3,clusterNode.slaves,,cluster.h,**slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
124,66752,slaveof,3,clusterNode.slaveof,,cluster.h,*slaveof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
125,66754,ping_sent,3,clusterNode.ping_sent,,cluster.h,ping_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
126,66755,pong_received,3,clusterNode.pong_received,,cluster.h,pong_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
127,66756,data_received,3,clusterNode.data_received,,cluster.h,data_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
128,66757,fail_time,3,clusterNode.fail_time,,cluster.h,fail_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
129,66759,repl_offset_time,3,clusterNode.repl_offset_time,,cluster.h,repl_offset_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
130,66761,repl_offset,3,clusterNode.repl_offset,,cluster.h,repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
131,66763,hostname,3,clusterNode.hostname,,cluster.h,hostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
132,66764,human_nodename,3,clusterNode.human_nodename,,cluster.h,human_nodename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
133,66765,tcp_port,3,clusterNode.tcp_port,,cluster.h,tcp_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
134,66766,tls_port,3,clusterNode.tls_port,,cluster.h,tls_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
135,66767,cport,3,clusterNode.cport,,cluster.h,cport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
136,66768,link,3,clusterNode.link,,cluster.h,*link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
137,66769,inbound_link,3,clusterNode.inbound_link,,cluster.h,*inbound_link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
138,66770,fail_reports,3,clusterNode.fail_reports,,cluster.h,*fail_reports,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
139,66793,count,3,slotToKeys.count,,cluster.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
140,66794,head,3,slotToKeys.head,,cluster.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
141,66811,db,3,clusterDictMetadata.db,,cluster.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
142,66874,nodename,3,clusterMsgDataGossip.nodename,,cluster.h,nodename[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
143,66875,ping_sent,3,clusterMsgDataGossip.ping_sent,,cluster.h,ping_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
144,66876,pong_received,3,clusterMsgDataGossip.pong_received,,cluster.h,pong_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
145,66877,ip,3,clusterMsgDataGossip.ip,,cluster.h,ip[NET_IP_STR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
146,66878,port,3,clusterMsgDataGossip.port,,cluster.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
147,66879,cport,3,clusterMsgDataGossip.cport,,cluster.h,cport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
148,66880,flags,3,clusterMsgDataGossip.flags,,cluster.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
149,66881,pport,3,clusterMsgDataGossip.pport,,cluster.h,pport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
150,66882,notused1,3,clusterMsgDataGossip.notused1,,cluster.h,notused1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
151,66954,hostname,3,clusterMsgPingExtHostname.hostname,,cluster.h,hostname[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
152,66963,human_nodename,3,clusterMsgPingExtHumanNodename.human_nodename,,cluster.h,human_nodename[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
153,66972,name,3,clusterMsgPingExtForgottenNode.name,,cluster.h,name[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
154,66973,ttl,3,clusterMsgPingExtForgottenNode.ttl,,cluster.h,ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
155,66985,shard_id,3,clusterMsgPingExtShardId.shard_id,,cluster.h,shard_id[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
156,66996,length,3,clusterMsgPingExt.length,,cluster.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
157,66997,type,3,clusterMsgPingExt.type,,cluster.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
158,67035,totlen,3,clusterMsg.totlen,,cluster.h,totlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
159,67036,ver,3,clusterMsg.ver,,cluster.h,ver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
160,67037,port,3,clusterMsg.port,,cluster.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
161,67038,type,3,clusterMsg.type,,cluster.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
162,67039,count,3,clusterMsg.count,,cluster.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
163,67040,currentEpoch,3,clusterMsg.currentEpoch,,cluster.h,currentEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
164,67041,configEpoch,3,clusterMsg.configEpoch,,cluster.h,configEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
165,67042,offset,3,clusterMsg.offset,,cluster.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
166,67043,sender,3,clusterMsg.sender,,cluster.h,sender[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
167,67044,myslots,3,clusterMsg.myslots,,cluster.h,myslots[CLUSTER_SLOTS/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
168,67045,slaveof,3,clusterMsg.slaveof,,cluster.h,slaveof[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
169,67046,myip,3,clusterMsg.myip,,cluster.h,myip[NET_IP_STR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
170,67047,extensions,3,clusterMsg.extensions,,cluster.h,extensions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
171,67049,pport,3,clusterMsg.pport,,cluster.h,pport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
172,67050,cport,3,clusterMsg.cport,,cluster.h,cport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
173,67051,flags,3,clusterMsg.flags,,cluster.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
174,67053,mflags,3,clusterMsg.mflags,,cluster.h,mflags[3],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
175,67055,data,3,clusterMsg.data,,cluster.h,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
176,67322,name,3,redisCommandArg.name,,commands.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
177,67330,num_args,3,redisCommandArg.num_args,,commands.h,num_args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
178,67332,subargs,3,redisCommandArg.subargs,,commands.h,*subargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
179,67932,name,3,standardConfig.name,,config.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
180,67933,alias,3,standardConfig.alias,,config.c,*alias,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
181,67934,flags,3,standardConfig.flags,,config.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,43,0,1,1,0,0,,0,0,0,0,0,
182,67935,interface,3,standardConfig.interface,,config.c,interface,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
183,67936,data,3,standardConfig.data,,config.c,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,137,0,1,1,0,0,,0,0,0,0,0,
184,67937,type,3,standardConfig.type,,config.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
185,67938,privdata,3,standardConfig.privdata,,config.c,*privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
186,70734,option_to_line,3,rewriteConfigState.option_to_line,,config.c,*option_to_line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
187,70735,rewritten,3,rewriteConfigState.rewritten,,config.c,*rewritten,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
188,70736,numlines,3,rewriteConfigState.numlines,,config.c,numlines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
189,70737,lines,3,rewriteConfigState.lines,,config.c,*lines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
190,70738,needs_signature,3,rewriteConfigState.needs_signature,,config.c,needs_signature,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
191,70739,force_write,3,rewriteConfigState.force_write,,config.c,force_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
192,98135,accept_handler,3,ConnectionType.accept_handler,,connection.h,*accept_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
193,98279,type,3,connection.type,,connection.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
194,98280,state,3,connection.state,,connection.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
195,98281,last_errno,3,connection.last_errno,,connection.h,last_errno,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
196,98282,fd,3,connection.fd,,connection.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
197,98283,flags,3,connection.flags,,connection.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
198,98284,refs,3,connection.refs,,connection.h,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
199,98285,iovcnt,3,connection.iovcnt,,connection.h,iovcnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
200,98286,private_data,3,connection.private_data,,connection.h,*private_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
201,98287,conn_handler,3,connection.conn_handler,,connection.h,conn_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
202,98288,write_handler,3,connection.write_handler,,connection.h,write_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
203,98289,read_handler,3,connection.read_handler,,connection.h,read_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
204,98291,fd,3,connListener.fd,,connection.h,fd[CONFIG_BINDADDR_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
205,98292,count,3,connListener.count,,connection.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
206,98293,bindaddr,3,connListener.bindaddr,,connection.h,**bindaddr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
207,98294,bindaddr_count,3,connListener.bindaddr_count,,connection.h,bindaddr_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
208,98295,port,3,connListener.port,,connection.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
209,98296,ct,3,connListener.ct,,connection.h,*ct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
210,98297,priv,3,connListener.priv,,connection.h,*priv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
211,104066,keys,3,scanData.keys,,db.c,*keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
212,104067,o,3,scanData.o,,db.c,*o,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
213,104068,type,3,scanData.type,,db.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
214,104069,pattern,3,scanData.pattern,,db.c,pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
215,104070,sampled,3,scanData.sampled,,db.c,sampled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
216,116284,key,3,dictEntry.key,,dict.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
217,116290,v,3,dictEntry.v,,dict.c,v,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
218,116293,metadata,3,dictEntry.metadata,,dict.c,*metadata[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
219,116300,key,3,dictEntryNoValue.key,,dict.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
220,116301,next,3,dictEntryNoValue.next,,dict.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
221,122629,type,3,dict.type,,dict.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,47,0,1,1,0,0,,0,0,0,0,0,
222,122630,ht_table,3,dict.ht_table,,dict.h,**ht_table[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
223,122631,ht_used,3,dict.ht_used,,dict.h,ht_used[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,95,0,1,1,0,0,,0,0,0,0,0,
224,122632,rehashidx,3,dict.rehashidx,,dict.h,rehashidx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
225,122633,pauserehash,3,dict.pauserehash,,dict.h,pauserehash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
226,122634,ht_size_exp,3,dict.ht_size_exp,,dict.h,ht_size_exp[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,118,0,1,1,0,0,,0,0,0,0,0,
227,122635,metadata,3,dict.metadata,,dict.h,*metadata[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
228,122648,d,3,dictIterator.d,,dict.h,*d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
229,122649,index,3,dictIterator.index,,dict.h,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
230,122650,table,3,dictIterator.table,,dict.h,table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
231,122651,safe,3,dictIterator.safe,,dict.h,safe,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
232,122652,entry,3,dictIterator.entry,,dict.h,*entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
233,122653,nextEntry,3,dictIterator.nextEntry,,dict.h,*nextEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
234,122668,defragAlloc,3,dictDefragFunctions.defragAlloc,,dict.h,*defragAlloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
235,122669,defragKey,3,dictDefragFunctions.defragKey,,dict.h,*defragKey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
236,122670,defragVal,3,dictDefragFunctions.defragVal,,dict.h,*defragVal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
237,123364,lua,3,luaCtx.lua,,eval.c,*lua,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
238,123365,lua_client,3,luaCtx.lua_client,,eval.c,*lua_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
239,123366,lua_scripts,3,luaCtx.lua_scripts,,eval.c,*lua_scripts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
240,123367,lua_scripts_mem,3,luaCtx.lua_scripts_mem,,eval.c,lua_scripts_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
241,123370,conn,3,ldbState.conn,,eval.c,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
242,123371,active,3,ldbState.active,,eval.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
243,123372,forked,3,ldbState.forked,,eval.c,forked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
244,123373,logs,3,ldbState.logs,,eval.c,*logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
245,123375,children,3,ldbState.children,,eval.c,*children,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
246,123376,bp,3,ldbState.bp,,eval.c,bp[LDB_BREAKPOINTS_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
247,123377,bpcount,3,ldbState.bpcount,,eval.c,bpcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
248,123378,step,3,ldbState.step,,eval.c,step,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
249,123379,luabp,3,ldbState.luabp,,eval.c,luabp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
250,123380,src,3,ldbState.src,,eval.c,*src,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
251,123381,lines,3,ldbState.lines,,eval.c,lines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
252,123382,currentline,3,ldbState.currentline,,eval.c,currentline,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
253,123383,cbuf,3,ldbState.cbuf,,eval.c,cbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
254,123384,maxlen,3,ldbState.maxlen,,eval.c,maxlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
255,123385,maxlen_hint_sent,3,ldbState.maxlen_hint_sent,,eval.c,maxlen_hint_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
256,130822,db,3,expireScanData.db,,expire.c,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
257,130823,now,3,expireScanData.now,,expire.c,now,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
258,130824,sampled,3,expireScanData.sampled,,expire.c,sampled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
259,130825,expired,3,expireScanData.expired,,expire.c,expired,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
260,130826,ttl_sum,3,expireScanData.ttl_sum,,expire.c,ttl_sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
261,130827,ttl_samples,3,expireScanData.ttl_samples,,expire.c,ttl_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
262,132644,lua,3,luaEngineCtx.lua,,function_lua.c,*lua,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
263,132647,lua_function_ref,3,luaFunctionCtx.lua_function_ref,,function_lua.c,lua_function_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
264,132650,li,3,loadCtx.li,,function_lua.c,*li,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
265,132651,start_time,3,loadCtx.start_time,,function_lua.c,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
266,132654,name,3,registerFunctionArgs.name,,function_lua.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
267,132655,desc,3,registerFunctionArgs.desc,,function_lua.c,desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
268,132656,lua_f_ctx,3,registerFunctionArgs.lua_f_ctx,,function_lua.c,*lua_f_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
269,132657,f_flags,3,registerFunctionArgs.f_flags,,function_lua.c,f_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
270,133961,n_lib,3,functionsLibEngineStats.n_lib,,functions.c,n_lib,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
271,133962,n_functions,3,functionsLibEngineStats.n_functions,,functions.c,n_functions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
272,133965,libraries,3,functionsLibCtx.libraries,,functions.c,*libraries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
273,133966,functions,3,functionsLibCtx.functions,,functions.c,*functions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
274,133967,cache_memory,3,functionsLibCtx.cache_memory,,functions.c,cache_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
275,133968,engines_stats,3,functionsLibCtx.engines_stats,,functions.c,*engines_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
276,133970,engine,3,functionsLibMataData.engine,,functions.c,engine,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
277,133971,name,3,functionsLibMataData.name,,functions.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
278,133972,code,3,functionsLibMataData.code,,functions.c,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
279,137418,engine_ctx,3,engine.engine_ctx,,functions.h,*engine_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
280,137461,name,3,engineInfo.name,,functions.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
281,137462,engine,3,engineInfo.engine,,functions.h,*engine,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
282,137466,name,3,functionInfo.name,,functions.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
283,137467,function,3,functionInfo.function,,functions.h,*function,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
284,137468,li,3,functionInfo.li,,functions.h,* li,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
285,137469,desc,3,functionInfo.desc,,functions.h,desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
286,137470,f_flags,3,functionInfo.f_flags,,functions.h,f_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
287,137473,name,3,functionLibInfo.name,,functions.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
288,137474,functions,3,functionLibInfo.functions,,functions.h,*functions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
289,137475,ei,3,functionLibInfo.ei,,functions.h,*ei,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
290,137476,code,3,functionLibInfo.code,,functions.h,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
291,141338,longitude,3,geoPoint.longitude,,geo.h,longitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
292,141339,latitude,3,geoPoint.latitude,,geo.h,latitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
293,141340,dist,3,geoPoint.dist,,geo.h,dist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
294,141341,score,3,geoPoint.score,,geo.h,score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
295,141342,member,3,geoPoint.member,,geo.h,*member,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
296,141346,array,3,geoArray.array,,geo.h,*array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
297,141347,buckets,3,geoArray.buckets,,geo.h,buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
298,141348,used,3,geoArray.used,,geo.h,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
299,142720,bits,3,GeoHashBits.bits,,geohash.h,bits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
300,142721,step,3,GeoHashBits.step,,geohash.h,step,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
301,142724,min,3,GeoHashRange.min,,geohash.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
302,142725,max,3,GeoHashRange.max,,geohash.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
303,142728,hash,3,GeoHashArea.hash,,geohash.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
304,142729,longitude,3,GeoHashArea.longitude,,geohash.h,longitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
305,142730,latitude,3,GeoHashArea.latitude,,geohash.h,latitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
306,142733,north,3,GeoHashNeighbors.north,,geohash.h,north,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
307,142734,east,3,GeoHashNeighbors.east,,geohash.h,east,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
308,142735,west,3,GeoHashNeighbors.west,,geohash.h,west,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
309,142736,south,3,GeoHashNeighbors.south,,geohash.h,south,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
310,142737,north_east,3,GeoHashNeighbors.north_east,,geohash.h,north_east,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
311,142738,south_east,3,GeoHashNeighbors.south_east,,geohash.h,south_east,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
312,142739,north_west,3,GeoHashNeighbors.north_west,,geohash.h,north_west,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
313,142740,south_west,3,GeoHashNeighbors.south_west,,geohash.h,south_west,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
314,142743,type,3,GeoShape.type,,geohash.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
315,142744,xy,3,GeoShape.xy,,geohash.h,xy[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
316,142745,conversion,3,GeoShape.conversion,,geohash.h,conversion,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
317,142746,bounds,3,GeoShape.bounds,,geohash.h,bounds[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
318,142753,t,3,GeoShape.t,,geohash.h,t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
319,143910,hash,3,GeoHashRadius.hash,,geohash_helper.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
320,143911,area,3,GeoHashRadius.area,,geohash_helper.h,area,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
321,143912,neighbors,3,GeoHashRadius.neighbors,,geohash_helper.h,neighbors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
322,143987,magic,3,hllhdr.magic,,hyperloglog.c,magic[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
323,143988,encoding,3,hllhdr.encoding,,hyperloglog.c,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
324,143990,card,3,hllhdr.card,,hyperloglog.c,card[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
325,143991,registers,3,hllhdr.registers,,hyperloglog.c,registers[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
326,150547,encoding,3,intset.encoding,,intset.h,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
327,150548,length,3,intset.length,,intset.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
328,150549,contents,3,intset.contents,,intset.h,contents[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
329,152996,idx,3,latencyTimeSeries.idx,,latency.h,idx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
330,152997,max,3,latencyTimeSeries.max,,latency.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
331,152999,samples,3,latencyTimeSeries.samples,,latency.h,samples[LATENCY_TS_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
332,153009,all_time_high,3,latencyStats.all_time_high,,latency.h,all_time_high,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
333,153010,avg,3,latencyStats.avg,,latency.h,avg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
334,153011,min,3,latencyStats.min,,latency.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
335,153012,max,3,latencyStats.max,,latency.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
336,153013,mad,3,latencyStats.mad,,latency.h,mad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
337,153014,samples,3,latencyStats.samples,,latency.h,samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
338,153015,period,3,latencyStats.period,,latency.h,period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
339,153028,cnt,3,durationStats.cnt,,latency.h,cnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
340,153029,sum,3,durationStats.sum,,latency.h,sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
341,153030,max,3,durationStats.max,,latency.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
342,159974,sval,3,listpackEntry.sval,,listpack.h,*sval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
343,159975,slen,3,listpackEntry.slen,,listpack.h,slen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
344,159976,lval,3,listpackEntry.lval,,listpack.h,lval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
345,161101,width,3,lwCanvas.width,,lolwut.h,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
346,161102,height,3,lwCanvas.height,,lolwut.h,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
347,161103,pixels,3,lwCanvas.pixels,,lolwut.h,*pixels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
348,161871,xoff,3,skyscraper.xoff,,lolwut6.c,xoff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
349,161872,width,3,skyscraper.width,,lolwut6.c,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
350,161873,height,3,skyscraper.height,,lolwut6.c,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
351,161874,windows,3,skyscraper.windows,,lolwut6.c,windows,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
352,161875,color,3,skyscraper.color,,lolwut6.c,color,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
353,164980,module,3,RedisModuleInfoCtx.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
354,164981,requested_sections,3,RedisModuleInfoCtx.requested_sections,,module.c,*requested_sections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
355,164982,info,3,RedisModuleInfoCtx.info,,module.c,info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
356,164983,sections,3,RedisModuleInfoCtx.sections,,module.c,sections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
357,164984,in_section,3,RedisModuleInfoCtx.in_section,,module.c,in_section,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
358,164985,in_dict_field,3,RedisModuleInfoCtx.in_dict_field,,module.c,in_dict_field,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
359,164987,func,3,RedisModuleSharedAPI.func,,module.c,*func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
360,164988,module,3,RedisModuleSharedAPI.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
361,164996,size,3,RedisModulePoolAllocBlock.size,,module.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
362,164997,used,3,RedisModulePoolAllocBlock.used,,module.c,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
363,164999,next,3,RedisModulePoolAllocBlock.next,,module.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
364,165000,memory,3,RedisModulePoolAllocBlock.memory,,module.c,memory[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
365,165012,module,3,RedisModuleCtx.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,79,0,1,1,0,0,,0,0,0,0,0,
366,165013,client,3,RedisModuleCtx.client,,module.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,83,0,1,1,0,0,,0,0,0,0,0,
367,165015,blocked_client,3,RedisModuleCtx.blocked_client,,module.c,*blocked_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
368,165017,amqueue,3,RedisModuleCtx.amqueue,,module.c,*amqueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
369,165018,amqueue_len,3,RedisModuleCtx.amqueue_len,,module.c,amqueue_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
370,165019,amqueue_used,3,RedisModuleCtx.amqueue_used,,module.c,amqueue_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
371,165020,flags,3,RedisModuleCtx.flags,,module.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
372,165021,postponed_arrays,3,RedisModuleCtx.postponed_arrays,,module.c,**postponed_arrays,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
373,165022,postponed_arrays_count,3,RedisModuleCtx.postponed_arrays_count,,module.c,postponed_arrays_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
374,165023,blocked_privdata,3,RedisModuleCtx.blocked_privdata,,module.c,*blocked_privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
375,165024,blocked_ready_key,3,RedisModuleCtx.blocked_ready_key,,module.c,*blocked_ready_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
376,165025,keys_result,3,RedisModuleCtx.keys_result,,module.c,*keys_result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
377,165027,pa_head,3,RedisModuleCtx.pa_head,,module.c,*pa_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
378,165028,next_yield_time,3,RedisModuleCtx.next_yield_time,,module.c,next_yield_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
379,165030,user,3,RedisModuleCtx.user,,module.c,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
380,165034,ctx,3,RedisModuleKey.ctx,,module.c,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
381,165035,db,3,RedisModuleKey.db,,module.c,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
382,165036,key,3,RedisModuleKey.key,,module.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
383,165037,value,3,RedisModuleKey.value,,module.c,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,128,0,1,1,0,0,,0,0,0,0,0,
384,165038,iter,3,RedisModuleKey.iter,,module.c,*iter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
385,165039,mode,3,RedisModuleKey.mode,,module.c,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
386,165059,u,3,RedisModuleKey.u,,module.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,51,0,1,1,0,0,,0,0,0,0,0,
387,165084,module,3,RedisModuleCommand.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
388,165085,func,3,RedisModuleCommand.func,,module.c,func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
389,165087,rediscmd,3,RedisModuleCommand.rediscmd,,module.c,*rediscmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
390,165094,module,3,RedisModuleAuthCtx.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
391,165095,auth_cb,3,RedisModuleAuthCtx.auth_cb,,module.c,auth_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
392,165098,client,3,RedisModuleBlockedClient.client,,module.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
393,165099,module,3,RedisModuleBlockedClient.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
394,165100,reply_callback,3,RedisModuleBlockedClient.reply_callback,,module.c,reply_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
395,165101,auth_reply_cb,3,RedisModuleBlockedClient.auth_reply_cb,,module.c,auth_reply_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
396,165102,timeout_callback,3,RedisModuleBlockedClient.timeout_callback,,module.c,timeout_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
397,165103,disconnect_callback,3,RedisModuleBlockedClient.disconnect_callback,,module.c,disconnect_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
398,165110,privdata,3,RedisModuleBlockedClient.privdata,,module.c,*privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
399,165111,thread_safe_ctx_client,3,RedisModuleBlockedClient.thread_safe_ctx_client,,module.c,*thread_safe_ctx_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
400,165112,reply_client,3,RedisModuleBlockedClient.reply_client,,module.c,*reply_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
401,165113,dbid,3,RedisModuleBlockedClient.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
402,165114,blocked_on_keys,3,RedisModuleBlockedClient.blocked_on_keys,,module.c,blocked_on_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
403,165115,unblocked,3,RedisModuleBlockedClient.unblocked,,module.c,unblocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
404,165116,background_timer,3,RedisModuleBlockedClient.background_timer,,module.c,background_timer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
405,165117,background_duration,3,RedisModuleBlockedClient.background_duration,,module.c,background_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
406,165157,module,3,RedisModuleKeyspaceSubscriber.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
407,165158,notify_callback,3,RedisModuleKeyspaceSubscriber.notify_callback,,module.c,notify_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
408,165159,event_mask,3,RedisModuleKeyspaceSubscriber.event_mask,,module.c,event_mask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
409,165160,active,3,RedisModuleKeyspaceSubscriber.active,,module.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
410,165163,module,3,RedisModulePostExecUnitJob.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
411,165164,callback,3,RedisModulePostExecUnitJob.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
412,165165,pd,3,RedisModulePostExecUnitJob.pd,,module.c,*pd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
413,165171,dbid,3,RedisModulePostExecUnitJob.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
414,165176,rax,3,RedisModuleDict.rax,,module.c,*rax,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
415,165179,dict,3,RedisModuleDictIter.dict,,module.c,*dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
416,165180,ri,3,RedisModuleDictIter.ri,,module.c,ri,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
417,165183,argv,3,RedisModuleCommandFilterCtx.argv,,module.c,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
418,165184,argv_len,3,RedisModuleCommandFilterCtx.argv_len,,module.c,argv_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
419,165185,argc,3,RedisModuleCommandFilterCtx.argc,,module.c,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
420,165186,c,3,RedisModuleCommandFilterCtx.c,,module.c,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
421,165194,module,3,RedisModuleCommandFilter.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
422,165195,callback,3,RedisModuleCommandFilter.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
423,165196,flags,3,RedisModuleCommandFilter.flags,,module.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
424,165207,done_handler,3,RedisModuleForkInfo.done_handler,,module.c,done_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
425,165208,done_handler_user_data,3,RedisModuleForkInfo.done_handler_user_data,,module.c,* done_handler_user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
426,165215,rax,3,RedisModuleServerInfoData.rax,,module.c,*rax,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
427,165218,module,3,RedisModuleEventListener.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
428,165219,event,3,RedisModuleEventListener.event,,module.c,event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
429,165220,callback,3,RedisModuleEventListener.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
430,165224,user,3,RedisModuleUser.user,,module.c,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
431,165225,free_user,3,RedisModuleUser.free_user,,module.c,free_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
432,165229,from_key,3,RedisModuleKeyOptCtx.from_key,,module.c,*from_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
433,165230,to_key,3,RedisModuleKeyOptCtx.to_key,,module.c,*to_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
434,165231,from_dbid,3,RedisModuleKeyOptCtx.from_dbid,,module.c,from_dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
435,165232,to_dbid,3,RedisModuleKeyOptCtx.to_dbid,,module.c,to_dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
436,165298,name,3,ModuleConfig.name,,module.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
437,165299,privdata,3,ModuleConfig.privdata,,module.c,*privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
438,165312,apply_fn,3,ModuleConfig.apply_fn,,module.c,apply_fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
439,165313,module,3,ModuleConfig.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
440,165315,ref_count,3,RedisModuleAsyncRMCallPromise.ref_count,,module.c,ref_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
441,165316,private_data,3,RedisModuleAsyncRMCallPromise.private_data,,module.c,*private_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
442,165317,module,3,RedisModuleAsyncRMCallPromise.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
443,165318,on_unblocked,3,RedisModuleAsyncRMCallPromise.on_unblocked,,module.c,on_unblocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
444,165319,c,3,RedisModuleAsyncRMCallPromise.c,,module.c,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
445,187472,module_id,3,moduleClusterReceiver.module_id,,module.c,module_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
446,187473,callback,3,moduleClusterReceiver.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
447,187475,module,3,moduleClusterReceiver.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
448,187477,next,3,moduleClusterReceiver.next,,module.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
449,188223,module,3,RedisModuleTimer.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
450,188224,callback,3,RedisModuleTimer.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
451,188225,data,3,RedisModuleTimer.data,,module.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
452,188226,dbid,3,RedisModuleTimer.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
453,188734,rFunc,3,EventLoopData.rFunc,,module.c,rFunc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
454,188735,wFunc,3,EventLoopData.wFunc,,module.c,wFunc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
455,188736,user_data,3,EventLoopData.user_data,,module.c,*user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
456,188739,func,3,EventLoopOneShot.func,,module.c,func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
457,188740,user_data,3,EventLoopOneShot.user_data,,module.c,*user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
458,192812,ctx,3,ScanCBData.ctx,,module.c,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
459,192813,user_data,3,ScanCBData.user_data,,module.c,* user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
460,192814,fn,3,ScanCBData.fn,,module.c,fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
461,192817,cursor,3,RedisModuleScanCursor.cursor,,module.c,cursor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
462,192818,done,3,RedisModuleScanCursor.done,,module.c,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
463,193007,key,3,ScanKeyCBData.key,,module.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
464,193008,user_data,3,ScanKeyCBData.user_data,,module.c,* user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
465,193009,fn,3,ScanKeyCBData.fn,,module.c,fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
466,198710,type,3,RedisModuleRdbStream.type,,module.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
467,198713,data,3,RedisModuleRdbStream.data,,module.c,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
468,199865,endtime,3,RedisModuleDefragCtx.endtime,,module.c,endtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
469,199866,cursor,3,RedisModuleDefragCtx.cursor,,module.c,*cursor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
470,199868,key,3,RedisModuleDefragCtx.key,,module.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
471,199869,dbid,3,RedisModuleDefragCtx.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
472,205267,value,3,HelloTypeNode.value,,modules\hellotype.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
473,205269,next,3,HelloTypeNode.next,,modules\hellotype.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
474,205272,head,3,HelloTypeObject.head,,modules\hellotype.c,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
475,205273,len,3,HelloTypeObject.len,,modules\hellotype.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
476,209710,node,3,watchedKey.node,,multi.c,node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
477,209711,key,3,watchedKey.key,,multi.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
478,209712,db,3,watchedKey.db,,multi.c,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
479,209713,client,3,watchedKey.client,,multi.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
480,209714,expired,3,watchedKey.expired,,multi.c,expired:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
481,235196,shard,3,pubsubtype.shard,,pubsub.c,shard,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
482,235207,serverPubSubChannels,3,pubsubtype.serverPubSubChannels,,pubsub.c,**serverPubSubChannels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
483,235208,subscribeMsg,3,pubsubtype.subscribeMsg,,pubsub.c,**subscribeMsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
484,235209,unsubscribeMsg,3,pubsubtype.unsubscribeMsg,,pubsub.c,**unsubscribeMsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
485,235210,messageBulk,3,pubsubtype.messageBulk,,pubsub.c,**messageBulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
486,243725,prev,3,quicklistNode.prev,,quicklist.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
487,243727,next,3,quicklistNode.next,,quicklist.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
488,243728,entry,3,quicklistNode.entry,,quicklist.h,*entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,43,0,1,1,0,0,,0,0,0,0,0,
489,243729,sz,3,quicklistNode.sz,,quicklist.h,sz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
490,243730,count,3,quicklistNode.count,,quicklist.h,count : 16,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,29,0,1,1,0,0,,0,0,0,0,0,
491,243731,encoding,3,quicklistNode.encoding,,quicklist.h,encoding : 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
492,243732,container,3,quicklistNode.container,,quicklist.h,container : 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
493,243733,recompress,3,quicklistNode.recompress,,quicklist.h,recompress : 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
494,243734,attempted_compress,3,quicklistNode.attempted_compress,,quicklist.h,attempted_compress : 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
495,243735,dont_compress,3,quicklistNode.dont_compress,,quicklist.h,dont_compress : 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
496,243739,sz,3,quicklistLZF.sz,,quicklist.h,sz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
497,243740,compressed,3,quicklistLZF.compressed,,quicklist.h,compressed[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
498,243748,node,3,quicklistBookmark.node,,quicklist.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
499,243752,head,3,quicklist.head,,quicklist.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
500,243753,tail,3,quicklist.tail,,quicklist.h,*tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
501,243754,count,3,quicklist.count,,quicklist.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
502,243755,len,3,quicklist.len,,quicklist.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
503,243756,fill,3,quicklist.fill,,quicklist.h,fill : QL_FILL_BITS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
504,243757,compress,3,quicklist.compress,,quicklist.h,compress : QL_COMP_BITS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
505,243758,bookmark_count,3,quicklist.bookmark_count,,quicklist.h,bookmark_count: QL_BM_BITS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
506,243759,bookmarks,3,quicklist.bookmarks,,quicklist.h,bookmarks[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
507,243767,quicklist,3,quicklistIter.quicklist,,quicklist.h,*quicklist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
508,243768,current,3,quicklistIter.current,,quicklist.h,*current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
509,243769,zi,3,quicklistIter.zi,,quicklist.h,*zi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
510,243770,offset,3,quicklistIter.offset,,quicklist.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
511,243771,direction,3,quicklistIter.direction,,quicklist.h,direction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
512,243774,quicklist,3,quicklistEntry.quicklist,,quicklist.h,*quicklist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
513,243775,node,3,quicklistEntry.node,,quicklist.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
514,243776,zi,3,quicklistEntry.zi,,quicklist.h,*zi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
515,243777,value,3,quicklistEntry.value,,quicklist.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
516,243778,longval,3,quicklistEntry.longval,,quicklist.h,longval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
517,243779,sz,3,quicklistEntry.sz,,quicklist.h,sz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
518,243780,offset,3,quicklistEntry.offset,,quicklist.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
519,251839,iskey,3,raxNode.iskey,,rax.h,iskey:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,55,0,1,1,0,0,,0,0,0,0,0,
520,251840,isnull,3,raxNode.isnull,,rax.h,isnull:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
521,251841,iscompr,3,raxNode.iscompr,,rax.h,iscompr:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,41,0,1,1,0,0,,0,0,0,0,0,
522,251842,size,3,raxNode.size,,rax.h,size:29,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,103,0,1,1,0,0,,0,0,0,0,0,
523,251843,data,3,raxNode.data,,rax.h,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
524,251851,head,3,rax.head,,rax.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
525,251852,numele,3,rax.numele,,rax.h,numele,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
526,251853,numnodes,3,rax.numnodes,,rax.h,numnodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
527,251856,stack,3,raxStack.stack,,rax.h,**stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
528,251857,items,3,raxStack.items,,rax.h,items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
529,251858,maxitems,3,raxStack.maxitems,,rax.h,maxitems,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
530,251859,static_items,3,raxStack.static_items,,rax.h,*static_items[RAX_STACK_STATIC_ITEMS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
531,251860,oom,3,raxStack.oom,,rax.h,oom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
532,251876,flags,3,raxIterator.flags,,rax.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
533,251877,rt,3,raxIterator.rt,,rax.h,*rt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
534,251878,key,3,raxIterator.key,,rax.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
535,251879,data,3,raxIterator.data,,rax.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
536,251880,key_len,3,raxIterator.key_len,,rax.h,key_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
537,251881,key_max,3,raxIterator.key_max,,rax.h,key_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
538,251882,key_static_string,3,raxIterator.key_static_string,,rax.h,key_static_string[RAX_ITER_STATIC_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
539,251883,node,3,raxIterator.node,,rax.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,72,0,1,1,0,0,,0,0,0,0,0,
540,251884,stack,3,raxIterator.stack,,rax.h,stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
541,251885,node_cb,3,raxIterator.node_cb,,rax.h,node_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
542,266458,el,3,config.el,,redis-benchmark.c,*el,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
543,266464,numclients,3,config.numclients,,redis-benchmark.c,numclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
544,266465,liveclients,3,config.liveclients,,redis-benchmark.c,liveclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
545,266466,requests,3,config.requests,,redis-benchmark.c,requests,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
546,266467,requests_issued,3,config.requests_issued,,redis-benchmark.c,requests_issued,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
547,266468,requests_finished,3,config.requests_finished,,redis-benchmark.c,requests_finished,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
548,266469,previous_requests_finished,3,config.previous_requests_finished,,redis-benchmark.c,previous_requests_finished,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
549,266470,last_printed_bytes,3,config.last_printed_bytes,,redis-benchmark.c,last_printed_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
550,266473,datasize,3,config.datasize,,redis-benchmark.c,datasize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
551,266474,randomkeys,3,config.randomkeys,,redis-benchmark.c,randomkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
552,266475,randomkeys_keyspacelen,3,config.randomkeys_keyspacelen,,redis-benchmark.c,randomkeys_keyspacelen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
553,266476,keepalive,3,config.keepalive,,redis-benchmark.c,keepalive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
554,266477,pipeline,3,config.pipeline,,redis-benchmark.c,pipeline,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
555,266478,start,3,config.start,,redis-benchmark.c,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
556,266479,totlatency,3,config.totlatency,,redis-benchmark.c,totlatency,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
557,266480,title,3,config.title,,redis-benchmark.c,*title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
558,266481,clients,3,config.clients,,redis-benchmark.c,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
559,266482,quiet,3,config.quiet,,redis-benchmark.c,quiet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
560,266483,csv,3,config.csv,,redis-benchmark.c,csv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
561,266484,loop,3,config.loop,,redis-benchmark.c,loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
562,266485,idlemode,3,config.idlemode,,redis-benchmark.c,idlemode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
563,266487,tests,3,config.tests,,redis-benchmark.c,*tests,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
564,266488,stdinarg,3,config.stdinarg,,redis-benchmark.c,stdinarg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
565,266489,precision,3,config.precision,,redis-benchmark.c,precision,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
566,266490,num_threads,3,config.num_threads,,redis-benchmark.c,num_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
567,266492,threads,3,config.threads,,redis-benchmark.c,**threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
568,266494,cluster_node_count,3,config.cluster_node_count,,redis-benchmark.c,cluster_node_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
569,266496,cluster_nodes,3,config.cluster_nodes,,redis-benchmark.c,**cluster_nodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
570,266498,redis_config,3,config.redis_config,,redis-benchmark.c,*redis_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
571,266500,latency_histogram,3,config.latency_histogram,,redis-benchmark.c,* latency_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
572,266502,current_sec_latency_histogram,3,config.current_sec_latency_histogram,,redis-benchmark.c,* current_sec_latency_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
573,266503,is_fetching_slots,3,config.is_fetching_slots,,redis-benchmark.c,is_fetching_slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
574,266504,is_updating_slots,3,config.is_updating_slots,,redis-benchmark.c,is_updating_slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
575,266505,slots_last_update,3,config.slots_last_update,,redis-benchmark.c,slots_last_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
576,266506,enable_tracking,3,config.enable_tracking,,redis-benchmark.c,enable_tracking,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
577,266507,liveclients_mutex,3,config.liveclients_mutex,,redis-benchmark.c,liveclients_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
578,266508,is_updating_slots_mutex,3,config.is_updating_slots_mutex,,redis-benchmark.c,is_updating_slots_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
579,266533,thread,3,benchmarkThread.thread,,redis-benchmark.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
580,266537,ip,3,clusterNode.ip,,redis-benchmark.c,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,34,0,1,1,0,0,,0,0,0,0,0,
581,266538,port,3,clusterNode.port,,redis-benchmark.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
582,266539,name,3,clusterNode.name,,redis-benchmark.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
583,266540,flags,3,clusterNode.flags,,redis-benchmark.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,89,0,1,1,0,0,,0,0,0,0,0,
584,266542,slots,3,clusterNode.slots,,redis-benchmark.c,*slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
585,266543,slots_count,3,clusterNode.slots_count,,redis-benchmark.c,slots_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
586,266544,current_slot_index,3,clusterNode.current_slot_index,,redis-benchmark.c,current_slot_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
587,266548,migrating,3,clusterNode.migrating,,redis-benchmark.c,*migrating,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
588,266550,migrating_count,3,clusterNode.migrating_count,,redis-benchmark.c,migrating_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
589,266553,redis_config,3,clusterNode.redis_config,,redis-benchmark.c,*redis_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
590,266556,save,3,redisConfig.save,,redis-benchmark.c,save,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
591,266557,appendonly,3,redisConfig.appendonly,,redis-benchmark.c,appendonly,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
592,277129,conn_info,3,config.conn_info,,redis-cli.c,conn_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
593,277130,hostsocket,3,config.hostsocket,,redis-cli.c,*hostsocket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
594,277131,tls,3,config.tls,,redis-cli.c,tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
595,277132,sslconfig,3,config.sslconfig,,redis-cli.c,sslconfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
596,277133,repeat,3,config.repeat,,redis-cli.c,repeat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
597,277134,interval,3,config.interval,,redis-cli.c,interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
598,277135,dbnum,3,config.dbnum,,redis-cli.c,dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
599,277136,interactive,3,config.interactive,,redis-cli.c,interactive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
600,277137,shutdown,3,config.shutdown,,redis-cli.c,shutdown,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
601,277138,monitor_mode,3,config.monitor_mode,,redis-cli.c,monitor_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
602,277139,pubsub_mode,3,config.pubsub_mode,,redis-cli.c,pubsub_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
603,277140,blocking_state_aborted,3,config.blocking_state_aborted,,redis-cli.c,blocking_state_aborted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
604,277143,latency_history,3,config.latency_history,,redis-cli.c,latency_history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
605,277145,lru_test_sample_size,3,config.lru_test_sample_size,,redis-cli.c,lru_test_sample_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
606,277146,cluster_mode,3,config.cluster_mode,,redis-cli.c,cluster_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
607,277147,cluster_reissue_command,3,config.cluster_reissue_command,,redis-cli.c,cluster_reissue_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
608,277148,cluster_send_asking,3,config.cluster_send_asking,,redis-cli.c,cluster_send_asking,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
609,277149,slave_mode,3,config.slave_mode,,redis-cli.c,slave_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
610,277151,pipe_timeout,3,config.pipe_timeout,,redis-cli.c,pipe_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
611,277156,count,3,config.count,,redis-cli.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
612,277158,intrinsic_latency_duration,3,config.intrinsic_latency_duration,,redis-cli.c,intrinsic_latency_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
613,277159,pattern,3,config.pattern,,redis-cli.c,pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
614,277165,stdin_lastarg,3,config.stdin_lastarg,,redis-cli.c,stdin_lastarg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
615,277169,quoted_input,3,config.quoted_input,,redis-cli.c,quoted_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
616,277170,output,3,config.output,,redis-cli.c,output,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
617,277172,mb_delim,3,config.mb_delim,,redis-cli.c,mb_delim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
618,277174,prompt,3,config.prompt,,redis-cli.c,prompt[128],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
619,277175,eval,3,config.eval,,redis-cli.c,*eval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
620,277176,eval_ldb,3,config.eval_ldb,,redis-cli.c,eval_ldb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
621,277177,eval_ldb_sync,3,config.eval_ldb_sync,,redis-cli.c,eval_ldb_sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
622,277178,eval_ldb_end,3,config.eval_ldb_end,,redis-cli.c,eval_ldb_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
623,277179,enable_ldb_on_eval,3,config.enable_ldb_on_eval,,redis-cli.c,enable_ldb_on_eval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
624,277180,last_cmd_type,3,config.last_cmd_type,,redis-cli.c,last_cmd_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
625,277181,last_reply,3,config.last_reply,,redis-cli.c,*last_reply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
626,277182,verbose,3,config.verbose,,redis-cli.c,verbose,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
627,277184,cluster_manager_command,3,config.cluster_manager_command,,redis-cli.c,cluster_manager_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
628,277186,resp2,3,config.resp2,,redis-cli.c,resp2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
629,277187,resp3,3,config.resp3,,redis-cli.c,resp3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
630,277188,current_resp3,3,config.current_resp3,,redis-cli.c,current_resp3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
631,277189,in_multi,3,config.in_multi,,redis-cli.c,in_multi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
632,277191,server_version,3,config.server_version,,redis-cli.c,*server_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
633,277202,hints,3,pref.hints,,redis-cli.c,hints,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
634,277560,type,3,helpEntry.type,,redis-cli.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
635,277561,argc,3,helpEntry.argc,,redis-cli.c,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
636,277562,argv,3,helpEntry.argv,,redis-cli.c,*argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
637,277563,full,3,helpEntry.full,,redis-cli.c,full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
638,277565,docs,3,helpEntry.docs,,redis-cli.c,docs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
639,289858,nodes,3,clusterManager.nodes,,redis-cli.c,*nodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
640,289859,errors,3,clusterManager.errors,,redis-cli.c,*errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
641,289860,unreachable_masters,3,clusterManager.unreachable_masters,,redis-cli.c,unreachable_masters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
642,289867,context,3,clusterManagerNode.context,,redis-cli.c,*context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
643,289868,name,3,clusterManagerNode.name,,redis-cli.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
644,289869,ip,3,clusterManagerNode.ip,,redis-cli.c,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
645,289870,port,3,clusterManagerNode.port,,redis-cli.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,
646,289872,current_epoch,3,clusterManagerNode.current_epoch,,redis-cli.c,current_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
647,289875,flags,3,clusterManagerNode.flags,,redis-cli.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
648,289876,flags_str,3,clusterManagerNode.flags_str,,redis-cli.c,*flags_str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
649,289877,replicate,3,clusterManagerNode.replicate,,redis-cli.c,replicate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
650,289879,slots,3,clusterManagerNode.slots,,redis-cli.c,slots[CLUSTER_MANAGER_SLOTS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
651,289880,slots_count,3,clusterManagerNode.slots_count,,redis-cli.c,slots_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
652,289881,replicas_count,3,clusterManagerNode.replicas_count,,redis-cli.c,replicas_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
653,289882,friends,3,clusterManagerNode.friends,,redis-cli.c,*friends,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
654,289883,migrating,3,clusterManagerNode.migrating,,redis-cli.c,*migrating,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
655,289884,importing,3,clusterManagerNode.importing,,redis-cli.c,*importing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
656,289885,migrating_count,3,clusterManagerNode.migrating_count,,redis-cli.c,migrating_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
657,289886,importing_count,3,clusterManagerNode.importing_count,,redis-cli.c,importing_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
658,289888,balance,3,clusterManagerNode.balance,,redis-cli.c,balance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
659,289905,source,3,clusterManagerReshardTableItem.source,,redis-cli.c,*source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
660,289906,slot,3,clusterManagerReshardTableItem.slot,,redis-cli.c,slot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
661,289909,node_name,3,clusterManagerLink.node_name,,redis-cli.c,node_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
662,289910,node_addr,3,clusterManagerLink.node_addr,,redis-cli.c,node_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
663,289911,connected,3,clusterManagerLink.connected,,redis-cli.c,connected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
664,289912,handshaking,3,clusterManagerLink.handshaking,,redis-cli.c,handshaking,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
665,290170,name,3,clusterManagerCommandDef.name,,redis-cli.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
666,290171,proc,3,clusterManagerCommandDef.proc,,redis-cli.c,*proc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
667,290172,arity,3,clusterManagerCommandDef.arity,,redis-cli.c,arity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
668,310346,name,3,typeinfo.name,,redis-cli.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
669,310348,sizeunit,3,typeinfo.sizeunit,,redis-cli.c,*sizeunit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
670,310349,biggest,3,typeinfo.biggest,,redis-cli.c,biggest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
671,310350,count,3,typeinfo.count,,redis-cli.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
672,310351,totalsize,3,typeinfo.totalsize,,redis-cli.c,totalsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
673,310352,biggest_key,3,typeinfo.biggest_key,,redis-cli.c,biggest_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
674,314164,ms,3,RedisModuleStreamID.ms,,redismodule.h,ms,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
675,314165,seq,3,RedisModuleStreamID.seq,,redismodule.h,seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
676,314206,name,3,RedisModuleCommandArg.name,,redismodule.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
677,314207,type,3,RedisModuleCommandArg.type,,redismodule.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
678,314208,key_spec_index,3,RedisModuleCommandArg.key_spec_index,,redismodule.h,key_spec_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
679,314209,token,3,RedisModuleCommandArg.token,,redismodule.h,*token,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
680,314210,summary,3,RedisModuleCommandArg.summary,,redismodule.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
681,314211,since,3,RedisModuleCommandArg.since,,redismodule.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
682,314212,flags,3,RedisModuleCommandArg.flags,,redismodule.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
683,314213,deprecated_since,3,RedisModuleCommandArg.deprecated_since,,redismodule.h,*deprecated_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
684,314215,subargs,3,RedisModuleCommandArg.subargs,,redismodule.h,*subargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
685,314216,display_text,3,RedisModuleCommandArg.display_text,,redismodule.h,*display_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
686,314219,since,3,RedisModuleCommandHistoryEntry.since,,redismodule.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
687,314220,changes,3,RedisModuleCommandHistoryEntry.changes,,redismodule.h,*changes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
688,314223,notes,3,RedisModuleCommandKeySpec.notes,,redismodule.h,*notes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
689,314224,flags,3,RedisModuleCommandKeySpec.flags,,redismodule.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
690,314225,begin_search_type,3,RedisModuleCommandKeySpec.begin_search_type,,redismodule.h,begin_search_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
691,314235,find_keys_type,3,RedisModuleCommandKeySpec.find_keys_type,,redismodule.h,find_keys_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
692,314247,fk,3,RedisModuleCommandKeySpec.fk,,redismodule.h,fk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
693,314251,sizeof_historyentry,3,RedisModuleCommandInfoVersion.sizeof_historyentry,,redismodule.h,sizeof_historyentry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
694,314252,sizeof_keyspec,3,RedisModuleCommandInfoVersion.sizeof_keyspec,,redismodule.h,sizeof_keyspec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
695,314253,sizeof_arg,3,RedisModuleCommandInfoVersion.sizeof_arg,,redismodule.h,sizeof_arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
696,314279,version,3,RedisModuleCommandInfo.version,,redismodule.h,*version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
697,314280,summary,3,RedisModuleCommandInfo.summary,,redismodule.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
698,314281,complexity,3,RedisModuleCommandInfo.complexity,,redismodule.h,*complexity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
699,314282,since,3,RedisModuleCommandInfo.since,,redismodule.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
700,314283,history,3,RedisModuleCommandInfo.history,,redismodule.h,*history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
701,314284,tips,3,RedisModuleCommandInfo.tips,,redismodule.h,*tips,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
702,314285,arity,3,RedisModuleCommandInfo.arity,,redismodule.h,arity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
703,314286,key_specs,3,RedisModuleCommandInfo.key_specs,,redismodule.h,*key_specs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
704,314287,args,3,RedisModuleCommandInfo.args,,redismodule.h,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
705,314302,id,3,RedisModuleEvent.id,,redismodule.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
706,314303,dataver,3,RedisModuleEvent.dataver,,redismodule.h,dataver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
707,334362,curr_location,3,ReplyParser.curr_location,,resp_parser.h,*curr_location,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,42,0,1,1,0,0,,0,0,0,0,0,
708,334363,callbacks,3,ReplyParser.callbacks,,resp_parser.h,callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
709,338606,funcname,3,scriptRunCtx.funcname,,script.h,*funcname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
710,338607,c,3,scriptRunCtx.c,,script.h,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
711,338608,original_client,3,scriptRunCtx.original_client,,script.h,*original_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
712,338609,flags,3,scriptRunCtx.flags,,script.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
713,338610,repl_flags,3,scriptRunCtx.repl_flags,,script.h,repl_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
714,338611,start_time,3,scriptRunCtx.start_time,,script.h,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
715,338613,flag,3,scriptFlag.flag,,script.h,flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
716,338614,str,3,scriptFlag.str,,script.h,*str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
717,343372,msg,3,errorInfo.msg,,script_lua.h,msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
718,343373,source,3,errorInfo.source,,script_lua.h,source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
719,343374,line,3,errorInfo.line,,script_lua.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
720,343375,ignore_err_stats_update,3,errorInfo.ignore_err_stats_update,,script_lua.h,ignore_err_stats_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
721,346976,len,3,sdshdr8.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
722,346977,alloc,3,sdshdr8.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
723,346978,flags,3,sdshdr8.flags,,sds.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
724,346979,buf,3,sdshdr8.buf,,sds.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
725,346986,len,3,sdshdr16.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
726,346987,alloc,3,sdshdr16.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
727,346996,len,3,sdshdr32.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
728,346997,alloc,3,sdshdr32.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
729,347006,len,3,sdshdr64.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
730,347007,alloc,3,sdshdr64.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
731,347979,hostname,3,sentinelAddr.hostname,,sentinel.c,*hostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
732,347980,ip,3,sentinelAddr.ip,,sentinel.c,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
733,347981,port,3,sentinelAddr.port,,sentinel.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
734,348046,refcount,3,instanceLink.refcount,,sentinel.c,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
735,348047,disconnected,3,instanceLink.disconnected,,sentinel.c,disconnected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
736,348048,pending_commands,3,instanceLink.pending_commands,,sentinel.c,pending_commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
737,348049,cc,3,instanceLink.cc,,sentinel.c,*cc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
738,348050,pc,3,instanceLink.pc,,sentinel.c,*pc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
739,348051,cc_conn_time,3,instanceLink.cc_conn_time,,sentinel.c,cc_conn_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
740,348052,pc_conn_time,3,instanceLink.pc_conn_time,,sentinel.c,pc_conn_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
741,348053,pc_last_activity,3,instanceLink.pc_last_activity,,sentinel.c,pc_last_activity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
742,348054,last_avail_time,3,instanceLink.last_avail_time,,sentinel.c,last_avail_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
743,348055,act_ping_time,3,instanceLink.act_ping_time,,sentinel.c,act_ping_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
744,348056,last_ping_time,3,instanceLink.last_ping_time,,sentinel.c,last_ping_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
745,348057,last_pong_time,3,instanceLink.last_pong_time,,sentinel.c,last_pong_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
746,348058,last_reconn_time,3,instanceLink.last_reconn_time,,sentinel.c,last_reconn_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
747,348061,flags,3,sentinelRedisInstance.flags,,sentinel.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,88,0,1,1,0,0,,0,0,0,0,0,
748,348062,name,3,sentinelRedisInstance.name,,sentinel.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
749,348063,runid,3,sentinelRedisInstance.runid,,sentinel.c,*runid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
750,348064,config_epoch,3,sentinelRedisInstance.config_epoch,,sentinel.c,config_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
751,348065,addr,3,sentinelRedisInstance.addr,,sentinel.c,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
752,348066,link,3,sentinelRedisInstance.link,,sentinel.c,*link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,76,0,1,1,0,0,,0,0,0,0,0,
753,348067,last_pub_time,3,sentinelRedisInstance.last_pub_time,,sentinel.c,last_pub_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
754,348068,last_hello_time,3,sentinelRedisInstance.last_hello_time,,sentinel.c,last_hello_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
755,348069,last_master_down_reply_time,3,sentinelRedisInstance.last_master_down_reply_time,,sentinel.c,last_master_down_reply_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
756,348070,s_down_since_time,3,sentinelRedisInstance.s_down_since_time,,sentinel.c,s_down_since_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
757,348071,o_down_since_time,3,sentinelRedisInstance.o_down_since_time,,sentinel.c,o_down_since_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
758,348072,down_after_period,3,sentinelRedisInstance.down_after_period,,sentinel.c,down_after_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
759,348073,master_reboot_down_after_period,3,sentinelRedisInstance.master_reboot_down_after_period,,sentinel.c,master_reboot_down_after_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
760,348074,master_reboot_since_time,3,sentinelRedisInstance.master_reboot_since_time,,sentinel.c,master_reboot_since_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
761,348075,info_refresh,3,sentinelRedisInstance.info_refresh,,sentinel.c,info_refresh,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
762,348076,renamed_commands,3,sentinelRedisInstance.renamed_commands,,sentinel.c,*renamed_commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
763,348077,role_reported,3,sentinelRedisInstance.role_reported,,sentinel.c,role_reported,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
764,348078,role_reported_time,3,sentinelRedisInstance.role_reported_time,,sentinel.c,role_reported_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
765,348079,slave_conf_change_time,3,sentinelRedisInstance.slave_conf_change_time,,sentinel.c,slave_conf_change_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
766,348080,sentinels,3,sentinelRedisInstance.sentinels,,sentinel.c,*sentinels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
767,348081,slaves,3,sentinelRedisInstance.slaves,,sentinel.c,*slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
768,348082,quorum,3,sentinelRedisInstance.quorum,,sentinel.c,quorum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
769,348083,parallel_syncs,3,sentinelRedisInstance.parallel_syncs,,sentinel.c,parallel_syncs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
770,348084,auth_pass,3,sentinelRedisInstance.auth_pass,,sentinel.c,*auth_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
771,348085,auth_user,3,sentinelRedisInstance.auth_user,,sentinel.c,*auth_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
772,348086,master_link_down_time,3,sentinelRedisInstance.master_link_down_time,,sentinel.c,master_link_down_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
773,348087,slave_priority,3,sentinelRedisInstance.slave_priority,,sentinel.c,slave_priority,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
774,348088,replica_announced,3,sentinelRedisInstance.replica_announced,,sentinel.c,replica_announced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
775,348089,slave_reconf_sent_time,3,sentinelRedisInstance.slave_reconf_sent_time,,sentinel.c,slave_reconf_sent_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
776,348091,master,3,sentinelRedisInstance.master,,sentinel.c,*master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
777,348092,slave_master_host,3,sentinelRedisInstance.slave_master_host,,sentinel.c,*slave_master_host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
778,348093,slave_master_port,3,sentinelRedisInstance.slave_master_port,,sentinel.c,slave_master_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
779,348094,slave_master_link_status,3,sentinelRedisInstance.slave_master_link_status,,sentinel.c,slave_master_link_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
780,348095,slave_repl_offset,3,sentinelRedisInstance.slave_repl_offset,,sentinel.c,slave_repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
781,348096,leader,3,sentinelRedisInstance.leader,,sentinel.c,*leader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
782,348097,leader_epoch,3,sentinelRedisInstance.leader_epoch,,sentinel.c,leader_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
783,348098,failover_epoch,3,sentinelRedisInstance.failover_epoch,,sentinel.c,failover_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
784,348099,failover_state,3,sentinelRedisInstance.failover_state,,sentinel.c,failover_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
785,348100,failover_state_change_time,3,sentinelRedisInstance.failover_state_change_time,,sentinel.c,failover_state_change_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
786,348101,failover_start_time,3,sentinelRedisInstance.failover_start_time,,sentinel.c,failover_start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
787,348102,failover_timeout,3,sentinelRedisInstance.failover_timeout,,sentinel.c,failover_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
788,348103,failover_delay_logged,3,sentinelRedisInstance.failover_delay_logged,,sentinel.c,failover_delay_logged,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
789,348105,promoted_slave,3,sentinelRedisInstance.promoted_slave,,sentinel.c,*promoted_slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
790,348106,notification_script,3,sentinelRedisInstance.notification_script,,sentinel.c,*notification_script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
791,348107,client_reconfig_script,3,sentinelRedisInstance.client_reconfig_script,,sentinel.c,*client_reconfig_script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
792,348108,info,3,sentinelRedisInstance.info,,sentinel.c,info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
793,348111,myid,3,sentinelState.myid,,sentinel.c,myid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
794,348112,current_epoch,3,sentinelState.current_epoch,,sentinel.c,current_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
795,348113,masters,3,sentinelState.masters,,sentinel.c,*masters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
796,348114,tilt,3,sentinelState.tilt,,sentinel.c,tilt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
797,348115,running_scripts,3,sentinelState.running_scripts,,sentinel.c,running_scripts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
798,348116,tilt_start_time,3,sentinelState.tilt_start_time,,sentinel.c,tilt_start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
799,348117,previous_time,3,sentinelState.previous_time,,sentinel.c,previous_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
800,348118,scripts_queue,3,sentinelState.scripts_queue,,sentinel.c,*scripts_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
801,348119,announce_ip,3,sentinelState.announce_ip,,sentinel.c,*announce_ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
802,348120,announce_port,3,sentinelState.announce_port,,sentinel.c,announce_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
803,348121,simfailure_flags,3,sentinelState.simfailure_flags,,sentinel.c,simfailure_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
804,348122,deny_scripts_reconfig,3,sentinelState.deny_scripts_reconfig,,sentinel.c,deny_scripts_reconfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
805,348123,sentinel_auth_pass,3,sentinelState.sentinel_auth_pass,,sentinel.c,*sentinel_auth_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
806,348124,sentinel_auth_user,3,sentinelState.sentinel_auth_user,,sentinel.c,*sentinel_auth_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
807,348125,resolve_hostnames,3,sentinelState.resolve_hostnames,,sentinel.c,resolve_hostnames,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
808,348126,announce_hostnames,3,sentinelState.announce_hostnames,,sentinel.c,announce_hostnames,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
809,348139,flags,3,sentinelScriptJob.flags,,sentinel.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
810,348140,retry_num,3,sentinelScriptJob.retry_num,,sentinel.c,retry_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
811,348141,argv,3,sentinelScriptJob.argv,,sentinel.c,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
812,348142,start_time,3,sentinelScriptJob.start_time,,sentinel.c,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
813,348143,pid,3,sentinelScriptJob.pid,,sentinel.c,pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
814,348146,context,3,redisAeEvents.context,,sentinel.c,*context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
815,348147,loop,3,redisAeEvents.loop,,sentinel.c,*loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
816,348148,fd,3,redisAeEvents.fd,,sentinel.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
817,348149,reading,3,redisAeEvents.reading,,sentinel.c,reading,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
818,348150,writing,3,redisAeEvents.writing,,sentinel.c,writing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
819,383923,type,3,commandListFilter.type,,server.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
820,383924,arg,3,commandListFilter.arg,,server.c,arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
821,390995,paused_actions,3,pause_event.paused_actions,,server.h,paused_actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
822,390996,end,3,pause_event.end,,server.h,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
823,391161,type,3,moduleValue.type,,server.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
824,391162,value,3,moduleValue.value,,server.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
825,391165,handle,3,RedisModule.handle,,server.h,*handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
826,391166,name,3,RedisModule.name,,server.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
827,391167,ver,3,RedisModule.ver,,server.h,ver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
828,391168,apiver,3,RedisModule.apiver,,server.h,apiver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
829,391169,types,3,RedisModule.types,,server.h,*types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
830,391170,usedby,3,RedisModule.usedby,,server.h,*usedby,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
831,391171,using,3,RedisModule.using,,server.h,*using,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
832,391172,filters,3,RedisModule.filters,,server.h,*filters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
833,391173,module_configs,3,RedisModule.module_configs,,server.h,*module_configs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
834,391174,configs_initialized,3,RedisModule.configs_initialized,,server.h,configs_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
835,391175,in_call,3,RedisModule.in_call,,server.h,in_call,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
836,391176,in_hook,3,RedisModule.in_hook,,server.h,in_hook,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
837,391177,options,3,RedisModule.options,,server.h,options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
838,391179,info_cb,3,RedisModule.info_cb,,server.h,info_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
839,391180,defrag_cb,3,RedisModule.defrag_cb,,server.h,defrag_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
840,391182,loadmod,3,RedisModule.loadmod,,server.h,*loadmod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
841,391183,num_commands_with_acl_categories,3,RedisModule.num_commands_with_acl_categories,,server.h,num_commands_with_acl_categories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
842,391184,onload,3,RedisModule.onload,,server.h,onload,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
843,391188,bytes,3,RedisModuleIO.bytes,,server.h,bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
844,391189,rio,3,RedisModuleIO.rio,,server.h,*rio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
845,391190,type,3,RedisModuleIO.type,,server.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
846,391191,error,3,RedisModuleIO.error,,server.h,error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
847,391193,ctx,3,RedisModuleIO.ctx,,server.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
848,391195,key,3,RedisModuleIO.key,,server.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
849,391196,dbid,3,RedisModuleIO.dbid,,server.h,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
850,391197,pre_flush_buffer,3,RedisModuleIO.pre_flush_buffer,,server.h,pre_flush_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
851,391199,o,3,RedisModuleDigest.o,,server.h,o[20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
852,391200,x,3,RedisModuleDigest.x,,server.h,x[20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
853,391202,key,3,RedisModuleDigest.key,,server.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
854,391203,dbid,3,RedisModuleDigest.dbid,,server.h,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
855,391225,size,3,clientReplyBlock.size,,server.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
856,391226,used,3,clientReplyBlock.used,,server.h,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
857,391227,buf,3,clientReplyBlock.buf,,server.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
858,391235,refcount,3,replBufBlock.refcount,,server.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
859,391236,id,3,replBufBlock.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
860,391237,repl_offset,3,replBufBlock.repl_offset,,server.h,repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
861,391238,size,3,replBufBlock.size,,server.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
862,391239,used,3,replBufBlock.used,,server.h,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
863,391240,buf,3,replBufBlock.buf,,server.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
864,391250,dict,3,redisDb.dict,,server.h,*dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,60,0,1,1,0,0,,0,0,0,0,0,
865,391251,expires,3,redisDb.expires,,server.h,*expires,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
866,391252,blocking_keys,3,redisDb.blocking_keys,,server.h,*blocking_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
867,391253,blocking_keys_unblock_on_nokey,3,redisDb.blocking_keys_unblock_on_nokey,,server.h,*blocking_keys_unblock_on_nokey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
868,391254,ready_keys,3,redisDb.ready_keys,,server.h,*ready_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
869,391255,watched_keys,3,redisDb.watched_keys,,server.h,*watched_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
870,391256,id,3,redisDb.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
871,391257,avg_ttl,3,redisDb.avg_ttl,,server.h,avg_ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
872,391258,expires_cursor,3,redisDb.expires_cursor,,server.h,expires_cursor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
873,391260,slots_to_keys,3,redisDb.slots_to_keys,,server.h,*slots_to_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
874,391265,dbarray,3,rdbLoadingCtx.dbarray,,server.h,* dbarray,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
875,391269,argv,3,multiCmd.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
876,391270,argv_len,3,multiCmd.argv_len,,server.h,argv_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
877,391271,argc,3,multiCmd.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
878,391273,cmd,3,multiCmd.cmd,,server.h,*cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
879,391276,commands,3,multiState.commands,,server.h,*commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
880,391277,count,3,multiState.count,,server.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
881,391295,db,3,readyList.db,,server.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
882,391296,key,3,readyList.key,,server.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
883,391299,name,3,user.name,,server.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
884,391300,flags,3,user.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
885,391301,passwords,3,user.passwords,,server.h,*passwords,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
886,391302,selectors,3,user.selectors,,server.h,*selectors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
887,391303,acl_string,3,user.acl_string,,server.h,*acl_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
888,391313,clients,3,clientMemUsageBucket.clients,,server.h,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
889,391314,mem_usage_sum,3,clientMemUsageBucket.mem_usage_sum,,server.h,mem_usage_sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
890,391317,id,3,client.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
891,391318,flags,3,client.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,281,0,1,1,0,0,,0,0,0,0,0,
892,391319,conn,3,client.conn,,server.h,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,49,0,1,1,0,0,,0,0,0,0,0,
893,391320,resp,3,client.resp,,server.h,resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,57,0,1,1,0,0,,0,0,0,0,0,
894,391321,db,3,client.db,,server.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,166,0,1,1,0,0,,0,0,0,0,0,
895,391322,name,3,client.name,,server.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
896,391323,lib_name,3,client.lib_name,,server.h,*lib_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
897,391324,lib_ver,3,client.lib_ver,,server.h,*lib_ver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
898,391325,querybuf,3,client.querybuf,,server.h,querybuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,58,0,1,1,0,0,,0,0,0,0,0,
899,391326,qb_pos,3,client.qb_pos,,server.h,qb_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
900,391327,querybuf_peak,3,client.querybuf_peak,,server.h,querybuf_peak,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
901,391328,argc,3,client.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,208,0,1,1,0,0,,0,0,0,0,0,
902,391329,argv,3,client.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,382,0,1,1,0,0,,0,0,0,0,0,
903,391330,argv_len,3,client.argv_len,,server.h,argv_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
904,391331,original_argc,3,client.original_argc,,server.h,original_argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
905,391332,original_argv,3,client.original_argv,,server.h,**original_argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
906,391333,argv_len_sum,3,client.argv_len_sum,,server.h,argv_len_sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
907,391335,cmd,3,client.cmd,,server.h,*cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,101,0,1,1,0,0,,0,0,0,0,0,
908,391336,lastcmd,3,client.lastcmd,,server.h,*lastcmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
909,391338,realcmd,3,client.realcmd,,server.h,*realcmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
910,391339,user,3,client.user,,server.h,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
911,391340,reqtype,3,client.reqtype,,server.h,reqtype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
912,391341,multibulklen,3,client.multibulklen,,server.h,multibulklen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
913,391342,bulklen,3,client.bulklen,,server.h,bulklen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
914,391343,reply,3,client.reply,,server.h,*reply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,50,0,1,1,0,0,,0,0,0,0,0,
915,391344,reply_bytes,3,client.reply_bytes,,server.h,reply_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
916,391345,deferred_reply_errors,3,client.deferred_reply_errors,,server.h,*deferred_reply_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
917,391346,sentlen,3,client.sentlen,,server.h,sentlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
918,391347,ctime,3,client.ctime,,server.h,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
919,391348,duration,3,client.duration,,server.h,duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
920,391349,slot,3,client.slot,,server.h,slot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
921,391350,cur_script,3,client.cur_script,,server.h,*cur_script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
922,391351,lastinteraction,3,client.lastinteraction,,server.h,lastinteraction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
923,391352,obuf_soft_limit_reached_time,3,client.obuf_soft_limit_reached_time,,server.h,obuf_soft_limit_reached_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
924,391353,authenticated,3,client.authenticated,,server.h,authenticated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
925,391354,replstate,3,client.replstate,,server.h,replstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
926,391355,repl_start_cmd_stream_on_ack,3,client.repl_start_cmd_stream_on_ack,,server.h,repl_start_cmd_stream_on_ack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
927,391356,repldbfd,3,client.repldbfd,,server.h,repldbfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
928,391357,repldboff,3,client.repldboff,,server.h,repldboff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
929,391358,repldbsize,3,client.repldbsize,,server.h,repldbsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
930,391359,replpreamble,3,client.replpreamble,,server.h,replpreamble,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
931,391360,read_reploff,3,client.read_reploff,,server.h,read_reploff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
932,391361,reploff,3,client.reploff,,server.h,reploff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
933,391362,repl_applied,3,client.repl_applied,,server.h,repl_applied,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
934,391363,repl_ack_off,3,client.repl_ack_off,,server.h,repl_ack_off,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
935,391364,repl_aof_off,3,client.repl_aof_off,,server.h,repl_aof_off,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
936,391365,repl_ack_time,3,client.repl_ack_time,,server.h,repl_ack_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
937,391366,repl_last_partial_write,3,client.repl_last_partial_write,,server.h,repl_last_partial_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
938,391367,psync_initial_offset,3,client.psync_initial_offset,,server.h,psync_initial_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
939,391369,slave_listening_port,3,client.slave_listening_port,,server.h,slave_listening_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
940,391370,slave_addr,3,client.slave_addr,,server.h,*slave_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
941,391371,slave_capa,3,client.slave_capa,,server.h,slave_capa,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
942,391372,slave_req,3,client.slave_req,,server.h,slave_req,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
943,391373,mstate,3,client.mstate,,server.h,mstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,49,0,1,1,0,0,,0,0,0,0,0,
944,391374,bstate,3,client.bstate,,server.h,bstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,65,0,1,1,0,0,,0,0,0,0,0,
945,391375,woff,3,client.woff,,server.h,woff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
946,391376,watched_keys,3,client.watched_keys,,server.h,*watched_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
947,391377,pubsub_channels,3,client.pubsub_channels,,server.h,*pubsub_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
948,391378,pubsub_patterns,3,client.pubsub_patterns,,server.h,*pubsub_patterns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
949,391379,pubsubshard_channels,3,client.pubsubshard_channels,,server.h,*pubsubshard_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
950,391380,peerid,3,client.peerid,,server.h,peerid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
951,391381,sockname,3,client.sockname,,server.h,sockname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
952,391382,client_list_node,3,client.client_list_node,,server.h,*client_list_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
953,391383,postponed_list_node,3,client.postponed_list_node,,server.h,*postponed_list_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
954,391384,pending_read_list_node,3,client.pending_read_list_node,,server.h,*pending_read_list_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
955,391385,module_blocked_client,3,client.module_blocked_client,,server.h,*module_blocked_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
956,391386,module_auth_ctx,3,client.module_auth_ctx,,server.h,*module_auth_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
957,391387,auth_callback,3,client.auth_callback,,server.h,auth_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
958,391388,auth_callback_privdata,3,client.auth_callback_privdata,,server.h,*auth_callback_privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
959,391389,auth_module,3,client.auth_module,,server.h,*auth_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
960,391390,client_tracking_redirection,3,client.client_tracking_redirection,,server.h,client_tracking_redirection,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
961,391391,client_tracking_prefixes,3,client.client_tracking_prefixes,,server.h,*client_tracking_prefixes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
962,391392,last_memory_usage,3,client.last_memory_usage,,server.h,last_memory_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
963,391393,last_memory_type,3,client.last_memory_type,,server.h,last_memory_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
964,391394,mem_usage_bucket_node,3,client.mem_usage_bucket_node,,server.h,*mem_usage_bucket_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
965,391395,mem_usage_bucket,3,client.mem_usage_bucket,,server.h,*mem_usage_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
966,391396,ref_repl_buf_node,3,client.ref_repl_buf_node,,server.h,*ref_repl_buf_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
967,391397,ref_block_pos,3,client.ref_block_pos,,server.h,ref_block_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
968,391398,clients_pending_write_node,3,client.clients_pending_write_node,,server.h,clients_pending_write_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
969,391399,buf_peak,3,client.buf_peak,,server.h,buf_peak,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
970,391400,buf_peak_last_reset_time,3,client.buf_peak_last_reset_time,,server.h,buf_peak_last_reset_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
971,391401,bufpos,3,client.bufpos,,server.h,bufpos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,29,0,1,1,0,0,,0,0,0,0,0,
972,391402,buf_usable_size,3,client.buf_usable_size,,server.h,buf_usable_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
973,391403,buf,3,client.buf,,server.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
974,391426,path,3,moduleLoadQueueEntry.path,,server.h,path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
975,391427,argc,3,moduleLoadQueueEntry.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
976,391428,argv,3,moduleLoadQueueEntry.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
977,391430,argc,3,sentinelLoadQueueEntry.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
978,391431,argv,3,sentinelLoadQueueEntry.argv,,server.h,*argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
979,391432,linenum,3,sentinelLoadQueueEntry.linenum,,server.h,linenum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
980,391433,line,3,sentinelLoadQueueEntry.line,,server.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
981,391439,ok,3,sharedObjectsStruct.ok,,server.h,*ok,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
982,391446,queued,3,sharedObjectsStruct.queued,,server.h,*queued,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
983,391458,loadingerr,3,sharedObjectsStruct.loadingerr,,server.h,*loadingerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
984,391462,bgsaveerr,3,sharedObjectsStruct.bgsaveerr,,server.h,*bgsaveerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
985,391463,masterdownerr,3,sharedObjectsStruct.masterdownerr,,server.h,*masterdownerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
986,391464,roslaveerr,3,sharedObjectsStruct.roslaveerr,,server.h,*roslaveerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
987,391466,noautherr,3,sharedObjectsStruct.noautherr,,server.h,*noautherr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
988,391467,noreplicaserr,3,sharedObjectsStruct.noreplicaserr,,server.h,*noreplicaserr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
989,391469,oomerr,3,sharedObjectsStruct.oomerr,,server.h,*oomerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
990,391488,multi,3,sharedObjectsStruct.multi,,server.h,*multi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
991,391489,exec,3,sharedObjectsStruct.exec,,server.h,*exec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
992,391497,replconf,3,sharedObjectsStruct.replconf,,server.h,*replconf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
993,391516,getack,3,sharedObjectsStruct.getack,,server.h,*getack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
994,391517,special_asterick,3,sharedObjectsStruct.special_asterick,,server.h,*special_asterick,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
995,391526,mbulkhdr,3,sharedObjectsStruct.mbulkhdr,,server.h,*mbulkhdr[OBJ_SHARED_BULKHDR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
996,391569,ele,3,zskiplistNode.ele,,server.h,ele,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
997,391570,score,3,zskiplistNode.score,,server.h,score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
998,391572,backward,3,zskiplistNode.backward,,server.h,*backward,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
999,391577,level,3,zskiplistNode.level,,server.h,level[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1000,391586,header,3,zskiplist.header,,server.h,*header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1001,391587,tail,3,zskiplist.tail,,server.h,*tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1002,391588,length,3,zskiplist.length,,server.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1003,391589,level,3,zskiplist.level,,server.h,level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1004,391592,dict,3,zset.dict,,server.h,*dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1005,391593,zsl,3,zset.zsl,,server.h,*zsl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1006,391606,argv,3,redisOp.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1007,391607,argc,3,redisOp.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1008,391608,dbid,3,redisOp.dbid,,server.h,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1009,391609,target,3,redisOp.target,,server.h,target,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1010,391612,ops,3,redisOpArray.ops,,server.h,*ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1011,391613,numops,3,redisOpArray.numops,,server.h,numops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1012,391614,capacity,3,redisOpArray.capacity,,server.h,capacity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1013,391617,peak_allocated,3,redisMemOverhead.peak_allocated,,server.h,peak_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1014,391618,total_allocated,3,redisMemOverhead.total_allocated,,server.h,total_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1015,391619,startup_allocated,3,redisMemOverhead.startup_allocated,,server.h,startup_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1016,391620,repl_backlog,3,redisMemOverhead.repl_backlog,,server.h,repl_backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1017,391621,clients_slaves,3,redisMemOverhead.clients_slaves,,server.h,clients_slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1018,391622,clients_normal,3,redisMemOverhead.clients_normal,,server.h,clients_normal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1019,391623,cluster_links,3,redisMemOverhead.cluster_links,,server.h,cluster_links,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1020,391624,aof_buffer,3,redisMemOverhead.aof_buffer,,server.h,aof_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1021,391625,lua_caches,3,redisMemOverhead.lua_caches,,server.h,lua_caches,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1022,391626,functions_caches,3,redisMemOverhead.functions_caches,,server.h,functions_caches,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1023,391627,overhead_total,3,redisMemOverhead.overhead_total,,server.h,overhead_total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1024,391628,dataset,3,redisMemOverhead.dataset,,server.h,dataset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1025,391629,total_keys,3,redisMemOverhead.total_keys,,server.h,total_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1026,391630,bytes_per_key,3,redisMemOverhead.bytes_per_key,,server.h,bytes_per_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1027,391631,dataset_perc,3,redisMemOverhead.dataset_perc,,server.h,dataset_perc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1028,391632,peak_perc,3,redisMemOverhead.peak_perc,,server.h,peak_perc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1029,391633,total_frag,3,redisMemOverhead.total_frag,,server.h,total_frag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1030,391634,total_frag_bytes,3,redisMemOverhead.total_frag_bytes,,server.h,total_frag_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1031,391635,allocator_frag,3,redisMemOverhead.allocator_frag,,server.h,allocator_frag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1032,391636,allocator_frag_bytes,3,redisMemOverhead.allocator_frag_bytes,,server.h,allocator_frag_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1033,391637,allocator_rss,3,redisMemOverhead.allocator_rss,,server.h,allocator_rss,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1034,391638,allocator_rss_bytes,3,redisMemOverhead.allocator_rss_bytes,,server.h,allocator_rss_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1035,391639,rss_extra,3,redisMemOverhead.rss_extra,,server.h,rss_extra,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1036,391640,rss_extra_bytes,3,redisMemOverhead.rss_extra_bytes,,server.h,rss_extra_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1037,391641,num_dbs,3,redisMemOverhead.num_dbs,,server.h,num_dbs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1038,391661,repl_stream_db,3,rdbSaveInfo.repl_stream_db,,server.h,repl_stream_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1039,391719,file_name,3,aofInfo.file_name,,server.h,file_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1040,391720,file_seq,3,aofInfo.file_seq,,server.h,file_seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1041,391721,file_type,3,aofInfo.file_type,,server.h,file_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1042,391724,base_aof_info,3,aofManifest.base_aof_info,,server.h,*base_aof_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1043,391725,incr_aof_list,3,aofManifest.incr_aof_list,,server.h,*incr_aof_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,34,0,1,1,0,0,,0,0,0,0,0,
1044,391726,history_aof_list,3,aofManifest.history_aof_list,,server.h,*history_aof_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1045,391727,curr_base_file_seq,3,aofManifest.curr_base_file_seq,,server.h,curr_base_file_seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1046,391728,curr_incr_file_seq,3,aofManifest.curr_incr_file_seq,,server.h,curr_incr_file_seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1047,391729,dirty,3,aofManifest.dirty,,server.h,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1048,391738,pid,3,redisServer.pid,,server.h,pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1049,391739,main_thread_id,3,redisServer.main_thread_id,,server.h,main_thread_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1050,391740,configfile,3,redisServer.configfile,,server.h,*configfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1051,391741,executable,3,redisServer.executable,,server.h,*executable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1052,391742,exec_argv,3,redisServer.exec_argv,,server.h,**exec_argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1053,391743,dynamic_hz,3,redisServer.dynamic_hz,,server.h,dynamic_hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1054,391744,config_hz,3,redisServer.config_hz,,server.h,config_hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1055,391746,hz,3,redisServer.hz,,server.h,hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
1056,391747,in_fork_child,3,redisServer.in_fork_child,,server.h,in_fork_child,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1057,391748,db,3,redisServer.db,,server.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,42,0,1,1,0,0,,0,0,0,0,0,
1058,391749,commands,3,redisServer.commands,,server.h,*commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
1059,391750,orig_commands,3,redisServer.orig_commands,,server.h,*orig_commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1060,391751,el,3,redisServer.el,,server.h,*el,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1061,391752,errors,3,redisServer.errors,,server.h,*errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1062,391753,lruclock,3,redisServer.lruclock,,server.h,lruclock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1063,391754,shutdown_asap,3,redisServer.shutdown_asap,,server.h,shutdown_asap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1064,391755,shutdown_mstime,3,redisServer.shutdown_mstime,,server.h,shutdown_mstime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1065,391756,last_sig_received,3,redisServer.last_sig_received,,server.h,last_sig_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1066,391757,shutdown_flags,3,redisServer.shutdown_flags,,server.h,shutdown_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1067,391758,activerehashing,3,redisServer.activerehashing,,server.h,activerehashing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1068,391759,active_defrag_running,3,redisServer.active_defrag_running,,server.h,active_defrag_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1069,391760,pidfile,3,redisServer.pidfile,,server.h,*pidfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1070,391761,arch_bits,3,redisServer.arch_bits,,server.h,arch_bits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1071,391762,cronloops,3,redisServer.cronloops,,server.h,cronloops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1072,391763,runid,3,redisServer.runid,,server.h,runid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1073,391764,sentinel_mode,3,redisServer.sentinel_mode,,server.h,sentinel_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1074,391765,initial_memory_usage,3,redisServer.initial_memory_usage,,server.h,initial_memory_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1075,391766,always_show_logo,3,redisServer.always_show_logo,,server.h,always_show_logo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1076,391767,in_exec,3,redisServer.in_exec,,server.h,in_exec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1077,391768,busy_module_yield_flags,3,redisServer.busy_module_yield_flags,,server.h,busy_module_yield_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1078,391769,busy_module_yield_reply,3,redisServer.busy_module_yield_reply,,server.h,*busy_module_yield_reply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1079,391770,ignore_warnings,3,redisServer.ignore_warnings,,server.h,*ignore_warnings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1080,391771,client_pause_in_transaction,3,redisServer.client_pause_in_transaction,,server.h,client_pause_in_transaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1081,391772,thp_enabled,3,redisServer.thp_enabled,,server.h,thp_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1082,391773,page_size,3,redisServer.page_size,,server.h,page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1083,391778,module_pipe,3,redisServer.module_pipe,,server.h,module_pipe[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1084,391779,child_pid,3,redisServer.child_pid,,server.h,child_pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1085,391780,child_type,3,redisServer.child_type,,server.h,child_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1086,391781,port,3,redisServer.port,,server.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1087,391782,tls_port,3,redisServer.tls_port,,server.h,tls_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1088,391783,tcp_backlog,3,redisServer.tcp_backlog,,server.h,tcp_backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1089,391784,bindaddr,3,redisServer.bindaddr,,server.h,*bindaddr[CONFIG_BINDADDR_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1090,391785,bindaddr_count,3,redisServer.bindaddr_count,,server.h,bindaddr_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1091,391787,unixsocket,3,redisServer.unixsocket,,server.h,*unixsocket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1092,391788,unixsocketperm,3,redisServer.unixsocketperm,,server.h,unixsocketperm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1093,391789,listeners,3,redisServer.listeners,,server.h,listeners[CONN_TYPE_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1094,391790,socket_mark_id,3,redisServer.socket_mark_id,,server.h,socket_mark_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1095,391791,clistener,3,redisServer.clistener,,server.h,clistener,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1096,391792,clients,3,redisServer.clients,,server.h,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1097,391793,clients_to_close,3,redisServer.clients_to_close,,server.h,*clients_to_close,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1098,391794,clients_pending_write,3,redisServer.clients_pending_write,,server.h,*clients_pending_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1099,391795,clients_pending_read,3,redisServer.clients_pending_read,,server.h,*clients_pending_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1100,391796,slaves,3,redisServer.slaves,,server.h,*slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1101,391797,monitors,3,redisServer.monitors,,server.h,*monitors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1102,391798,current_client,3,redisServer.current_client,,server.h,*current_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1103,391802,client_mem_usage_buckets,3,redisServer.client_mem_usage_buckets,,server.h,* client_mem_usage_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1104,391803,clients_timeout_table,3,redisServer.clients_timeout_table,,server.h,*clients_timeout_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1105,391804,execution_nesting,3,redisServer.execution_nesting,,server.h,execution_nesting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1106,391805,clients_index,3,redisServer.clients_index,,server.h,*clients_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1107,391806,paused_actions,3,redisServer.paused_actions,,server.h,paused_actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1108,391807,postponed_clients,3,redisServer.postponed_clients,,server.h,*postponed_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1109,391808,client_pause_per_purpose,3,redisServer.client_pause_per_purpose,,server.h,client_pause_per_purpose[NUM_PAUSE_PURPOSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1110,391809,neterr,3,redisServer.neterr,,server.h,neterr[ANET_ERR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1111,391810,migrate_cached_sockets,3,redisServer.migrate_cached_sockets,,server.h,*migrate_cached_sockets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1112,391811,next_client_id,3,redisServer.next_client_id,,server.h,next_client_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1113,391815,io_threads_active,3,redisServer.io_threads_active,,server.h,io_threads_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1114,391816,events_processed_while_blocked,3,redisServer.events_processed_while_blocked,,server.h,events_processed_while_blocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1115,391818,enable_debug_cmd,3,redisServer.enable_debug_cmd,,server.h,enable_debug_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1116,391819,enable_module_cmd,3,redisServer.enable_module_cmd,,server.h,enable_module_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1117,391820,loading,3,redisServer.loading,,server.h,loading,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1118,391821,async_loading,3,redisServer.async_loading,,server.h,async_loading,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1119,391822,loading_total_bytes,3,redisServer.loading_total_bytes,,server.h,loading_total_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1120,391823,loading_rdb_used_mem,3,redisServer.loading_rdb_used_mem,,server.h,loading_rdb_used_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1121,391824,loading_loaded_bytes,3,redisServer.loading_loaded_bytes,,server.h,loading_loaded_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1122,391825,loading_start_time,3,redisServer.loading_start_time,,server.h,loading_start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1123,391827,stat_starttime,3,redisServer.stat_starttime,,server.h,stat_starttime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1124,391828,stat_numcommands,3,redisServer.stat_numcommands,,server.h,stat_numcommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1125,391829,stat_numconnections,3,redisServer.stat_numconnections,,server.h,stat_numconnections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1126,391830,stat_expiredkeys,3,redisServer.stat_expiredkeys,,server.h,stat_expiredkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1127,391831,stat_expired_stale_perc,3,redisServer.stat_expired_stale_perc,,server.h,stat_expired_stale_perc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1128,391832,stat_expired_time_cap_reached_count,3,redisServer.stat_expired_time_cap_reached_count,,server.h,stat_expired_time_cap_reached_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1129,391833,stat_expire_cycle_time_used,3,redisServer.stat_expire_cycle_time_used,,server.h,stat_expire_cycle_time_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1130,391834,stat_evictedkeys,3,redisServer.stat_evictedkeys,,server.h,stat_evictedkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1131,391835,stat_evictedclients,3,redisServer.stat_evictedclients,,server.h,stat_evictedclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1132,391836,stat_total_eviction_exceeded_time,3,redisServer.stat_total_eviction_exceeded_time,,server.h,stat_total_eviction_exceeded_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1133,391837,stat_last_eviction_exceeded_time,3,redisServer.stat_last_eviction_exceeded_time,,server.h,stat_last_eviction_exceeded_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1134,391838,stat_keyspace_hits,3,redisServer.stat_keyspace_hits,,server.h,stat_keyspace_hits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1135,391839,stat_keyspace_misses,3,redisServer.stat_keyspace_misses,,server.h,stat_keyspace_misses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1136,391840,stat_active_defrag_hits,3,redisServer.stat_active_defrag_hits,,server.h,stat_active_defrag_hits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1137,391841,stat_active_defrag_misses,3,redisServer.stat_active_defrag_misses,,server.h,stat_active_defrag_misses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1138,391842,stat_active_defrag_key_hits,3,redisServer.stat_active_defrag_key_hits,,server.h,stat_active_defrag_key_hits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1139,391843,stat_active_defrag_key_misses,3,redisServer.stat_active_defrag_key_misses,,server.h,stat_active_defrag_key_misses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1140,391844,stat_active_defrag_scanned,3,redisServer.stat_active_defrag_scanned,,server.h,stat_active_defrag_scanned,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1141,391845,stat_total_active_defrag_time,3,redisServer.stat_total_active_defrag_time,,server.h,stat_total_active_defrag_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1142,391846,stat_last_active_defrag_time,3,redisServer.stat_last_active_defrag_time,,server.h,stat_last_active_defrag_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1143,391847,stat_peak_memory,3,redisServer.stat_peak_memory,,server.h,stat_peak_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1144,391848,stat_aof_rewrites,3,redisServer.stat_aof_rewrites,,server.h,stat_aof_rewrites,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1145,391849,stat_aofrw_consecutive_failures,3,redisServer.stat_aofrw_consecutive_failures,,server.h,stat_aofrw_consecutive_failures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1146,391850,stat_rdb_saves,3,redisServer.stat_rdb_saves,,server.h,stat_rdb_saves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1147,391851,stat_fork_time,3,redisServer.stat_fork_time,,server.h,stat_fork_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1148,391852,stat_fork_rate,3,redisServer.stat_fork_rate,,server.h,stat_fork_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1149,391853,stat_total_forks,3,redisServer.stat_total_forks,,server.h,stat_total_forks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1150,391854,stat_rejected_conn,3,redisServer.stat_rejected_conn,,server.h,stat_rejected_conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1151,391855,stat_sync_full,3,redisServer.stat_sync_full,,server.h,stat_sync_full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1152,391856,stat_sync_partial_ok,3,redisServer.stat_sync_partial_ok,,server.h,stat_sync_partial_ok,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1153,391857,stat_sync_partial_err,3,redisServer.stat_sync_partial_err,,server.h,stat_sync_partial_err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1154,391863,cron_malloc_stats,3,redisServer.cron_malloc_stats,,server.h,cron_malloc_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
1155,391864,stat_net_input_bytes,3,redisServer.stat_net_input_bytes,,server.h,stat_net_input_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1156,391865,stat_net_output_bytes,3,redisServer.stat_net_output_bytes,,server.h,stat_net_output_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1157,391866,stat_net_repl_input_bytes,3,redisServer.stat_net_repl_input_bytes,,server.h,stat_net_repl_input_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1158,391867,stat_net_repl_output_bytes,3,redisServer.stat_net_repl_output_bytes,,server.h,stat_net_repl_output_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1159,391868,stat_current_cow_peak,3,redisServer.stat_current_cow_peak,,server.h,stat_current_cow_peak,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1160,391869,stat_current_cow_bytes,3,redisServer.stat_current_cow_bytes,,server.h,stat_current_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1161,391870,stat_current_cow_updated,3,redisServer.stat_current_cow_updated,,server.h,stat_current_cow_updated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1162,391871,stat_current_save_keys_processed,3,redisServer.stat_current_save_keys_processed,,server.h,stat_current_save_keys_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1163,391872,stat_current_save_keys_total,3,redisServer.stat_current_save_keys_total,,server.h,stat_current_save_keys_total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1164,391873,stat_rdb_cow_bytes,3,redisServer.stat_rdb_cow_bytes,,server.h,stat_rdb_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1165,391874,stat_aof_cow_bytes,3,redisServer.stat_aof_cow_bytes,,server.h,stat_aof_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1166,391875,stat_module_cow_bytes,3,redisServer.stat_module_cow_bytes,,server.h,stat_module_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1167,391876,stat_module_progress,3,redisServer.stat_module_progress,,server.h,stat_module_progress,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1168,391877,stat_clients_type_memory,3,redisServer.stat_clients_type_memory,,server.h,stat_clients_type_memory[CLIENT_TYPE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1169,391878,stat_cluster_links_memory,3,redisServer.stat_cluster_links_memory,,server.h,stat_cluster_links_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1170,391879,stat_unexpected_error_replies,3,redisServer.stat_unexpected_error_replies,,server.h,stat_unexpected_error_replies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1171,391880,stat_total_error_replies,3,redisServer.stat_total_error_replies,,server.h,stat_total_error_replies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1172,391881,stat_dump_payload_sanitizations,3,redisServer.stat_dump_payload_sanitizations,,server.h,stat_dump_payload_sanitizations,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1173,391882,stat_io_reads_processed,3,redisServer.stat_io_reads_processed,,server.h,stat_io_reads_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1174,391883,stat_io_writes_processed,3,redisServer.stat_io_writes_processed,,server.h,stat_io_writes_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1175,391884,stat_total_reads_processed,3,redisServer.stat_total_reads_processed,,server.h,stat_total_reads_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1176,391885,stat_total_writes_processed,3,redisServer.stat_total_writes_processed,,server.h,stat_total_writes_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1177,391900,stat_reply_buffer_shrinks,3,redisServer.stat_reply_buffer_shrinks,,server.h,stat_reply_buffer_shrinks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1178,391901,stat_reply_buffer_expands,3,redisServer.stat_reply_buffer_expands,,server.h,stat_reply_buffer_expands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1179,391902,el_start,3,redisServer.el_start,,server.h,el_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1180,391903,el_cmd_cnt_start,3,redisServer.el_cmd_cnt_start,,server.h,el_cmd_cnt_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1181,391904,el_cmd_cnt_max,3,redisServer.el_cmd_cnt_max,,server.h,el_cmd_cnt_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1182,391905,el_cron_duration,3,redisServer.el_cron_duration,,server.h,el_cron_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1183,391906,duration_stats,3,redisServer.duration_stats,,server.h,duration_stats[EL_DURATION_TYPE_NUM],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1184,391907,verbosity,3,redisServer.verbosity,,server.h,verbosity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
1185,391910,active_expire_enabled,3,redisServer.active_expire_enabled,,server.h,active_expire_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1186,391912,lazy_expire_disabled,3,redisServer.lazy_expire_disabled,,server.h,lazy_expire_disabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1187,391915,skip_checksum_validation,3,redisServer.skip_checksum_validation,,server.h,skip_checksum_validation,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1188,391916,jemalloc_bg_thread,3,redisServer.jemalloc_bg_thread,,server.h,jemalloc_bg_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1189,391924,dbnum,3,redisServer.dbnum,,server.h,dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1190,391925,supervised,3,redisServer.supervised,,server.h,supervised,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1191,391926,supervised_mode,3,redisServer.supervised_mode,,server.h,supervised_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1192,391927,daemonize,3,redisServer.daemonize,,server.h,daemonize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1193,391928,set_proc_title,3,redisServer.set_proc_title,,server.h,set_proc_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1194,391931,pause_cron,3,redisServer.pause_cron,,server.h,pause_cron,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1195,391932,latency_tracking_enabled,3,redisServer.latency_tracking_enabled,,server.h,latency_tracking_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1196,391933,latency_tracking_info_percentiles,3,redisServer.latency_tracking_info_percentiles,,server.h,*latency_tracking_info_percentiles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1197,391934,latency_tracking_info_percentiles_len,3,redisServer.latency_tracking_info_percentiles_len,,server.h,latency_tracking_info_percentiles_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1198,391935,aof_enabled,3,redisServer.aof_enabled,,server.h,aof_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1199,391936,aof_state,3,redisServer.aof_state,,server.h,aof_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1200,391943,aof_rewrite_base_size,3,redisServer.aof_rewrite_base_size,,server.h,aof_rewrite_base_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1201,391944,aof_current_size,3,redisServer.aof_current_size,,server.h,aof_current_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1202,391945,aof_last_incr_size,3,redisServer.aof_last_incr_size,,server.h,aof_last_incr_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1203,391946,aof_last_incr_fsync_offset,3,redisServer.aof_last_incr_fsync_offset,,server.h,aof_last_incr_fsync_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1204,391947,aof_flush_sleep,3,redisServer.aof_flush_sleep,,server.h,aof_flush_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1205,391948,aof_rewrite_scheduled,3,redisServer.aof_rewrite_scheduled,,server.h,aof_rewrite_scheduled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1206,391949,aof_buf,3,redisServer.aof_buf,,server.h,aof_buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1207,391950,aof_fd,3,redisServer.aof_fd,,server.h,aof_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1208,391951,aof_selected_db,3,redisServer.aof_selected_db,,server.h,aof_selected_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1209,391952,aof_flush_postponed_start,3,redisServer.aof_flush_postponed_start,,server.h,aof_flush_postponed_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1210,391953,aof_last_fsync,3,redisServer.aof_last_fsync,,server.h,aof_last_fsync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1211,391954,aof_rewrite_time_last,3,redisServer.aof_rewrite_time_last,,server.h,aof_rewrite_time_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1212,391955,aof_rewrite_time_start,3,redisServer.aof_rewrite_time_start,,server.h,aof_rewrite_time_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1213,391956,aof_cur_timestamp,3,redisServer.aof_cur_timestamp,,server.h,aof_cur_timestamp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1214,391958,aof_lastbgrewrite_status,3,redisServer.aof_lastbgrewrite_status,,server.h,aof_lastbgrewrite_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1215,391959,aof_delayed_fsync,3,redisServer.aof_delayed_fsync,,server.h,aof_delayed_fsync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1216,391962,aof_last_write_status,3,redisServer.aof_last_write_status,,server.h,aof_last_write_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1217,391963,aof_last_write_errno,3,redisServer.aof_last_write_errno,,server.h,aof_last_write_errno,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1218,391966,aof_bio_fsync_status,3,redisServer.aof_bio_fsync_status,,server.h,aof_bio_fsync_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1219,391968,aof_manifest,3,redisServer.aof_manifest,,server.h,*aof_manifest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1220,391970,dirty,3,redisServer.dirty,,server.h,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1221,391972,rdb_last_load_keys_expired,3,redisServer.rdb_last_load_keys_expired,,server.h,rdb_last_load_keys_expired,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1222,391973,rdb_last_load_keys_loaded,3,redisServer.rdb_last_load_keys_loaded,,server.h,rdb_last_load_keys_loaded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1223,391976,saveparamslen,3,redisServer.saveparamslen,,server.h,saveparamslen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1224,391977,rdb_filename,3,redisServer.rdb_filename,,server.h,*rdb_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1225,391981,lastsave,3,redisServer.lastsave,,server.h,lastsave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1226,391982,lastbgsave_try,3,redisServer.lastbgsave_try,,server.h,lastbgsave_try,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1227,391983,rdb_save_time_last,3,redisServer.rdb_save_time_last,,server.h,rdb_save_time_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1228,391984,rdb_save_time_start,3,redisServer.rdb_save_time_start,,server.h,rdb_save_time_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1229,391985,rdb_bgsave_scheduled,3,redisServer.rdb_bgsave_scheduled,,server.h,rdb_bgsave_scheduled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1230,391986,rdb_child_type,3,redisServer.rdb_child_type,,server.h,rdb_child_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1231,391987,lastbgsave_status,3,redisServer.lastbgsave_status,,server.h,lastbgsave_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1232,391988,stop_writes_on_bgsave_err,3,redisServer.stop_writes_on_bgsave_err,,server.h,stop_writes_on_bgsave_err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1233,391991,rdb_pipe_conns,3,redisServer.rdb_pipe_conns,,server.h,**rdb_pipe_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1234,391992,rdb_pipe_numconns,3,redisServer.rdb_pipe_numconns,,server.h,rdb_pipe_numconns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1235,391993,rdb_pipe_numconns_writing,3,redisServer.rdb_pipe_numconns_writing,,server.h,rdb_pipe_numconns_writing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1236,391994,rdb_pipe_buff,3,redisServer.rdb_pipe_buff,,server.h,*rdb_pipe_buff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1237,391995,rdb_pipe_bufflen,3,redisServer.rdb_pipe_bufflen,,server.h,rdb_pipe_bufflen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1238,391998,child_info_pipe,3,redisServer.child_info_pipe,,server.h,child_info_pipe[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1239,391999,child_info_nread,3,redisServer.child_info_nread,,server.h,child_info_nread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1240,392000,also_propagate,3,redisServer.also_propagate,,server.h,also_propagate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1241,392001,replication_allowed,3,redisServer.replication_allowed,,server.h,replication_allowed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1242,392002,logfile,3,redisServer.logfile,,server.h,*logfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1243,392003,syslog_enabled,3,redisServer.syslog_enabled,,server.h,syslog_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1244,392004,syslog_ident,3,redisServer.syslog_ident,,server.h,*syslog_ident,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1245,392005,syslog_facility,3,redisServer.syslog_facility,,server.h,syslog_facility,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1246,392006,crashlog_enabled,3,redisServer.crashlog_enabled,,server.h,crashlog_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1247,392009,shutdown_timeout,3,redisServer.shutdown_timeout,,server.h,shutdown_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1248,392010,shutdown_on_sigint,3,redisServer.shutdown_on_sigint,,server.h,shutdown_on_sigint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1249,392012,replid,3,redisServer.replid,,server.h,replid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1250,392013,replid2,3,redisServer.replid2,,server.h,replid2[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1251,392014,master_repl_offset,3,redisServer.master_repl_offset,,server.h,master_repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1252,392015,second_replid_offset,3,redisServer.second_replid_offset,,server.h,second_replid_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1253,392016,fsynced_reploff_pending,3,redisServer.fsynced_reploff_pending,,server.h,fsynced_reploff_pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1254,392017,fsynced_reploff,3,redisServer.fsynced_reploff,,server.h,fsynced_reploff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1255,392018,slaveseldb,3,redisServer.slaveseldb,,server.h,slaveseldb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1256,392020,repl_backlog,3,redisServer.repl_backlog,,server.h,*repl_backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1257,392021,repl_backlog_size,3,redisServer.repl_backlog_size,,server.h,repl_backlog_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1258,392023,repl_no_slaves_since,3,redisServer.repl_no_slaves_since,,server.h,repl_no_slaves_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1259,392024,repl_min_slaves_to_write,3,redisServer.repl_min_slaves_to_write,,server.h,repl_min_slaves_to_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1260,392025,repl_min_slaves_max_lag,3,redisServer.repl_min_slaves_max_lag,,server.h,repl_min_slaves_max_lag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1261,392026,repl_good_slaves_count,3,redisServer.repl_good_slaves_count,,server.h,repl_good_slaves_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1262,392031,repl_buffer_mem,3,redisServer.repl_buffer_mem,,server.h,repl_buffer_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1263,392035,masterhost,3,redisServer.masterhost,,server.h,*masterhost,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1264,392036,masterport,3,redisServer.masterport,,server.h,masterport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1265,392038,master,3,redisServer.master,,server.h,*master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1266,392039,cached_master,3,redisServer.cached_master,,server.h,*cached_master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1267,392040,repl_syncio_timeout,3,redisServer.repl_syncio_timeout,,server.h,repl_syncio_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1268,392041,repl_state,3,redisServer.repl_state,,server.h,repl_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1269,392042,repl_transfer_size,3,redisServer.repl_transfer_size,,server.h,repl_transfer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1270,392043,repl_transfer_read,3,redisServer.repl_transfer_read,,server.h,repl_transfer_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1271,392045,repl_transfer_s,3,redisServer.repl_transfer_s,,server.h,*repl_transfer_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1272,392046,repl_transfer_fd,3,redisServer.repl_transfer_fd,,server.h,repl_transfer_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1273,392047,repl_transfer_tmpfile,3,redisServer.repl_transfer_tmpfile,,server.h,*repl_transfer_tmpfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1274,392048,repl_transfer_lastio,3,redisServer.repl_transfer_lastio,,server.h,repl_transfer_lastio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1275,392049,repl_serve_stale_data,3,redisServer.repl_serve_stale_data,,server.h,repl_serve_stale_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1276,392050,repl_slave_ro,3,redisServer.repl_slave_ro,,server.h,repl_slave_ro,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1277,392052,repl_down_since,3,redisServer.repl_down_since,,server.h,repl_down_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1278,392054,slave_priority,3,redisServer.slave_priority,,server.h,slave_priority,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1279,392055,replica_announced,3,redisServer.replica_announced,,server.h,replica_announced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1280,392059,repl_ignore_disk_write_error,3,redisServer.repl_ignore_disk_write_error,,server.h,repl_ignore_disk_write_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1281,392061,master_initial_offset,3,redisServer.master_initial_offset,,server.h,master_initial_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1282,392063,clients_waiting_acks,3,redisServer.clients_waiting_acks,,server.h,*clients_waiting_acks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1283,392064,get_ack_from_slaves,3,redisServer.get_ack_from_slaves,,server.h,get_ack_from_slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1284,392065,maxclients,3,redisServer.maxclients,,server.h,maxclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1285,392066,maxmemory,3,redisServer.maxmemory,,server.h,maxmemory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1286,392067,maxmemory_clients,3,redisServer.maxmemory_clients,,server.h,maxmemory_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1287,392068,maxmemory_policy,3,redisServer.maxmemory_policy,,server.h,maxmemory_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1288,392077,blocked_clients,3,redisServer.blocked_clients,,server.h,blocked_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1289,392078,blocked_clients_by_type,3,redisServer.blocked_clients_by_type,,server.h,blocked_clients_by_type[BLOCKED_NUM],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1290,392079,unblocked_clients,3,redisServer.unblocked_clients,,server.h,*unblocked_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1291,392080,ready_keys,3,redisServer.ready_keys,,server.h,*ready_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1292,392081,tracking_clients,3,redisServer.tracking_clients,,server.h,tracking_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1293,392083,tracking_pending_keys,3,redisServer.tracking_pending_keys,,server.h,*tracking_pending_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1294,392084,pending_push_messages,3,redisServer.pending_push_messages,,server.h,*pending_push_messages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1295,392101,unixtime,3,redisServer.unixtime,,server.h,unixtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1296,392102,timezone,3,redisServer.timezone,,server.h,timezone,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1297,392103,daylight_active,3,redisServer.daylight_active,,server.h,daylight_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1298,392104,mstime,3,redisServer.mstime,,server.h,mstime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1299,392105,ustime,3,redisServer.ustime,,server.h,ustime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1300,392106,cmd_time_snapshot,3,redisServer.cmd_time_snapshot,,server.h,cmd_time_snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1301,392107,blocking_op_nesting,3,redisServer.blocking_op_nesting,,server.h,blocking_op_nesting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1302,392108,blocked_last_cron,3,redisServer.blocked_last_cron,,server.h,blocked_last_cron,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1303,392109,pubsub_channels,3,redisServer.pubsub_channels,,server.h,*pubsub_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1304,392110,pubsub_patterns,3,redisServer.pubsub_patterns,,server.h,*pubsub_patterns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1305,392111,notify_keyspace_events,3,redisServer.notify_keyspace_events,,server.h,notify_keyspace_events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1306,392112,pubsubshard_channels,3,redisServer.pubsubshard_channels,,server.h,*pubsubshard_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1307,392113,cluster_enabled,3,redisServer.cluster_enabled,,server.h,cluster_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1308,392119,cluster,3,redisServer.cluster,,server.h,*cluster,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1309,392132,cluster_module_flags,3,redisServer.cluster_module_flags,,server.h,cluster_module_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1310,392134,cluster_config_file_lock_fd,3,redisServer.cluster_config_file_lock_fd,,server.h,cluster_config_file_lock_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1311,392136,cluster_drop_packet_filter,3,redisServer.cluster_drop_packet_filter,,server.h,cluster_drop_packet_filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1312,392138,pre_command_oom_state,3,redisServer.pre_command_oom_state,,server.h,pre_command_oom_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1313,392145,latency_monitor_threshold,3,redisServer.latency_monitor_threshold,,server.h,latency_monitor_threshold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1314,392149,requirepass,3,redisServer.requirepass,,server.h,requirepass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1315,392151,acl_info,3,redisServer.acl_info,,server.h,acl_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1316,392152,watchdog_period,3,redisServer.watchdog_period,,server.h,watchdog_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1317,392153,system_memory_size,3,redisServer.system_memory_size,,server.h,system_memory_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1318,392154,tls_cluster,3,redisServer.tls_cluster,,server.h,tls_cluster,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1319,392155,tls_replication,3,redisServer.tls_replication,,server.h,tls_replication,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1320,392157,tls_ctx_config,3,redisServer.tls_ctx_config,,server.h,tls_ctx_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1321,392164,failover_end_time,3,redisServer.failover_end_time,,server.h,failover_end_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1322,392165,force_failover,3,redisServer.force_failover,,server.h,force_failover,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1323,392166,target_replica_host,3,redisServer.target_replica_host,,server.h,*target_replica_host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1324,392167,target_replica_port,3,redisServer.target_replica_port,,server.h,target_replica_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1325,392168,failover_state,3,redisServer.failover_state,,server.h,failover_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1326,392170,reply_buffer_peak_reset_time,3,redisServer.reply_buffer_peak_reset_time,,server.h,reply_buffer_peak_reset_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1327,392171,reply_buffer_resizing_enabled,3,redisServer.reply_buffer_resizing_enabled,,server.h,reply_buffer_resizing_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1328,392172,locale_collate,3,redisServer.locale_collate,,server.h,*locale_collate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1329,392244,keysbuf,3,getKeysResult.keysbuf,,server.h,keysbuf[MAX_KEYS_BUFFER],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1330,392245,keys,3,getKeysResult.keys,,server.h,*keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1331,392246,numkeys,3,getKeysResult.numkeys,,server.h,numkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
1332,392247,size,3,getKeysResult.size,,server.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1333,392285,flags,3,keySpec.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1334,392286,begin_search_type,3,keySpec.begin_search_type,,server.h,begin_search_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1335,392295,bs,3,keySpec.bs,,server.h,bs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1336,392296,find_keys_type,3,keySpec.find_keys_type,,server.h,find_keys_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1337,392348,declared_name,3,redisCommand.declared_name,,server.h,*declared_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1338,392349,summary,3,redisCommand.summary,,server.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1339,392350,complexity,3,redisCommand.complexity,,server.h,*complexity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1340,392351,since,3,redisCommand.since,,server.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1341,392352,doc_flags,3,redisCommand.doc_flags,,server.h,doc_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1342,392353,replaced_by,3,redisCommand.replaced_by,,server.h,*replaced_by,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1343,392354,deprecated_since,3,redisCommand.deprecated_since,,server.h,*deprecated_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1344,392355,group,3,redisCommand.group,,server.h,group,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1345,392356,history,3,redisCommand.history,,server.h,*history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1346,392357,num_history,3,redisCommand.num_history,,server.h,num_history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1347,392358,tips,3,redisCommand.tips,,server.h,**tips,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1348,392359,num_tips,3,redisCommand.num_tips,,server.h,num_tips,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1349,392360,proc,3,redisCommand.proc,,server.h,*proc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1350,392361,arity,3,redisCommand.arity,,server.h,arity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1351,392362,flags,3,redisCommand.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
1352,392363,acl_categories,3,redisCommand.acl_categories,,server.h,acl_categories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1353,392364,key_specs,3,redisCommand.key_specs,,server.h,*key_specs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,63,0,1,1,0,0,,0,0,0,0,0,
1354,392365,key_specs_num,3,redisCommand.key_specs_num,,server.h,key_specs_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1355,392366,getkeys_proc,3,redisCommand.getkeys_proc,,server.h,*getkeys_proc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1356,392367,num_args,3,redisCommand.num_args,,server.h,num_args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1357,392369,subcommands,3,redisCommand.subcommands,,server.h,*subcommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1358,392371,args,3,redisCommand.args,,server.h,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1359,392374,microseconds,3,redisCommand.microseconds,,server.h,microseconds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1360,392375,calls,3,redisCommand.calls,,server.h,calls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1361,392376,rejected_calls,3,redisCommand.rejected_calls,,server.h,rejected_calls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1362,392377,failed_calls,3,redisCommand.failed_calls,,server.h,failed_calls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1363,392378,id,3,redisCommand.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1364,392379,fullname,3,redisCommand.fullname,,server.h,fullname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,34,0,1,1,0,0,,0,0,0,0,0,
1365,392381,latency_histogram,3,redisCommand.latency_histogram,,server.h,* latency_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1366,392382,legacy_range_key_spec,3,redisCommand.legacy_range_key_spec,,server.h,legacy_range_key_spec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1367,392383,subcommands_dict,3,redisCommand.subcommands_dict,,server.h,*subcommands_dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
1368,392385,parent,3,redisCommand.parent,,server.h,*parent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1369,392387,module_cmd,3,redisCommand.module_cmd,,server.h,*module_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1370,392389,count,3,redisError.count,,server.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1371,392407,direction,3,listTypeIterator.direction,,server.h,direction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1372,392425,encoding,3,hashTypeIterator.encoding,,server.h,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1373,394748,min,3,zrangespec.min,,server.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1374,394749,max,3,zrangespec.max,,server.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1375,394750,minex,3,zrangespec.minex,,server.h,minex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1376,394751,maxex,3,zrangespec.maxex,,server.h,maxex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1377,394754,min,3,zlexrangespec.min,,server.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1378,394755,max,3,zlexrangespec.max,,server.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1379,394756,minex,3,zlexrangespec.minex,,server.h,minex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1380,394757,maxex,3,zlexrangespec.maxex,,server.h,maxex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1381,395621,name,3,configEnum.name,,server.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1382,395622,val,3,configEnum.val,,server.h,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1383,396455,flags,3,luaScript.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1384,396456,body,3,luaScript.body,,server.h,*body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1385,407584,state,3,SHA1_CTX.state,,sha1.h,state[5],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1386,407585,count,3,SHA1_CTX.count,,sha1.h,count[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1387,407586,buffer,3,SHA1_CTX.buffer,,sha1.h,buffer[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1388,408626,data,3,SHA256_CTX.data,,sha256.h,data[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1389,408627,datalen,3,SHA256_CTX.datalen,,sha256.h,datalen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1390,408628,bitlen,3,SHA256_CTX.bitlen,,sha256.h,bitlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1391,408629,state,3,SHA256_CTX.state,,sha256.h,state[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
1392,411167,argv,3,slowlogEntry.argv,,slowlog.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1393,411168,argc,3,slowlogEntry.argc,,slowlog.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1394,411169,id,3,slowlogEntry.id,,slowlog.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1395,411170,duration,3,slowlogEntry.duration,,slowlog.h,duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1396,411171,time,3,slowlogEntry.time,,slowlog.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1397,411172,cname,3,slowlogEntry.cname,,slowlog.h,cname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1398,411173,peerid,3,slowlogEntry.peerid,,slowlog.h,peerid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1399,415401,value,3,sample.value,,sparkline.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1400,415404,length,3,sequence.length,,sparkline.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1401,415405,labels,3,sequence.labels,,sparkline.h,labels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1402,415407,samples,3,sequence.samples,,sparkline.h,*samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1403,415408,min,3,sequence.min,,sparkline.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1404,415409,max,3,sequence.max,,sparkline.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1405,415453,ms,3,streamID.ms,,stream.h,ms,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1406,415454,seq,3,streamID.seq,,stream.h,seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1407,415457,rax,3,stream.rax,,stream.h,*rax,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1408,415458,length,3,stream.length,,stream.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1409,415459,last_id,3,stream.last_id,,stream.h,last_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1410,415460,first_id,3,stream.first_id,,stream.h,first_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1411,415461,max_deleted_entry_id,3,stream.max_deleted_entry_id,,stream.h,max_deleted_entry_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1412,415462,entries_added,3,stream.entries_added,,stream.h,entries_added,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1413,415463,cgroups,3,stream.cgroups,,stream.h,*cgroups,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1414,415500,last_id,3,streamCG.last_id,,stream.h,last_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1415,415501,entries_read,3,streamCG.entries_read,,stream.h,entries_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1416,415502,pel,3,streamCG.pel,,stream.h,*pel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1417,415503,consumers,3,streamCG.consumers,,stream.h,*consumers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1418,415506,seen_time,3,streamConsumer.seen_time,,stream.h,seen_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1419,415507,active_time,3,streamConsumer.active_time,,stream.h,active_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1420,415508,name,3,streamConsumer.name,,stream.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1421,415509,pel,3,streamConsumer.pel,,stream.h,*pel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1422,415512,delivery_time,3,streamNACK.delivery_time,,stream.h,delivery_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1423,415513,delivery_count,3,streamNACK.delivery_count,,stream.h,delivery_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1424,415514,consumer,3,streamNACK.consumer,,stream.h,*consumer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1425,416211,name,3,check.name,,syscheck.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1426,433800,trim_strategy,3,streamAddTrimArgs.trim_strategy,,t_stream.c,trim_strategy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1427,433802,approx_trim,3,streamAddTrimArgs.approx_trim,,t_stream.c,approx_trim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1428,433803,limit,3,streamAddTrimArgs.limit,,t_stream.c,limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1429,433804,maxlen,3,streamAddTrimArgs.maxlen,,t_stream.c,maxlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1430,433805,minid,3,streamAddTrimArgs.minid,,t_stream.c,minid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1431,456548,subject,3,zsetopsrc.subject,,t_zset.c,*subject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1432,456549,type,3,zsetopsrc.type,,t_zset.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1433,456550,encoding,3,zsetopsrc.encoding,,t_zset.c,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1434,456579,iter,3,zsetopsrc.iter,,t_zset.c,iter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1435,456582,flags,3,zsetopval.flags,,t_zset.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1436,456584,ele,3,zsetopval.ele,,t_zset.c,ele,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1437,456585,estr,3,zsetopval.estr,,t_zset.c,*estr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1438,456586,elen,3,zsetopval.elen,,t_zset.c,elen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1439,456587,ell,3,zsetopval.ell,,t_zset.c,ell,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1440,456588,score,3,zsetopval.score,,t_zset.c,score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1441,459951,client,3,zrange_result_handler.client,,t_zset.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1442,459952,dstkey,3,zrange_result_handler.dstkey,,t_zset.c,*dstkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1443,459953,dstobj,3,zrange_result_handler.dstobj,,t_zset.c,*dstobj,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1444,459954,userdata,3,zrange_result_handler.userdata,,t_zset.c,*userdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1445,459955,withscores,3,zrange_result_handler.withscores,,t_zset.c,withscores,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1446,459956,should_emit_array_length,3,zrange_result_handler.should_emit_array_length,,t_zset.c,should_emit_array_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1447,459957,beginResultEmission,3,zrange_result_handler.beginResultEmission,,t_zset.c,beginResultEmission,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1448,459958,finalizeResultEmission,3,zrange_result_handler.finalizeResultEmission,,t_zset.c,finalizeResultEmission,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1449,459959,emitResultFromCBuffer,3,zrange_result_handler.emitResultFromCBuffer,,t_zset.c,emitResultFromCBuffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1450,459960,emitResultFromLongLong,3,zrange_result_handler.emitResultFromLongLong,,t_zset.c,emitResultFromLongLong,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1451,465631,keys,3,bcastState.keys,,tracking.c,*keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1452,465632,clients,3,bcastState.clients,,tracking.c,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1453,471622,prevrawlensize,3,zlentry.prevrawlensize,,ziplist.c,prevrawlensize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,54,0,1,1,0,0,,0,0,0,0,0,
1454,471623,prevrawlen,3,zlentry.prevrawlen,,ziplist.c,prevrawlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
1455,471624,lensize,3,zlentry.lensize,,ziplist.c,lensize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
1456,471625,len,3,zlentry.len,,ziplist.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,59,0,1,1,0,0,,0,0,0,0,0,
1457,471626,headersize,3,zlentry.headersize,,ziplist.c,headersize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
1458,471627,encoding,3,zlentry.encoding,,ziplist.c,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,57,0,1,1,0,0,,0,0,0,0,0,
1459,471628,p,3,zlentry.p,,ziplist.c,*p,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1460,478177,sval,3,ziplistEntry.sval,,ziplist.h,*sval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1461,478178,slen,3,ziplistEntry.slen,,ziplist.h,slen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1462,478179,lval,3,ziplistEntry.lval,,ziplist.h,lval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1463,282,ACLResetFirstArgsForCommand,1,ACLResetFirstArgsForCommand,"void ACLResetFirstArgsForCommand (aclSelector*,long unsigned)",acl.c,"void ACLResetFirstArgsForCommand(aclSelector *selector, unsigned long id) {
    if (selector->allowed_firstargs && selector->allowed_firstargs[id]) {
        for (int i = 0; selector->allowed_firstargs[id][i]; i++)
            sdsfree(selector->allowed_firstargs[id][i]);
        zfree(selector->allowed_firstargs[id]);
        selector->allowed_firstargs[id] = NULL;
    }
}",889.0,896.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1464,288,ACLResetFirstArgs,1,ACLResetFirstArgs,void ACLResetFirstArgs (aclSelector*),acl.c,"void ACLResetFirstArgs(aclSelector *selector) {
    if (selector->allowed_firstargs == NULL) return;
    for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++) {
        if (selector->allowed_firstargs[j]) {
            for (int i = 0; selector->allowed_firstargs[j][i]; i++)
                sdsfree(selector->allowed_firstargs[j][i]);
            zfree(selector->allowed_firstargs[j]);
        }
    }
    zfree(selector->allowed_firstargs);
    selector->allowed_firstargs = NULL;
}",901.0,912.0,1.0,24.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1465,293,ACLAddAllowedFirstArg,1,ACLAddAllowedFirstArg,"void ACLAddAllowedFirstArg (aclSelector*,long unsigned,char*)",acl.c,"void ACLAddAllowedFirstArg(aclSelector *selector, unsigned long id, const char *sub) {
    /* If this is the first first-arg to be configured for
     * this user, we have to allocate the first-args array. */
    if (selector->allowed_firstargs == NULL) {
        selector->allowed_firstargs = zcalloc(USER_COMMAND_BITS_COUNT * sizeof(sds*));
    }

    /* We also need to enlarge the allocation pointing to the
     * null terminated SDS array, to make space for this one.
     * To start check the current size, and while we are here
     * make sure the first-arg is not already specified inside. */
    long items = 0;
    if (selector->allowed_firstargs[id]) {
        while(selector->allowed_firstargs[id][items]) {
            /* If it's already here do not add it again. */
            if (!strcasecmp(selector->allowed_firstargs[id][items],sub))
                return;
            items++;
        }
    }

    /* Now we can make space for the new item (and the null term). */
    items ...",916.0,942.0,1.0,46.0,27.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1466,300,ACLFreeLogEntry,1,ACLFreeLogEntry,void ACLFreeLogEntry (void*),acl.c,"void ACLFreeLogEntry(void *leptr) {
    ACLLogEntry *le = leptr;
    sdsfree(le->object);
    sdsfree(le->username);
    sdsfree(le->cinfo);
    zfree(le);
}",2529.0,2535.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1467,305,ACLSetSelector,1,ACLSetSelector,"int ACLSetSelector (aclSelector*,char*,size_t)",acl.c,"int ACLSetSelector(aclSelector *selector, const char* op, size_t oplen) {
    if (!strcasecmp(op,""allkeys"") ||
               !strcasecmp(op,""~*""))
    {
        selector->flags |= SELECTOR_FLAG_ALLKEYS;
        listEmpty(selector->patterns);
    } else if (!strcasecmp(op,""resetkeys"")) {
        selector->flags &= ~SELECTOR_FLAG_ALLKEYS;
        listEmpty(selector->patterns);
    } else if (!strcasecmp(op,""allchannels"") ||
               !strcasecmp(op,""&*""))
    {
        selector->flags |= SELECTOR_FLAG_ALLCHANNELS;
        listEmpty(selector->channels);
    } else if (!strcasecmp(op,""resetchannels"")) {
        selector->flags &= ~SELECTOR_FLAG_ALLCHANNELS;
        listEmpty(selector->channels);
    } else if (!strcasecmp(op,""allcommands"") ||
               !strcasecmp(op,""+@all""))
    {
        memset(selector->allowed_commands,255,sizeof(selector->allowed_commands));
        selector->flags |= SELECTOR_FLAG_ALLCOMMANDS;
        sdsclear(selector->command_rules);
        ACLReset...",1008.0,1178.0,1.0,27.0,171.0,0,0,0,0,5,0,1,1,0,0,,0,0,6,3,3,int
1468,312,time_independent_strcmp,1,time_independent_strcmp,"int time_independent_strcmp (char*,char*,int)",acl.c,"int time_independent_strcmp(char *a, char *b, int len) {
    int diff = 0;
    for (int j = 0; j < len; j++) {
        diff |= (a[j] ^ b[j]);
    }
    return diff; /* If zero strings are the same. */
}",162.0,168.0,1.0,1.0,7.0,6,4,10,5,1,0,2,2,0,0,,0,0,6,3,3,int
1469,346,ACLHashPassword,1,ACLHashPassword,"sds ACLHashPassword (unsigned char*,size_t)",acl.c,"sds ACLHashPassword(unsigned char *cleartext, size_t len) {
    SHA256_CTX ctx;
    unsigned char hash[SHA256_BLOCK_SIZE];
    char hex[HASH_PASSWORD_LEN];
    char *cset = ""0123456789abcdef"";

    sha256_init(&ctx);
    sha256_update(&ctx,(unsigned char*)cleartext,len);
    sha256_final(&ctx,hash);

    for (int j = 0; j < SHA256_BLOCK_SIZE; j++) {
        hex[j*2] = cset[((hash[j]&0xF0)>>4)];
        hex[j*2+1] = cset[(hash[j]&0xF)];
    }
    return sdsnewlen(hex,HASH_PASSWORD_LEN);
}",172.0,187.0,1.0,23.0,16.0,22,9,20,7,1,4,2,2,0,4,,0,0,4,2,2,sds
1470,493,ACLStringHasSpaces,1,ACLStringHasSpaces,"int ACLStringHasSpaces (char*,size_t)",acl.c,"int ACLStringHasSpaces(const char *s, size_t len) {
    for (size_t i = 0; i < len; i++) {
        if (isspace(s[i]) || s[i] == 0) return 1;
    }
    return 0;
}",217.0,222.0,1.0,1.0,6.0,6,5,7,3,3,0,3,4,0,0,,0,0,4,2,2,int
1471,527,ACLGetCommandCategoryFlagByName,1,ACLGetCommandCategoryFlagByName,uint64_t ACLGetCommandCategoryFlagByName (char*),acl.c,"uint64_t ACLGetCommandCategoryFlagByName(const char *name) {
    for (int j = 0; ACLCommandCategories[j].flag != 0; j++) {
        if (!strcasecmp(name,ACLCommandCategories[j].name)) {
            return ACLCommandCategories[j].flag;
        }
    }
    return 0; /* No match. */
}",226.0,233.0,1.0,1.0,8.0,9,5,8,3,4,3,3,4,2,0,,0,3,2,1,1,uint64_t
1472,566,ACLListMatchLoadedUser,1,ACLListMatchLoadedUser,"int ACLListMatchLoadedUser (void*,void*)",acl.c,"int ACLListMatchLoadedUser(void *definition, void *user) {
    sds *user_definition = definition;
    return sdscmp(user_definition[0], user) == 0;
}",238.0,241.0,1.0,1.0,4.0,3,3,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
1473,584,ACLListMatchSds,1,ACLListMatchSds,"int ACLListMatchSds (void*,void*)",acl.c,"int ACLListMatchSds(void *a, void *b) {
    return sdscmp(a,b) == 0;
}",245.0,247.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
1474,596,ACLListFreeSds,1,ACLListFreeSds,void ACLListFreeSds (void*),acl.c,"void ACLListFreeSds(void *item) {
    sdsfree(item);
}",250.0,252.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1475,603,ACLListDupSds,1,ACLListDupSds,void* ACLListDupSds (void*),acl.c,"void *ACLListDupSds(void *item) {
    return sdsdup(item);
}",255.0,257.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void*
1476,615,ACLKeyPatternCreate,1,ACLKeyPatternCreate,"keyPattern ACLKeyPatternCreate (sds,int)",acl.c,"keyPattern *ACLKeyPatternCreate(sds pattern, int flags) {
    keyPattern *new = (keyPattern *) zmalloc(sizeof(keyPattern));
    new->pattern = pattern;
    new->flags = flags;
    return new;
}",267.0,272.0,1.0,1.0,6.0,7,4,7,4,1,4,1,1,0,1,,0,4,4,2,2,keyPattern
1477,641,ACLKeyPatternFree,1,ACLKeyPatternFree,void ACLKeyPatternFree (keyPattern*),acl.c,"void ACLKeyPatternFree(keyPattern *pattern) {
    sdsfree(pattern->pattern);
    zfree(pattern);
}",275.0,278.0,1.0,1.0,4.0,1,1,2,1,1,3,1,1,0,2,,0,1,2,1,1,void
1478,652,ACLListMatchKeyPattern,1,ACLListMatchKeyPattern,"int ACLListMatchKeyPattern (void*,void*)",acl.c,"int ACLListMatchKeyPattern(void *a, void *b) {
    return sdscmp(((keyPattern *) a)->pattern,((keyPattern *) b)->pattern) == 0;
}",282.0,284.0,1.0,1.0,3.0,5,3,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
1479,672,ACLListFreeKeyPattern,1,ACLListFreeKeyPattern,void ACLListFreeKeyPattern (void*),acl.c,"void ACLListFreeKeyPattern(void *item) {
    ACLKeyPatternFree(item);
}",287.0,289.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1480,679,ACLListDupKeyPattern,1,ACLListDupKeyPattern,void* ACLListDupKeyPattern (void*),acl.c,"void *ACLListDupKeyPattern(void *item) {
    keyPattern *old = (keyPattern *) item;
    return ACLKeyPatternCreate(sdsdup(old->pattern), old->flags);
}",292.0,295.0,1.0,1.0,4.0,4,3,4,2,0,4,1,1,0,2,,0,3,2,1,1,void*
1481,699,sdsCatPatternString,1,sdsCatPatternString,"sds sdsCatPatternString (sds,keyPattern*)",acl.c,"sds sdsCatPatternString(sds base, keyPattern *pat) {
    if (pat->flags == ACL_ALL_PERMISSION) {
        base = sdscatlen(base,""~"",1);
    } else if (pat->flags == ACL_READ_PERMISSION) {
        base = sdscatlen(base,""%R~"",3);
    } else if (pat->flags == ACL_WRITE_PERMISSION) {
        base = sdscatlen(base,""%W~"",3);
    } else {
        serverPanic(""Invalid key pattern flag detected"");
    }
    return sdscatsds(base, pat->pattern);
}",299.0,310.0,1.0,22.0,12.0,7,5,5,2,0,4,2,2,1,2,,0,3,4,2,2,sds
1482,780,ACLCreateSelector,1,ACLCreateSelector,aclSelector ACLCreateSelector (int),acl.c,"aclSelector *ACLCreateSelector(int flags) {
    aclSelector *selector = zmalloc(sizeof(aclSelector));
    selector->flags = flags | server.acl_pubsub_default;
    selector->patterns = listCreate();
    selector->channels = listCreate();
    selector->allowed_firstargs = NULL;
    selector->command_rules = sdsempty();

    listSetMatchMethod(selector->patterns,ACLListMatchKeyPattern);
    listSetFreeMethod(selector->patterns,ACLListFreeKeyPattern);
    listSetDupMethod(selector->patterns,ACLListDupKeyPattern);
    listSetMatchMethod(selector->channels,ACLListMatchSds);
    listSetFreeMethod(selector->channels,ACLListFreeSds);
    listSetDupMethod(selector->channels,ACLListDupSds);
    memset(selector->allowed_commands,0,sizeof(selector->allowed_commands));

    return selector;
}",314.0,331.0,1.0,4.0,18.0,41,5,25,5,3,24,1,1,0,4,,0,24,2,1,1,aclSelector
1483,909,ACLFreeSelector,1,ACLFreeSelector,void ACLFreeSelector (aclSelector*),acl.c,"void ACLFreeSelector(aclSelector *selector) {
    listRelease(selector->patterns);
    listRelease(selector->channels);
    sdsfree(selector->command_rules);
    ACLResetFirstArgs(selector);
    zfree(selector);
}",334.0,340.0,1.0,1.0,7.0,3,1,5,1,3,8,1,1,0,5,,0,3,2,1,1,void
1484,930,ACLCopySelector,1,ACLCopySelector,aclSelector ACLCopySelector (aclSelector*),acl.c,"aclSelector *ACLCopySelector(aclSelector *src) {
    aclSelector *dst = zmalloc(sizeof(aclSelector));
    dst->flags = src->flags;
    dst->patterns = listDup(src->patterns);
    dst->channels = listDup(src->channels);
    dst->command_rules = sdsdup(src->command_rules);
    memcpy(dst->allowed_commands,src->allowed_commands,
           sizeof(dst->allowed_commands));
    dst->allowed_firstargs = NULL;
    /* Copy the allowed first-args array of array of SDS strings. */
    if (src->allowed_firstargs) {
        for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++) {
            if (!(src->allowed_firstargs[j])) continue;
            for (int i = 0; src->allowed_firstargs[j][i]; i++) {
                ACLAddAllowedFirstArg(dst, j, src->allowed_firstargs[j][i]);
            }
        }
    }
    return dst;
}",343.0,362.0,1.0,28.0,20.0,33,6,30,6,1,22,6,10,3,5,,0,21,2,1,1,aclSelector
1485,1044,ACLListFreeSelector,1,ACLListFreeSelector,void ACLListFreeSelector (void*),acl.c,"void ACLListFreeSelector(void *a) {
    ACLFreeSelector((aclSelector *) a);
}",365.0,367.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1486,1053,ACLListDuplicateSelector,1,ACLListDuplicateSelector,void* ACLListDuplicateSelector (void*),acl.c,"void *ACLListDuplicateSelector(void *src) {
    return ACLCopySelector((aclSelector *)src);
}",370.0,372.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void*
1487,1063,ACLUserGetRootSelector,1,ACLUserGetRootSelector,aclSelector ACLUserGetRootSelector (user*),acl.c,"aclSelector *ACLUserGetRootSelector(user *u) {
    serverAssert(listLength(u->selectors));
    aclSelector *s = (aclSelector *) listNodeValue(listFirst(u->selectors));
    serverAssert(s->flags & SELECTOR_FLAG_ROOT);
    return s;
}",377.0,382.0,1.0,4.0,6.0,18,8,5,2,0,5,1,1,0,2,,0,3,2,1,1,aclSelector
1488,1122,ACLCreateUser,1,ACLCreateUser,"user ACLCreateUser (char*,size_t)",acl.c,"user *ACLCreateUser(const char *name, size_t namelen) {
    if (raxFind(Users,(unsigned char*)name,namelen) != raxNotFound) return NULL;
    user *u = zmalloc(sizeof(*u));
    u->name = sdsnewlen(name,namelen);
    u->flags = USER_FLAG_DISABLED;
    u->flags |= USER_FLAG_SANITIZE_PAYLOAD;
    u->passwords = listCreate();
    u->acl_string = NULL;
    listSetMatchMethod(u->passwords,ACLListMatchSds);
    listSetFreeMethod(u->passwords,ACLListFreeSds);
    listSetDupMethod(u->passwords,ACLListDupSds);

    u->selectors = listCreate();
    listSetFreeMethod(u->selectors,ACLListFreeSelector);
    listSetDupMethod(u->selectors,ACLListDuplicateSelector);

    /* Add the initial root selector */
    aclSelector *s = ACLCreateSelector(SELECTOR_FLAG_ROOT);
    listAddNodeHead(u->selectors, s);

    raxInsert(Users,(unsigned char*)name,namelen,u,NULL);
    return u;
}",389.0,411.0,1.0,15.0,23.0,42,7,35,7,5,27,2,2,2,8,,0,25,4,2,2,user
1489,1276,ACLCreateUnlinkedUser,1,ACLCreateUnlinkedUser,user ACLCreateUnlinkedUser (void),acl.c,"user *ACLCreateUnlinkedUser(void) {
    char username[64];
    for (int j = 0; ; j++) {
        snprintf(username,sizeof(username),""__fakeuser:%d__"",j);
        user *fakeuser = ACLCreateUser(username,strlen(username));
        if (fakeuser == NULL) continue;
        int retval = raxRemove(Users,(unsigned char*) username,
                               strlen(username),NULL);
        serverAssert(retval != 0);
        return fakeuser;
    }
}",417.0,428.0,1.0,8.0,12.0,12,9,17,6,3,4,4,4,0,3,,0,3,2,1,1,user
1490,1339,ACLFreeUser,1,ACLFreeUser,void ACLFreeUser (user*),acl.c,"void ACLFreeUser(user *u) {
    sdsfree(u->name);
    if (u->acl_string) {
        decrRefCount(u->acl_string);
        u->acl_string = NULL;
    }
    listRelease(u->passwords);
    listRelease(u->selectors);
    zfree(u);
}",432.0,441.0,1.0,1.0,10.0,7,2,8,2,5,11,2,2,1,5,,0,6,2,1,1,void
1491,1372,ACLFreeUserAndKillClients,1,ACLFreeUserAndKillClients,void ACLFreeUserAndKillClients (user*),acl.c,"void ACLFreeUserAndKillClients(user *u) {
    listIter li;
    listNode *ln;
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (c->user == u) {
            /* We'll free the connection asynchronously, so
             * in theory to set a different user is not needed.
             * However if there are bugs in Redis, soon or later
             * this may result in some security hole: it's much
             * more defensive to set the default user and put
             * it in non authenticated mode. */
            c->user = DefaultUser;
            c->authenticated = 0;
            /* We will write replies to this client later, so we can't
             * close it directly even if async. */
            if (c == server.current_client) {
                c->flags |= CLIENT_CLOSE_AFTER_COMMAND;
            } else {
                freeClientAsync(c);
            }
        }
    }
    ACLFreeUser(u);
}",446.0,471.0,1.0,20.0,26.0,17,7,17,7,1,9,4,7,2,3,,0,7,2,1,1,void
1492,1442,ACLCopyUser,1,ACLCopyUser,"void ACLCopyUser (user*,user*)",acl.c,"void ACLCopyUser(user *dst, user *src) {
    listRelease(dst->passwords);
    listRelease(dst->selectors);
    dst->passwords = listDup(src->passwords);
    dst->selectors = listDup(src->selectors);
    dst->flags = src->flags;
    if (dst->acl_string) {
        decrRefCount(dst->acl_string);
    }
    dst->acl_string = src->acl_string;
    if (dst->acl_string) {
        /* if src is NULL, we set it to NULL, if not, need to increment reference count */
        incrRefCount(dst->acl_string);
    }
}",476.0,490.0,1.0,1.0,15.0,18,2,14,2,3,20,3,3,2,6,,0,16,4,2,2,void
1493,1504,ACLFreeUsersSet,1,ACLFreeUsersSet,void ACLFreeUsersSet (rax*),acl.c,"void ACLFreeUsersSet(rax *users) {
    raxFreeWithCallback(users,(void(*)(void*))ACLFreeUserAndKillClients);
}",494.0,496.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
1494,1514,ACLGetCommandBitCoordinates,1,ACLGetCommandBitCoordinates,"int ACLGetCommandBitCoordinates (uint64_t,uint64_t*,uint64_t*)",acl.c,"int ACLGetCommandBitCoordinates(uint64_t id, uint64_t *word, uint64_t *bit) {
    if (id >= USER_COMMAND_BITS_COUNT) return C_ERR;
    *word = id / sizeof(uint64_t) / 8;
    *bit = 1ULL << (id % (sizeof(uint64_t) * 8));
    return C_OK;
}",504.0,509.0,1.0,14.0,6.0,13,9,7,4,2,0,2,2,0,0,,0,0,6,3,3,int
1495,1557,ACLGetSelectorCommandBit,1,ACLGetSelectorCommandBit,"int ACLGetSelectorCommandBit (aclSelector*,long unsigned)",acl.c,"int ACLGetSelectorCommandBit(const aclSelector *selector, unsigned long id) {
    uint64_t word, bit;
    if (ACLGetCommandBitCoordinates(id,&word,&bit) == C_ERR) return 0;
    return (selector->allowed_commands[word] & bit) != 0;
}",518.0,522.0,1.0,54.0,5.0,8,7,6,4,3,2,2,2,1,1,,0,2,4,2,2,int
1496,1590,ACLSelectorCanExecuteFutureCommands,1,ACLSelectorCanExecuteFutureCommands,int ACLSelectorCanExecuteFutureCommands (aclSelector*),acl.c,"int ACLSelectorCanExecuteFutureCommands(aclSelector *selector) {
    return ACLGetSelectorCommandBit(selector,USER_COMMAND_BITS_COUNT-1);
}",527.0,529.0,1.0,45.0,3.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,int
1497,1603,ACLSetSelectorCommandBit,1,ACLSetSelectorCommandBit,"void ACLSetSelectorCommandBit (aclSelector*,long unsigned,int)",acl.c,"void ACLSetSelectorCommandBit(aclSelector *selector, unsigned long id, int value) {
    uint64_t word, bit;
    if (ACLGetCommandBitCoordinates(id,&word,&bit) == C_ERR) return;
    if (value) {
        selector->allowed_commands[word] |= bit;
    } else {
        selector->allowed_commands[word] &= ~bit;
        selector->flags &= ~SELECTOR_FLAG_ALLCOMMANDS;
    }
}",536.0,545.0,1.0,54.0,10.0,6,5,7,5,2,2,3,3,1,1,,0,2,6,3,3,void
1498,1656,ACLSelectorRemoveCommandRule,1,ACLSelectorRemoveCommandRule,"void ACLSelectorRemoveCommandRule (aclSelector*,sds)",acl.c,"void ACLSelectorRemoveCommandRule(aclSelector *selector, sds new_rule) {
    size_t new_len = sdslen(new_rule);
    char *existing_rule = selector->command_rules;

    /* Loop over the existing rules, trying to find a rule that ""matches""
     * the new rule. If we find a match, then remove the command from the string by
     * copying the later rules over it. */
    while(existing_rule[0]) {
        /* The first character of the rule is +/-, which we don't need to compare. */
        char *copy_position = existing_rule;
        existing_rule += 1;

        /* Assume a trailing space after a command is part of the command, like '+get ', so trim it
         * as well if the command is removed. */
        char *rule_end = strchr(existing_rule, ' ');
        if (!rule_end) {
            /* This is the last rule, so it it to the end of the string. */
            rule_end = existing_rule + strlen(existing_rule);

            /* This approach can leave a trailing space if the last rule is ...",550.0,590.0,1.0,45.0,41.0,31,17,44,8,1,5,7,14,1,2,,0,4,4,2,2,void
1499,1774,ACLUpdateCommandRules,1,ACLUpdateCommandRules,"void ACLUpdateCommandRules (aclSelector*,char*,int)",acl.c,"void ACLUpdateCommandRules(aclSelector *selector, const char *rule, int allow) {
    sds new_rule = sdsnew(rule);
    sdstolower(new_rule);

    ACLSelectorRemoveCommandRule(selector, new_rule);
    if (sdslen(selector->command_rules)) selector->command_rules = sdscat(selector->command_rules, "" "");
    selector->command_rules = sdscatfmt(selector->command_rules, allow ? ""+%S"" : ""-%S"", new_rule);
    sdsfree(new_rule);
}",594.0,602.0,1.0,1.0,9.0,9,3,13,4,1,12,2,2,2,7,,0,9,6,3,3,void
1500,1821,ACLChangeSelectorPerm,1,ACLChangeSelectorPerm,"void ACLChangeSelectorPerm (aclSelector*,redisCommand*,int)",acl.c,"void ACLChangeSelectorPerm(aclSelector *selector, struct redisCommand *cmd, int allow) {
    unsigned long id = cmd->id;
    ACLSetSelectorCommandBit(selector,id,allow);
    ACLResetFirstArgsForCommand(selector,id);
    if (cmd->subcommands_dict) {
        dictEntry *de;
        dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);
        while((de = dictNext(di)) != NULL) {
            struct redisCommand *sub = (struct redisCommand *)dictGetVal(de);
            ACLSetSelectorCommandBit(selector,sub->id,allow);
        }
        dictReleaseIterator(di);
    }
}",606.0,619.0,1.0,1.0,14.0,10,4,19,8,1,11,3,4,2,7,,0,7,6,3,3,void
1501,1877,ACLSetSelectorCommandBitsForCategory,1,ACLSetSelectorCommandBitsForCategory,"void ACLSetSelectorCommandBitsForCategory (dict*,aclSelector*,uint64_t,int)",acl.c,"void ACLSetSelectorCommandBitsForCategory(dict *commands, aclSelector *selector, uint64_t cflag, int value) {
    dictIterator *di = dictGetIterator(commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->acl_categories & cflag) {
            ACLChangeSelectorPerm(selector,cmd,value);
        }
        if (cmd->subcommands_dict) {
            ACLSetSelectorCommandBitsForCategory(cmd->subcommands_dict, selector, cflag, value);
        }
    }
    dictReleaseIterator(di);
}",627.0,640.0,1.0,1.0,14.0,8,4,18,8,1,8,4,6,3,5,,0,6,8,4,4,void
1502,1929,ACLRecomputeCommandBitsFromCommandRulesAllUsers,1,ACLRecomputeCommandBitsFromCommandRulesAllUsers,void ACLRecomputeCommandBitsFromCommandRulesAllUsers (void),acl.c,"void ACLRecomputeCommandBitsFromCommandRulesAllUsers(void) {
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        listIter li;
        listNode *ln;
        listRewind(u->selectors,&li);
        while((ln = listNext(&li))) {
            aclSelector *selector = (aclSelector *) listNodeValue(ln);
            int argc = 0;
            sds *argv = sdssplitargs(selector->command_rules, &argc);
            serverAssert(argv != NULL);
            /* Checking selector's permissions for all commands to start with a clean state. */
            if (ACLSelectorCanExecuteFutureCommands(selector)) {
                int res = ACLSetSelector(selector,""+@all"",-1);
                serverAssert(res == C_OK);
            } else {
                int res = ACLSetSelector(selector,""-@all"",-1);
                serverAssert(res == C_OK);
            }

            /* Apply all of the commands and categories to this selector. ...",645.0,678.0,1.0,52.0,34.0,39,13,37,11,2,20,5,10,3,15,,0,12,2,1,1,void
1503,2111,ACLSetSelectorCategory,1,ACLSetSelectorCategory,"int ACLSetSelectorCategory (aclSelector*,char*,int)",acl.c,"int ACLSetSelectorCategory(aclSelector *selector, const char *category, int allow) {
    uint64_t cflag = ACLGetCommandCategoryFlagByName(category + 1);
    if (!cflag) return C_ERR;

    ACLUpdateCommandRules(selector, category, allow);

    /* Set the actual command bits on the selector. */
    ACLSetSelectorCommandBitsForCategory(server.orig_commands, selector, cflag, allow);
    return C_OK;
}",680.0,689.0,1.0,23.0,10.0,5,5,10,5,0,3,2,2,0,3,,0,1,6,3,3,int
1504,2149,ACLCountCategoryBitsForCommands,1,ACLCountCategoryBitsForCommands,"void ACLCountCategoryBitsForCommands (dict*,aclSelector*,long unsigned*,long unsigned*,uint64_t)",acl.c,"void ACLCountCategoryBitsForCommands(dict *commands, aclSelector *selector, unsigned long *on, unsigned long *off, uint64_t cflag) {
    dictIterator *di = dictGetIterator(commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->acl_categories & cflag) {
            if (ACLGetSelectorCommandBit(selector,cmd->id))
                (*on)++;
            else
                (*off)++;
        }
        if (cmd->subcommands_dict) {
            ACLCountCategoryBitsForCommands(cmd->subcommands_dict, selector, on, off, cflag);
        }
    }
    dictReleaseIterator(di);
}",691.0,707.0,1.0,1.0,17.0,11,6,19,9,1,9,5,9,5,5,,0,8,10,5,5,void
1505,2214,ACLCountCategoryBitsForSelector,1,ACLCountCategoryBitsForSelector,"int ACLCountCategoryBitsForSelector (aclSelector*,long unsigned*,long unsigned*,char*)",acl.c,"int ACLCountCategoryBitsForSelector(aclSelector *selector, unsigned long *on, unsigned long *off,
                                const char *category)
{
    uint64_t cflag = ACLGetCommandCategoryFlagByName(category);
    if (!cflag) return C_ERR;

    *on = *off = 0;
    ACLCountCategoryBitsForCommands(server.orig_commands, selector, on, off, cflag);
    return C_OK;
}",713.0,722.0,1.0,23.0,10.0,8,5,10,6,0,2,2,2,0,2,,0,1,8,4,4,int
1506,2255,ACLDescribeSelectorCommandRules,1,ACLDescribeSelectorCommandRules,sds ACLDescribeSelectorCommandRules (aclSelector*),acl.c,"sds ACLDescribeSelectorCommandRules(aclSelector *selector) {
    sds rules = sdsempty();

    /* We use this fake selector as a ""sanity"" check to make sure the rules
     * we generate have the same bitmap as those on the current selector. */
    aclSelector *fake_selector = ACLCreateSelector(0);

    /* Here we want to understand if we should start with +@all or -@all.
     * Note that when starting with +@all and subtracting, the user
     * will be able to execute future commands, while -@all and adding will just
     * allow the user the run the selected commands and/or categories.
     * How do we test for that? We use the trick of a reserved command ID bit
     * that is set only by +@all (and its alias ""allcommands""). */
    if (ACLSelectorCanExecuteFutureCommands(selector)) {
        rules = sdscat(rules,""+@all "");
        ACLSetSelector(fake_selector,""+@all"",-1);
    } else {
        rules = sdscat(rules,""-@all "");
        ACLSetSelector(fake_selector,""-@all"",-1);
    }

  ...",731.0,784.0,1.0,4.0,54.0,36,15,34,9,2,22,5,5,6,16,,0,14,2,1,1,sds
1507,2430,ACLDescribeSelector,1,ACLDescribeSelector,sds ACLDescribeSelector (aclSelector*),acl.c,"sds ACLDescribeSelector(aclSelector *selector) {
    listIter li;
    listNode *ln;
    sds res = sdsempty();
    /* Key patterns. */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) {
        res = sdscatlen(res,""~* "",3);
    } else {
        listRewind(selector->patterns,&li);
        while((ln = listNext(&li))) {
            keyPattern *thispat = (keyPattern *)listNodeValue(ln);
            res = sdsCatPatternString(res, thispat);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Pub/sub channel patterns. */
    if (selector->flags & SELECTOR_FLAG_ALLCHANNELS) {
        res = sdscatlen(res,""&* "",3);
    } else {
        res = sdscatlen(res,""resetchannels "",14);
        listRewind(selector->channels,&li);
        while((ln = listNext(&li))) {
            sds thispat = listNodeValue(ln);
            res = sdscatlen(res,""&"",1);
            res = sdscatsds(res,thispat);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Command rules. */
    sds rules = ACL...",786.0,821.0,1.0,26.0,36.0,11,4,14,3,1,8,3,3,2,6,,0,7,2,1,1,sds
1508,2573,ACLDescribeUser,1,ACLDescribeUser,robj ACLDescribeUser (user*),acl.c,"robj *ACLDescribeUser(user *u) {
    if (u->acl_string) {
        incrRefCount(u->acl_string);
        return u->acl_string;
    }

    sds res = sdsempty();

    /* Flags. */
    for (int j = 0; ACLUserFlags[j].flag; j++) {
        if (u->flags & ACLUserFlags[j].flag) {
            res = sdscat(res,ACLUserFlags[j].name);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Passwords. */
    listIter li;
    listNode *ln;
    listRewind(u->passwords,&li);
    while((ln = listNext(&li))) {
        sds thispass = listNodeValue(ln);
        res = sdscatlen(res,""#"",1);
        res = sdscatsds(res,thispass);
        res = sdscatlen(res,"" "",1);
    }

    /* Selectors (Commands and keys) */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *selector = (aclSelector *) listNodeValue(ln);
        sds default_perm = ACLDescribeSelector(selector);
        if (selector->flags & SELECTOR_FLAG_ROOT) {
            res = sdscatfmt(res, ""%s"", default_...",829.0,874.0,1.0,23.0,46.0,40,8,48,9,3,31,7,9,7,16,,0,26,2,1,1,robj
1509,2749,ACLLookupCommand,1,ACLLookupCommand,struct redisCommand ACLLookupCommand (char*),acl.c,"struct redisCommand *ACLLookupCommand(const char *name) {
    struct redisCommand *cmd;
    sds sdsname = sdsnew(name);
    cmd = lookupCommandBySdsLogic(server.orig_commands,sdsname);
    sdsfree(sdsname);
    return cmd;
}",879.0,885.0,1.0,1.0,7.0,3,2,7,4,0,3,1,1,0,3,,0,2,2,1,1,struct redisCommand
1510,2998,aclCreateSelectorFromOpSet,1,aclCreateSelectorFromOpSet,"aclSelector aclCreateSelectorFromOpSet (char*,size_t)",acl.c,"aclSelector *aclCreateSelectorFromOpSet(const char *opset, size_t opsetlen) {
    serverAssert(opset[0] == '(' && opset[opsetlen - 1] == ')');
    aclSelector *s = ACLCreateSelector(0);

    int argc = 0;
    sds trimmed = sdsnewlen(opset + 1, opsetlen - 2);
    sds *argv = sdssplitargs(trimmed, &argc);
    for (int i = 0; i < argc; i++) {
        if (ACLSetSelector(s, argv[i], sdslen(argv[i])) == C_ERR) {
            ACLFreeSelector(s);
            s = NULL;
            goto cleanup;
        }
    }

cleanup:
    sdsfreesplitres(argv, argc);
    sdsfree(trimmed);
    return s;
}",950.0,969.0,1.0,4.0,20.0,24,13,26,8,0,9,4,4,2,9,,0,5,4,2,2,aclSelector
1511,3880,ACLSetUser,1,ACLSetUser,"int ACLSetUser (user*,char*,ssize_t)",acl.c,"int ACLSetUser(user *u, const char *op, ssize_t oplen) {
    /* as we are changing the ACL, the old generated string is now invalid */
    if (u->acl_string) {
        decrRefCount(u->acl_string);
        u->acl_string = NULL;
    }

    if (oplen == -1) oplen = strlen(op);
    if (oplen == 0) return C_OK; /* Empty string is a no-operation. */
    if (!strcasecmp(op,""on"")) {
        u->flags |= USER_FLAG_ENABLED;
        u->flags &= ~USER_FLAG_DISABLED;
    } else if (!strcasecmp(op,""off"")) {
        u->flags |= USER_FLAG_DISABLED;
        u->flags &= ~USER_FLAG_ENABLED;
    } else if (!strcasecmp(op,""skip-sanitize-payload"")) {
        u->flags |= USER_FLAG_SANITIZE_PAYLOAD_SKIP;
        u->flags &= ~USER_FLAG_SANITIZE_PAYLOAD;
    } else if (!strcasecmp(op,""sanitize-payload"")) {
        u->flags &= ~USER_FLAG_SANITIZE_PAYLOAD_SKIP;
        u->flags |= USER_FLAG_SANITIZE_PAYLOAD;
    } else if (!strcasecmp(op,""nopass"")) {
        u->flags |= USER_FLAG_NOPASS;
        listEmpty(u->pa...",1250.0,1350.0,1.0,27.0,101.0,14,7,11,4,13,6,5,5,1,1,,0,5,6,3,3,int
1512,4565,ACLSetUserStringError,1,ACLSetUserStringError,const char* ACLSetUserStringError (void),acl.c,"const char *ACLSetUserStringError(void) {
    const char *errmsg = ""Wrong format"";
    if (errno == ENOENT)
        errmsg = ""Unknown command or category name in ACL"";
    else if (errno == EINVAL)
        errmsg = ""Syntax error"";
    else if (errno == EEXIST)
        errmsg = ""Adding a pattern after the * pattern (or the ""
                 ""'allkeys' flag) is not valid and does not have any ""
                 ""effect. Try 'resetkeys' to start with an empty ""
                 ""list of patterns"";
    else if (errno == EISDIR)
        errmsg = ""Adding a pattern after the * pattern (or the ""
                 ""'allchannels' flag) is not valid and does not have any ""
                 ""effect. Try 'resetchannels' to start with an empty ""
                 ""list of channels"";
    else if (errno == ENODEV)
        errmsg = ""The password you are trying to remove from the user does ""
                 ""not exist"";
    else if (errno == EBADMSG)
        errmsg = ""The password hash must be exactl...",1354.0,1382.0,1.0,1.0,29.0,3,2,5,3,3,0,2,2,0,0,,0,0,2,1,1,const char*
1513,4654,ACLCreateDefaultUser,1,ACLCreateDefaultUser,user ACLCreateDefaultUser (void),acl.c,"user *ACLCreateDefaultUser(void) {
    user *new = ACLCreateUser(""default"",7);
    ACLSetUser(new,""+@all"",-1);
    ACLSetUser(new,""~*"",-1);
    ACLSetUser(new,""&*"",-1);
    ACLSetUser(new,""on"",-1);
    ACLSetUser(new,""nopass"",-1);
    return new;
}",1385.0,1393.0,1.0,1.0,9.0,6,2,7,1,2,6,1,1,0,6,,0,1,2,1,1,user
1514,4692,ACLInit,1,ACLInit,void ACLInit (void),acl.c,"void ACLInit(void) {
    Users = raxNew();
    UsersToLoad = listCreate();
    listSetMatchMethod(UsersToLoad, ACLListMatchLoadedUser);
    ACLLog = listCreate();
    DefaultUser = ACLCreateDefaultUser();
}",1396.0,1402.0,1.0,4.0,7.0,6,2,6,4,0,10,1,1,0,4,,0,10,2,1,1,void
1515,4718,ACLCheckUserCredentials,1,ACLCheckUserCredentials,"int ACLCheckUserCredentials (robj*,robj*)",acl.c,"int ACLCheckUserCredentials(robj *username, robj *password) {
    user *u = ACLGetUserByName(username->ptr,sdslen(username->ptr));
    if (u == NULL) {
        errno = ENOENT;
        return C_ERR;
    }

    /* Disabled users can't login. */
    if (u->flags & USER_FLAG_DISABLED) {
        errno = EINVAL;
        return C_ERR;
    }

    /* If the user is configured to don't require any password, we
     * are already fine here. */
    if (u->flags & USER_FLAG_NOPASS) return C_OK;

    /* Check all the user passwords for at least one to match. */
    listIter li;
    listNode *ln;
    listRewind(u->passwords,&li);
    sds hashed = ACLHashPassword(password->ptr,sdslen(password->ptr));
    while((ln = listNext(&li))) {
        sds thispass = listNodeValue(ln);
        if (!time_independent_strcmp(hashed, thispass, HASH_PASSWORD_LEN)) {
            sdsfree(hashed);
            return C_OK;
        }
    }
    sdsfree(hashed);

    /* If we reached this point, no password matched. */
 ...",1410.0,1444.0,1.0,15.0,35.0,27,9,27,11,1,13,6,7,4,9,,0,10,4,2,2,int
1516,4844,addAuthErrReply,1,addAuthErrReply,"void addAuthErrReply (client*,robj*)",acl.c,"void addAuthErrReply(client *c, robj *err) {
    if (clientHasPendingReplies(c)) return;
    if (!err) {
        addReplyError(c, ""-WRONGPASS invalid username-password pair or user is disabled."");
        return;
    }
    addReplyError(c, err->ptr);
}",1448.0,1455.0,1.0,1.0,8.0,2,2,5,2,1,3,3,3,1,3,,0,1,4,2,2,void
1517,4868,checkPasswordBasedAuth,1,checkPasswordBasedAuth,"int checkPasswordBasedAuth (client*,robj*,robj*)",acl.c,"int checkPasswordBasedAuth(client *c, robj *username, robj *password) {
    if (ACLCheckUserCredentials(username,password) == C_OK) {
        c->authenticated = 1;
        c->user = ACLGetUserByName(username->ptr,sdslen(username->ptr));
        moduleNotifyUserChanged(c);
        return AUTH_OK;
    } else {
        addACLLogEntry(c,ACL_DENIED_AUTH,(c->flags & CLIENT_MULTI) ? ACL_LOG_CTX_MULTI : ACL_LOG_CTX_TOPLEVEL,0,username->ptr,NULL);
        return AUTH_ERR;
    }
}",1462.0,1472.0,1.0,54.0,11.0,7,3,8,4,1,6,2,2,1,4,,0,5,6,3,3,int
1518,4935,ACLAuthenticateUser,1,ACLAuthenticateUser,"int ACLAuthenticateUser (client*,robj*,robj*,robj**)",acl.c,"int ACLAuthenticateUser(client *c, robj *username, robj *password, robj **err) {
    int result = checkModuleAuthentication(c, username, password, err);
    /* If authentication was not handled by any Module, attempt normal password based auth. */
    if (result == AUTH_NOT_HANDLED) {
        result = checkPasswordBasedAuth(c, username, password);
    }
    return result;
}",1481.0,1488.0,1.0,1.0,8.0,3,2,12,6,2,2,2,2,0,2,,0,2,8,4,4,int
1519,4964,ACLGetCommandID,1,ACLGetCommandID,unsigned long ACLGetCommandID (sds),acl.c,"unsigned long ACLGetCommandID(sds cmdname) {
    sds lowername = sdsdup(cmdname);
    sdstolower(lowername);
    if (commandId == NULL) commandId = raxNew();
    void *id = raxFind(commandId,(unsigned char*)lowername,sdslen(lowername));
    if (id != raxNotFound) {
        sdsfree(lowername);
        return (unsigned long)id;
    }
    raxInsert(commandId,(unsigned char*)lowername,strlen(lowername),
              (void*)nextid,NULL);
    sdsfree(lowername);
    unsigned long thisid = nextid;
    nextid++;

    /* We never assign the last bit in the user commands bitmap structure,
     * this way we can later check if this bit is set, understanding if the
     * current ACL for the user was created starting with a +@all to add all
     * the possible commands and just subtracting other single commands or
     * categories, or if, instead, the ACL was created just adding commands
     * and command categories from scratch, not allowing future commands by
     * default (loaded via mod...",1499.0,1524.0,1.0,18.0,26.0,14,6,26,8,3,17,4,4,2,8,,0,13,2,1,1,unsigned long
1520,5037,ACLClearCommandID,1,ACLClearCommandID,void ACLClearCommandID (void),acl.c,"void ACLClearCommandID(void) {
    if (commandId) raxFree(commandId);
    commandId = NULL;
    nextid = 0;
}",1527.0,1531.0,1.0,1.0,5.0,2,1,5,3,0,5,2,2,1,1,,0,4,2,1,1,void
1521,5053,ACLGetUserByName,1,ACLGetUserByName,"user ACLGetUserByName (char*,size_t)",acl.c,"user *ACLGetUserByName(const char *name, size_t namelen) {
    void *myuser = raxFind(Users,(unsigned char*)name,namelen);
    if (myuser == raxNotFound) return NULL;
    return myuser;
}",1534.0,1538.0,1.0,1.0,5.0,3,3,8,6,7,2,2,2,0,1,,0,2,4,2,2,user
1522,5077,ACLSelectorCheckKey,1,ACLSelectorCheckKey,"int ACLSelectorCheckKey (aclSelector*,char*,int,int)",acl.c,"static int ACLSelectorCheckKey(aclSelector *selector, const char *key, int keylen, int keyspec_flags) {
    /* The selector can access any key */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) return ACL_OK;

    listIter li;
    listNode *ln;
    listRewind(selector->patterns,&li);

    int key_flags = 0;
    if (keyspec_flags & CMD_KEY_ACCESS) key_flags |= ACL_READ_PERMISSION;
    if (keyspec_flags & CMD_KEY_INSERT) key_flags |= ACL_WRITE_PERMISSION;
    if (keyspec_flags & CMD_KEY_DELETE) key_flags |= ACL_WRITE_PERMISSION;
    if (keyspec_flags & CMD_KEY_UPDATE) key_flags |= ACL_WRITE_PERMISSION;

    /* Test this key against every pattern. */
    while((ln = listNext(&li))) {
        keyPattern *pattern = listNodeValue(ln);
        if ((pattern->flags & key_flags) != key_flags)
            continue;
        size_t plen = sdslen(pattern->pattern);
        if (stringmatchlen(pattern->pattern,plen,key,keylen,0))
            return ACL_OK;
    }
    return ACL_DENIED_KEY;
}",1548.0,1572.0,1.0,26.0,25.0,28,6,26,9,2,10,10,11,5,4,,0,9,8,4,4,int
1523,5227,ACLSelectorHasUnrestrictedKeyAccess,1,ACLSelectorHasUnrestrictedKeyAccess,"int ACLSelectorHasUnrestrictedKeyAccess (aclSelector*,int)",acl.c,"static int ACLSelectorHasUnrestrictedKeyAccess(aclSelector *selector, int flags) {
    /* The selector can access any key */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) return 1;

    listIter li;
    listNode *ln;
    listRewind(selector->patterns,&li);

    int access_flags = 0;
    if (flags & CMD_KEY_ACCESS) access_flags |= ACL_READ_PERMISSION;
    if (flags & CMD_KEY_INSERT) access_flags |= ACL_WRITE_PERMISSION;
    if (flags & CMD_KEY_DELETE) access_flags |= ACL_WRITE_PERMISSION;
    if (flags & CMD_KEY_UPDATE) access_flags |= ACL_WRITE_PERMISSION;

    /* Test this key against every pattern. */
    while((ln = listNext(&li))) {
        keyPattern *pattern = listNodeValue(ln);
        if ((pattern->flags & access_flags) != access_flags)
            continue;
        if (!strcmp(pattern->pattern,""*"")) {
           return 1;
       }
    }
    return 0;
}",1579.0,1603.0,1.0,26.0,25.0,27,7,21,6,1,7,10,11,4,2,,0,6,4,2,2,int
1524,5360,ACLCheckChannelAgainstList,1,ACLCheckChannelAgainstList,"int ACLCheckChannelAgainstList (list*,char*,int,int)",acl.c,"static int ACLCheckChannelAgainstList(list *reference, const char *channel, int channellen, int is_pattern) {
    listIter li;
    listNode *ln;

    listRewind(reference, &li);
    while((ln = listNext(&li))) {
        sds pattern = listNodeValue(ln);
        size_t plen = sdslen(pattern);
        /* Channel patterns are matched literally against the channels in
         * the list. Regular channels perform pattern matching. */
        if ((is_pattern && !strcmp(pattern,channel)) || 
            (!is_pattern && stringmatchlen(pattern,plen,channel,channellen,0)))
        {
            return ACL_OK;
        }
    }
    return ACL_DENIED_CHANNEL;
}",1613.0,1630.0,1.0,22.0,18.0,11,6,17,8,5,5,3,4,2,4,,0,4,8,4,4,int
1525,5425,initACLKeyResultCache,1,initACLKeyResultCache,void initACLKeyResultCache (aclKeyResultCache*),acl.c,"void initACLKeyResultCache(aclKeyResultCache *cache) {
    cache->keys_init = 0;
}",1639.0,1641.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
1526,5435,cleanupACLKeyResultCache,1,cleanupACLKeyResultCache,void cleanupACLKeyResultCache (aclKeyResultCache*),acl.c,"void cleanupACLKeyResultCache(aclKeyResultCache *cache) {
    if (cache->keys_init) getKeysFreeResult(&(cache->keys));
}",1643.0,1645.0,1.0,1.0,3.0,3,2,2,1,4,3,2,2,1,1,,0,2,2,1,1,void
1527,5450,ACLSelectorCheckCmd,1,ACLSelectorCheckCmd,"int ACLSelectorCheckCmd (aclSelector*,redisCommand*,robj**,int,int*,aclKeyResultCache*)",acl.c,"static int ACLSelectorCheckCmd(aclSelector *selector, struct redisCommand *cmd, robj **argv, int argc, int *keyidxptr, aclKeyResultCache *cache) {
    uint64_t id = cmd->id;
    int ret;
    if (!(selector->flags & SELECTOR_FLAG_ALLCOMMANDS) && !(cmd->flags & CMD_NO_AUTH)) {
        /* If the bit is not set we have to check further, in case the
         * command is allowed just with that specific first argument. */
        if (ACLGetSelectorCommandBit(selector,id) == 0) {
            /* Check if the first argument matches. */
            if (argc < 2 ||
                selector->allowed_firstargs == NULL ||
                selector->allowed_firstargs[id] == NULL)
            {
                return ACL_DENIED_CMD;
            }

            long subid = 0;
            while (1) {
                if (selector->allowed_firstargs[id][subid] == NULL)
                    return ACL_DENIED_CMD;
                int idx = cmd->parent ? 2 : 1;
                if (!strcasecmp(argv[idx]->ptr...",1655.0,1723.0,1.0,28.0,69.0,120,19,98,18,2,31,19,43,14,11,,0,27,12,6,6,int
1528,5845,ACLUserCheckKeyPerm,1,ACLUserCheckKeyPerm,"int ACLUserCheckKeyPerm (user*,char*,int,int)",acl.c,"int ACLUserCheckKeyPerm(user *u, const char *key, int keylen, int flags) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* Check all of the selectors */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        if (ACLSelectorCheckKey(s, key, keylen, flags) == ACL_OK) {
            return ACL_OK;
        }
    }
    return ACL_DENIED_KEY;
}",1731.0,1747.0,1.0,26.0,17.0,9,5,13,8,1,5,4,5,2,3,,0,4,8,4,4,int
1529,5907,ACLUserCheckCmdWithUnrestrictedKeyAccess,1,ACLUserCheckCmdWithUnrestrictedKeyAccess,"int ACLUserCheckCmdWithUnrestrictedKeyAccess (user*,redisCommand*,robj**,int,int)",acl.c,"int ACLUserCheckCmdWithUnrestrictedKeyAccess(user *u, struct redisCommand *cmd, robj **argv, int argc, int flags) {
    listIter li;
    listNode *ln;
    int local_idxptr;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return 1;

    /* For multiple selectors, we cache the key result in between selector
     * calls to prevent duplicate lookups. */
    aclKeyResultCache cache;
    initACLKeyResultCache(&cache);

    /* Check each selector sequentially */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        int acl_retval = ACLSelectorCheckCmd(s, cmd, argv, argc, &local_idxptr, &cache);
        if (acl_retval == ACL_OK && ACLSelectorHasUnrestrictedKeyAccess(s, flags)) {
            cleanupACLKeyResultCache(&cache);
            return 1;
        }
    }
    cleanupACLKeyResultCache(&cache);
    return 0;
}",1755.0,1780.0,1.0,41.0,26.0,16,6,22,12,1,9,4,5,2,7,,0,5,10,5,5,int
1530,5987,ACLUserCheckChannelPerm,1,ACLUserCheckChannelPerm,"int ACLUserCheckChannelPerm (user*,sds,int)",acl.c,"int ACLUserCheckChannelPerm(user *u, sds channel, int is_pattern) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* Check all of the selectors */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        /* The selector can run any keys */
        if (s->flags & SELECTOR_FLAG_ALLCHANNELS) return ACL_OK;

        /* Otherwise, loop over the selectors list and check each channel */
        if (ACLCheckChannelAgainstList(s->channels, channel, sdslen(channel), is_pattern) == ACL_OK) {
            return ACL_OK;
        }
    }
    return ACL_DENIED_CHANNEL;
}",1787.0,1807.0,1.0,26.0,21.0,13,7,14,7,1,8,5,7,5,4,,0,7,6,3,3,int
1531,6066,ACLCheckAllUserCommandPerm,1,ACLCheckAllUserCommandPerm,"int ACLCheckAllUserCommandPerm (user*,redisCommand*,robj**,int,int*)",acl.c,"int ACLCheckAllUserCommandPerm(user *u, struct redisCommand *cmd, robj **argv, int argc, int *idxptr) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* We have to pick a single error to log, the logic for picking is as follows:
     * 1) If no selector can execute the command, return the command.
     * 2) Return the last key or channel that no selector could match. */
    int relevant_error = ACL_DENIED_CMD;
    int local_idxptr = 0, last_idx = 0;

    /* For multiple selectors, we cache the key result in between selector
     * calls to prevent duplicate lookups. */
    aclKeyResultCache cache;
    initACLKeyResultCache(&cache);

    /* Check each selector sequentially */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        int acl_retval = ACLSelectorCheckCmd(s, cmd, argv, argc, &local_idxptr, &...",1814.0,1852.0,1.0,26.0,39.0,27,9,36,14,3,8,5,7,1,6,,0,4,10,5,5,int
1532,6182,ACLCheckAllPerm,1,ACLCheckAllPerm,"int ACLCheckAllPerm (client*,int*)",acl.c,"int ACLCheckAllPerm(client *c, int *idxptr) {
    return ACLCheckAllUserCommandPerm(c->user, c->cmd, c->argv, c->argc, idxptr);
}",1855.0,1857.0,1.0,1.0,3.0,4,1,5,2,3,5,1,1,0,1,,0,4,4,2,2,int
1533,6203,ACLKillPubsubClientsIfNeeded,1,ACLKillPubsubClientsIfNeeded,"void ACLKillPubsubClientsIfNeeded (user*,user*)",acl.c,"void ACLKillPubsubClientsIfNeeded(user *new, user *original) {
    listIter li, lpi;
    listNode *ln, *lpn;
    robj *o;
    int kill = 0;
    
    /* First optimization is we check if any selector has all channel
     * permissions. */
    listRewind(new->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        if (s->flags & SELECTOR_FLAG_ALLCHANNELS) return;
    }

    /* Second optimization is to check if the new list of channels
     * is a strict superset of the original. This is done by
     * created an ""upcoming"" list of all channels that are in
     * the new user and checking each of the existing channels
     * against it.  */
    list *upcoming = listCreate();
    listRewind(new->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        listRewind(s->channels, &lpi);
        while((lpn = listNext(&lpi))) {
            listAddNodeTail(upcoming, listNo...",1861.0,1965.0,1.0,41.0,105.0,95,11,108,17,1,54,20,39,15,37,,0,41,4,2,2,void
1534,6571,ACLMergeSelectorArguments,1,ACLMergeSelectorArguments,"sds ACLMergeSelectorArguments (sds*,int,int*,int*)",acl.c,"sds *ACLMergeSelectorArguments(sds *argv, int argc, int *merged_argc, int *invalid_idx) {
    *merged_argc = 0;
    int open_bracket_start = -1;

    sds *acl_args = (sds *) zmalloc(sizeof(sds) * argc);

    sds selector = NULL;
    for (int j = 0; j < argc; j++) {
        char *op = argv[j];

        if (op[0] == '(' && op[sdslen(op) - 1] != ')') {
            selector = sdsdup(argv[j]);
            open_bracket_start = j;
            continue;
        }

        if (open_bracket_start != -1) {
            selector = sdscatfmt(selector, "" %s"", op);
            if (op[sdslen(op) - 1] == ')') {
                open_bracket_start = -1;
                acl_args[*merged_argc] = selector;                        
                (*merged_argc)++;
            }
            continue;
        }

        acl_args[*merged_argc] = sdsdup(argv[j]);
        (*merged_argc)++;
    }

    if (open_bracket_start != -1) {
        for (int i = 0; i < *merged_argc; i++) sdsfree(acl_args[i]);
        zfr...",1983.0,2022.0,1.0,1.0,40.0,48,13,48,12,3,8,10,14,2,8,,0,6,8,4,4,sds
1535,6731,ACLStringSetUser,1,ACLStringSetUser,"sds ACLStringSetUser (user*,sds,sds*,int)",acl.c,"sds ACLStringSetUser(user *u, sds username, sds *argv, int argc) {
    serverAssert(u != NULL || username != NULL);

    sds error = NULL;

    int merged_argc = 0, invalid_idx = 0;
    sds *acl_args = ACLMergeSelectorArguments(argv, argc, &merged_argc, &invalid_idx);

    if (!acl_args) {
        return sdscatfmt(sdsempty(),
                         ""Unmatched parenthesis in acl selector starting ""
                         ""at '%s'."", (char *) argv[invalid_idx]);
    }

    /* Create a temporary user to validate and stage all changes against
     * before applying to an existing user or creating a new user. If all
     * arguments are valid the user parameters will all be applied together.
     * If there are any errors then none of the changes will be applied. */
    user *tempu = ACLCreateUnlinkedUser();
    if (u) {
        ACLCopyUser(tempu, u);
    }

    for (int j = 0; j < merged_argc; j++) {
        if (ACLSetUser(tempu,acl_args[j],(ssize_t) sdslen(acl_args[j])) != C_OK) {
...",2029.0,2084.0,1.0,4.0,56.0,37,11,52,13,2,19,9,9,2,19,,0,10,8,4,4,sds
1536,6907,ACLAppendUserForLoading,1,ACLAppendUserForLoading,"int ACLAppendUserForLoading (sds*,int,int*)",acl.c,"int ACLAppendUserForLoading(sds *argv, int argc, int *argc_err) {
    if (argc < 2 || strcasecmp(argv[0],""user"")) {
        if (argc_err) *argc_err = 0;
        return C_ERR;
    }

    if (listSearchKey(UsersToLoad, argv[1])) {
        if (argc_err) *argc_err = 1;
        errno = EALREADY;
        return C_ERR; 
    }

    /* Merged selectors before trying to process */
    int merged_argc;
    sds *acl_args = ACLMergeSelectorArguments(argv + 2, argc - 2, &merged_argc, argc_err);

    if (!acl_args) {
        return C_ERR;
    }

    /* Try to apply the user rules in a fake user to see if they
     * are actually valid. */
    user *fakeuser = ACLCreateUnlinkedUser();

    for (int j = 0; j < merged_argc; j++) {
        if (ACLSetUser(fakeuser,acl_args[j],sdslen(acl_args[j])) == C_ERR) {
            if (errno != ENOENT) {
                ACLFreeUser(fakeuser);
                if (argc_err) *argc_err = j;
                for (int i = 0; i < merged_argc; i++) sdsfree(acl_args[i]);
  ...",2104.0,2150.0,1.0,15.0,47.0,44,14,53,15,0,14,13,24,4,12,,0,9,6,3,3,int
1537,7122,ACLLoadConfiguredUsers,1,ACLLoadConfiguredUsers,int ACLLoadConfiguredUsers (void),acl.c,"int ACLLoadConfiguredUsers(void) {
    listIter li;
    listNode *ln;
    listRewind(UsersToLoad,&li);
    while ((ln = listNext(&li)) != NULL) {
        sds *aclrules = listNodeValue(ln);
        sds username = aclrules[0];

        if (ACLStringHasSpaces(aclrules[0],sdslen(aclrules[0]))) {
            serverLog(LL_WARNING,""Spaces not allowed in ACL usernames"");
            return C_ERR;
        }

        user *u = ACLCreateUser(username,sdslen(username));
        if (!u) {
            /* Only valid duplicate user is the default one. */
            serverAssert(!strcmp(username, ""default""));
            u = ACLGetUserByName(""default"",7);
            ACLSetUser(u,""reset"",-1);
        }

        /* Load every rule defined for this user. */
        for (int j = 1; aclrules[j]; j++) {
            if (ACLSetUser(u,aclrules[j],sdslen(aclrules[j])) != C_OK) {
                const char *errmsg = ACLSetUserStringError();
                serverLog(LL_WARNING,""Error loading ACL rule '%s' fo...",2155.0,2197.0,1.0,24.0,43.0,42,15,37,10,1,18,7,13,6,15,,0,12,2,1,1,int
1538,7325,ACLLoadFromFile,1,ACLLoadFromFile,sds ACLLoadFromFile (char*),acl.c,"sds ACLLoadFromFile(const char *filename) {
    FILE *fp;
    char buf[1024];

    /* Open the ACL file. */
    if ((fp = fopen(filename,""r"")) == NULL) {
        sds errors = sdscatprintf(sdsempty(),
            ""Error loading ACLs, opening file '%s': %s"",
            filename, strerror(errno));
        return errors;
    }

    /* Load the whole file as a single string in memory. */
    sds acls = sdsempty();
    while(fgets(buf,sizeof(buf),fp) != NULL)
        acls = sdscat(acls,buf);
    fclose(fp);

    /* Split the file into lines and attempt to load each line. */
    int totlines;
    sds *lines, errors = sdsempty();
    lines = sdssplitlen(acls,strlen(acls),""\n"",1,&totlines);
    sdsfree(acls);

    /* We do all the loading in a fresh instance of the Users radix tree,
     * so if there are errors loading the ACL file we can rollback to the
     * old version. */
    rax *old_users = Users;
    Users = raxNew();

    /* Load each line of the file. */
    for (int i = 0; i < t...",2222.0,2379.0,1.0,65.0,158.0,75,13,134,25,1,48,25,34,6,43,,0,33,2,1,1,sds
1539,7752,ACLSaveToFile,1,ACLSaveToFile,int ACLSaveToFile (char*),acl.c,"int ACLSaveToFile(const char *filename) {
    sds acl = sdsempty();
    int fd = -1;
    sds tmpfilename = NULL;
    int retval = C_ERR;

    /* Let's generate an SDS string containing the new version of the
     * ACL file. */
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        /* Return information in the configuration file format. */
        sds user = sdsnew(""user "");
        user = sdscatsds(user,u->name);
        user = sdscatlen(user,"" "",1);
        robj *descr = ACLDescribeUser(u);
        user = sdscatsds(user,descr->ptr);
        decrRefCount(descr);
        acl = sdscatsds(acl,user);
        acl = sdscatlen(acl,""\n"",1);
        sdsfree(user);
    }
    raxStop(&ri);

    /* Create a temp file with the new content. */
    tmpfilename = sdsnew(filename);
    tmpfilename = sdscatfmt(tmpfilename,"".tmp-%i-%I"",
        (int) getpid(),commandTimeSnapshot());
    if ((fd = open(tmpfilename,O_WRONLY...",2384.0,2459.0,1.0,17.0,76.0,63,15,81,18,0,31,17,14,3,28,,0,18,2,1,1,int
1540,8075,ACLLoadUsersAtStartup,1,ACLLoadUsersAtStartup,void ACLLoadUsersAtStartup (void),acl.c,"void ACLLoadUsersAtStartup(void) {
    if (server.acl_filename[0] != '\0' && listLength(UsersToLoad) != 0) {
        serverLog(LL_WARNING,
            ""Configuring Redis with users defined in redis.conf and at ""
            ""the same setting an ACL file path is invalid. This setup ""
            ""is very likely to lead to configuration errors and security ""
            ""holes, please define either an ACL file or declare users ""
            ""directly in your redis.conf, but not both."");
        exit(1);
    }

    if (ACLLoadConfiguredUsers() == C_ERR) {
        serverLog(LL_WARNING,
            ""Critical error while loading ACLs. Exiting."");
        exit(1);
    }

    if (server.acl_filename[0] != '\0') {
        sds errors = ACLLoadFromFile(server.acl_filename);
        if (errors) {
            serverLog(LL_WARNING,
                ""Aborting Redis startup because of ACL errors: %s"", errors);
            sdsfree(errors);
            exit(1);
        }
    }
}",2466.0,2492.0,1.0,42.0,27.0,22,10,12,3,0,9,5,6,4,6,,0,5,2,1,1,void
1541,8199,ACLLogMatchEntry,1,ACLLogMatchEntry,"int ACLLogMatchEntry (ACLLogEntry*,ACLLogEntry*)",acl.c,"int ACLLogMatchEntry(ACLLogEntry *a, ACLLogEntry *b) {
    if (a->reason != b->reason) return 0;
    if (a->context != b->context) return 0;
    mstime_t delta = a->ctime - b->ctime;
    if (delta < 0) delta = -delta;
    if (delta > ACL_LOG_GROUPING_MAX_TIME_DELTA) return 0;
    if (sdscmp(a->object,b->object) != 0) return 0;
    if (sdscmp(a->username,b->username) != 0) return 0;
    return 1;
}",2517.0,2526.0,1.0,16.0,10.0,20,7,15,3,1,12,7,7,10,2,,0,12,4,2,2,int
1542,8306,ACLUpdateInfoMetrics,1,ACLUpdateInfoMetrics,void ACLUpdateInfoMetrics (int),acl.c,"void ACLUpdateInfoMetrics(int reason){
    if (reason == ACL_DENIED_AUTH) {
        server.acl_info.user_auth_failures++;
    } else if (reason == ACL_DENIED_CMD) {
        server.acl_info.invalid_cmd_accesses++;
    } else if (reason == ACL_DENIED_KEY) {
        server.acl_info.invalid_key_accesses++;
    } else if (reason == ACL_DENIED_CHANNEL) {
        server.acl_info.invalid_channel_accesses++;
    } else {
        serverPanic(""Unknown ACL_DENIED encoding"");
    }
}",2538.0,2550.0,1.0,18.0,13.0,4,3,2,2,1,0,2,2,0,0,,0,0,2,1,1,void
1543,8379,addACLLogEntry,1,addACLLogEntry,"void addACLLogEntry (client*,int,int,int,sds,sds)",acl.c,"void addACLLogEntry(client *c, int reason, int context, int argpos, sds username, sds object) {
    /* Update ACL info metrics */
    ACLUpdateInfoMetrics(reason);
    
    /* Create a new entry. */
    struct ACLLogEntry *le = zmalloc(sizeof(*le));
    le->count = 1;
    le->reason = reason;
    le->username = sdsdup(username ? username : c->user->name);
    le->ctime = commandTimeSnapshot();
    le->entry_id = ACLLogEntryCount;
    le->timestamp_created = le->ctime;

    if (object) {
        le->object = object;
    } else {
        switch(reason) {
            case ACL_DENIED_CMD: le->object = sdsdup(c->cmd->fullname); break;
            case ACL_DENIED_KEY: le->object = sdsdup(c->argv[argpos]->ptr); break;
            case ACL_DENIED_CHANNEL: le->object = sdsdup(c->argv[argpos]->ptr); break;
            case ACL_DENIED_AUTH: le->object = sdsdup(c->argv[0]->ptr); break;
            default: le->object = sdsempty();
        }
    }

    /* if we have a real client from the networ...",2567.0,2640.0,1.0,17.0,74.0,51,11,56,16,6,36,6,6,2,13,,0,30,12,6,6,void
1544,8670,getAclErrorMessage,1,getAclErrorMessage,"sds getAclErrorMessage (int,user*,redisCommand*,sds,int)",acl.c,"sds getAclErrorMessage(int acl_res, user *user, struct redisCommand *cmd, sds errored_val, int verbose) {
    switch (acl_res) {
    case ACL_DENIED_CMD:
        return sdscatfmt(sdsempty(), ""User %S has no permissions to run ""
                                     ""the '%S' command"", user->name, cmd->fullname);
    case ACL_DENIED_KEY:
        if (verbose) {
            return sdscatfmt(sdsempty(), ""User %S has no permissions to access ""
                                         ""the '%S' key"", user->name, errored_val);
        } else {
            return sdsnew(""No permissions to access a key"");
        }
    case ACL_DENIED_CHANNEL:
        if (verbose) {
            return sdscatfmt(sdsempty(), ""User %S has no permissions to access ""
                                         ""the '%S' channel"", user->name, errored_val);
        } else {
            return sdsnew(""No permissions to access a channel"");
        }
    }
    serverPanic(""Reached deadcode on getAclErrorMessage"");
}",2642.0,2663.0,1.0,9.0,22.0,5,2,9,5,3,11,4,6,0,7,,0,7,10,5,5,sds
1545,8744,aclCatWithFlags,1,aclCatWithFlags,"void aclCatWithFlags (client*,dict*,uint64_t,int*)",acl.c,"void aclCatWithFlags(client *c, dict *commands, uint64_t cflag, int *arraylen) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->flags & CMD_MODULE) continue;
        if (cmd->acl_categories & cflag) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            (*arraylen)++;
        }

        if (cmd->subcommands_dict) {
            aclCatWithFlags(c, cmd->subcommands_dict, cflag, arraylen);
        }
    }
    dictReleaseIterator(di);
}",2670.0,2687.0,1.0,25.0,18.0,15,7,20,8,0,12,6,8,4,6,,0,10,8,4,4,void
1546,8816,aclAddReplySelectorDescription,1,aclAddReplySelectorDescription,"int aclAddReplySelectorDescription (client*,aclSelector*)",acl.c,"int aclAddReplySelectorDescription(client *c, aclSelector *s) {
    listIter li;
    listNode *ln;

    /* Commands */
    addReplyBulkCString(c,""commands"");
    sds cmddescr = ACLDescribeSelectorCommandRules(s);
    addReplyBulkSds(c,cmddescr);
    
    /* Key patterns */
    addReplyBulkCString(c,""keys"");
    if (s->flags & SELECTOR_FLAG_ALLKEYS) {
        addReplyBulkCBuffer(c,""~*"",2);
    } else {
        sds dsl = sdsempty();
        listRewind(s->patterns,&li);
        while((ln = listNext(&li))) {
            keyPattern *thispat = (keyPattern *) listNodeValue(ln);
            if (ln != listFirst(s->patterns)) dsl = sdscat(dsl, "" "");
            dsl = sdsCatPatternString(dsl, thispat);
        }
        addReplyBulkSds(c, dsl);
    }

    /* Pub/sub patterns */
    addReplyBulkCString(c,""channels"");
    if (s->flags & SELECTOR_FLAG_ALLCHANNELS) {
        addReplyBulkCBuffer(c,""&*"",2);
    } else {
        sds dsl = sdsempty();
        listRewind(s->channels,&li);
        while...",2695.0,2734.0,1.0,19.0,40.0,7,4,11,3,0,9,3,3,2,7,,0,3,4,2,2,int
1547,8986,aclCommand,1,aclCommand,void aclCommand (client*),acl.c,"void aclCommand(client *c) {
    char *sub = c->argv[1]->ptr;
    if (!strcasecmp(sub,""setuser"") && c->argc >= 3) {
        /* Initially redact all of the arguments to not leak any information
         * about the user. */
        for (int j = 2; j < c->argc; j++) {
            redactClientCommandArgument(c, j);
        }

        sds username = c->argv[2]->ptr;
        /* Check username validity. */
        if (ACLStringHasSpaces(username,sdslen(username))) {
            addReplyErrorFormat(c,
                ""Usernames can't contain spaces or null characters"");
            return;
        }

        user *u = ACLGetUserByName(username,sdslen(username));

        sds *temp_argv = zmalloc(c->argc * sizeof(sds));
        for (int i = 3; i < c->argc; i++) temp_argv[i-3] = c->argv[i]->ptr;

        sds error = ACLStringSetUser(u, username, temp_argv, c->argc - 3);
        zfree(temp_argv);
        if (error == NULL) {
            addReply(c,shared.ok);
        } else {
            addR...",2750.0,3071.0,1.0,27.0,322.0,28,12,33,11,0,17,6,10,5,10,,0,13,2,1,1,void
1548,10430,addReplyCommandCategories,1,addReplyCommandCategories,"void addReplyCommandCategories (client*,redisCommand*)",acl.c,"void addReplyCommandCategories(client *c, struct redisCommand *cmd) {
    int flagcount = 0;
    void *flaglen = addReplyDeferredLen(c);
    for (int j = 0; ACLCommandCategories[j].flag != 0; j++) {
        if (cmd->acl_categories & ACLCommandCategories[j].flag) {
            addReplyStatusFormat(c, ""@%s"", ACLCommandCategories[j].name);
            flagcount++;
        }
    }
    setDeferredSetLen(c, flaglen, flagcount);
}",3073.0,3083.0,1.0,1.0,11.0,13,7,16,6,0,7,3,4,3,3,,0,5,4,2,2,void
1549,10486,authCommand,1,authCommand,void authCommand (client*),acl.c,"void authCommand(client *c) {
    /* Only two or three argument forms are allowed. */
    if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }
    /* Always redact the second argument */
    redactClientCommandArgument(c, 1);

    /* Handle the two different forms here. The form with two arguments
     * will just use ""default"" as username. */
    robj *username, *password;
    if (c->argc == 2) {
        /* Mimic the old behavior of giving an error for the two argument
         * form if no password is configured. */
        if (DefaultUser->flags & USER_FLAG_NOPASS) {
            addReplyError(c,""AUTH <password> called without any password ""
                            ""configured for the default user. Are you sure ""
                            ""your configuration is correct?"");
            return;
        }

        username = shared.default_username; 
        password = c->argv[1];
    } else {
        username = c->argv[1];
        password ...",3090.0,3128.0,1.0,33.0,39.0,18,9,24,9,0,11,6,7,4,6,,0,6,2,1,1,void
1550,10600,ACLUpdateDefaultUserPassword,1,ACLUpdateDefaultUserPassword,void ACLUpdateDefaultUserPassword (sds),acl.c,"void ACLUpdateDefaultUserPassword(sds password) {
    ACLSetUser(DefaultUser,""resetpass"",-1);
    if (password) {
        sds aclop = sdscatlen(sdsnew("">""), password, sdslen(password));
        ACLSetUser(DefaultUser,aclop,sdslen(aclop));
        sdsfree(aclop);
    } else {
        ACLSetUser(DefaultUser,""nopass"",-1);
    }
}",3132.0,3141.0,1.0,1.0,10.0,2,2,9,3,2,9,2,2,0,7,,0,6,2,1,1,void
1551,10647,listCreate,1,listCreate,list listCreate (void),adlist.c,"list *listCreate(void)
{
    struct list *list;

    if ((list = zmalloc(sizeof(*list))) == NULL)
        return NULL;
    list->head = list->tail = NULL;
    list->len = 0;
    list->dup = NULL;
    list->free = NULL;
    list->match = NULL;
    return list;
}",42.0,54.0,1.0,1.0,13.0,16,5,15,2,71,4,2,2,1,1,,0,4,2,1,1,list
1552,10696,listEmpty,1,listEmpty,void listEmpty (list*),adlist.c,"void listEmpty(list *list)
{
    unsigned long len;
    listNode *current, *next;

    current = list->head;
    len = list->len;
    while(len--) {
        next = current->next;
        if (list->free) list->free(current->value);
        zfree(current);
        current = next;
    }
    list->head = list->tail = NULL;
    list->len = 0;
}",57.0,72.0,1.0,1.0,16.0,17,3,17,5,6,9,3,4,0,2,,0,7,2,1,1,void
1553,10754,listRelease,1,listRelease,void listRelease (list*),adlist.c,"void listRelease(list *list)
{
    listEmpty(list);
    zfree(list);
}",77.0,81.0,1.0,1.0,5.0,0,0,2,1,52,2,1,1,0,2,,0,0,2,1,1,void
1554,10763,listAddNodeHead,1,listAddNodeHead,"list listAddNodeHead (list*,void*)",adlist.c,"list *listAddNodeHead(list *list, void *value)
{
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    listLinkNodeHead(list, node);
    return list;
}",89.0,98.0,1.0,1.0,10.0,6,5,9,4,8,3,2,2,1,2,,0,2,4,2,2,list
1555,10792,listLinkNodeHead,1,listLinkNodeHead,"void listLinkNodeHead (list*,listNode*)",adlist.c,"void listLinkNodeHead(list* list, listNode *node) {
    if (list->len == 0) {
        list->head = list->tail = node;
        node->prev = node->next = NULL;
    } else {
        node->prev = NULL;
        node->next = list->head;
        list->head->prev = node;
        list->head = node;
    }
    list->len++;
}",103.0,114.0,1.0,1.0,12.0,12,4,8,3,3,6,2,2,1,0,,0,6,4,2,2,void
1556,10853,listAddNodeTail,1,listAddNodeTail,"list listAddNodeTail (list*,void*)",adlist.c,"list *listAddNodeTail(list *list, void *value)
{
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    listLinkNodeTail(list, node);
    return list;
}",122.0,131.0,1.0,1.0,10.0,6,5,9,4,62,3,2,2,1,2,,0,2,4,2,2,list
1557,10882,listLinkNodeTail,1,listLinkNodeTail,"void listLinkNodeTail (list*,listNode*)",adlist.c,"void listLinkNodeTail(list *list, listNode *node) {
    if (list->len == 0) {
        list->head = list->tail = node;
        node->prev = node->next = NULL;
    } else {
        node->prev = list->tail;
        node->next = NULL;
        list->tail->next = node;
        list->tail = node;
    }
    list->len++;
}",136.0,147.0,1.0,1.0,12.0,12,4,8,3,2,6,2,2,1,0,,0,6,4,2,2,void
1558,10943,listInsertNode,1,listInsertNode,"list listInsertNode (list*,listNode*,void*,int)",adlist.c,"list *listInsertNode(list *list, listNode *old_node, void *value, int after) {
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    if (after) {
        node->prev = old_node;
        node->next = old_node->next;
        if (list->tail == old_node) {
            list->tail = node;
        }
    } else {
        node->next = old_node;
        node->prev = old_node->prev;
        if (list->head == old_node) {
            list->head = node;
        }
    }
    if (node->prev != NULL) {
        node->prev->next = node;
    }
    if (node->next != NULL) {
        node->next->prev = node;
    }
    list->len++;
    return list;
}",149.0,176.0,1.0,1.0,28.0,27,7,25,6,0,12,6,7,4,1,,0,12,8,4,4,list
1559,11056,listDelNode,1,listDelNode,"void listDelNode (list*,listNode*)",adlist.c,"void listDelNode(list *list, listNode *node)
{
    listUnlinkNode(list, node);
    if (list->free) list->free(node->value);
    zfree(node);
}",182.0,187.0,1.0,1.0,6.0,3,1,6,2,51,4,2,2,0,3,,0,1,4,2,2,void
1560,11079,listUnlinkNode,1,listUnlinkNode,"void listUnlinkNode (list*,listNode*)",adlist.c,"void listUnlinkNode(list *list, listNode *node) {
    if (node->prev)
        node->prev->next = node->next;
    else
        list->head = node->next;
    if (node->next)
        node->next->prev = node->prev;
    else
        list->tail = node->prev;

    node->next = NULL;
    node->prev = NULL;

    list->len--;
}",192.0,206.0,1.0,1.0,15.0,16,3,11,3,6,9,3,3,2,0,,0,9,4,2,2,void
1561,11145,listGetIterator,1,listGetIterator,"listIter listGetIterator (list*,int)",adlist.c,"listIter *listGetIterator(list *list, int direction)
{
    listIter *iter;

    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;
    if (direction == AL_START_HEAD)
        iter->next = list->head;
    else
        iter->next = list->tail;
    iter->direction = direction;
    return iter;
}",212.0,223.0,1.0,21.0,12.0,10,5,10,4,0,4,3,3,1,1,,0,4,4,2,2,listIter
1562,11194,listReleaseIterator,1,listReleaseIterator,void listReleaseIterator (listIter*),adlist.c,"void listReleaseIterator(listIter *iter) {
    zfree(iter);
}",226.0,228.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1563,11201,listRewind,1,listRewind,"void listRewind (list*,listIter*)",adlist.c,"void listRewind(list *list, listIter *li) {
    li->next = list->head;
    li->direction = AL_START_HEAD;
}",231.0,234.0,1.0,20.0,4.0,5,2,3,2,135,3,1,1,0,0,,0,3,4,2,2,void
1564,11221,listRewindTail,1,listRewindTail,"void listRewindTail (list*,listIter*)",adlist.c,"void listRewindTail(list *list, listIter *li) {
    li->next = list->tail;
    li->direction = AL_START_TAIL;
}",236.0,239.0,1.0,20.0,4.0,5,2,3,2,1,3,1,1,0,0,,0,3,4,2,2,void
1565,11241,listNext,1,listNext,listNode listNext (listIter*),adlist.c,"listNode *listNext(listIter *iter)
{
    listNode *current = iter->next;

    if (current != NULL) {
        if (iter->direction == AL_START_HEAD)
            iter->next = current->next;
        else
            iter->next = current->prev;
    }
    return current;
}",255.0,266.0,1.0,31.0,12.0,8,4,8,3,137,4,3,4,1,0,,0,4,2,1,1,listNode
1566,11284,listDup,1,listDup,list listDup (list*),adlist.c,"list *listDup(list *orig)
{
    list *copy;
    listIter iter;
    listNode *node;

    if ((copy = listCreate()) == NULL)
        return NULL;
    copy->dup = orig->dup;
    copy->free = orig->free;
    copy->match = orig->match;
    listRewind(orig, &iter);
    while((node = listNext(&iter)) != NULL) {
        void *value;

        if (copy->dup) {
            value = copy->dup(node->value);
            if (value == NULL) {
                listRelease(copy);
                return NULL;
            }
        } else {
            value = node->value;
        }
        
        if (listAddNodeTail(copy, value) == NULL) {
            /* Free value if dup succeed but listAddNodeTail failed. */
            if (copy->free) copy->free(value);

            listRelease(copy);
            return NULL;
        }
    }
    return copy;
}",276.0,310.0,1.0,1.0,35.0,23,5,31,6,6,9,7,13,3,8,,0,5,2,1,1,list
1567,11389,listSearchKey,1,listSearchKey,"listNode listSearchKey (list*,void*)",adlist.c,"listNode *listSearchKey(list *list, void *key)
{
    listIter iter;
    listNode *node;

    listRewind(list, &iter);
    while((node = listNext(&iter)) != NULL) {
        if (list->match) {
            if (list->match(node->value, key)) {
                return node;
            }
        } else {
            if (key == node->value) {
                return node;
            }
        }
    }
    return NULL;
}",321.0,339.0,1.0,1.0,19.0,7,4,11,5,16,4,4,7,3,3,,0,3,4,2,2,listNode
1568,11440,listIndex,1,listIndex,"listNode listIndex (list*,long)",adlist.c,"listNode *listIndex(list *list, long index) {
    listNode *n;

    if (index < 0) {
        index = (-index)-1;
        n = list->tail;
        while(index-- && n) n = n->prev;
    } else {
        n = list->head;
        while(index-- && n) n = n->next;
    }
    return n;
}",346.0,358.0,1.0,1.0,13.0,8,7,8,3,1,1,3,4,0,0,,0,1,4,2,2,listNode
1569,11492,listRotateTailToHead,1,listRotateTailToHead,void listRotateTailToHead (list*),adlist.c,"void listRotateTailToHead(list *list) {
    if (listLength(list) <= 1) return;

    /* Detach current tail */
    listNode *tail = list->tail;
    list->tail = tail->prev;
    list->tail->next = NULL;
    /* Move it as head */
    list->head->prev = tail;
    tail->prev = NULL;
    tail->next = list->head;
    list->head = tail;
}",361.0,373.0,1.0,8.0,13.0,20,3,16,3,0,10,2,2,1,0,,0,10,2,1,1,void
1570,11552,listRotateHeadToTail,1,listRotateHeadToTail,void listRotateHeadToTail (list*),adlist.c,"void listRotateHeadToTail(list *list) {
    if (listLength(list) <= 1) return;

    listNode *head = list->head;
    /* Detach current head */
    list->head = head->next;
    list->head->prev = NULL;
    /* Move it as tail */
    list->tail->next = head;
    head->next = NULL;
    head->prev = list->tail;
    list->tail = head;
}",376.0,388.0,1.0,8.0,13.0,20,3,16,3,1,10,2,2,1,0,,0,10,2,1,1,void
1571,11612,listJoin,1,listJoin,"void listJoin (list*,list*)",adlist.c,"void listJoin(list *l, list *o) {
    if (o->len == 0) return;

    o->head->prev = l->tail;

    if (l->tail)
        l->tail->next = o->head;
    else
        l->head = o->head;

    l->tail = o->tail;
    l->len += o->len;

    /* Setup other as an empty list. */
    o->head = o->tail = NULL;
    o->len = 0;
}",392.0,408.0,1.0,1.0,17.0,23,4,14,3,2,13,3,3,2,0,,0,13,4,2,2,void
1572,11686,listInitNode,1,listInitNode,"void listInitNode (listNode*,void*)",adlist.c,"void listInitNode(listNode *node, void *value) {
    node->prev = NULL;
    node->next = NULL;
    node->value = value;
}",413.0,417.0,1.0,1.0,5.0,6,2,6,3,1,3,1,1,0,0,,0,3,4,2,2,void
1573,11726,dup,1,list.dup,void* list.dup (void*),adlist.h,void *(*dup)(void *ptr);,50.0,50.0,10.0,27.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void*
1574,11731,free,1,list.free,void list.free (void*),adlist.h,void (*free)(void *ptr);,51.0,51.0,10.0,27.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1575,11736,match,1,list.match,"int list.match (void*,void*)",adlist.h,"int (*match)(void *ptr, void *key);",52.0,52.0,9.0,38.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1576,11911,aeCreateEventLoop,1,aeCreateEventLoop,aeEventLoop aeCreateEventLoop (int),ae.c,"aeEventLoop *aeCreateEventLoop(int setsize) {
    aeEventLoop *eventLoop;
    int i;

    monotonicInit();    /* just in case the calling app didn't initialize */

    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;
    eventLoop->events = zmalloc(sizeof(aeFileEvent)*setsize);
    eventLoop->fired = zmalloc(sizeof(aeFiredEvent)*setsize);
    if (eventLoop->events == NULL || eventLoop->fired == NULL) goto err;
    eventLoop->setsize = setsize;
    eventLoop->timeEventHead = NULL;
    eventLoop->timeEventNextId = 0;
    eventLoop->stop = 0;
    eventLoop->maxfd = -1;
    eventLoop->beforesleep = NULL;
    eventLoop->aftersleep = NULL;
    eventLoop->flags = 0;
    if (aeApiCreate(eventLoop) == -1) goto err;
    /* Events with mask == AE_NONE are not set. So let's initialize the
     * vector with it. */
    for (i = 0; i < setsize; i++)
        eventLoop->events[i].mask = AE_NONE;
    return eventLoop;

err:
    if (eventLoop) {
        zfree(eventLoop->events);
     ...",67.0,99.0,1.0,36.0,33.0,40,9,35,6,2,22,9,6,4,8,,0,18,2,1,1,aeEventLoop
1577,12050,aeGetSetSize,1,aeGetSetSize,int aeGetSetSize (aeEventLoop*),ae.c,"int aeGetSetSize(aeEventLoop *eventLoop) {
    return eventLoop->setsize;
}",102.0,104.0,1.0,1.0,3.0,1,1,1,1,3,1,1,1,0,0,,0,1,2,1,1,int
1578,12059,aeSetDontWait,1,aeSetDontWait,"void aeSetDontWait (aeEventLoop*,int)",ae.c,"void aeSetDontWait(aeEventLoop *eventLoop, int noWait) {
    if (noWait)
        eventLoop->flags |= AE_DONT_WAIT;
    else
        eventLoop->flags &= ~AE_DONT_WAIT;
}",111.0,116.0,1.0,28.0,6.0,2,2,2,2,1,1,2,2,0,0,,0,1,4,2,2,void
1579,12089,aeResizeSetSize,1,aeResizeSetSize,"int aeResizeSetSize (aeEventLoop*,int)",ae.c,"int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
    int i;

    if (setsize == eventLoop->setsize) return AE_OK;
    if (eventLoop->maxfd >= setsize) return AE_ERR;
    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;

    eventLoop->events = zrealloc(eventLoop->events,sizeof(aeFileEvent)*setsize);
    eventLoop->fired = zrealloc(eventLoop->fired,sizeof(aeFiredEvent)*setsize);
    eventLoop->setsize = setsize;

    /* Make sure that if we created new slots, they are initialized with
     * an AE_NONE mask. */
    for (i = eventLoop->maxfd+1; i < setsize; i++)
        eventLoop->events[i].mask = AE_NONE;
    return AE_OK;
}",125.0,141.0,1.0,46.0,17.0,24,9,20,5,1,11,5,5,3,3,,0,11,4,2,2,int
1580,12190,aeDeleteEventLoop,1,aeDeleteEventLoop,void aeDeleteEventLoop (aeEventLoop*),ae.c,"void aeDeleteEventLoop(aeEventLoop *eventLoop) {
    aeApiFree(eventLoop);
    zfree(eventLoop->events);
    zfree(eventLoop->fired);

    /* Free the time events list. */
    aeTimeEvent *next_te, *te = eventLoop->timeEventHead;
    while (te) {
        next_te = te->next;
        zfree(te);
        te = next_te;
    }
    zfree(eventLoop);
}",143.0,156.0,1.0,1.0,14.0,7,2,12,3,0,9,2,2,0,5,,0,4,2,1,1,void
1581,12227,aeStop,1,aeStop,void aeStop (aeEventLoop*),ae.c,"void aeStop(aeEventLoop *eventLoop) {
    eventLoop->stop = 1;
}",158.0,160.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
1582,12237,aeCreateFileEvent,1,aeCreateFileEvent,"int aeCreateFileEvent (aeEventLoop*,int,int,aeFileProc*,void*)",ae.c,"int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
        aeFileProc *proc, void *clientData)
{
    if (fd >= eventLoop->setsize) {
        errno = ERANGE;
        return AE_ERR;
    }
    aeFileEvent *fe = &eventLoop->events[fd];

    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
        return AE_ERR;
    fe->mask |= mask;
    if (mask & AE_READABLE) fe->rfileProc = proc;
    if (mask & AE_WRITABLE) fe->wfileProc = proc;
    fe->clientData = clientData;
    if (fd > eventLoop->maxfd)
        eventLoop->maxfd = fd;
    return AE_OK;
}",162.0,180.0,1.0,15.0,19.0,24,9,24,8,7,9,6,6,3,1,,0,9,10,5,5,int
1583,12334,aeDeleteFileEvent,1,aeDeleteFileEvent,"void aeDeleteFileEvent (aeEventLoop*,int,int)",ae.c,"void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
{
    if (fd >= eventLoop->setsize) return;
    aeFileEvent *fe = &eventLoop->events[fd];
    if (fe->mask == AE_NONE) return;

    /* We want to always remove AE_BARRIER if set when AE_WRITABLE
     * is removed. */
    if (mask & AE_WRITABLE) mask |= AE_BARRIER;

    aeApiDelEvent(eventLoop, fd, mask);
    fe->mask = fe->mask & (~mask);
    if (fd == eventLoop->maxfd && fe->mask == AE_NONE) {
        /* Update the max fd */
        int j;

        for (j = eventLoop->maxfd-1; j >= 0; j--)
            if (eventLoop->events[j].mask != AE_NONE) break;
        eventLoop->maxfd = j;
    }
}",182.0,202.0,1.0,20.0,21.0,25,10,22,5,11,10,6,7,4,1,,0,9,6,3,3,void
1584,12443,aeGetFileClientData,1,aeGetFileClientData,"void* aeGetFileClientData (aeEventLoop*,int)",ae.c,"void *aeGetFileClientData(aeEventLoop *eventLoop, int fd) {
    if (fd >= eventLoop->setsize) return NULL;
    aeFileEvent *fe = &eventLoop->events[fd];
    if (fe->mask == AE_NONE) return NULL;

    return fe->clientData;
}",204.0,210.0,1.0,20.0,7.0,9,6,9,4,2,4,3,3,2,0,,0,4,4,2,2,void*
1585,12482,aeGetFileEvents,1,aeGetFileEvents,"int aeGetFileEvents (aeEventLoop*,int)",ae.c,"int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {
    if (fd >= eventLoop->setsize) return 0;
    aeFileEvent *fe = &eventLoop->events[fd];

    return fe->mask;
}",212.0,217.0,1.0,1.0,6.0,7,5,6,3,2,3,2,2,1,0,,0,3,4,2,2,int
1586,12510,aeCreateTimeEvent,1,aeCreateTimeEvent,"long long aeCreateTimeEvent (aeEventLoop*,long long,aeTimeProc*,void*,aeEventFinalizerProc*)",ae.c,"long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
        aeTimeProc *proc, void *clientData,
        aeEventFinalizerProc *finalizerProc)
{
    long long id = eventLoop->timeEventNextId++;
    aeTimeEvent *te;

    te = zmalloc(sizeof(*te));
    if (te == NULL) return AE_ERR;
    te->id = id;
    te->when = getMonotonicUs() + milliseconds * 1000;
    te->timeProc = proc;
    te->finalizerProc = finalizerProc;
    te->clientData = clientData;
    te->prev = NULL;
    te->next = eventLoop->timeEventHead;
    te->refcount = 0;
    if (te->next)
        te->next->prev = te;
    eventLoop->timeEventHead = te;
    return id;
}",219.0,240.0,1.0,27.0,22.0,33,9,27,8,4,15,3,3,1,2,,0,15,10,5,5,long long
1587,12608,aeDeleteTimeEvent,1,aeDeleteTimeEvent,"int aeDeleteTimeEvent (aeEventLoop*,long long)",ae.c,"int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
{
    aeTimeEvent *te = eventLoop->timeEventHead;
    while(te) {
        if (te->id == id) {
            te->id = AE_DELETED_EVENT_ID;
            return AE_OK;
        }
        te = te->next;
    }
    return AE_ERR; /* NO event with the specified ID found */
}",242.0,253.0,1.0,21.0,12.0,10,4,8,3,1,4,3,4,1,0,,0,4,4,2,2,int
1588,12652,usUntilEarliestTimer,1,usUntilEarliestTimer,int64_t usUntilEarliestTimer (aeEventLoop*),ae.c,"static int64_t usUntilEarliestTimer(aeEventLoop *eventLoop) {
    aeTimeEvent *te = eventLoop->timeEventHead;
    if (te == NULL) return -1;

    aeTimeEvent *earliest = NULL;
    while (te) {
        if ((!earliest || te->when < earliest->when) && te->id != AE_DELETED_EVENT_ID)
            earliest = te;
        te = te->next;
    }

    monotime now = getMonotonicUs();
    return (now >= earliest->when) ? 0 : earliest->when - now;
}",264.0,277.0,1.0,66.0,14.0,23,12,20,5,0,8,4,5,3,1,,0,8,2,1,1,int64_t
1589,12724,processTimeEvents,1,processTimeEvents,int processTimeEvents (aeEventLoop*),ae.c,"static int processTimeEvents(aeEventLoop *eventLoop) {
    int processed = 0;
    aeTimeEvent *te;
    long long maxId;

    te = eventLoop->timeEventHead;
    maxId = eventLoop->timeEventNextId-1;
    monotime now = getMonotonicUs();
    while(te) {
        long long id;

        /* Remove events scheduled for deletion. */
        if (te->id == AE_DELETED_EVENT_ID) {
            aeTimeEvent *next = te->next;
            /* If a reference exists for this timer event,
             * don't free it. This is currently incremented
             * for recursive timerProc calls */
            if (te->refcount) {
                te = next;
                continue;
            }
            if (te->prev)
                te->prev->next = te->next;
            else
                eventLoop->timeEventHead = te->next;
            if (te->next)
                te->next->prev = te->prev;
            if (te->finalizerProc) {
                te->finalizerProc(eventLoop, te->clientData);
           ...",280.0,344.0,1.0,22.0,65.0,54,12,51,8,1,28,13,23,7,4,,0,27,2,1,1,int
1590,12923,aeProcessEvents,1,aeProcessEvents,"int aeProcessEvents (aeEventLoop*,int)",ae.c,"int aeProcessEvents(aeEventLoop *eventLoop, int flags)
{
    int processed = 0, numevents;

    /* Nothing to do? return ASAP */
    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;

    /* Note that we want to call aeApiPoll() even if there are no
     * file events to process as long as we want to process time
     * events, in order to sleep until the next time event is ready
     * to fire. */
    if (eventLoop->maxfd != -1 ||
        ((flags & AE_TIME_EVENTS) && !(flags & AE_DONT_WAIT))) {
        int j;
        struct timeval tv, *tvp = NULL; /* NULL means infinite wait. */
        int64_t usUntilTimer;

        if (eventLoop->beforesleep != NULL && (flags & AE_CALL_BEFORE_SLEEP))
            eventLoop->beforesleep(eventLoop);

        /* The eventLoop->flags may be changed inside beforesleep.
         * So we should check it after beforesleep be called. At the same time,
         * the parameter flags always should have the highest priority.
         * Th...",361.0,469.0,1.0,18.0,109.0,109,15,87,13,2,27,14,31,11,2,,0,26,4,2,2,int
1591,13300,aeWait,1,aeWait,"int aeWait (int,int,long long)",ae.c,"int aeWait(int fd, int mask, long long milliseconds) {
    struct pollfd pfd;
    int retmask = 0, retval;

    memset(&pfd, 0, sizeof(pfd));
    pfd.fd = fd;
    if (mask & AE_READABLE) pfd.events |= POLLIN;
    if (mask & AE_WRITABLE) pfd.events |= POLLOUT;

    if ((retval = poll(&pfd, 1, milliseconds))== 1) {
        if (pfd.revents & POLLIN) retmask |= AE_READABLE;
        if (pfd.revents & POLLOUT) retmask |= AE_WRITABLE;
        if (pfd.revents & POLLERR) retmask |= AE_WRITABLE;
        if (pfd.revents & POLLHUP) retmask |= AE_WRITABLE;
        return retmask;
    } else {
        return retval;
    }
}",473.0,491.0,1.0,15.0,19.0,20,6,27,10,2,0,8,12,0,0,,0,0,6,3,3,int
1592,13413,aeMain,1,aeMain,void aeMain (aeEventLoop*),ae.c,"void aeMain(aeEventLoop *eventLoop) {
    eventLoop->stop = 0;
    while (!eventLoop->stop) {
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    }
}",493.0,500.0,1.0,35.0,8.0,11,5,3,1,1,3,2,2,1,1,,0,2,2,1,1,void
1593,13452,aeGetApiName,1,aeGetApiName,char* aeGetApiName (void),ae.c,"char *aeGetApiName(void) {
    return aeApiName();
}",502.0,504.0,1.0,1.0,3.0,0,0,0,0,1,1,1,1,0,1,,0,0,2,1,1,char*
1594,13459,aeSetBeforeSleepProc,1,aeSetBeforeSleepProc,"void aeSetBeforeSleepProc (aeEventLoop*,aeBeforeSleepProc*)",ae.c,"void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {
    eventLoop->beforesleep = beforesleep;
}",506.0,508.0,1.0,1.0,3.0,2,2,2,2,1,1,1,1,0,0,,0,1,4,2,2,void
1595,13470,aeSetAfterSleepProc,1,aeSetAfterSleepProc,"void aeSetAfterSleepProc (aeEventLoop*,aeBeforeSleepProc*)",ae.c,"void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) {
    eventLoop->aftersleep = aftersleep;
}",510.0,512.0,1.0,1.0,3.0,2,2,2,2,1,1,1,1,0,0,,0,1,4,2,2,void
1596,13672,aeApiCreate,1,aeApiCreate,int aeApiCreate (aeEventLoop*),ae_select.c,"static int aeApiCreate(aeEventLoop *eventLoop) {
    aeApiState *state = zmalloc(sizeof(aeApiState));

    if (!state) return -1;
    FD_ZERO(&state->rfds);
    FD_ZERO(&state->wfds);
    eventLoop->apidata = state;
    return 0;
}",42.0,50.0,1.0,1.0,9.0,22,7,15,4,1,14,4,4,2,6,,0,10,2,1,1,int
1597,13746,aeApiResize,1,aeApiResize,"int aeApiResize (aeEventLoop*,int)",ae_select.c,"static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
    AE_NOTUSED(eventLoop);
    /* Just ensure we have enough room in the fd_set type. */
    if (setsize >= FD_SETSIZE) return -1;
    return 0;
}",52.0,57.0,1.0,1.0,6.0,7,4,6,4,1,4,1,1,0,1,,0,4,4,2,2,int
1598,13772,aeApiFree,1,aeApiFree,void aeApiFree (aeEventLoop*),ae_select.c,"static void aeApiFree(aeEventLoop *eventLoop) {
    zfree(eventLoop->apidata);
}",59.0,61.0,1.0,1.0,3.0,4,2,5,2,1,5,1,1,0,2,,0,3,2,1,1,void
1599,13793,aeApiAddEvent,1,aeApiAddEvent,"int aeApiAddEvent (aeEventLoop*,int,int)",ae_select.c,"static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;

    if (mask & AE_READABLE) FD_SET(fd,&state->rfds);
    if (mask & AE_WRITABLE) FD_SET(fd,&state->wfds);
    return 0;
}",63.0,69.0,1.0,1.0,7.0,27,10,27,13,1,4,4,4,1,0,,0,4,6,3,3,int
1600,13885,aeApiDelEvent,1,aeApiDelEvent,"void aeApiDelEvent (aeEventLoop*,int,int)",ae_select.c,"static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;

    if (mask & AE_READABLE) FD_CLR(fd,&state->rfds);
    if (mask & AE_WRITABLE) FD_CLR(fd,&state->wfds);
}",71.0,76.0,1.0,1.0,6.0,22,9,24,12,1,3,4,4,0,0,,0,3,6,3,3,void
1601,13971,aeApiPoll,1,aeApiPoll,"int aeApiPoll (aeEventLoop*,timeval*)",ae_select.c,"static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
    aeApiState *state = eventLoop->apidata;
    int retval, j, numevents = 0;

    memcpy(&state->_rfds,&state->rfds,sizeof(fd_set));
    memcpy(&state->_wfds,&state->wfds,sizeof(fd_set));

    retval = select(eventLoop->maxfd+1,
                &state->_rfds,&state->_wfds,NULL,tvp);
    if (retval > 0) {
        for (j = 0; j <= eventLoop->maxfd; j++) {
            int mask = 0;
            aeFileEvent *fe = &eventLoop->events[j];

            if (fe->mask == AE_NONE) continue;
            if (fe->mask & AE_READABLE && FD_ISSET(j,&state->_rfds))
                mask |= AE_READABLE;
            if (fe->mask & AE_WRITABLE && FD_ISSET(j,&state->_wfds))
                mask |= AE_WRITABLE;
            eventLoop->fired[numevents].fd = j;
            eventLoop->fired[numevents].mask = mask;
            numevents++;
        }
    } else if (retval == -1 && errno != EINTR) {
        panic(""aeApiPoll: select, %s"", strerror(...",78.0,106.0,1.0,1.0,29.0,43,13,45,14,1,7,7,16,0,0,,0,7,4,2,2,int
1602,14133,aeApiName,1,aeApiName,char* aeApiName (void),ae_select.c,"static char *aeApiName(void) {
    return ""select"";
}",108.0,110.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
1603,14291,aeApiLookupPending,1,aeApiLookupPending,"int aeApiLookupPending (aeApiState*,int)",ae_evport.c,"static int aeApiLookupPending(aeApiState *state, int fd) {
    uint_t i;

    for (i = 0; i < state->npending; i++) {
        if (state->pending_fds[i] == fd)
            return (i);
    }

    return (-1);
}",111.0,120.0,1.0,1.0,10.0,7,6,7,3,0,2,3,4,2,0,,0,2,4,2,2,int
1604,14325,aeApiAssociate,1,aeApiAssociate,"int aeApiAssociate (char*,int,int,int)",ae_evport.c,"static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {
    int events = 0;
    int rv, err;

    if (mask & AE_READABLE)
        events |= POLLIN;
    if (mask & AE_WRITABLE)
        events |= POLLOUT;

    if (evport_debug)
        fprintf(stderr, ""%s: port_associate(%d, 0x%x) = "", where, fd, events);

    rv = port_associate(portfd, PORT_SOURCE_FD, fd, events,
        (void *)(uintptr_t)mask);
    err = errno;

    if (evport_debug)
        fprintf(stderr, ""%d (%s)\n"", rv, rv == 0 ? ""no error"" : strerror(err));

    if (rv == -1) {
        fprintf(stderr, ""%s: port_associate: %s\n"", where, strerror(err));

        if (err == EAGAIN)
            fprintf(stderr, ""aeApiAssociate: event port limit exceeded."");
    }

    return rv;
}",125.0,152.0,1.0,1.0,28.0,12,6,35,16,0,2,7,8,2,0,,0,2,8,4,4,int
1605,15878,anetSetError,1,anetSetError,"void anetSetError (char*,char*...)",anet.c,"static void anetSetError(char *err, const char *fmt, ...)
{
    va_list ap;

    if (!err) return;
    va_start(ap, fmt);
    vsnprintf(err, ANET_ERR_LEN, fmt, ap);
    va_end(ap);
}",55.0,63.0,1.0,19.0,9.0,1,1,7,3,23,0,2,2,0,0,,0,0,4,2,2,void
1606,15902,anetGetError,1,anetGetError,int anetGetError (int),anet.c,"int anetGetError(int fd) {
    int sockerr = 0;
    socklen_t errlen = sizeof(sockerr);

    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
        sockerr = errno;
    return sockerr;
}",65.0,72.0,1.0,1.0,8.0,8,5,11,6,1,0,2,2,0,0,,0,0,2,1,1,int
1607,15934,anetSetBlock,1,anetSetBlock,"int anetSetBlock (char*,int,int)",anet.c,"int anetSetBlock(char *err, int fd, int non_block) {
    int flags;

    /* Set the socket blocking (if non_block is zero) or non-blocking.
     * Note that fcntl(2) for F_GETFL and F_SETFL can't be
     * interrupted by a signal. */
    if ((flags = fcntl(fd, F_GETFL)) == -1) {
        anetSetError(err, ""fcntl(F_GETFL): %s"", strerror(errno));
        return ANET_ERR;
    }

    /* Check if this flag has been set or unset, if so, 
     * then there is no need to call fcntl to set/unset it again. */
    if (!!(flags & O_NONBLOCK) == !!non_block)
        return ANET_OK;

    if (non_block)
        flags |= O_NONBLOCK;
    else
        flags &= ~O_NONBLOCK;

    if (fcntl(fd, F_SETFL, flags) == -1) {
        anetSetError(err, ""fcntl(F_SETFL,O_NONBLOCK): %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",74.0,100.0,1.0,15.0,27.0,13,5,16,8,2,2,5,5,0,2,,0,0,6,3,3,int
1608,16012,anetNonBlock,1,anetNonBlock,"int anetNonBlock (char*,int)",anet.c,"int anetNonBlock(char *err, int fd) {
    return anetSetBlock(err,fd,1);
}",102.0,104.0,1.0,1.0,3.0,0,0,2,2,6,1,1,1,0,1,,0,0,4,2,2,int
1609,16023,anetBlock,1,anetBlock,"int anetBlock (char*,int)",anet.c,"int anetBlock(char *err, int fd) {
    return anetSetBlock(err,fd,0);
}",106.0,108.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
1610,16034,anetCloexec,1,anetCloexec,int anetCloexec (int),anet.c,"int anetCloexec(int fd) {
    int r;
    int flags;

    do {
        r = fcntl(fd, F_GETFD);
    } while (r == -1 && errno == EINTR);

    if (r == -1 || (r & FD_CLOEXEC))
        return r;

    flags = r | FD_CLOEXEC;

    do {
        r = fcntl(fd, F_SETFD, flags);
    } while (r == -1 && errno == EINTR);

    return r;
}",113.0,131.0,1.0,1.0,19.0,16,7,21,8,6,0,4,4,0,0,,0,0,2,1,1,int
1611,16091,anetKeepAlive,1,anetKeepAlive,"int anetKeepAlive (char*,int,int)",anet.c,"int anetKeepAlive(char *err, int fd, int interval)
{
    int val = 1;

    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1)
    {
        anetSetError(err, ""setsockopt SO_KEEPALIVE: %s"", strerror(errno));
        return ANET_ERR;
    }

#ifdef __linux__
    /* Default settings are more or less garbage, with the keepalive time
     * set to 7200 by default on Linux. Modify settings to make the feature
     * actually useful. */

    /* Send first probe after interval. */
    val = interval;
    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
        anetSetError(err, ""setsockopt TCP_KEEPIDLE: %s\n"", strerror(errno));
        return ANET_ERR;
    }

    /* Send next probes after the specified interval. Note that we set the
     * delay as interval / 3, as we send three probes before detecting
     * an error (see the next setsockopt call). */
    val = interval/3;
    if (val == 0) val = 1;
    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL...",136.0,187.0,1.0,15.0,52.0,7,6,9,7,1,1,2,2,0,1,,0,0,6,3,3,int
1612,16132,anetSetTcpNoDelay,1,anetSetTcpNoDelay,"int anetSetTcpNoDelay (char*,int,int)",anet.c,"static int anetSetTcpNoDelay(char *err, int fd, int val)
{
    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)) == -1)
    {
        anetSetError(err, ""setsockopt TCP_NODELAY: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",189.0,197.0,1.0,15.0,9.0,5,4,7,6,2,1,2,2,0,1,,0,0,6,3,3,int
1613,16166,anetEnableTcpNoDelay,1,anetEnableTcpNoDelay,"int anetEnableTcpNoDelay (char*,int)",anet.c,"int anetEnableTcpNoDelay(char *err, int fd)
{
    return anetSetTcpNoDelay(err, fd, 1);
}",199.0,202.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
1614,16177,anetDisableTcpNoDelay,1,anetDisableTcpNoDelay,"int anetDisableTcpNoDelay (char*,int)",anet.c,"int anetDisableTcpNoDelay(char *err, int fd)
{
    return anetSetTcpNoDelay(err, fd, 0);
}",204.0,207.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
1615,16188,anetSendTimeout,1,anetSendTimeout,"int anetSendTimeout (char*,int,long long)",anet.c,"int anetSendTimeout(char *err, int fd, long long ms) {
    struct timeval tv;

    tv.tv_sec = ms/1000;
    tv.tv_usec = (ms%1000)*1000;
    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
        anetSetError(err, ""setsockopt SO_SNDTIMEO: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",211.0,221.0,1.0,15.0,11.0,12,9,11,7,0,1,2,2,0,1,,0,0,6,3,3,int
1616,16239,anetRecvTimeout,1,anetRecvTimeout,"int anetRecvTimeout (char*,int,long long)",anet.c,"int anetRecvTimeout(char *err, int fd, long long ms) {
    struct timeval tv;

    tv.tv_sec = ms/1000;
    tv.tv_usec = (ms%1000)*1000;
    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
        anetSetError(err, ""setsockopt SO_RCVTIMEO: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",225.0,235.0,1.0,15.0,11.0,12,9,11,7,0,1,2,2,0,1,,0,0,6,3,3,int
1617,16290,anetResolve,1,anetResolve,"int anetResolve (char*,char*,char*,size_t,int)",anet.c,"int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
                       int flags)
{
    struct addrinfo hints, *info;
    int rv;

    memset(&hints,0,sizeof(hints));
    if (flags & ANET_IP_ONLY) hints.ai_flags = AI_NUMERICHOST;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;  /* specify socktype to avoid dups */

    if ((rv = getaddrinfo(host, NULL, &hints, &info)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    if (info->ai_family == AF_INET) {
        struct sockaddr_in *sa = (struct sockaddr_in *)info->ai_addr;
        inet_ntop(AF_INET, &(sa->sin_addr), ipbuf, ipbuf_len);
    } else {
        struct sockaddr_in6 *sa = (struct sockaddr_in6 *)info->ai_addr;
        inet_ntop(AF_INET6, &(sa->sin6_addr), ipbuf, ipbuf_len);
    }

    freeaddrinfo(info);
    return ANET_OK;
}",243.0,268.0,1.0,16.0,26.0,22,11,25,14,2,1,4,4,0,1,,0,0,10,5,5,int
1618,16402,anetSetReuseAddr,1,anetSetReuseAddr,"int anetSetReuseAddr (char*,int)",anet.c,"static int anetSetReuseAddr(char *err, int fd) {
    int yes = 1;
    /* Make sure connection-intensive things like the redis benchmark
     * will be able to close/open sockets a zillion of times */
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {
        anetSetError(err, ""setsockopt SO_REUSEADDR: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",270.0,279.0,1.0,15.0,10.0,6,5,8,6,3,1,2,2,0,1,,0,0,4,2,2,int
1619,16439,anetCreateSocket,1,anetCreateSocket,"int anetCreateSocket (char*,int)",anet.c,"static int anetCreateSocket(char *err, int domain) {
    int s;
    if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {
        anetSetError(err, ""creating socket: %s"", strerror(errno));
        return ANET_ERR;
    }

    /* Make sure connection-intensive things like the redis benchmark
     * will be able to close/open sockets a zillion of times */
    if (anetSetReuseAddr(err,s) == ANET_ERR) {
        close(s);
        return ANET_ERR;
    }
    return s;
}",281.0,295.0,1.0,15.0,15.0,7,3,9,5,2,2,3,3,1,2,,0,1,4,2,2,int
1620,16486,anetTcpGenericConnect,1,anetTcpGenericConnect,"int anetTcpGenericConnect (char*,char*,int,char*,int)",anet.c,"static int anetTcpGenericConnect(char *err, const char *addr, int port,
                                 const char *source_addr, int flags)
{
    int s = ANET_ERR, rv;
    char portstr[6];  /* strlen(""65535"") + 1; */
    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;

    snprintf(portstr,sizeof(portstr),""%d"",port);
    memset(&hints,0,sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(addr,portstr,&hints,&servinfo)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p->ai_next) {
        /* Try to create the socket and to connect it.
         * If we fail in the socket() call, or on connect(), we retry with
         * the next entry in servinfo. */
        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
            continue;
        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
        if (flags & ANET_CONNECT_...",300.0,378.0,1.0,12.0,79.0,59,11,75,19,2,6,25,32,2,6,,0,2,10,5,5,int
1621,16774,anetTcpNonBlockConnect,1,anetTcpNonBlockConnect,"int anetTcpNonBlockConnect (char*,char*,int)",anet.c,"int anetTcpNonBlockConnect(char *err, const char *addr, int port)
{
    return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONBLOCK);
}",380.0,383.0,1.0,52.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,int
1622,16790,anetTcpNonBlockBestEffortBindConnect,1,anetTcpNonBlockBestEffortBindConnect,"int anetTcpNonBlockBestEffortBindConnect (char*,char*,int,char*)",anet.c,"int anetTcpNonBlockBestEffortBindConnect(char *err, const char *addr, int port,
                                         const char *source_addr)
{
    return anetTcpGenericConnect(err,addr,port,source_addr,
            ANET_CONNECT_NONBLOCK|ANET_CONNECT_BE_BINDING);
}",385.0,390.0,1.0,12.0,6.0,1,1,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
1623,16811,anetUnixGenericConnect,1,anetUnixGenericConnect,"int anetUnixGenericConnect (char*,char*,int)",anet.c,"int anetUnixGenericConnect(char *err, const char *path, int flags)
{
    int s;
    struct sockaddr_un sa;

    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
        return ANET_ERR;

    sa.sun_family = AF_LOCAL;
    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));
    if (flags & ANET_CONNECT_NONBLOCK) {
        if (anetNonBlock(err,s) != ANET_OK) {
            close(s);
            return ANET_ERR;
        }
    }
    if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {
        if (errno == EINPROGRESS &&
            flags & ANET_CONNECT_NONBLOCK)
            return s;

        anetSetError(err, ""connect: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }
    return s;
}",392.0,418.0,1.0,48.0,27.0,21,10,23,8,0,4,6,8,2,4,,0,2,6,3,3,int
1624,16914,anetListen,1,anetListen,"int anetListen (char*,int,sockaddr*,socklen_t,int)",anet.c,"static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {
    if (bind(s,sa,len) == -1) {
        anetSetError(err, ""bind: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }

    if (listen(s, backlog) == -1) {
        anetSetError(err, ""listen: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }
    return ANET_OK;
}",420.0,433.0,1.0,15.0,14.0,6,2,11,6,2,2,3,3,0,2,,0,0,10,5,5,int
1625,16968,anetV6Only,1,anetV6Only,"int anetV6Only (char*,int)",anet.c,"static int anetV6Only(char *err, int s) {
    int yes = 1;
    if (setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes)) == -1) {
        anetSetError(err, ""setsockopt: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",435.0,442.0,1.0,15.0,8.0,6,5,8,6,1,1,2,2,0,1,,0,0,4,2,2,int
1626,17005,_anetTcpServer,1,_anetTcpServer,"int _anetTcpServer (char*,int,char*,int,int)",anet.c,"static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)
{
    int s = -1, rv;
    char _port[6];  /* strlen(""65535"") */
    struct addrinfo hints, *servinfo, *p;

    snprintf(_port,6,""%d"",port);
    memset(&hints,0,sizeof(hints));
    hints.ai_family = af;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */
    if (bindaddr && !strcmp(""*"", bindaddr))
        bindaddr = NULL;
    if (af == AF_INET6 && bindaddr && !strcmp(""::*"", bindaddr))
        bindaddr = NULL;

    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p->ai_next) {
        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
            continue;

        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;
        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
        ...",444.0,484.0,1.0,15.0,41.0,48,10,57,16,2,5,16,15,3,5,,0,3,10,5,5,int
1627,17211,anetTcpServer,1,anetTcpServer,"int anetTcpServer (char*,int,char*,int)",anet.c,"int anetTcpServer(char *err, int port, char *bindaddr, int backlog)
{
    return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);
}",486.0,489.0,1.0,1.0,4.0,0,0,5,5,0,1,1,1,0,1,,0,0,8,4,4,int
1628,17226,anetTcp6Server,1,anetTcp6Server,"int anetTcp6Server (char*,int,char*,int)",anet.c,"int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)
{
    return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);
}",491.0,494.0,1.0,1.0,4.0,0,0,5,5,1,1,1,1,0,1,,0,0,8,4,4,int
1629,17241,anetUnixServer,1,anetUnixServer,"int anetUnixServer (char*,char*,mode_t,int)",anet.c,"int anetUnixServer(char *err, char *path, mode_t perm, int backlog)
{
    int s;
    struct sockaddr_un sa;

    if (strlen(path) > sizeof(sa.sun_path)-1) {
        anetSetError(err,""unix socket path too long (%zu), must be under %zu"", strlen(path), sizeof(sa.sun_path));
        return ANET_ERR;
    }
    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
        return ANET_ERR;

    memset(&sa,0,sizeof(sa));
    sa.sun_family = AF_LOCAL;
    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));
    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)
        return ANET_ERR;
    if (perm)
        chmod(sa.sun_path, perm);
    return s;
}",496.0,516.0,1.0,15.0,21.0,25,9,24,7,1,4,5,5,2,4,,0,2,8,4,4,int
1630,17345,anetGenericAccept,1,anetGenericAccept,"int anetGenericAccept (char*,int,sockaddr*,socklen_t*)",anet.c,"static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {
    int fd;
    do {
        /* Use the accept4() call on linux to simultaneously accept and
         * set a socket as non-blocking. */
#ifdef HAVE_ACCEPT4
        fd = accept4(s, sa, len,  SOCK_NONBLOCK | SOCK_CLOEXEC);
#else
        fd = accept(s,sa,len);
#endif
    } while(fd == -1 && errno == EINTR);
    if (fd == -1) {
        anetSetError(err, ""accept: %s"", strerror(errno));
        return ANET_ERR;
    }
#ifndef HAVE_ACCEPT4
    if (anetCloexec(fd) == -1) {
        anetSetError(err, ""anetCloexec: %s"", strerror(errno));
        close(fd);
        return ANET_ERR;
    }
    if (anetNonBlock(err, fd) != ANET_OK) {
        close(fd);
        return ANET_ERR;
    }
#endif
    return fd;
}",520.0,547.0,1.0,15.0,28.0,13,5,18,7,2,4,5,5,2,4,,0,2,8,4,4,int
1631,17423,anetTcpAccept,1,anetTcpAccept,"int anetTcpAccept (char*,int,char*,size_t,int*)",anet.c,"int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port) {
    int fd;
    struct sockaddr_storage sa;
    socklen_t salen = sizeof(sa);
    if ((fd = anetGenericAccept(err,serversock,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
        return ANET_ERR;

    if (sa.ss_family == AF_INET) {
        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);
        if (port) *port = ntohs(s->sin_port);
    } else {
        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
        if (port) *port = ntohs(s->sin6_port);
    }
    return fd;
}",551.0,568.0,1.0,81.0,18.0,20,9,20,10,1,1,5,7,1,1,,0,1,10,5,5,int
1632,17533,anetUnixAccept,1,anetUnixAccept,"int anetUnixAccept (char*,int)",anet.c,"int anetUnixAccept(char *err, int s) {
    int fd;
    struct sockaddr_un sa;
    socklen_t salen = sizeof(sa);
    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
        return ANET_ERR;

    return fd;
}",572.0,580.0,1.0,72.0,9.0,9,6,8,5,1,1,2,2,1,1,,0,1,4,2,2,int
1633,17571,anetFdToString,1,anetFdToString,"int anetFdToString (int,char*,size_t,int*,int)",anet.c,"int anetFdToString(int fd, char *ip, size_t ip_len, int *port, int remote) {
    struct sockaddr_storage sa;
    socklen_t salen = sizeof(sa);

    if (remote) {
        if (getpeername(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;
    } else {
        if (getsockname(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;
    }

    if (sa.ss_family == AF_INET) {
        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
        if (ip) {
            if (inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len) == NULL)
                goto error;
        }
        if (port) *port = ntohs(s->sin_port);
    } else if (sa.ss_family == AF_INET6) {
        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
        if (ip) {
            if (inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len) == NULL)
                goto error;
        }
        if (port) *port = ntohs(s->sin6_port);
    } else if (sa.ss_family == AF_UNIX) {
        if (ip) {
            int res = snprintf(ip, ip_le...",582.0,628.0,1.0,1.0,47.0,27,11,25,10,1,0,12,16,0,0,,0,0,10,5,5,int
1634,17789,anetPipe,1,anetPipe,"int anetPipe (int[2],int,int)",anet.c,"int anetPipe(int fds[2], int read_flags, int write_flags) {
    int pipe_flags = 0;
#if defined(__linux__) || defined(__FreeBSD__)
    /* When possible, try to leverage pipe2() to apply flags that are common to both ends.
     * There is no harm to set O_CLOEXEC to prevent fd leaks. */
    pipe_flags = O_CLOEXEC | (read_flags & write_flags);
    if (pipe2(fds, pipe_flags)) {
        /* Fail on real failures, and fallback to simple pipe if pipe2 is unsupported. */
        if (errno != ENOSYS && errno != EINVAL)
            return -1;
        pipe_flags = 0;
    } else {
        /* If the flags on both ends are identical, no need to do anything else. */
        if ((O_CLOEXEC | read_flags) == (O_CLOEXEC | write_flags))
            return 0;
        /* Clear the flags which have already been set using pipe2. */
        read_flags &= ~pipe_flags;
        write_flags &= ~pipe_flags;
    }
#endif

    /* When we reach here with pipe_flags of 0, it means pipe2 failed (or was not attempted)...",633.0,684.0,1.0,1.0,52.0,15,7,27,8,4,0,14,14,0,0,,0,0,6,3,3,int
1635,17885,anetSetSockMarkId,1,anetSetSockMarkId,"int anetSetSockMarkId (char*,int,uint32_t)",anet.c,"int anetSetSockMarkId(char *err, int fd, uint32_t id) {
#ifdef HAVE_SOCKOPTMARKID
    if (setsockopt(fd, SOL_SOCKET, SOCKOPTMARKID, (void *)&id, sizeof(id)) == -1) {
        anetSetError(err, ""setsockopt: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
#else
    UNUSED(fd);
    UNUSED(id);
    anetSetError(err,""anetSetSockMarkid unsupported on this platform"");
    return ANET_OK;
#endif
}",686.0,699.0,1.0,4.0,14.0,2,1,5,3,1,1,1,1,0,1,,0,0,6,3,3,int
1636,18123,freeClientArgv,1,freeClientArgv,void freeClientArgv (client*),networking.c,"void freeClientArgv(client *c) {
    int j;
    for (j = 0; j < c->argc; j++)
        decrRefCount(c->argv[j]);
    c->argc = 0;
    c->cmd = NULL;
    c->argv_len_sum = 0;
    c->argv_len = 0;
    zfree(c->argv);
    c->argv = NULL;
}",1386.0,1396.0,1.0,1.0,11.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,void
1637,18128,getAppendOnlyFileSize,1,getAppendOnlyFileSize,"off_t getAppendOnlyFileSize (sds,int*)",aof.c,"off_t getAppendOnlyFileSize(sds filename, int *status) {
    struct redis_stat sb;
    off_t size;
    mstime_t latency;

    sds aof_filepath = makePath(server.aof_dirname, filename);
    latencyStartMonitor(latency);
    if (redis_stat(aof_filepath, &sb) == -1) {
        if (status) *status = errno == ENOENT ? AOF_NOT_EXIST : AOF_OPEN_ERR;
        serverLog(LL_WARNING, ""Unable to obtain the AOF file %s length. stat: %s"",
            filename, strerror(errno));
        size = 0;
    } else {
        if (status) *status = AOF_OK;
        size = sb.st_size;
    }
    latencyEndMonitor(latency);
    latencyAddSampleIfNeeded(""aof-fstat"", latency);
    sdsfree(aof_filepath);
    return size;
}",2521.0,2541.0,1.0,11.0,21.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,off_t
1638,18134,getBaseAndIncrAppendOnlyFilesSize,1,getBaseAndIncrAppendOnlyFilesSize,"off_t getBaseAndIncrAppendOnlyFilesSize (aofManifest*,int*)",aof.c,"off_t getBaseAndIncrAppendOnlyFilesSize(aofManifest *am, int *status) {
    off_t size = 0;
    listNode *ln;
    listIter li;

    if (am->base_aof_info) {
        serverAssert(am->base_aof_info->file_type == AOF_FILE_TYPE_BASE);

        size += getAppendOnlyFileSize(am->base_aof_info->file_name, status);
        if (*status != AOF_OK) return 0;
    }

    listRewind(am->incr_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_INCR);
        size += getAppendOnlyFileSize(ai->file_name, status);
        if (*status != AOF_OK) return 0;
    }

    return size;
}",2546.0,2567.0,1.0,8.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,off_t
1639,18140,getBaseAndIncrAppendOnlyFilesNum,1,getBaseAndIncrAppendOnlyFilesNum,int getBaseAndIncrAppendOnlyFilesNum (aofManifest*),aof.c,"int getBaseAndIncrAppendOnlyFilesNum(aofManifest *am) {
    int num = 0;
    if (am->base_aof_info) num++;
    if (am->incr_aof_list) num += listLength(am->incr_aof_list);
    return num;
}",2569.0,2574.0,1.0,34.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
1640,18145,aofFileExist,1,aofFileExist,int aofFileExist (char*),aof.c,"int aofFileExist(char *filename) {
    sds file_path = makePath(server.aof_dirname, filename);
    int ret = fileExist(file_path);
    sdsfree(file_path);
    return ret;
}",770.0,775.0,1.0,1.0,6.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
1641,18150,rewriteAppendOnlyFile,1,rewriteAppendOnlyFile,int rewriteAppendOnlyFile (char*),aof.c,"int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp = NULL;
    char tmpfile[256];

    /* Note that we have to use a different temp name here compared to the
     * one used by rewriteAppendOnlyFileBackground() function. */
    snprintf(tmpfile,256,""temp-rewriteaof-%d.aof"", (int) getpid());
    fp = fopen(tmpfile,""w"");
    if (!fp) {
        serverLog(LL_WARNING, ""Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"", strerror(errno));
        return C_ERR;
    }

    rioInitWithFile(&aof,fp);

    if (server.aof_rewrite_incremental_fsync) {
        rioSetAutoSync(&aof,REDIS_AUTOSYNC_BYTES);
        rioSetReclaimCache(&aof,1);
    }

    startSaving(RDBFLAGS_AOF_PREAMBLE);

    if (server.aof_use_rdb_preamble) {
        int error;
        if (rdbSaveRio(SLAVE_REQ_NONE,&aof,&error,RDBFLAGS_AOF_PREAMBLE,NULL) == C_ERR) {
            errno = error;
            goto werr;
        }
    } else {
        if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto ...",2357.0,2418.0,1.0,8.0,62.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
1642,18155,aofLoadManifestFromFile,1,aofLoadManifestFromFile,aofManifest* aofLoadManifestFromFile (sds),aof.c,"aofManifest *aofLoadManifestFromFile(sds am_filepath) {
    const char *err = NULL;
    long long maxseq = 0;

    aofManifest *am = aofManifestCreate();
    FILE *fp = fopen(am_filepath, ""r"");
    if (fp == NULL) {
        serverLog(LL_WARNING, ""Fatal error: can't open the AOF manifest ""
            ""file %s for reading: %s"", am_filepath, strerror(errno));
        exit(1);
    }

    char buf[MANIFEST_MAX_LINE+1];
    sds *argv = NULL;
    int argc;
    aofInfo *ai = NULL;

    sds line = NULL;
    int linenum = 0;

    while (1) {
        if (fgets(buf, MANIFEST_MAX_LINE+1, fp) == NULL) {
            if (feof(fp)) {
                if (linenum == 0) {
                    err = ""Found an empty AOF manifest"";
                    goto loaderr;
                } else {
                    break;
                }
            } else {
                err = ""Read AOF manifest failed"";
                goto loaderr;
            }
        }

        linenum++;

        /* Skip comments lin...",256.0,382.0,1.0,8.0,127.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,aofManifest
1643,18160,aofManifestFreeAndUpdate,1,aofManifestFreeAndUpdate,void aofManifestFreeAndUpdate (aofManifest*),aof.c,"void aofManifestFreeAndUpdate(aofManifest *am) {
    serverAssert(am != NULL);
    if (server.aof_manifest) aofManifestFree(server.aof_manifest);
    server.aof_manifest = am;
}",412.0,416.0,1.0,4.0,5.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1644,18165,aof_background_fsync_and_close,1,aof_background_fsync_and_close,void aof_background_fsync_and_close (int),aof.c,"void aof_background_fsync_and_close(int fd) {
    bioCreateCloseAofJob(fd, server.master_repl_offset, 1);
}",929.0,931.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1645,18170,aofInfoCreate,1,aofInfoCreate,aofInfo aofInfoCreate (void),aof.c,"aofInfo *aofInfoCreate(void) {
    return zcalloc(sizeof(aofInfo));
}",99.0,101.0,1.0,1.0,3.0,1,1,1,1,4,1,1,1,0,1,,0,0,2,1,1,aofInfo
1646,18179,aofInfoFree,1,aofInfoFree,void aofInfoFree (aofInfo*),aof.c,"void aofInfoFree(aofInfo *ai) {
    serverAssert(ai != NULL);
    if (ai->file_name) sdsfree(ai->file_name);
    zfree(ai);
}",104.0,108.0,1.0,4.0,5.0,7,6,5,2,3,5,2,2,1,3,,0,2,2,1,1,void
1647,18211,aofInfoDup,1,aofInfoDup,aofInfo aofInfoDup (aofInfo*),aof.c,"aofInfo *aofInfoDup(aofInfo *orig) {
    serverAssert(orig != NULL);
    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdsdup(orig->file_name);
    ai->file_seq = orig->file_seq;
    ai->file_type = orig->file_type;
    return ai;
}",111.0,118.0,1.0,4.0,8.0,15,7,10,3,3,9,1,1,0,3,,0,8,2,1,1,aofInfo
1648,18260,aofInfoFormat,1,aofInfoFormat,"sds aofInfoFormat (sds,aofInfo*)",aof.c,"sds aofInfoFormat(sds buf, aofInfo *ai) {
    sds filename_repr = NULL;

    if (sdsneedsrepr(ai->file_name))
        filename_repr = sdscatrepr(sdsempty(), ai->file_name, sdslen(ai->file_name));

    sds ret = sdscatprintf(buf, ""%s %s %s %lld %s %c\n"",
        AOF_MANIFEST_KEY_FILE_NAME, filename_repr ? filename_repr : ai->file_name,
        AOF_MANIFEST_KEY_FILE_SEQ, ai->file_seq,
        AOF_MANIFEST_KEY_FILE_TYPE, ai->file_type);
    sdsfree(filename_repr);

    return ret;
}",121.0,134.0,1.0,8.0,14.0,10,3,15,5,3,12,2,2,2,6,,0,11,4,2,2,sds
1649,18318,aofListFree,1,aofListFree,void aofListFree (void*),aof.c,"void aofListFree(void *item) {
    aofInfo *ai = (aofInfo *)item;
    aofInfoFree(ai);
}",137.0,140.0,1.0,1.0,4.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
1650,18331,aofListDup,1,aofListDup,void* aofListDup (void*),aof.c,"void *aofListDup(void *item) {
    return aofInfoDup(item);
}",143.0,145.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void*
1651,18339,aofManifestCreate,1,aofManifestCreate,aofManifest aofManifestCreate (void),aof.c,"aofManifest *aofManifestCreate(void) {
    aofManifest *am = zcalloc(sizeof(aofManifest));
    am->incr_aof_list = listCreate();
    am->history_aof_list = listCreate();
    listSetFreeMethod(am->incr_aof_list, aofListFree);
    listSetDupMethod(am->incr_aof_list, aofListDup);
    listSetFreeMethod(am->history_aof_list, aofListFree);
    listSetDupMethod(am->history_aof_list, aofListDup);
    return am;
}",148.0,157.0,1.0,4.0,10.0,22,3,13,2,1,13,1,1,0,3,,0,13,2,1,1,aofManifest
1652,18414,aofManifestFree,1,aofManifestFree,void aofManifestFree (aofManifest*),aof.c,"void aofManifestFree(aofManifest *am) {
    if (am->base_aof_info) aofInfoFree(am->base_aof_info);
    if (am->incr_aof_list) listRelease(am->incr_aof_list);
    if (am->history_aof_list) listRelease(am->history_aof_list);
    zfree(am);
}",160.0,165.0,1.0,1.0,6.0,6,1,7,1,5,10,4,4,3,4,,0,6,2,1,1,void
1653,18448,getAofManifestFileName,1,getAofManifestFileName,sds getAofManifestFileName (void),aof.c,"sds getAofManifestFileName(void) {
    return sdscatprintf(sdsempty(), ""%s%s"", server.aof_filename,
                MANIFEST_NAME_SUFFIX);
}",167.0,170.0,1.0,16.0,4.0,1,1,1,1,2,2,1,1,0,2,,0,1,2,1,1,sds
1654,18463,getTempAofManifestFileName,1,getTempAofManifestFileName,sds getTempAofManifestFileName (void),aof.c,"sds getTempAofManifestFileName(void) {
    return sdscatprintf(sdsempty(), ""%s%s%s"", TEMP_FILE_NAME_PREFIX,
                server.aof_filename, MANIFEST_NAME_SUFFIX);
}",172.0,175.0,1.0,46.0,4.0,1,1,1,1,1,2,1,1,0,2,,0,1,2,1,1,sds
1655,18481,getAofManifestAsString,1,getAofManifestAsString,sds getAofManifestAsString (aofManifest*),aof.c,"sds getAofManifestAsString(aofManifest *am) {
    serverAssert(am != NULL);

    sds buf = sdsempty();
    listNode *ln;
    listIter li;

    /* 1. Add BASE File information, it is always at the beginning
     * of the manifest file. */
    if (am->base_aof_info) {
        buf = aofInfoFormat(buf, am->base_aof_info);
    }

    /* 2. Add HISTORY type AOF information. */
    listRewind(am->history_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        buf = aofInfoFormat(buf, ai);
    }

    /* 3. Add INCR type AOF information. */
    listRewind(am->incr_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        buf = aofInfoFormat(buf, ai);
    }

    return buf;
}",192.0,220.0,1.0,4.0,29.0,27,8,28,6,1,15,4,4,3,9,,0,12,2,1,1,sds
1656,18578,aofLoadManifestFromDisk,1,aofLoadManifestFromDisk,void aofLoadManifestFromDisk (void),aof.c,"void aofLoadManifestFromDisk(void) {
    server.aof_manifest = aofManifestCreate();
    if (!dirExists(server.aof_dirname)) {
        serverLog(LL_DEBUG, ""The AOF directory %s doesn't exist"", server.aof_dirname);
        return;
    }

    sds am_name = getAofManifestFileName();
    sds am_filepath = makePath(server.aof_dirname, am_name);
    if (!fileExist(am_filepath)) {
        serverLog(LL_DEBUG, ""The AOF manifest file %s doesn't exist"", am_name);
        sdsfree(am_name);
        sdsfree(am_filepath);
        return;
    }

    aofManifest *am = aofLoadManifestFromFile(am_filepath);
    if (am) aofManifestFreeAndUpdate(am);
    sdsfree(am_name);
    sdsfree(am_filepath);
}",232.0,252.0,1.0,8.0,21.0,16,5,19,4,0,13,4,4,2,13,,0,6,2,1,1,void
1657,19144,aofManifestDup,1,aofManifestDup,aofManifest aofManifestDup (aofManifest*),aof.c,"aofManifest *aofManifestDup(aofManifest *orig) {
    serverAssert(orig != NULL);
    aofManifest *am = zcalloc(sizeof(aofManifest));

    am->curr_base_file_seq = orig->curr_base_file_seq;
    am->curr_incr_file_seq = orig->curr_incr_file_seq;
    am->dirty = orig->dirty;

    if (orig->base_aof_info) {
        am->base_aof_info = aofInfoDup(orig->base_aof_info);
    }

    am->incr_aof_list = listDup(orig->incr_aof_list);
    am->history_aof_list = listDup(orig->history_aof_list);
    serverAssert(am->incr_aof_list != NULL);
    serverAssert(am->history_aof_list != NULL);
    return am;
}",391.0,408.0,1.0,4.0,18.0,38,8,22,4,1,22,2,2,1,7,,0,19,2,1,1,aofManifest
1658,19294,getNewBaseFileNameAndMarkPreAsHistory,1,getNewBaseFileNameAndMarkPreAsHistory,sds getNewBaseFileNameAndMarkPreAsHistory (aofManifest*),aof.c,"sds getNewBaseFileNameAndMarkPreAsHistory(aofManifest *am) {
    serverAssert(am != NULL);
    if (am->base_aof_info) {
        serverAssert(am->base_aof_info->file_type == AOF_FILE_TYPE_BASE);
        am->base_aof_info->file_type = AOF_FILE_TYPE_HIST;
        listAddNodeHead(am->history_aof_list, am->base_aof_info);
    }

    char *format_suffix = server.aof_use_rdb_preamble ?
        RDB_FORMAT_SUFFIX:AOF_FORMAT_SUFFIX;

    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdscatprintf(sdsempty(), ""%s.%lld%s%s"", server.aof_filename,
                        ++am->curr_base_file_seq, BASE_FILE_SUFFIX, format_suffix);
    ai->file_seq = am->curr_base_file_seq;
    ai->file_type = AOF_FILE_TYPE_BASE;
    am->base_aof_info = ai;
    am->dirty = 1;
    return am->base_aof_info->file_name;
}",427.0,446.0,1.0,4.0,20.0,38,10,24,7,2,19,2,2,1,6,,0,16,2,1,1,sds
1659,19417,getNewIncrAofName,1,getNewIncrAofName,sds getNewIncrAofName (aofManifest*),aof.c,"sds getNewIncrAofName(aofManifest *am) {
    aofInfo *ai = aofInfoCreate();
    ai->file_type = AOF_FILE_TYPE_INCR;
    ai->file_name = sdscatprintf(sdsempty(), ""%s.%lld%s%s"", server.aof_filename,
                        ++am->curr_incr_file_seq, INCR_FILE_SUFFIX, AOF_FORMAT_SUFFIX);
    ai->file_seq = am->curr_incr_file_seq;
    listAddNodeTail(am->incr_aof_list, ai);
    am->dirty = 1;
    return ai->file_name;
}",455.0,464.0,1.0,50.0,10.0,15,4,12,4,2,12,1,1,0,4,,0,11,2,1,1,sds
1660,19472,getTempIncrAofName,1,getTempIncrAofName,sds getTempIncrAofName (void),aof.c,"sds getTempIncrAofName(void) {
    return sdscatprintf(sdsempty(), ""%s%s%s"", TEMP_FILE_NAME_PREFIX, server.aof_filename,
        INCR_FILE_SUFFIX);
}",467.0,470.0,1.0,46.0,4.0,1,1,1,1,3,2,1,1,0,2,,0,1,2,1,1,sds
1661,19490,getLastIncrAofName,1,getLastIncrAofName,sds getLastIncrAofName (aofManifest*),aof.c,"sds getLastIncrAofName(aofManifest *am) {
    serverAssert(am != NULL);

    /* If 'incr_aof_list' is empty, just create a new one. */
    if (!listLength(am->incr_aof_list)) {
        return getNewIncrAofName(am);
    }

    /* Or return the last one. */
    listNode *lastnode = listIndex(am->incr_aof_list, -1);
    aofInfo *ai = listNodeValue(lastnode);
    return ai->file_name;
}",473.0,485.0,1.0,4.0,13.0,15,9,11,4,1,8,2,2,2,3,,0,6,2,1,1,sds
1662,19549,markRewrittenIncrAofAsHistory,1,markRewrittenIncrAofAsHistory,void markRewrittenIncrAofAsHistory (aofManifest*),aof.c,"void markRewrittenIncrAofAsHistory(aofManifest *am) {
    serverAssert(am != NULL);
    if (!listLength(am->incr_aof_list)) {
        return;
    }

    listNode *ln;
    listIter li;

    listRewindTail(am->incr_aof_list, &li);

    /* ""server.aof_fd != -1"" means AOF enabled, then we must skip the
     * last AOF, because this file is our currently writing. */
    if (server.aof_fd != -1) {
        ln = listNext(&li);
        serverAssert(ln != NULL);
    }

    /* Move aofInfo from 'incr_aof_list' to 'history_aof_list'. */
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_INCR);

        aofInfo *hai = aofInfoDup(ai);
        hai->file_type = AOF_FILE_TYPE_HIST;
        listAddNodeHead(am->history_aof_list, hai);
        listDelNode(am->incr_aof_list, ln);
    }

    am->dirty = 1;
}",492.0,522.0,1.0,4.0,31.0,40,12,27,9,1,18,4,4,3,9,,0,12,2,1,1,void
1663,19681,writeAofManifestFile,1,writeAofManifestFile,int writeAofManifestFile (sds),aof.c,"int writeAofManifestFile(sds buf) {
    int ret = C_OK;
    ssize_t nwritten;
    int len;

    sds am_name = getAofManifestFileName();
    sds am_filepath = makePath(server.aof_dirname, am_name);
    sds tmp_am_name = getTempAofManifestFileName();
    sds tmp_am_filepath = makePath(server.aof_dirname, tmp_am_name);

    int fd = open(tmp_am_filepath, O_WRONLY|O_TRUNC|O_CREAT, 0644);
    if (fd == -1) {
        serverLog(LL_WARNING, ""Can't open the AOF manifest file %s: %s"",
            tmp_am_name, strerror(errno));

        ret = C_ERR;
        goto cleanup;
    }

    len = sdslen(buf);
    while(len) {
        nwritten = write(fd, buf, len);

        if (nwritten < 0) {
            if (errno == EINTR) continue;

            serverLog(LL_WARNING, ""Error trying to write the temporary AOF manifest file %s: %s"",
                tmp_am_name, strerror(errno));

            ret = C_ERR;
            goto cleanup;
        }

        len -= nwritten;
        buf += nwritten;
    }

    if...",525.0,595.0,1.0,14.0,71.0,50,10,62,15,1,15,15,12,1,15,,0,6,2,1,1,int
1664,19949,persistAofManifest,1,persistAofManifest,int persistAofManifest (aofManifest*),aof.c,"int persistAofManifest(aofManifest *am) {
    if (am->dirty == 0) {
        return C_OK;
    }

    sds amstr = getAofManifestAsString(am);
    int ret = writeAofManifestFile(amstr);
    sdsfree(amstr);
    if (ret == C_OK) am->dirty = 0;
    return ret;
}",598.0,608.0,1.0,15.0,11.0,7,3,9,3,5,5,3,3,1,3,,0,4,2,1,1,int
1665,19991,aofUpgradePrepare,1,aofUpgradePrepare,void aofUpgradePrepare (aofManifest*),aof.c,"void aofUpgradePrepare(aofManifest *am) {
    serverAssert(!aofFileExist(server.aof_filename));

    /* Create AOF directory use 'server.aof_dirname' as the name. */
    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        exit(1);
    }

    /* Manually construct a BASE type aofInfo and add it to aofManifest. */
    if (am->base_aof_info) aofInfoFree(am->base_aof_info);
    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdsnew(server.aof_filename);
    ai->file_seq = 1;
    ai->file_type = AOF_FILE_TYPE_BASE;
    am->base_aof_info = ai;
    am->curr_base_file_seq = 1;
    am->dirty = 1;

    /* Persist the manifest file to AOF directory. */
    if (persistAofManifest(am) != C_OK) {
        exit(1);
    }

    /* Move the old AOF file to AOF directory. */
    sds aof_filepath = makePath(server.aof_dirname, server.aof_filename);
    if (rename(serv...",620.0,660.0,1.0,4.0,41.0,48,13,33,6,1,22,5,5,3,14,,0,13,2,1,1,void
1666,20185,aofDelHistoryFiles,1,aofDelHistoryFiles,int aofDelHistoryFiles (void),aof.c,"int aofDelHistoryFiles(void) {
    if (server.aof_manifest == NULL ||
        server.aof_disable_auto_gc == 1 ||
        !listLength(server.aof_manifest->history_aof_list))
    {
        return C_OK;
    }

    listNode *ln;
    listIter li;

    listRewind(server.aof_manifest->history_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_HIST);
        serverLog(LL_NOTICE, ""Removing the history file %s in the background"", ai->file_name);
        sds aof_filepath = makePath(server.aof_dirname, ai->file_name);
        bg_unlink(aof_filepath);
        sdsfree(aof_filepath);
        listDelNode(server.aof_manifest->history_aof_list, ln);
    }

    server.aof_manifest->dirty = 1;
    return persistAofManifest(server.aof_manifest);
}",668.0,692.0,1.0,9.0,25.0,40,14,25,7,2,13,3,3,1,9,,0,6,2,1,1,int
1667,20322,aofDelTempIncrAofFile,1,aofDelTempIncrAofFile,void aofDelTempIncrAofFile (void),aof.c,"void aofDelTempIncrAofFile(void) {
    sds aof_filename = getTempIncrAofName();
    sds aof_filepath = makePath(server.aof_dirname, aof_filename);
    serverLog(LL_NOTICE, ""Removing the temp incr aof file %s in the background"", aof_filename);
    bg_unlink(aof_filepath);
    sdsfree(aof_filepath);
    sdsfree(aof_filename);
    return;
}",695.0,703.0,1.0,4.0,9.0,6,4,9,3,1,6,1,1,0,6,,0,2,2,1,1,void
1668,20365,aofOpenIfNeededOnServerStart,1,aofOpenIfNeededOnServerStart,void aofOpenIfNeededOnServerStart (void),aof.c,"void aofOpenIfNeededOnServerStart(void) {
    if (server.aof_state != AOF_ON) {
        return;
    }

    serverAssert(server.aof_manifest != NULL);
    serverAssert(server.aof_fd == -1);

    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        exit(1);
    }

    /* If we start with an empty dataset, we will force create a BASE file. */
    size_t incr_aof_len = listLength(server.aof_manifest->incr_aof_list);
    if (!server.aof_manifest->base_aof_info && !incr_aof_len) {
        sds base_name = getNewBaseFileNameAndMarkPreAsHistory(server.aof_manifest);
        sds base_filepath = makePath(server.aof_dirname, base_name);
        if (rewriteAppendOnlyFile(base_filepath) != C_OK) {
            exit(1);
        }
        sdsfree(base_filepath);
        serverLog(LL_NOTICE, ""Creating AOF base file %s on server start"",
            base_name);
    }

  ...",713.0,768.0,1.0,28.0,56.0,66,15,48,12,0,16,8,9,2,16,,0,8,2,1,1,void
1669,20680,openNewIncrAofForAppend,1,openNewIncrAofForAppend,int openNewIncrAofForAppend (void),aof.c,"int openNewIncrAofForAppend(void) {
    serverAssert(server.aof_manifest != NULL);
    int newfd = -1;
    aofManifest *temp_am = NULL;
    sds new_aof_name = NULL;

    /* Only open new INCR AOF when AOF enabled. */
    if (server.aof_state == AOF_OFF) return C_OK;

    /* Open new AOF. */
    if (server.aof_state == AOF_WAIT_REWRITE) {
        /* Use a temporary INCR AOF file to accumulate data during AOF_WAIT_REWRITE. */
        new_aof_name = getTempIncrAofName();
    } else {
        /* Dup a temp aof_manifest to modify. */
        temp_am = aofManifestDup(server.aof_manifest);
        new_aof_name = sdsdup(getNewIncrAofName(temp_am));
    }
    sds new_aof_filepath = makePath(server.aof_dirname, new_aof_name);
    newfd = open(new_aof_filepath, O_WRONLY|O_TRUNC|O_CREAT, 0644);
    sdsfree(new_aof_filepath);
    if (newfd == -1) {
        serverLog(LL_WARNING, ""Can't open the append-only file %s: %s"",
            new_aof_name, strerror(errno));
        goto cleanup;
    }

    ...",790.0,853.0,1.0,4.0,64.0,46,12,44,10,1,12,13,12,1,12,,0,3,2,1,1,int
1670,20903,aofRewriteLimited,1,aofRewriteLimited,int aofRewriteLimited (void),aof.c,"int aofRewriteLimited(void) {
    static int next_delay_minutes = 0;
    static time_t next_rewrite_time = 0;

    if (server.stat_aofrw_consecutive_failures < AOF_REWRITE_LIMITE_THRESHOLD) {
        /* We may be recovering from limited state, so reset all states. */
        next_delay_minutes = 0;
        next_rewrite_time = 0;
        return 0;
    }

    /* if it is in the limiting state, then check if the next_rewrite_time is reached */
    if (next_rewrite_time != 0) {
        if (server.unixtime < next_rewrite_time) {
            return 1;
        } else {
            next_rewrite_time = 0;
            return 0;
        }
    }

    next_delay_minutes = (next_delay_minutes == 0) ? 1 : (next_delay_minutes * 2);
    if (next_delay_minutes > AOF_REWRITE_LIMITE_MAX_MINUTES) {
        next_delay_minutes = AOF_REWRITE_LIMITE_MAX_MINUTES;
    }

    next_rewrite_time = server.unixtime + next_delay_minutes * 60;
    serverLog(LL_WARNING,
        ""Background AOF rewrite has repeatedly ...",877.0,907.0,1.0,49.0,31.0,22,10,18,3,1,1,5,6,0,1,,0,0,2,1,1,int
1671,21006,aofFsyncInProgress,1,aofFsyncInProgress,int aofFsyncInProgress (void),aof.c,"int aofFsyncInProgress(void) {
    /* Note that we don't care about aof_background_fsync_and_close because
     * server.aof_fd has been replaced by the new INCR AOF file fd,
     * see openNewIncrAofForAppend. */
    return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
}",915.0,920.0,1.0,1.0,6.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,int
1672,21016,aof_background_fsync,1,aof_background_fsync,void aof_background_fsync (int),aof.c,"void aof_background_fsync(int fd) {
    bioCreateFsyncJob(fd, server.master_repl_offset, 1);
}",924.0,926.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
1673,21038,killAppendOnlyChild,1,killAppendOnlyChild,void killAppendOnlyChild (void),aof.c,"void killAppendOnlyChild(void) {
    int statloc;
    /* No AOFRW child? return. */
    if (server.child_type != CHILD_TYPE_AOF) return;
    /* Kill AOFRW child, wait for child exit. */
    serverLog(LL_NOTICE,""Killing running AOF rewrite child: %ld"",
        (long) server.child_pid);
    if (kill(server.child_pid,SIGUSR1) != -1) {
        while(waitpid(-1, &statloc, 0) != server.child_pid);
    }
    aofRemoveTempFile(server.child_pid);
    resetChildState();
    server.aof_rewrite_time_start = -1;
}",934.0,947.0,1.0,29.0,14.0,18,8,9,3,1,3,4,5,0,3,,0,0,2,1,1,void
1674,21109,stopAppendOnly,1,stopAppendOnly,void stopAppendOnly (void),aof.c,"void stopAppendOnly(void) {
    serverAssert(server.aof_state != AOF_OFF);
    flushAppendOnlyFile(1);
    if (redis_fsync(server.aof_fd) == -1) {
        serverLog(LL_WARNING,""Fail to fsync the AOF file: %s"",strerror(errno));
    } else {
        server.aof_last_fsync = server.unixtime;
    }
    close(server.aof_fd);

    server.aof_fd = -1;
    server.aof_selected_db = -1;
    server.aof_state = AOF_OFF;
    server.aof_rewrite_scheduled = 0;
    server.aof_last_incr_size = 0;
    server.aof_last_incr_fsync_offset = 0;
    server.fsynced_reploff = -1;
    atomicSet(server.fsynced_reploff_pending, 0);
    killAppendOnlyChild();
    sdsfree(server.aof_buf);
    server.aof_buf = sdsempty();
}",951.0,972.0,1.0,4.0,22.0,35,11,16,2,4,6,2,2,0,6,,0,1,2,1,1,void
1675,21236,startAppendOnly,1,startAppendOnly,int startAppendOnly (void),aof.c,"int startAppendOnly(void) {
    serverAssert(server.aof_state == AOF_OFF);

    /* Wait for all bio jobs related to AOF to drain. This prevents a race
     * between updates to `fsynced_reploff_pending` of the worker thread, belonging
     * to the previous AOF, and the new one. This concern is specific for a full
     * sync scenario where we don't wanna risk the ACKed replication offset
     * jumping backwards or forward when switching to a different master. */
    bioDrainWorker(BIO_AOF_FSYNC);

    /* Set the initial repl_offset, which will be applied to fsynced_reploff
     * when AOFRW finishes (after possibly being updated by a bio thread) */
    atomicSet(server.fsynced_reploff_pending, server.master_repl_offset);
    server.fsynced_reploff = 0;

    server.aof_state = AOF_WAIT_REWRITE;
    if (hasActiveChildProcess() && server.child_type != CHILD_TYPE_AOF) {
        server.aof_rewrite_scheduled = 1;
        serverLog(LL_NOTICE,""AOF was enabled but there is already another ...",976.0,1029.0,1.0,4.0,54.0,38,12,19,3,2,6,4,4,1,6,,0,1,2,1,1,int
1676,21497,aofWrite,1,aofWrite,"ssize_t aofWrite (int,char*,size_t)",aof.c,"ssize_t aofWrite(int fd, const char *buf, size_t len) {
    ssize_t nwritten = 0, totwritten = 0;

    while(len) {
        nwritten = write(fd, buf, len);

        if (nwritten < 0) {
            if (errno == EINTR) continue;
            return totwritten ? totwritten : -1;
        }

        len -= nwritten;
        buf += nwritten;
        totwritten += nwritten;
    }

    return totwritten;
}",1038.0,1055.0,1.0,1.0,18.0,10,7,19,7,1,0,5,7,0,0,,0,0,6,3,3,ssize_t
1677,21549,flushAppendOnlyFile,1,flushAppendOnlyFile,void flushAppendOnlyFile (int),aof.c,"void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) {
        /* Check if we need to do fsync even the aof buffer is empty,
         * because previously in AOF_FSYNC_EVERYSEC mode, fsync is
         * called only when aof buffer is not empty, so if users
         * stop write commands before fsync called in one second,
         * the data in page cache cannot be flushed in time. */
        if (server.aof_fsync == AOF_FSYNC_EVERYSEC &&
            server.aof_last_incr_fsync_offset != server.aof_last_incr_size &&
            server.unixtime > server.aof_last_fsync &&
            !(sync_in_progress = aofFsyncInProgress())) {
            goto try_fsync;

        /* Check if we need to do fsync even the aof buffer is empty,
         * the reason is described in the previous AOF_FSYNC_EVERYSEC block,
         * and AOF_FSYNC_ALWAYS is also checked here to handle a case where
         * aof_f...",1076.0,1278.0,1.0,32.0,203.0,118,16,94,8,6,22,19,28,7,22,,0,14,2,1,1,void
1678,22292,catAppendOnlyGenericCommand,1,catAppendOnlyGenericCommand,"sds catAppendOnlyGenericCommand (sds,int,robj**)",aof.c,"sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
    char buf[32];
    int len, j;
    robj *o;

    buf[0] = '*';
    len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
    buf[len++] = '\r';
    buf[len++] = '\n';
    dst = sdscatlen(dst,buf,len);

    for (j = 0; j < argc; j++) {
        o = getDecodedObject(argv[j]);
        buf[0] = '$';
        len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
        buf[len++] = '\r';
        buf[len++] = '\n';
        dst = sdscatlen(dst,buf,len);
        dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
        dst = sdscatlen(dst,""\r\n"",2);
        decrRefCount(o);
    }
    return dst;
}",1280.0,1303.0,1.0,1.0,24.0,37,8,40,7,1,10,2,2,0,10,,0,9,6,3,3,sds
1679,22416,genAofTimestampAnnotationIfNeeded,1,genAofTimestampAnnotationIfNeeded,sds genAofTimestampAnnotationIfNeeded (int),aof.c,"sds genAofTimestampAnnotationIfNeeded(int force) {
    sds ts = NULL;

    if (force || server.aof_cur_timestamp < server.unixtime) {
        server.aof_cur_timestamp = force ? time(NULL) : server.unixtime;
        ts = sdscatfmt(sdsempty(), ""#TS:%I\r\n"", server.aof_cur_timestamp);
        serverAssert(sdslen(ts) <= AOF_ANNOTATION_LINE_MAX_LEN);
    }
    return ts;
}",1313.0,1322.0,1.0,8.0,10.0,16,9,13,4,2,4,2,2,0,4,,0,2,2,1,1,sds
1680,22474,feedAppendOnlyFile,1,feedAppendOnlyFile,"void feedAppendOnlyFile (int,robj**,int)",aof.c,"void feedAppendOnlyFile(int dictid, robj **argv, int argc) {
    sds buf = sdsempty();

    serverAssert(dictid == -1 || (dictid >= 0 && dictid < server.dbnum));

    /* Feed timestamp if needed */
    if (server.aof_timestamp_enabled) {
        sds ts = genAofTimestampAnnotationIfNeeded(0);
        if (ts != NULL) {
            buf = sdscatsds(buf, ts);
            sdsfree(ts);
        }
    }

    /* The DB this command was targeting is not the same as the last command
     * we appended. To issue a SELECT command is needed. */
    if (dictid != -1 && dictid != server.aof_selected_db) {
        char seldb[64];

        snprintf(seldb,sizeof(seldb),""%d"",dictid);
        buf = sdscatprintf(buf,""*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"",
            (unsigned long)strlen(seldb),seldb);
        server.aof_selected_db = dictid;
    }

    /* All commands should be propagated the same way in AOF as in replication.
     * No need for AOF-specific translation. */
    buf = catAppendOnlyGeneri...",1332.0,1371.0,1.0,4.0,40.0,38,14,37,8,1,10,5,6,0,10,,0,7,6,3,3,void
1681,22612,createAOFClient,1,createAOFClient,struct client createAOFClient (void),aof.c,"struct client *createAOFClient(void) {
    struct client *c = createClient(NULL);

    c->id = CLIENT_ID_AOF; /* So modules can identify it's the AOF client. */

    /*
     * The AOF client should never be blocked (unlike master
     * replication connection).
     * This is because blocking the AOF client might cause
     * deadlock (because potentially no one will unblock it).
     * Also, if the AOF client will be blocked just for
     * background processing there is a chance that the
     * command execution order will be violated.
     */
    c->flags = CLIENT_DENY_BLOCKING;

    /* We set the fake client as a slave waiting for the synchronization
     * so that Redis will not try to send replies to this client. */
    c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
    return c;
}",1379.0,1399.0,1.0,12.0,21.0,8,3,7,3,1,4,1,1,0,1,,0,4,2,1,1,struct client
1682,22647,loadSingleAppendOnlyFile,1,loadSingleAppendOnlyFile,int loadSingleAppendOnlyFile (char*),aof.c,"int loadSingleAppendOnlyFile(char *filename) {
    struct client *fakeClient;
    struct redis_stat sb;
    int old_aof_state = server.aof_state;
    long loops = 0;
    off_t valid_up_to = 0; /* Offset of latest well-formed command loaded. */
    off_t valid_before_multi = 0; /* Offset before MULTI command loaded. */
    off_t last_progress_report_size = 0;
    int ret = AOF_OK;

    sds aof_filepath = makePath(server.aof_dirname, filename);
    FILE *fp = fopen(aof_filepath, ""r"");
    if (fp == NULL) {
        int en = errno;
        if (redis_stat(aof_filepath, &sb) == 0 || errno != ENOENT) {
            serverLog(LL_WARNING,""Fatal error: can't open the append log file %s for reading: %s"", filename, strerror(en));
            sdsfree(aof_filepath);
            return AOF_OPEN_ERR;
        } else {
            serverLog(LL_WARNING,""The append log file %s doesn't exist: %s"", filename, strerror(errno));
            sdsfree(aof_filepath);
            return AOF_NOT_EXIST;
        }
 ...",1407.0,1658.0,1.0,11.0,252.0,187,27,181,34,2,49,46,60,4,33,,0,22,2,1,1,int
1683,23735,loadAppendOnlyFiles,1,loadAppendOnlyFiles,int loadAppendOnlyFiles (aofManifest*),aof.c,"int loadAppendOnlyFiles(aofManifest *am) {
    serverAssert(am != NULL);
    int status, ret = AOF_OK;
    long long start;
    off_t total_size = 0, base_size = 0;
    sds aof_name;
    int total_num, aof_num = 0, last_file;

    /* If the 'server.aof_filename' file exists in dir, we may be starting
     * from an old redis version. We will use enter upgrade mode in three situations.
     *
     * 1. If the 'server.aof_dirname' directory not exist
     * 2. If the 'server.aof_dirname' directory exists but the manifest file is missing
     * 3. If the 'server.aof_dirname' directory exists and the manifest file it contains
     *    has only one base AOF record, and the file name of this base AOF is 'server.aof_filename',
     *    and the 'server.aof_filename' file not exist in 'server.aof_dirname' directory
     * */
    if (fileExist(server.aof_filename)) {
        if (!dirExists(server.aof_dirname) ||
            (am->base_aof_info == NULL && listLength(am->incr_aof_list) == 0) |...",1661.0,1784.0,1.0,4.0,124.0,147,20,103,17,1,46,18,30,17,27,,0,32,2,1,1,int
1684,24283,rioWriteBulkObject,1,rioWriteBulkObject,"int rioWriteBulkObject (rio*,robj*)",aof.c,"int rioWriteBulkObject(rio *r, robj *obj) {
    /* Avoid using getDecodedObject to help copy-on-write (we are often
     * in a child process when this function is called). */
    if (obj->encoding == OBJ_ENCODING_INT) {
        return rioWriteBulkLongLong(r,(long)obj->ptr);
    } else if (sdsEncodedObject(obj)) {
        return rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));
    } else {
        serverPanic(""Unknown string encoding"");
    }
}",1792.0,1802.0,1.0,25.0,11.0,4,3,3,2,13,1,2,2,0,1,,0,0,4,2,2,int
1685,24344,rewriteListObject,1,rewriteListObject,"int rewriteListObject (rio*,robj*,robj*)",aof.c,"int rewriteListObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = listTypeLength(o);

    listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
    listTypeEntry entry;
    while (listTypeNext(li,&entry)) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;
            if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
                !rioWriteBulkString(r,""RPUSH"",5) ||
                !rioWriteBulkObject(r,key)) 
            {
                listTypeReleaseIterator(li);
                return 0;
            }
        }

        unsigned char *vstr;
        size_t vlen;
        long long lval;
        vstr = listTypeGetValue(&entry,&vlen,&lval);
        if (vstr) {
            if (!rioWriteBulkString(r,(char*)vstr,vlen)) {
                listTypeReleaseIterator(li);
                return 0;
            }
        } else {
            if (!rioWriteBulkLongLong(r,lval)) {
 ...",1806.0,1844.0,1.0,52.0,39.0,24,11,30,11,0,11,7,14,5,11,,0,8,6,3,3,int
1686,24475,rewriteSetObject,1,rewriteSetObject,"int rewriteSetObject (rio*,robj*,robj*)",aof.c,"int rewriteSetObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = setTypeSize(o);
    setTypeIterator *si = setTypeInitIterator(o);
    char *str;
    size_t len;
    int64_t llval;
    while (setTypeNext(si, &str, &len, &llval) != -1) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;
            if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
                !rioWriteBulkString(r,""SADD"",4) ||
                !rioWriteBulkObject(r,key))
            {
                return 0;
            }
        }
        size_t written = str ?
            rioWriteBulkString(r, str, len) : rioWriteBulkLongLong(r, llval);
        if (!written) {
            setTypeReleaseIterator(si);
            return 0;
        }
        if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
        items--;
    }
    setTypeReleaseIterator(si);
    return 1;
}",1848.0,1876.0,1.0,37.0,29.0,25,12,31,11,0,10,6,11,4,10,,0,8,6,3,3,int
1687,24589,rewriteSortedSetObject,1,rewriteSortedSetObject,"int rewriteSortedSetObject (rio*,robj*,robj*)",aof.c,"int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = zsetLength(o);

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vll;
        double score;

        eptr = lpSeek(zl,0);
        serverAssert(eptr != NULL);
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        while (eptr != NULL) {
            vstr = lpGetValue(eptr,&vlen,&vll);
            score = zzlGetScore(sptr);

            if (count == 0) {
                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                    AOF_REWRITE_ITEMS_PER_CMD : items;

                if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
                    !rioWriteBulkString(r,""ZADD"",4) ||
                    !rioWriteBulkObject(r,key)) 
                {
                    return 0;
                }
            }
            i...",1880.0,1956.0,1.0,23.0,77.0,44,16,45,14,0,13,9,24,5,13,,0,10,6,3,3,int
1688,24912,rioWriteHashIteratorCursor,1,rioWriteHashIteratorCursor,"int rioWriteHashIteratorCursor (rio*,hashTypeIterator*,int)",aof.c,"static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *vstr = NULL;
        unsigned int vlen = UINT_MAX;
        long long vll = LLONG_MAX;

        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);
        if (vstr)
            return rioWriteBulkString(r, (char*)vstr, vlen);
        else
            return rioWriteBulkLongLong(r, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds value = hashTypeCurrentFromHashTable(hi, what);
        return rioWriteBulkString(r, value, sdslen(value));
    }

    serverPanic(""Unknown hash encoding"");
    return 0;
}",1964.0,1982.0,1.0,24.0,19.0,10,6,16,9,2,4,3,4,1,3,,0,1,6,3,3,int
1689,24998,rewriteHashObject,1,rewriteHashObject,"int rewriteHashObject (rio*,robj*,robj*)",aof.c,"int rewriteHashObject(rio *r, robj *key, robj *o) {
    hashTypeIterator *hi;
    long long count = 0, items = hashTypeLength(o);

    hi = hashTypeInitIterator(o);
    while (hashTypeNext(hi) != C_ERR) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;

            if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
                !rioWriteBulkString(r,""HMSET"",5) ||
                !rioWriteBulkObject(r,key)) 
            {
                hashTypeReleaseIterator(hi);
                return 0;
            }
        }

        if (!rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) ||
            !rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE))
        {
            hashTypeReleaseIterator(hi);
            return 0;           
        }
        if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
        items--;
    }

    hashTypeReleaseIterator(hi);

    return 1;
}",1986.0,2018.0,1.0,31.0,33.0,23,12,25,7,0,11,6,11,6,11,,0,8,6,3,3,int
1690,25110,rioWriteBulkStreamID,1,rioWriteBulkStreamID,"int rioWriteBulkStreamID (rio*,streamID*)",aof.c,"int rioWriteBulkStreamID(rio *r,streamID *id) {
    int retval;

    sds replyid = sdscatfmt(sdsempty(),""%U-%U"",id->ms,id->seq);
    retval = rioWriteBulkString(r,replyid,sdslen(replyid));
    sdsfree(replyid);
    return retval;
}",2022.0,2029.0,1.0,1.0,8.0,4,2,9,4,5,7,1,1,0,5,,0,6,4,2,2,int
1691,25140,rioWriteStreamPendingEntry,1,rioWriteStreamPendingEntry,"int rioWriteStreamPendingEntry (rio*,robj*,char*,size_t,streamConsumer*,unsigned char*,streamNACK*)",aof.c,"int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
     /* XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
               RETRYCOUNT <count> JUSTID FORCE. */
    streamID id;
    streamDecodeID(rawid,&id);
    if (rioWriteBulkCount(r,'*',12) == 0) return 0;
    if (rioWriteBulkString(r,""XCLAIM"",6) == 0) return 0;
    if (rioWriteBulkObject(r,key) == 0) return 0;
    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
    if (rioWriteBulkString(r,""0"",1) == 0) return 0;
    if (rioWriteBulkStreamID(r,&id) == 0) return 0;
    if (rioWriteBulkString(r,""TIME"",4) == 0) return 0;
    if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
    if (rioWriteBulkString(r,""RETRYCOUNT"",10) == 0) return 0;
    if (rioWriteBulkLongLong(r,nack->delivery_count) == ...",2035.0,2054.0,1.0,1.0,20.0,19,3,23,8,1,19,14,14,18,15,,0,18,14,7,7,int
1692,25294,rioWriteStreamEmptyConsumer,1,rioWriteStreamEmptyConsumer,"int rioWriteStreamEmptyConsumer (rio*,robj*,char*,size_t,streamConsumer*)",aof.c,"int rioWriteStreamEmptyConsumer(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer) {
    /* XGROUP CREATECONSUMER <key> <group> <consumer> */
    if (rioWriteBulkCount(r,'*',5) == 0) return 0;
    if (rioWriteBulkString(r,""XGROUP"",6) == 0) return 0;
    if (rioWriteBulkString(r,""CREATECONSUMER"",14) == 0) return 0;
    if (rioWriteBulkObject(r,key) == 0) return 0;
    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
    return 1;
}",2059.0,2068.0,1.0,1.0,10.0,8,2,11,5,1,9,7,7,9,7,,0,9,10,5,5,int
1693,25369,rewriteStreamObject,1,rewriteStreamObject,"int rewriteStreamObject (rio*,robj*,robj*)",aof.c,"int rewriteStreamObject(rio *r, robj *key, robj *o) {
    stream *s = o->ptr;
    streamIterator si;
    streamIteratorStart(&si,s,NULL,NULL,0);
    streamID id;
    int64_t numfields;

    if (s->length) {
        /* Reconstruct the stream data using XADD commands. */
        while(streamIteratorGetID(&si,&id,&numfields)) {
            /* Emit a two elements array for each item. The first is
             * the ID, the second is an array of field-value pairs. */

            /* Emit the XADD <key> <id> ...fields... command. */
            if (!rioWriteBulkCount(r,'*',3+numfields*2) || 
                !rioWriteBulkString(r,""XADD"",4) ||
                !rioWriteBulkObject(r,key) ||
                !rioWriteBulkStreamID(r,&id)) 
            {
                streamIteratorStop(&si);
                return 0;
            }
            while(numfields--) {
                unsigned char *field, *value;
                int64_t field_len, value_len;
                streamIteratorGetField(&...",2072.0,2210.0,1.0,1.0,139.0,115,11,105,18,0,74,16,42,44,53,,0,50,6,3,3,int
1694,25829,rewriteModuleObject,1,rewriteModuleObject,"int rewriteModuleObject (rio*,robj*,robj*,int)",aof.c,"int rewriteModuleObject(rio *r, robj *key, robj *o, int dbid) {
    RedisModuleIO io;
    moduleValue *mv = o->ptr;
    moduleType *mt = mv->type;
    moduleInitIOContext(io,mt,r,key,dbid);
    mt->aof_rewrite(&io,key,mv->value);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    return io.error ? 0 : 1;
}",2215.0,2226.0,1.0,4.0,12.0,28,5,31,8,0,16,2,2,1,2,,0,14,8,4,4,int
1695,25930,rewriteFunctions,1,rewriteFunctions,int rewriteFunctions (rio*),aof.c,"static int rewriteFunctions(rio *aof) {
    dict *functions = functionsLibGet();
    dictIterator *iter = dictGetIterator(functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionLibInfo *li = dictGetVal(entry);
        if (rioWrite(aof, ""*3\r\n"", 4) == 0) goto werr;
        char function_load[] = ""$8\r\nFUNCTION\r\n$4\r\nLOAD\r\n"";
        if (rioWrite(aof, function_load, sizeof(function_load) - 1) == 0) goto werr;
        if (rioWriteBulkString(aof, li->code, sdslen(li->code)) == 0) goto werr;
    }
    dictReleaseIterator(iter);
    return 1;

werr:
    dictReleaseIterator(iter);
    return 0;
}",2228.0,2245.0,1.0,1.0,18.0,13,5,19,7,1,12,8,8,7,10,,0,10,2,1,1,int
1696,26007,rewriteAppendOnlyFileRio,1,rewriteAppendOnlyFileRio,int rewriteAppendOnlyFileRio (rio*),aof.c,"int rewriteAppendOnlyFileRio(rio *aof) {
    dictIterator *di = NULL;
    dictEntry *de;
    int j;
    long key_count = 0;
    long long updated_time = 0;

    /* Record timestamp at the beginning of rewriting AOF. */
    if (server.aof_timestamp_enabled) {
        sds ts = genAofTimestampAnnotationIfNeeded(1);
        if (rioWrite(aof,ts,sdslen(ts)) == 0) { sdsfree(ts); goto werr; }
        sdsfree(ts);
    }

    if (rewriteFunctions(aof) == 0) goto werr;

    for (j = 0; j < server.dbnum; j++) {
        char selectcmd[] = ""*2\r\n$6\r\nSELECT\r\n"";
        redisDb *db = server.db+j;
        dict *d = db->dict;
        if (dictSize(d) == 0) continue;
        di = dictGetSafeIterator(d);

        /* SELECT the new DB */
        if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
        if (rioWriteBulkLongLong(aof,j) == 0) goto werr;

        /* Iterate this DB writing every entry */
        while((de = dictNext(di)) != NULL) {
            sds keystr;
            robj...",2247.0,2348.0,1.0,12.0,102.0,77,15,90,22,0,28,33,58,14,25,,0,21,2,1,1,int
1697,26736,rewriteAppendOnlyFileBackground,1,rewriteAppendOnlyFileBackground,int rewriteAppendOnlyFileBackground (void),aof.c,"int rewriteAppendOnlyFileBackground(void) {
    pid_t childpid;

    if (hasActiveChildProcess()) return C_ERR;

    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        server.aof_lastbgrewrite_status = C_ERR;
        return C_ERR;
    }

    /* We set aof_selected_db to -1 in order to force the next call to the
     * feedAppendOnlyFile() to issue a SELECT command. */
    server.aof_selected_db = -1;
    flushAppendOnlyFile(1);
    if (openNewIncrAofForAppend() != C_OK) {
        server.aof_lastbgrewrite_status = C_ERR;
        return C_ERR;
    }
    server.stat_aof_rewrites++;
    if ((childpid = redisFork(CHILD_TYPE_AOF)) == 0) {
        char tmpfile[256];

        /* Child */
        redisSetProcTitle(""redis-aof-rewrite"");
        redisSetCpuAffinity(server.aof_rewrite_cpulist);
        snprintf(tmpfile,256,""temp-rewriteaof-bg-%d.aof"", (int) get...",2437.0,2489.0,1.0,40.0,53.0,30,9,15,5,1,12,6,7,5,12,,0,5,2,1,1,int
1698,26968,bgrewriteaofCommand,1,bgrewriteaofCommand,void bgrewriteaofCommand (client*),aof.c,"void bgrewriteaofCommand(client *c) {
    if (server.child_type == CHILD_TYPE_AOF) {
        addReplyError(c,""Background append only file rewriting already in progress"");
    } else if (hasActiveChildProcess() || server.in_exec) {
        server.aof_rewrite_scheduled = 1;
        /* When manually triggering AOFRW we reset the count 
         * so that it can be executed immediately. */
        server.stat_aofrw_consecutive_failures = 0;
        addReplyStatus(c,""Background append only file rewriting scheduled"");
    } else if (rewriteAppendOnlyFileBackground() == C_OK) {
        addReplyStatus(c,""Background append only file rewriting started"");
    } else {
        addReplyError(c,""Can't execute an AOF background rewriting. ""
                        ""Please check the server logs for more information."");
    }
}",2491.0,2506.0,1.0,29.0,16.0,2,2,2,2,0,1,2,2,0,1,,0,0,2,1,1,void
1699,27024,aofRemoveTempFile,1,aofRemoveTempFile,void aofRemoveTempFile (pid_t),aof.c,"void aofRemoveTempFile(pid_t childpid) {
    char tmpfile[256];

    snprintf(tmpfile,256,""temp-rewriteaof-bg-%d.aof"", (int) childpid);
    bg_unlink(tmpfile);

    snprintf(tmpfile,256,""temp-rewriteaof-%d.aof"", (int) childpid);
    bg_unlink(tmpfile);
}",2508.0,2516.0,1.0,1.0,9.0,2,1,6,2,2,2,1,1,0,2,,0,0,2,1,1,void
1700,27334,backgroundRewriteDoneHandler,1,backgroundRewriteDoneHandler,"void backgroundRewriteDoneHandler (int,int)",aof.c,"void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        char tmpfile[256];
        long long now = ustime();
        sds new_base_filepath = NULL;
        sds new_incr_filepath = NULL;
        aofManifest *temp_am;
        mstime_t latency;

        serverLog(LL_NOTICE,
            ""Background AOF rewrite terminated with success"");

        snprintf(tmpfile, 256, ""temp-rewriteaof-bg-%d.aof"",
            (int)server.child_pid);

        serverAssert(server.aof_manifest != NULL);

        /* Dup a temporary aof_manifest for subsequent modifications. */
        temp_am = aofManifestDup(server.aof_manifest);

        /* Get a new BASE file name and mark the previous (if we have)
         * as the HISTORY type. */
        sds new_base_filename = getNewBaseFileNameAndMarkPreAsHistory(temp_am);
        serverAssert(new_base_filename != NULL);
        new_base_filepath = makePath(server.aof_dirname, new_base_filename);

        /* Rename...",2578.0,2738.0,1.0,8.0,161.0,132,17,131,16,0,50,15,22,1,50,,0,16,4,2,2,void
1701,28129,bioInit,1,bioInit,void bioInit (void),bio.c,"void bioInit(void) {
    pthread_attr_t attr;
    pthread_t thread;
    size_t stacksize;
    unsigned long j;

    /* Initialization of state vars and objects */
    for (j = 0; j < BIO_WORKER_NUM; j++) {
        pthread_mutex_init(&bio_mutex[j],NULL);
        pthread_cond_init(&bio_newjob_cond[j],NULL);
        bio_jobs[j] = listCreate();
    }

    /* Set the stack size as by default it may be small in some system */
    pthread_attr_init(&attr);
    pthread_attr_getstacksize(&attr,&stacksize);
    if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */
    while (stacksize < REDIS_THREAD_STACK_SIZE) stacksize *= 2;
    pthread_attr_setstacksize(&attr, stacksize);

    /* Ready to spawn our threads. We use the single argument the thread
     * function accepts in order to pass the job ID the thread is
     * responsible for. */
    for (j = 0; j < BIO_WORKER_NUM; j++) {
        void *arg = (void*)(unsigned long) j;
        if (pthread_create(&thread,&attr,bioProce...",119.0,150.0,1.0,20.0,32.0,38,13,35,14,1,10,6,7,4,2,,0,9,2,1,1,void
1702,28269,bioSubmitJob,1,bioSubmitJob,"void bioSubmitJob (int,bio_job*)",bio.c,"void bioSubmitJob(int type, bio_job *job) {
    job->header.type = type;
    unsigned long worker = bio_job_to_worker[type];
    pthread_mutex_lock(&bio_mutex[worker]);
    listAddNodeTail(bio_jobs[worker],job);
    bio_jobs_counter[type]++;
    pthread_cond_signal(&bio_newjob_cond[worker]);
    pthread_mutex_unlock(&bio_mutex[worker]);
}",152.0,160.0,1.0,1.0,9.0,14,6,16,8,4,7,1,1,0,1,,0,6,4,2,2,void
1703,28312,bioCreateLazyFreeJob,1,bioCreateLazyFreeJob,"void bioCreateLazyFreeJob (lazy_free_fn,int...)",bio.c,"void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) {
    va_list valist;
    /* Allocate memory for the job structure and all required
     * arguments */
    bio_job *job = zmalloc(sizeof(*job) + sizeof(void *) * (arg_count));
    job->free_args.free_fn = free_fn;

    va_start(valist, arg_count);
    for (int i = 0; i < arg_count; i++) {
        job->free_args.free_args[i] = va_arg(valist, void *);
    }
    va_end(valist);
    bioSubmitJob(BIO_LAZY_FREE, job);
}",162.0,175.0,1.0,1.0,14.0,11,8,14,7,6,2,2,2,0,2,,0,1,4,2,2,void
1704,28359,bioCreateCloseJob,1,bioCreateCloseJob,"void bioCreateCloseJob (int,int,int)",bio.c,"void bioCreateCloseJob(int fd, int need_fsync, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.need_fsync = need_fsync;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_CLOSE_FILE, job);
}",177.0,184.0,1.0,1.0,8.0,12,5,10,5,2,2,1,1,0,2,,0,1,6,3,3,void
1705,28397,bioCreateCloseAofJob,1,bioCreateCloseAofJob,"void bioCreateCloseAofJob (int,long long,int)",bio.c,"void bioCreateCloseAofJob(int fd, long long offset, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.offset = offset;
    job->fd_args.need_fsync = 1;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_CLOSE_AOF, job);
}",186.0,194.0,1.0,1.0,9.0,15,5,11,5,0,2,1,1,0,2,,0,1,6,3,3,void
1706,28442,bioCreateFsyncJob,1,bioCreateFsyncJob,"void bioCreateFsyncJob (int,long long,int)",bio.c,"void bioCreateFsyncJob(int fd, long long offset, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.offset = offset;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_AOF_FSYNC, job);
}",196.0,203.0,1.0,1.0,8.0,12,5,10,5,1,2,1,1,0,2,,0,1,6,3,3,void
1707,28920,bioPendingJobsOfType,1,bioPendingJobsOfType,unsigned long bioPendingJobsOfType (int),bio.c,"unsigned long bioPendingJobsOfType(int type) {
    unsigned int worker = bio_job_to_worker[type];

    pthread_mutex_lock(&bio_mutex[worker]);
    unsigned long val = bio_jobs_counter[type];
    pthread_mutex_unlock(&bio_mutex[worker]);

    return val;
}",303.0,311.0,1.0,1.0,9.0,8,3,11,6,3,4,1,1,0,0,,0,4,2,1,1,unsigned long
1708,28949,bioDrainWorker,1,bioDrainWorker,void bioDrainWorker (int),bio.c,"void bioDrainWorker(int job_type) {
    unsigned long worker = bio_job_to_worker[job_type];

    pthread_mutex_lock(&bio_mutex[worker]);
    while (listLength(bio_jobs[worker]) > 0) {
        pthread_cond_wait(&bio_newjob_cond[worker], &bio_mutex[worker]);
    }
    pthread_mutex_unlock(&bio_mutex[worker]);
}",314.0,322.0,1.0,11.0,9.0,14,5,15,6,2,7,2,2,2,0,,0,7,2,1,1,void
1709,28993,bioKillThreads,1,bioKillThreads,void bioKillThreads (void),bio.c,"void bioKillThreads(void) {
    int err;
    unsigned long j;

    for (j = 0; j < BIO_WORKER_NUM; j++) {
        if (bio_threads[j] == pthread_self()) continue;
        if (bio_threads[j] && pthread_cancel(bio_threads[j]) == 0) {
            if ((err = pthread_join(bio_threads[j],NULL)) != 0) {
                serverLog(LL_WARNING,
                    ""Bio worker thread #%lu can not be joined: %s"",
                        j, strerror(err));
            } else {
                serverLog(LL_WARNING,
                    ""Bio worker thread #%lu terminated"",j);
            }
        }
    }
}",328.0,345.0,1.0,20.0,18.0,18,11,17,6,1,7,6,9,6,1,,0,6,2,1,1,void
1710,29734,redisBitpos,1,redisBitpos,"long long redisBitpos (void*,long unsigned,int)",bitops.c,"long long redisBitpos(void *s, unsigned long count, int bit) {
    unsigned long *l;
    unsigned char *c;
    unsigned long skipval, word = 0, one;
    long long pos = 0; /* Position of bit, to return to the caller. */
    unsigned long j;
    int found;

    /* Process whole words first, seeking for first word that is not
     * all ones or all zeros respectively if we are looking for zeros
     * or ones. This is much faster with large strings having contiguous
     * blocks of 1 or 0 bits compared to the vanilla bit per bit processing.
     *
     * Note that if we start from an address that is not aligned
     * to sizeof(unsigned long) we consume it byte by byte until it is
     * aligned. */

    /* Skip initial bits not aligned to sizeof(unsigned long) byte by byte. */
    skipval = bit ? 0 : UCHAR_MAX;
    c = (unsigned char*) s;
    found = 0;
    while((unsigned long)c & (sizeof(*l)-1) && count) {
        if (*c != skipval) {
            found = 1;
            break;
    ...",101.0,186.0,1.0,4.0,86.0,58,21,57,13,0,1,13,17,0,1,,0,0,6,3,3,long long
1711,29925,setUnsignedBitfield,1,setUnsignedBitfield,"void setUnsignedBitfield (unsigned char*,uint64_t,uint64_t,uint64_t)",bitops.c,"void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {
    uint64_t byte, bit, byteval, bitval, j;

    for (j = 0; j < bits; j++) {
        bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
        byte = offset >> 3;
        bit = 7 - (offset & 0x7);
        byteval = p[byte];
        byteval &= ~(1 << bit);
        byteval |= bitval << bit;
        p[byte] = byteval & 0xff;
        offset++;
    }
}",209.0,222.0,1.0,1.0,14.0,23,11,23,9,1,0,2,2,0,0,,0,0,8,4,4,void
1712,30001,setSignedBitfield,1,setSignedBitfield,"void setSignedBitfield (unsigned char*,uint64_t,uint64_t,int64_t)",bitops.c,"void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
    uint64_t uv = value; /* Casting will add UINT64_MAX + 1 if v is negative. */
    setUnsignedBitfield(p,offset,bits,uv);
}",224.0,227.0,1.0,1.0,4.0,1,1,6,5,1,1,1,1,0,1,,0,0,8,4,4,void
1713,30018,getUnsignedBitfield,1,getUnsignedBitfield,"uint64_t getUnsignedBitfield (unsigned char*,uint64_t,uint64_t)",bitops.c,"uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
    uint64_t byte, bit, byteval, bitval, j, value = 0;

    for (j = 0; j < bits; j++) {
        byte = offset >> 3;
        bit = 7 - (offset & 0x7);
        byteval = p[byte];
        bitval = (byteval >> bit) & 1;
        value = (value<<1) | bitval;
        offset++;
    }
    return value;
}",229.0,241.0,1.0,1.0,13.0,17,9,19,9,1,0,2,2,0,0,,0,0,6,3,3,uint64_t
1714,30080,getSignedBitfield,1,getSignedBitfield,"int64_t getSignedBitfield (unsigned char*,uint64_t,uint64_t)",bitops.c,"int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
    int64_t value;
    union {uint64_t u; int64_t i;} conv;

    /* Converting from unsigned to signed is undefined when the value does
     * not fit, however here we assume two's complement and the original value
     * was obtained from signed -> unsigned conversion, so we'll find the
     * most significant bit set if the original value was negative.
     *
     * Note that two's complement is mandatory for exact-width types
     * according to the C99 standard. */
    conv.u = getUnsignedBitfield(p,offset,bits);
    value = conv.i;

    /* If the top significant bit is 1, propagate it to all the
     * higher bits for two's complement representation of signed
     * integers. */
    if (bits < 64 && (value & ((uint64_t)1 << (bits-1))))
        value |= ((uint64_t)-1) << bits;
    return value;
}",243.0,263.0,1.0,1.0,21.0,12,8,13,6,1,1,2,2,0,1,,0,1,6,3,3,int64_t
1715,30266,checkSignedBitfieldOverflow,1,checkSignedBitfieldOverflow,"int checkSignedBitfieldOverflow (int64_t,int64_t,uint64_t,int,int64_t*)",bitops.c,"int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {
    int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);
    int64_t min = (-max)-1;

    /* Note that maxincr and minincr could overflow, but we use the values
     * only after checking 'value' range, so when we use it no overflow
     * happens. 'uint64_t' cast is there just to prevent undefined behavior on
     * overflow */
    int64_t maxincr = (uint64_t)max-value;
    int64_t minincr = min-value;

    if (value > max || (bits != 64 && incr > maxincr) || (value >= 0 && incr > 0 && incr > maxincr))
    {
        if (limit) {
            if (owtype == BFOVERFLOW_WRAP) {
                goto handle_wrap;
            } else if (owtype == BFOVERFLOW_SAT) {
                *limit = max;
            }
        }
        return 1;
    } else if (value < min || (bits != 64 && incr < minincr) || (value < 0 && incr < 0 && incr < minincr)) {
        if (limit) {
       ...",325.0,378.0,1.0,26.0,54.0,42,16,42,16,1,0,7,10,0,0,,0,0,10,5,5,int
1716,30527,getBitOffsetFromArgument,1,getBitOffsetFromArgument,"int getBitOffsetFromArgument (client*,robj*,uint64_t*,int,int)",bitops.c,"int getBitOffsetFromArgument(client *c, robj *o, uint64_t *offset, int hash, int bits) {
    long long loffset;
    char *err = ""bit offset is not an integer or out of range"";
    char *p = o->ptr;
    size_t plen = sdslen(p);
    int usehash = 0;

    /* Handle #<offset> form. */
    if (p[0] == '#' && hash && bits > 0) usehash = 1;

    if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
        addReplyError(c,err);
        return C_ERR;
    }

    /* Adjust the offset by 'bits' for #<offset> form. */
    if (usehash) loffset *= bits;

    /* Limit offset to server.proto_max_bulk_len (512MB in bytes by default) */
    if (loffset < 0 || (!mustObeyClient(c) && (loffset >> 3) >= server.proto_max_bulk_len))
    {
        addReplyError(c,err);
        return C_ERR;
    }

    *offset = loffset;
    return C_OK;
}",414.0,441.0,1.0,15.0,28.0,27,18,28,11,3,5,5,5,2,5,,0,3,10,5,5,int
1717,30632,getBitfieldTypeFromArgument,1,getBitfieldTypeFromArgument,"int getBitfieldTypeFromArgument (client*,robj*,int*,int*)",bitops.c,"int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {
    char *p = o->ptr;
    char *err = ""Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is."";
    long long llbits;

    if (p[0] == 'i') {
        *sign = 1;
    } else if (p[0] == 'u') {
        *sign = 0;
    } else {
        addReplyError(c,err);
        return C_ERR;
    }

    if ((string2ll(p+1,strlen(p+1),&llbits)) == 0 ||
        llbits < 1 ||
        (*sign == 1 && llbits > 64) ||
        (*sign == 0 && llbits > 63))
    {
        addReplyError(c,err);
        return C_ERR;
    }
    *bits = llbits;
    return C_OK;
}",450.0,474.0,1.0,15.0,25.0,26,12,17,7,1,2,3,3,1,2,,0,1,8,4,4,int
1718,30737,lookupStringForBitCommand,1,lookupStringForBitCommand,"robj lookupStringForBitCommand (client*,uint64_t,int*)",bitops.c,"robj *lookupStringForBitCommand(client *c, uint64_t maxbit, int *dirty) {
    size_t byte = maxbit >> 3;
    robj *o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return NULL;
    if (dirty) *dirty = 0;

    if (o == NULL) {
        o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
        dbAdd(c->db,c->argv[1],o);
        if (dirty) *dirty = 1;
    } else {
        o = dbUnshareStringValue(c->db,c->argv[1],o);
        size_t oldlen = sdslen(o->ptr);
        o->ptr = sdsgrowzero(o->ptr,byte+1);
        if (dirty && oldlen != sdslen(o->ptr)) *dirty = 1;
    }
    return o;
}",481.0,498.0,1.0,22.0,18.0,16,7,21,6,1,9,5,6,1,5,,0,8,6,3,3,robj
1719,30860,getObjectReadOnlyString,1,getObjectReadOnlyString,"unsigned char* getObjectReadOnlyString (robj*,long*,char*)",bitops.c,"unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {
    serverAssert(!o || o->type == OBJ_STRING);
    unsigned char *p = NULL;

    /* Set the 'p' pointer to the string, that can be just a stack allocated
     * array if our string was integer encoded. */
    if (o && o->encoding == OBJ_ENCODING_INT) {
        p = (unsigned char*) llbuf;
        if (len) *len = ll2string(llbuf,LONG_STR_SIZE,(long)o->ptr);
    } else if (o) {
        p = (unsigned char*) o->ptr;
        if (len) *len = sdslen(o->ptr);
    } else {
        if (len) *len = 0;
    }
    return p;
}",513.0,529.0,1.0,4.0,17.0,18,11,13,5,2,2,3,4,0,2,,0,1,6,3,3,unsigned char*
1720,30957,setbitCommand,1,setbitCommand,void setbitCommand (client*),bitops.c,"void setbitCommand(client *c) {
    robj *o;
    char *err = ""bit is not an integer or out of range"";
    uint64_t bitoffset;
    ssize_t byte, bit;
    int byteval, bitval;
    long on;

    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
        return;

    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
        return;

    /* Bits can only be set or cleared... */
    if (on & ~1) {
        addReplyError(c,err);
        return;
    }

    int dirty;
    if ((o = lookupStringForBitCommand(c,bitoffset,&dirty)) == NULL) return;

    /* Get current values */
    byte = bitoffset >> 3;
    byteval = ((uint8_t*)o->ptr)[byte];
    bit = 7 - (bitoffset & 0x7);
    bitval = byteval & (1 << bit);

    /* Either it is newly created, changed length, or the bit changes before and after.
     * Note that the bitval here is actually a decimal number.
     * So we need to use `!!` to convert it to 0 or 1 for comparison. */
    if (dirty || (!!bitval != on)) {
    ...",532.0,576.0,1.0,65.0,45.0,51,17,47,13,0,13,6,6,5,7,,0,9,2,1,1,void
1721,31131,getbitCommand,1,getbitCommand,void getbitCommand (client*),bitops.c,"void getbitCommand(client *c) {
    robj *o;
    char llbuf[32];
    uint64_t bitoffset;
    size_t byte, bit;
    size_t bitval = 0;

    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
        return;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;

    byte = bitoffset >> 3;
    bit = 7 - (bitoffset & 0x7);
    if (sdsEncodedObject(o)) {
        if (byte < sdslen(o->ptr))
            bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
    } else {
        if (byte < (size_t)ll2string(llbuf,sizeof(llbuf),(long)o->ptr))
            bitval = llbuf[byte] & (1 << bit);
    }

    addReply(c, bitval ? shared.cone : shared.czero);
}",579.0,603.0,1.0,65.0,25.0,32,15,28,8,0,7,5,6,6,5,,0,6,2,1,1,void
1722,31272,bitopCommand,1,bitopCommand,void bitopCommand (client*),bitops.c,"void bitopCommand(client *c) {
    char *opname = c->argv[1]->ptr;
    robj *o, *targetkey = c->argv[2];
    unsigned long op, j, numkeys;
    robj **objects;      /* Array of source objects. */
    unsigned char **src; /* Array of source strings pointers. */
    unsigned long *len, maxlen = 0; /* Array of length of src strings,
                                       and max len. */
    unsigned long minlen = 0;    /* Min len among the input keys. */
    unsigned char *res = NULL; /* Resulting string. */

    /* Parse the operation name. */
    if ((opname[0] == 'a' || opname[0] == 'A') && !strcasecmp(opname,""and""))
        op = BITOP_AND;
    else if((opname[0] == 'o' || opname[0] == 'O') && !strcasecmp(opname,""or""))
        op = BITOP_OR;
    else if((opname[0] == 'x' || opname[0] == 'X') && !strcasecmp(opname,""xor""))
        op = BITOP_XOR;
    else if((opname[0] == 'n' || opname[0] == 'N') && !strcasecmp(opname,""not""))
        op = BITOP_NOT;
    else {
        addReplyErrorObje...",607.0,793.0,1.0,13.0,187.0,149,24,181,25,0,30,28,54,2,22,,0,17,2,1,1,void
1723,32170,bitcountCommand,1,bitcountCommand,void bitcountCommand (client*),bitops.c,"void bitcountCommand(client *c) {
    robj *o;
    long long start, end;
    long strlen;
    unsigned char *p;
    char llbuf[LONG_STR_SIZE];
    int isbit = 0;
    unsigned char first_byte_neg_mask = 0, last_byte_neg_mask = 0;

    /* Lookup, check for type, and return 0 for non existing keys. */
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;
    p = getObjectReadOnlyString(o,&strlen,llbuf);

    /* Parse start/end range if any. */
    if (c->argc == 4 || c->argc == 5) {
        long long totlen = strlen;
        /* Make sure we will not overflow */
        serverAssert(totlen <= LLONG_MAX >> 3);
        if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
            return;
        if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
            return;
        /* Convert negative indexes */
        if (start < 0 && end < 0 && start > end) {
            addReply(c,shared.czero);
    ...",796.0,874.0,1.0,15.0,79.0,73,24,68,14,0,15,16,29,11,8,,0,12,2,1,1,void
1724,32555,bitposCommand,1,bitposCommand,void bitposCommand (client*),bitops.c,"void bitposCommand(client *c) {
    robj *o;
    long long start, end;
    long bit, strlen;
    unsigned char *p;
    char llbuf[LONG_STR_SIZE];
    int isbit = 0, end_given = 0;
    unsigned char first_byte_neg_mask = 0, last_byte_neg_mask = 0;

    /* Parse the bit argument to understand what we are looking for, set
     * or clear bits. */
    if (getLongFromObjectOrReply(c,c->argv[2],&bit,NULL) != C_OK)
        return;
    if (bit != 0 && bit != 1) {
        addReplyError(c, ""The bit argument must be 1 or 0."");
        return;
    }

    /* If the key does not exist, from our point of view it is an infinite
     * array of 0 bits. If the user is looking for the first clear bit return 0,
     * If the user is looking for the first set bit, return -1. */
    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
        addReplyLongLong(c, bit ? -1 : 0);
        return;
    }
    if (checkType(c,o,OBJ_STRING)) return;
    p = getObjectReadOnlyString(o,&strlen,llbuf);

    /* Parse ...",877.0,1003.0,1.0,15.0,127.0,82,24,73,15,0,21,19,33,16,10,,0,17,2,1,1,void
1725,33129,bitfieldGeneric,1,bitfieldGeneric,"void bitfieldGeneric (client*,int)",bitops.c,"void bitfieldGeneric(client *c, int flags) {
    robj *o;
    uint64_t bitoffset;
    int j, numops = 0, changes = 0, dirty = 0;
    struct bitfieldOp *ops = NULL; /* Array of ops to execute at end. */
    int owtype = BFOVERFLOW_WRAP; /* Overflow type. */
    int readonly = 1;
    uint64_t highest_write_offset = 0;

    for (j = 2; j < c->argc; j++) {
        int remargs = c->argc-j-1; /* Remaining args other than current. */
        char *subcmd = c->argv[j]->ptr; /* Current command name. */
        int opcode; /* Current operation code. */
        long long i64 = 0;  /* Signed SET value. */
        int sign = 0; /* Signed or unsigned type? */
        int bits = 0; /* Bitfield width in bits. */

        if (!strcasecmp(subcmd,""get"") && remargs >= 2)
            opcode = BITFIELDOP_GET;
        else if (!strcasecmp(subcmd,""set"") && remargs >= 3)
            opcode = BITFIELDOP_SET;
        else if (!strcasecmp(subcmd,""incrby"") && remargs >= 3)
            opcode = BITFIELDOP_INCRBY...",1030.0,1259.0,1.0,17.0,230.0,128,21,133,25,2,43,17,39,13,18,,0,33,4,2,2,void
1726,34005,bitfieldCommand,1,bitfieldCommand,void bitfieldCommand (client*),bitops.c,"void bitfieldCommand(client *c) {
    bitfieldGeneric(c, BITFIELD_FLAG_NONE);
}",1261.0,1263.0,1.0,23.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1727,34015,bitfieldroCommand,1,bitfieldroCommand,void bitfieldroCommand (client*),bitops.c,"void bitfieldroCommand(client *c) {
    bitfieldGeneric(c, BITFIELD_FLAG_READONLY);
}",1265.0,1267.0,1.0,23.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
1728,34040,unblockClientWaitingData,1,unblockClientWaitingData,void unblockClientWaitingData (client*),blocked.c,"static void unblockClientWaitingData(client *c) {
    dictEntry *de;
    dictIterator *di;

    if (dictSize(c->bstate.keys) == 0)
        return;

    di = dictGetIterator(c->bstate.keys);
    /* The client may wait for multiple keys, so unblock it for every key. */
    while((de = dictNext(di)) != NULL) {
        releaseBlockedEntry(c, de, 0);
    }
    dictReleaseIterator(di);
    dictEmpty(c->bstate.keys, NULL);
}",419.0,433.0,1.0,8.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1729,34045,handleClientsBlockedOnKey,1,handleClientsBlockedOnKey,void handleClientsBlockedOnKey (readyList*),blocked.c,"static void handleClientsBlockedOnKey(readyList *rl) {

    /* We serve clients in the same order they blocked for
     * this key, from the first blocked to the last. */
    dictEntry *de = dictFind(rl->db->blocking_keys,rl->key);

    if (de) {
        list *clients = dictGetVal(de);
        listNode *ln;
        listIter li;
        listRewind(clients,&li);

        /* Avoid processing more than the initial count so that we're not stuck
         * in an endless loop in case the reprocessing of the command blocks again. */
        long count = listLength(clients);
        while ((ln = listNext(&li)) && count--) {
            client *receiver = listNodeValue(ln);
            robj *o = lookupKeyReadWithFlags(rl->db, rl->key, LOOKUP_NOEFFECTS);
            /* 1. In case new key was added/touched we need to verify it satisfy the
             *    blocked type, since we might process the wrong key type.
             * 2. We want to serve clients blocked on module keys
             *   ...",558.0,594.0,1.0,21.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1730,34069,initClientBlockingState,1,initClientBlockingState,void initClientBlockingState (client*),blocked.c,"void initClientBlockingState(client *c) {
    c->bstate.btype = BLOCKED_NONE;
    c->bstate.timeout = 0;
    c->bstate.keys = dictCreate(&objectKeyHeapPointerValueDictType);
    c->bstate.numreplicas = 0;
    c->bstate.reploffset = 0;
    c->bstate.unblock_on_nokey = 0;
    c->bstate.async_rm_call_handle = NULL;
}",75.0,83.0,1.0,1.0,9.0,22,4,10,4,1,8,1,1,0,1,,0,8,2,1,1,void
1731,34125,blockClient,1,blockClient,"void blockClient (client*,int)",blocked.c,"void blockClient(client *c, int btype) {
    /* Master client should never be blocked unless pause or module */
    serverAssert(!(c->flags & CLIENT_MASTER &&
                   btype != BLOCKED_MODULE &&
                   btype != BLOCKED_POSTPONE));

    c->flags |= CLIENT_BLOCKED;
    c->bstate.btype = btype;
    if (!(c->flags & CLIENT_MODULE)) server.blocked_clients++; /* We count blocked client stats on regular clients and not on module clients */
    server.blocked_clients_by_type[btype]++;
    addClientToTimeoutTable(c);
}",88.0,99.0,1.0,4.0,12.0,26,14,13,5,5,6,2,2,1,2,,0,4,4,2,2,void
1732,34200,updateStatsOnUnblock,1,updateStatsOnUnblock,"void updateStatsOnUnblock (client*,long,long,int)",blocked.c,"void updateStatsOnUnblock(client *c, long blocked_us, long reply_us, int had_errors){
    const ustime_t total_cmd_duration = c->duration + blocked_us + reply_us;
    c->lastcmd->microseconds += total_cmd_duration;
    c->lastcmd->calls++;
    server.stat_numcommands++;
    if (had_errors)
        c->lastcmd->failed_calls++;
    if (server.latency_tracking_enabled)
        updateCommandLatencyHistogram(&(c->lastcmd->latency_histogram), total_cmd_duration*1000);
    /* Log the command into the Slow log if needed. */
    slowlogPushCurrentCommand(c, c->lastcmd, total_cmd_duration);
    c->duration = 0;
    /* Log the reply duration event. */
    latencyAddSampleIfNeeded(""command-unblocking"",reply_us/1000);
}",106.0,120.0,1.0,4.0,15.0,29,11,21,6,5,10,3,3,0,3,,0,7,8,4,4,void
1733,34291,processUnblockedClients,1,processUnblockedClients,void processUnblockedClients (void),blocked.c,"void processUnblockedClients(void) {
    listNode *ln;
    client *c;

    while (listLength(server.unblocked_clients)) {
        ln = listFirst(server.unblocked_clients);
        serverAssert(ln != NULL);
        c = ln->value;
        listDelNode(server.unblocked_clients,ln);
        c->flags &= ~CLIENT_UNBLOCKED;

        if (c->flags & CLIENT_MODULE) {
            if (!(c->flags & CLIENT_BLOCKED)) {
                moduleCallCommandUnblockedHandler(c);
            }
            continue;
        }

        /* Process remaining data in the input buffer, unless the client
         * is blocked again. Actually processInputBuffer() checks that the
         * client is not blocked before to proceed, but things may change and
         * the code is conceptually more correct this way. */
        if (!(c->flags & CLIENT_BLOCKED)) {
            /* If we have a queued command, execute it now. */
            if (processPendingCommandAndInputBuffer(c) == C_ERR) {
                c = NULL;
 ...",125.0,155.0,1.0,11.0,31.0,32,14,20,4,1,10,7,12,4,5,,0,6,2,1,1,void
1734,34410,queueClientForReprocessing,1,queueClientForReprocessing,void queueClientForReprocessing (client*),blocked.c,"void queueClientForReprocessing(client *c) {
    /* The client may already be into the unblocked list because of a previous
     * blocking operation, don't add back it into the list multiple times. */
    if (!(c->flags & CLIENT_UNBLOCKED)) {
        c->flags |= CLIENT_UNBLOCKED;
        listAddNodeTail(server.unblocked_clients,c);
    }
}",173.0,180.0,1.0,21.0,8.0,7,5,4,2,2,3,2,2,1,1,,0,2,2,1,1,void
1735,34441,unblockClient,1,unblockClient,"void unblockClient (client*,int)",blocked.c,"void unblockClient(client *c, int queue_for_reprocessing) {
    if (c->bstate.btype == BLOCKED_LIST ||
        c->bstate.btype == BLOCKED_ZSET ||
        c->bstate.btype == BLOCKED_STREAM) {
        unblockClientWaitingData(c);
    } else if (c->bstate.btype == BLOCKED_WAIT || c->bstate.btype == BLOCKED_WAITAOF) {
        unblockClientWaitingReplicas(c);
    } else if (c->bstate.btype == BLOCKED_MODULE) {
        if (moduleClientIsBlockedOnKeys(c)) unblockClientWaitingData(c);
        unblockClientFromModule(c);
    } else if (c->bstate.btype == BLOCKED_POSTPONE) {
        listDelNode(server.postponed_clients,c->postponed_list_node);
        c->postponed_list_node = NULL;
    } else if (c->bstate.btype == BLOCKED_SHUTDOWN) {
        /* No special cleanup. */
    } else {
        serverPanic(""Unknown btype in unblockClient()."");
    }

    /* Reset the client for a new query, unless the client has pending command to process
     * or in case a shutdown operation was canceled and we a...",184.0,224.0,1.0,8.0,41.0,39,13,24,8,9,16,5,5,6,6,,0,10,4,2,2,void
1736,34641,replyToBlockedClientTimedOut,1,replyToBlockedClientTimedOut,void replyToBlockedClientTimedOut (client*),blocked.c,"void replyToBlockedClientTimedOut(client *c) {
    if (c->bstate.btype == BLOCKED_LIST ||
        c->bstate.btype == BLOCKED_ZSET ||
        c->bstate.btype == BLOCKED_STREAM) {
        addReplyNullArray(c);
        updateStatsOnUnblock(c, 0, 0, 0);
    } else if (c->bstate.btype == BLOCKED_WAIT) {
        addReplyLongLong(c,replicationCountAcksByOffset(c->bstate.reploffset));
    } else if (c->bstate.btype == BLOCKED_WAITAOF) {
        addReplyArrayLen(c,2);
        addReplyLongLong(c,server.fsynced_reploff >= c->bstate.reploffset);
        addReplyLongLong(c,replicationCountAOFAcksByOffset(c->bstate.reploffset));
    } else if (c->bstate.btype == BLOCKED_MODULE) {
        moduleBlockedClientTimedOut(c);
    } else {
        serverPanic(""Unknown btype in replyToBlockedClientTimedOut()."");
    }
}",229.0,246.0,1.0,8.0,18.0,11,4,8,4,1,5,2,2,3,2,,0,3,2,1,1,void
1737,34753,replyToClientsBlockedOnShutdown,1,replyToClientsBlockedOnShutdown,void replyToClientsBlockedOnShutdown (void),blocked.c,"void replyToClientsBlockedOnShutdown(void) {
    if (server.blocked_clients_by_type[BLOCKED_SHUTDOWN] == 0) return;
    listNode *ln;
    listIter li;
    listRewind(server.clients, &li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        if (c->flags & CLIENT_BLOCKED && c->bstate.btype == BLOCKED_SHUTDOWN) {
            addReplyError(c, ""Errors trying to SHUTDOWN. Check logs."");
            unblockClient(c, 1);
        }
    }
}",250.0,262.0,1.0,20.0,13.0,16,9,14,5,1,7,4,5,3,4,,0,4,2,1,1,void
1738,34817,disconnectAllBlockedClients,1,disconnectAllBlockedClients,void disconnectAllBlockedClients (void),blocked.c,"void disconnectAllBlockedClients(void) {
    listNode *ln;
    listIter li;

    listRewind(server.clients,&li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);

        if (c->flags & CLIENT_BLOCKED) {
            /* POSTPONEd clients are an exception, when they'll be unblocked, the
             * command processing will start from scratch, and the command will
             * be either executed or rejected. (unlike LIST blocked clients for
             * which the command is already in progress in a way. */
            if (c->bstate.btype == BLOCKED_POSTPONE)
                continue;

            unblockClientOnError(c,
                ""-UNBLOCKED force unblock from blocking operation, ""
                ""instance state changed (master -> replica?)"");
            c->flags |= CLIENT_CLOSE_AFTER_REPLY;
        }
    }
}",271.0,293.0,1.0,20.0,23.0,14,7,12,5,1,7,5,7,3,3,,0,5,2,1,1,void
1739,34879,handleClientsBlockedOnKeys,1,handleClientsBlockedOnKeys,void handleClientsBlockedOnKeys (void),blocked.c,"void handleClientsBlockedOnKeys(void) {

    /* In case we are already in the process of unblocking clients we should
     * not make a recursive call, in order to prevent breaking fairness. */
    static int in_handling_blocked_clients = 0;
    if (in_handling_blocked_clients)
        return;
    in_handling_blocked_clients = 1;

    /* This function is called only when also_propagate is in its basic state
     * (i.e. not from call(), module context, etc.) */
    serverAssert(server.also_propagate.numops == 0);

    /* If a command being unblocked causes another command to get unblocked,
     * like a BLMOVE would do, then the new unblocked command will get processed
     * right away rather than wait for later. */
    while(listLength(server.ready_keys) != 0) {
        list *l;

        /* Point server.ready_keys to a fresh list and save the current one
         * locally. This way as we run the old list we are free to call
         * signalKeyAsReady() that may push new elements...",315.0,359.0,1.0,4.0,45.0,28,9,25,5,1,14,4,5,1,8,,0,7,2,1,1,void
1740,34990,blockForKeys,1,blockForKeys,"void blockForKeys (client*,int,robj**,int,mstime_t,int)",blocked.c,"void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, int unblock_on_nokey) {
    dictEntry *db_blocked_entry, *db_blocked_existing_entry, *client_blocked_entry;
    list *l;
    int j;

    c->bstate.timeout = timeout;
    for (j = 0; j < numkeys; j++) {
        /* If the key already exists in the dictionary ignore it. */
        if (!(client_blocked_entry = dictAddRaw(c->bstate.keys,keys[j],NULL))) {
            continue;
        }
        incrRefCount(keys[j]);

        /* And in the other ""side"", to map keys -> clients */
        db_blocked_entry = dictAddRaw(c->db->blocking_keys,keys[j], &db_blocked_existing_entry);

        /* In case key[j] did not have blocking clients yet, we need to create a new list */
        if (db_blocked_entry != NULL) {
            l = listCreate();
            dictSetVal(c->db->blocking_keys, db_blocked_entry, l);
            incrRefCount(keys[j]);
        } else {
            l = dictGetVal(db_blocked_existing_entry);
...",368.0,415.0,1.0,55.0,48.0,36,9,48,13,2,21,8,12,2,12,,0,13,12,6,6,void
1741,35220,getBlockedTypeByType,1,getBlockedTypeByType,blocking_type getBlockedTypeByType (int),blocked.c,"static blocking_type getBlockedTypeByType(int type) {
    switch (type) {
        case OBJ_LIST: return BLOCKED_LIST;
        case OBJ_ZSET: return BLOCKED_ZSET;
        case OBJ_MODULE: return BLOCKED_MODULE;
        case OBJ_STREAM: return BLOCKED_STREAM;
        default: return BLOCKED_NONE;
    }
}",435.0,443.0,1.0,13.0,9.0,0,0,6,6,1,0,2,2,0,0,,0,0,2,1,1,blocking_type
1742,35255,signalKeyAsReadyLogic,1,signalKeyAsReadyLogic,"void signalKeyAsReadyLogic (redisDb*,robj*,int,int)",blocked.c,"static void signalKeyAsReadyLogic(redisDb *db, robj *key, int type, int deleted) {
    readyList *rl;

    /* Quick returns. */
    int btype = getBlockedTypeByType(type);
    if (btype == BLOCKED_NONE) {
        /* The type can never block. */
        return;
    }
    if (!server.blocked_clients_by_type[btype] &&
        !server.blocked_clients_by_type[BLOCKED_MODULE]) {
        /* No clients block on this type. Note: Blocked modules are represented
         * by BLOCKED_MODULE, even if the intention is to wake up by normal
         * types (list, zset, stream), so we need to check that there are no
         * blocked modules before we do a quick return here. */
        return;
    }

    if (deleted) {
        /* Key deleted and no clients blocking for this key? No need to queue it. */
        if (dictFind(db->blocking_keys_unblock_on_nokey,key) == NULL)
            return;
        /* Note: if we made it here it means the key is also present in db->blocking_keys */
    } else {
 ...",452.0,499.0,1.0,1.0,48.0,22,10,27,12,2,11,6,7,2,7,,0,8,8,4,4,void
1743,35495,signalKeyAsReady,1,signalKeyAsReady,"void signalKeyAsReady (redisDb*,robj*,int)",blocked.c,"void signalKeyAsReady(redisDb *db, robj *key, int type) {
    signalKeyAsReadyLogic(db, key, type, 0);
}",547.0,549.0,1.0,1.0,3.0,0,0,3,3,4,1,1,1,0,1,,0,0,6,3,3,void
1744,35507,signalDeletedKeyAsReady,1,signalDeletedKeyAsReady,"void signalDeletedKeyAsReady (redisDb*,robj*,int)",blocked.c,"void signalDeletedKeyAsReady(redisDb *db, robj *key, int type) {
    signalKeyAsReadyLogic(db, key, type, 1);
}",551.0,553.0,1.0,1.0,3.0,0,0,3,3,2,1,1,1,0,1,,0,0,6,3,3,void
1745,35660,blockForReplication,1,blockForReplication,"void blockForReplication (client*,mstime_t,long long,long)",blocked.c,"void blockForReplication(client *c, mstime_t timeout, long long offset, long numreplicas) {
    c->bstate.timeout = timeout;
    c->bstate.reploffset = offset;
    c->bstate.numreplicas = numreplicas;
    listAddNodeHead(server.clients_waiting_acks,c);
    blockClient(c,BLOCKED_WAIT);
}",597.0,603.0,1.0,1.0,7.0,10,3,10,6,1,5,1,1,0,2,,0,3,8,4,4,void
1746,35697,blockForAofFsync,1,blockForAofFsync,"void blockForAofFsync (client*,mstime_t,long long,int,long)",blocked.c,"void blockForAofFsync(client *c, mstime_t timeout, long long offset, int numlocal, long numreplicas) {
    c->bstate.timeout = timeout;
    c->bstate.reploffset = offset;
    c->bstate.numreplicas = numreplicas;
    c->bstate.numlocal = numlocal;
    listAddNodeHead(server.clients_waiting_acks,c);
    blockClient(c,BLOCKED_WAITAOF);
}",606.0,613.0,1.0,1.0,8.0,13,3,12,7,1,6,1,1,0,2,,0,4,10,5,5,void
1747,35742,blockPostponeClient,1,blockPostponeClient,void blockPostponeClient (client*),blocked.c,"void blockPostponeClient(client *c) {
    c->bstate.timeout = 0;
    blockClient(c,BLOCKED_POSTPONE);
    listAddNodeTail(server.postponed_clients, c);
    c->postponed_list_node = listLast(server.postponed_clients);
    /* Mark this client to execute its command */
    c->flags |= CLIENT_PENDING_COMMAND;
}",618.0,625.0,1.0,29.0,8.0,11,4,9,3,2,5,1,1,0,2,,0,3,2,1,1,void
1748,35785,blockClientShutdown,1,blockClientShutdown,void blockClientShutdown (client*),blocked.c,"void blockClientShutdown(client *c) {
    blockClient(c, BLOCKED_SHUTDOWN);
}",628.0,630.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
1749,35977,unblockClientOnTimeout,1,unblockClientOnTimeout,void unblockClientOnTimeout (client*),blocked.c,"void unblockClientOnTimeout(client *c) {
    replyToBlockedClientTimedOut(c);
    if (c->flags & CLIENT_PENDING_COMMAND)
        c->flags &= ~CLIENT_PENDING_COMMAND;
    unblockClient(c, 1);
}",705.0,710.0,1.0,19.0,6.0,6,4,4,1,1,4,2,2,1,2,,0,2,2,1,1,void
1750,36008,unblockClientOnError,1,unblockClientOnError,"void unblockClientOnError (client*,char*)",blocked.c,"void unblockClientOnError(client *c, const char *err_str) {
    if (err_str)
        addReplyError(c, err_str);
    updateStatsOnUnblock(c, 0, 0, 1);
    if (c->flags & CLIENT_PENDING_COMMAND)
        c->flags &= ~CLIENT_PENDING_COMMAND;
    unblockClient(c, 1);
}",714.0,721.0,1.0,19.0,8.0,6,4,7,2,1,5,3,3,1,3,,0,2,4,2,2,void
1751,36049,totalNumberOfBlockingKeys,1,totalNumberOfBlockingKeys,"void totalNumberOfBlockingKeys (long unsigned*,long unsigned*)",blocked.c,"void totalNumberOfBlockingKeys(unsigned long *blocking_keys, unsigned long *bloking_keys_on_nokey) {
    unsigned long bkeys=0, bkeys_on_nokey=0;
    for (int j = 0; j < server.dbnum; j++) {
        bkeys += dictSize(server.db[j].blocking_keys);
        bkeys_on_nokey += dictSize(server.db[j].blocking_keys_unblock_on_nokey);
    }
    if (blocking_keys)
        *blocking_keys = bkeys;
    if (bloking_keys_on_nokey)
        *bloking_keys_on_nokey = bkeys_on_nokey;
}",726.0,736.0,1.0,17.0,11.0,39,8,25,6,1,0,4,4,0,0,,0,0,4,2,2,void
1752,36159,blockedBeforeSleep,1,blockedBeforeSleep,void blockedBeforeSleep (void),blocked.c,"void blockedBeforeSleep(void) {
    /* Handle precise timeouts of blocked clients. */
    handleBlockedClientsTimeout();

    /* Unblock all the clients blocked for synchronous replication
     * in WAIT or WAITAOF. */
    if (listLength(server.clients_waiting_acks))
        processClientsWaitingReplicas();

    /* Try to process blocked clients every once in while.
     *
     * Example: A module calls RM_SignalKeyAsReady from within a timer callback
     * (So we don't visit processCommand() at all).
     *
     * This may unblock clients, so must be done before processUnblockedClients */
    handleClientsBlockedOnKeys();

    /* Check if there are clients unblocked by modules that implement
     * blocking commands. */
    if (moduleCount())
        moduleHandleBlockedClients();

    /* Try to process pending commands for clients that were just unblocked. */
    if (listLength(server.unblocked_clients))
        processUnblockedClients();
}",738.0,763.0,1.0,8.0,26.0,6,2,4,1,1,6,4,4,1,6,,0,1,2,1,1,void
1753,36227,callReplySetSharedData,1,callReplySetSharedData,"void callReplySetSharedData (CallReply*,int,char*,size_t,int)",call_reply.c,"static void callReplySetSharedData(CallReply *rep, int type, const char *proto, size_t proto_len, int extra_flags) {
    rep->type = type;
    rep->proto = proto;
    rep->proto_len = proto_len;
    rep->flags |= extra_flags;
}",67.0,72.0,1.0,1.0,6.0,7,2,8,5,11,4,1,1,0,0,,0,4,10,5,5,void
1754,36256,callReplyNull,1,callReplyNull,"void callReplyNull (void*,char*,size_t)",call_reply.c,"static void callReplyNull(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, REPLY_FLAG_RESP3);
}",74.0,77.0,1.0,32.0,4.0,2,2,5,4,0,1,1,1,0,1,,0,0,6,3,3,void
1755,36279,callReplyNullBulkString,1,callReplyNullBulkString,"void callReplyNullBulkString (void*,char*,size_t)",call_reply.c,"static void callReplyNullBulkString(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, 0);
}",79.0,82.0,1.0,32.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,6,3,3,void
1756,36298,callReplyNullArray,1,callReplyNullArray,"void callReplyNullArray (void*,char*,size_t)",call_reply.c,"static void callReplyNullArray(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, 0);
}",84.0,87.0,1.0,32.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,6,3,3,void
1757,36317,callReplyBulkString,1,callReplyBulkString,"void callReplyBulkString (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyBulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_STRING, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",89.0,94.0,1.0,32.0,6.0,6,3,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
1758,36350,callReplyError,1,callReplyError,"void callReplyError (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyError(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_ERROR, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",96.0,101.0,1.0,32.0,6.0,6,3,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
1759,36383,callReplySimpleStr,1,callReplySimpleStr,"void callReplySimpleStr (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplySimpleStr(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_STRING, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",103.0,108.0,1.0,32.0,6.0,6,3,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
1760,36416,callReplyLong,1,callReplyLong,"void callReplyLong (void*,long long,char*,size_t)",call_reply.c,"static void callReplyLong(void *ctx, long long val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_INTEGER, proto, proto_len, 0);
    rep->val.ll = val;
}",110.0,114.0,1.0,32.0,5.0,4,3,7,5,0,1,1,1,0,1,,0,0,8,4,4,void
1761,36443,callReplyDouble,1,callReplyDouble,"void callReplyDouble (void*,double,char*,size_t)",call_reply.c,"static void callReplyDouble(void *ctx, double val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_DOUBLE, proto, proto_len, REPLY_FLAG_RESP3);
    rep->val.d = val;
}",116.0,120.0,1.0,32.0,5.0,5,4,7,5,0,1,1,1,0,1,,0,0,8,4,4,void
1762,36474,callReplyVerbatimString,1,callReplyVerbatimString,"void callReplyVerbatimString (void*,char*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyVerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_VERBATIM_STRING, proto, proto_len, REPLY_FLAG_RESP3);
    rep->len = len;
    rep->val.verbatim_str.str = str;
    rep->val.verbatim_str.format = format;
}",122.0,128.0,1.0,32.0,7.0,12,4,11,7,0,2,1,1,0,1,,0,1,12,6,6,void
1763,36523,callReplyBigNumber,1,callReplyBigNumber,"void callReplyBigNumber (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyBigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_BIG_NUMBER, proto, proto_len, REPLY_FLAG_RESP3);
    rep->len = len;
    rep->val.str = str;
}",130.0,135.0,1.0,32.0,6.0,7,4,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
1764,36560,callReplyBool,1,callReplyBool,"void callReplyBool (void*,int,char*,size_t)",call_reply.c,"static void callReplyBool(void *ctx, int val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_BOOL, proto, proto_len, REPLY_FLAG_RESP3);
    rep->val.ll = val;
}",137.0,141.0,1.0,32.0,5.0,5,4,7,5,0,1,1,1,0,1,,0,0,8,4,4,void
1765,36591,callReplyParseCollection,1,callReplyParseCollection,"void callReplyParseCollection (ReplyParser*,CallReply*,size_t,char*,size_t)",call_reply.c,"static void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t len, const char *proto, size_t elements_per_entry) {
    rep->len = len;
    rep->val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));
    for (size_t i = 0; i < len * elements_per_entry; i += elements_per_entry) {
        for (size_t j = 0 ; j < elements_per_entry ; ++j) {
            rep->val.array[i + j].private_data = rep->private_data;
            parseReply(parser, rep->val.array + i + j);
            rep->val.array[i + j].flags |= REPLY_FLAG_PARSED;
            if (rep->val.array[i + j].flags & REPLY_FLAG_RESP3) {
                /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */
                rep->flags |= REPLY_FLAG_RESP3;
            }
        }
    }
    rep->proto = proto;
    rep->proto_len = parser->curr_location - proto;
}",143.0,159.0,1.0,43.0,17.0,45,11,33,8,4,8,4,7,0,2,,0,7,10,5,5,void
1766,36730,callReplyAttribute,1,callReplyAttribute,"void callReplyAttribute (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplyAttribute(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->attribute = zcalloc(sizeof(CallReply));

    /* Continue parsing the attribute reply */
    rep->attribute->len = len;
    rep->attribute->type = REDISMODULE_REPLY_ATTRIBUTE;
    callReplyParseCollection(parser, rep->attribute, len, proto, 2);
    rep->attribute->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_RESP3;
    rep->attribute->private_data = rep->private_data;

    /* Continue parsing the reply */
    parseReply(parser, rep);

    /* In this case we need to fix the proto address and len, it should start from the attribute */
    rep->proto = proto;
    rep->proto_len = parser->curr_location - proto;
    rep->flags |= REPLY_FLAG_RESP3;
}",161.0,179.0,1.0,27.0,19.0,28,6,22,6,0,14,1,1,0,3,,0,12,8,4,4,void
1767,36825,callReplyArray,1,callReplyArray,"void callReplyArray (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplyArray(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_ARRAY;
    callReplyParseCollection(parser, rep, len, proto, 1);
}",181.0,185.0,1.0,16.0,5.0,3,2,7,5,0,2,1,1,0,1,,0,1,8,4,4,void
1768,36850,callReplySet,1,callReplySet,"void callReplySet (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplySet(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_SET;
    callReplyParseCollection(parser, rep, len, proto, 1);
    rep->flags |= REPLY_FLAG_RESP3;
}",187.0,192.0,1.0,16.0,6.0,5,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
1769,36884,callReplyMap,1,callReplyMap,"void callReplyMap (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplyMap(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_MAP;
    callReplyParseCollection(parser, rep, len, proto, 2);
    rep->flags |= REPLY_FLAG_RESP3;
}",194.0,199.0,1.0,16.0,6.0,5,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
1770,36918,callReplyParseError,1,callReplyParseError,void callReplyParseError (void*),call_reply.c,"static void callReplyParseError(void *ctx) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_UNKNOWN;
}",201.0,204.0,1.0,16.0,4.0,4,3,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
1771,36935,freeCallReplyInternal,1,freeCallReplyInternal,void freeCallReplyInternal (CallReply*),call_reply.c,"static void freeCallReplyInternal(CallReply *rep) {
    if (rep->type == REDISMODULE_REPLY_ARRAY || rep->type == REDISMODULE_REPLY_SET) {
        for (size_t i = 0 ; i < rep->len ; ++i) {
            freeCallReplyInternal(rep->val.array + i);
        }
        zfree(rep->val.array);
    }

    if (rep->type == REDISMODULE_REPLY_MAP || rep->type == REDISMODULE_REPLY_ATTRIBUTE) {
        for (size_t i = 0 ; i < rep->len ; ++i) {
            freeCallReplyInternal(rep->val.array + i * 2);
            freeCallReplyInternal(rep->val.array + i * 2 + 1);
        }
        zfree(rep->val.array);
    }

    if (rep->attribute) {
        freeCallReplyInternal(rep->attribute);
        zfree(rep->attribute);
    }
}",207.0,227.0,1.0,21.0,21.0,35,8,21,2,1,12,6,8,7,3,,0,9,2,1,1,void
1772,37057,freeCallReply,1,freeCallReply,void freeCallReply (CallReply*),call_reply.c,"void freeCallReply(CallReply *rep) {
    if (!(rep->flags & REPLY_FLAG_ROOT)) {
        return;
    }
    if (rep->flags & REPLY_FLAG_PARSED) {
        if (rep->type == REDISMODULE_REPLY_PROMISE) {
            zfree(rep);
            return;
        }
        freeCallReplyInternal(rep);
    }
    sdsfree(rep->original_proto);
    if (rep->deferred_error_list)
        listRelease(rep->deferred_error_list);
    zfree(rep);
}",232.0,247.0,1.0,23.0,16.0,12,5,9,1,0,11,5,6,4,5,,0,6,2,1,1,void
1773,37115,callReplyCreatePromise,1,callReplyCreatePromise,CallReply callReplyCreatePromise (void*),call_reply.c,"CallReply *callReplyCreatePromise(void *private_data) {
    CallReply *res = zmalloc(sizeof(*res));
    res->type = REDISMODULE_REPLY_PROMISE;
    /* Mark the reply as parsed so there will be not attempt to parse
     * it when calling reply API such as freeCallReply.
     * Also mark the reply as root so freeCallReply will not ignore it. */
    res->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_ROOT;
    res->private_data = private_data;
    return res;
}",249.0,258.0,1.0,16.0,10.0,11,6,7,2,1,4,1,1,0,1,,0,4,2,1,1,CallReply
1774,37224,callReplyParse,1,callReplyParse,void callReplyParse (CallReply*),call_reply.c,"static void callReplyParse(CallReply *rep) {
    if (rep->flags & REPLY_FLAG_PARSED) {
        return;
    }

    ReplyParser parser = {.curr_location = rep->proto, .callbacks = DefaultParserCallbacks};

    parseReply(&parser, rep);
    rep->flags |= REPLY_FLAG_PARSED;
}",281.0,290.0,1.0,21.0,10.0,11,6,9,5,11,5,2,2,1,1,,0,4,2,1,1,void
1775,37268,callReplyType,1,callReplyType,int callReplyType (CallReply*),call_reply.c,"int callReplyType(CallReply *rep) {
    if (!rep) return REDISMODULE_REPLY_UNKNOWN;
    callReplyParse(rep);
    return rep->type;
}",293.0,297.0,1.0,21.0,5.0,3,3,3,1,2,2,2,2,0,1,,0,1,2,1,1,int
1776,37288,callReplyGetString,1,callReplyGetString,"const char* callReplyGetString (CallReply*,size_t*)",call_reply.c,"const char *callReplyGetString(CallReply *rep, size_t *len) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_STRING &&
        rep->type != REDISMODULE_REPLY_ERROR) return NULL;
    if (len) *len = rep->len;
    return rep->val.str;
}",309.0,315.0,1.0,21.0,7.0,10,6,8,3,2,4,3,3,2,1,,0,3,4,2,2,const char*
1777,37330,callReplyGetLongLong,1,callReplyGetLongLong,long long callReplyGetLongLong (CallReply*),call_reply.c,"long long callReplyGetLongLong(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;
    return rep->val.ll;
}",320.0,324.0,1.0,21.0,5.0,4,3,4,2,2,2,2,2,1,1,,0,1,2,1,1,long long
1778,37354,callReplyGetDouble,1,callReplyGetDouble,double callReplyGetDouble (CallReply*),call_reply.c,"double callReplyGetDouble(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_DOUBLE) return LLONG_MIN;
    return rep->val.d;
}",329.0,333.0,1.0,21.0,5.0,4,3,4,2,1,2,2,2,1,1,,0,1,2,1,1,double
1779,37378,callReplyGetBool,1,callReplyGetBool,int callReplyGetBool (CallReply*),call_reply.c,"int callReplyGetBool(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_BOOL) return INT_MIN;
    return rep->val.ll;
}",338.0,342.0,1.0,21.0,5.0,4,3,4,2,1,2,2,2,1,1,,0,1,2,1,1,int
1780,37402,callReplyGetLen,1,callReplyGetLen,size_t callReplyGetLen (CallReply*),call_reply.c,"size_t callReplyGetLen(CallReply *rep) {
    callReplyParse(rep);
    switch(rep->type) {
        case REDISMODULE_REPLY_STRING:
        case REDISMODULE_REPLY_ERROR:
        case REDISMODULE_REPLY_ARRAY:
        case REDISMODULE_REPLY_SET:
        case REDISMODULE_REPLY_MAP:
        case REDISMODULE_REPLY_ATTRIBUTE:
            return rep->len;
        default:
            return 0;
    }
}",352.0,365.0,1.0,13.0,14.0,2,1,3,1,1,3,2,2,1,1,,0,2,2,1,1,size_t
1781,37445,callReplyGetCollectionElement,1,callReplyGetCollectionElement,"CallReply callReplyGetCollectionElement (CallReply*,size_t,int)",call_reply.c,"static CallReply *callReplyGetCollectionElement(CallReply *rep, size_t idx, int elements_per_entry) {
    if (idx >= rep->len * elements_per_entry) return NULL; // real len is rep->len * elements_per_entry
    return rep->val.array+idx;
}",367.0,370.0,1.0,1.0,4.0,6,5,6,4,4,1,2,2,1,0,,0,1,6,3,3,CallReply
1782,37471,callReplyGetArrayElement,1,callReplyGetArrayElement,"CallReply callReplyGetArrayElement (CallReply*,size_t)",call_reply.c,"CallReply *callReplyGetArrayElement(CallReply *rep, size_t idx) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_ARRAY) return NULL;
    return callReplyGetCollectionElement(rep, idx, 1);
}",378.0,382.0,1.0,21.0,5.0,2,2,5,3,1,3,2,2,1,2,,0,1,4,2,2,CallReply
1783,37495,callReplyGetSetElement,1,callReplyGetSetElement,"CallReply callReplyGetSetElement (CallReply*,size_t)",call_reply.c,"CallReply *callReplyGetSetElement(CallReply *rep, size_t idx) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_SET) return NULL;
    return callReplyGetCollectionElement(rep, idx, 1);
}",390.0,394.0,1.0,21.0,5.0,2,2,5,3,1,3,2,2,1,2,,0,1,4,2,2,CallReply
1784,37519,callReplyGetMapElementInternal,1,callReplyGetMapElementInternal,"int callReplyGetMapElementInternal (CallReply*,size_t,CallReply**,CallReply**,int)",call_reply.c,"static int callReplyGetMapElementInternal(CallReply *rep, size_t idx, CallReply **key, CallReply **val, int type) {
    callReplyParse(rep);
    if (rep->type != type) return C_ERR;
    if (idx >= rep->len) return C_ERR;
    if (key) *key = callReplyGetCollectionElement(rep, idx * 2, 2);
    if (val) *val = callReplyGetCollectionElement(rep, idx * 2 + 1, 2);
    return C_OK;
}",396.0,403.0,1.0,34.0,8.0,13,8,13,5,2,5,5,5,2,3,,0,4,10,5,5,int
1785,37584,callReplyGetMapElement,1,callReplyGetMapElement,"int callReplyGetMapElement (CallReply*,size_t,CallReply**,CallReply**)",call_reply.c,"int callReplyGetMapElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val) {
    return callReplyGetMapElementInternal(rep, idx, key, val, REDISMODULE_REPLY_MAP);
}",417.0,419.0,1.0,62.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
1786,37601,callReplyGetAttribute,1,callReplyGetAttribute,CallReply callReplyGetAttribute (CallReply*),call_reply.c,"CallReply *callReplyGetAttribute(CallReply *rep) {
    return rep->attribute;
}",426.0,428.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,CallReply
1787,37610,callReplyGetAttributeElement,1,callReplyGetAttributeElement,"int callReplyGetAttributeElement (CallReply*,size_t,CallReply**,CallReply**)",call_reply.c,"int callReplyGetAttributeElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val) {
    return callReplyGetMapElementInternal(rep, idx, key, val, REDISMODULE_REPLY_MAP);
}",442.0,444.0,1.0,62.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
1788,37627,callReplyGetBigNumber,1,callReplyGetBigNumber,"const char* callReplyGetBigNumber (CallReply*,size_t*)",call_reply.c,"const char *callReplyGetBigNumber(CallReply *rep, size_t *len) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_BIG_NUMBER) return NULL;
    *len = rep->len;
    return rep->val.str;
}",458.0,463.0,1.0,21.0,6.0,7,5,6,3,1,3,2,2,1,1,,0,2,4,2,2,const char*
1789,37658,callReplyGetVerbatim,1,callReplyGetVerbatim,"const char* callReplyGetVerbatim (CallReply*,size_t*,char**)",call_reply.c,"const char *callReplyGetVerbatim(CallReply *rep, size_t *len, const char **format){
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_VERBATIM_STRING) return NULL;
    *len = rep->len;
    if (format) *format = rep->val.verbatim_str.format;
    return rep->val.verbatim_str.str;
}",479.0,485.0,1.0,21.0,7.0,13,5,9,4,1,3,3,3,1,1,,0,2,6,3,3,const char*
1790,37705,callReplyGetProto,1,callReplyGetProto,"const char* callReplyGetProto (CallReply*,size_t*)",call_reply.c,"const char *callReplyGetProto(CallReply *rep, size_t *proto_len) {
    *proto_len = rep->proto_len;
    return rep->proto;
}",492.0,495.0,1.0,1.0,4.0,4,3,3,2,2,2,1,1,0,0,,0,2,4,2,2,const char*
1791,37721,callReplyGetPrivateData,1,callReplyGetPrivateData,void* callReplyGetPrivateData (CallReply*),call_reply.c,"void *callReplyGetPrivateData(CallReply *rep) {
    return rep->private_data;
}",499.0,501.0,1.0,1.0,3.0,1,1,1,1,3,1,1,1,0,0,,0,1,2,1,1,void*
1792,37730,callReplyIsResp3,1,callReplyIsResp3,int callReplyIsResp3 (CallReply*),call_reply.c,"int callReplyIsResp3(CallReply *rep) {
    return rep->flags & REPLY_FLAG_RESP3;
}",504.0,506.0,1.0,24.0,3.0,3,3,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
1793,37745,callReplyDeferredErrorList,1,callReplyDeferredErrorList,list callReplyDeferredErrorList (CallReply*),call_reply.c,"list *callReplyDeferredErrorList(CallReply *rep) {
    return rep->deferred_error_list;
}",509.0,511.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,list
1794,37754,callReplyCreate,1,callReplyCreate,"CallReply callReplyCreate (sds,list*,void*)",call_reply.c,"CallReply *callReplyCreate(sds reply, list *deferred_error_list, void *private_data) {
    CallReply *res = zmalloc(sizeof(*res));
    res->flags = REPLY_FLAG_ROOT;
    res->original_proto = reply;
    res->proto = reply;
    res->proto_len = sdslen(reply);
    res->private_data = private_data;
    res->attribute = NULL;
    res->deferred_error_list = deferred_error_list;
    return res;
}",532.0,542.0,1.0,17.0,11.0,18,5,16,5,2,9,1,1,0,2,,0,9,6,3,3,CallReply
1795,37810,callReplyCreateError,1,callReplyCreateError,"CallReply callReplyCreateError (sds,void*)",call_reply.c,"CallReply *callReplyCreateError(sds reply, void *private_data) {
    sds err_buff = reply;
    if (err_buff[0] != '-') {
        err_buff = sdscatfmt(sdsempty(), ""-ERR %S\r\n"", reply);
        sdsfree(reply);
    }
    list *deferred_error_list = listCreate();
    listSetFreeMethod(deferred_error_list, (void (*)(void*))sdsfree);
    listAddNodeTail(deferred_error_list, sdsnew(err_buff));
    return callReplyCreate(err_buff, deferred_error_list, private_data);
}",550.0,560.0,1.0,4.0,11.0,8,5,15,5,12,7,2,2,0,7,,0,4,4,2,2,CallReply
1796,38013,openChildInfoPipe,1,openChildInfoPipe,void openChildInfoPipe (void),childinfo.c,"void openChildInfoPipe(void) {
    if (anetPipe(server.child_info_pipe, O_NONBLOCK, 0) == -1) {
        /* On error our two file descriptors should be still set to -1,
         * but we call anyway closeChildInfoPipe() since can't hurt. */
        closeChildInfoPipe();
    } else {
        server.child_info_nread = 0;
    }
}",45.0,53.0,1.0,1.0,9.0,3,3,2,2,1,2,2,2,1,2,,0,1,2,1,1,void
1797,38037,closeChildInfoPipe,1,closeChildInfoPipe,void closeChildInfoPipe (void),childinfo.c,"void closeChildInfoPipe(void) {
    if (server.child_info_pipe[0] != -1 ||
        server.child_info_pipe[1] != -1)
    {
        close(server.child_info_pipe[0]);
        close(server.child_info_pipe[1]);
        server.child_info_pipe[0] = -1;
        server.child_info_pipe[1] = -1;
        server.child_info_nread = 0;
    }
}",56.0,66.0,1.0,1.0,11.0,23,6,7,1,2,0,2,2,0,0,,0,0,2,1,1,void
1798,38094,sendChildInfoGeneric,1,sendChildInfoGeneric,"void sendChildInfoGeneric (childInfoType,size_t,double,char*)",childinfo.c,"void sendChildInfoGeneric(childInfoType info_type, size_t keys, double progress, char *pname) {
    if (server.child_info_pipe[1] == -1) return;

    static monotime cow_updated = 0;
    static uint64_t cow_update_cost = 0;
    static size_t cow = 0;
    static size_t peak_cow = 0;
    static size_t update_count = 0;
    static unsigned long long sum_cow = 0;

    child_info_data data = {0}; /* zero everything, including padding to satisfy valgrind */

    /* When called to report current info, we need to throttle down CoW updates as they
     * can be very expensive. To do that, we measure the time it takes to get a reading
     * and schedule the next reading to happen not before time*CHILD_COW_COST_FACTOR
     * passes. */

    monotime now = getMonotonicUs();
    if (info_type != CHILD_INFO_TYPE_CURRENT_INFO ||
        !cow_updated ||
        now - cow_updated > cow_update_cost * CHILD_COW_DUTY_CYCLE)
    {
        cow = zmalloc_get_private_dirty(-1);
        cow_updated = getMo...",69.0,119.0,1.0,46.0,51.0,60,21,58,17,3,11,6,8,0,6,,0,8,8,4,4,void
1799,38302,updateChildInfo,1,updateChildInfo,"void updateChildInfo (childInfoType,size_t,monotime,size_t,double)",childinfo.c,"void updateChildInfo(childInfoType information_type, size_t cow, monotime cow_updated, size_t keys, double progress) {
    if (cow > server.stat_current_cow_peak) server.stat_current_cow_peak = cow;

    if (information_type == CHILD_INFO_TYPE_CURRENT_INFO) {
        server.stat_current_cow_bytes = cow;
        server.stat_current_cow_updated = cow_updated;
        server.stat_current_save_keys_processed = keys;
        if (progress != -1) server.stat_module_progress = progress;
    } else if (information_type == CHILD_INFO_TYPE_AOF_COW_SIZE) {
        server.stat_aof_cow_bytes = server.stat_current_cow_peak;
    } else if (information_type == CHILD_INFO_TYPE_RDB_COW_SIZE) {
        server.stat_rdb_cow_bytes = server.stat_current_cow_peak;
    } else if (information_type == CHILD_INFO_TYPE_MODULE_COW_SIZE) {
        server.stat_module_cow_bytes = server.stat_current_cow_peak;
    }
}",122.0,137.0,1.0,1.0,16.0,15,6,15,7,1,0,4,5,0,0,,0,0,10,5,5,void
1800,38396,readChildInfo,1,readChildInfo,"int readChildInfo (childInfoType*,size_t*,monotime*,size_t*,double*)",childinfo.c,"int readChildInfo(childInfoType *information_type, size_t *cow, monotime *cow_updated, size_t *keys, double* progress) {
    /* We are using here a static buffer in combination with the server.child_info_nread to handle short reads */
    static child_info_data buffer;
    ssize_t wlen = sizeof(buffer);

    /* Do not overlap */
    if (server.child_info_nread == wlen) server.child_info_nread = 0;

    int nread = read(server.child_info_pipe[0], (char *)&buffer + server.child_info_nread, wlen - server.child_info_nread);
    if (nread > 0) {
        server.child_info_nread += nread;
    }

    /* We have complete child info */
    if (server.child_info_nread == wlen) {
        *information_type = buffer.information_type;
        *cow = buffer.cow;
        *cow_updated = buffer.cow_updated;
        *keys = buffer.keys;
        *progress = buffer.progress;
        return 1;
    } else {
        return 0;
    }
}",143.0,167.0,1.0,1.0,25.0,35,12,26,9,1,5,4,4,0,0,,0,5,10,5,5,int
1801,38498,receiveChildInfo,1,receiveChildInfo,void receiveChildInfo (void),childinfo.c,"void receiveChildInfo(void) {
    if (server.child_info_pipe[0] == -1) return;

    size_t cow;
    monotime cow_updated;
    size_t keys;
    double progress;
    childInfoType information_type;

    /* Drain the pipe and update child info so that we get the final message. */
    while (readChildInfo(&information_type, &cow, &cow_updated, &keys, &progress)) {
        updateChildInfo(information_type, cow, cow_updated, keys, progress);
    }
}",170.0,183.0,1.0,1.0,14.0,9,5,11,6,1,2,3,3,1,2,,0,1,2,1,1,void
1802,38621,cliSecureConnection,1,cliSecureConnection,"int cliSecureConnection (redisContext*,cliSSLconfig,char**)",cli_common.c,"int cliSecureConnection(redisContext *c, cliSSLconfig config, const char **err) {
#ifdef USE_OPENSSL
    static SSL_CTX *ssl_ctx = NULL;

    if (!ssl_ctx) {
        ssl_ctx = SSL_CTX_new(SSLv23_client_method());
        if (!ssl_ctx) {
            *err = ""Failed to create SSL_CTX"";
            goto error;
        }
        SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
        SSL_CTX_set_verify(ssl_ctx, config.skip_cert_verify ? SSL_VERIFY_NONE : SSL_VERIFY_PEER, NULL);

        if (config.cacert || config.cacertdir) {
            if (!SSL_CTX_load_verify_locations(ssl_ctx, config.cacert, config.cacertdir)) {
                *err = ""Invalid CA Certificate File/Directory"";
                goto error;
            }
        } else {
            if (!SSL_CTX_set_default_verify_paths(ssl_ctx)) {
                *err = ""Failed to use default CA paths"";
                goto error;
            }
        }

        if (config.cert && !SSL_CTX_use_certificate_chain_file(ss...",54.0,124.0,1.0,1.0,71.0,3,1,4,4,2,0,1,1,0,0,,0,0,6,3,3,int
1803,38639,cliWriteConn,1,cliWriteConn,"ssize_t cliWriteConn (redisContext*,char*,size_t)",cli_common.c,"ssize_t cliWriteConn(redisContext *c, const char *buf, size_t buf_len)
{
    int done = 0;

    /* Append data to buffer which is *usually* expected to be empty
     * but we don't assume that, and write.
     */
    c->obuf = sdscatlen(c->obuf, buf, buf_len);
    if (redisBufferWrite(c, &done) == REDIS_ERR) {
        if (!(c->flags & REDIS_BLOCK))
            errno = EAGAIN;

        /* On error, we assume nothing was written and we roll back the
         * buffer to its original state.
         */
        if (sdslen(c->obuf) > buf_len)
            sdsrange(c->obuf, 0, -(buf_len+1));
        else
            sdsclear(c->obuf);

        return -1;
    }

    /* If we're done, free up everything. We may have written more than
     * buf_len (if c->obuf was not initially empty) but we don't have to
     * tell.
     */
    if (done) {
        sdsclear(c->obuf);
        return buf_len;
    }

    /* Write was successful but we have some leftovers which we should
     * remove from the ...",140.0,190.0,1.0,1.0,51.0,26,10,28,9,2,8,6,8,2,8,,0,4,6,3,3,ssize_t
1804,38755,readArgFromStdin,1,readArgFromStdin,sds readArgFromStdin (void),cli_common.c,"sds readArgFromStdin(void) {
    char buf[1024];
    sds arg = sdsempty();

    while(1) {
        int nread = read(fileno(stdin),buf,1024);

        if (nread == 0) break;
        else if (nread == -1) {
            perror(""Reading from standard input"");
            exit(1);
        }
        arg = sdscatlen(arg,buf,nread);
    }
    return arg;
}",205.0,220.0,1.0,1.0,16.0,4,2,10,4,2,2,4,4,0,2,,0,2,2,1,1,sds
1805,38802,getSdsArrayFromArgv,1,getSdsArrayFromArgv,"sds getSdsArrayFromArgv (int,char**,int)",cli_common.c,"sds *getSdsArrayFromArgv(int argc,char **argv, int quoted) {
    sds *res = sds_malloc(sizeof(sds) * argc);

    for (int j = 0; j < argc; j++) {
        if (quoted) {
            sds unquoted = unquoteCString(argv[j]);
            if (!unquoted) {
                while (--j >= 0) sdsfree(res[j]);
                sds_free(res);
                return NULL;
            }
            res[j] = unquoted;
        } else {
            res[j] = sdsnew(argv[j]);
        }
    }

    return res;
}",229.0,247.0,1.0,1.0,19.0,12,8,18,8,2,3,5,11,0,3,,0,2,6,3,3,sds
1806,38873,unquoteCString,1,unquoteCString,sds unquoteCString (char*),cli_common.c,"sds unquoteCString(char *str) {
    int count;
    sds *unquoted = sdssplitargs(str, &count);
    sds res = NULL;

    if (unquoted && count == 1) {
        res = unquoted[0];
        unquoted[0] = NULL;
    }

    if (unquoted)
        sdsfreesplitres(unquoted, count);

    return res;
}",250.0,264.0,1.0,1.0,15.0,9,5,15,5,1,2,3,3,0,2,,0,1,2,1,1,sds
1807,38915,percentDecode,1,percentDecode,"sds percentDecode (char*,size_t)",cli_common.c,"static sds percentDecode(const char *pe, size_t len) {
    const char *end = pe + len;
    sds ret = sdsempty();
    const char *curr = pe;

    while (curr < end) {
        if (*curr == '%') {
            if ((end - curr) < 2) {
                fprintf(stderr, ""Incomplete URI encoding\n"");
                exit(1);
            }

            char h = tolower(*(++curr));
            char l = tolower(*(++curr));
            if (!isHexChar(h) || !isHexChar(l)) {
                fprintf(stderr, ""Illegal character in URI encoding\n"");
                exit(1);
            }
            char c = decodeHex(h, l);
            ret = sdscatlen(ret, &c, 1);
            curr++;
        } else {
            ret = sdscatlen(ret, curr++, 1);
        }
    }

    return ret;
}",272.0,299.0,1.0,17.0,28.0,40,16,39,9,2,2,5,10,0,2,,0,2,4,2,2,sds
1808,39060,parseRedisUri,1,parseRedisUri,"void parseRedisUri (char*,char*,cliConnInfo*,int*)",cli_common.c,"void parseRedisUri(const char *uri, const char* tool_name, cliConnInfo *connInfo, int *tls_flag) {
#ifdef USE_OPENSSL
    UNUSED(tool_name);
#else
    UNUSED(tls_flag);
#endif

    const char *scheme = ""redis://"";
    const char *tlsscheme = ""rediss://"";
    const char *curr = uri;
    const char *end = uri + strlen(uri);
    const char *userinfo, *username, *port, *host, *path;

    /* URI must start with a valid scheme. */
    if (!strncasecmp(tlsscheme, curr, strlen(tlsscheme))) {
#ifdef USE_OPENSSL
        *tls_flag = 1;
        curr += strlen(tlsscheme);
#else
        fprintf(stderr,""rediss:// is only supported when %s is compiled with OpenSSL\n"", tool_name);
        exit(1);
#endif
    } else if (!strncasecmp(scheme, curr, strlen(scheme))) {
        curr += strlen(scheme);
    } else {
        fprintf(stderr,""Invalid URI scheme\n"");
        exit(1);
    }
    if (curr == end) return;

    /* Extract user info. */
    if ((userinfo = strchr(curr,'@'))) {
        if ((username =...",309.0,377.0,1.0,4.0,69.0,52,13,65,14,0,10,11,18,0,4,,0,9,8,4,4,void
1809,39304,freeCliConnInfo,1,freeCliConnInfo,void freeCliConnInfo (cliConnInfo),cli_common.c,"void freeCliConnInfo(cliConnInfo connInfo){
    if (connInfo.hostip) sdsfree(connInfo.hostip);
    if (connInfo.auth) sdsfree(connInfo.auth);
    if (connInfo.user) sdsfree(connInfo.user);
}",379.0,383.0,1.0,1.0,5.0,6,1,6,1,1,9,4,4,3,3,,0,6,2,1,1,void
1810,39336,escapeJsonString,1,escapeJsonString,"sds escapeJsonString (sds,char*,size_t)",cli_common.c,"sds escapeJsonString(sds s, const char *p, size_t len) {
    s = sdscatlen(s,""\"""",1);
    while(len--) {
        switch(*p) {
        case '\\':
        case '""':
            s = sdscatprintf(s,""\\%c"",*p);
            break;
        case '\n': s = sdscatlen(s,""\\n"",2); break;
        case '\f': s = sdscatlen(s,""\\f"",2); break;
        case '\r': s = sdscatlen(s,""\\r"",2); break;
        case '\t': s = sdscatlen(s,""\\t"",2); break;
        case '\b': s = sdscatlen(s,""\\b"",2); break;
        default:
            s = sdscatprintf(s,*(unsigned char *)p <= 0x1f ? ""\\u%04x"" : ""%c"",*p);
        }
        p++;
    }
    return sdscatlen(s,""\"""",1);
}",389.0,408.0,1.0,1.0,20.0,17,7,23,3,1,9,9,4,0,9,,0,8,6,3,3,sds
1811,39554,createClusterNode,1,createClusterNode,"clusterNode* createClusterNode (char*,int)",redis-benchmark.c,"static clusterNode *createClusterNode(char *ip, int port) {
    clusterNode *node = zmalloc(sizeof(*node));
    if (!node) return NULL;
    node->ip = ip;
    node->port = port;
    node->name = NULL;
    node->flags = 0;
    node->replicate = NULL;
    node->replicas_count = 0;
    node->slots = zmalloc(CLUSTER_SLOTS * sizeof(int));
    node->slots_count = 0;
    node->current_slot_index = 0;
    node->updated_slots = NULL;
    node->updated_slots_count = 0;
    node->migrating = NULL;
    node->importing = NULL;
    node->migrating_count = 0;
    node->importing_count = 0;
    node->redis_config = NULL;
    return node;
}",1056.0,1076.0,1.0,26.0,21.0,0,0,0,0,7,0,1,1,0,0,,0,0,4,2,2,clusterNode
1812,39560,clusterAddNode,1,clusterAddNode,void clusterAddNode (clusterNode*),cluster.c,"void clusterAddNode(clusterNode *node) {
    int retval;

    retval = dictAdd(server.cluster->nodes,
            sdsnewlen(node->name,CLUSTER_NAMELEN), node);
    serverAssert(retval == DICT_OK);
}",1571.0,1577.0,1.0,33.0,7.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,void
1813,39578,clusterSendPing,1,clusterSendPing,"void clusterSendPing (clusterLink*,int)",cluster.c,"void clusterSendPing(clusterLink *link, int type) {
    static unsigned long long cluster_pings_sent = 0;
    cluster_pings_sent++;
    int gossipcount = 0; /* Number of gossip sections added so far. */
    int wanted; /* Number of gossip sections we want to append if possible. */
    int estlen; /* Upper bound on estimated packet length */
    /* freshnodes is the max number of nodes we can hope to append at all:
     * nodes available minus two (ourself and the node we are sending the
     * message to). However practically there may be less valid nodes since
     * nodes in handshake state, disconnected, are not considered. */
    int freshnodes = dictSize(server.cluster->nodes)-2;

    /* How many gossip sections we want to add? 1/10 of the number of nodes
     * and anyway at least 3. Why 1/10?
     *
     * If we have N masters, with N/10 entries, and we consider that in
     * node_timeout we exchange with each other node at least 4 packets
     * (we ping in the worst case i...",3539.0,3667.0,1.0,21.0,129.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,void
1814,39584,clusterSendFail,1,clusterSendFail,void clusterSendFail (char*),cluster.c,"void clusterSendFail(char *nodename) {
    uint32_t msglen = sizeof(clusterMsg) - sizeof(union clusterMsgData)
        + sizeof(clusterMsgDataFail);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAIL, msglen);

    clusterMsg *hdr = &msgblock->msg;
    memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);

    clusterBroadcastMessage(msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3744.0,3754.0,1.0,62.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1815,39595,clusterUpdateState,1,clusterUpdateState,void clusterUpdateState (void),cluster.c,"void clusterUpdateState(void) {
    int j, new_state;
    int reachable_masters = 0;
    static mstime_t among_minority_time;
    static mstime_t first_call_time = 0;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_UPDATE_STATE;

    /* If this is a master node, wait some time before turning the state
     * into OK, since it is not a good idea to rejoin the cluster as a writable
     * master, after a reboot, without giving the cluster a chance to
     * reconfigure this node. Note that the delay is calculated starting from
     * the first call to this function and not since the server start, in order
     * to not count the DB loading time. */
    if (first_call_time == 0) first_call_time = mstime();
    if (nodeIsMaster(myself) &&
        server.cluster->state == CLUSTER_FAIL &&
        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;

    /* Start assuming the state is OK. We'll turn it into FAIL if there
     * are the right conditions. */
    new_state = C...",4971.0,5066.0,1.0,42.0,96.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1816,39600,clusterNodeGetSlotBit,1,clusterNodeGetSlotBit,"int clusterNodeGetSlotBit (clusterNode*,int)",cluster.c,"int clusterNodeGetSlotBit(clusterNode *n, int slot) {
    return bitmapTestBit(n->slots,slot);
}",4901.0,4903.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1817,39606,clusterGetNodesInMyShard,1,clusterGetNodesInMyShard,list* clusterGetNodesInMyShard (clusterNode*),cluster.c,"list *clusterGetNodesInMyShard(clusterNode *node) {
    sds s = sdsnewlen(node->shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards,s);
    sdsfree(s);
    return (de != NULL) ? dictGetVal(de) : NULL;
}",1651.0,1656.0,1.0,38.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,list
1818,39611,clusterNodeAddSlave,1,clusterNodeAddSlave,"int clusterNodeAddSlave (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
    int j;

    /* If it's already a slave, don't add it again. */
    for (j = 0; j < master->numslaves; j++)
        if (master->slaves[j] == slave) return C_ERR;
    master->slaves = zrealloc(master->slaves,
        sizeof(clusterNode*)*(master->numslaves+1));
    master->slaves[master->numslaves] = slave;
    master->numslaves++;
    master->flags |= CLUSTER_NODE_MIGRATE_TO;
    return C_OK;
}",1520.0,1532.0,1.0,47.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1819,39617,clusterAddSlot,1,clusterAddSlot,"int clusterAddSlot (clusterNode*,int)",cluster.c,"int clusterAddSlot(clusterNode *n, int slot) {
    if (server.cluster->slots[slot]) return C_ERR;
    clusterNodeSetSlotBit(n,slot);
    server.cluster->slots[slot] = n;
    return C_OK;
}",4909.0,4914.0,1.0,44.0,6.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
1820,39623,clusterDelSlot,1,clusterDelSlot,int clusterDelSlot (int),cluster.c,"int clusterDelSlot(int slot) {
    clusterNode *n = server.cluster->slots[slot];

    if (!n) return C_ERR;

    /* Cleanup the channels in master/replica as part of slot deletion. */
    list *nodes_for_slot = clusterGetNodesInMyShard(n);
    serverAssert(nodes_for_slot != NULL);
    listNode *ln = listSearchKey(nodes_for_slot, myself);
    if (ln != NULL) {
        removeChannelsInSlot(slot);
    }
    serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
    server.cluster->slots[slot] = NULL;
    return C_OK;
}",4919.0,4934.0,1.0,19.0,16.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
1821,39639,clusterSetMaster,1,clusterSetMaster,void clusterSetMaster (clusterNode*),cluster.c,"void clusterSetMaster(clusterNode *n) {
    serverAssert(n != myself);
    serverAssert(myself->numslots == 0);

    if (nodeIsMaster(myself)) {
        myself->flags &= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
        myself->flags |= CLUSTER_NODE_SLAVE;
        clusterCloseAllSlots();
    } else {
        if (myself->slaveof)
            clusterNodeRemoveSlave(myself->slaveof,myself);
    }
    myself->slaveof = n;
    updateShardId(myself, n->shard_id);
    clusterNodeAddSlave(n,myself);
    replicationSetMaster(n->ip, getNodeDefaultReplicationPort(n));
    resetManualFailover();
}",5145.0,5162.0,1.0,4.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1822,39644,clusterHandleSlaveFailover,1,clusterHandleSlaveFailover,void clusterHandleSlaveFailover (void),cluster.c,"void clusterHandleSlaveFailover(void) {
    mstime_t data_age;
    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
    int needed_quorum = (server.cluster->size / 2) + 1;
    int manual_failover = server.cluster->mf_end != 0 &&
                          server.cluster->mf_can_start;
    mstime_t auth_timeout, auth_retry_time;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_HANDLE_FAILOVER;

    /* Compute the failover timeout (the max time we have to send votes
     * and wait for replies), and the failover retry time (the time to wait
     * before trying to get voted again).
     *
     * Timeout is MAX(NODE_TIMEOUT*2,2000) milliseconds.
     * Retry is two times the Timeout.
     */
    auth_timeout = server.cluster_node_timeout*2;
    if (auth_timeout < 2000) auth_timeout = 2000;
    auth_retry_time = auth_timeout*2;

    /* Pre conditions to run the function, that must be met both in case
     * of an automatic or manual failover:
     * 1) We are a s...",4149.0,4318.0,1.0,42.0,170.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1823,39649,clusterHandleSlaveMigration,1,clusterHandleSlaveMigration,void clusterHandleSlaveMigration (int),cluster.c,"void clusterHandleSlaveMigration(int max_slaves) {
    int j, okslaves = 0;
    clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
    dictIterator *di;
    dictEntry *de;

    /* Step 1: Don't migrate if the cluster state is not ok. */
    if (server.cluster->state != CLUSTER_OK) return;

    /* Step 2: Don't migrate if my master will not be left with at least
     *         'migration-barrier' slaves after my migration. */
    if (mymaster == NULL) return;
    for (j = 0; j < mymaster->numslaves; j++)
        if (!nodeFailed(mymaster->slaves[j]) &&
            !nodeTimedOut(mymaster->slaves[j])) okslaves++;
    if (okslaves <= server.cluster_migration_barrier) return;

    /* Step 3: Identify a candidate for migration, and check if among the
     * masters with the greatest number of ok slaves, I'm the one with the
     * smallest node ID (the ""candidate slave"").
     *
     * Note: this means that eventually a replica migration will occur
     * since sla...",4347.0,4430.0,1.0,33.0,84.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1824,39654,bitmapTestBit,1,bitmapTestBit,"int bitmapTestBit (unsigned char*,int)",cluster.c,"int bitmapTestBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    return (bitmap[byte] & (1<<bit)) != 0;
}",4828.0,4832.0,1.0,1.0,5.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int
1825,39666,bitmapClearBit,1,bitmapClearBit,"void bitmapClearBit (unsigned char*,int)",cluster.c,"void bitmapClearBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    bitmap[byte] &= ~(1<<bit);
}",4842.0,4846.0,1.0,1.0,5.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
1826,39672,clusterDoBeforeSleep,1,clusterDoBeforeSleep,void clusterDoBeforeSleep (int),cluster.c,"void clusterDoBeforeSleep(int flags) {
    server.cluster->todo_before_sleep |= flags;
}",4818.0,4820.0,1.0,1.0,3.0,0,0,0,0,21,0,1,1,0,0,,0,0,2,1,1,void
1827,39677,clusterSendUpdate,1,clusterSendUpdate,"void clusterSendUpdate (clusterLink*,clusterNode*)",cluster.c,"void clusterSendUpdate(clusterLink *link, clusterNode *node) {
    if (link == NULL) return;

    uint32_t msglen = sizeof(clusterMsg) - sizeof(union clusterMsgData)
        + sizeof(clusterMsgDataUpdate);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_UPDATE, msglen);

    clusterMsg *hdr = &msgblock->msg;
    memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
    hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
    memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
    for (unsigned int i = 0; i < sizeof(node->slots); i++) {
        /* Don't advertise slots that the node stopped claiming */
        hdr->data.update.nodecfg.slots[i] = hdr->data.update.nodecfg.slots[i] & (~server.cluster->owner_not_claiming_slot[i]);
    }

    clusterSendMessage(link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3759.0,3777.0,1.0,62.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
1828,39683,resetManualFailover,1,resetManualFailover,void resetManualFailover (void),cluster.c,"void resetManualFailover(void) {
    if (server.cluster->mf_slave) {
        /* We were a master failing over, so we paused clients and related actions.
         * Regardless of the outcome we unpause now to allow traffic again. */
        unpauseActions(PAUSE_DURING_FAILOVER);
    }
    server.cluster->mf_end = 0; /* No manual failover in progress. */
    server.cluster->mf_can_start = 0;
    server.cluster->mf_slave = NULL;
    server.cluster->mf_master_offset = -1;
}",4466.0,4476.0,1.0,1.0,11.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
1829,39688,clusterCloseAllSlots,1,clusterCloseAllSlots,void clusterCloseAllSlots (void),cluster.c,"void clusterCloseAllSlots(void) {
    memset(server.cluster->migrating_slots_to,0,
        sizeof(server.cluster->migrating_slots_to));
    memset(server.cluster->importing_slots_from,0,
        sizeof(server.cluster->importing_slots_from));
}",4952.0,4957.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1830,39693,clusterSetNodeAsMaster,1,clusterSetNodeAsMaster,void clusterSetNodeAsMaster (clusterNode*),cluster.c,"void clusterSetNodeAsMaster(clusterNode *n) {
    if (nodeIsMaster(n)) return;

    if (n->slaveof) {
        clusterNodeRemoveSlave(n->slaveof,n);
        if (n != myself) n->flags |= CLUSTER_NODE_MIGRATE_TO;
    }
    n->flags &= ~CLUSTER_NODE_SLAVE;
    n->flags |= CLUSTER_NODE_MASTER;
    n->slaveof = NULL;

    /* Update config and state. */
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                         CLUSTER_TODO_UPDATE_STATE);
}",2302.0,2316.0,1.0,8.0,15.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1831,39698,clusterDelNode,1,clusterDelNode,void clusterDelNode (clusterNode*),cluster.c,"void clusterDelNode(clusterNode *delnode) {
    int j;
    dictIterator *di;
    dictEntry *de;

    /* 1) Mark slots as unassigned. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (server.cluster->importing_slots_from[j] == delnode)
            server.cluster->importing_slots_from[j] = NULL;
        if (server.cluster->migrating_slots_to[j] == delnode)
            server.cluster->migrating_slots_to[j] = NULL;
        if (server.cluster->slots[j] == delnode)
            clusterDelSlot(j);
    }

    /* 2) Remove failure reports. */
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node == delnode) continue;
        clusterNodeDelFailureReport(node,delnode);
    }
    dictReleaseIterator(di);

    /* 3) Remove the node from the owning shard */
    clusterRemoveNodeFromShard(delnode);

    /* 4) Free the node, unlinking it from the cluster. */
    freeClusterNode(delnode);
}",1591.0,1621.0,1.0,20.0,31.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
1832,39703,representClusterNodeFlags,1,representClusterNodeFlags,"sds representClusterNodeFlags (sds,uint16_t)",cluster.c,"sds representClusterNodeFlags(sds ci, uint16_t flags) {
    size_t orig_len = sdslen(ci);
    int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
    for (i = 0; i < size; i++) {
        struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
        if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
    }
    /* If no flag was added, add the ""noflags"" special flag. */
    if (sdslen(ci) == orig_len) ci = sdscat(ci,""noflags,"");
    sdsIncrLen(ci,-1); /* Remove trailing comma. */
    return ci;
}",5186.0,5197.0,1.0,1.0,12.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,sds
1833,39709,representSlotInfo,1,representSlotInfo,"sds representSlotInfo (sds,uint16_t*,int)",cluster.c,"sds representSlotInfo(sds ci, uint16_t *slot_info_pairs, int slot_info_pairs_count) {
    for (int i = 0; i< slot_info_pairs_count; i+=2) {
        unsigned long start = slot_info_pairs[i];
        unsigned long end = slot_info_pairs[i+1];
        if (start == end) {
            ci = sdscatfmt(ci, "" %i"", start);
        } else {
            ci = sdscatfmt(ci, "" %i-%i"", start, end);
        }
    }
    return ci;
}",5202.0,5213.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,sds
1834,39716,clusterFreeNodesSlotsInfo,1,clusterFreeNodesSlotsInfo,void clusterFreeNodesSlotsInfo (clusterNode*),cluster.c,"void clusterFreeNodesSlotsInfo(clusterNode *n) {
    zfree(n->slot_info_pairs);
    n->slot_info_pairs = NULL;
    n->slot_info_pairs_count = 0;
}",5350.0,5354.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1835,39721,clusterGetMaxEpoch,1,clusterGetMaxEpoch,uint64_t clusterGetMaxEpoch (void),cluster.c,"uint64_t clusterGetMaxEpoch(void) {
    uint64_t max = 0;
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->configEpoch > max) max = node->configEpoch;
    }
    dictReleaseIterator(di);
    if (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
    return max;
}",1713.0,1726.0,1.0,1.0,14.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,uint64_t
1836,39740,clusterGetMessageTypeString,1,clusterGetMessageTypeString,char* clusterGetMessageTypeString (int),cluster.c,"const char *clusterGetMessageTypeString(int type) {
    switch(type) {
    case CLUSTERMSG_TYPE_PING: return ""ping"";
    case CLUSTERMSG_TYPE_PONG: return ""pong"";
    case CLUSTERMSG_TYPE_MEET: return ""meet"";
    case CLUSTERMSG_TYPE_FAIL: return ""fail"";
    case CLUSTERMSG_TYPE_PUBLISH: return ""publish"";
    case CLUSTERMSG_TYPE_PUBLISHSHARD: return ""publishshard"";
    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return ""auth-req"";
    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return ""auth-ack"";
    case CLUSTERMSG_TYPE_UPDATE: return ""update"";
    case CLUSTERMSG_TYPE_MFSTART: return ""mfstart"";
    case CLUSTERMSG_TYPE_MODULE: return ""module"";
    }
    return ""unknown"";
}",5473.0,5488.0,1.0,9.0,16.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,const char*
1837,39750,countKeysInSlot,1,countKeysInSlot,unsigned int countKeysInSlot (unsigned int),cluster.c,"unsigned int countKeysInSlot(unsigned int hashslot) {
    return (*server.db->slots_to_keys).by_slot[hashslot].count;
}",7629.0,7631.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,unsigned int
1838,39765,clusterAddNodeToShard,1,clusterAddNodeToShard,"void clusterAddNodeToShard (char*,clusterNode*)",cluster.c,"void clusterAddNodeToShard(const char *shard_id, clusterNode *node) {
    sds s = sdsnewlen(shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards,s);
    if (de == NULL) {
        list *l = listCreate();
        listAddNodeTail(l, node);
        serverAssert(dictAdd(server.cluster->shards, s, l) == DICT_OK);
    } else {
        list *l = dictGetVal(de);
        if (listSearchKey(l, node) == NULL) {
            listAddNodeTail(l, node);
        }
        sdsfree(s);
    }
}",1675.0,1689.0,1.0,32.0,15.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,void
1839,39776,clusterRemoveNodeFromShard,1,clusterRemoveNodeFromShard,void clusterRemoveNodeFromShard (clusterNode*),cluster.c,"void clusterRemoveNodeFromShard(clusterNode *node) {
    sds s = sdsnewlen(node->shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards, s);
    if (de != NULL) {
        list *l = dictGetVal(de);
        listNode *ln = listSearchKey(l, node);
        if (ln != NULL) {
            listDelNode(l, ln);
        }
        if (listLength(l) == 0) {
            dictDelete(server.cluster->shards, s);
        }
    }
    sdsfree(s);
}",1691.0,1705.0,1.0,38.0,15.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
1840,39853,clusterBuildMessageHdr,1,clusterBuildMessageHdr,"void clusterBuildMessageHdr (clusterMsg*,int,size_t)",cluster.c,"static void clusterBuildMessageHdr(clusterMsg *hdr, int type, size_t msglen) {
    uint64_t offset;
    clusterNode *master;

    /* If this node is a master, we send its slots bitmap and configEpoch.
     * If this node is a slave we send the master's information instead (the
     * node is flagged as slave so the receiver knows that it is NOT really
     * in charge for this slots. */
    master = (nodeIsSlave(myself) && myself->slaveof) ?
              myself->slaveof : myself;

    hdr->ver = htons(CLUSTER_PROTO_VER);
    hdr->sig[0] = 'R';
    hdr->sig[1] = 'C';
    hdr->sig[2] = 'm';
    hdr->sig[3] = 'b';
    hdr->type = htons(type);
    memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);

    /* If cluster-announce-ip option is enabled, force the receivers of our
     * packets to use the specified address for this node. Otherwise if the
     * first byte is zero, they'll do auto discovery. */
    memset(hdr->myip,0,NET_IP_STR_LEN);
    if (server.cluster_announce_ip) {
      ...",3452.0,3514.0,1.0,14.0,63.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
1841,39860,getNodeDefaultClientPort,1,getNodeDefaultClientPort,int getNodeDefaultClientPort (clusterNode*),cluster.c,"int getNodeDefaultClientPort(clusterNode *n) {
    return server.tls_cluster ? n->tls_port : n->tcp_port;
}",106.0,108.0,1.0,1.0,3.0,4,3,3,2,4,2,1,1,0,0,,0,2,2,1,1,int
1842,39876,getNodeDefaultReplicationPort,1,getNodeDefaultReplicationPort,int getNodeDefaultReplicationPort (clusterNode*),cluster.c,"static inline int getNodeDefaultReplicationPort(clusterNode *n) {
    return server.tls_replication ? n->tls_port : n->tcp_port;
}",110.0,112.0,1.0,1.0,3.0,4,3,3,2,2,2,1,1,0,0,,0,2,2,1,1,int
1843,39892,getNodeClientPort,1,getNodeClientPort,"int getNodeClientPort (clusterNode*,int)",cluster.c,"static inline int getNodeClientPort(clusterNode *n, int use_tls) {
    return use_tls ? n->tls_port : n->tcp_port;
}",114.0,116.0,1.0,1.0,3.0,3,2,3,2,2,2,1,1,0,0,,0,2,4,2,2,int
1844,39907,defaultClientPort,1,defaultClientPort,int defaultClientPort (void),cluster.c,"static inline int defaultClientPort(void) {
    return server.tls_cluster ? server.tls_port : server.port;
}",118.0,120.0,1.0,1.0,3.0,4,2,3,1,2,0,1,1,0,0,,0,0,2,1,1,int
1845,39945,connTypeOfCluster,1,connTypeOfCluster,ConnectionType connTypeOfCluster (void),cluster.c,"static ConnectionType *connTypeOfCluster(void) {
    if (server.tls_cluster) {
        return connectionTypeTls();
    }

    return connectionTypeTcp();
}",161.0,167.0,1.0,1.0,7.0,1,1,1,1,5,2,2,2,0,2,,0,0,2,1,1,ConnectionType
1846,40025,isValidAuxChar,1,isValidAuxChar,int isValidAuxChar (int),cluster.c,"int isValidAuxChar(int c) {
    return isalnum(c) || (strchr(""!#$%&()*+:;<>?@[]^{|}~"", c) == NULL);
}",224.0,226.0,1.0,1.0,3.0,2,2,3,2,1,0,1,1,0,0,,0,0,2,1,1,int
1847,40039,isValidAuxString,1,isValidAuxString,"int isValidAuxString (char*,unsigned int)",cluster.c,"int isValidAuxString(char *s, unsigned int length) {
    for (unsigned i = 0; i < length; i++) {
        if (!isValidAuxChar(s[i])) return 0;
    }
    return 1;
}",228.0,233.0,1.0,1.0,6.0,4,4,5,3,2,1,3,4,1,1,,0,1,4,2,2,int
1848,40445,clusterLoadConfig,1,clusterLoadConfig,int clusterLoadConfig (char*),cluster.c,"int clusterLoadConfig(char *filename) {
    FILE *fp = fopen(filename,""r"");
    struct stat sb;
    char *line;
    int maxline, j;

    if (fp == NULL) {
        if (errno == ENOENT) {
            return C_ERR;
        } else {
            serverLog(LL_WARNING,
                ""Loading the cluster node config from %s: %s"",
                filename, strerror(errno));
            exit(1);
        }
    }

    if (redis_fstat(fileno(fp),&sb) == -1) {
        serverLog(LL_WARNING,
            ""Unable to obtain the cluster node config file stat %s: %s"",
            filename, strerror(errno));
        exit(1);
    }
    /* Check if the file is zero-length: if so return C_ERR to signal
     * we have to write the config. */
    if (sb.st_size == 0) {
        fclose(fp);
        return C_ERR;
    }

    /* Parse the file. Note that single lines of the cluster config file can
     * be really long as they include all the hash slots of the node.
     * This means in the worst possible case, ...",338.0,692.0,1.0,19.0,355.0,249,29,278,38,1,89,70,128,19,64,,0,56,2,1,1,int
1849,41825,clusterSaveConfig,1,clusterSaveConfig,int clusterSaveConfig (int),cluster.c,"int clusterSaveConfig(int do_fsync) {
    sds ci,tmpfilename;
    size_t content_size,offset = 0;
    ssize_t written_bytes;
    int fd = -1;
    int retval = C_ERR;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_SAVE_CONFIG;

    /* Get the nodes description and concatenate our ""vars"" directive to
     * save currentEpoch and lastVoteEpoch. */
    ci = clusterGenNodesDescription(NULL, CLUSTER_NODE_HANDSHAKE, 0);
    ci = sdscatprintf(ci,""vars currentEpoch %llu lastVoteEpoch %llu\n"",
        (unsigned long long) server.cluster->currentEpoch,
        (unsigned long long) server.cluster->lastVoteEpoch);
    content_size = sdslen(ci);

    /* Create a temp file with the new content. */
    tmpfilename = sdscatfmt(sdsempty(),""%s.tmp-%i-%I"",
        server.cluster_configfile,(int) getpid(),mstime());
    if ((fd = open(tmpfilename,O_WRONLY|O_CREAT,0644)) == -1) {
        serverLog(LL_WARNING,""Could not open temp cluster config file: %s"",strerror(errno));
        goto cleanup;
  ...",706.0,769.0,1.0,17.0,64.0,62,16,58,14,1,14,18,17,1,14,,0,7,2,1,1,int
1850,42125,clusterSaveConfigOrDie,1,clusterSaveConfigOrDie,void clusterSaveConfigOrDie (int),cluster.c,"void clusterSaveConfigOrDie(int do_fsync) {
    if (clusterSaveConfig(do_fsync) == -1) {
        serverLog(LL_WARNING,""Fatal: can't update cluster config file."");
        exit(1);
    }
}",771.0,776.0,1.0,8.0,6.0,5,5,2,2,5,2,2,2,1,2,,0,1,2,1,1,void
1851,42157,clusterLockConfig,1,clusterLockConfig,int clusterLockConfig (char*),cluster.c,"int clusterLockConfig(char *filename) {
/* flock() does not exist on Solaris
 * and a fcntl-based solution won't help, as we constantly re-open that file,
 * which will release _all_ locks anyway
 */
#if !defined(__sun)
    /* To lock it, we need to open the file in a way it is created if
     * it does not exist, otherwise there is a race condition with other
     * processes. */
    int fd = open(filename,O_WRONLY|O_CREAT|O_CLOEXEC,0644);
    if (fd == -1) {
        serverLog(LL_WARNING,
            ""Can't open %s in order to acquire a lock: %s"",
            filename, strerror(errno));
        return C_ERR;
    }

    if (flock(fd,LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
            serverLog(LL_WARNING,
                 ""Sorry, the cluster configuration file %s is already used ""
                 ""by a different Redis Cluster node. Please make sure that ""
                 ""different nodes use different cluster configuration ""
                 ""files."", filenam...",787.0,833.0,1.0,8.0,47.0,19,7,19,10,1,2,4,5,0,2,,0,0,2,1,1,int
1852,42278,deriveAnnouncedPorts,1,deriveAnnouncedPorts,"void deriveAnnouncedPorts (int*,int*,int*)",cluster.c,"void deriveAnnouncedPorts(int *announced_tcp_port, int *announced_tls_port,
                          int *announced_cport) {
    /* Config overriding announced ports. */
    *announced_tcp_port = server.cluster_announce_port ? 
                          server.cluster_announce_port : server.port;
    *announced_tls_port = server.cluster_announce_tls_port ? 
                          server.cluster_announce_tls_port : server.tls_port;
    /* Derive cluster bus port. */
    if (server.cluster_announce_bus_port) {
        *announced_cport = server.cluster_announce_bus_port;
    } else if (server.cluster_port) {
        *announced_cport = server.cluster_port;
    } else {
        *announced_cport = defaultClientPort() + CLUSTER_PORT_INCR;
    }
}",836.0,851.0,1.0,49.0,16.0,16,4,11,4,2,0,2,2,0,0,,0,0,6,3,3,void
1853,42345,clusterUpdateMyselfFlags,1,clusterUpdateMyselfFlags,void clusterUpdateMyselfFlags (void),cluster.c,"void clusterUpdateMyselfFlags(void) {
    if (!myself) return;
    int oldflags = myself->flags;
    int nofailover = server.cluster_slave_no_failover ?
                     CLUSTER_NODE_NOFAILOVER : 0;
    myself->flags &= ~CLUSTER_NODE_NOFAILOVER;
    myself->flags |= nofailover;
    if (myself->flags != oldflags) {
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                             CLUSTER_TODO_UPDATE_STATE);
    }
}",857.0,868.0,1.0,21.0,12.0,14,9,10,4,2,10,3,3,3,1,,0,9,2,1,1,void
1854,42404,clusterUpdateMyselfAnnouncedPorts,1,clusterUpdateMyselfAnnouncedPorts,void clusterUpdateMyselfAnnouncedPorts (void),cluster.c,"void clusterUpdateMyselfAnnouncedPorts(void) {
    if (!myself) return;
    deriveAnnouncedPorts(&myself->tcp_port,&myself->tls_port,&myself->cport);
}",874.0,877.0,1.0,1.0,4.0,7,3,4,1,1,8,2,2,1,1,,0,7,2,1,1,void
1855,42427,clusterUpdateMyselfIp,1,clusterUpdateMyselfIp,void clusterUpdateMyselfIp (void),cluster.c,"void clusterUpdateMyselfIp(void) {
    if (!myself) return;
    static char *prev_ip = NULL;
    char *curr_ip = server.cluster_announce_ip;
    int changed = 0;

    if (prev_ip == NULL && curr_ip != NULL) changed = 1;
    else if (prev_ip != NULL && curr_ip == NULL) changed = 1;
    else if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;

    if (changed) {
        if (prev_ip) zfree(prev_ip);
        prev_ip = curr_ip;

        if (curr_ip) {
            /* We always take a copy of the previous IP address, by
            * duplicating the string. This way later we can check if
            * the address really changed. */
            prev_ip = zstrdup(prev_ip);
            redis_strlcpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);
        } else {
            myself->ip[0] = '\0'; /* Force autodetection. */
        }
    }
}",881.0,905.0,1.0,64.0,25.0,13,7,21,6,2,6,6,8,1,3,,0,4,2,1,1,void
1856,42528,updateAnnouncedHostname,1,updateAnnouncedHostname,"void updateAnnouncedHostname (clusterNode*,char*)",cluster.c,"static void updateAnnouncedHostname(clusterNode *node, char *new) {
    /* Previous and new hostname are the same, no need to update. */
    if (new && !strcmp(new, node->hostname)) {
        return;
    } else if (!new && (sdslen(node->hostname) == 0)) {
        return;
    }

    if (new) {
        node->hostname = sdscpy(node->hostname, new);
    } else if (sdslen(node->hostname) != 0) {
        sdsclear(node->hostname);
    }
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
}",908.0,922.0,1.0,25.0,15.0,7,5,7,2,2,5,3,3,1,2,,0,4,4,2,2,void
1857,42591,updateAnnouncedHumanNodename,1,updateAnnouncedHumanNodename,"void updateAnnouncedHumanNodename (clusterNode*,char*)",cluster.c,"static void updateAnnouncedHumanNodename(clusterNode *node, char *new) {
    if (new && !strcmp(new, node->human_nodename)) {
        return;
    } else if (!new && (sdslen(node->human_nodename) == 0)) {
        return;
    }
    
    if (new) {
        node->human_nodename = sdscpy(node->human_nodename, new);
    } else if (sdslen(node->human_nodename) != 0) {
        sdsclear(node->human_nodename);
    }
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
}",924.0,937.0,1.0,25.0,14.0,7,5,7,2,2,5,3,3,1,2,,0,4,4,2,2,void
1858,42654,updateShardId,1,updateShardId,"void updateShardId (clusterNode*,char*)",cluster.c,"static void updateShardId(clusterNode *node, const char *shard_id) {
    if (memcmp(node->shard_id, shard_id, CLUSTER_NAMELEN) != 0) {
        clusterRemoveNodeFromShard(node);
        memcpy(node->shard_id, shard_id, CLUSTER_NAMELEN);
        clusterAddNodeToShard(shard_id, node);
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
    }
    if (myself != node && myself->slaveof == node) {
        if (memcmp(myself->shard_id, shard_id, CLUSTER_NAMELEN) != 0) {
            /* shard-id can diverge right after a rolling upgrade
             * from pre-7.2 releases */
            clusterRemoveNodeFromShard(myself);
            memcpy(myself->shard_id, shard_id, CLUSTER_NAMELEN);
            clusterAddNodeToShard(shard_id, myself);
            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_FSYNC_CONFIG);
        }
    }
}",940.0,957.0,1.0,41.0,18.0,14,6,18,3,1,17,4,5,6,6,,0,11,4,2,2,void
1859,42739,clusterUpdateMyselfHostname,1,clusterUpdateMyselfHostname,void clusterUpdateMyselfHostname (void),cluster.c,"void clusterUpdateMyselfHostname(void) {
    if (!myself) return;
    updateAnnouncedHostname(myself, server.cluster_announce_hostname);
}",960.0,963.0,1.0,1.0,4.0,2,2,3,2,3,3,2,2,1,1,,0,2,2,1,1,void
1860,42754,clusterUpdateMyselfHumanNodename,1,clusterUpdateMyselfHumanNodename,void clusterUpdateMyselfHumanNodename (void),cluster.c,"void clusterUpdateMyselfHumanNodename(void) {
    if (!myself) return;
    updateAnnouncedHumanNodename(myself, server.cluster_announce_human_nodename);
}",965.0,968.0,1.0,1.0,4.0,2,2,3,2,2,3,2,2,1,1,,0,2,2,1,1,void
1861,42769,clusterInit,1,clusterInit,void clusterInit (void),cluster.c,"void clusterInit(void) {
    int saveconf = 0;

    server.cluster = zmalloc(sizeof(clusterState));
    server.cluster->myself = NULL;
    server.cluster->currentEpoch = 0;
    server.cluster->state = CLUSTER_FAIL;
    server.cluster->size = 1;
    server.cluster->todo_before_sleep = 0;
    server.cluster->nodes = dictCreate(&clusterNodesDictType);
    server.cluster->shards = dictCreate(&clusterSdsToListType);
    server.cluster->nodes_black_list =
        dictCreate(&clusterNodesBlackListDictType);
    server.cluster->failover_auth_time = 0;
    server.cluster->failover_auth_count = 0;
    server.cluster->failover_auth_rank = 0;
    server.cluster->failover_auth_epoch = 0;
    server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
    server.cluster->lastVoteEpoch = 0;

    /* Initialize stats */
    for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
        server.cluster->stats_bus_messages_sent[i] = 0;
        server.cluster->stats_bus_messages_received[i] = 0;
    }...",970.0,1056.0,1.0,28.0,87.0,125,15,60,10,0,39,7,7,2,23,,0,25,2,1,1,void
1862,43156,clusterInitListeners,1,clusterInitListeners,void clusterInitListeners (void),cluster.c,"void clusterInitListeners(void) {
    if (connectionIndexByType(connTypeOfCluster()->get_type(NULL)) < 0) {
        serverLog(LL_WARNING, ""Missing connection type %s, but it is required for the Cluster bus."", connTypeOfCluster()->get_type(NULL));
        exit(1);
    }

    int port = defaultClientPort();
    connListener *listener = &server.clistener;
    listener->count = 0;
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.cluster_port ? server.cluster_port : port + CLUSTER_PORT_INCR;
    listener->ct = connTypeOfCluster();
    if (connListen(listener) == C_ERR ) {
        /* Note: the following log text is matched by the test suite. */
        serverLog(LL_WARNING, ""Failed listening on port %u (cluster), aborting."", listener->port);
        exit(1);
    }
    
    if (createSocketAcceptHandler(&server.clistener, clusterAcceptHandler) != C_OK) {
        serverPanic(""Unrecoverable error creating Redis Cluste...",1058.0,1080.0,1.0,8.0,23.0,36,12,21,5,0,17,4,4,5,11,,0,14,2,1,1,void
1863,43299,clusterReset,1,clusterReset,void clusterReset (int),cluster.c,"void clusterReset(int hard) {
    dictIterator *di;
    dictEntry *de;
    int j;

    /* Turn into master. */
    if (nodeIsSlave(myself)) {
        clusterSetNodeAsMaster(myself);
        replicationUnsetMaster();
        emptyData(-1,EMPTYDB_NO_FLAGS,NULL);
    }

    /* Close slots, reset manual failover state. */
    clusterCloseAllSlots();
    resetManualFailover();

    /* Unassign all the slots. */
    for (j = 0; j < CLUSTER_SLOTS; j++) clusterDelSlot(j);

    /* Recreate shards dict */
    dictEmpty(server.cluster->shards, NULL);

    /* Forget all the nodes, but myself. */
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node == myself) continue;
        clusterDelNode(node);
    }
    dictReleaseIterator(di);

    /* Hard reset only: set epochs to 0, change node ID. */
    if (hard) {
        sds oldname;

        server.cluster->currentEpoch = 0;
        server.cluster-...",1091.0,1150.0,1.0,8.0,60.0,41,10,36,9,0,40,7,7,5,21,,0,23,2,1,1,void
1864,43500,createClusterMsgSendBlock,1,createClusterMsgSendBlock,"clusterMsgSendBlock createClusterMsgSendBlock (int,uint32_t)",cluster.c,"static clusterMsgSendBlock *createClusterMsgSendBlock(int type, uint32_t msglen) {
    uint32_t blocklen = msglen + sizeof(clusterMsgSendBlock) - sizeof(clusterMsg);
    clusterMsgSendBlock *msgblock = zcalloc(blocklen);
    msgblock->refcount = 1;
    msgblock->totlen = blocklen;
    server.stat_cluster_links_memory += blocklen;
    clusterBuildMessageHdr(&msgblock->msg,type,msglen);
    return msgblock;
}",1155.0,1163.0,1.0,1.0,9.0,14,8,15,7,5,6,1,1,0,2,,0,5,4,2,2,clusterMsgSendBlock
1865,43545,clusterMsgSendBlockDecrRefCount,1,clusterMsgSendBlockDecrRefCount,void clusterMsgSendBlockDecrRefCount (void*),cluster.c,"static void clusterMsgSendBlockDecrRefCount(void *node) {
    clusterMsgSendBlock *msgblock = (clusterMsgSendBlock*)node;
    msgblock->refcount--;
    serverAssert(msgblock->refcount >= 0);
    if (msgblock->refcount == 0) {
        server.stat_cluster_links_memory -= msgblock->totlen;
        zfree(msgblock);
    }
}",1165.0,1173.0,1.0,4.0,9.0,15,11,8,3,6,6,2,2,1,2,,0,4,2,1,1,void
1866,43594,createClusterLink,1,createClusterLink,clusterLink createClusterLink (clusterNode*),cluster.c,"clusterLink *createClusterLink(clusterNode *node) {
    clusterLink *link = zmalloc(sizeof(*link));
    link->ctime = mstime();
    link->send_msg_queue = listCreate();
    listSetFreeMethod(link->send_msg_queue, clusterMsgSendBlockDecrRefCount);
    link->head_msg_send_offset = 0;
    link->send_msg_queue_mem = sizeof(list);
    link->rcvbuf = zmalloc(link->rcvbuf_alloc = RCVBUF_INIT_LEN);
    link->rcvbuf_len = 0;
    server.stat_cluster_links_memory += link->rcvbuf_alloc + link->send_msg_queue_mem;
    link->conn = NULL;
    link->node = node;
    /* Related node can only possibly be known at link creation time if this is an outbound link */
    link->inbound = (node == NULL);
    if (!link->inbound) {
        node->link = link;
    }
    return link;
}",1175.0,1193.0,1.0,4.0,19.0,38,9,26,5,2,20,2,2,1,4,,0,20,2,1,1,clusterLink
1867,43698,freeClusterLink,1,freeClusterLink,void freeClusterLink (clusterLink*),cluster.c,"void freeClusterLink(clusterLink *link) {
    if (link->conn) {
        connClose(link->conn);
        link->conn = NULL;
    }
    server.stat_cluster_links_memory -= sizeof(list) + listLength(link->send_msg_queue)*sizeof(listNode);
    listRelease(link->send_msg_queue);
    server.stat_cluster_links_memory -= link->rcvbuf_alloc;
    zfree(link->rcvbuf);
    if (link->node) {
        if (link->node->link == link) {
            serverAssert(!link->inbound);
            link->node->link = NULL;
        } else if (link->node->inbound_link == link) {
            serverAssert(link->inbound);
            link->node->inbound_link = NULL;
        }
    }
    zfree(link);
}",1198.0,1217.0,1.0,55.0,20.0,33,13,21,5,10,18,4,5,3,5,,0,13,2,1,1,void
1868,43833,setClusterNodeToInboundClusterLink,1,setClusterNodeToInboundClusterLink,"void setClusterNodeToInboundClusterLink (clusterNode*,clusterLink*)",cluster.c,"void setClusterNodeToInboundClusterLink(clusterNode *node, clusterLink *link) {
    serverAssert(!link->node);
    serverAssert(link->inbound);
    if (node->inbound_link) {
        /* A peer may disconnect and then reconnect with us, and it's not guaranteed that
         * we would always process the disconnection of the existing inbound link before
         * accepting a new existing inbound link. Therefore, it's possible to have more than
         * one inbound link from the same node at the same time. Our cleanup logic assumes
         * a one to one relationship between nodes and inbound links, so we need to kill
         * one of the links. The existing link is more likely the outdated one, but it's
         * possible the other node may need to open another link. */
        serverLog(LL_DEBUG, ""Replacing inbound link fd %d from node %.40s with fd %d"",
                node->inbound_link->conn->fd, node->name, link->conn->fd);
        freeClusterLink(node->inbound_link);
    }
...",1219.0,1237.0,1.0,4.0,19.0,37,10,16,3,0,18,2,2,1,5,,0,13,4,2,2,void
1869,43952,clusterConnAcceptHandler,1,clusterConnAcceptHandler,void clusterConnAcceptHandler (connection*),cluster.c,"static void clusterConnAcceptHandler(connection *conn) {
    clusterLink *link;

    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_VERBOSE,
                ""Error accepting cluster node connection: %s"", connGetLastError(conn));
        connClose(conn);
        return;
    }

    /* Create a link object we use to handle the connection.
     * It gets passed to the readable handler when data is available.
     * Initially the link->node pointer is set to NULL as we don't know
     * which node is, but the right node is references once we know the
     * node identity. */
    link = createClusterLink(NULL);
    link->conn = conn;
    connSetPrivateData(conn, link);

    /* Register read handler */
    connSetReadHandler(conn, clusterReadHandler);
}",1239.0,1260.0,1.0,8.0,22.0,7,6,13,6,0,8,2,2,1,7,,0,4,2,1,1,void
1870,44213,getClusterConnectionsCount,1,getClusterConnectionsCount,unsigned long getClusterConnectionsCount (void),cluster.c,"unsigned long getClusterConnectionsCount(void) {
    /* We decrement the number of nodes by one, since there is the
     * ""myself"" node too in the list. Each node uses two file descriptors,
     * one incoming and one outgoing, thus the multiplication by 2. */
    return server.cluster_enabled ?
           ((dictSize(server.cluster->nodes)-1)*2) : 0;
}",1317.0,1323.0,1.0,13.0,7.0,15,7,4,1,2,0,1,1,0,0,,0,0,2,1,1,unsigned long
1871,44254,keyHashSlot,1,keyHashSlot,"unsigned int keyHashSlot (char*,int)",cluster.c,"unsigned int keyHashSlot(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */

    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    /* No '{' ? Hash the whole key. This is the base case. */
    if (s == keylen) return crc16(key,keylen) & 0x3FFF;

    /* '{' found? Check if we have the corresponding '}'. */
    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    /* No '}' or nothing between {} ? Hash the whole key. */
    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;

    /* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */
    return crc16(key+s+1,e-s-1) & 0x3FFF;
}",1335.0,1354.0,1.0,1.0,20.0,17,7,21,4,5,3,5,5,0,3,,0,0,4,2,2,unsigned int
1872,44544,clusterNodeAddFailureReport,1,clusterNodeAddFailureReport,"int clusterNodeAddFailureReport (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
    list *l = failing->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;

    /* If a failure report from the same sender already exists, just update
     * the timestamp. */
    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (fr->node == sender) {
            fr->time = mstime();
            return 0;
        }
    }

    /* Otherwise create a new report. */
    fr = zmalloc(sizeof(*fr));
    fr->node = sender;
    fr->time = mstime();
    listAddNodeTail(l,fr);
    return 1;
}",1416.0,1439.0,1.0,1.0,24.0,19,7,19,7,1,12,3,4,2,6,,0,10,4,2,2,int
1873,44612,clusterNodeCleanupFailureReports,1,clusterNodeCleanupFailureReports,void clusterNodeCleanupFailureReports (clusterNode*),cluster.c,"void clusterNodeCleanupFailureReports(clusterNode *node) {
    list *l = node->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;
    mstime_t maxtime = server.cluster_node_timeout *
                     CLUSTER_FAIL_REPORT_VALIDITY_MULT;
    mstime_t now = mstime();

    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (now - fr->time > maxtime) listDelNode(l,ln);
    }
}",1446.0,1460.0,1.0,21.0,15.0,15,8,17,9,2,7,3,4,2,4,,0,5,2,1,1,void
1874,44670,clusterNodeDelFailureReport,1,clusterNodeDelFailureReport,"int clusterNodeDelFailureReport (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
    list *l = node->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;

    /* Search for a failure report from this sender. */
    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (fr->node == sender) break;
    }
    if (!ln) return 0; /* No failure report from this sender. */

    /* Remove the failure report. */
    listDelNode(l,ln);
    clusterNodeCleanupFailureReports(node);
    return 1;
}",1473.0,1491.0,1.0,1.0,19.0,11,6,15,7,0,7,5,5,2,4,,0,4,4,2,2,int
1875,44724,clusterNodeFailureReportsCount,1,clusterNodeFailureReportsCount,int clusterNodeFailureReportsCount (clusterNode*),cluster.c,"int clusterNodeFailureReportsCount(clusterNode *node) {
    clusterNodeCleanupFailureReports(node);
    return listLength(node->fail_reports);
}",1496.0,1499.0,1.0,11.0,4.0,3,1,3,1,2,3,1,1,0,1,,0,2,2,1,1,int
1876,44742,clusterNodeRemoveSlave,1,clusterNodeRemoveSlave,"int clusterNodeRemoveSlave (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
    int j;

    for (j = 0; j < master->numslaves; j++) {
        if (master->slaves[j] == slave) {
            if ((j+1) < master->numslaves) {
                int remaining_slaves = (master->numslaves - j) - 1;
                memmove(master->slaves+j,master->slaves+(j+1),
                        (sizeof(*master->slaves) * remaining_slaves));
            }
            master->numslaves--;
            if (master->numslaves == 0)
                master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
            return C_OK;
        }
    }
    return C_ERR;
}",1501.0,1518.0,1.0,34.0,18.0,29,13,20,4,1,10,5,10,4,0,,0,10,4,2,2,int
1877,44911,clusterCountNonFailingSlaves,1,clusterCountNonFailingSlaves,int clusterCountNonFailingSlaves (clusterNode*),cluster.c,"int clusterCountNonFailingSlaves(clusterNode *n) {
    int j, okslaves = 0;

    for (j = 0; j < n->numslaves; j++)
        if (!nodeFailed(n->slaves[j])) okslaves++;
    return okslaves;
}",1534.0,1540.0,1.0,13.0,7.0,4,3,5,3,1,1,2,2,1,0,,0,1,2,1,1,int
1878,44956,freeClusterNode,1,freeClusterNode,void freeClusterNode (clusterNode*),redis-benchmark.c,"static void freeClusterNode(clusterNode *node) {
    int i;
    if (node->name) sdsfree(node->name);
    if (node->replicate) sdsfree(node->replicate);
    if (node->migrating != NULL) {
        for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
        zfree(node->migrating);
    }
    if (node->importing != NULL) {
        for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
        zfree(node->importing);
    }
    /* If the node is not the reference node, that uses the address from
     * config.conn_info.hostip and config.conn_info.hostport, then the node ip has been
     * allocated by fetchClusterConfiguration, so it must be freed. */
    if (node->ip && strcmp(node->ip, config.conn_info.hostip) != 0) sdsfree(node->ip);
    if (node->redis_config != NULL) freeRedisConfig(node->redis_config);
    zfree(node->slots);
    zfree(node);
}",1078.0,1097.0,1.0,1.0,20.0,25,11,22,4,1,25,5,5,5,12,,0,14,2,1,1,void
1879,45220,verifyClusterNodeId,1,verifyClusterNodeId,"int verifyClusterNodeId (char*,int)",cluster.c,"int verifyClusterNodeId(const char *name, int length) {
    if (length != CLUSTER_NAMELEN) return C_ERR;
    for (int i = 0; i < length; i++) {
        if (name[i] >= 'a' && name[i] <= 'z') continue;
        if (name[i] >= '0' && name[i] <= '9') continue;
        return C_ERR;
    }
    return C_OK;
}",1625.0,1633.0,1.0,18.0,9.0,15,8,12,3,4,0,7,7,0,0,,0,0,4,2,2,int
1880,45287,clusterLookupNode,1,clusterLookupNode,"clusterNode clusterLookupNode (char*,int)",cluster.c,"clusterNode *clusterLookupNode(const char *name, int length) {
    if (verifyClusterNodeId(name, length) != C_OK) return NULL;
    sds s = sdsnewlen(name, length);
    dictEntry *de = dictFind(server.cluster->nodes, s);
    sdsfree(s);
    if (de == NULL) return NULL;
    return dictGetVal(de);
}",1636.0,1643.0,1.0,45.0,8.0,6,5,14,6,8,5,3,3,1,5,,0,3,4,2,2,clusterNode
1881,45367,clusterRenameNode,1,clusterRenameNode,"void clusterRenameNode (clusterNode*,char*)",cluster.c,"void clusterRenameNode(clusterNode *node, char *newname) {
    int retval;
    sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);

    serverLog(LL_DEBUG,""Renaming node %.40s into %.40s"",
        node->name, newname);
    retval = dictDelete(server.cluster->nodes, s);
    sdsfree(s);
    serverAssert(retval == DICT_OK);
    memcpy(node->name, newname, CLUSTER_NAMELEN);
    clusterAddNode(node);
}",1662.0,1673.0,1.0,34.0,12.0,15,10,13,5,1,9,1,1,0,6,,0,5,4,2,2,void
1882,45736,clusterHandleConfigEpochCollision,1,clusterHandleConfigEpochCollision,void clusterHandleConfigEpochCollision (clusterNode*),cluster.c,"void clusterHandleConfigEpochCollision(clusterNode *sender) {
    /* Prerequisites: nodes have the same configEpoch and are both masters. */
    if (sender->configEpoch != myself->configEpoch ||
        !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
    /* Don't act if the colliding node has a smaller Node ID. */
    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
    /* Get the next ID available at the best of this node knowledge. */
    server.cluster->currentEpoch++;
    myself->configEpoch = server.cluster->currentEpoch;
    clusterSaveConfigOrDie(1);
    serverLog(LL_VERBOSE,
        ""WARNING: configEpoch collision with node %.40s (%s).""
        "" configEpoch set to %llu"",
        sender->name,sender->human_nodename,
        (unsigned long long) myself->configEpoch);
}",1822.0,1837.0,1.0,9.0,16.0,28,11,15,3,1,18,3,3,10,2,,0,16,2,1,1,void
1883,45832,clusterBlacklistCleanup,1,clusterBlacklistCleanup,void clusterBlacklistCleanup (void),cluster.c,"void clusterBlacklistCleanup(void) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes_black_list);
    while((de = dictNext(di)) != NULL) {
        int64_t expire = dictGetUnsignedIntegerVal(de);

        if (expire < server.unixtime)
            dictDelete(server.cluster->nodes_black_list,dictGetKey(de));
    }
    dictReleaseIterator(di);
}",1870.0,1882.0,1.0,1.0,13.0,10,5,12,5,2,6,3,4,1,6,,0,4,2,1,1,void
1884,45877,clusterBlacklistAddNode,1,clusterBlacklistAddNode,void clusterBlacklistAddNode (clusterNode*),cluster.c,"void clusterBlacklistAddNode(clusterNode *node) {
    dictEntry *de;
    sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);

    clusterBlacklistCleanup();
    if (dictAdd(server.cluster->nodes_black_list,id,NULL) == DICT_OK) {
        /* If the key was added, duplicate the sds string representation of
         * the key for the next lookup. We'll free it at the end. */
        id = sdsdup(id);
    }
    de = dictFind(server.cluster->nodes_black_list,id);
    dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
    sdsfree(id);
}",1885.0,1898.0,1.0,34.0,14.0,10,5,13,5,0,8,2,2,1,7,,0,5,2,1,1,void
1885,45931,clusterBlacklistExists,1,clusterBlacklistExists,int clusterBlacklistExists (char*),cluster.c,"int clusterBlacklistExists(char *nodeid) {
    sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);
    int retval;

    clusterBlacklistCleanup();
    retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
    sdsfree(id);
    return retval;
}",1903.0,1911.0,1.0,30.0,9.0,5,4,8,5,0,4,1,1,0,4,,0,2,2,1,1,int
1886,45961,markNodeAsFailingIfNeeded,1,markNodeAsFailingIfNeeded,void markNodeAsFailingIfNeeded (clusterNode*),cluster.c,"void markNodeAsFailingIfNeeded(clusterNode *node) {
    int failures;
    int needed_quorum = (server.cluster->size / 2) + 1;

    if (!nodeTimedOut(node)) return; /* We can reach it. */
    if (nodeFailed(node)) return; /* Already FAILing. */

    failures = clusterNodeFailureReportsCount(node);
    /* Also count myself as a voter if I'm a master. */
    if (nodeIsMaster(myself)) failures++;
    if (failures < needed_quorum) return; /* No weak agreement from masters. */

    serverLog(LL_NOTICE,
        ""Marking node %.40s (%s) as failing (quorum reached)."", node->name, node->human_nodename);

    /* Mark the node as failing. */
    node->flags &= ~CLUSTER_NODE_PFAIL;
    node->flags |= CLUSTER_NODE_FAIL;
    node->fail_time = mstime();

    /* Broadcast the failing node name to everybody, forcing all the other
     * reachable nodes to flag the node as FAIL.
     * We do that even if this node is a replica and not a master: anyway
     * the failing state is triggered collecting f...",1938.0,1965.0,1.0,9.0,28.0,29,12,20,5,1,16,5,5,5,5,,0,13,2,1,1,void
1887,46084,clearNodeFailureIfNeeded,1,clearNodeFailureIfNeeded,void clearNodeFailureIfNeeded (clusterNode*),cluster.c,"void clearNodeFailureIfNeeded(clusterNode *node) {
    mstime_t now = mstime();

    serverAssert(nodeFailed(node));

    /* For slaves we always clear the FAIL flag if we can contact the
     * node again. */
    if (nodeIsSlave(node) || node->numslots == 0) {
        serverLog(LL_NOTICE,
            ""Clear FAIL state for node %.40s (%s):%s is reachable again."",
                node->name,node->human_nodename,
                nodeIsSlave(node) ? ""replica"" : ""master without slots"");
        node->flags &= ~CLUSTER_NODE_FAIL;
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
    }

    /* If it is a master and...
     * 1) The FAIL state is old enough.
     * 2) It is yet serving slots from our point of view (not failed over).
     * Apparently no one is going to fix these slots, clear the FAIL flag. */
    if (nodeIsMaster(node) && node->numslots > 0 &&
        (now - node->fail_time) >
        (server.cluster_node_timeout * CLUSTER_FAIL_UNDO_TIME_MUL...",1970.0,2000.0,1.0,4.0,31.0,46,18,20,3,0,19,3,3,5,6,,0,14,2,1,1,void
1888,46253,clusterHandshakeInProgress,1,clusterHandshakeInProgress,"int clusterHandshakeInProgress (char*,int,int)",cluster.c,"int clusterHandshakeInProgress(char *ip, int port, int cport) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (!nodeInHandshake(node)) continue;
        if (!strcasecmp(node->ip,ip) &&
            getNodeDefaultClientPort(node) == port &&
            node->cport == cport) break;
    }
    dictReleaseIterator(di);
    return de != NULL;
}",2005.0,2020.0,1.0,13.0,16.0,17,8,18,8,1,8,6,6,5,5,,0,7,6,3,3,int
1889,46321,clusterStartHandshake,1,clusterStartHandshake,"int clusterStartHandshake (char*,int,int)",cluster.c,"int clusterStartHandshake(char *ip, int port, int cport) {
    clusterNode *n;
    char norm_ip[NET_IP_STR_LEN];
    struct sockaddr_storage sa;

    /* IP sanity check */
    if (inet_pton(AF_INET,ip,
            &(((struct sockaddr_in *)&sa)->sin_addr)))
    {
        sa.ss_family = AF_INET;
    } else if (inet_pton(AF_INET6,ip,
            &(((struct sockaddr_in6 *)&sa)->sin6_addr)))
    {
        sa.ss_family = AF_INET6;
    } else {
        errno = EINVAL;
        return 0;
    }

    /* Port sanity check */
    if (port <= 0 || port > 65535 || cport <= 0 || cport > 65535) {
        errno = EINVAL;
        return 0;
    }

    /* Set norm_ip as the normalized string representation of the node
     * IP address. */
    memset(norm_ip,0,NET_IP_STR_LEN);
    if (sa.ss_family == AF_INET)
        inet_ntop(AF_INET,
            (void*)&(((struct sockaddr_in *)&sa)->sin_addr),
            norm_ip,NET_IP_STR_LEN);
    else
        inet_ntop(AF_INET6,
            (void*)&(((struct socka...",2029.0,2084.0,1.0,17.0,56.0,32,11,33,12,0,7,6,6,1,3,,0,6,6,3,3,int
1890,46498,getClientPortFromClusterMsg,1,getClientPortFromClusterMsg,"void getClientPortFromClusterMsg (clusterMsg*,int*,int*)",cluster.c,"static void getClientPortFromClusterMsg(clusterMsg *hdr, int *tls_port, int *tcp_port) {
    if (server.tls_cluster) {
        *tls_port = ntohs(hdr->port);
        *tcp_port = ntohs(hdr->pport);
    } else {
        *tls_port = ntohs(hdr->pport);
        *tcp_port = ntohs(hdr->port);
    }
}",2086.0,2094.0,1.0,1.0,9.0,7,4,5,4,2,2,2,2,0,0,,0,2,6,3,3,void
1891,46540,getClientPortFromGossip,1,getClientPortFromGossip,"void getClientPortFromGossip (clusterMsgDataGossip*,int*,int*)",cluster.c,"static void getClientPortFromGossip(clusterMsgDataGossip *g, int *tls_port, int *tcp_port) {
    if (server.tls_cluster) {
        *tls_port = ntohs(g->port);
        *tcp_port = ntohs(g->pport);
    } else {
        *tls_port = ntohs(g->pport);
        *tcp_port = ntohs(g->port);
    }
}",2096.0,2104.0,1.0,1.0,9.0,7,4,5,4,1,2,2,2,0,0,,0,2,6,3,3,void
1892,46582,clusterProcessGossipSection,1,clusterProcessGossipSection,"void clusterProcessGossipSection (clusterMsg*,clusterLink*)",cluster.c,"void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
    uint16_t count = ntohs(hdr->count);
    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;
    clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);

    while(count--) {
        uint16_t flags = ntohs(g->flags);
        clusterNode *node;
        sds ci;

        if (server.verbosity == LL_DEBUG) {
            ci = representClusterNodeFlags(sdsempty(), flags);
            serverLog(LL_DEBUG,""GOSSIP %.40s %s:%d@%d %s"",
                g->nodename,
                g->ip,
                ntohs(g->port),
                ntohs(g->cport),
                ci);
            sdsfree(ci);
        }

        /* Convert port and pport into TCP port and TLS port. */
        int msg_tls_port, msg_tcp_port;
        getClientPortFromGossip(g, &msg_tls_port, &msg_tcp_port);

        /* Update our state accordingly to the gossip sections */
        node = cluster...",2110.0,2226.0,1.0,83.0,117.0,107,21,80,13,2,53,11,32,18,12,,0,47,4,2,2,void
1893,47045,nodeIp2String,1,nodeIp2String,"int nodeIp2String (char*,clusterLink*,char*)",cluster.c,"int nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
    if (announced_ip[0] != '\0') {
        memcpy(buf,announced_ip,NET_IP_STR_LEN);
        buf[NET_IP_STR_LEN-1] = '\0'; /* We are not sure the input is sane. */
        return C_OK;
    } else {
        if (connAddrPeerName(link->conn, buf, NET_IP_STR_LEN, NULL) == -1) {
            serverLog(LL_NOTICE, ""Error converting peer IP to string: %s"",
                link->conn ? connGetLastError(link->conn) : ""no link"");
            return C_ERR;
        }
        return C_OK;
    }
}",2231.0,2244.0,1.0,32.0,14.0,5,4,4,2,2,0,2,2,0,0,,0,0,6,3,3,int
1894,47130,nodeUpdateAddressIfNeeded,1,nodeUpdateAddressIfNeeded,"int nodeUpdateAddressIfNeeded (clusterNode*,clusterLink*,clusterMsg*)",cluster.c,"int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
                              clusterMsg *hdr)
{
    char ip[NET_IP_STR_LEN] = {0};
    int cport = ntohs(hdr->cport);
    int tcp_port, tls_port;
    getClientPortFromClusterMsg(hdr, &tls_port, &tcp_port);

    /* We don't proceed if the link is the same as the sender link, as this
     * function is designed to see if the node link is consistent with the
     * symmetric link that is used to receive PINGs from the node.
     *
     * As a side effect this function never frees the passed 'link', so
     * it is safe to call during packet processing. */
    if (link == node->link) return 0;

    /* If the peer IP is unavailable for some reasons like invalid fd or closed
     * link, just give up the update this time, and the update will be retried
     * in the next round of PINGs */
    if (nodeIp2String(ip,link,hdr->myip) == C_ERR) return 0;

    if (node->tcp_port == tcp_port && node->cport == cport && node->tls_...",2258.0,2297.0,1.0,12.0,40.0,46,12,42,9,2,30,6,6,13,7,,0,26,6,3,3,int
1895,47372,clusterUpdateSlotsConfigWith,1,clusterUpdateSlotsConfigWith,"void clusterUpdateSlotsConfigWith (clusterNode*,uint64_t,unsigned char*)",cluster.c,"void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {
    int j;
    clusterNode *curmaster = NULL, *newmaster = NULL;
    /* The dirty slots list is a list of slots for which we lose the ownership
     * while having still keys inside. This usually happens after a failover
     * or after a manual cluster reconfiguration operated by the admin.
     *
     * If the update message is not able to demote a master to slave (in this
     * case we'll resync with the master updating the whole key space), we
     * need to delete all the keys in the slots we lost ownership. */
    uint16_t dirty_slots[CLUSTER_SLOTS];
    int dirty_slots_count = 0;

    /* We should detect if sender is new master of our shard.
     * We will know it if all our slots were migrated to sender, and sender
     * has no slots except ours */
    int sender_slots = 0;
    int migrated_our_slots = 0;

    /* Here we set curmaster to this node or the node this nod...",2329.0,2465.0,1.0,25.0,137.0,82,14,67,13,1,24,13,24,7,12,,0,15,6,3,3,void
1896,47783,getPingExtLength,1,getPingExtLength,uint32_t getPingExtLength (clusterMsgPingExt*),cluster.c,"static uint32_t getPingExtLength(clusterMsgPingExt *ext) {
    return ntohl(ext->length);
}",2478.0,2480.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,uint32_t
1897,47793,getInitialPingExt,1,getInitialPingExt,"clusterMsgPingExt getInitialPingExt (clusterMsg*,int)",cluster.c,"static clusterMsgPingExt *getInitialPingExt(clusterMsg *hdr, int count) {
    clusterMsgPingExt *initial = (clusterMsgPingExt*) &(hdr->data.ping.gossip[count]);
    return initial;
}",2484.0,2487.0,1.0,1.0,4.0,7,6,4,3,3,1,1,1,0,0,,0,1,4,2,2,clusterMsgPingExt
1898,47816,getNextPingExt,1,getNextPingExt,clusterMsgPingExt getNextPingExt (clusterMsgPingExt*),cluster.c,"static clusterMsgPingExt *getNextPingExt(clusterMsgPingExt *ext) {
    clusterMsgPingExt *next = (clusterMsgPingExt *) (((char *) ext) + getPingExtLength(ext));
    return next;
}",2491.0,2494.0,1.0,1.0,4.0,4,3,4,2,2,1,1,1,0,1,,0,1,2,1,1,clusterMsgPingExt
1899,47834,getAlignedPingExtSize,1,getAlignedPingExtSize,uint32_t getAlignedPingExtSize (uint32_t),cluster.c,"uint32_t getAlignedPingExtSize(uint32_t dataSize) {

    return sizeof(clusterMsgPingExt) + EIGHT_BYTE_ALIGN(dataSize);
}",2497.0,2500.0,1.0,39.0,4.0,5,4,3,2,4,0,1,1,0,0,,0,0,2,1,1,uint32_t
1900,47853,getHostnamePingExtSize,1,getHostnamePingExtSize,uint32_t getHostnamePingExtSize (void),cluster.c,"uint32_t getHostnamePingExtSize(void) {
    if (sdslen(myself->hostname) == 0) {
        return 0;
    }
    return getAlignedPingExtSize(sdslen(myself->hostname) + 1);
}",2502.0,2507.0,1.0,1.0,6.0,4,3,2,1,2,7,2,2,3,3,,0,6,2,1,1,uint32_t
1901,47876,getHumanNodenamePingExtSize,1,getHumanNodenamePingExtSize,uint32_t getHumanNodenamePingExtSize (void),cluster.c,"uint32_t getHumanNodenamePingExtSize(void) {
    if (sdslen(myself->human_nodename) == 0) {
        return 0;
    }
    return getAlignedPingExtSize(sdslen(myself->human_nodename) + 1);
}",2509.0,2514.0,1.0,1.0,6.0,4,3,2,1,2,7,2,2,3,3,,0,6,2,1,1,uint32_t
1902,47899,getShardIdPingExtSize,1,getShardIdPingExtSize,uint32_t getShardIdPingExtSize (void),cluster.c,"uint32_t getShardIdPingExtSize(void) {
    return getAlignedPingExtSize(sizeof(clusterMsgPingExtShardId));
}",2516.0,2518.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,uint32_t
1903,47908,getForgottenNodeExtSize,1,getForgottenNodeExtSize,uint32_t getForgottenNodeExtSize (void),cluster.c,"uint32_t getForgottenNodeExtSize(void) {
    return getAlignedPingExtSize(sizeof(clusterMsgPingExtForgottenNode));
}",2520.0,2522.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,uint32_t
1904,47917,preparePingExt,1,preparePingExt,"void* preparePingExt (clusterMsgPingExt*,uint16_t,uint32_t)",cluster.c,"void *preparePingExt(clusterMsgPingExt *ext, uint16_t type, uint32_t length) {
    ext->type = htons(type);
    ext->length = htonl(length);
    return &ext->ext[0];
}",2524.0,2528.0,1.0,1.0,5.0,7,4,5,3,4,2,1,1,0,0,,0,2,6,3,3,void*
1905,47943,nextPingExt,1,nextPingExt,clusterMsgPingExt nextPingExt (clusterMsgPingExt*),cluster.c,"clusterMsgPingExt *nextPingExt(clusterMsgPingExt *ext) {
    return (clusterMsgPingExt *)((char*)ext + ntohl(ext->length));
}",2530.0,2532.0,1.0,1.0,3.0,4,3,2,1,4,1,1,1,0,0,,0,1,2,1,1,clusterMsgPingExt
1906,47959,writePingExt,1,writePingExt,"uint32_t writePingExt (clusterMsg*,int)",cluster.c,"uint32_t writePingExt(clusterMsg *hdr, int gossipcount)  {
    uint16_t extensions = 0;
    uint32_t totlen = 0;
    clusterMsgPingExt *cursor = NULL;
    /* Set the initial extension position */
    if (hdr != NULL) {
        cursor = getInitialPingExt(hdr, gossipcount);
    }

    /* hostname is optional */
    if (sdslen(myself->hostname) != 0) {
        if (cursor != NULL) {
            /* Populate hostname */
            clusterMsgPingExtHostname *ext = preparePingExt(cursor, CLUSTERMSG_EXT_TYPE_HOSTNAME, getHostnamePingExtSize());
            memcpy(ext->hostname, myself->hostname, sdslen(myself->hostname));

            /* Move the write cursor */
            cursor = nextPingExt(cursor);
        }

        totlen += getHostnamePingExtSize();
        extensions++;
    }

    if (sdslen(myself->human_nodename) != 0) {
        if (cursor != NULL) {
            /* Populate human_nodename */
            clusterMsgPingExtHumanNodename *ext = preparePingExt(cursor, CLUSTERMSG_EXT_T...",2540.0,2619.0,1.0,8.0,80.0,71,13,83,17,0,48,14,22,7,27,,0,40,4,2,2,uint32_t
1907,48239,clusterProcessPingExtensions,1,clusterProcessPingExtensions,"void clusterProcessPingExtensions (clusterMsg*,clusterLink*)",cluster.c,"void clusterProcessPingExtensions(clusterMsg *hdr, clusterLink *link) {
    clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);
    char *ext_hostname = NULL;
    char *ext_humannodename = NULL;
    char *ext_shardid = NULL;
    uint16_t extensions = ntohs(hdr->extensions);
    /* Loop through all the extensions and process them */
    clusterMsgPingExt *ext = getInitialPingExt(hdr, ntohs(hdr->count));
    while (extensions--) {
        uint16_t type = ntohs(ext->type);
        if (type == CLUSTERMSG_EXT_TYPE_HOSTNAME) {
            clusterMsgPingExtHostname *hostname_ext = (clusterMsgPingExtHostname *) &(ext->ext[0].hostname);
            ext_hostname = hostname_ext->hostname;
	} else if (type == CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME) {
            clusterMsgPingExtHumanNodename *humannodename_ext = (clusterMsgPingExtHumanNodename *) &(ext->ext[0].human_nodename);
            ext_humannodename = humannodename_ext->human_nodename;
        } ...",2623.0,2669.0,1.0,83.0,47.0,25,9,32,12,1,13,3,4,0,6,,0,10,4,2,2,void
1908,48529,getNodeFromLinkAndMsg,1,getNodeFromLinkAndMsg,"clusterNode getNodeFromLinkAndMsg (clusterLink*,clusterMsg*)",cluster.c,"static clusterNode *getNodeFromLinkAndMsg(clusterLink *link, clusterMsg *hdr) {
    clusterNode *sender;
    if (link->node && !nodeInHandshake(link->node)) {
        /* If the link has an associated node, use that so that we don't have to look it
         * up every time, except when the node is still in handshake, the node still has
         * a random name thus not truly ""known"". */
        sender = link->node;
    } else {
        /* Otherwise, fetch sender based on the message */
        sender = clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);
        /* We know the sender node but haven't associate it with the link. This must
         * be an inbound link because only for inbound links we didn't know which node
         * to associate when they were created. */
        if (sender && !link->node) {
            setClusterNodeToInboundClusterLink(sender, link);
        }
    }
    return sender;
}",2671.0,2689.0,1.0,23.0,19.0,9,5,6,2,1,4,2,2,3,0,,0,4,4,2,2,clusterNode
1909,48584,clusterProcessPacket,1,clusterProcessPacket,int clusterProcessPacket (clusterLink*),cluster.c,"int clusterProcessPacket(clusterLink *link) {
    clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
    uint32_t totlen = ntohl(hdr->totlen);
    uint16_t type = ntohs(hdr->type);
    mstime_t now = mstime();

    if (type < CLUSTERMSG_TYPE_COUNT)
        server.cluster->stats_bus_messages_received[type]++;
    serverLog(LL_DEBUG,""--- Processing packet of type %s, %lu bytes"",
        clusterGetMessageTypeString(type), (unsigned long) totlen);

    /* Perform sanity checks */
    if (totlen < 16) return 1; /* At least signature, version, totlen, count. */
    if (totlen > link->rcvbuf_len) return 1;

    if (ntohs(hdr->ver) != CLUSTER_PROTO_VER) {
        /* Can't handle messages of different versions. */
        return 1;
    }

    if (type == server.cluster_drop_packet_filter) {
        serverLog(LL_WARNING, ""Dropping packet that matches debug drop filter"");
        return 1;
    }

    uint16_t flags = ntohs(hdr->flags);
    uint16_t extensions = ntohs(hdr->extensions);
    uint64_t ...",2700.0,3218.0,1.0,15.0,519.0,320,28,246,26,0,135,45,98,38,52,,0,102,2,1,1,int
1910,50800,handleLinkIOError,1,handleLinkIOError,void handleLinkIOError (clusterLink*),cluster.c,"void handleLinkIOError(clusterLink *link) {
    freeClusterLink(link);
}",3226.0,3228.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
1911,50807,clusterWriteHandler,1,clusterWriteHandler,void clusterWriteHandler (connection*),cluster.c,"void clusterWriteHandler(connection *conn) {
    clusterLink *link = connGetPrivateData(conn);
    ssize_t nwritten;
    size_t totwritten = 0;

    while (totwritten < NET_MAX_WRITES_PER_EVENT && listLength(link->send_msg_queue) > 0) {
        listNode *head = listFirst(link->send_msg_queue);
        clusterMsgSendBlock *msgblock = (clusterMsgSendBlock*)head->value;
        clusterMsg *msg = &msgblock->msg;
        size_t msg_offset = link->head_msg_send_offset;
        size_t msg_len = ntohl(msg->totlen);

        nwritten = connWrite(conn, (char*)msg + msg_offset, msg_len - msg_offset);
        if (nwritten <= 0) {
            serverLog(LL_DEBUG,""I/O error writing to node link: %s"",
                (nwritten == -1) ? connGetLastError(conn) : ""short write"");
            handleLinkIOError(link);
            return;
        }
        if (msg_offset + nwritten < msg_len) {
            /* If full message wasn't written, record the offset
             * and continue sending from this p...",3231.0,3270.0,1.0,24.0,40.0,62,21,52,13,0,24,5,7,4,8,,0,19,2,1,1,void
1912,51014,clusterLinkConnectHandler,1,clusterLinkConnectHandler,void clusterLinkConnectHandler (connection*),cluster.c,"void clusterLinkConnectHandler(connection *conn) {
    clusterLink *link = connGetPrivateData(conn);
    clusterNode *node = link->node;

    /* Check if connection succeeded */
    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_VERBOSE, ""Connection with Node %.40s at %s:%d failed: %s"",
                node->name, node->ip, node->cport,
                connGetLastError(conn));
        freeClusterLink(link);
        return;
    }

    /* Register a read handler from now on */
    connSetReadHandler(conn, clusterReadHandler);

    /* Queue a PING in the new connection ASAP: this is crucial
     * to avoid false positives in failure detection.
     *
     * If the node is flagged as MEET, we send a MEET message instead
     * of a PING one, to force the receiver to add us in its node
     * table. */
    mstime_t old_ping_sent = node->ping_sent;
    clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?
            CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
...",3275.0,3315.0,1.0,8.0,41.0,25,8,26,7,0,19,3,3,1,8,,0,14,2,1,1,void
1913,51496,clusterSendMessage,1,clusterSendMessage,"void clusterSendMessage (clusterLink*,clusterMsgSendBlock*)",cluster.c,"void clusterSendMessage(clusterLink *link, clusterMsgSendBlock *msgblock) {
    if (!link) {
        return;
    }
    if (listLength(link->send_msg_queue) == 0 && msgblock->msg.totlen != 0)
        connSetWriteHandlerWithBarrier(link->conn, clusterWriteHandler, 1);

    listAddNodeTail(link->send_msg_queue, msgblock);
    msgblock->refcount++;

    /* Update memory tracking */
    link->send_msg_queue_mem += sizeof(listNode) + msgblock->totlen;
    server.stat_cluster_links_memory += sizeof(listNode);

    /* Populate sent messages stats. */
    uint16_t type = ntohs(msgblock->msg.type);
    if (type < CLUSTERMSG_TYPE_COUNT)
        server.cluster->stats_bus_messages_sent[type]++;
}",3409.0,3427.0,1.0,8.0,19.0,29,13,18,5,5,11,4,4,3,2,,0,9,4,2,2,void
1914,51584,clusterBroadcastMessage,1,clusterBroadcastMessage,void clusterBroadcastMessage (clusterMsgSendBlock*),cluster.c,"void clusterBroadcastMessage(clusterMsgSendBlock *msgblock) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
            continue;
        clusterSendMessage(node->link,msgblock);
    }
    dictReleaseIterator(di);
}",3435.0,3448.0,1.0,27.0,14.0,10,6,11,6,2,7,4,4,2,5,,0,5,2,1,1,void
1915,51930,clusterSetGossipEntry,1,clusterSetGossipEntry,"void clusterSetGossipEntry (clusterMsg*,int,clusterNode*)",cluster.c,"void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
    clusterMsgDataGossip *gossip;
    gossip = &(hdr->data.ping.gossip[i]);
    memcpy(gossip->nodename,n->name,CLUSTER_NAMELEN);
    gossip->ping_sent = htonl(n->ping_sent/1000);
    gossip->pong_received = htonl(n->pong_received/1000);
    memcpy(gossip->ip,n->ip,sizeof(n->ip));
    if (server.tls_cluster) {
        gossip->port = htons(n->tls_port);
        gossip->pport = htons(n->tcp_port);
    } else {
        gossip->port = htons(n->tcp_port);
        gossip->pport = htons(n->tls_port);
    }
    gossip->cport = htons(n->cport);
    gossip->flags = htons(n->flags);
    gossip->notused1 = 0;
}",3518.0,3535.0,1.0,36.0,18.0,35,7,22,5,0,19,2,2,0,0,,0,19,6,3,3,void
1916,52442,clusterBroadcastPong,1,clusterBroadcastPong,void clusterBroadcastPong (int),cluster.c,"void clusterBroadcastPong(int target) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (!node->link) continue;
        if (node == myself || nodeInHandshake(node)) continue;
        if (target == CLUSTER_BROADCAST_LOCAL_SLAVES) {
            int local_slave =
                nodeIsSlave(node) && node->slaveof &&
                (node->slaveof == myself || node->slaveof == myself->slaveof);
            if (!local_slave) continue;
        }
        clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
    }
    dictReleaseIterator(di);
}",3685.0,3704.0,1.0,30.0,20.0,27,9,24,8,1,16,9,11,4,5,,0,14,2,1,1,void
1917,52542,clusterCreatePublishMsgBlock,1,clusterCreatePublishMsgBlock,"clusterMsgSendBlock clusterCreatePublishMsgBlock (robj*,robj*,uint16_t)",cluster.c,"clusterMsgSendBlock *clusterCreatePublishMsgBlock(robj *channel, robj *message, uint16_t type) {

    uint32_t channel_len, message_len;

    channel = getDecodedObject(channel);
    message = getDecodedObject(message);
    channel_len = sdslen(channel->ptr);
    message_len = sdslen(message->ptr);

    size_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    msglen += sizeof(clusterMsgDataPublish) - 8 + channel_len + message_len;
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(type, msglen);

    clusterMsg *hdr = &msgblock->msg;
    hdr->data.publish.msg.channel_len = htonl(channel_len);
    hdr->data.publish.msg.message_len = htonl(message_len);
    memcpy(hdr->data.publish.msg.bulk_data,channel->ptr,sdslen(channel->ptr));
    memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),
        message->ptr,sdslen(message->ptr));

    decrRefCount(channel);
    decrRefCount(message);
    
    return msgblock;
}",3713.0,3737.0,1.0,1.0,25.0,43,8,34,11,2,15,1,1,0,10,,0,10,6,3,3,clusterMsgSendBlock
1918,52862,clusterSendModule,1,clusterSendModule,"void clusterSendModule (clusterLink*,uint64_t,uint8_t,char*,uint32_t)",cluster.c,"void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
                       const char *payload, uint32_t len) {
    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    msglen += sizeof(clusterMsgModule) - 3 + len;
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_MODULE, msglen);

    clusterMsg *hdr = &msgblock->msg;
    hdr->data.module.msg.module_id = module_id; /* Already endian adjusted. */
    hdr->data.module.msg.type = type;
    hdr->data.module.msg.len = htonl(len);
    memcpy(hdr->data.module.msg.bulk_data,payload,len);

    if (link)
        clusterSendMessage(link,msgblock);
    else
        clusterBroadcastMessage(msgblock);

    clusterMsgSendBlockDecrRefCount(msgblock);
}",3782.0,3800.0,1.0,62.0,19.0,31,8,23,11,1,8,2,2,0,3,,0,6,10,5,5,void
1919,52960,clusterSendModuleMessageToTarget,1,clusterSendModuleMessageToTarget,"int clusterSendModuleMessageToTarget (char*,uint64_t,uint8_t,char*,uint32_t)",cluster.c,"int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, const char *payload, uint32_t len) {
    clusterNode *node = NULL;

    if (target != NULL) {
        node = clusterLookupNode(target, strlen(target));
        if (node == NULL || node->link == NULL) return C_ERR;
    }

    clusterSendModule(target ? node->link : NULL,
                      module_id, type, payload, len);
    return C_OK;
}",3808.0,3819.0,1.0,55.0,12.0,10,7,18,7,1,4,3,4,1,2,,0,3,10,5,5,int
1920,53015,clusterPropagatePublish,1,clusterPropagatePublish,"void clusterPropagatePublish (robj*,robj*,int)",cluster.c,"void clusterPropagatePublish(robj *channel, robj *message, int sharded) {
    clusterMsgSendBlock *msgblock;

    if (!sharded) {
        msgblock = clusterCreatePublishMsgBlock(channel, message, CLUSTERMSG_TYPE_PUBLISH);
        clusterBroadcastMessage(msgblock);
        clusterMsgSendBlockDecrRefCount(msgblock);
        return;
    }

    listIter li;
    listNode *ln;
    list *nodes_for_slot = clusterGetNodesInMyShard(server.cluster->myself);
    serverAssert(nodes_for_slot != NULL);
    listRewind(nodes_for_slot, &li);
    msgblock = clusterCreatePublishMsgBlock(channel, message, CLUSTERMSG_TYPE_PUBLISHSHARD);
    while((ln = listNext(&li))) {
        clusterNode *node = listNodeValue(ln);
        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
            continue;
        clusterSendMessage(node->link,msgblock);
    }
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3831.0,3854.0,1.0,66.0,24.0,20,12,24,10,1,13,5,5,2,10,,0,7,6,3,3,void
1921,53116,clusterRequestFailoverAuth,1,clusterRequestFailoverAuth,void clusterRequestFailoverAuth (void),cluster.c,"void clusterRequestFailoverAuth(void) {
    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST, msglen);

    clusterMsg *hdr = &msgblock->msg;
    /* If this is a manual failover, set the CLUSTERMSG_FLAG0_FORCEACK bit
     * in the header to communicate the nodes receiving the message that
     * they should authorized the failover even if the master is working. */
    if (server.cluster->mf_end) hdr->mflags[0] |= CLUSTERMSG_FLAG0_FORCEACK;
    clusterBroadcastMessage(msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3866.0,3877.0,1.0,62.0,12.0,13,8,11,6,0,5,2,2,0,3,,0,3,2,1,1,void
1922,53166,clusterSendFailoverAuth,1,clusterSendFailoverAuth,void clusterSendFailoverAuth (clusterNode*),cluster.c,"void clusterSendFailoverAuth(clusterNode *node) {
    if (!node->link) return;

    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK, msglen);

    clusterSendMessage(node->link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3880.0,3888.0,1.0,62.0,9.0,8,5,9,5,0,5,2,2,1,3,,0,3,2,1,1,void
1923,53201,clusterSendMFStart,1,clusterSendMFStart,void clusterSendMFStart (clusterNode*),cluster.c,"void clusterSendMFStart(clusterNode *node) {
    if (!node->link) return;

    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_MFSTART, msglen);

    clusterSendMessage(node->link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3891.0,3899.0,1.0,62.0,9.0,8,5,9,5,0,5,2,2,1,3,,0,3,2,1,1,void
1924,53743,clusterGetSlaveRank,1,clusterGetSlaveRank,int clusterGetSlaveRank (void),cluster.c,"int clusterGetSlaveRank(void) {
    long long myoffset;
    int j, rank = 0;
    clusterNode *master;

    serverAssert(nodeIsSlave(myself));
    master = myself->slaveof;
    if (master == NULL) return 0; /* Never called by slaves without master. */

    myoffset = replicationGetSlaveOffset();
    for (j = 0; j < master->numslaves; j++)
        if (master->slaves[j] != myself &&
            !nodeCantFailover(master->slaves[j]) &&
            master->slaves[j]->repl_offset > myoffset) rank++;
    return rank;
}",4017.0,4032.0,1.0,4.0,16.0,14,9,11,6,0,7,3,3,1,2,,0,6,2,1,1,int
1925,53841,clusterLogCantFailover,1,clusterLogCantFailover,void clusterLogCantFailover (int),cluster.c,"void clusterLogCantFailover(int reason) {
    char *msg;
    static time_t lastlog_time = 0;
    mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;

    /* Don't log if we have the same reason for some time. */
    if (reason == server.cluster->cant_failover_reason &&
        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
        return;

    server.cluster->cant_failover_reason = reason;

    /* We also don't emit any log if the master failed no long ago, the
     * goal of this function is to log slaves in a stalled condition for
     * a long time. */
    if (myself->slaveof &&
        nodeFailed(myself->slaveof) &&
        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;

    switch(reason) {
    case CLUSTER_CANT_FAILOVER_DATA_AGE:
        msg = ""Disconnected from master for longer than allowed. ""
              ""Please check the 'cluster-replica-validity-factor' configuration ""
              ""option."";
        break;
    case CLUSTER...",4056.0,4103.0,1.0,34.0,48.0,47,11,33,9,0,11,10,5,9,3,,0,9,2,1,1,void
1926,54030,clusterFailoverReplaceYourMaster,1,clusterFailoverReplaceYourMaster,void clusterFailoverReplaceYourMaster (void),cluster.c,"void clusterFailoverReplaceYourMaster(void) {
    int j;
    clusterNode *oldmaster = myself->slaveof;

    if (nodeIsMaster(myself) || oldmaster == NULL) return;

    /* 1) Turn this node into a master. */
    clusterSetNodeAsMaster(myself);
    replicationUnsetMaster();

    /* 2) Claim all the slots assigned to our master. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (clusterNodeGetSlotBit(oldmaster,j)) {
            clusterDelSlot(j);
            clusterAddSlot(myself,j);
        }
    }

    /* 3) Update state and save config. */
    clusterUpdateState();
    clusterSaveConfigOrDie(1);

    /* 4) Pong all the other nodes so that they can update the state
     *    accordingly and detect that we switched to master role. */
    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);

    /* 5) If there was a manual failover in progress, clear the state. */
    resetManualFailover();
}",4111.0,4139.0,1.0,8.0,29.0,8,6,14,4,0,16,4,5,4,9,,0,8,2,1,1,void
1927,55043,manualFailoverCheckTimeout,1,manualFailoverCheckTimeout,void manualFailoverCheckTimeout (void),cluster.c,"void manualFailoverCheckTimeout(void) {
    if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {
        serverLog(LL_WARNING,""Manual failover timed out."");
        resetManualFailover();
    }
}",4479.0,4484.0,1.0,8.0,6.0,9,5,3,1,1,3,2,2,1,3,,0,1,2,1,1,void
1928,55082,clusterHandleManualFailover,1,clusterHandleManualFailover,void clusterHandleManualFailover (void),cluster.c,"void clusterHandleManualFailover(void) {
    /* Return ASAP if no manual failover is in progress. */
    if (server.cluster->mf_end == 0) return;

    /* If mf_can_start is non-zero, the failover was already triggered so the
     * next steps are performed by clusterHandleSlaveFailover(). */
    if (server.cluster->mf_can_start) return;

    if (server.cluster->mf_master_offset == -1) return; /* Wait for offset... */

    if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
        /* Our replication offset matches the master replication offset
         * announced after clients were paused. We can start the failover. */
        server.cluster->mf_can_start = 1;
        serverLog(LL_NOTICE,
            ""All master replication stream processed, ""
            ""manual failover can start."");
        clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
        return;
    }
    clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_MANUALFAILOVER);
}",4488.0,4509.0,1.0,8.0,22.0,20,8,6,1,2,4,5,5,1,4,,0,1,2,1,1,void
1929,55163,clusterNodeCronHandleReconnect,1,clusterNodeCronHandleReconnect,"int clusterNodeCronHandleReconnect (clusterNode*,mstime_t,mstime_t)",cluster.c,"static int clusterNodeCronHandleReconnect(clusterNode *node, mstime_t handshake_timeout, mstime_t now) {
    /* Not interested in reconnecting the link with myself or nodes
     * for which we have no address. */
    if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) return 1;

    if (node->flags & CLUSTER_NODE_PFAIL)
        server.cluster->stats_pfail_nodes++;

    /* A Node in HANDSHAKE state has a limited lifespan equal to the
     * configured node timeout. */
    if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {
        clusterDelNode(node);
        return 1;
    }

    if (node->link == NULL) {
        clusterLink *link = createClusterLink(node);
        link->conn = connCreate(connTypeOfCluster());
        connSetPrivateData(link->conn, link);
        if (connConnect(link->conn, node->ip, node->cport, server.bind_source_addr,
                    clusterLinkConnectHandler) == C_ERR) {
            /* We got a synchronous error from connect before...",4518.0,4554.0,1.0,23.0,37.0,36,12,27,6,1,23,7,10,10,9,,0,19,6,3,3,int
1930,55311,freeClusterLinkOnBufferLimitReached,1,freeClusterLinkOnBufferLimitReached,void freeClusterLinkOnBufferLimitReached (clusterLink*),cluster.c,"static void freeClusterLinkOnBufferLimitReached(clusterLink *link) {
    if (link == NULL || server.cluster_link_msg_queue_limit_bytes == 0) {
        return;
    }

    unsigned long long mem_link = link->send_msg_queue_mem;
    if (mem_link > server.cluster_link_msg_queue_limit_bytes) {
        serverLog(LL_WARNING, ""Freeing cluster link(%s node %.40s, used memory: %llu) due to ""
                ""exceeding send buffer memory limit."", link->inbound ? ""from"" : ""to"",
                link->node ? link->node->name : """", mem_link);
        freeClusterLink(link);
        server.cluster->stat_cluster_links_buffer_limit_exceeded++;
    }
}",4556.0,4569.0,1.0,8.0,14.0,20,10,14,4,2,6,3,3,0,2,,0,4,2,1,1,void
1931,55384,clusterNodeCronFreeLinkOnBufferLimitReached,1,clusterNodeCronFreeLinkOnBufferLimitReached,void clusterNodeCronFreeLinkOnBufferLimitReached (clusterNode*),cluster.c,"static void clusterNodeCronFreeLinkOnBufferLimitReached(clusterNode *node) {
    freeClusterLinkOnBufferLimitReached(node->link);
    freeClusterLinkOnBufferLimitReached(node->inbound_link);
}",4572.0,4575.0,1.0,1.0,4.0,2,1,2,1,1,4,1,1,0,2,,0,2,2,1,1,void
1932,55397,clusterCron,1,clusterCron,void clusterCron (void),cluster.c,"void clusterCron(void) {
    dictIterator *di;
    dictEntry *de;
    int update_state = 0;
    int orphaned_masters; /* How many masters there are without ok slaves. */
    int max_slaves; /* Max number of ok slaves for a single master. */
    int this_slaves; /* Number of ok slaves for our master (if we are slave). */
    mstime_t min_pong = 0, now = mstime();
    clusterNode *min_pong_node = NULL;
    static unsigned long long iteration = 0;
    mstime_t handshake_timeout;

    iteration++; /* Number of times this function was called so far. */

    clusterUpdateMyselfHostname();

    /* The handshake timeout is the time after which a handshake node that was
     * not turned into a normal node is removed from the nodes. Usually it is
     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use
     * the value of 1 second. */
    handshake_timeout = server.cluster_node_timeout;
    if (handshake_timeout < 1000) handshake_timeout = 1000;

    /* Clear so clusterN...",4578.0,4779.0,1.0,31.0,202.0,184,19,146,22,1,81,34,53,41,29,,0,65,2,1,1,void
1933,56022,clusterBeforeSleep,1,clusterBeforeSleep,void clusterBeforeSleep (void),cluster.c,"void clusterBeforeSleep(void) {
    int flags = server.cluster->todo_before_sleep;

    /* Reset our flags (not strictly needed since every single function
     * called for flags set should be able to clear its flag). */
    server.cluster->todo_before_sleep = 0;

    if (flags & CLUSTER_TODO_HANDLE_MANUALFAILOVER) {
        /* Handle manual failover as soon as possible so that won't have a 100ms
         * as it was handled only in clusterCron */
        if(nodeIsSlave(myself)) {
            clusterHandleManualFailover();
            if (!(server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_FAILOVER))
                clusterHandleSlaveFailover();
        }
    } else if (flags & CLUSTER_TODO_HANDLE_FAILOVER) {
        /* Handle failover, this is needed when it is likely that there is already
         * the quorum from masters in order to react fast. */
        clusterHandleSlaveFailover();
    }

    /* Update the cluster state. */
    if (flags & CLUSTER_TODO_UPDATE_STATE)
     ...",4786.0,4816.0,1.0,16.0,31.0,21,6,12,4,1,7,6,9,3,4,,0,3,2,1,1,void
1934,56209,clusterMastersHaveSlaves,1,clusterMastersHaveSlaves,int clusterMastersHaveSlaves (void),cluster.c,"int clusterMastersHaveSlaves(void) {
    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
    dictEntry *de;
    int slaves = 0;
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (nodeIsSlave(node)) continue;
        slaves += node->numslaves;
    }
    dictReleaseIterator(di);
    return slaves != 0;
}",4851.0,4863.0,1.0,12.0,13.0,12,6,14,6,0,6,4,4,2,4,,0,5,2,1,1,int
1935,56308,clusterNodeClearSlotBit,1,clusterNodeClearSlotBit,"int clusterNodeClearSlotBit (clusterNode*,int)",cluster.c,"int clusterNodeClearSlotBit(clusterNode *n, int slot) {
    int old = bitmapTestBit(n->slots,slot);
    if (old) {
        bitmapClearBit(n->slots,slot);
        n->numslots--;
    }
    return old;
}",4891.0,4898.0,1.0,1.0,8.0,5,3,8,3,0,5,2,2,0,2,,0,4,4,2,2,int
1936,56856,verifyClusterConfigWithData,1,verifyClusterConfigWithData,int verifyClusterConfigWithData (void),cluster.c,"int verifyClusterConfigWithData(void) {
    int j;
    int update_config = 0;

    /* Return ASAP if a module disabled cluster redirections. In that case
     * every master can store keys about every possible hash slot. */
    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
        return C_OK;

    /* If this node is a slave, don't perform the check at all as we
     * completely depend on the replication stream. */
    if (nodeIsSlave(myself)) return C_OK;

    /* Make sure we only have keys in DB0. */
    for (j = 1; j < server.dbnum; j++) {
        if (dictSize(server.db[j].dict)) return C_ERR;
    }

    /* Check that all the slots we see populated memory have a corresponding
     * entry in the cluster table. Otherwise fix the table. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (!countKeysInSlot(j)) continue; /* No keys in this slot. */
        /* Check if we are assigned to this slot or if we are importing it.
         * In both cases check t...",5090.0,5137.0,1.0,38.0,48.0,44,14,31,5,0,9,12,14,5,4,,0,6,2,1,1,int
1937,57341,clusterGenNodeDescription,1,clusterGenNodeDescription,"sds clusterGenNodeDescription (client*,clusterNode*,int)",cluster.c,"sds clusterGenNodeDescription(client *c, clusterNode *node, int tls_primary) {
    int j, start;
    sds ci;
    int port = getNodeClientPort(node, tls_primary);

    /* Node coordinates */
    ci = sdscatlen(sdsempty(),node->name,CLUSTER_NAMELEN);
    ci = sdscatfmt(ci,"" %s:%i@%i"",
        node->ip,
        port,
        node->cport);
    if (sdslen(node->hostname) != 0) {
        ci = sdscatfmt(ci,"",%s"", node->hostname);
    }
    if (sdslen(node->hostname) == 0) {
        ci = sdscatfmt(ci,"","", 1);
    }
    /* Don't expose aux fields to any clients yet but do allow them
     * to be persisted to nodes.conf */
    if (c == NULL) {
        for (int i = af_count-1; i >=0; i--) {
            if ((tls_primary && i == af_tls_port) || (!tls_primary && i == af_tcp_port)) {
                continue;
            }
            if (auxFieldHandlers[i].isPresent(node)) {
                ci = sdscatprintf(ci, "",%s="", auxFieldHandlers[i].field);
                ci = auxFieldHandlers[i].getter(...",5219.0,5313.0,1.0,41.0,95.0,74,15,81,14,1,40,14,21,10,16,,0,40,6,3,3,sds
1938,57765,clusterGenNodesSlotsInfo,1,clusterGenNodesSlotsInfo,void clusterGenNodesSlotsInfo (int),cluster.c,"void clusterGenNodesSlotsInfo(int filter) {
    clusterNode *n = NULL;
    int start = -1;

    for (int i = 0; i <= CLUSTER_SLOTS; i++) {
        /* Find start node and slot id. */
        if (n == NULL) {
            if (i == CLUSTER_SLOTS) break;
            n = server.cluster->slots[i];
            start = i;
            continue;
        }

        /* Generate slots info when occur different node with start
         * or end of slot. */
        if (i == CLUSTER_SLOTS || n != server.cluster->slots[i]) {
            if (!(n->flags & filter)) {
                if (!n->slot_info_pairs) {
                    n->slot_info_pairs = zmalloc(2 * n->numslots * sizeof(uint16_t));
                }
                serverAssert((n->slot_info_pairs_count + 1) < (2 * n->numslots));
                n->slot_info_pairs[n->slot_info_pairs_count++] = start;
                n->slot_info_pairs[n->slot_info_pairs_count++] = i-1;
            }
            if (i == CLUSTER_SLOTS) break;
            n = ...",5319.0,5348.0,1.0,25.0,30.0,55,21,37,7,2,12,11,19,2,2,,0,11,2,1,1,void
1939,57948,clusterGenNodesDescription,1,clusterGenNodesDescription,"sds clusterGenNodesDescription (client*,int,int)",cluster.c,"sds clusterGenNodesDescription(client *c, int filter, int tls_primary) {
    sds ci = sdsempty(), ni;
    dictIterator *di;
    dictEntry *de;

    /* Generate all nodes slots info firstly. */
    clusterGenNodesSlotsInfo(filter);

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node->flags & filter) continue;
        ni = clusterGenNodeDescription(c, node, tls_primary);
        ci = sdscatsds(ci,ni);
        sdsfree(ni);
        ci = sdscatlen(ci,""\n"",1);

        /* Release slots info. */
        clusterFreeNodesSlotsInfo(node);
    }
    dictReleaseIterator(di);
    return ci;
}",5371.0,5394.0,1.0,1.0,24.0,12,5,24,10,2,12,4,4,2,11,,0,8,6,3,3,sds
1940,58018,addReplyClusterLinkDescription,1,addReplyClusterLinkDescription,"void addReplyClusterLinkDescription (client*,clusterLink*)",cluster.c,"void addReplyClusterLinkDescription(client *c, clusterLink *link) {
    addReplyMapLen(c, 6);

    addReplyBulkCString(c, ""direction"");
    addReplyBulkCString(c, link->inbound ? ""from"" : ""to"");

    /* addReplyClusterLinkDescription is only called for links that have been
     * associated with nodes. The association is always bi-directional, so
     * in addReplyClusterLinkDescription, link->node should never be NULL. */
    serverAssert(link->node);
    sds node_name = sdsnewlen(link->node->name, CLUSTER_NAMELEN);
    addReplyBulkCString(c, ""node"");
    addReplyBulkCString(c, node_name);
    sdsfree(node_name);

    addReplyBulkCString(c, ""create-time"");
    addReplyLongLong(c, link->ctime);

    char events[3], *p;
    p = events;
    if (link->conn) {
        if (connHasReadHandler(link->conn)) *p++ = 'r';
        if (connHasWriteHandler(link->conn)) *p++ = 'w';
    }
    *p = '\0';
    addReplyBulkCString(c, ""events"");
    addReplyBulkCString(c, events);

    addReplyBulkCStri...",5398.0,5431.0,1.0,4.0,34.0,26,8,32,5,2,28,4,6,5,18,,0,13,4,2,2,void
1941,58143,addReplyClusterLinksDescription,1,addReplyClusterLinksDescription,void addReplyClusterLinksDescription (client*),cluster.c,"void addReplyClusterLinksDescription(client *c) {
    dictIterator *di;
    dictEntry *de;
    void *arraylen_ptr = NULL;
    int num_links = 0;

    arraylen_ptr = addReplyDeferredLen(c);

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->link) {
            num_links++;
            addReplyClusterLinkDescription(c, node->link);
        }
        if (node->inbound_link) {
            num_links++;
            addReplyClusterLinkDescription(c, node->inbound_link);
        }
    }
    dictReleaseIterator(di);

    setDeferredArrayLen(c, arraylen_ptr, num_links);
}",5435.0,5458.0,1.0,1.0,24.0,15,5,24,8,0,12,4,6,3,8,,0,8,2,1,1,void
1942,58213,getPreferredEndpoint,1,getPreferredEndpoint,const char* getPreferredEndpoint (clusterNode*),cluster.c,"const char *getPreferredEndpoint(clusterNode *n) {
    switch(server.cluster_preferred_endpoint_type) {
    case CLUSTER_ENDPOINT_TYPE_IP: return n->ip;
    case CLUSTER_ENDPOINT_TYPE_HOSTNAME: return (sdslen(n->hostname) != 0) ? n->hostname : ""?"";
    case CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT: return """";
    }
    return ""unknown"";
}",5464.0,5471.0,1.0,1.0,8.0,6,4,7,5,1,4,2,2,0,1,,0,3,2,1,1,const char*
1943,58325,getSlotOrReply,1,getSlotOrReply,"int getSlotOrReply (client*,robj*)",cluster.c,"int getSlotOrReply(client *c, robj *o) {
    long long slot;

    if (getLongLongFromObject(o,&slot) != C_OK ||
        slot < 0 || slot >= CLUSTER_SLOTS)
    {
        addReplyError(c,""Invalid or out of range slot"");
        return -1;
    }
    return (int) slot;
}",5490.0,5500.0,1.0,42.0,11.0,8,7,6,3,0,2,2,2,1,2,,0,1,4,2,2,int
1944,58362,isReplicaAvailable,1,isReplicaAvailable,int isReplicaAvailable (clusterNode*),cluster.c,"static int isReplicaAvailable(clusterNode *node) {
    if (nodeFailed(node)) {
        return 0;
    }
    long long repl_offset = node->repl_offset;
    if (node->flags & CLUSTER_NODE_MYSELF) {
        /* Nodes do not update their own information
         * in the cluster node list. */
        repl_offset = replicationGetSlaveOffset();
    }
    return (repl_offset != 0);
}",5507.0,5518.0,1.0,8.0,12.0,8,4,7,2,2,4,3,3,2,1,,0,4,2,1,1,int
1945,58401,checkSlotAssignmentsOrReply,1,checkSlotAssignmentsOrReply,"int checkSlotAssignmentsOrReply (client*,unsigned char*,int,int,int)",cluster.c,"int checkSlotAssignmentsOrReply(client *c, unsigned char *slots, int del, int start_slot, int end_slot) {
    int slot;
    for (slot = start_slot; slot <= end_slot; slot++) {
        if (del && server.cluster->slots[slot] == NULL) {
            addReplyErrorFormat(c,""Slot %d is already unassigned"", slot);
            return C_ERR;
        } else if (!del && server.cluster->slots[slot]) {
            addReplyErrorFormat(c,""Slot %d is already busy"", slot);
            return C_ERR;
        }
        if (slots[slot]++ == 1) {
            addReplyErrorFormat(c,""Slot %d specified multiple times"",(int)slot);
            return C_ERR;
        }
    }
    return C_OK;
}",5520.0,5536.0,1.0,19.0,17.0,13,10,14,8,0,2,4,6,0,2,,0,0,10,5,5,int
1946,58490,clusterUpdateSlots,1,clusterUpdateSlots,"void clusterUpdateSlots (client*,unsigned char*,int)",cluster.c,"void clusterUpdateSlots(client *c, unsigned char *slots, int del) {
    int j;
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (slots[j]) {
            int retval;
                
            /* If this slot was set as importing we can clear this
             * state as now we are the real owner of the slot. */
            if (server.cluster->importing_slots_from[j])
                server.cluster->importing_slots_from[j] = NULL;

            retval = del ? clusterDelSlot(j) :
                           clusterAddSlot(myself,j);
            serverAssertWithInfo(c,NULL,retval == C_OK);
        }
    }
}",5538.0,5554.0,1.0,20.0,17.0,17,10,19,8,0,4,4,7,0,3,,0,3,6,3,3,void
1947,58564,addNodeToNodeReply,1,addNodeToNodeReply,"void addNodeToNodeReply (client*,clusterNode*)",cluster.c,"void addNodeToNodeReply(client *c, clusterNode *node) {
    addReplyArrayLen(c, 4);
    if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_IP) {
        addReplyBulkCString(c, node->ip);
    } else if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_HOSTNAME) {
        if (sdslen(node->hostname) != 0) {
            addReplyBulkCBuffer(c, node->hostname, sdslen(node->hostname));
        } else {
            addReplyBulkCString(c, ""?"");
        }
    } else if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT) {
        addReplyNull(c);
    } else {
        serverPanic(""Unrecognized preferred endpoint type"");
    }

    /* Report TLS ports to TLS client, and report non-TLS port to non-TLS client. */
    addReplyLongLong(c, getNodeClientPort(node, connIsTLS(c->conn)));
    addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);

    /* Add the additional endpoint information, this is all the known networking information
    ...",5556.0,5604.0,1.0,8.0,49.0,32,12,35,6,2,23,6,6,4,15,,0,13,4,2,2,void
1948,58746,addNodeReplyForClusterSlot,1,addNodeReplyForClusterSlot,"void addNodeReplyForClusterSlot (client*,clusterNode*,int,int)",cluster.c,"void addNodeReplyForClusterSlot(client *c, clusterNode *node, int start_slot, int end_slot) {
    int i, nested_elements = 3; /* slots (2) + master addr (1) */
    for (i = 0; i < node->numslaves; i++) {
        if (!isReplicaAvailable(node->slaves[i])) continue;
        nested_elements++;
    }
    addReplyArrayLen(c, nested_elements);
    addReplyLongLong(c, start_slot);
    addReplyLongLong(c, end_slot);
    addNodeToNodeReply(c, node);

    /* Remaining nodes in reply are replicas for slot range */
    for (i = 0; i < node->numslaves; i++) {
        /* This loop is copy/pasted from clusterGenNodeDescription()
         * with modifications for per-slot node aggregation. */
        if (!isReplicaAvailable(node->slaves[i])) continue;
        addNodeToNodeReply(c, node->slaves[i]);
        nested_elements--;
    }
    serverAssert(nested_elements == 3); /* Original 3 elements */
}",5606.0,5626.0,1.0,4.0,21.0,22,12,25,6,1,13,7,7,6,8,,0,7,8,4,4,void
1949,58844,addNodeDetailsToShardReply,1,addNodeDetailsToShardReply,"void addNodeDetailsToShardReply (client*,clusterNode*)",cluster.c,"void addNodeDetailsToShardReply(client *c, clusterNode *node) {
    int reply_count = 0;
    void *node_replylen = addReplyDeferredLen(c);
    addReplyBulkCString(c, ""id"");
    addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);
    reply_count++;

    if (node->tcp_port) {
        addReplyBulkCString(c, ""port"");
        addReplyLongLong(c, node->tcp_port);
        reply_count++;
    }

    if (node->tls_port) {
        addReplyBulkCString(c, ""tls-port"");
        addReplyLongLong(c, node->tls_port);
        reply_count++;
    }

    addReplyBulkCString(c, ""ip"");
    addReplyBulkCString(c, node->ip);
    reply_count++;

    addReplyBulkCString(c, ""endpoint"");
    addReplyBulkCString(c, getPreferredEndpoint(node));
    reply_count++;

    if (sdslen(node->hostname) != 0) {
        addReplyBulkCString(c, ""hostname"");
        addReplyBulkCBuffer(c, node->hostname, sdslen(node->hostname));
        reply_count++;
    }

    long long node_offset;
    if (node->flags & CLUSTER_NODE_MYSELF...",5629.0,5690.0,1.0,39.0,62.0,35,7,57,8,1,37,6,6,6,24,,0,18,4,2,2,void
1950,59054,addShardReplyForClusterShards,1,addShardReplyForClusterShards,"void addShardReplyForClusterShards (client*,list*)",cluster.c,"void addShardReplyForClusterShards(client *c, list *nodes) {
    serverAssert(listLength(nodes) > 0);
    clusterNode *n = listNodeValue(listFirst(nodes));
    addReplyMapLen(c, 2);
    addReplyBulkCString(c, ""slots"");

    /* Use slot_info_pairs from the primary only */
    while (n->slaveof != NULL) n = n->slaveof;

    if (n->slot_info_pairs != NULL) {
        serverAssert((n->slot_info_pairs_count % 2) == 0);
        addReplyArrayLen(c, n->slot_info_pairs_count);
        for (int i = 0; i < n->slot_info_pairs_count; i++)
            addReplyBulkLongLong(c, (unsigned long)n->slot_info_pairs[i]);
    } else {
        /* If no slot info pair is provided, the node owns no slots */
        addReplyArrayLen(c, 0);
    }

    addReplyBulkCString(c, ""nodes"");
    addReplyArrayLen(c, listLength(nodes));
    listIter li;
    listRewind(nodes, &li);
    for (listNode *ln = listNext(&li); ln != NULL; ln = listNext(&li)) {
        clusterNode *n = listNodeValue(ln);
        addNodeDetailsToS...",5693.0,5721.0,1.0,4.0,29.0,31,12,31,7,1,19,5,6,3,11,,0,9,4,2,2,void
1951,59211,clusterReplyShards,1,clusterReplyShards,void clusterReplyShards (client*),cluster.c,"void clusterReplyShards(client *c) {
    addReplyArrayLen(c, dictSize(server.cluster->shards));
    /* This call will add slot_info_pairs to all nodes */
    clusterGenNodesSlotsInfo(0);
    dictIterator *di = dictGetSafeIterator(server.cluster->shards);
    for(dictEntry *de = dictNext(di); de != NULL; de = dictNext(di)) {
        addShardReplyForClusterShards(c, dictGetVal(de));
    }
    dictReleaseIterator(di);
}",5726.0,5735.0,1.0,24.0,10.0,16,6,13,5,0,7,2,2,0,7,,0,3,2,1,1,void
1952,59276,clusterReplyMultiBulkSlots,1,clusterReplyMultiBulkSlots,void clusterReplyMultiBulkSlots (client*),cluster.c,"void clusterReplyMultiBulkSlots(client * c) {
    /* Format: 1) 1) start slot
     *            2) end slot
     *            3) 1) master IP
     *               2) master port
     *               3) node ID
     *            4) 1) replica IP
     *               2) replica port
     *               3) node ID
     *           ... continued until done
     */
    clusterNode *n = NULL;
    int num_masters = 0, start = -1;
    void *slot_replylen = addReplyDeferredLen(c);

    for (int i = 0; i <= CLUSTER_SLOTS; i++) {
        /* Find start node and slot id. */
        if (n == NULL) {
            if (i == CLUSTER_SLOTS) break;
            n = server.cluster->slots[i];
            start = i;
            continue;
        }

        /* Add cluster slots info when occur different node with start
         * or end of slot. */
        if (i == CLUSTER_SLOTS || n != server.cluster->slots[i]) {
            addNodeReplyForClusterSlot(c, n, start, i-1);
            num_masters++;
         ...",5737.0,5772.0,1.0,25.0,36.0,28,11,34,8,0,3,9,12,0,3,,0,1,2,1,1,void
1953,59389,genClusterInfoString,1,genClusterInfoString,sds genClusterInfoString (void),cluster.c,"sds genClusterInfoString(void) {
    sds info = sdsempty();
    char *statestr[] = {""ok"",""fail""};
    int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;
    uint64_t myepoch;
    int j;

    for (j = 0; j < CLUSTER_SLOTS; j++) {
        clusterNode *n = server.cluster->slots[j];

        if (n == NULL) continue;
        slots_assigned++;
        if (nodeFailed(n)) {
            slots_fail++;
        } else if (nodeTimedOut(n)) {
            slots_pfail++;
        } else {
            slots_ok++;
        }
    }

    myepoch = (nodeIsSlave(myself) && myself->slaveof) ?
                myself->slaveof->configEpoch : myself->configEpoch;

    info = sdscatprintf(info,
        ""cluster_state:%s\r\n""
        ""cluster_slots_assigned:%d\r\n""
        ""cluster_slots_ok:%d\r\n""
        ""cluster_slots_pfail:%d\r\n""
        ""cluster_slots_fail:%d\r\n""
        ""cluster_known_nodes:%lu\r\n""
        ""cluster_size:%d\r\n""
        ""cluster_current_epoch:%llu\r\n""
        ""cluster...",5774.0,5850.0,1.0,20.0,77.0,83,14,73,15,1,19,11,12,1,9,,0,19,2,1,1,sds
1954,59693,clusterCommand,1,clusterCommand,void clusterCommand (client*),cluster.c,"void clusterCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""ADDSLOTS <slot> [<slot> ...]"",
""    Assign slots to current node."",
""ADDSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]"",
""    Assign slots which are between <start-slot> and <end-slot> to current node."",
""BUMPEPOCH"",
""    Advance the cluster config epoch."",
""COUNT-FAILURE-REPORTS <node-id>"",
""    Return number of failure reports for <node-id>."",
""COUNTKEYSINSLOT <slot>"",
""    Return the number of keys in <slot>."",
""DELSLOTS <slot> [<slot> ...]"",
""    Delete slots information from current node."",
""DELSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]"",
""    Delete slots information which are between <start-slot> and <end-slot> from current node."",
""FAILOVER [FORCE|TAKEOVER]"",
""    Promote current...",5852.0,6455.0,1.0,56.0,604.0,11,8,8,4,0,4,3,3,2,2,,0,2,2,1,1,void
1955,62523,createDumpPayload,1,createDumpPayload,"void createDumpPayload (rio*,robj*,robj*,int)",cluster.c,"void createDumpPayload(rio *payload, robj *o, robj *key, int dbid) {
    unsigned char buf[2];
    uint64_t crc;

    /* Serialize the object in an RDB-like format. It consist of an object type
     * byte followed by the serialized object. This is understood by RESTORE. */
    rioInitWithBuffer(payload,sdsempty());
    serverAssert(rdbSaveObjectType(payload,o));
    serverAssert(rdbSaveObject(payload,o,key,dbid));

    /* Write the footer, this is how it looks like:
     * ----------------+---------------------+---------------+
     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |
     * ----------------+---------------------+---------------+
     * RDB version and CRC are both in little endian.
     */

    /* RDB version */
    buf[0] = RDB_VERSION & 0xff;
    buf[1] = (RDB_VERSION >> 8) & 0xff;
    payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);

    /* CRC64 */
    crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,
                sdslen(payload->i...",6487.0,6514.0,1.0,4.0,28.0,40,11,20,6,2,11,1,1,0,11,,0,5,8,4,4,void
1956,62655,verifyDumpPayload,1,verifyDumpPayload,"int verifyDumpPayload (unsigned char*,size_t,uint16_t*)",cluster.c,"int verifyDumpPayload(unsigned char *p, size_t len, uint16_t *rdbver_ptr) {
    unsigned char *footer;
    uint16_t rdbver;
    uint64_t crc;

    /* At least 2 bytes of RDB version and 8 of CRC64 should be present. */
    if (len < 10) return C_ERR;
    footer = p+(len-10);

    /* Set and verify RDB version. */
    rdbver = (footer[1] << 8) | footer[0];
    if (rdbver_ptr) {
        *rdbver_ptr = rdbver;
    }
    if (rdbver > RDB_VERSION) return C_ERR;

    if (server.skip_checksum_validation)
        return C_OK;

    /* Verify CRC64 */
    crc = crc64(0,p,len-8);
    memrev64ifbe(&crc);
    return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
}",6521.0,6544.0,1.0,25.0,24.0,24,14,19,7,2,2,5,5,0,2,,0,1,6,3,3,int
1957,62754,dumpCommand,1,dumpCommand,void dumpCommand (client*),cluster.c,"void dumpCommand(client *c) {
    robj *o;
    rio payload;

    /* Check if the key is here. */
    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
        addReplyNull(c);
        return;
    }

    /* Create the DUMP encoded representation. */
    createDumpPayload(&payload,o,c->argv[1],c->db->id);

    /* Transfer to the client */
    addReplyBulkSds(c,payload.io.buffer.ptr);
    return;
}",6549.0,6565.0,1.0,1.0,17.0,13,6,11,4,0,8,2,2,3,4,,0,5,2,1,1,void
1958,62803,restoreCommand,1,restoreCommand,void restoreCommand (client*),cluster.c,"void restoreCommand(client *c) {
    long long ttl, lfu_freq = -1, lru_idle = -1, lru_clock = -1;
    rio payload;
    int j, type, replace = 0, absttl = 0;
    robj *obj;

    /* Parse additional options */
    for (j = 4; j < c->argc; j++) {
        int additional = c->argc-j-1;
        if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""absttl"")) {
            absttl = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""idletime"") && additional >= 1 &&
                   lfu_freq == -1)
        {
            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lru_idle,NULL)
                    != C_OK) return;
            if (lru_idle < 0) {
                addReplyError(c,""Invalid IDLETIME value, must be >= 0"");
                return;
            }
            lru_clock = LRU_CLOCK();
            j++; /* Consume additional arg. */
        } else if (!strcasecmp(c->argv[j]->ptr,""freq"") && additional >= 1 &&
         ...",6568.0,6674.0,1.0,23.0,107.0,87,17,98,19,0,46,13,16,14,28,,0,27,2,1,1,void
1959,63295,migrateGetSocket,1,migrateGetSocket,"migrateCachedSocket migrateGetSocket (client*,robj*,robj*,long)",cluster.c,"migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long timeout) {
    connection *conn;
    sds name = sdsempty();
    migrateCachedSocket *cs;

    /* Check if we have an already cached socket for this ip:port pair. */
    name = sdscatlen(name,host->ptr,sdslen(host->ptr));
    name = sdscatlen(name,"":"",1);
    name = sdscatlen(name,port->ptr,sdslen(port->ptr));
    cs = dictFetchValue(server.migrate_cached_sockets,name);
    if (cs) {
        sdsfree(name);
        cs->last_use_time = server.unixtime;
        return cs;
    }

    /* No cached socket, create one. */
    if (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) {
        /* Too many items, drop one at random. */
        dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);
        cs = dictGetVal(de);
        connClose(cs->conn);
        zfree(cs);
        dictDelete(server.migrate_cached_sockets,dictGetKey(de));
    }

    /* Create the connection */
    conn = co...",6702.0,6747.0,1.0,8.0,46.0,43,10,51,10,1,28,4,4,1,23,,0,19,8,4,4,migrateCachedSocket
1960,63470,migrateCloseSocket,1,migrateCloseSocket,"void migrateCloseSocket (robj*,robj*)",cluster.c,"void migrateCloseSocket(robj *host, robj *port) {
    sds name = sdsempty();
    migrateCachedSocket *cs;

    name = sdscatlen(name,host->ptr,sdslen(host->ptr));
    name = sdscatlen(name,"":"",1);
    name = sdscatlen(name,port->ptr,sdslen(port->ptr));
    cs = dictFetchValue(server.migrate_cached_sockets,name);
    if (!cs) {
        sdsfree(name);
        return;
    }

    connClose(cs->conn);
    zfree(cs);
    dictDelete(server.migrate_cached_sockets,name);
    sdsfree(name);
}",6750.0,6767.0,1.0,1.0,18.0,13,4,21,5,2,13,2,2,0,12,,0,8,4,2,2,void
1961,63536,migrateCloseTimedoutSockets,1,migrateCloseTimedoutSockets,void migrateCloseTimedoutSockets (void),cluster.c,"void migrateCloseTimedoutSockets(void) {
    dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);
    dictEntry *de;

    while((de = dictNext(di)) != NULL) {
        migrateCachedSocket *cs = dictGetVal(de);

        if ((server.unixtime - cs->last_use_time) > MIGRATE_SOCKET_CACHE_TTL) {
            connClose(cs->conn);
            zfree(cs);
            dictDelete(server.migrate_cached_sockets,dictGetKey(de));
        }
    }
    dictReleaseIterator(di);
}",6769.0,6783.0,1.0,52.0,15.0,11,6,14,5,1,10,3,4,2,8,,0,6,2,1,1,void
1962,63589,migrateCommand,1,migrateCommand,void migrateCommand (client*),cluster.c,"void migrateCommand(client *c) {
    migrateCachedSocket *cs;
    int copy = 0, replace = 0, j;
    char *username = NULL;
    char *password = NULL;
    long timeout;
    long dbid;
    robj **ov = NULL; /* Objects to migrate. */
    robj **kv = NULL; /* Key names. */
    robj **newargv = NULL; /* Used to rewrite the command as DEL ... keys ... */
    rio cmd, payload;
    int may_retry = 1;
    int write_error = 0;
    int argv_rewritten = 0;

    /* To support the KEYS option we need the following additional state. */
    int first_key = 3; /* Argument index of the first key. */
    int num_keys = 1;  /* By default only migrate the 'key' argument. */

    /* Parse additional options */
    for (j = 6; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        if (!strcasecmp(c->argv[j]->ptr,""copy"")) {
            copy = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""auth"")) {
      ...",6792.0,7130.0,1.0,64.0,339.0,292,24,313,43,0,94,44,55,16,72,,0,45,2,1,1,void
1963,64924,askingCommand,1,askingCommand,void askingCommand (client*),cluster.c,"void askingCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags |= CLIENT_ASKING;
    addReply(c,shared.ok);
}",7140.0,7147.0,1.0,16.0,8.0,5,4,5,3,0,3,2,2,0,2,,0,1,2,1,1,void
1964,64954,readonlyCommand,1,readonlyCommand,void readonlyCommand (client*),cluster.c,"void readonlyCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags |= CLIENT_READONLY;
    addReply(c,shared.ok);
}",7152.0,7159.0,1.0,16.0,8.0,5,4,5,3,0,3,2,2,0,2,,0,1,2,1,1,void
1965,64984,readwriteCommand,1,readwriteCommand,void readwriteCommand (client*),cluster.c,"void readwriteCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags &= ~CLIENT_READONLY;
    addReply(c,shared.ok);
}",7162.0,7169.0,1.0,17.0,8.0,6,5,5,3,0,3,2,2,0,2,,0,1,2,1,1,void
1966,65015,getNodeByQuery,1,getNodeByQuery,"clusterNode getNodeByQuery (client*,redisCommand*,robj**,int,int*,int*)",cluster.c,"clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {
    clusterNode *n = NULL;
    robj *firstkey = NULL;
    int multiple_keys = 0;
    multiState *ms, _ms;
    multiCmd mc;
    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0,
        existing_keys = 0;

    /* Allow any key to be set if a module disabled cluster redirections. */
    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
        return myself;

    /* Set error code optimistically for the base case. */
    if (error_code) *error_code = CLUSTER_REDIR_NONE;

    /* Modules can turn off Redis Cluster redirection: this is useful
     * when writing a module that implements a completely different
     * distributed system. */

    /* We handle all the cases as if they were EXEC commands, so we have
     * a common code path for everything */
    if (cmd->proc == execCommand) {
        /* If CLIENT_MULTI flag is...",7203.0,7413.0,1.0,38.0,211.0,155,18,139,34,3,35,28,59,14,7,,0,33,12,6,6,clusterNode
1967,65692,clusterRedirectClient,1,clusterRedirectClient,"void clusterRedirectClient (client*,clusterNode*,int,int)",cluster.c,"void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
    if (error_code == CLUSTER_REDIR_CROSS_SLOT) {
        addReplyError(c,""-CROSSSLOT Keys in request don't hash to the same slot"");
    } else if (error_code == CLUSTER_REDIR_UNSTABLE) {
        /* The request spawns multiple keys in the same slot,
         * but the slot is not ""stable"" currently as there is
         * a migration or import in progress. */
        addReplyError(c,""-TRYAGAIN Multiple keys request during rehashing of slot"");
    } else if (error_code == CLUSTER_REDIR_DOWN_STATE) {
        addReplyError(c,""-CLUSTERDOWN The cluster is down"");
    } else if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) {
        addReplyError(c,""-CLUSTERDOWN The cluster is down and only accepts read commands"");
    } else if (error_code == CLUSTER_REDIR_DOWN_UNBOUND) {
        addReplyError(c,""-CLUSTERDOWN Hash slot not served"");
    } else if (error_code == CLUSTER_REDIR_MOVED ||
               error_c...",7422.0,7448.0,1.0,22.0,27.0,1,1,2,2,3,1,2,2,0,1,,0,0,8,4,4,void
1968,65809,clusterRedirectBlockedClientIfNeeded,1,clusterRedirectBlockedClientIfNeeded,int clusterRedirectBlockedClientIfNeeded (client*),cluster.c,"int clusterRedirectBlockedClientIfNeeded(client *c) {
    if (c->flags & CLIENT_BLOCKED &&
        (c->bstate.btype == BLOCKED_LIST ||
         c->bstate.btype == BLOCKED_ZSET ||
         c->bstate.btype == BLOCKED_STREAM ||
         c->bstate.btype == BLOCKED_MODULE))
    {
        dictEntry *de;
        dictIterator *di;

        /* If the cluster is down, unblock the client with the right error.
         * If the cluster is configured to allow reads on cluster down, we
         * still want to emit this error since a write will be required
         * to unblock them which may never come.  */
        if (server.cluster->state == CLUSTER_FAIL) {
            clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
            return 1;
        }

        /* If the client is blocked on module, but not on a specific key,
         * don't unblock it (except for the CLUSTER_FAIL case above). */
        if (c->bstate.btype == BLOCKED_MODULE && !moduleClientIsBlockedOnKeys(c))
          ...",7461.0,7521.0,1.0,19.0,61.0,64,12,47,13,0,26,8,18,16,10,,0,22,2,1,1,int
1969,66024,slotToKeyAddEntry,1,slotToKeyAddEntry,"void slotToKeyAddEntry (dictEntry*,redisDb*)",cluster.c,"void slotToKeyAddEntry(dictEntry *entry, redisDb *db) {
    sds key = dictGetKey(entry);
    unsigned int hashslot = keyHashSlot(key, sdslen(key));
    slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
    slot_to_keys->count++;

    /* Insert entry before the first element in the list. */
    dictEntry *first = slot_to_keys->head;
    dictEntryNextInSlot(entry) = first;
    if (first != NULL) {
        serverAssert(dictEntryPrevInSlot(first) == NULL);
        dictEntryPrevInSlot(first) = entry;
    }
    serverAssert(dictEntryPrevInSlot(entry) == NULL);
    slot_to_keys->head = entry;
}",7528.0,7543.0,1.0,4.0,16.0,35,13,25,7,2,13,2,2,0,9,,0,7,4,2,2,void
1970,66138,slotToKeyDelEntry,1,slotToKeyDelEntry,"void slotToKeyDelEntry (dictEntry*,redisDb*)",cluster.c,"void slotToKeyDelEntry(dictEntry *entry, redisDb *db) {
    sds key = dictGetKey(entry);
    unsigned int hashslot = keyHashSlot(key, sdslen(key));
    slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
    slot_to_keys->count--;

    /* Connect previous and next entries to each other. */
    dictEntry *next = dictEntryNextInSlot(entry);
    dictEntry *prev = dictEntryPrevInSlot(entry);
    if (next != NULL) {
        dictEntryPrevInSlot(next) = prev;
    }
    if (prev != NULL) {
        dictEntryNextInSlot(prev) = next;
    } else {
        /* The removed entry was the first in the list. */
        serverAssert(slot_to_keys->head == entry);
        slot_to_keys->head = next;
    }
}",7545.0,7564.0,1.0,22.0,20.0,24,9,25,8,1,9,3,3,0,7,,0,7,4,2,2,void
1971,66253,slotToKeyReplaceEntry,1,slotToKeyReplaceEntry,"void slotToKeyReplaceEntry (dict*,dictEntry*)",cluster.c,"void slotToKeyReplaceEntry(dict *d, dictEntry *entry) {
    dictEntry *next = dictEntryNextInSlot(entry);
    dictEntry *prev = dictEntryPrevInSlot(entry);
    if (next != NULL) {
        dictEntryPrevInSlot(next) = entry;
    }
    if (prev != NULL) {
        dictEntryNextInSlot(prev) = entry;
    } else {
        /* The replaced entry was the first in the list. */
        sds key = dictGetKey(entry);
        unsigned int hashslot = keyHashSlot(key, sdslen(key));
        clusterDictMetadata *dictmeta = dictMetadata(d);
        redisDb *db = dictmeta->db;
        slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
        slot_to_keys->head = entry;
    }
}",7568.0,7585.0,1.0,22.0,18.0,14,4,16,4,1,4,3,3,0,4,,0,2,4,2,2,void
1972,66357,slotToKeyInit,1,slotToKeyInit,void slotToKeyInit (redisDb*),cluster.c,"void slotToKeyInit(redisDb *db) {
    db->slots_to_keys = zcalloc(sizeof(clusterSlotToKeyMapping));
    clusterDictMetadata *dictmeta = dictMetadata(db->dict);
    dictmeta->db = db;
}",7588.0,7592.0,1.0,1.0,5.0,7,3,6,3,2,5,1,1,0,2,,0,5,2,1,1,void
1973,66381,slotToKeyFlush,1,slotToKeyFlush,void slotToKeyFlush (redisDb*),cluster.c,"void slotToKeyFlush(redisDb *db) {
    memset(db->slots_to_keys, 0,
        sizeof(clusterSlotToKeyMapping));
}",7595.0,7598.0,1.0,1.0,4.0,2,2,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
1974,66393,slotToKeyDestroy,1,slotToKeyDestroy,void slotToKeyDestroy (redisDb*),cluster.c,"void slotToKeyDestroy(redisDb *db) {
    zfree(db->slots_to_keys);
    db->slots_to_keys = NULL;
}",7601.0,7604.0,1.0,1.0,4.0,3,2,3,2,1,3,1,1,0,1,,0,2,2,1,1,void
1975,66531,slotToChannelUpdate,1,slotToChannelUpdate,"void slotToChannelUpdate (sds,int)",cluster.c,"void slotToChannelUpdate(sds channel, int add) {
    size_t keylen = sdslen(channel);
    unsigned int hashslot = keyHashSlot(channel,keylen);
    unsigned char buf[64];
    unsigned char *indexed = buf;

    if (keylen+2 > 64) indexed = zmalloc(keylen+2);
    indexed[0] = (hashslot >> 8) & 0xff;
    indexed[1] = hashslot & 0xff;
    memcpy(indexed+2,channel,keylen);
    if (add) {
        raxInsert(server.cluster->slots_to_channels,indexed,keylen+2,NULL,NULL);
    } else {
        raxRemove(server.cluster->slots_to_channels,indexed,keylen+2,NULL);
    }
    if (indexed != buf) zfree(indexed);
}",7637.0,7653.0,1.0,1.0,17.0,19,9,26,8,2,5,4,4,0,5,,0,3,4,2,2,void
1976,66623,slotToChannelAdd,1,slotToChannelAdd,void slotToChannelAdd (sds),cluster.c,"void slotToChannelAdd(sds channel) {
    slotToChannelUpdate(channel,1);
}",7655.0,7657.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
1977,66631,slotToChannelDel,1,slotToChannelDel,void slotToChannelDel (sds),cluster.c,"void slotToChannelDel(sds channel) {
    slotToChannelUpdate(channel,0);
}",7659.0,7661.0,1.0,1.0,3.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void
1978,67335,commandGroupStr,1,commandGroupStr,char* commandGroupStr (int),commands.h,const char *commandGroupStr(int index);,38.0,38.0,12.0,38.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
1979,67812,is_valid_fn,1,boolConfigData.is_valid_fn,"int boolConfigData.is_valid_fn (int,char**)",config.c,"int (*is_valid_fn)(int val, const char **err);",188.0,188.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1980,67822,is_valid_fn,1,stringConfigData.is_valid_fn,"int stringConfigData.is_valid_fn (char*,char**)",config.c,"int (*is_valid_fn)(char* val, const char **err);",194.0,194.0,9.0,51.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1981,67833,is_valid_fn,1,sdsConfigData.is_valid_fn,"int sdsConfigData.is_valid_fn (sds,char**)",config.c,"int (*is_valid_fn)(sds val, const char **err);",202.0,202.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1982,67845,is_valid_fn,1,enumConfigData.is_valid_fn,"int enumConfigData.is_valid_fn (int,char**)",config.c,"int (*is_valid_fn)(int val, const char **err);",211.0,211.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1983,67882,is_valid_fn,1,numericConfigData.is_valid_fn,"int numericConfigData.is_valid_fn (long long,char**)",config.c,"int (*is_valid_fn)(long long val, const char **err);",245.0,245.0,9.0,55.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
1984,67904,init,1,typeInterface.init,void typeInterface.init (standardConfig*),config.c,void (*init)(standardConfig *config);,261.0,261.0,10.0,40.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
1985,67909,set,1,typeInterface.set,"int typeInterface.set (standardConfig*,sds*,int,char**)",config.c,"int (*set)(standardConfig *config, sds *argv, int argc, const char **err);",265.0,265.0,9.0,77.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,int
1986,67918,get,1,typeInterface.get,sds typeInterface.get (standardConfig*),config.c,sds (*get)(standardConfig *config);,271.0,271.0,9.0,38.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sds
1987,67923,rewrite,1,typeInterface.rewrite,"void typeInterface.rewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"void (*rewrite)(standardConfig *config, const char *name, struct rewriteConfigState *state);",273.0,273.0,10.0,95.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
1988,67943,lookupConfig,1,lookupConfig,standardConfig lookupConfig (sds),config.c,"static standardConfig *lookupConfig(sds name) {
    dictEntry *de = dictFind(configs, name);
    return de ? dictGetVal(de) : NULL;
}",290.0,293.0,1.0,1.0,4.0,2,2,6,4,8,3,1,1,0,2,,0,2,2,1,1,standardConfig
1989,67960,configEnumGetValue,1,configEnumGetValue,"int configEnumGetValue (configEnum*,sds*,int,int)",config.c,"int configEnumGetValue(configEnum *ce, sds *argv, int argc, int bitflags) {
    if (argc == 0 || (!bitflags && argc != 1)) return INT_MIN;
    int values = 0;
    for (int i = 0; i < argc; i++) {
        int matched = 0;
        for (configEnum *ceItem = ce; ceItem->name != NULL; ceItem++) {
            if (!strcasecmp(argv[i],ceItem->name)) {
                values |= ceItem->val;
                matched = 1;
            }
        }
        if (!matched) return INT_MIN;
    }
    return values;
}",300.0,314.0,1.0,1.0,15.0,18,9,22,10,1,0,6,10,0,0,,0,0,8,4,4,int
1990,68042,configEnumGetName,1,configEnumGetName,"sds configEnumGetName (configEnum*,int,int)",config.c,"static sds configEnumGetName(configEnum *ce, int values, int bitflags) {
    sds names = NULL;
    int unmatched = values;
    for( ; ce->name != NULL; ce++) {
        if (values == ce->val) { /* Short path for perfect match */
            sdsfree(names);
            return sdsnew(ce->name);
        }

        /* Note: for bitflags, we want them sorted from high to low, so that if there are several / partially
         * overlapping entries, we'll prefer the ones matching more bits. */
        if (bitflags && ce->val && ce->val == (unmatched & ce->val)) {
            names = names ? sdscatfmt(names, "" %s"", ce->name) : sdsnew(ce->name);
            unmatched &= ~ce->val;
        }
    }
    if (!names || unmatched) {
        sdsfree(names);
        return sdsnew(""unknown"");
    }
    return names;
}",317.0,338.0,1.0,1.0,22.0,22,10,26,6,2,15,5,7,5,6,,0,11,6,3,3,sds
1991,68131,evictPolicyToString,1,evictPolicyToString,const char* evictPolicyToString (void),config.c,"const char *evictPolicyToString(void) {
    for (configEnum *ce = maxmemory_policy_enum; ce->name != NULL; ce++) {
        if (server.maxmemory_policy == ce->val)
            return ce->name;
    }
    serverPanic(""unknown eviction policy"");
}",341.0,347.0,1.0,4.0,7.0,8,6,7,4,1,2,3,4,0,1,,0,1,2,1,1,const char*
1992,68171,yesnotoi,1,yesnotoi,int yesnotoi (char*),config.c,"int yesnotoi(char *s) {
    if (!strcasecmp(s,""yes"")) return 1;
    else if (!strcasecmp(s,""no"")) return 0;
    else return -1;
}",353.0,357.0,1.0,1.0,5.0,1,1,1,1,1,0,2,2,0,0,,0,0,2,1,1,int
1993,68199,appendServerSaveParams,1,appendServerSaveParams,"void appendServerSaveParams (time_t,int)",config.c,"void appendServerSaveParams(time_t seconds, int changes) {
    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));
    server.saveparams[server.saveparamslen].seconds = seconds;
    server.saveparams[server.saveparamslen].changes = changes;
    server.saveparamslen++;
}",359.0,364.0,1.0,1.0,6.0,19,7,11,4,4,1,1,1,0,1,,0,1,4,2,2,void
1994,68247,resetServerSaveParams,1,resetServerSaveParams,void resetServerSaveParams (void),config.c,"void resetServerSaveParams(void) {
    zfree(server.saveparams);
    server.saveparams = NULL;
    server.saveparamslen = 0;
}",366.0,370.0,1.0,1.0,5.0,5,2,4,2,3,1,1,1,0,1,,0,0,2,1,1,void
1995,68266,queueLoadModule,1,queueLoadModule,"void queueLoadModule (sds,sds*,int)",config.c,"void queueLoadModule(sds path, sds *argv, int argc) {
    int i;
    struct moduleLoadQueueEntry *loadmod;

    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));
    loadmod->argv = argc ? zmalloc(sizeof(robj*)*argc) : NULL;
    loadmod->path = sdsnew(path);
    loadmod->argc = argc;
    for (i = 0; i < argc; i++) {
        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
    }
    listAddNodeTail(server.loadmodule_queue,loadmod);
}",372.0,384.0,1.0,1.0,13.0,19,8,22,9,0,10,2,2,0,6,,0,9,6,3,3,void
1996,68333,updateClientOutputBufferLimit,1,updateClientOutputBufferLimit,"int updateClientOutputBufferLimit (sds*,int,char**)",config.c,"static int updateClientOutputBufferLimit(sds *args, int arg_len, const char **err) {
    int j;
    int class;
    unsigned long long hard, soft;
    int hard_err, soft_err;
    int soft_seconds;
    char *soft_seconds_eptr;
    clientBufferLimitsConfig values[CLIENT_TYPE_OBUF_COUNT];
    int classes[CLIENT_TYPE_OBUF_COUNT] = {0};

    /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */
    if (arg_len % 4) {
        if (err) *err = ""Wrong number of arguments in ""
                        ""buffer limit configuration."";
        return 0;
    }

    /* Sanity check of single arguments, so that we either refuse the
     * whole configuration string or accept it all, even if a single
     * error in a single client class is present. */
    for (j = 0; j < arg_len; j += 4) {
        class = getClientTypeByName(args[j]);
        if (class == -1 || class == CLIENT_TYPE_MASTER) {
            if (err) *err = ""Invalid client class specified in ""
                            ""buf...",389.0,440.0,1.0,36.0,52.0,53,13,51,14,1,3,10,18,0,3,,0,3,6,3,3,int
1997,68517,loadServerConfigFromString,1,loadServerConfigFromString,void loadServerConfigFromString (char*),config.c,"void loadServerConfigFromString(char *config) {
    deprecatedConfig deprecated_configs[] = {
        {""list-max-ziplist-entries"", 2, 2},
        {""list-max-ziplist-value"", 2, 2},
        {""lua-replicate-commands"", 2, 2},
        {NULL, 0},
    };
    char buf[1024];
    const char *err = NULL;
    int linenum = 0, totlines, i;
    sds *lines;
    sds *argv = NULL;
    int argc;

    reading_config_file = 1;
    lines = sdssplitlen(config,strlen(config),""\n"",1,&totlines);

    for (i = 0; i < totlines; i++) {
        linenum = i+1;
        lines[i] = sdstrim(lines[i],"" \t\r\n"");

        /* Skip comments and blank lines */
        if (lines[i][0] == '#' || lines[i][0] == '\0') continue;

        /* Split into arguments */
        argv = sdssplitargs(lines[i],&argc);
        if (argv == NULL) {
            err = ""Unbalanced quotes in configuration line"";
            goto loaderr;
        }

        /* Skip this line if the resulting command vector is empty. */
        if (argc == 0) ...",447.0,645.0,1.0,34.0,199.0,96,16,108,17,1,24,27,36,5,19,,0,14,2,1,1,void
1998,69259,loadServerConfig,1,loadServerConfig,"void loadServerConfig (char*,char,char*)",config.c,"void loadServerConfig(char *filename, char config_from_stdin, char *options) {
    sds config = sdsempty();
    char buf[CONFIG_READ_LEN+1];
    FILE *fp;
    glob_t globbuf;

    /* Load the file content */
    if (filename) {

        /* The logic for handling wildcards has slightly different behavior in cases where
         * there is a failure to locate the included file.
         * Whether or not a wildcard is specified, we should ALWAYS log errors when attempting
         * to open included config files.
         *
         * However, we desire a behavioral difference between instances where a wildcard was
         * specified and those where it hasn't:
         *      no wildcards   : attempt to open the specified file and fail with a logged error
         *                       if the file cannot be found and opened.
         *      with wildcards : attempt to glob the specified pattern; if no files match the
         *                       pattern, then gracefully continu...",655.0,726.0,1.0,13.0,72.0,28,10,39,12,1,7,10,25,0,7,,0,3,6,3,3,void
1999,69483,performInterfaceSet,1,performInterfaceSet,"int performInterfaceSet (standardConfig*,sds,char**)",config.c,"static int performInterfaceSet(standardConfig *config, sds value, const char **errstr) {
    sds *argv;
    int argc, res;

    if (config->flags & MULTI_ARG_CONFIG) {
        argv = sdssplitlen(value, sdslen(value), "" "", 1, &argc);
    } else {
        argv = (char**)&value;
        argc = 1;
    }

    /* Set the config */
    res = config->interface.set(config, argv, argc, errstr);
    if (config->flags & MULTI_ARG_CONFIG) sdsfreesplitres(argv, argc);
    return res;
}",728.0,743.0,1.0,24.0,16.0,11,6,15,6,3,7,3,3,2,4,,0,6,6,3,3,int
2000,69553,performModuleConfigSetFromName,1,performModuleConfigSetFromName,"int performModuleConfigSetFromName (sds,sds,char**)",config.c,"int performModuleConfigSetFromName(sds name, sds value, const char **err) {
    standardConfig *config = lookupConfig(name);
    if (!config || !(config->flags & MODULE_CONFIG)) {
        *err = ""Config name not found"";
        return 0;
    }
    return performInterfaceSet(config, value, err);
}",746.0,753.0,1.0,37.0,8.0,9,7,8,4,1,3,2,2,1,2,,0,2,6,3,3,int
2001,69591,performModuleConfigSetDefaultFromName,1,performModuleConfigSetDefaultFromName,"int performModuleConfigSetDefaultFromName (sds,char**)",config.c,"int performModuleConfigSetDefaultFromName(sds name, const char **err) {
    standardConfig *config = lookupConfig(name);
    serverAssert(config);
    if (!(config->flags & MODULE_CONFIG)) {
        *err = ""Config name not found"";
        return 0;
    }
    switch (config->type) {
        case BOOL_CONFIG:
            return setModuleBoolConfig(config->privdata, config->data.yesno.default_value, err);
        case SDS_CONFIG:
            return setModuleStringConfig(config->privdata, config->data.sds.default_value, err);
        case NUMERIC_CONFIG:
            return setModuleNumericConfig(config->privdata, config->data.numeric.default_value, err);
        case ENUM_CONFIG:
            return setModuleEnumConfig(config->privdata, config->data.enumd.default_value, err);
        default:
            serverPanic(""Config type of module config is not allowed."");
    }
    return 0;
}",756.0,776.0,1.0,4.0,21.0,29,11,23,7,0,17,3,3,2,7,,0,11,4,2,2,int
2002,69711,restoreBackupConfig,1,restoreBackupConfig,"void restoreBackupConfig (standardConfig**,sds*,int,apply_fn*,list*)",config.c,"static void restoreBackupConfig(standardConfig **set_configs, sds *old_values, int count, apply_fn *apply_fns, list *module_configs) {
    int i;
    const char *errstr = ""unknown error"";
    /* Set all backup values */
    for (i = 0; i < count; i++) {
        if (!performInterfaceSet(set_configs[i], old_values[i], &errstr))
            serverLog(LL_WARNING, ""Failed restoring failed CONFIG SET command. Error setting %s to '%s': %s"",
                      set_configs[i]->name, old_values[i], errstr);
    }
    /* Apply backup */
    if (apply_fns) {
        for (i = 0; i < count && apply_fns[i] != NULL; i++) {
            if (!apply_fns[i](&errstr))
                serverLog(LL_WARNING, ""Failed applying restored failed CONFIG SET command: %s"", errstr);
        }
    }
    if (module_configs) {
        if (!moduleConfigApplyConfig(module_configs, &errstr, NULL))
            serverLog(LL_WARNING, ""Failed applying restored failed CONFIG SET command: %s"", errstr);
    }
}",778.0,798.0,1.0,12.0,21.0,29,10,33,9,3,5,8,13,2,5,,0,2,10,5,5,void
2003,69853,configSetCommand,1,configSetCommand,void configSetCommand (client*),config.c,"void configSetCommand(client *c) {
    const char *errstr = NULL;
    const char *invalid_arg_name = NULL;
    const char *err_arg_name = NULL;
    standardConfig **set_configs; /* TODO: make this a dict for better performance */
    list *module_configs_apply;
    const char **config_names;
    sds *new_values;
    sds *old_values = NULL;
    apply_fn *apply_fns; /* TODO: make this a set for better performance */
    int config_count, i, j;
    int invalid_args = 0, deny_loading_error = 0;
    int *config_map_fns;

    /* Make sure we have an even number of arguments: conf-val pairs */
    if (c->argc & 1) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    config_count = (c->argc - 2) / 2;

    module_configs_apply = listCreate();
    set_configs = zcalloc(sizeof(standardConfig*)*config_count);
    config_names = zcalloc(sizeof(char*)*config_count);
    new_values = zmalloc(sizeof(sds*)*config_count);
    old_values = zcalloc(sizeof(sds*)*config_count);
 ...",804.0,964.0,1.0,28.0,161.0,152,20,158,28,0,41,30,32,7,28,,0,24,2,1,1,void
2004,70527,configGetCommand,1,configGetCommand,void configGetCommand (client*),config.c,"void configGetCommand(client *c) {
    int i;
    dictEntry *de;
    dictIterator *di;
    /* Create a dictionary to store the matched configs */
    dict *matches = dictCreate(&externalStringType);
    for (i = 0; i < c->argc - 2; i++) {
        robj *o = c->argv[2+i];
        sds name = o->ptr;

        /* If the string doesn't contain glob patterns, just directly
         * look up the key in the dictionary. */
        if (!strpbrk(name, ""[*?"")) {
            if (dictFind(matches, name)) continue;
            standardConfig *config = lookupConfig(name);

            if (config) {
                dictAdd(matches, name, config);
            }
            continue;
        }

        /* Otherwise, do a match against all items in the dictionary. */
        di = dictGetIterator(configs);
        
        while ((de = dictNext(di)) != NULL) {
            standardConfig *config = dictGetVal(de);
            /* Note that hidden configs require an exact match (not a pattern) */
          ...",970.0,1016.0,1.0,32.0,47.0,34,13,53,11,0,31,14,22,9,23,,0,23,2,1,1,void
2005,70706,rewriteConfigSentinelOption,1,rewriteConfigSentinelOption,void rewriteConfigSentinelOption (rewriteConfigState*),sentinel.c,"void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
    dictIterator *di, *di2;
    dictEntry *de;
    sds line;

    /* sentinel unique ID. */
    line = sdscatprintf(sdsempty(), ""sentinel myid %s"", sentinel.myid);
    rewriteConfigRewriteLine(state,""sentinel myid"",line,1);

    /* sentinel deny-scripts-reconfig. */
    line = sdscatprintf(sdsempty(), ""sentinel deny-scripts-reconfig %s"",
        sentinel.deny_scripts_reconfig ? ""yes"" : ""no"");
    rewriteConfigRewriteLine(state,""sentinel deny-scripts-reconfig"",line,
        sentinel.deny_scripts_reconfig != SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG);

    /* sentinel resolve-hostnames.
     * This must be included early in the file so it is already in effect
     * when reading the file.
     */
    line = sdscatprintf(sdsempty(), ""sentinel resolve-hostnames %s"",
                        sentinel.resolve_hostnames ? ""yes"" : ""no"");
    rewriteConfigRewriteLine(state,""sentinel resolve-hostnames"",line,
                    ...",2029.0,2276.0,1.0,42.0,248.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2006,70740,rewriteConfigReleaseState,1,rewriteConfigReleaseState,void rewriteConfigReleaseState (rewriteConfigState*),config.c,"void rewriteConfigReleaseState(struct rewriteConfigState *state) {
    sdsfreesplitres(state->lines,state->numlines);
    dictRelease(state->option_to_line);
    dictRelease(state->rewritten);
    zfree(state);
}",1067.0,1072.0,1.0,1.0,6.0,4,1,5,1,3,8,1,1,0,4,,0,4,2,1,1,void
2007,70762,rewriteConfigCreateState,1,rewriteConfigCreateState,struct rewriteConfigState rewriteConfigCreateState (void),config.c,"struct rewriteConfigState *rewriteConfigCreateState(void) {
    struct rewriteConfigState *state = zmalloc(sizeof(*state));
    state->option_to_line = dictCreate(&optionToLineDictType);
    state->rewritten = dictCreate(&optionSetDictType);
    state->numlines = 0;
    state->lines = NULL;
    state->needs_signature = 1;
    state->force_write = 0;
    return state;
}",1075.0,1084.0,1.0,1.0,10.0,17,5,12,4,2,11,1,1,0,3,,0,11,2,1,1,struct rewriteConfigState
2008,70810,rewriteConfigAppendLine,1,rewriteConfigAppendLine,"void rewriteConfigAppendLine (rewriteConfigState*,sds)",config.c,"void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));
    state->lines[state->numlines++] = line;
}",1087.0,1090.0,1.0,1.0,4.0,12,7,7,3,3,6,1,1,0,1,,0,6,4,2,2,void
2009,70842,rewriteConfigAddLineNumberToOption,1,rewriteConfigAddLineNumberToOption,"void rewriteConfigAddLineNumberToOption (rewriteConfigState*,sds,int)",config.c,"void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
    list *l = dictFetchValue(state->option_to_line,option);

    if (l == NULL) {
        l = listCreate();
        dictAdd(state->option_to_line,sdsdup(option),l);
    }
    listAddNodeTail(l,(void*)(long)linenum);
}",1093.0,1101.0,1.0,1.0,9.0,7,4,11,5,1,7,2,2,0,5,,0,5,6,3,3,void
2010,70879,rewriteConfigMarkAsProcessed,1,rewriteConfigMarkAsProcessed,"void rewriteConfigMarkAsProcessed (rewriteConfigState*,char*)",config.c,"void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
    sds opt = sdsnew(option);

    if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
}",1107.0,1111.0,1.0,46.0,5.0,3,3,6,4,11,4,2,2,2,3,,0,3,4,2,2,void
2011,70904,rewriteConfigReadOldFile,1,rewriteConfigReadOldFile,struct rewriteConfigState rewriteConfigReadOldFile (char*),config.c,"struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
    FILE *fp = fopen(path,""r"");
    if (fp == NULL && errno != ENOENT) return NULL;

    struct redis_stat sb;
    if (fp && redis_fstat(fileno(fp),&sb) == -1) return NULL;

    int linenum = -1;
    struct rewriteConfigState *state = rewriteConfigCreateState();

    if (fp == NULL || sb.st_size == 0) return state;

    /* Load the file content */
    sds config = sdsnewlen(SDS_NOINIT,sb.st_size);
    if (fread(config,1,sb.st_size,fp) == 0) {
        sdsfree(config);
        rewriteConfigReleaseState(state);
        fclose(fp);
        return NULL;
    }

    int i, totlines;
    sds *lines = sdssplitlen(config,sdslen(config),""\n"",1,&totlines);

    /* Read the old content line by line, populate the state. */
    for (i = 0; i < totlines; i++) {
        int argc;
        sds *argv;
        sds line = sdstrim(lines[i],""\r\n\t "");
        lines[i] = NULL;

        linenum++; /* Zero based, so we init at -1 */

        /...",1118.0,1213.0,1.0,11.0,96.0,77,16,98,20,1,31,14,20,3,27,,0,17,2,1,1,struct rewriteConfigState
2012,71232,rewriteConfigRewriteLine,1,rewriteConfigRewriteLine,"int rewriteConfigRewriteLine (rewriteConfigState*,char*,sds,int)",config.c,"int rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
    sds o = sdsnew(option);
    list *l = dictFetchValue(state->option_to_line,o);

    rewriteConfigMarkAsProcessed(state,option);

    if (!l && !force && !state->force_write) {
        /* Option not used previously, and we are not forced to use it. */
        sdsfree(line);
        sdsfree(o);
        return 0;
    }

    if (l) {
        listNode *ln = listFirst(l);
        int linenum = (long) ln->value;

        /* There are still lines in the old configuration file we can reuse
         * for this option. Replace the line with the new one. */
        listDelNode(l,ln);
        if (listLength(l) == 0) dictDelete(state->option_to_line,o);
        sdsfree(state->lines[linenum]);
        state->lines[linenum] = line;
    } else {
        /* Append a new line. */
        if (state->needs_signature) {
            rewriteConfigAppendLine(state,
                sdsnew(REDIS_CONFI...",1231.0,1265.0,1.0,23.0,35.0,22,7,30,8,17,17,4,5,2,9,,0,10,8,4,4,int
2013,71350,rewriteConfigFormatMemory,1,rewriteConfigFormatMemory,"int rewriteConfigFormatMemory (char*,size_t,long long)",config.c,"int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {
    int gb = 1024*1024*1024;
    int mb = 1024*1024;
    int kb = 1024;

    if (bytes && (bytes % gb) == 0) {
        return snprintf(buf,len,""%lldgb"",bytes/gb);
    } else if (bytes && (bytes % mb) == 0) {
        return snprintf(buf,len,""%lldmb"",bytes/mb);
    } else if (bytes && (bytes % kb) == 0) {
        return snprintf(buf,len,""%lldkb"",bytes/kb);
    } else {
        return snprintf(buf,len,""%lld"",bytes);
    }
}",1269.0,1283.0,1.0,1.0,15.0,10,6,10,6,3,0,2,2,0,0,,0,0,6,3,3,int
2014,71438,rewriteConfigBytesOption,1,rewriteConfigBytesOption,"void rewriteConfigBytesOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigBytesOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    char buf[64];
    int force = value != defvalue;
    sds line;

    rewriteConfigFormatMemory(buf,sizeof(buf),value);
    line = sdscatprintf(sdsempty(),""%s %s"",option,buf);
    rewriteConfigRewriteLine(state,option,line,force);
}",1286.0,1294.0,1.0,1.0,9.0,4,3,13,7,0,4,1,1,0,4,,0,2,8,4,4,void
2015,71471,rewriteConfigPercentOption,1,rewriteConfigPercentOption,"void rewriteConfigPercentOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigPercentOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %lld%%"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1297.0,1302.0,1.0,1.0,6.0,3,2,10,6,1,3,1,1,0,3,,0,2,8,4,4,void
2016,71498,rewriteConfigYesNoOption,1,rewriteConfigYesNoOption,"void rewriteConfigYesNoOption (rewriteConfigState*,char*,int,int)",config.c,"void rewriteConfigYesNoOption(struct rewriteConfigState *state, const char *option, int value, int defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %s"",option,
        value ? ""yes"" : ""no"");

    rewriteConfigRewriteLine(state,option,line,force);
}",1305.0,1311.0,1.0,1.0,7.0,4,3,10,6,1,3,1,1,0,3,,0,2,8,4,4,void
2017,71528,rewriteConfigStringOption,1,rewriteConfigStringOption,"void rewriteConfigStringOption (rewriteConfigState*,char*,char*,char*)",config.c,"void rewriteConfigStringOption(struct rewriteConfigState *state, const char *option, char *value, const char *defvalue) {
    int force = 1;
    sds line;

    /* String options set to NULL need to be not present at all in the
     * configuration file to be set to NULL again at the next reboot. */
    if (value == NULL) {
        rewriteConfigMarkAsProcessed(state,option);
        return;
    }

    /* Set force to zero if the value is set to its default. */
    if (defvalue && strcmp(value,defvalue) == 0) force = 0;

    line = sdsnew(option);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, value, strlen(value));

    rewriteConfigRewriteLine(state,option,line,force);
}",1314.0,1333.0,1.0,1.0,20.0,8,3,21,7,2,5,3,3,0,5,,0,3,8,4,4,void
2018,71584,rewriteConfigSdsOption,1,rewriteConfigSdsOption,"void rewriteConfigSdsOption (rewriteConfigState*,char*,sds,char*)",config.c,"void rewriteConfigSdsOption(struct rewriteConfigState *state, const char *option, sds value, const char *defvalue) {
    int force = 1;
    sds line;

    /* If there is no value set, we don't want the SDS option
     * to be present in the configuration at all. */
    if (value == NULL) {
        rewriteConfigMarkAsProcessed(state, option);
        return;
    }

    /* Set force to zero if the value is set to its default. */
    if (defvalue && strcmp(value, defvalue) == 0) force = 0;

    line = sdsnew(option);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, value, sdslen(value));

    rewriteConfigRewriteLine(state, option, line, force);
}",1336.0,1355.0,1.0,1.0,20.0,8,3,21,7,1,6,3,3,0,6,,0,4,8,4,4,void
2019,71640,rewriteConfigNumericalOption,1,rewriteConfigNumericalOption,"void rewriteConfigNumericalOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigNumericalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %lld"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1358.0,1363.0,1.0,1.0,6.0,3,2,10,6,0,3,1,1,0,3,,0,2,8,4,4,void
2020,71667,rewriteConfigOctalOption,1,rewriteConfigOctalOption,"void rewriteConfigOctalOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigOctalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %llo"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1366.0,1371.0,1.0,1.0,6.0,3,2,10,6,0,3,1,1,0,3,,0,2,8,4,4,void
2021,71694,rewriteConfigEnumOption,1,rewriteConfigEnumOption,"void rewriteConfigEnumOption (rewriteConfigState*,char*,int,standardConfig*)",config.c,"void rewriteConfigEnumOption(struct rewriteConfigState *state, const char *option, int value, standardConfig *config) {
    int multiarg = config->flags & MULTI_ARG_CONFIG;
    sds names = configEnumGetName(config->data.enumd.enum_value,value,multiarg);
    sds line = sdscatfmt(sdsempty(),""%s %s"",option,names);
    sdsfree(names);
    int force = value != config->data.enumd.default_value;

    rewriteConfigRewriteLine(state,option,line,force);
}",1376.0,1384.0,1.0,35.0,9.0,14,6,17,8,1,8,1,1,0,5,,0,6,8,4,4,void
2022,71754,rewriteConfigSaveOption,1,rewriteConfigSaveOption,"void rewriteConfigSaveOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigSaveOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int j;
    sds line;

    /* In Sentinel mode we don't need to rewrite the save parameters */
    if (server.sentinel_mode) {
        rewriteConfigMarkAsProcessed(state,name);
        return;
    }

    /* Rewrite save parameters, or an empty 'save """"' line to avoid the
     * defaults from being used.
     */
    if (!server.saveparamslen) {
        rewriteConfigRewriteLine(state,name,sdsnew(""save \""\""""),1);
    } else {
        for (j = 0; j < server.saveparamslen; j++) {
            line = sdscatprintf(sdsempty(),""save %ld %d"",
                (long) server.saveparams[j].seconds, server.saveparams[j].changes);
            rewriteConfigRewriteLine(state,name,line,1);
        }
    }

    /* Mark ""save"" as processed in case server.saveparamslen is zero. */
    rewriteConfigMarkAsProcessed(state,name);
}",1387.0,1413.0,1.0,4.0,27.0,4,3,10,4,0,4,3,3,0,4,,0,1,6,3,3,void
2023,71834,rewriteConfigUserOption,1,rewriteConfigUserOption,void rewriteConfigUserOption (rewriteConfigState*),config.c,"void rewriteConfigUserOption(struct rewriteConfigState *state) {
    /* If there is a user file defined we just mark this configuration
     * directive as processed, so that all the lines containing users
     * inside the config file gets discarded. */
    if (server.acl_filename[0] != '\0') {
        rewriteConfigMarkAsProcessed(state,""user"");
        return;
    }

    /* Otherwise scan the list of users and rewrite every line. Note that
     * in case the list here is empty, the effect will just be to comment
     * all the users directive inside the config file. */
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        sds line = sdsnew(""user "");
        line = sdscatsds(line,u->name);
        line = sdscatlen(line,"" "",1);
        robj *descr = ACLDescribeUser(u);
        line = sdscatsds(line,descr->ptr);
        decrRefCount(descr);
        rewriteConfigRewriteLine(state,""user"",line,1);
    }
   ...",1416.0,1445.0,1.0,1.0,30.0,16,6,25,8,1,15,3,3,1,13,,0,8,2,1,1,void
2024,71917,rewriteConfigDirOption,1,rewriteConfigDirOption,"void rewriteConfigDirOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigDirOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    char cwd[1024];

    if (getcwd(cwd,sizeof(cwd)) == NULL) {
        rewriteConfigMarkAsProcessed(state,name);
        return; /* no rewrite on error. */
    }
    rewriteConfigStringOption(state,name,cwd,NULL);
}",1448.0,1457.0,1.0,4.0,10.0,3,3,11,5,0,2,2,2,0,2,,0,0,6,3,3,void
2025,71948,rewriteConfigReplicaOfOption,1,rewriteConfigReplicaOfOption,"void rewriteConfigReplicaOfOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigReplicaOfOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    sds line;

    /* If this is a master, we want all the slaveof config options
     * in the file to be removed. Note that if this is a cluster instance
     * we don't want a slaveof directive inside redis.conf. */
    if (server.cluster_enabled || server.masterhost == NULL) {
        rewriteConfigMarkAsProcessed(state, name);
        return;
    }
    line = sdscatprintf(sdsempty(),""%s %s %d"", name,
        server.masterhost, server.masterport);
    rewriteConfigRewriteLine(state,name,line,1);
}",1460.0,1474.0,1.0,4.0,15.0,8,5,14,6,0,4,2,2,0,4,,0,2,6,3,3,void
2026,71994,rewriteConfigNotifyKeyspaceEventsOption,1,rewriteConfigNotifyKeyspaceEventsOption,"void rewriteConfigNotifyKeyspaceEventsOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigNotifyKeyspaceEventsOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = server.notify_keyspace_events != 0;
    sds line, flags;

    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);
    line = sdsnew(name);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, flags, sdslen(flags));
    sdsfree(flags);
    rewriteConfigRewriteLine(state,name,line,force);
}",1477.0,1488.0,1.0,4.0,12.0,9,4,19,7,0,7,1,1,0,7,,0,5,6,3,3,void
2027,72047,rewriteConfigClientOutputBufferLimitOption,1,rewriteConfigClientOutputBufferLimitOption,"void rewriteConfigClientOutputBufferLimitOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigClientOutputBufferLimitOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int j;
    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
        int force = (server.client_obuf_limits[j].hard_limit_bytes !=
                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||
                    (server.client_obuf_limits[j].soft_limit_bytes !=
                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||
                    (server.client_obuf_limits[j].soft_limit_seconds !=
                    clientBufferLimitsDefaults[j].soft_limit_seconds);
        sds line;
        char hard[64], soft[64];

        rewriteConfigFormatMemory(hard,sizeof(hard),
                server.client_obuf_limits[j].hard_limit_bytes);
        rewriteConfigFormatMemory(soft,sizeof(soft),
                server.client_obuf_limits[j].soft_limit_bytes);

        char *typename = getClientTypeName(j);
        if (!strcmp(typename,""...",1491.0,1516.0,1.0,4.0,26.0,40,9,40,11,0,9,3,4,0,6,,0,6,6,3,3,void
2028,72180,rewriteConfigOOMScoreAdjValuesOption,1,rewriteConfigOOMScoreAdjValuesOption,"void rewriteConfigOOMScoreAdjValuesOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigOOMScoreAdjValuesOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = 0;
    int j;
    sds line;

    line = sdsnew(name);
    line = sdscatlen(line, "" "", 1);
    for (j = 0; j < CONFIG_OOM_COUNT; j++) {
        if (server.oom_score_adj_values[j] != configOOMScoreAdjValuesDefaults[j])
            force = 1;

        line = sdscatprintf(line, ""%d"", server.oom_score_adj_values[j]);
        if (j+1 != CONFIG_OOM_COUNT)
            line = sdscatlen(line, "" "", 1);
    }
    rewriteConfigRewriteLine(state,name,line,force);
}",1519.0,1536.0,1.0,4.0,18.0,17,7,25,8,0,6,4,6,1,5,,0,5,6,3,3,void
2029,72266,rewriteConfigBindOption,1,rewriteConfigBindOption,"void rewriteConfigBindOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigBindOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = 1;
    sds line, addresses;
    int is_default = 0;

    /* Compare server.bindaddr with CONFIG_DEFAULT_BINDADDR */
    if (server.bindaddr_count == CONFIG_DEFAULT_BINDADDR_COUNT) {
        is_default = 1;
        char *default_bindaddr[CONFIG_DEFAULT_BINDADDR_COUNT] = CONFIG_DEFAULT_BINDADDR;
        for (int j = 0; j < CONFIG_DEFAULT_BINDADDR_COUNT; j++) {
            if (strcmp(server.bindaddr[j], default_bindaddr[j]) != 0) {
                is_default = 0;
                break;
            }
        }
    }

    if (is_default) {
        rewriteConfigMarkAsProcessed(state,name);
        return;
    }

    /* Rewrite as bind <addr1> <addr2> ... <addrN> */
    if (server.bindaddr_count > 0)
        addresses = sdsjoin(server.bindaddr,server.bindaddr_count,"" "");
    else
        addresses = sdsnew(""\""\"""");
    line = sdsnew(name);
    line ...",1539.0,1573.0,1.0,4.0,35.0,23,9,33,10,0,7,7,9,0,7,,0,4,6,3,3,void
2030,72390,rewriteConfigLoadmoduleOption,1,rewriteConfigLoadmoduleOption,void rewriteConfigLoadmoduleOption (rewriteConfigState*),config.c,"void rewriteConfigLoadmoduleOption(struct rewriteConfigState *state) {
    sds line;

    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        line = sdsnew(""loadmodule "");
        line = sdscatsds(line, module->loadmod->path);
        for (int i = 0; i < module->loadmod->argc; i++) {
            line = sdscatlen(line, "" "", 1);
            line = sdscatsds(line, module->loadmod->argv[i]->ptr);
        }
        rewriteConfigRewriteLine(state,""loadmodule"",line,1);
    }
    dictReleaseIterator(di);
    /* Mark ""loadmodule"" as processed in case modules is empty. */
    rewriteConfigMarkAsProcessed(state,""loadmodule"");
}",1576.0,1594.0,1.0,1.0,19.0,18,5,24,8,1,13,3,4,2,10,,0,10,2,1,1,void
2031,72473,rewriteConfigGetContentFromState,1,rewriteConfigGetContentFromState,sds rewriteConfigGetContentFromState (rewriteConfigState*),config.c,"sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
    sds content = sdsempty();
    int j, was_empty = 0;

    for (j = 0; j < state->numlines; j++) {
        /* Every cluster of empty lines is turned into a single empty line. */
        if (sdslen(state->lines[j]) == 0) {
            if (was_empty) continue;
            was_empty = 1;
        } else {
            was_empty = 0;
        }
        content = sdscatsds(content,state->lines[j]);
        content = sdscatlen(content,""\n"",1);
    }
    return content;
}",1598.0,1614.0,1.0,1.0,17.0,13,5,16,4,2,7,5,7,3,4,,0,7,2,1,1,sds
2032,72539,rewriteConfigRemoveOrphaned,1,rewriteConfigRemoveOrphaned,void rewriteConfigRemoveOrphaned (rewriteConfigState*),config.c,"void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
    dictIterator *di = dictGetIterator(state->option_to_line);
    dictEntry *de;

    while((de = dictNext(di)) != NULL) {
        list *l = dictGetVal(de);
        sds option = dictGetKey(de);

        /* Don't blank lines about options the rewrite process
         * don't understand. */
        if (dictFind(state->rewritten,option) == NULL) {
            serverLog(LL_DEBUG,""Not rewritten option: %s"", option);
            continue;
        }

        while(listLength(l)) {
            listNode *ln = listFirst(l);
            int linenum = (long) ln->value;

            sdsfree(state->lines[linenum]);
            state->lines[linenum] = sdsempty();
            listDelNode(l,ln);
        }
    }
    dictReleaseIterator(di);
}",1624.0,1649.0,1.0,12.0,26.0,22,9,28,9,1,17,5,6,4,10,,0,13,2,1,1,void
2033,72642,getConfigDebugInfo,1,getConfigDebugInfo,sds getConfigDebugInfo (void),config.c,"sds getConfigDebugInfo(void) {
    struct rewriteConfigState *state = rewriteConfigCreateState();
    state->force_write = 1; /* Force the output */
    state->needs_signature = 0; /* Omit the rewrite signature */

    /* Iterate the configs and ""rewrite"" the ones that have 
     * the debug flag. */
    dictIterator *di = dictGetIterator(configs);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        standardConfig *config = dictGetVal(de);
        if (!(config->flags & DEBUG_CONFIG)) continue;
        config->interface.rewrite(config, config->name, state);
    }
    dictReleaseIterator(di);
    sds info = rewriteConfigGetContentFromState(state);
    rewriteConfigReleaseState(state);
    return info;
}",1653.0,1671.0,1.0,30.0,19.0,17,7,20,7,1,14,4,4,2,8,,0,11,2,1,1,sds
2034,72715,rewriteConfigOverwriteFile,1,rewriteConfigOverwriteFile,"int rewriteConfigOverwriteFile (char*,sds)",config.c,"int rewriteConfigOverwriteFile(char *configfile, sds content) {
    int fd = -1;
    int retval = -1;
    char tmp_conffile[PATH_MAX];
    const char *tmp_suffix = "".XXXXXX"";
    size_t offset = 0;
    ssize_t written_bytes = 0;
    int old_errno;

    int tmp_path_len = snprintf(tmp_conffile, sizeof(tmp_conffile), ""%s%s"", configfile, tmp_suffix);
    if (tmp_path_len <= 0 || (unsigned int)tmp_path_len >= sizeof(tmp_conffile)) {
        serverLog(LL_WARNING, ""Config file full path is too long"");
        errno = ENAMETOOLONG;
        return retval;
    }

#if defined(_GNU_SOURCE) && !defined(__HAIKU__)
    fd = mkostemp(tmp_conffile, O_CLOEXEC);
#else
    /* There's a theoretical chance here to leak the FD if a module thread forks & execv in the middle */
    fd = mkstemp(tmp_conffile);
#endif

    if (fd == -1) {
        serverLog(LL_WARNING, ""Could not create tmp config file (%s)"", strerror(errno));
        return retval;
    }

    while (offset < sdslen(content)) {
         writt...",1678.0,1735.0,1.0,8.0,58.0,39,14,50,14,1,6,10,11,1,6,,0,2,4,2,2,int
2035,73033,rewriteConfig,1,rewriteConfig,"int rewriteConfig (char*,int)",config.c,"int rewriteConfig(char *path, int force_write) {
    struct rewriteConfigState *state;
    sds newcontent;
    int retval;

    /* Step 1: read the old config into our rewrite state. */
    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
    if (force_write) state->force_write = 1;

    /* Step 2: rewrite every single option, replacing or appending it inside
     * the rewrite state. */

    /* Iterate the configs that are standard */
    dictIterator *di = dictGetIterator(configs);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        standardConfig *config = dictGetVal(de);
        /* Only rewrite the primary names */
        if (config->flags & ALIAS_CONFIG) continue;
        if (config->interface.rewrite) config->interface.rewrite(config, dictGetKey(de), state);
    }
    dictReleaseIterator(di);

    rewriteConfigUserOption(state);
    rewriteConfigLoadmoduleOption(state);

    /* Rewrite Sentinel config if in Sentinel mode. */
    if (server.sen...",1747.0,1789.0,1.0,28.0,43.0,20,8,32,11,2,20,8,9,4,15,,0,12,4,2,2,int
2036,73146,boolConfigInit,1,boolConfigInit,void boolConfigInit (standardConfig*),config.c,"static void boolConfigInit(standardConfig *config) {
    *config->data.yesno.config = config->data.yesno.default_value;
}",1823.0,1825.0,1.0,1.0,3.0,8,4,2,1,0,2,1,1,0,0,,0,2,2,1,1,void
2037,73167,boolConfigSet,1,boolConfigSet,"int boolConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int boolConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    int yn = yesnotoi(argv[0]);
    if (yn == -1) {
        *err = ""argument must be 'yes' or 'no'"";
        return 0;
    }
    if (config->data.yesno.is_valid_fn && !config->data.yesno.is_valid_fn(yn, err))
        return 0;
    int prev = config->flags & MODULE_CONFIG ? getModuleBoolConfig(config->privdata) : *(config->data.yesno.config);
    if (prev != yn) {
        if (config->flags & MODULE_CONFIG) {
            return setModuleBoolConfig(config->privdata, yn, err);
        }
        *(config->data.yesno.config) = yn;
        return 1;
    }
    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",1827.0,1845.0,1.0,4.0,19.0,39,14,23,6,0,13,5,6,4,4,,0,12,8,4,4,int
2038,73296,boolConfigGet,1,boolConfigGet,sds boolConfigGet (standardConfig*),config.c,"static sds boolConfigGet(standardConfig *config) {
    if (config->flags & MODULE_CONFIG) {
        return sdsnew(getModuleBoolConfig(config->privdata) ? ""yes"" : ""no"");
    }
    return sdsnew(*config->data.yesno.config ? ""yes"" : ""no"");
}",1847.0,1852.0,1.0,24.0,6.0,10,6,3,1,0,6,2,2,1,3,,0,4,2,1,1,sds
2039,73334,boolConfigRewrite,1,boolConfigRewrite,"void boolConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void boolConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    int val = config->flags & MODULE_CONFIG ? getModuleBoolConfig(config->privdata) : *(config->data.yesno.config);
    rewriteConfigYesNoOption(state, name, val, config->data.yesno.default_value);
}",1854.0,1857.0,1.0,30.0,4.0,13,7,8,4,0,6,1,1,0,2,,0,5,6,3,3,void
2040,73377,stringConfigInit,1,stringConfigInit,void stringConfigInit (standardConfig*),config.c,"static void stringConfigInit(standardConfig *config) {
    *config->data.string.config = (config->data.string.convert_empty_to_null && !config->data.string.default_value) ? NULL : zstrdup(config->data.string.default_value);
}",1871.0,1873.0,1.0,1.0,3.0,17,7,5,2,0,5,1,1,0,1,,0,5,2,1,1,void
2041,73417,stringConfigSet,1,stringConfigSet,"int stringConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int stringConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    if (config->data.string.is_valid_fn && !config->data.string.is_valid_fn(argv[0], err))
        return 0;
    char *prev = *config->data.string.config;
    char *new = (config->data.string.convert_empty_to_null && !argv[0][0]) ? NULL : argv[0];
    if (new != prev && (new == NULL || prev == NULL || strcmp(prev, new))) {
        *config->data.string.config = new != NULL ? zstrdup(new) : NULL;
        zfree(prev);
        return 1;
    }
    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",1875.0,1887.0,1.0,4.0,13.0,42,14,28,7,0,9,3,3,3,3,,0,8,8,4,4,int
2042,73539,stringConfigGet,1,stringConfigGet,sds stringConfigGet (standardConfig*),config.c,"static sds stringConfigGet(standardConfig *config) {
    return sdsnew(*config->data.string.config ? *config->data.string.config : """");
}",1889.0,1891.0,1.0,1.0,3.0,9,4,2,1,0,3,1,1,0,1,,0,2,2,1,1,sds
2043,73564,stringConfigRewrite,1,stringConfigRewrite,"void stringConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void stringConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    rewriteConfigStringOption(state, name,*(config->data.string.config), config->data.string.default_value);
}",1893.0,1895.0,1.0,1.0,3.0,7,3,4,3,0,3,1,1,0,1,,0,2,6,3,3,void
2044,73589,sdsConfigInit,1,sdsConfigInit,void sdsConfigInit (standardConfig*),config.c,"static void sdsConfigInit(standardConfig *config) {
    *config->data.sds.config = (config->data.sds.convert_empty_to_null && !config->data.sds.default_value) ? NULL : sdsnew(config->data.sds.default_value);
}",1898.0,1900.0,1.0,1.0,3.0,17,7,5,2,0,5,1,1,0,1,,0,5,2,1,1,void
2045,73629,sdsConfigSet,1,sdsConfigSet,"int sdsConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int sdsConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    if (config->data.sds.is_valid_fn && !config->data.sds.is_valid_fn(argv[0], err))
        return 0;

    sds prev = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    sds new = (config->data.string.convert_empty_to_null && (sdslen(argv[0]) == 0)) ? NULL : argv[0];

    /* if prev and new configuration are not equal, set the new one */
    if (new != prev && (new == NULL || prev == NULL || sdscmp(prev, new))) {
        /* If MODULE_CONFIG flag is set, then free temporary prev getModuleStringConfig returned.
         * Otherwise, free the actual previous config value Redis held (Same action, different reasons) */
        sdsfree(prev);

        if (config->flags & MODULE_CONFIG) {
            return setModuleStringConfig(config->privdata, new, err);
        }
        *config->data.sds.config = new != NULL ? sdsdup(new) : NUL...",1902.0,1924.0,1.0,4.0,23.0,54,14,37,7,0,19,5,6,6,8,,0,16,8,4,4,int
2046,73798,sdsConfigGet,1,sdsConfigGet,sds sdsConfigGet (standardConfig*),config.c,"static sds sdsConfigGet(standardConfig *config) {
    sds val = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    if (val) {
        if (config->flags & MODULE_CONFIG) return val;
        return sdsdup(val);
    } else {
        return sdsnew("""");
    }
}",1926.0,1934.0,1.0,30.0,9.0,13,7,8,2,0,6,3,4,1,2,,0,5,2,1,1,sds
2047,73852,sdsConfigRewrite,1,sdsConfigRewrite,"void sdsConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void sdsConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    sds val = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    rewriteConfigSdsOption(state, name, val, config->data.sds.default_value);
    if ((val) && (config->flags & MODULE_CONFIG)) sdsfree(val);
}",1936.0,1940.0,1.0,30.0,5.0,17,8,11,4,0,8,2,2,1,3,,0,6,6,3,3,void
2048,73910,enumConfigInit,1,enumConfigInit,void enumConfigInit (standardConfig*),config.c,"static void enumConfigInit(standardConfig *config) {
    *config->data.enumd.config = config->data.enumd.default_value;
}",1971.0,1973.0,1.0,1.0,3.0,8,4,2,1,0,2,1,1,0,0,,0,2,2,1,1,void
2049,73931,enumConfigSet,1,enumConfigSet,"int enumConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int enumConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    int enumval;
    int bitflags = !!(config->flags & MULTI_ARG_CONFIG);
    enumval = configEnumGetValue(config->data.enumd.enum_value, argv, argc, bitflags);

    if (enumval == INT_MIN) {
        sds enumerr = sdsnew(""argument(s) must be one of the following: "");
        configEnum *enumNode = config->data.enumd.enum_value;
        while(enumNode->name != NULL) {
            enumerr = sdscatlen(enumerr, enumNode->name,
                                strlen(enumNode->name));
            enumerr = sdscatlen(enumerr, "", "", 2);
            enumNode++;
        }
        sdsrange(enumerr,0,-3); /* Remove final "", "". */

        redis_strlcpy(loadbuf, enumerr, LOADBUF_SIZE);

        sdsfree(enumerr);
        *err = loadbuf;
        return 0;
    }
    if (config->data.enumd.is_valid_fn && !config->data.enumd.is_valid_fn(enumval, err))
        return 0;
    int prev = config->flags & MODULE_CONFI...",1975.0,2007.0,1.0,38.0,33.0,58,13,44,12,0,27,6,8,5,10,,0,23,8,4,4,int
2050,74128,enumConfigGet,1,enumConfigGet,sds enumConfigGet (standardConfig*),config.c,"static sds enumConfigGet(standardConfig *config) {
    int val = config->flags & MODULE_CONFIG ? getModuleEnumConfig(config->privdata) : *(config->data.enumd.config);
    int bitflags = !!(config->flags & MULTI_ARG_CONFIG);
    return configEnumGetName(config->data.enumd.enum_value,val,bitflags);
}",2009.0,2013.0,1.0,30.0,5.0,19,8,9,3,0,7,1,1,0,2,,0,6,2,1,1,sds
2051,74183,enumConfigRewrite,1,enumConfigRewrite,"void enumConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void enumConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    int val = config->flags & MODULE_CONFIG ? getModuleEnumConfig(config->privdata) : *(config->data.enumd.config);
    rewriteConfigEnumOption(state, name, val, config);
}",2015.0,2018.0,1.0,30.0,4.0,10,7,8,4,0,5,1,1,0,2,,0,4,6,3,3,void
2052,74220,setNumericType,1,setNumericType,"int setNumericType (standardConfig*,long long,char**)",config.c,"int setNumericType(standardConfig *config, long long val, const char **err) {
    if (config->data.numeric.numeric_type == NUMERIC_TYPE_INT) {
        *(config->data.numeric.config.i) = (int) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_UINT) {
        *(config->data.numeric.config.ui) = (unsigned int) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_LONG) {
        *(config->data.numeric.config.l) = (long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG) {
        *(config->data.numeric.config.ul) = (unsigned long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_LONG_LONG) {
        if (config->flags & MODULE_CONFIG)
            return setModuleNumericConfig(config->privdata, val, err);
        else *(config->data.numeric.config.ll) = (long long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG) {
        *(config->data.numeric.config.ull) = (unsigned long...",2034.0,2059.0,1.0,28.0,26.0,11,6,4,3,2,2,2,2,1,0,,0,2,6,3,3,int
2053,74517,numericConfigInit,1,numericConfigInit,void numericConfigInit (standardConfig*),config.c,"static void numericConfigInit(standardConfig *config) {
    setNumericType(config, config->data.numeric.default_value, NULL);
}",2088.0,2090.0,1.0,1.0,3.0,3,2,3,2,0,2,1,1,0,1,,0,1,2,1,1,void
2054,74532,numericBoundaryCheck,1,numericBoundaryCheck,"int numericBoundaryCheck (standardConfig*,long long,char**)",config.c,"static int numericBoundaryCheck(standardConfig *config, long long ll, const char **err) {
    if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG ||
        config->data.numeric.numeric_type == NUMERIC_TYPE_UINT ||
        config->data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) {
        /* Boundary check for unsigned types */
        unsigned long long ull = ll;
        unsigned long long upper_bound = config->data.numeric.upper_bound;
        unsigned long long lower_bound = config->data.numeric.lower_bound;
        if (ull > upper_bound || ull < lower_bound) {
            if (config->data.numeric.flags & OCTAL_CONFIG) {
                snprintf(loadbuf, LOADBUF_SIZE,
                    ""argument must be between %llo and %llo inclusive"",
                    lower_bound,
                    upper_bound);
            } else {
                snprintf(loadbuf, LOADBUF_SIZE,
                    ""argument must be between %llu and %llu inclusive"",
                    low...",2092.0,2137.0,1.0,45.0,46.0,33,10,22,10,1,8,4,7,4,0,,0,8,6,3,3,int
2055,74745,numericParseString,1,numericParseString,"int numericParseString (standardConfig*,sds,char**,long long*)",config.c,"static int numericParseString(standardConfig *config, sds value, const char **err, long long *res) {
    /* First try to parse as memory */
    if (config->data.numeric.flags & MEMORY_CONFIG) {
        int memerr;
        *res = memtoull(value, &memerr);
        if (!memerr)
            return 1;
    }

    /* Attempt to parse as percent */
    if (config->data.numeric.flags & PERCENT_CONFIG &&
        sdslen(value) > 1 && value[sdslen(value)-1] == '%' &&
        string2ll(value, sdslen(value)-1, res) &&
        *res >= 0) {
            /* We store percentage as negative value */
            *res = -*res;
            return 1;
    }

    /* Attempt to parse as an octal number */
    if (config->data.numeric.flags & OCTAL_CONFIG) {
        char *endptr;
        errno = 0;
        *res = strtoll(value, &endptr, 8);
        if (errno == 0 && *endptr == '\0')
            return 1; /* No overflow or invalid characters */
    }

    /* Attempt a simple number (no special flags set) */
   ...",2139.0,2182.0,1.0,37.0,44.0,60,15,29,7,1,13,8,10,12,7,,0,13,8,4,4,int
2056,74972,numericConfigSet,1,numericConfigSet,"int numericConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int numericConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    long long ll, prev = 0;

    if (!numericParseString(config, argv[0], err, &ll))
        return 0;

    if (!numericBoundaryCheck(config, ll, err))
        return 0;

    if (config->data.numeric.is_valid_fn && !config->data.numeric.is_valid_fn(ll, err))
        return 0;

    GET_NUMERIC_TYPE(prev)
    if (prev != ll) {
        return setNumericType(config, ll, err);
    }

    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",2184.0,2203.0,1.0,4.0,20.0,124,14,64,16,0,30,5,5,5,5,,0,29,8,4,4,int
2057,75327,numericConfigGet,1,numericConfigGet,sds numericConfigGet (standardConfig*),config.c,"static sds numericConfigGet(standardConfig *config) {
    char buf[128];

    long long value = 0;
    GET_NUMERIC_TYPE(value)

    if (config->data.numeric.flags & PERCENT_CONFIG && value < 0) {
        int len = ll2string(buf, sizeof(buf), -value);
        buf[len] = '%';
        buf[len+1] = '\0';
    }
    else if (config->data.numeric.flags & MEMORY_CONFIG) {
        ull2string(buf, sizeof(buf), value);
    } else if (config->data.numeric.flags & OCTAL_CONFIG) {
        snprintf(buf, sizeof(buf), ""%llo"", value);
    } else {
        ll2string(buf, sizeof(buf), value);
    }
    return sdsnew(buf);
}",2205.0,2224.0,1.0,4.0,20.0,121,13,56,14,0,26,2,2,1,3,,0,25,2,1,1,sds
2058,75700,numericConfigRewrite,1,numericConfigRewrite,"void numericConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void numericConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    long long value = 0;

    GET_NUMERIC_TYPE(value)

    if (config->data.numeric.flags & PERCENT_CONFIG && value < 0) {
        rewriteConfigPercentOption(state, name, -value, config->data.numeric.default_value);
    } else if (config->data.numeric.flags & MEMORY_CONFIG) {
        rewriteConfigBytesOption(state, name, value, config->data.numeric.default_value);
    } else if (config->data.numeric.flags & OCTAL_CONFIG) {
        rewriteConfigOctalOption(state, name, value, config->data.numeric.default_value);
    } else {
        rewriteConfigNumericalOption(state, name, value, config->data.numeric.default_value);
    }
}",2226.0,2240.0,1.0,4.0,15.0,117,10,51,14,0,26,2,2,1,2,,0,25,6,3,3,void
2059,76096,isValidDBfilename,1,isValidDBfilename,"int isValidDBfilename (char*,char**)",config.c,"static int isValidDBfilename(char *val, const char **err) {
    if (!pathIsBaseName(val)) {
        *err = ""dbfilename can't be a path, just a filename"";
        return 0;
    }
    return 1;
}",2345.0,2351.0,1.0,1.0,7.0,3,3,2,2,0,1,2,2,1,1,,0,1,4,2,2,int
2060,76115,isValidAOFfilename,1,isValidAOFfilename,"int isValidAOFfilename (char*,char**)",config.c,"static int isValidAOFfilename(char *val, const char **err) {
    if (!strcmp(val, """")) {
        *err = ""appendfilename can't be empty"";
        return 0;
    }
    if (!pathIsBaseName(val)) {
        *err = ""appendfilename can't be a path, just a filename"";
        return 0;
    }
    return 1;
}",2353.0,2363.0,1.0,1.0,11.0,6,3,4,2,0,1,3,3,1,1,,0,1,4,2,2,int
2061,76146,isValidAOFdirname,1,isValidAOFdirname,"int isValidAOFdirname (char*,char**)",config.c,"static int isValidAOFdirname(char *val, const char **err) {
    if (!strcmp(val, """")) {
        *err = ""appenddirname can't be empty"";
        return 0;
    }
    if (!pathIsBaseName(val)) {
        *err = ""appenddirname can't be a path, just a dirname"";
        return 0;
    }
    return 1;
}",2365.0,2375.0,1.0,1.0,11.0,6,3,4,2,0,1,3,3,1,1,,0,1,4,2,2,int
2062,76204,isValidAnnouncedNodename,1,isValidAnnouncedNodename,"int isValidAnnouncedNodename (char*,char**)",config.c,"static int isValidAnnouncedNodename(char *val,const char **err) {
    if (!(isValidAuxString(val,sdslen(val)))) {
        *err = ""Announced human node name contained invalid character"";
	return 0;
    }
    return 1;
}",2387.0,2393.0,1.0,1.0,7.0,3,3,3,2,0,2,2,2,2,2,,0,2,4,2,2,int
2063,76305,isValidProcTitleTemplate,1,isValidProcTitleTemplate,"int isValidProcTitleTemplate (char*,char**)",config.c,"static int isValidProcTitleTemplate(char *val, const char **err) {
    if (!validateProcTitleTemplate(val)) {
        *err = ""template format is invalid or contains unknown variables"";
        return 0;
    }
    return 1;
}",2420.0,2426.0,1.0,1.0,7.0,3,3,2,2,0,1,2,2,1,1,,0,1,4,2,2,int
2064,76350,updateProcTitleTemplate,1,updateProcTitleTemplate,int updateProcTitleTemplate (char**),config.c,"static int updateProcTitleTemplate(const char **err) {
    if (redisSetProcTitle(NULL) == C_ERR) {
        *err = ""failed to set process title"";
        return 0;
    }
    return 1;
}",2437.0,2443.0,1.0,35.0,7.0,4,4,2,2,0,1,2,2,1,1,,0,1,2,1,1,int
2065,76424,updatePort,1,updatePort,int updatePort (char**),config.c,"static int updatePort(const char **err) {
    connListener *listener = listenerByType(CONN_TYPE_SOCKET);

    serverAssert(listener != NULL);
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.port;
    listener->ct = connectionByType(CONN_TYPE_SOCKET);
    if (changeListener(listener) == C_ERR) {
        *err = ""Unable to listen on this port. Check server logs."";
        return 0;
    }

    return 1;
}",2455.0,2469.0,1.0,44.0,15.0,21,11,12,4,0,8,2,2,1,4,,0,7,2,1,1,int
2066,76498,updateJemallocBgThread,1,updateJemallocBgThread,int updateJemallocBgThread (char**),config.c,"static int updateJemallocBgThread(const char **err) {
    UNUSED(err);
    set_jemalloc_bg_thread(server.jemalloc_bg_thread);
    return 1;
}",2471.0,2475.0,1.0,4.0,5.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,int
2067,76515,updateReplBacklogSize,1,updateReplBacklogSize,int updateReplBacklogSize (char**),config.c,"static int updateReplBacklogSize(const char **err) {
    UNUSED(err);
    resizeReplicationBacklog();
    return 1;
}",2477.0,2481.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2068,76529,updateMaxmemory,1,updateMaxmemory,int updateMaxmemory (char**),config.c,"static int updateMaxmemory(const char **err) {
    UNUSED(err);
    if (server.maxmemory) {
        size_t used = zmalloc_used_memory()-freeMemoryGetNotCountedMemory();
        if (server.maxmemory < used) {
            serverLog(LL_WARNING,""WARNING: the new maxmemory value set via CONFIG SET (%llu) is smaller than the current memory usage (%zu). This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy."", server.maxmemory, used);
        }
        startEvictionTimeProc();
    }
    return 1;
}",2483.0,2493.0,1.0,4.0,11.0,10,6,9,3,0,4,3,4,0,4,,0,2,2,1,1,int
2069,76583,updateGoodSlaves,1,updateGoodSlaves,int updateGoodSlaves (char**),config.c,"static int updateGoodSlaves(const char **err) {
    UNUSED(err);
    refreshGoodSlavesCount();
    return 1;
}",2495.0,2499.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2070,76597,updateWatchdogPeriod,1,updateWatchdogPeriod,int updateWatchdogPeriod (char**),config.c,"static int updateWatchdogPeriod(const char **err) {
    UNUSED(err);
    applyWatchdogPeriod();
    return 1;
}",2501.0,2505.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2071,76611,updateAppendonly,1,updateAppendonly,int updateAppendonly (char**),config.c,"static int updateAppendonly(const char **err) {
    if (!server.aof_enabled && server.aof_state != AOF_OFF) {
        stopAppendOnly();
    } else if (server.aof_enabled && server.aof_state == AOF_OFF) {
        if (startAppendOnly() == C_ERR) {
            *err = ""Unable to turn on AOF. Check server logs."";
            return 0;
        }
    }
    return 1;
}",2507.0,2517.0,1.0,51.0,11.0,5,4,2,1,0,1,2,2,0,1,,0,0,2,1,1,int
2072,76662,updateAofAutoGCEnabled,1,updateAofAutoGCEnabled,int updateAofAutoGCEnabled (char**),config.c,"static int updateAofAutoGCEnabled(const char **err) {
    UNUSED(err);
    if (!server.aof_disable_auto_gc) {
        aofDelHistoryFiles();
    }

    return 1;
}",2519.0,2526.0,1.0,4.0,8.0,3,3,3,2,0,1,2,2,0,1,,0,0,2,1,1,int
2073,76682,updateSighandlerEnabled,1,updateSighandlerEnabled,int updateSighandlerEnabled (char**),config.c,"static int updateSighandlerEnabled(const char **err) {
    UNUSED(err);
    if (server.crashlog_enabled)
        setupSignalHandlers();
    else
        removeSignalHandlers();
    return 1;
}",2528.0,2535.0,1.0,4.0,8.0,2,2,3,2,0,1,2,2,0,1,,0,0,2,1,1,int
2074,76704,updateMaxclients,1,updateMaxclients,int updateMaxclients (char**),config.c,"static int updateMaxclients(const char **err) {
    unsigned int new_maxclients = server.maxclients;
    adjustOpenFilesLimit();
    if (server.maxclients != new_maxclients) {
        static char msg[128];
        snprintf(msg, sizeof(msg), ""The operating system is not able to handle the specified number of clients, try with %d"", server.maxclients);
        *err = msg;
        return 0;
    }
    if ((unsigned int) aeGetSetSize(server.el) <
        server.maxclients + CONFIG_FDSET_INCR)
    {
        if (aeResizeSetSize(server.el,
            server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)
        {
            *err = ""The event loop API used by Redis is not able to handle the specified number of clients"";
            return 0;
        }
    }
    return 1;
}",2537.0,2557.0,1.0,28.0,21.0,22,10,14,4,0,3,4,5,2,3,,0,2,2,1,1,int
2075,76784,updateOOMScoreAdj,1,updateOOMScoreAdj,int updateOOMScoreAdj (char**),config.c,"static int updateOOMScoreAdj(const char **err) {
    if (setOOMScoreAdj(-1) == C_ERR) {
        *err = ""Failed to set current oom_score_adj. Check server logs."";
        return 0;
    }

    return 1;
}",2559.0,2566.0,1.0,30.0,8.0,5,4,1,1,0,1,2,2,1,1,,0,1,2,1,1,int
2076,76807,updateRequirePass,1,updateRequirePass,int updateRequirePass (char**),config.c,"int updateRequirePass(const char **err) {
    UNUSED(err);
    /* The old ""requirepass"" directive just translates to setting
     * a password to the default user. The only thing we do
     * additionally is to remember the cleartext password in this
     * case, for backward compatibility with Redis <= 5. */
    ACLUpdateDefaultUserPassword(server.requirepass);
    return 1;
}",2568.0,2576.0,1.0,4.0,9.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,int
2077,76824,updateAppendFsync,1,updateAppendFsync,int updateAppendFsync (char**),config.c,"int updateAppendFsync(const char **err) {
    UNUSED(err);
    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        /* Wait for all bio jobs related to AOF to drain before proceeding. This prevents a race
         * between updates to `fsynced_reploff_pending` done in the main thread and those done on the
         * worker thread. */
        bioDrainWorker(BIO_AOF_FSYNC);
    }
    return 1;
}",2578.0,2587.0,1.0,4.0,10.0,3,3,4,3,0,1,2,2,0,1,,0,0,2,1,1,int
2078,76848,applyBind,1,applyBind,int applyBind (char**),config.c,"static int applyBind(const char **err) {
    connListener *tcp_listener = listenerByType(CONN_TYPE_SOCKET);
    connListener *tls_listener = listenerByType(CONN_TYPE_TLS);

    serverAssert(tcp_listener != NULL);
    tcp_listener->bindaddr = server.bindaddr;
    tcp_listener->bindaddr_count = server.bindaddr_count;
    tcp_listener->port = server.port;
    tcp_listener->ct = connectionByType(CONN_TYPE_SOCKET);
    if (changeListener(tcp_listener) == C_ERR) {
        *err = ""Failed to bind to specified addresses."";
        if (tls_listener)
            closeListener(tls_listener); /* failed with TLS together */
        return 0;
    }

    if (server.tls_port != 0) {
        serverAssert(tls_listener != NULL);
        tls_listener->bindaddr = server.bindaddr;
        tls_listener->bindaddr_count = server.bindaddr_count;
        tls_listener->port = server.tls_port;
        tls_listener->ct = connectionByType(CONN_TYPE_TLS);
        if (changeListener(tls_listener) == C_ERR) {
       ...",2590.0,2620.0,1.0,48.0,31.0,44,11,28,5,0,18,5,7,2,10,,0,14,2,1,1,int
2079,77003,updateClusterFlags,1,updateClusterFlags,int updateClusterFlags (char**),config.c,"int updateClusterFlags(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfFlags();
    return 1;
}",2622.0,2626.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2080,77017,updateClusterAnnouncedPort,1,updateClusterAnnouncedPort,int updateClusterAnnouncedPort (char**),config.c,"static int updateClusterAnnouncedPort(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfAnnouncedPorts();
    return 1;
}",2628.0,2632.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2081,77031,updateClusterIp,1,updateClusterIp,int updateClusterIp (char**),config.c,"static int updateClusterIp(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfIp();
    return 1;
}",2634.0,2638.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2082,77045,updateClusterHostname,1,updateClusterHostname,int updateClusterHostname (char**),config.c,"int updateClusterHostname(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfHostname();
    return 1;
}",2640.0,2644.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2083,77059,updateClusterHumanNodename,1,updateClusterHumanNodename,int updateClusterHumanNodename (char**),config.c,"int updateClusterHumanNodename(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfHumanNodename();
    return 1;
}",2646.0,2650.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
2084,77073,applyTlsCfg,1,applyTlsCfg,int applyTlsCfg (char**),config.c,"static int applyTlsCfg(const char **err) {
    UNUSED(err);

    /* If TLS is enabled, try to configure OpenSSL. */
    if ((server.tls_port || server.tls_replication || server.tls_cluster)
         && connTypeConfigure(connectionTypeTls(), &server.tls_ctx_config, 1) == C_ERR) {
        *err = ""Unable to update TLS configuration. Check server logs."";
        return 0;
    }
    return 1;
}",2652.0,2662.0,1.0,4.0,11.0,13,9,7,2,0,2,2,2,2,2,,0,2,2,1,1,int
2085,77118,applyTLSPort,1,applyTLSPort,int applyTLSPort (char**),config.c,"static int applyTLSPort(const char **err) {
    /* Configure TLS in case it wasn't enabled */
    if (connTypeConfigure(connectionTypeTls(), &server.tls_ctx_config, 0) == C_ERR) {
        *err = ""Unable to update TLS configuration. Check server logs."";
        return 0;
    }

    connListener *listener = listenerByType(CONN_TYPE_TLS);
    serverAssert(listener != NULL);
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.tls_port;
    listener->ct = connectionByType(CONN_TYPE_TLS);
    if (changeListener(listener) == C_ERR) {
        *err = ""Unable to listen on this port. Check server logs."";
        return 0;
    }

    return 1;
}",2664.0,2683.0,1.0,77.0,20.0,27,12,14,4,0,10,3,3,3,6,,0,9,2,1,1,int
2086,77255,getConfigDirOption,1,getConfigDirOption,sds getConfigDirOption (standardConfig*),config.c,"static sds getConfigDirOption(standardConfig *config) {
    UNUSED(config);
    char buf[1024];

    if (getcwd(buf,sizeof(buf)) == NULL)
        buf[0] = '\0';

    return sdsnew(buf);
}",2698.0,2706.0,1.0,4.0,9.0,5,5,7,3,0,1,2,2,0,1,,0,0,2,1,1,sds
2087,77283,setConfigSaveOption,1,setConfigSaveOption,"int setConfigSaveOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigSaveOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    int j;

    /* Special case: treat single arg """" as zero args indicating empty save configuration */
    if (argc == 1 && !strcasecmp(argv[0],"""")) {
        resetServerSaveParams();
        argc = 0;
    }

    /* Perform sanity check before setting the new config:
    * - Even number of args
    * - Seconds >= 1, changes >= 0 */
    if (argc & 1) {
        *err = ""Invalid save parameters"";
        return 0;
    }
    for (j = 0; j < argc; j++) {
        char *eptr;
        long val;

        val = strtoll(argv[j], &eptr, 10);
        if (eptr[0] != '\0' ||
            ((j & 1) == 0 && val < 1) ||
            ((j & 1) == 1 && val < 0)) {
            *err = ""Invalid save parameters"";
            return 0;
        }
    }
    /* Finally set the new config */
    if (!reading_config_file) {
        resetServerSaveParams();
    } else {
        /* We don't reset save p...",2708.0,2761.0,1.0,4.0,54.0,36,13,34,11,0,4,7,8,1,3,,0,1,8,4,4,int
2088,77436,getConfigSaveOption,1,getConfigSaveOption,sds getConfigSaveOption (standardConfig*),config.c,"static sds getConfigSaveOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;

    for (j = 0; j < server.saveparamslen; j++) {
        buf = sdscatprintf(buf,""%jd %d"",
                           (intmax_t)server.saveparams[j].seconds,
                           server.saveparams[j].changes);
        if (j != server.saveparamslen-1)
            buf = sdscatlen(buf,"" "",1);
    }

    return buf;
}",2763.0,2777.0,1.0,4.0,15.0,17,7,17,4,0,3,3,4,0,3,,0,3,2,1,1,sds
2089,77503,setConfigClientOutputBufferLimitOption,1,setConfigClientOutputBufferLimitOption,"int setConfigClientOutputBufferLimitOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigClientOutputBufferLimitOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    return updateClientOutputBufferLimit(argv, argc, err);
}",2779.0,2782.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2090,77522,getConfigClientOutputBufferLimitOption,1,getConfigClientOutputBufferLimitOption,sds getConfigClientOutputBufferLimitOption (standardConfig*),config.c,"static sds getConfigClientOutputBufferLimitOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;
    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
        buf = sdscatprintf(buf,""%s %llu %llu %ld"",
                           getClientTypeName(j),
                           server.client_obuf_limits[j].hard_limit_bytes,
                           server.client_obuf_limits[j].soft_limit_bytes,
                           (long) server.client_obuf_limits[j].soft_limit_seconds);
        if (j != CLIENT_TYPE_OBUF_COUNT-1)
            buf = sdscatlen(buf,"" "",1);
    }
    return buf;
}",2784.0,2798.0,1.0,4.0,15.0,18,7,18,4,0,4,3,4,0,4,,0,4,2,1,1,sds
2091,77598,setConfigOOMScoreAdjValuesOption,1,setConfigOOMScoreAdjValuesOption,"int setConfigOOMScoreAdjValuesOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigOOMScoreAdjValuesOption(standardConfig *config, sds *argv, int argc, const char **err) {
    int i;
    int values[CONFIG_OOM_COUNT];
    int change = 0;
    UNUSED(config);

    if (argc != CONFIG_OOM_COUNT) {
        *err = ""wrong number of arguments"";
        return 0;
    }

    for (i = 0; i < CONFIG_OOM_COUNT; i++) {
        char *eptr;
        long long val = strtoll(argv[i], &eptr, 10);

        if (*eptr != '\0' || val < -2000 || val > 2000) {
            if (err) *err = ""Invalid oom-score-adj-values, elements must be between -2000 and 2000."";
            return 0;
        }

        values[i] = val;
    }

    /* Verify that the values make sense. If they don't omit a warning but
     * keep the configuration, which may still be valid for privileged processes.
     */

    if (values[CONFIG_OOM_REPLICA] < values[CONFIG_OOM_MASTER] ||
        values[CONFIG_OOM_BGCHILD] < values[CONFIG_OOM_REPLICA])
    {
        serverLog(LL_WARNING,
                  ""T...",2803.0,2846.0,1.0,15.0,44.0,43,13,36,10,0,1,8,12,0,1,,0,0,8,4,4,int
2092,77768,getConfigOOMScoreAdjValuesOption,1,getConfigOOMScoreAdjValuesOption,sds getConfigOOMScoreAdjValuesOption (standardConfig*),config.c,"static sds getConfigOOMScoreAdjValuesOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;

    for (j = 0; j < CONFIG_OOM_COUNT; j++) {
        buf = sdscatprintf(buf,""%d"", server.oom_score_adj_values[j]);
        if (j != CONFIG_OOM_COUNT-1)
            buf = sdscatlen(buf,"" "",1);
    }

    return buf;
}",2848.0,2860.0,1.0,4.0,13.0,10,7,13,4,0,3,3,4,0,3,,0,3,2,1,1,sds
2093,77824,setConfigNotifyKeyspaceEventsOption,1,setConfigNotifyKeyspaceEventsOption,"int setConfigNotifyKeyspaceEventsOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigNotifyKeyspaceEventsOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    if (argc != 1) {
        *err = ""wrong number of arguments"";
        return 0;
    }
    int flags = keyspaceEventsStringToFlags(argv[0]);
    if (flags == -1) {
        *err = ""Invalid event class character. Use 'Ag$lshzxeKEtmdn'."";
        return 0;
    }
    server.notify_keyspace_events = flags;
    return 1;
}",2862.0,2875.0,1.0,4.0,14.0,12,8,10,6,0,1,3,3,0,1,,0,1,8,4,4,int
2094,77875,getConfigNotifyKeyspaceEventsOption,1,getConfigNotifyKeyspaceEventsOption,sds getConfigNotifyKeyspaceEventsOption (standardConfig*),config.c,"static sds getConfigNotifyKeyspaceEventsOption(standardConfig *config) {
    UNUSED(config);
    return keyspaceEventsFlagsToString(server.notify_keyspace_events);
}",2877.0,2880.0,1.0,4.0,4.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,sds
2095,77891,setConfigBindOption,1,setConfigBindOption,"int setConfigBindOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigBindOption(standardConfig *config, sds* argv, int argc, const char **err) {
    UNUSED(config);
    int j;

    if (argc > CONFIG_BINDADDR_MAX) {
        *err = ""Too many bind addresses specified."";
        return 0;
    }

    /* A single empty argument is treated as a zero bindaddr count */
    if (argc == 1 && sdslen(argv[0]) == 0) argc = 0;

    /* Free old bind addresses */
    for (j = 0; j < server.bindaddr_count; j++) {
        zfree(server.bindaddr[j]);
    }
    for (j = 0; j < argc; j++)
        server.bindaddr[j] = zstrdup(argv[j]);
    server.bindaddr_count = argc;

    return 1;
}",2882.0,2903.0,1.0,4.0,22.0,18,9,17,6,0,2,5,5,1,2,,0,1,8,4,4,int
2096,77980,setConfigReplicaOfOption,1,setConfigReplicaOfOption,"int setConfigReplicaOfOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigReplicaOfOption(standardConfig *config, sds* argv, int argc, const char **err) {
    UNUSED(config);

    if (argc != 2) {
        *err = ""wrong number of arguments"";
        return 0;
    }

    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (!strcasecmp(argv[0], ""no"") && !strcasecmp(argv[1], ""one"")) {
        return 1;
    }
    char *ptr;
    server.masterport = strtol(argv[1], &ptr, 10);
    if (server.masterport < 0 || server.masterport > 65535 || *ptr != '\0') {
        *err = ""Invalid master port"";
        return 0;
    }
    server.masterhost = sdsnew(argv[0]);
    server.repl_state = REPL_STATE_CONNECT;
    return 1;
}",2905.0,2927.0,1.0,4.0,23.0,31,12,20,8,0,2,4,4,0,2,,0,1,8,4,4,int
2097,78082,getConfigBindOption,1,getConfigBindOption,sds getConfigBindOption (standardConfig*),config.c,"static sds getConfigBindOption(standardConfig *config) {
    UNUSED(config);
    return sdsjoin(server.bindaddr,server.bindaddr_count,"" "");
}",2929.0,2932.0,1.0,4.0,4.0,3,2,4,2,0,1,1,1,0,1,,0,0,2,1,1,sds
2098,78102,getConfigReplicaOfOption,1,getConfigReplicaOfOption,sds getConfigReplicaOfOption (standardConfig*),config.c,"static sds getConfigReplicaOfOption(standardConfig *config) {
    UNUSED(config);
    char buf[256];
    if (server.masterhost)
        snprintf(buf,sizeof(buf),""%s %d"",
                 server.masterhost, server.masterport);
    else
        buf[0] = '\0';
    return sdsnew(buf);
}",2934.0,2943.0,1.0,4.0,10.0,5,3,8,3,0,1,2,2,0,1,,0,0,2,1,1,sds
2099,78140,allowProtectedAction,1,allowProtectedAction,"int allowProtectedAction (int,client*)",config.c,"int allowProtectedAction(int config, client *c) {
    return (config == PROTECTED_ACTION_ALLOWED_YES) ||
           (config == PROTECTED_ACTION_ALLOWED_LOCAL && (connIsLocal(c->conn) == 1));
}",2945.0,2948.0,1.0,22.0,4.0,6,4,3,2,3,2,1,1,0,1,,0,1,4,2,2,int
2100,78165,setConfigLatencyTrackingInfoPercentilesOutputOption,1,setConfigLatencyTrackingInfoPercentilesOutputOption,"int setConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    zfree(server.latency_tracking_info_percentiles);
    server.latency_tracking_info_percentiles = NULL;
    server.latency_tracking_info_percentiles_len = argc;

    /* Special case: treat single arg """" as zero args indicating empty percentile configuration */
    if (argc == 1 && sdslen(argv[0]) == 0)
        server.latency_tracking_info_percentiles_len = 0;
    else
        server.latency_tracking_info_percentiles = zmalloc(sizeof(double)*argc);

    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        double percentile;
        if (!string2d(argv[j], sdslen(argv[j]), &percentile)) {
            *err = ""Invalid latency-tracking-info-percentiles parameters"";
            goto configerr;
        }
        if (percentile > 100.0 || percentile < 0.0) {
            *err = ""latency-tracking-info-percentiles param...",2951.0,2982.0,1.0,4.0,32.0,34,12,29,8,0,5,7,7,3,5,,0,3,8,4,4,int
2101,78294,getConfigLatencyTrackingInfoPercentilesOutputOption,1,getConfigLatencyTrackingInfoPercentilesOutputOption,sds getConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*),config.c,"static sds getConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        char fbuf[128];
        size_t len = snprintf(fbuf, sizeof(fbuf), ""%f"", server.latency_tracking_info_percentiles[j]);
        len = trimDoubleString(fbuf, len);
        buf = sdscatlen(buf, fbuf, len);
        if (j != server.latency_tracking_info_percentiles_len-1)
            buf = sdscatlen(buf,"" "",1);
    }
    return buf;
}",2984.0,2996.0,1.0,4.0,13.0,15,8,23,6,0,4,3,4,0,4,,0,4,2,1,1,sds
2102,78365,rewriteConfigLatencyTrackingInfoPercentilesOutputOption,1,rewriteConfigLatencyTrackingInfoPercentilesOutputOption,"void rewriteConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    sds line = sdsnew(name);
    /* Rewrite latency-tracking-info-percentiles parameters,
     * or an empty 'latency-tracking-info-percentiles """"' line to avoid the
     * defaults from being used.
     */
    if (!server.latency_tracking_info_percentiles_len) {
        line = sdscat(line,"" \""\"""");
    } else {
        for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
            char fbuf[128];
            size_t len = snprintf(fbuf, sizeof(fbuf), "" %f"", server.latency_tracking_info_percentiles[j]);
            len = trimDoubleString(fbuf, len);
            line = sdscatlen(line, fbuf, len);
        }
    }
    rewriteConfigRewriteLine(state,name,line,1);
}",2999.0,3017.0,1.0,4.0,19.0,5,4,10,5,0,3,2,2,0,3,,0,2,6,3,3,void
2103,78440,applyClientMaxMemoryUsage,1,applyClientMaxMemoryUsage,int applyClientMaxMemoryUsage (char**),config.c,"static int applyClientMaxMemoryUsage(const char **err) {
    UNUSED(err);
    listIter li;
    listNode *ln;

    /* server.client_mem_usage_buckets is an indication that the previous config
     * was non-zero, in which case we can exit and no apply is needed. */
    if(server.maxmemory_clients !=0 && server.client_mem_usage_buckets)
        return 1;
    if (server.maxmemory_clients != 0)
        initServerClientMemUsageBuckets();

    /* When client eviction is enabled update memory buckets for all clients.
     * When disabled, clear that data structure. */
    listRewind(server.clients, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (server.maxmemory_clients == 0) {
            /* Remove client from memory usage bucket. */
            removeClientFromMemUsageBucket(c, 0);
        } else {
            /* Update each client(s) memory usage and add to appropriate bucket. */
            updateClientMemUsageAndBucket(c);
        }
...",3019.0,3048.0,1.0,4.0,30.0,18,8,16,6,0,6,6,7,1,5,,0,2,2,1,1,int
2104,96540,registerConfigValue,1,registerConfigValue,"int registerConfigValue (char*,standardConfig*,int)",config.c,"int registerConfigValue(const char *name, const standardConfig *config, int alias) {
    standardConfig *new = zmalloc(sizeof(standardConfig));
    memcpy(new, config, sizeof(standardConfig));
    if (alias) {
        new->flags |= ALIAS_CONFIG;
        new->name = config->alias;
        new->alias = config->name;
    }

    return dictAdd(configs, sdsnew(name), new) == DICT_OK;
}",3271.0,3281.0,1.0,22.0,11.0,12,5,14,6,6,9,2,2,0,3,,0,8,6,3,3,int
2105,96594,initConfigValues,1,initConfigValues,void initConfigValues (void),config.c,"void initConfigValues(void) {
    configs = dictCreate(&sdsHashDictType);
    dictExpand(configs, sizeof(static_configs) / sizeof(standardConfig));
    for (standardConfig *config = static_configs; config->name != NULL; config++) {
        if (config->interface.init) config->interface.init(config);
        /* Add the primary config to the dictionary. */
        int ret = registerConfigValue(config->name, config, 0);
        serverAssert(ret);

        /* Aliases are the same as their primary counter parts, but they
         * also have a flag indicating they are the alias. */
        if (config->alias) {
            int ret = registerConfigValue(config->alias, config, ALIAS_CONFIG);
            serverAssert(ret);
        }
    }
}",3285.0,3301.0,1.0,8.0,17.0,26,12,23,7,1,11,4,6,0,7,,0,7,2,1,1,void
2106,96696,removeConfig,1,removeConfig,void removeConfig (sds),config.c,"void removeConfig(sds name) {
    standardConfig *config = lookupConfig(name);
    if (!config) return;
    if (config->flags & MODULE_CONFIG) {
        sdsfree((sds) config->name);
        if (config->type == ENUM_CONFIG) {
            configEnum *enumNode = config->data.enumd.enum_value;
            while(enumNode->name != NULL) {
                zfree(enumNode->name);
                enumNode++;
            }
            zfree(config->data.enumd.enum_value);
        } else if (config->type == SDS_CONFIG) {
            if (config->data.sds.default_value) sdsfree((sds)config->data.sds.default_value);
        }
    }
    dictDelete(configs, name);
}",3304.0,3321.0,1.0,24.0,18.0,20,10,16,6,1,13,5,8,3,5,,0,9,2,1,1,void
2107,96797,addModuleBoolConfig,1,addModuleBoolConfig,"void addModuleBoolConfig (char*,char*,int,void*,int)",config.c,"void addModuleBoolConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    int config_dummy_address;
    standardConfig module_config = createBoolConfig(config_name, NULL, flags | MODULE_CONFIG, config_dummy_address, default_val, NULL, NULL);
    module_config.data.yesno.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3328.0,3335.0,1.0,35.0,8.0,35,6,39,11,1,5,1,1,0,3,,0,4,10,5,5,void
2108,96915,addModuleStringConfig,1,addModuleStringConfig,"void addModuleStringConfig (char*,char*,int,void*,sds)",config.c,"void addModuleStringConfig(const char *module_name, const char *name, int flags, void *privdata, sds default_val) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    sds config_dummy_address;
    standardConfig module_config = createSDSConfig(config_name, NULL, flags | MODULE_CONFIG, 0, config_dummy_address, default_val, NULL, NULL);
    module_config.data.sds.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3337.0,3344.0,1.0,35.0,8.0,37,6,41,11,1,5,1,1,0,3,,0,4,10,5,5,void
2109,97041,addModuleEnumConfig,1,addModuleEnumConfig,"void addModuleEnumConfig (char*,char*,int,void*,int,configEnum*)",config.c,"void addModuleEnumConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val, configEnum *enum_vals) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    int config_dummy_address;
    standardConfig module_config = createEnumConfig(config_name, NULL, flags | MODULE_CONFIG, enum_vals, config_dummy_address, default_val, NULL, NULL);
    module_config.data.enumd.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3346.0,3353.0,1.0,35.0,8.0,37,6,43,12,1,5,1,1,0,3,,0,4,12,6,6,void
2110,97168,addModuleNumericConfig,1,addModuleNumericConfig,"void addModuleNumericConfig (char*,char*,int,void*,long long,int,long long,long long)",config.c,"void addModuleNumericConfig(const char *module_name, const char *name, int flags, void *privdata, long long default_val, int conf_flags, long long lower, long long upper) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    long long config_dummy_address;
    standardConfig module_config = createLongLongConfig(config_name, NULL, flags | MODULE_CONFIG, lower, upper, config_dummy_address, default_val, conf_flags, NULL, NULL);
    module_config.data.numeric.config.ll = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3355.0,3362.0,1.0,35.0,8.0,48,6,59,15,1,5,1,1,0,3,,0,4,16,8,8,void
2111,97331,configHelpCommand,1,configHelpCommand,void configHelpCommand (client*),config.c,"void configHelpCommand(client *c) {
    const char *help[] = {
""GET <pattern>"",
""    Return parameters matching the glob-like <pattern> and their values."",
""SET <directive> <value>"",
""    Set the configuration <directive> to <value>."",
""RESETSTAT"",
""    Reset statistics reported by the INFO command."",
""REWRITE"",
""    Rewrite the configuration file."",
NULL
    };

    addReplyHelp(c, help);
}",3368.0,3382.0,1.0,1.0,15.0,2,2,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
2112,97352,configResetStatCommand,1,configResetStatCommand,void configResetStatCommand (client*),config.c,"void configResetStatCommand(client *c) {
    resetServerStats();
    resetCommandTableStats(server.commands);
    resetErrorTableStats();
    addReply(c,shared.ok);
}",3388.0,3393.0,1.0,1.0,6.0,2,1,3,3,0,4,1,1,0,4,,0,0,2,1,1,void
2113,97368,configRewriteCommand,1,configRewriteCommand,void configRewriteCommand (client*),config.c,"void configRewriteCommand(client *c) {
    if (server.configfile == NULL) {
        addReplyError(c,""The server is running without a config file"");
        return;
    }
    if (rewriteConfig(server.configfile, 0) == -1) {
        /* save errno in case of being tainted. */
        int err = errno;
        serverLog(LL_WARNING,""CONFIG REWRITE failed: %s"", strerror(err));
        addReplyErrorFormat(c,""Rewriting config file: %s"", strerror(err));
    } else {
        serverLog(LL_NOTICE,""CONFIG REWRITE executed with success."");
        addReply(c,shared.ok);
    }
}",3399.0,3413.0,1.0,8.0,15.0,9,6,10,5,0,4,3,3,1,4,,0,1,2,1,1,void
2114,97491,connTypeRegister,1,connTypeRegister,int connTypeRegister (ConnectionType*),connection.c,"int connTypeRegister(ConnectionType *ct) {
    const char *typename = ct->get_type(NULL);
    ConnectionType *tmpct;
    int type;

    /* find an empty slot to store the new connection type */
    for (type = 0; type < CONN_TYPE_MAX; type++) {
        tmpct = connTypes[type];
        if (!tmpct)
            break;

        /* ignore case, we really don't care ""tls""/""TLS"" */
        if (!strcasecmp(typename, tmpct->get_type(NULL))) {
            serverLog(LL_WARNING, ""Connection types %s already registered"", typename);
            return C_ERR;
        }
    }

    serverLog(LL_VERBOSE, ""Connection type %s registered"", typename);
    connTypes[type] = ct;

    if (ct->init) {
        ct->init();
    }

    return C_OK;
}",32.0,58.0,1.0,26.0,27.0,20,8,21,7,0,7,6,7,1,5,,0,4,2,1,1,int
2115,97600,connTypeInitialize,1,connTypeInitialize,int connTypeInitialize (void),connection.c,"int connTypeInitialize(void) {
    /* currently socket connection type is necessary  */
    serverAssert(RedisRegisterConnectionTypeSocket() == C_OK);

    /* currently unix socket connection type is necessary  */
    serverAssert(RedisRegisterConnectionTypeUnix() == C_OK);

    /* may fail if without BUILD_TLS=yes */
    RedisRegisterConnectionTypeTLS();

    return C_OK;
}",60.0,71.0,1.0,4.0,12.0,10,5,0,0,0,5,1,1,0,5,,0,0,2,1,1,int
2116,97642,connectionByType,1,connectionByType,ConnectionType connectionByType (char*),connection.c,"ConnectionType *connectionByType(const char *typename) {
    ConnectionType *ct;

    for (int type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (!strcasecmp(typename, ct->get_type(NULL)))
            return ct;
    }

    serverLog(LL_WARNING, ""Missing implement of connection type %s"", typename);

    return NULL;
}",73.0,88.0,1.0,30.0,16.0,10,7,13,6,10,3,5,6,1,2,,0,2,2,1,1,ConnectionType
2117,97705,connectionTypeTcp,1,connectionTypeTcp,ConnectionType connectionTypeTcp (void),connection.c,"ConnectionType *connectionTypeTcp(void) {
    static ConnectionType *ct_tcp = NULL;

    if (ct_tcp != NULL)
        return ct_tcp;

    ct_tcp = connectionByType(CONN_TYPE_SOCKET);
    serverAssert(ct_tcp != NULL);

    return ct_tcp;
}",91.0,101.0,1.0,30.0,11.0,8,6,9,2,12,2,2,2,0,2,,0,1,2,1,1,ConnectionType
2118,97745,connectionTypeTls,1,connectionTypeTls,ConnectionType connectionTypeTls (void),connection.c,"ConnectionType *connectionTypeTls(void) {
    static ConnectionType *ct_tls = NULL;
    static int cached = 0;

    /* Unlike the TCP and Unix connections, the TLS one can be missing
     * So we need the cached pointer to handle NULL correctly too. */
    if (!cached) {
        cached = 1;
        ct_tls = connectionByType(CONN_TYPE_TLS);
    }

    return ct_tls;
}",104.0,116.0,1.0,34.0,13.0,5,2,7,3,7,1,2,2,0,1,,0,1,2,1,1,ConnectionType
2119,97773,connectionTypeUnix,1,connectionTypeUnix,ConnectionType connectionTypeUnix (void),connection.c,"ConnectionType *connectionTypeUnix(void) {
    static ConnectionType *ct_unix = NULL;

    if (ct_unix != NULL)
        return ct_unix;

    ct_unix = connectionByType(CONN_TYPE_UNIX);
    return ct_unix;
}",119.0,127.0,1.0,31.0,9.0,3,2,7,2,0,1,2,2,0,1,,0,1,2,1,1,ConnectionType
2120,97797,connectionIndexByType,1,connectionIndexByType,int connectionIndexByType (char*),connection.c,"int connectionIndexByType(const char *typename) {
    ConnectionType *ct;

    for (int type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (!strcasecmp(typename, ct->get_type(NULL)))
            return type;
    }

    return -1;
}",129.0,142.0,1.0,30.0,14.0,8,6,10,5,5,2,5,6,1,1,,0,2,2,1,1,int
2121,97842,connTypeCleanupAll,1,connTypeCleanupAll,void connTypeCleanupAll (void),connection.c,"void connTypeCleanupAll(void) {
    ConnectionType *ct;
    int type;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (ct->cleanup)
            ct->cleanup();
    }
}",144.0,156.0,1.0,26.0,13.0,7,5,8,3,0,2,5,6,0,1,,0,1,2,1,1,void
2122,97881,connTypeHasPendingData,1,connTypeHasPendingData,int connTypeHasPendingData (void),connection.c,"int connTypeHasPendingData(void) {
    ConnectionType *ct;
    int type;
    int ret = 0;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (ct && ct->has_pending_data && (ret = ct->has_pending_data())) {
            return ret;
        }
    }

    return ret;
}",159.0,172.0,1.0,26.0,14.0,10,5,12,4,1,2,3,4,1,1,,0,2,2,1,1,int
2123,97928,connTypeProcessPendingData,1,connTypeProcessPendingData,int connTypeProcessPendingData (void),connection.c,"int connTypeProcessPendingData(void) {
    ConnectionType *ct;
    int type;
    int ret = 0;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (ct && ct->process_pending_data) {
            ret += ct->process_pending_data();
        }
    }

    return ret;
}",175.0,188.0,1.0,26.0,14.0,9,6,11,4,2,2,3,4,0,1,,0,1,2,1,1,int
2124,97972,getListensInfoString,1,getListensInfoString,sds getListensInfoString (sds),connection.c,"sds getListensInfoString(sds info) {
    for (int j = 0; j < CONN_TYPE_MAX; j++) {
        connListener *listener = &server.listeners[j];
        if (listener->ct == NULL)
            continue;

        info = sdscatfmt(info, ""listener%i:name=%s"", j, listener->ct->get_type(NULL));
        for (int i = 0; i < listener->count; i++) {
            info = sdscatfmt(info, "",bind=%s"", listener->bindaddr[i]);
        }

        if (listener->port)
            info = sdscatfmt(info, "",port=%i"", listener->port);

        info = sdscatfmt(info, ""\r\n"");
    }

    return info;
}",190.0,208.0,1.0,24.0,19.0,21,7,26,6,1,11,6,8,3,5,,0,11,2,1,1,sds
2125,98106,get_type,1,ConnectionType.get_type,char* ConnectionType.get_type (connection*),connection.h,const char *(*get_type)(struct connection *conn);,70.0,70.0,16.0,52.0,1.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,char*
2126,98111,init,1,ConnectionType.init,void ConnectionType.init (void),connection.h,void (*init)(void);,73.0,73.0,10.0,22.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2127,98116,cleanup,1,ConnectionType.cleanup,void ConnectionType.cleanup (void),connection.h,void (*cleanup)(void);,74.0,74.0,10.0,25.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2128,98121,configure,1,ConnectionType.configure,"int ConnectionType.configure (void*,int)",connection.h,"int (*configure)(void *priv, int reconfigure);",75.0,75.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2129,98127,ae_handler,1,ConnectionType.ae_handler,"void ConnectionType.ae_handler (aeEventLoop*,int,void*,int)",connection.h,"void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);",78.0,78.0,10.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
2130,98136,addr,1,ConnectionType.addr,"int ConnectionType.addr (connection*,char*,size_t,int*,int)",connection.h,"int (*addr)(connection *conn, char *ip, size_t ip_len, int *port, int remote);",80.0,80.0,9.0,81.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,int
2131,98145,is_local,1,ConnectionType.is_local,int ConnectionType.is_local (connection*),connection.h,int (*is_local)(connection *conn);,81.0,81.0,9.0,37.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2132,98150,listen,1,ConnectionType.listen,int ConnectionType.listen (connListener*),connection.h,int (*listen)(connListener *listener);,82.0,82.0,9.0,41.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2133,98155,conn_create,1,ConnectionType.conn_create,connection* ConnectionType.conn_create (void),connection.h,connection* (*conn_create)(void);,85.0,85.0,15.0,36.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,connection*
2134,98160,conn_create_accepted,1,ConnectionType.conn_create_accepted,"connection* ConnectionType.conn_create_accepted (int,void*)",connection.h,"connection* (*conn_create_accepted)(int fd, void *priv);",86.0,86.0,15.0,59.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,connection*
2135,98166,shutdown,1,ConnectionType.shutdown,void ConnectionType.shutdown (connection*),connection.h,void (*shutdown)(struct connection *conn);,87.0,87.0,10.0,45.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
2136,98171,close,1,ConnectionType.close,void ConnectionType.close (connection*),connection.h,void (*close)(struct connection *conn);,88.0,88.0,10.0,42.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
2137,98176,connect,1,ConnectionType.connect,"int ConnectionType.connect (connection*,char*,int,char*,ConnectionCallbackFunc)",connection.h,"int (*connect)(struct connection *conn, const char *addr, int port, const char *source_addr, ConnectionCallbackFunc connect_handler);",91.0,91.0,9.0,136.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
2138,98185,blocking_connect,1,ConnectionType.blocking_connect,"int ConnectionType.blocking_connect (connection*,char*,int,long long)",connection.h,"int (*blocking_connect)(struct connection *conn, const char *addr, int port, long long timeout);",92.0,92.0,9.0,99.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
2139,98193,accept,1,ConnectionType.accept,"int ConnectionType.accept (connection*,ConnectionCallbackFunc)",connection.h,"int (*accept)(struct connection *conn, ConnectionCallbackFunc accept_handler);",93.0,93.0,9.0,81.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
2140,98199,write,1,ConnectionType.write,"int ConnectionType.write (connection*,void*,size_t)",connection.h,"int (*write)(struct connection *conn, const void *data, size_t data_len);",96.0,96.0,9.0,76.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
2141,98206,writev,1,ConnectionType.writev,"int ConnectionType.writev (connection*,iovec*,int)",connection.h,"int (*writev)(struct connection *conn, const struct iovec *iov, int iovcnt);",97.0,97.0,9.0,79.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
2142,98213,read,1,ConnectionType.read,"int ConnectionType.read (connection*,void*,size_t)",connection.h,"int (*read)(struct connection *conn, void *buf, size_t buf_len);",98.0,98.0,9.0,67.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
2143,98220,set_write_handler,1,ConnectionType.set_write_handler,"int ConnectionType.set_write_handler (connection*,ConnectionCallbackFunc,int)",connection.h,"int (*set_write_handler)(struct connection *conn, ConnectionCallbackFunc handler, int barrier);",99.0,99.0,9.0,98.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,int
2144,98227,set_read_handler,1,ConnectionType.set_read_handler,"int ConnectionType.set_read_handler (connection*,ConnectionCallbackFunc)",connection.h,"int (*set_read_handler)(struct connection *conn, ConnectionCallbackFunc handler);",100.0,100.0,9.0,84.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
2145,98233,get_last_error,1,ConnectionType.get_last_error,char* ConnectionType.get_last_error (connection*),connection.h,const char *(*get_last_error)(struct connection *conn);,101.0,101.0,16.0,58.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
2146,98238,sync_write,1,ConnectionType.sync_write,"ssize_t ConnectionType.sync_write (connection*,char*,ssize_t,long long)",connection.h,"ssize_t (*sync_write)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",102.0,102.0,13.0,94.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ssize_t
2147,98246,sync_read,1,ConnectionType.sync_read,"ssize_t ConnectionType.sync_read (connection*,char*,ssize_t,long long)",connection.h,"ssize_t (*sync_read)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",103.0,103.0,13.0,93.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ssize_t
2148,98254,sync_readline,1,ConnectionType.sync_readline,"ssize_t ConnectionType.sync_readline (connection*,char*,ssize_t,long long)",connection.h,"ssize_t (*sync_readline)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",104.0,104.0,13.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ssize_t
2149,98262,has_pending_data,1,ConnectionType.has_pending_data,int ConnectionType.has_pending_data (void),connection.h,int (*has_pending_data)(void);,107.0,107.0,9.0,33.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2150,98267,process_pending_data,1,ConnectionType.process_pending_data,int ConnectionType.process_pending_data (void),connection.h,int (*process_pending_data)(void);,108.0,108.0,9.0,37.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2151,98272,get_peer_cert,1,ConnectionType.get_peer_cert,sds ConnectionType.get_peer_cert (connection*),connection.h,sds (*get_peer_cert)(struct connection *conn);,111.0,111.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sds
2152,98306,connAccept,1,connAccept,"int connAccept (connection*,ConnectionCallbackFunc)",connection.h,"static inline int connAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    return conn->type->accept(conn, accept_handler);
}",159.0,161.0,1.0,1.0,3.0,2,1,3,2,1,2,1,1,0,1,,0,1,4,2,2,int
2153,98321,connConnect,1,connConnect,"int connConnect (connection*,char*,int,char*,ConnectionCallbackFunc)",connection.h,"static inline int connConnect(connection *conn, const char *addr, int port, const char *src_addr,
        ConnectionCallbackFunc connect_handler) {
    return conn->type->connect(conn, addr, port, src_addr, connect_handler);
}",172.0,175.0,1.0,1.0,4.0,2,1,6,5,2,2,1,1,0,1,,0,1,10,5,5,int
2154,98342,connBlockingConnect,1,connBlockingConnect,"int connBlockingConnect (connection*,char*,int,long long)",connection.h,"static inline int connBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {
    return conn->type->blocking_connect(conn, addr, port, timeout);
}",183.0,185.0,1.0,1.0,3.0,2,1,5,4,1,2,1,1,0,1,,0,1,8,4,4,int
2155,98361,connWrite,1,connWrite,"int connWrite (connection*,void*,size_t)",connection.h,"static inline int connWrite(connection *conn, const void *data, size_t data_len) {
    return conn->type->write(conn, data, data_len);
}",194.0,196.0,1.0,1.0,3.0,2,1,4,3,13,2,1,1,0,1,,0,1,6,3,3,int
2156,98378,connWritev,1,connWritev,"int connWritev (connection*,iovec*,int)",connection.h,"static inline int connWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    return conn->type->writev(conn, iov, iovcnt);
}",206.0,208.0,1.0,1.0,3.0,2,1,4,3,1,2,1,1,0,1,,0,1,6,3,3,int
2157,98395,connRead,1,connRead,"int connRead (connection*,void*,size_t)",connection.h,"static inline int connRead(connection *conn, void *buf, size_t buf_len) {
    int ret = conn->type->read(conn, buf, buf_len);
    return ret;
}",218.0,221.0,1.0,1.0,4.0,3,2,6,4,4,2,1,1,0,1,,0,2,6,3,3,int
2158,98416,connSetWriteHandler,1,connSetWriteHandler,"int connSetWriteHandler (connection*,ConnectionCallbackFunc)",connection.h,"static inline int connSetWriteHandler(connection *conn, ConnectionCallbackFunc func) {
    return conn->type->set_write_handler(conn, func, 0);
}",226.0,228.0,1.0,1.0,3.0,2,1,3,2,7,2,1,1,0,1,,0,1,4,2,2,int
2159,98432,connSetReadHandler,1,connSetReadHandler,"int connSetReadHandler (connection*,ConnectionCallbackFunc)",connection.h,"static inline int connSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    return conn->type->set_read_handler(conn, func);
}",233.0,235.0,1.0,1.0,3.0,2,1,3,2,12,2,1,1,0,1,,0,1,4,2,2,int
2160,98447,connSetWriteHandlerWithBarrier,1,connSetWriteHandlerWithBarrier,"int connSetWriteHandlerWithBarrier (connection*,ConnectionCallbackFunc,int)",connection.h,"static inline int connSetWriteHandlerWithBarrier(connection *conn, ConnectionCallbackFunc func, int barrier) {
    return conn->type->set_write_handler(conn, func, barrier);
}",242.0,244.0,1.0,1.0,3.0,2,1,4,3,2,2,1,1,0,1,,0,1,6,3,3,int
2161,98464,connShutdown,1,connShutdown,void connShutdown (connection*),connection.h,"static inline void connShutdown(connection *conn) {
    conn->type->shutdown(conn);
}",246.0,248.0,1.0,1.0,3.0,2,1,2,1,1,2,1,1,0,1,,0,1,2,1,1,void
2162,98476,connClose,1,connClose,void connClose (connection*),connection.h,"static inline void connClose(connection *conn) {
    conn->type->close(conn);
}",250.0,252.0,1.0,1.0,3.0,2,1,2,1,15,2,1,1,0,1,,0,1,2,1,1,void
2163,98488,connGetLastError,1,connGetLastError,const char* connGetLastError (connection*),connection.h,"static inline const char *connGetLastError(connection *conn) {
    return conn->type->get_last_error(conn);
}",257.0,259.0,1.0,1.0,3.0,2,1,2,1,19,2,1,1,0,1,,0,1,2,1,1,const char*
2164,98501,connSyncWrite,1,connSyncWrite,"ssize_t connSyncWrite (connection*,char*,ssize_t,long long)",connection.h,"static inline ssize_t connSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_write(conn, ptr, size, timeout);
}",261.0,263.0,1.0,1.0,3.0,2,1,5,4,3,2,1,1,0,1,,0,1,8,4,4,ssize_t
2165,98520,connSyncRead,1,connSyncRead,"ssize_t connSyncRead (connection*,char*,ssize_t,long long)",connection.h,"static inline ssize_t connSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_read(conn, ptr, size, timeout);
}",265.0,267.0,1.0,1.0,3.0,2,1,5,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
2166,98539,connSyncReadLine,1,connSyncReadLine,"ssize_t connSyncReadLine (connection*,char*,ssize_t,long long)",connection.h,"static inline ssize_t connSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_readline(conn, ptr, size, timeout);
}",269.0,271.0,1.0,1.0,3.0,2,1,5,4,5,2,1,1,0,1,,0,1,8,4,4,ssize_t
2167,98558,connGetType,1,connGetType,const char* connGetType (connection*),connection.h,"static inline const char *connGetType(connection *conn) {
    return conn->type->get_type(conn);
}",274.0,276.0,1.0,1.0,3.0,2,1,2,1,0,2,1,1,0,1,,0,1,2,1,1,const char*
2168,98571,connLastErrorRetryable,1,connLastErrorRetryable,int connLastErrorRetryable (connection*),connection.h,"static inline int connLastErrorRetryable(connection *conn) {
    return conn->last_errno == EINTR;
}",278.0,280.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,int
2169,98582,connAddr,1,connAddr,"int connAddr (connection*,char*,size_t,int*,int)",connection.h,"static inline int connAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    if (conn && conn->type->addr) {
        return conn->type->addr(conn, ip, ip_len, port, remote);
    }

    return -1;
}",284.0,290.0,1.0,1.0,7.0,6,3,8,5,3,3,2,2,1,1,,0,2,10,5,5,int
2170,98615,formatAddr,1,formatAddr,"int formatAddr (char*,size_t,char*,int)",connection.h,"static inline int formatAddr(char *buf, size_t buf_len, char *ip, int port) {
    return snprintf(buf, buf_len, strchr(ip,':') ?
           ""[%s]:%d"" : ""%s:%d"", ip, port);
}",295.0,298.0,1.0,1.0,4.0,1,1,5,4,2,0,1,1,0,0,,0,0,8,4,4,int
2171,98635,connFormatAddr,1,connFormatAddr,"int connFormatAddr (connection*,char*,size_t,int)",connection.h,"static inline int connFormatAddr(connection *conn, char *buf, size_t buf_len, int remote)
{
    char ip[CONN_ADDR_STR_LEN];
    int port;

    if (connAddr(conn, ip, sizeof(ip), &port, remote) < 0) {
        return -1;
    }

    return formatAddr(buf, buf_len, ip, port);
}",300.0,310.0,1.0,12.0,11.0,4,4,9,6,4,2,2,2,1,2,,0,1,8,4,4,int
2172,98666,connAddrPeerName,1,connAddrPeerName,"int connAddrPeerName (connection*,char*,size_t,int*)",connection.h,"static inline int connAddrPeerName(connection *conn, char *ip, size_t ip_len, int *port) {
    return connAddr(conn, ip, ip_len, port, 1);
}",312.0,314.0,1.0,1.0,3.0,0,0,4,4,6,1,1,1,0,1,,0,0,8,4,4,int
2173,98681,connAddrSockName,1,connAddrSockName,"int connAddrSockName (connection*,char*,size_t,int*)",connection.h,"static inline int connAddrSockName(connection *conn, char *ip, size_t ip_len, int *port) {
    return connAddr(conn, ip, ip_len, port, 0);
}",316.0,318.0,1.0,1.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
2174,98696,connIsLocal,1,connIsLocal,int connIsLocal (connection*),connection.h,"static inline int connIsLocal(connection *conn) {
    if (conn && conn->type->is_local) {
        return conn->type->is_local(conn);
    }

    return -1;
}",322.0,328.0,1.0,1.0,7.0,6,3,4,1,2,3,2,2,1,1,,0,2,2,1,1,int
2175,98721,connGetState,1,connGetState,int connGetState (connection*),connection.h,"static inline int connGetState(connection *conn) {
    return conn->state;
}",330.0,332.0,1.0,1.0,3.0,1,1,1,1,12,1,1,1,0,0,,0,1,2,1,1,int
2176,98730,connHasWriteHandler,1,connHasWriteHandler,int connHasWriteHandler (connection*),connection.h,"static inline int connHasWriteHandler(connection *conn) {
    return conn->write_handler != NULL;
}",335.0,337.0,1.0,1.0,3.0,2,2,2,2,4,1,1,1,0,0,,0,1,2,1,1,int
2177,98741,connHasReadHandler,1,connHasReadHandler,int connHasReadHandler (connection*),connection.h,"static inline int connHasReadHandler(connection *conn) {
    return conn->read_handler != NULL;
}",340.0,342.0,1.0,1.0,3.0,2,2,2,2,2,1,1,1,0,0,,0,1,2,1,1,int
2178,98752,connSetPrivateData,1,connSetPrivateData,"void connSetPrivateData (connection*,void*)",connection.h,"static inline void connSetPrivateData(connection *conn, void *data) {
    conn->private_data = data;
}",345.0,347.0,1.0,1.0,3.0,2,2,2,2,3,1,1,1,0,0,,0,1,4,2,2,void
2179,98763,connGetPrivateData,1,connGetPrivateData,void* connGetPrivateData (connection*),connection.h,"static inline void *connGetPrivateData(connection *conn) {
    return conn->private_data;
}",350.0,352.0,1.0,1.0,3.0,1,1,1,1,11,1,1,1,0,0,,0,1,2,1,1,void*
2180,98772,connGetInfo,1,connGetInfo,"const char* connGetInfo (connection*,char*,size_t)",connection.h,"static inline const char *connGetInfo(connection *conn, char *buf, size_t buf_len) {
    snprintf(buf, buf_len-1, ""fd=%i"", conn == NULL ? -1 : conn->fd);
    return buf;
}",359.0,362.0,1.0,1.0,4.0,5,5,6,4,3,1,1,1,0,0,,0,1,6,3,3,const char*
2181,98796,connBlock,1,connBlock,int connBlock (connection*),socket.c,"int connBlock(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetBlock(NULL, conn->fd);
}",435.0,438.0,1.0,31.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
2182,98801,connNonBlock,1,connNonBlock,int connNonBlock (connection*),socket.c,"int connNonBlock(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetNonBlock(NULL, conn->fd);
}",440.0,443.0,1.0,31.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
2183,98806,connEnableTcpNoDelay,1,connEnableTcpNoDelay,int connEnableTcpNoDelay (connection*),socket.c,"int connEnableTcpNoDelay(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetEnableTcpNoDelay(NULL, conn->fd);
}",445.0,448.0,1.0,31.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
2184,98811,connDisableTcpNoDelay,1,connDisableTcpNoDelay,int connDisableTcpNoDelay (connection*),socket.c,"int connDisableTcpNoDelay(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetDisableTcpNoDelay(NULL, conn->fd);
}",450.0,453.0,1.0,31.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2185,98816,connKeepAlive,1,connKeepAlive,"int connKeepAlive (connection*,int)",socket.c,"int connKeepAlive(connection *conn, int interval) {
    if (conn->fd == -1) return C_ERR;
    return anetKeepAlive(NULL, conn->fd, interval);
}",455.0,458.0,1.0,31.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2186,98822,connSendTimeout,1,connSendTimeout,"int connSendTimeout (connection*,long long)",socket.c,"int connSendTimeout(connection *conn, long long ms) {
    return anetSendTimeout(NULL, conn->fd, ms);
}",460.0,462.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
2187,98828,connRecvTimeout,1,connRecvTimeout,"int connRecvTimeout (connection*,long long)",socket.c,"int connRecvTimeout(connection *conn, long long ms) {
    return anetRecvTimeout(NULL, conn->fd, ms);
}",464.0,466.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
2188,98834,connGetPeerCert,1,connGetPeerCert,sds connGetPeerCert (connection*),connection.h,"static inline sds connGetPeerCert(connection *conn) {
    if (conn->type->get_peer_cert) {
        return conn->type->get_peer_cert(conn);
    }

    return NULL;
}",374.0,380.0,1.0,1.0,7.0,4,1,4,2,1,3,2,2,1,1,,0,2,2,1,1,sds
2189,98891,connCreate,1,connCreate,connection connCreate (ConnectionType*),connection.h,"static inline connection *connCreate(ConnectionType *ct) {
    return ct->conn_create();
}",404.0,406.0,1.0,1.0,3.0,1,1,1,1,3,1,1,1,0,1,,0,0,2,1,1,connection
2190,98901,connCreateAccepted,1,connCreateAccepted,"connection connCreateAccepted (ConnectionType*,int,void*)",connection.h,"static inline connection *connCreateAccepted(ConnectionType *ct, int fd, void *priv) {
    return ct->conn_create_accepted(fd, priv);
}",410.0,412.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,6,3,3,connection
2191,98915,connTypeConfigure,1,connTypeConfigure,"int connTypeConfigure (ConnectionType*,void*,int)",connection.h,"static inline int connTypeConfigure(ConnectionType *ct, void *priv, int reconfigure) {
    return ct->configure(priv, reconfigure);
}",417.0,419.0,1.0,1.0,3.0,1,1,3,3,3,1,1,1,0,1,,0,0,6,3,3,int
2192,98944,connListen,1,connListen,int connListen (connListener*),connection.h,"static inline int connListen(connListener *listener) {
    return listener->ct->listen(listener);
}",431.0,433.0,1.0,1.0,3.0,2,1,2,1,3,2,1,1,0,1,,0,1,2,1,1,int
2193,98957,connAcceptHandler,1,connAcceptHandler,aeFileProc connAcceptHandler (ConnectionType*),connection.h,"static inline aeFileProc *connAcceptHandler(ConnectionType *ct) {
    if (ct)
        return ct->accept_handler;
    return NULL;
}",436.0,440.0,1.0,1.0,5.0,1,1,3,2,1,1,2,2,0,0,,0,1,2,1,1,aeFileProc
2194,98976,RedisRegisterConnectionTypeSocket,1,RedisRegisterConnectionTypeSocket,int RedisRegisterConnectionTypeSocket (void),socket.c,"int RedisRegisterConnectionTypeSocket(void)
{
    return connTypeRegister(&CT_Socket);
}",468.0,471.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2195,98981,RedisRegisterConnectionTypeUnix,1,RedisRegisterConnectionTypeUnix,int RedisRegisterConnectionTypeUnix (void),unix.c,"int RedisRegisterConnectionTypeUnix(void)
{
    return connTypeRegister(&CT_Unix);
}",204.0,207.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2196,98986,RedisRegisterConnectionTypeTLS,1,RedisRegisterConnectionTypeTLS,int RedisRegisterConnectionTypeTLS (void),tls.c,"int RedisRegisterConnectionTypeTLS(void) {
    serverLog(LL_VERBOSE, ""Connection type %s not builtin"", CONN_TYPE_TLS);
    return C_ERR;
}",1161.0,1164.0,1.0,4.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2197,98991,connIsTLS,1,connIsTLS,int connIsTLS (connection*),connection.h,"static inline int connIsTLS(connection *conn) {
    return conn && conn->type == connectionTypeTls();
}",450.0,452.0,1.0,1.0,3.0,3,3,2,1,1,2,1,1,0,1,,0,1,2,1,1,int
2198,99011,connIncrRefs,1,connIncrRefs,void connIncrRefs (connection*),connhelpers.h,"static inline void connIncrRefs(connection *conn) {
    conn->refs++;
}",52.0,54.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
2199,99020,connDecrRefs,1,connDecrRefs,void connDecrRefs (connection*),connhelpers.h,"static inline void connDecrRefs(connection *conn) {
    conn->refs--;
}",64.0,66.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
2200,99029,connHasRefs,1,connHasRefs,int connHasRefs (connection*),connhelpers.h,"static inline int connHasRefs(connection *conn) {
    return conn->refs;
}",68.0,70.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,int
2201,99038,callHandler,1,callHandler,"int callHandler (connection*,ConnectionCallbackFunc)",connhelpers.h,"static inline int callHandler(connection *conn, ConnectionCallbackFunc handler) {
    connIncrRefs(conn);
    if (handler) handler(conn);
    connDecrRefs(conn);
    if (conn->flags & CONN_FLAG_CLOSE_SCHEDULED) {
        if (!connHasRefs(conn)) connClose(conn);
        return 0;
    }
    return 1;
}",77.0,86.0,1.0,22.0,10.0,4,4,7,2,5,5,4,5,2,4,,0,2,4,2,2,int
2202,99342,crc16,1,crc16,"uint16_t crc16 (char*,int)",crc16.c,"uint16_t crc16(const char *buf, int len) {
    int counter;
    uint16_t crc = 0;
    for (counter = 0; counter < len; counter++)
            crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];
    return crc;
}",82.0,88.0,1.0,1.0,7.0,3,2,5,3,6,0,2,2,0,0,,0,0,4,2,2,uint16_t
2203,100409,crc_reflect,1,crc_reflect,"uint_fast64_t crc_reflect (uint_fast64_t,size_t)",crc64.c,"static inline uint_fast64_t crc_reflect(uint_fast64_t data, size_t data_len) {
    uint_fast64_t ret = data & 0x01;

    for (size_t i = 1; i < data_len; i++) {
        data >>= 1;
        ret = (ret << 1) | (data & 0x01);
    }

    return ret;
}",69.0,78.0,1.0,1.0,10.0,8,5,10,4,1,0,2,2,0,0,,0,0,4,2,2,uint_fast64_t
2204,100447,_crc64,1,_crc64,"uint64_t _crc64 (uint_fast64_t,void*,uint64_t)",crc64.c,"uint64_t _crc64(uint_fast64_t crc, const void *in_data, const uint64_t len) {
    const uint8_t *data = in_data;
    unsigned long long bit;

    for (uint64_t offset = 0; offset < len; offset++) {
        uint8_t c = data[offset];
        for (uint_fast8_t i = 0x01; i & 0xff; i <<= 1) {
            bit = crc & 0x8000000000000000;
            if (c & i) {
                bit = !bit;
            }

            crc <<= 1;
            if (bit) {
                crc ^= POLY;
            }
        }

        crc &= 0xffffffffffffffff;
    }

    crc = crc & 0xffffffffffffffff;
    return crc_reflect(crc, 64) ^ 0x0000000000000000;
}",88.0,111.0,1.0,23.0,24.0,15,6,23,8,0,1,5,10,0,1,,0,0,6,3,3,uint64_t
2205,100530,crc64_init,1,crc64_init,void crc64_init (void),crc64.c,"void crc64_init(void) {
    crcspeed64native_init(_crc64, crc64_table);
}",116.0,118.0,1.0,1.0,3.0,0,0,1,1,0,2,1,1,0,1,,0,1,2,1,1,void
2206,100538,crc64,1,crc64,"uint64_t crc64 (uint64_t,unsigned char*,uint64_t)",crc64.c,"uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {
    return crcspeed64native(crc64_table, crc, (void *) s, l);
}",121.0,123.0,1.0,1.0,3.0,1,1,4,4,5,2,1,1,0,1,,0,1,6,3,3,uint64_t
2207,100579,crcspeed64little_init,1,crcspeed64little_init,"void crcspeed64little_init (crcfn64,uint64_t[8][256])",crcspeed.c,"void crcspeed64little_init(crcfn64 crcfn, uint64_t table[8][256]) {
    uint64_t crc;

    /* generate CRCs for all single byte sequences */
    for (int n = 0; n < 256; n++) {
        unsigned char v = n;
        table[0][n] = crcfn(0, &v, 1);
    }

    /* generate nested CRC table for future slice-by-8 lookup */
    for (int n = 0; n < 256; n++) {
        crc = table[0][n];
        for (int k = 1; k < 8; k++) {
            crc = table[0][crc & 0xff] ^ (crc >> 8);
            table[k][n] = crc;
        }
    }
}",33.0,50.0,1.0,1.0,18.0,23,7,22,5,2,0,4,5,0,0,,0,0,4,2,2,void
2208,100664,crcspeed16little_init,1,crcspeed16little_init,"void crcspeed16little_init (crcfn16,uint16_t[8][256])",crcspeed.c,"void crcspeed16little_init(crcfn16 crcfn, uint16_t table[8][256]) {
    uint16_t crc;

    /* generate CRCs for all single byte sequences */
    for (int n = 0; n < 256; n++) {
        table[0][n] = crcfn(0, &n, 1);
    }

    /* generate nested CRC table for future slice-by-8 lookup */
    for (int n = 0; n < 256; n++) {
        crc = table[0][n];
        for (int k = 1; k < 8; k++) {
            crc = table[0][(crc >> 8) & 0xff] ^ (crc << 8);
            table[k][n] = crc;
        }
    }
}",52.0,68.0,1.0,1.0,17.0,23,8,20,4,2,0,4,5,0,0,,0,0,4,2,2,void
2209,100747,rev8,1,rev8,uint64_t rev8 (uint64_t),crcspeed.c,"static inline uint64_t rev8(uint64_t a) {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap64(a);
#else
    uint64_t m;

    m = UINT64_C(0xff00ff00ff00ff);
    a = ((a >> 8) & m) | (a & m) << 8;
    m = UINT64_C(0xffff0000ffff);
    a = ((a >> 16) & m) | (a & m) << 16;
    return a >> 32 | a << 32;
#endif
}",71.0,83.0,1.0,1.0,13.0,17,5,14,2,6,0,1,1,0,0,,0,0,2,1,1,uint64_t
2210,100795,crcspeed64big_init,1,crcspeed64big_init,"void crcspeed64big_init (crcfn64,uint64_t[8][256])",crcspeed.c,"void crcspeed64big_init(crcfn64 fn, uint64_t big_table[8][256]) {
    /* Create the little endian table then reverse all the entries. */
    crcspeed64little_init(fn, big_table);
    for (int k = 0; k < 8; k++) {
        for (int n = 0; n < 256; n++) {
            big_table[k][n] = rev8(big_table[k][n]);
        }
    }
}",87.0,95.0,1.0,1.0,9.0,9,3,12,4,1,2,3,4,0,2,,0,1,4,2,2,void
2211,100840,crcspeed16big_init,1,crcspeed16big_init,"void crcspeed16big_init (crcfn16,uint16_t[8][256])",crcspeed.c,"void crcspeed16big_init(crcfn16 fn, uint16_t big_table[8][256]) {
    /* Create the little endian table then reverse all the entries. */
    crcspeed16little_init(fn, big_table);
    for (int k = 0; k < 8; k++) {
        for (int n = 0; n < 256; n++) {
            big_table[k][n] = rev8(big_table[k][n]);
        }
    }
}",97.0,105.0,1.0,1.0,9.0,9,3,12,4,1,2,3,4,0,2,,0,1,4,2,2,void
2212,100885,crcspeed64little,1,crcspeed64little,"uint64_t crcspeed64little (uint64_t[8][256],uint64_t,void*,size_t)",crcspeed.c,"uint64_t crcspeed64little(uint64_t little_table[8][256], uint64_t crc,
                          void *buf, size_t len) {
    unsigned char *next = buf;

    /* process individual bytes until we reach an 8-byte aligned pointer */
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = little_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    /* fast middle processing, 8 bytes (aligned!) per loop */
    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = little_table[7][crc & 0xff] ^
              little_table[6][(crc >> 8) & 0xff] ^
              little_table[5][(crc >> 16) & 0xff] ^
              little_table[4][(crc >> 24) & 0xff] ^
              little_table[3][(crc >> 32) & 0xff] ^
              little_table[2][(crc >> 40) & 0xff] ^
              little_table[1][(crc >> 48) & 0xff] ^
              little_table[0][crc >> 56];
        next += 8;
        len -= 8;
    }

    /* process remaining bytes (can't be larger than 8) */
    while ...",112.0,144.0,1.0,1.0,33.0,68,14,40,5,1,0,4,4,0,0,,0,0,8,4,4,uint64_t
2213,101045,crcspeed16little,1,crcspeed16little,"uint16_t crcspeed16little (uint16_t[8][256],uint16_t,void*,size_t)",crcspeed.c,"uint16_t crcspeed16little(uint16_t little_table[8][256], uint16_t crc,
                          void *buf, size_t len) {
    unsigned char *next = buf;

    /* process individual bytes until we reach an 8-byte aligned pointer */
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = little_table[0][((crc >> 8) ^ *next++) & 0xff] ^ (crc << 8);
        len--;
    }

    /* fast middle processing, 8 bytes (aligned!) per loop */
    while (len >= 8) {
        uint64_t n = *(uint64_t *)next;
        crc = little_table[7][(n & 0xff) ^ ((crc >> 8) & 0xff)] ^
              little_table[6][((n >> 8) & 0xff) ^ (crc & 0xff)] ^
              little_table[5][(n >> 16) & 0xff] ^
              little_table[4][(n >> 24) & 0xff] ^
              little_table[3][(n >> 32) & 0xff] ^
              little_table[2][(n >> 40) & 0xff] ^
              little_table[1][(n >> 48) & 0xff] ^
              little_table[0][n >> 56];
        next += 8;
        len -= 8;
    }

    /* process remaining bytes ...",146.0,178.0,1.0,1.0,33.0,76,15,42,6,1,0,4,4,0,0,,0,0,8,4,4,uint16_t
2214,101220,crcspeed64big,1,crcspeed64big,"uint64_t crcspeed64big (uint64_t[8][256],uint64_t,void*,size_t)",crcspeed.c,"uint64_t crcspeed64big(uint64_t big_table[8][256], uint64_t crc, void *buf,
                       size_t len) {
    unsigned char *next = buf;

    crc = rev8(crc);
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = big_table[0][(crc >> 56) ^ *next++] ^ (crc << 8);
        len--;
    }

    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = big_table[0][crc & 0xff] ^
              big_table[1][(crc >> 8) & 0xff] ^
              big_table[2][(crc >> 16) & 0xff] ^
              big_table[3][(crc >> 24) & 0xff] ^
              big_table[4][(crc >> 32) & 0xff] ^
              big_table[5][(crc >> 40) & 0xff] ^
              big_table[6][(crc >> 48) & 0xff] ^
              big_table[7][crc >> 56];
        next += 8;
        len -= 8;
    }

    while (len) {
        crc = big_table[0][(crc >> 56) ^ *next++] ^ (crc << 8);
        len--;
    }

    return rev8(crc);
}",183.0,213.0,1.0,1.0,31.0,69,15,42,5,1,2,4,4,0,2,,0,1,8,4,4,uint64_t
2215,101385,crcspeed16big,1,crcspeed16big,"uint16_t crcspeed16big (uint16_t[8][256],uint16_t,void*,size_t)",crcspeed.c,"uint16_t crcspeed16big(uint16_t big_table[8][256], uint16_t crc_in, void *buf,
                       size_t len) {
    unsigned char *next = buf;
    uint64_t crc = crc_in;

    crc = rev8(crc);
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = big_table[0][((crc >> (56 - 8)) ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    while (len >= 8) {
        uint64_t n = *(uint64_t *)next;
        crc = big_table[0][(n & 0xff) ^ ((crc >> (56 - 8)) & 0xff)] ^
              big_table[1][((n >> 8) & 0xff) ^ (crc & 0xff)] ^
              big_table[2][(n >> 16) & 0xff] ^
              big_table[3][(n >> 24) & 0xff] ^
              big_table[4][(n >> 32) & 0xff] ^
              big_table[5][(n >> 40) & 0xff] ^
              big_table[6][(n >> 48) & 0xff] ^
              big_table[7][n >> 56];
        next += 8;
        len -= 8;
    }

    while (len) {
        crc = big_table[0][((crc >> (56 - 8)) ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    return rev8(crc);
}",216.0,247.0,1.0,1.0,32.0,81,15,46,7,1,2,4,4,0,2,,0,1,8,4,4,uint16_t
2216,101575,crcspeed64native,1,crcspeed64native,"uint64_t crcspeed64native (uint64_t[8][256],uint64_t,void*,size_t)",crcspeed.c,"uint64_t crcspeed64native(uint64_t table[8][256], uint64_t crc, void *buf,
                          size_t len) {
    uint64_t n = 1;

    return *(char *)&n ? crcspeed64little(table, crc, buf, len)
                       : crcspeed64big(table, crc, buf, len);
}",253.0,259.0,1.0,1.0,7.0,5,5,10,5,1,2,1,1,0,2,,0,0,8,4,4,uint64_t
2217,101604,crcspeed16native,1,crcspeed16native,"uint16_t crcspeed16native (uint16_t[8][256],uint16_t,void*,size_t)",crcspeed.c,"uint16_t crcspeed16native(uint16_t table[8][256], uint16_t crc, void *buf,
                          size_t len) {
    uint64_t n = 1;

    return *(char *)&n ? crcspeed16little(table, crc, buf, len)
                       : crcspeed16big(table, crc, buf, len);
}",261.0,267.0,1.0,1.0,7.0,5,5,10,5,0,2,1,1,0,2,,0,0,8,4,4,uint16_t
2218,101633,crcspeed64native_init,1,crcspeed64native_init,"void crcspeed64native_init (crcfn64,uint64_t[8][256])",crcspeed.c,"void crcspeed64native_init(crcfn64 fn, uint64_t table[8][256]) {
    uint64_t n = 1;

    *(char *)&n ? crcspeed64little_init(fn, table)
                : crcspeed64big_init(fn, table);
}",270.0,275.0,1.0,1.0,6.0,5,5,6,3,1,2,1,1,0,2,,0,0,4,2,2,void
2219,101655,crcspeed16native_init,1,crcspeed16native_init,"void crcspeed16native_init (crcfn16,uint16_t[8][256])",crcspeed.c,"void crcspeed16native_init(crcfn16 fn, uint16_t table[8][256]) {
    uint64_t n = 1;

    *(char *)&n ? crcspeed16little_init(fn, table)
                : crcspeed16big_init(fn, table);
}",277.0,282.0,1.0,1.0,6.0,5,5,6,3,0,2,1,1,0,2,,0,0,4,2,2,void
2220,101805,expireIfNeeded,1,expireIfNeeded,"int expireIfNeeded (redisDb*,robj*,int)",db.c,"int expireIfNeeded(redisDb *db, robj *key, int flags) {
    if (server.lazy_expire_disabled) return 0;
    if (!keyIsExpired(db,key)) return 0;

    /* If we are running in the context of a replica, instead of
     * evicting the expired key from the database, we return ASAP:
     * the replica key expiration is controlled by the master that will
     * send us synthesized DEL operations for expired keys. The
     * exception is when write operations are performed on writable
     * replicas.
     *
     * Still we try to return the right information to the caller,
     * that is, 0 if we think the key should be still valid, 1 if
     * we think the key is expired at this time.
     *
     * When replicating commands from the master, keys are never considered
     * expired. */
    if (server.masterhost != NULL) {
        if (server.current_client && (server.current_client->flags & CLIENT_MASTER)) return 0;
        if (!(flags & EXPIRE_FORCE_DELETE_EXPIRED)) return 1;
    }

    /* ...",1775.0,1818.0,1.0,69.0,44.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,int
2221,101812,keyIsExpired,1,keyIsExpired,"int keyIsExpired (redisDb*,robj*)",db.c,"int keyIsExpired(redisDb *db, robj *key) {
    /* Don't expire anything while loading. It will be done later. */
    if (server.loading) return 0;

    mstime_t when = getExpire(db,key);
    mstime_t now;

    if (when < 0) return 0; /* No expire for this key */

    now = commandTimeSnapshot();

    /* The key expired if the current (virtual or real) time is greater
     * than the expire time of the key. */
    return now > when;
}",1730.0,1744.0,1.0,1.0,15.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,int
2222,101818,dbSetValue,1,dbSetValue,"void dbSetValue (redisDb*,robj*,robj*,int,dictEntry*)",db.c,"static void dbSetValue(redisDb *db, robj *key, robj *val, int overwrite, dictEntry *de) {
    if (!de) de = dictFind(db->dict,key->ptr);
    serverAssertWithInfo(NULL,key,de != NULL);
    robj *old = dictGetVal(de);

    val->lru = old->lru;

    if (overwrite) {
        /* RM_StringDMA may call dbUnshareStringValue which may free val, so we
         * need to incr to retain old */
        incrRefCount(old);
        /* Although the key is not really deleted from the database, we regard
         * overwrite as two steps of unlink+add, so we still need to call the unlink
         * callback of the module. */
        moduleNotifyKeyUnlink(key,old,db->id,DB_FLAG_KEY_OVERWRITE);
        /* We want to try to unblock any module clients or clients using a blocking XREADGROUP */
        signalDeletedKeyAsReady(db,key,old->type);
        decrRefCount(old);
        /* Because of RM_StringDMA, old may be changed, so we need get old again */
        old = dictGetVal(de);
    }
    dictSetVal(db-...",245.0,274.0,1.0,4.0,30.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
2223,101827,updateLFU,1,updateLFU,void updateLFU (robj*),db.c,"void updateLFU(robj *val) {
    unsigned long counter = LFUDecrAndReturn(val);
    counter = LFULogIncr(counter);
    val->lru = (LFUGetTimeInMinutes()<<8) | counter;
}",55.0,59.0,1.0,1.0,5.0,6,4,6,2,1,3,1,1,0,3,,0,3,2,1,1,void
2224,101850,lookupKey,1,lookupKey,"robj lookupKey (redisDb*,robj*,int)",db.c,"robj *lookupKey(redisDb *db, robj *key, int flags) {
    dictEntry *de = dictFind(db->dict,key->ptr);
    robj *val = NULL;
    if (de) {
        val = dictGetVal(de);
        /* Forcing deletion of expired keys on a replica makes the replica
         * inconsistent with the master. We forbid it on readonly replicas, but
         * we have to allow it on writable replicas to make write commands
         * behave consistently.
         *
         * It's possible that the WRITE flag is set even during a readonly
         * command, since the command may trigger events that cause modules to
         * perform additional writes. */
        int is_ro_replica = server.masterhost && server.repl_slave_ro;
        int expire_flags = 0;
        if (flags & LOOKUP_WRITE && !is_ro_replica)
            expire_flags |= EXPIRE_FORCE_DELETE_EXPIRED;
        if (flags & LOOKUP_NOEXPIRE)
            expire_flags |= EXPIRE_AVOID_DELETE_EXPIRED;
        if (expireIfNeeded(db, key, expire_flags)) {
    ...",88.0,140.0,1.0,20.0,53.0,44,10,34,10,2,6,10,18,2,5,,0,5,6,3,3,robj
2225,102073,lookupKeyReadWithFlags,1,lookupKeyReadWithFlags,"robj lookupKeyReadWithFlags (redisDb*,robj*,int)",db.c,"robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
    serverAssert(!(flags & LOOKUP_WRITE));
    return lookupKey(db, key, flags);
}",151.0,154.0,1.0,4.0,4.0,7,7,4,3,8,2,1,1,0,2,,0,0,6,3,3,robj
2226,102104,lookupKeyRead,1,lookupKeyRead,"robj lookupKeyRead (redisDb*,robj*)",db.c,"robj *lookupKeyRead(redisDb *db, robj *key) {
    return lookupKeyReadWithFlags(db,key,LOOKUP_NONE);
}",158.0,160.0,1.0,41.0,3.0,0,0,2,2,17,1,1,1,0,1,,0,0,4,2,2,robj
2227,102117,lookupKeyWriteWithFlags,1,lookupKeyWriteWithFlags,"robj lookupKeyWriteWithFlags (redisDb*,robj*,int)",db.c,"robj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags) {
    return lookupKey(db, key, flags | LOOKUP_WRITE);
}",168.0,170.0,1.0,38.0,3.0,2,2,3,3,2,1,1,1,0,1,,0,0,6,3,3,robj
2228,102135,lookupKeyWrite,1,lookupKeyWrite,"robj lookupKeyWrite (redisDb*,robj*)",db.c,"robj *lookupKeyWrite(redisDb *db, robj *key) {
    return lookupKeyWriteWithFlags(db, key, LOOKUP_NONE);
}",172.0,174.0,1.0,44.0,3.0,0,0,2,2,22,1,1,1,0,1,,0,0,4,2,2,robj
2229,102148,lookupKeyReadOrReply,1,lookupKeyReadOrReply,"robj lookupKeyReadOrReply (client*,robj*,robj*)",db.c,"robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {
    robj *o = lookupKeyRead(c->db, key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",176.0,180.0,1.0,1.0,5.0,3,3,7,4,9,3,2,2,0,2,,0,2,6,3,3,robj
2230,102172,lookupKeyWriteOrReply,1,lookupKeyWriteOrReply,"robj lookupKeyWriteOrReply (client*,robj*,robj*)",db.c,"robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
    robj *o = lookupKeyWrite(c->db, key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",182.0,186.0,1.0,1.0,5.0,3,3,7,4,4,3,2,2,0,2,,0,2,6,3,3,robj
2231,102196,dbAddInternal,1,dbAddInternal,"void dbAddInternal (redisDb*,robj*,robj*,int)",db.c,"static void dbAddInternal(redisDb *db, robj *key, robj *val, int update_if_existing) {
    dictEntry *existing;
    dictEntry *de = dictAddRaw(db->dict, key->ptr, &existing);
    if (update_if_existing && existing) {
        dbSetValue(db, key, val, 1, existing);
        return;
    }
    serverAssertWithInfo(NULL, key, de != NULL);
    dictSetKey(db->dict, de, sdsdup(key->ptr));
    initObjectLRUOrLFU(val);
    dictSetVal(db->dict, de, val);
    signalKeyAsReady(db, key, val->type);
    if (server.cluster_enabled) slotToKeyAddEntry(de, db);
    notifyKeyspaceEvent(NOTIFY_NEW,""new"",key,db->id);
}",193.0,207.0,1.0,4.0,15.0,17,11,31,8,1,14,3,3,0,10,,0,6,8,4,4,void
2232,102291,dbAdd,1,dbAdd,"void dbAdd (redisDb*,robj*,robj*)",db.c,"void dbAdd(redisDb *db, robj *key, robj *val) {
    dbAddInternal(db, key, val, 0);
}",209.0,211.0,1.0,1.0,3.0,0,0,3,3,13,1,1,1,0,1,,0,0,6,3,3,void
2233,102303,dbAddRDBLoad,1,dbAddRDBLoad,"int dbAddRDBLoad (redisDb*,sds,robj*)",db.c,"int dbAddRDBLoad(redisDb *db, sds key, robj *val) {
    dictEntry *de = dictAddRaw(db->dict, key, NULL);
    if (de == NULL) return 0;
    initObjectLRUOrLFU(val);
    dictSetVal(db->dict, de, val);
    if (server.cluster_enabled) slotToKeyAddEntry(de, db);
    return 1;
}",224.0,231.0,1.0,1.0,8.0,5,4,13,6,0,6,3,3,0,4,,0,3,6,3,3,int
2234,102457,dbReplaceValue,1,dbReplaceValue,"void dbReplaceValue (redisDb*,robj*,robj*)",db.c,"void dbReplaceValue(redisDb *db, robj *key, robj *val) {
    dbSetValue(db, key, val, 0, NULL);
}",278.0,280.0,1.0,1.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
2235,102470,setKey,1,setKey,"void setKey (client*,redisDb*,robj*,robj*,int)",db.c,"void setKey(client *c, redisDb *db, robj *key, robj *val, int flags) {
    int keyfound = 0;

    if (flags & SETKEY_ALREADY_EXIST)
        keyfound = 1;
    else if (flags & SETKEY_ADD_OR_UPDATE)
        keyfound = -1;
    else if (!(flags & SETKEY_DOESNT_EXIST))
        keyfound = (lookupKeyWrite(db,key) != NULL);

    if (!keyfound) {
        dbAdd(db,key,val);
    } else if (keyfound<0) {
        dbAddInternal(db,key,val,1);
    } else {
        dbSetValue(db,key,val,1,NULL);
    }
    incrRefCount(val);
    if (!(flags & SETKEY_KEEPTTL)) removeExpire(db,key);
    if (!(flags & SETKEY_NO_SIGNAL)) signalModifiedKey(c,db,key);
}",295.0,315.0,1.0,16.0,21.0,8,3,15,6,8,4,5,5,0,4,,0,0,10,5,5,void
2236,102576,dbRandomKey,1,dbRandomKey,robj dbRandomKey (redisDb*),db.c,"robj *dbRandomKey(redisDb *db) {
    dictEntry *de;
    int maxtries = 100;
    int allvolatile = dictSize(db->dict) == dictSize(db->expires);

    while(1) {
        sds key;
        robj *keyobj;

        de = dictGetFairRandomKey(db->dict);
        if (de == NULL) return NULL;

        key = dictGetKey(de);
        keyobj = createStringObject(key,sdslen(key));
        if (dictFind(db->expires,key)) {
            if (allvolatile && server.masterhost && --maxtries == 0) {
                /* If the DB is composed only of keys with an expire set,
                 * it could happen that all the keys are already logically
                 * expired in the slave, so the function cannot stop because
                 * expireIfNeeded() is false, nor it can stop because
                 * dictGetFairRandomKey() returns NULL (there are keys to return).
                 * To prevent the infinite loop we do some tries, but if there
                 * are the conditions for an infinite loop, e...",321.0,354.0,1.0,22.0,34.0,30,8,28,8,2,15,7,12,3,7,,0,14,2,1,1,robj
2237,102690,dbGenericDelete,1,dbGenericDelete,"int dbGenericDelete (redisDb*,robj*,int,int)",db.c,"int dbGenericDelete(redisDb *db, robj *key, int async, int flags) {
    dictEntry **plink;
    int table;
    dictEntry *de = dictTwoPhaseUnlinkFind(db->dict,key->ptr,&plink,&table);
    if (de) {
        robj *val = dictGetVal(de);
        /* RM_StringDMA may call dbUnshareStringValue which may free val, so we
         * need to incr to retain val */
        incrRefCount(val);
        /* Tells the module that the key has been unlinked from the database. */
        moduleNotifyKeyUnlink(key,val,db->id,flags);
        /* We want to try to unblock any module clients or clients using a blocking XREADGROUP */
        signalDeletedKeyAsReady(db,key,val->type);
        /* We should call decr before freeObjAsync. If not, the refcount may be
         * greater than 1, so freeObjAsync doesn't work */
        decrRefCount(val);
        if (async) {
            /* Because of dbUnshareStringValue, the val in de may change. */
            freeObjAsync(key, dictGetVal(de), db->id);
            di...",357.0,388.0,1.0,12.0,32.0,23,7,36,10,6,21,5,8,3,12,,0,12,8,4,4,int
2238,102807,dbSyncDelete,1,dbSyncDelete,"int dbSyncDelete (redisDb*,robj*)",db.c,"int dbSyncDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, 0, DB_FLAG_KEY_DELETED);
}",391.0,393.0,1.0,39.0,3.0,1,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
2239,102823,dbAsyncDelete,1,dbAsyncDelete,"int dbAsyncDelete (redisDb*,robj*)",db.c,"int dbAsyncDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, 1, DB_FLAG_KEY_DELETED);
}",397.0,399.0,1.0,39.0,3.0,1,1,2,2,2,1,1,1,0,1,,0,0,4,2,2,int
2240,102839,dbDelete,1,dbDelete,"int dbDelete (redisDb*,robj*)",db.c,"int dbDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, server.lazyfree_lazy_server_del, DB_FLAG_KEY_DELETED);
}",403.0,405.0,1.0,69.0,3.0,2,2,3,3,11,1,1,1,0,1,,0,0,4,2,2,int
2241,102857,dbUnshareStringValue,1,dbUnshareStringValue,"robj dbUnshareStringValue (redisDb*,robj*,robj*)",db.c,"robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
    serverAssert(o->type == OBJ_STRING);
    if (o->refcount != 1 || o->encoding != OBJ_ENCODING_RAW) {
        robj *decoded = getDecodedObject(o);
        o = createRawStringObject(decoded->ptr, sdslen(decoded->ptr));
        decrRefCount(decoded);
        dbReplaceValue(db,key,o);
    }
    return o;
}",434.0,443.0,1.0,4.0,10.0,15,9,13,4,2,6,2,2,0,6,,0,3,6,3,3,robj
2242,102920,emptyDbStructure,1,emptyDbStructure,"long long emptyDbStructure (redisDb*,int,int,void)",db.c,"long long emptyDbStructure(redisDb *dbarray, int dbnum, int async,
                           void(callback)(dict*))
{
    long long removed = 0;
    int startdb, enddb;

    if (dbnum == -1) {
        startdb = 0;
        enddb = server.dbnum-1;
    } else {
        startdb = enddb = dbnum;
    }

    for (int j = startdb; j <= enddb; j++) {
        removed += dictSize(dbarray[j].dict);
        if (async) {
            emptyDbAsync(&dbarray[j]);
        } else {
            dictEmpty(dbarray[j].dict,callback);
            dictEmpty(dbarray[j].expires,callback);
        }
        /* Because all keys of database are removed, reset average ttl. */
        dbarray[j].avg_ttl = 0;
        dbarray[j].expires_cursor = 0;
    }

    return removed;
}",451.0,478.0,1.0,19.0,28.0,29,11,24,8,2,1,4,5,0,1,,0,0,8,4,4,long long
2243,103037,emptyData,1,emptyData,"long long emptyData (int,int,void)",db.c,"long long emptyData(int dbnum, int flags, void(callback)(dict*)) {
    int async = (flags & EMPTYDB_ASYNC);
    int with_functions = !(flags & EMPTYDB_NOFUNCTIONS);
    RedisModuleFlushInfoV1 fi = {REDISMODULE_FLUSHINFO_VERSION,!async,dbnum};
    long long removed = 0;

    if (dbnum < -1 || dbnum >= server.dbnum) {
        errno = EINVAL;
        return -1;
    }

    /* Fire the flushdb modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_FLUSHDB,
                          REDISMODULE_SUBEVENT_FLUSHDB_START,
                          &fi);

    /* Make sure the WATCHed keys are affected by the FLUSH* commands.
     * Note that we need to call the function while the keys are still
     * there. */
    signalFlushedDb(dbnum, async);

    /* Empty redis database structure. */
    removed = emptyDbStructure(server.db, dbnum, async, callback);

    /* Flush slots to keys map if enable cluster, we can flush entire
     * slots to keys map whatever dbnum because only support one...",495.0,538.0,1.0,25.0,44.0,32,16,29,10,4,8,5,5,0,8,,0,1,6,3,3,long long
2244,103167,initTempDb,1,initTempDb,redisDb initTempDb (void),db.c,"redisDb *initTempDb(void) {
    redisDb *tempDb = zcalloc(sizeof(redisDb)*server.dbnum);
    for (int i=0; i<server.dbnum; i++) {
        tempDb[i].dict = dictCreate(&dbDictType);
        tempDb[i].expires = dictCreate(&dbExpiresDictType);
        tempDb[i].slots_to_keys = NULL;
    }

    if (server.cluster_enabled) {
        /* Prepare temp slot to key map to be written during async diskless replication. */
        slotToKeyInit(tempDb);
    }

    return tempDb;
}",541.0,555.0,1.0,1.0,15.0,19,7,18,7,1,4,3,3,0,4,,0,3,2,1,1,redisDb
2245,103230,discardTempDb,1,discardTempDb,"void discardTempDb (redisDb*,void)",db.c,"void discardTempDb(redisDb *tempDb, void(callback)(dict*)) {
    int async = 1;

    /* Release temp DBs. */
    emptyDbStructure(tempDb, -1, async, callback);
    for (int i=0; i<server.dbnum; i++) {
        dictRelease(tempDb[i].dict);
        dictRelease(tempDb[i].expires);
    }

    if (server.cluster_enabled) {
        /* Release temp slot to key map. */
        slotToKeyDestroy(tempDb);
    }

    zfree(tempDb);
}",558.0,574.0,1.0,1.0,17.0,10,5,14,5,1,5,3,3,0,5,,0,0,4,2,2,void
2246,103281,selectDb,1,selectDb,"int selectDb (client*,int)",db.c,"int selectDb(client *c, int id) {
    if (id < 0 || id >= server.dbnum)
        return C_ERR;
    c->db = &server.db[id];
    return C_OK;
}",576.0,581.0,1.0,15.0,6.0,10,9,6,3,13,1,2,2,0,0,,0,1,4,2,2,int
2247,103317,dbTotalServerKeyCount,1,dbTotalServerKeyCount,long long dbTotalServerKeyCount (void),db.c,"long long dbTotalServerKeyCount(void) {
    long long total = 0;
    int j;
    for (j = 0; j < server.dbnum; j++) {
        total += dictSize(server.db[j].dict);
    }
    return total;
}",583.0,590.0,1.0,17.0,8.0,19,7,12,3,1,0,2,2,0,0,,0,0,2,1,1,long long
2248,103376,signalModifiedKey,1,signalModifiedKey,"void signalModifiedKey (client*,redisDb*,robj*)",db.c,"void signalModifiedKey(client *c, redisDb *db, robj *key) {
    touchWatchedKey(db,key);
    trackingInvalidateKey(c,key,1);
}",603.0,606.0,1.0,1.0,4.0,0,0,4,3,28,2,1,1,0,2,,0,0,6,3,3,void
2249,103390,signalFlushedDb,1,signalFlushedDb,"void signalFlushedDb (int,int)",db.c,"void signalFlushedDb(int dbid, int async) {
    int startdb, enddb;
    if (dbid == -1) {
        startdb = 0;
        enddb = server.dbnum-1;
    } else {
        startdb = enddb = dbid;
    }

    for (int j = startdb; j <= enddb; j++) {
        scanDatabaseForDeletedKeys(&server.db[j], NULL);
        touchAllWatchedKeysInDb(&server.db[j], NULL);
    }

    trackingInvalidateKeysOnFlush(async);

    /* Changes in this method may take place in swapMainDbWithTempDb as well,
     * where we execute similar calls, but with subtle differences as it's
     * not simply flushing db. */
}",608.0,627.0,1.0,1.0,20.0,14,8,15,7,1,3,3,3,0,3,,0,0,4,2,2,void
2250,103451,getFlushCommandFlags,1,getFlushCommandFlags,"int getFlushCommandFlags (client*,int*)",db.c,"int getFlushCommandFlags(client *c, int *flags) {
    /* Parse the optional ASYNC option. */
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""sync"")) {
        *flags = EMPTYDB_NO_FLAGS;
    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""async"")) {
        *flags = EMPTYDB_ASYNC;
    } else if (c->argc == 1) {
        *flags = server.lazyfree_lazy_user_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return C_ERR;
    }
    return C_OK;
}",642.0,655.0,1.0,17.0,14.0,9,7,3,2,2,2,2,2,2,0,,0,2,4,2,2,int
2251,103549,flushAllDataAndResetRDB,1,flushAllDataAndResetRDB,void flushAllDataAndResetRDB (int),db.c,"void flushAllDataAndResetRDB(int flags) {
    server.dirty += emptyData(-1,flags,NULL);
    if (server.child_type == CHILD_TYPE_RDB) killRDBChild();
    if (server.saveparamslen > 0) {
        rdbSaveInfo rsi, *rsiptr;
        rsiptr = rdbPopulateSaveInfo(&rsi);
        rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr,RDBFLAGS_NONE);
    }

#if defined(USE_JEMALLOC)
    /* jemalloc 5 doesn't release pages back to the OS when there's no traffic.
     * for large databases, flushdb blocks for long anyway, so a bit more won't
     * harm and this way the flush and purge will be synchronous. */
    if (!(flags & EMPTYDB_ASYNC))
        jemalloc_purge();
#endif
}",658.0,674.0,1.0,29.0,17.0,10,7,9,5,2,4,3,3,0,4,,0,1,2,1,1,void
2252,103598,flushdbCommand,1,flushdbCommand,void flushdbCommand (client*),db.c,"void flushdbCommand(client *c) {
    int flags;

    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
    /* flushdb should not flush the functions */
    server.dirty += emptyData(c->db->id,flags | EMPTYDB_NOFUNCTIONS,NULL);

    /* Without the forceCommandPropagation, when DB was already empty,
     * FLUSHDB will not be replicated nor put into the AOF. */
    forceCommandPropagation(c, PROPAGATE_REPL | PROPAGATE_AOF);

    addReply(c,shared.ok);

#if defined(USE_JEMALLOC)
    /* jemalloc 5 doesn't release pages back to the OS when there's no traffic.
     * for large databases, flushdb blocks for long anyway, so a bit more won't
     * harm and this way the flush and purge will be synchronous. */
    if (!(flags & EMPTYDB_ASYNC))
        jemalloc_purge();
#endif
}",679.0,699.0,1.0,42.0,21.0,11,8,9,5,0,5,2,2,1,4,,0,2,2,1,1,void
2253,103648,flushallCommand,1,flushallCommand,void flushallCommand (client*),db.c,"void flushallCommand(client *c) {
    int flags;
    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
    /* flushall should not flush the functions */
    flushAllDataAndResetRDB(flags | EMPTYDB_NOFUNCTIONS);

    /* Without the forceCommandPropagation, when DBs were already empty,
     * FLUSHALL will not be replicated nor put into the AOF. */
    forceCommandPropagation(c, PROPAGATE_REPL | PROPAGATE_AOF);

    addReply(c,shared.ok);
}",704.0,715.0,1.0,42.0,12.0,7,6,6,3,0,4,2,2,1,4,,0,1,2,1,1,void
2254,103688,delGenericCommand,1,delGenericCommand,"void delGenericCommand (client*,int)",db.c,"void delGenericCommand(client *c, int lazy) {
    int numdel = 0, j;

    for (j = 1; j < c->argc; j++) {
        expireIfNeeded(c->db,c->argv[j],0);
        int deleted  = lazy ? dbAsyncDelete(c->db,c->argv[j]) :
                              dbSyncDelete(c->db,c->argv[j]);
        if (deleted) {
            signalModifiedKey(c,c->db,c->argv[j]);
            notifyKeyspaceEvent(NOTIFY_GENERIC,
                ""del"",c->argv[j],c->db->id);
            server.dirty++;
            numdel++;
        }
    }
    addReplyLongLong(c,numdel);
}",718.0,734.0,1.0,32.0,17.0,26,8,27,6,2,17,3,4,1,6,,0,13,4,2,2,void
2255,103784,delCommand,1,delCommand,void delCommand (client*),db.c,"void delCommand(client *c) {
    delGenericCommand(c,server.lazyfree_lazy_user_del);
}",736.0,738.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
2256,103794,unlinkCommand,1,unlinkCommand,void unlinkCommand (client*),db.c,"void unlinkCommand(client *c) {
    delGenericCommand(c,1);
}",740.0,742.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2257,103802,existsCommand,1,existsCommand,void existsCommand (client*),db.c,"void existsCommand(client *c) {
    long long count = 0;
    int j;

    for (j = 1; j < c->argc; j++) {
        if (lookupKeyReadWithFlags(c->db,c->argv[j],LOOKUP_NOTOUCH)) count++;
    }
    addReplyLongLong(c,count);
}",746.0,754.0,1.0,52.0,9.0,9,6,10,3,0,5,3,4,4,2,,0,4,2,1,1,void
2258,103846,selectCommand,1,selectCommand,void selectCommand (client*),db.c,"void selectCommand(client *c) {
    int id;

    if (getIntFromObjectOrReply(c, c->argv[1], &id, NULL) != C_OK)
        return;

    if (server.cluster_enabled && id != 0) {
        addReplyError(c,""SELECT is not allowed in cluster mode"");
        return;
    }
    if (selectDb(c,id) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
    } else {
        addReply(c,shared.ok);
    }
}",756.0,771.0,1.0,61.0,16.0,9,8,10,4,0,5,4,4,3,4,,0,3,2,1,1,void
2259,103902,randomkeyCommand,1,randomkeyCommand,void randomkeyCommand (client*),db.c,"void randomkeyCommand(client *c) {
    robj *key;

    if ((key = dbRandomKey(c->db)) == NULL) {
        addReplyNull(c);
        return;
    }

    addReplyBulk(c,key);
    decrRefCount(key);
}",773.0,783.0,1.0,1.0,11.0,3,3,7,3,0,5,2,2,2,4,,0,2,2,1,1,void
2260,103926,keysCommand,1,keysCommand,void keysCommand (client*),db.c,"void keysCommand(client *c) {
    dictIterator *di;
    dictEntry *de;
    sds pattern = c->argv[1]->ptr;
    int plen = sdslen(pattern), allkeys;
    unsigned long numkeys = 0;
    void *replylen = addReplyDeferredLen(c);

    di = dictGetSafeIterator(c->db->dict);
    allkeys = (pattern[0] == '*' && plen == 1);
    robj keyobj;
    while((de = dictNext(di)) != NULL) {
        sds key = dictGetKey(de);

        if (allkeys || stringmatchlen(pattern,plen,key,sdslen(key),0)) {
            initStaticStringObject(keyobj, key);
            if (!keyIsExpired(c->db, &keyobj)) {
                addReplyBulkCBuffer(c, key, sdslen(key));
                numkeys++;
            }
        }
        if (c->flags & CLIENT_CLOSE_ASAP)
            break;
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c,replylen,numkeys);
}",785.0,811.0,1.0,12.0,27.0,35,14,41,12,0,16,6,9,6,12,,0,13,2,1,1,void
2261,104072,objectTypeCompare,1,objectTypeCompare,"int objectTypeCompare (robj*,long long)",db.c,"int objectTypeCompare(robj *o, long long target) {
    if (o->type != OBJ_MODULE) {
        if (o->type != target) 
            return 0;
        else 
            return 1;
    }
    /* module type compare */
    long long mt = (long long)REDISMODULE_TYPE_SIGN(((moduleValue *)o->ptr)->type->id);
    if (target != -mt)
        return 0;
    else 
        return 1;
}",823.0,836.0,1.0,19.0,14.0,17,10,7,3,1,0,4,5,0,0,,0,0,4,2,2,int
2262,104138,scanCallback,1,scanCallback,"void scanCallback (void*,dictEntry*)",db.c,"void scanCallback(void *privdata, const dictEntry *de) {
    scanData *data = (scanData *)privdata;
    list *keys = data->keys;
    robj *o = data->o;
    sds val = NULL;
    sds key = NULL;
    data->sampled++;

    /* o and typename can not have values at the same time. */
    serverAssert(!((data->type != LLONG_MAX) && o));

    /* Filter an element if it isn't the type we want. */
    /* TODO: uncomment in redis 8.0
    if (!o && data->type != LLONG_MAX) {
        robj *rval = dictGetVal(de);
        if (!objectTypeCompare(rval, data->type)) return;
    }*/

    /* Filter element if it does not match the pattern. */
    sds keysds = dictGetKey(de);
    if (data->pattern) {
        if (!stringmatchlen(data->pattern, sdslen(data->pattern), keysds, sdslen(keysds), 0)) {
            return;
        }
    }

    if (o == NULL) {
        key = keysds;
    } else if (o->type == OBJ_SET) {
        key = keysds;
    } else if (o->type == OBJ_HASH) {
        key = keysds;
        val = d...",839.0,883.0,1.0,4.0,45.0,25,11,30,10,0,14,5,6,6,7,,0,11,4,2,2,void
2263,104314,parseScanCursorOrReply,1,parseScanCursorOrReply,"int parseScanCursorOrReply (client*,robj*,long unsigned*)",db.c,"int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
    char *eptr;

    /* Use strtoul() because we need an *unsigned* long, so
     * getLongLongFromObject() does not cover the whole cursor space. */
    errno = 0;
    *cursor = strtoul(o->ptr, &eptr, 10);
    if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
    {
        addReplyError(c, ""invalid cursor"");
        return C_ERR;
    }
    return C_OK;
}",889.0,902.0,1.0,15.0,14.0,14,10,9,6,1,1,2,2,0,1,,0,0,6,3,3,int
2264,104378,getObjectTypeByName,1,getObjectTypeByName,long long getObjectTypeByName (char*),db.c,"long long getObjectTypeByName(char *name) {

    for (long long i = 0; i < OBJ_TYPE_MAX; i++) {
        if (obj_type_name[i] && !strcasecmp(name, obj_type_name[i])) {
            return i;
        }
    }

    moduleType *mt = moduleTypeLookupModuleByNameIgnoreCase(name);
    if (mt != NULL) return -(REDISMODULE_TYPE_SIGN(mt->id));

    return LLONG_MAX;
}",915.0,927.0,1.0,30.0,13.0,16,13,15,6,0,3,4,5,2,1,,0,3,2,1,1,long long
2265,104443,getObjectTypeName,1,getObjectTypeName,char* getObjectTypeName (robj*),db.c,"char *getObjectTypeName(robj *o) {
    if (o == NULL) {
        return ""none"";
    }

    serverAssert(o->type >= 0 && o->type < OBJ_TYPE_MAX);

    if (o->type == OBJ_MODULE) {
        moduleValue *mv = o->ptr;
        return mv->type->name;
    } else {
        return obj_type_name[o->type];
    }
}",929.0,942.0,1.0,4.0,14.0,16,10,8,3,1,2,3,3,0,1,,0,1,2,1,1,char*
2266,104508,scanGenericCommand,1,scanGenericCommand,"void scanGenericCommand (client*,robj*,long unsigned)",db.c,"void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
    int i, j;
    listNode *node;
    long count = 10;
    sds pat = NULL;
    sds typename = NULL;
    long long type = LLONG_MAX;
    int patlen = 0, use_pattern = 0;
    dict *ht;

    /* Object must be NULL (to iterate keys names), or the type of the object
     * must be Set, Sorted Set, or Hash. */
    serverAssert(o == NULL || o->type == OBJ_SET || o->type == OBJ_HASH ||
                o->type == OBJ_ZSET);

    /* Set i to the first option argument. The previous one is the cursor. */
    i = (o == NULL) ? 2 : 3; /* Skip the key argument if needed. */

    /* Step 1: Parse options. */
    while (i < c->argc) {
        j = c->argc - i;
        if (!strcasecmp(c->argv[i]->ptr, ""count"") && j >= 2) {
            if (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
                != C_OK)
            {
                return;
            }

            if (count < 1) {
                addReplyErrorObject(...",955.0,1159.0,1.0,4.0,205.0,107,24,121,28,1,32,16,29,11,19,,0,21,6,3,3,void
2267,105271,scanCommand,1,scanCommand,void scanCommand (client*),db.c,"void scanCommand(client *c) {
    unsigned long cursor;
    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
    scanGenericCommand(c,NULL,cursor);
}",1162.0,1166.0,1.0,56.0,5.0,5,5,6,3,0,3,2,2,2,2,,0,2,2,1,1,void
2268,105298,dbsizeCommand,1,dbsizeCommand,void dbsizeCommand (client*),db.c,"void dbsizeCommand(client *c) {
    addReplyLongLong(c,dictSize(c->db->dict));
}",1168.0,1170.0,1.0,23.0,3.0,11,3,4,1,0,4,1,1,0,1,,0,3,2,1,1,void
2269,105331,lastsaveCommand,1,lastsaveCommand,void lastsaveCommand (client*),db.c,"void lastsaveCommand(client *c) {
    addReplyLongLong(c,server.lastsave);
}",1172.0,1174.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
2270,105341,typeCommand,1,typeCommand,void typeCommand (client*),db.c,"void typeCommand(client *c) {
    robj *o;
    o = lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH);
    addReplyStatus(c, getObjectTypeName(o));
}",1176.0,1180.0,1.0,48.0,5.0,5,4,5,2,0,5,1,1,0,3,,0,4,2,1,1,void
2271,105367,shutdownCommand,1,shutdownCommand,void shutdownCommand (client*),db.c,"void shutdownCommand(client *c) {
    int flags = SHUTDOWN_NOFLAGS;
    int abort = 0;
    for (int i = 1; i < c->argc; i++) {
        if (!strcasecmp(c->argv[i]->ptr,""nosave"")) {
            flags |= SHUTDOWN_NOSAVE;
        } else if (!strcasecmp(c->argv[i]->ptr,""save"")) {
            flags |= SHUTDOWN_SAVE;
        } else if (!strcasecmp(c->argv[i]->ptr, ""now"")) {
            flags |= SHUTDOWN_NOW;
        } else if (!strcasecmp(c->argv[i]->ptr, ""force"")) {
            flags |= SHUTDOWN_FORCE;
        } else if (!strcasecmp(c->argv[i]->ptr, ""abort"")) {
            abort = 1;
        } else {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        }
    }
    if ((abort && flags != SHUTDOWN_NOFLAGS) ||
        (flags & SHUTDOWN_NOSAVE && flags & SHUTDOWN_SAVE))
    {
        /* Illegal combo. */
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    if (abort) {
        if (abortShutdown() == C_OK)
            addReply(c, shared.ok);
 ...",1182.0,1241.0,1.0,16.0,60.0,32,12,27,6,0,11,10,13,6,8,,0,6,2,1,1,void
2272,105632,renameGenericCommand,1,renameGenericCommand,"void renameGenericCommand (client*,int)",db.c,"void renameGenericCommand(client *c, int nx) {
    robj *o;
    long long expire;
    int samekey = 0;

    /* When source and dest key is the same, no operation is performed,
     * if the key exists, however we still return an error on unexisting key. */
    if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
        return;

    if (samekey) {
        addReply(c,nx ? shared.czero : shared.ok);
        return;
    }

    incrRefCount(o);
    expire = getExpire(c->db,c->argv[1]);
    if (lookupKeyWrite(c->db,c->argv[2]) != NULL) {
        if (nx) {
            decrRefCount(o);
            addReply(c,shared.czero);
            return;
        }
        /* Overwrite: delete the old key before creating the new one
         * with the same name. */
        dbDelete(c->db,c->argv[2]);
    }
    dbAdd(c->db,c->argv[2],o);
    if (expire != -1) setExpire(c,c->db,c->argv[2],expire);
    dbDelete(c->db,c-...",1243.0,1283.0,1.0,24.0,41.0,61,10,52,8,2,40,7,8,8,17,,0,27,4,2,2,void
2273,105847,renameCommand,1,renameCommand,void renameCommand (client*),db.c,"void renameCommand(client *c) {
    renameGenericCommand(c,0);
}",1285.0,1287.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2274,105855,renamenxCommand,1,renamenxCommand,void renamenxCommand (client*),db.c,"void renamenxCommand(client *c) {
    renameGenericCommand(c,1);
}",1289.0,1291.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2275,105863,moveCommand,1,moveCommand,void moveCommand (client*),db.c,"void moveCommand(client *c) {
    robj *o;
    redisDb *src, *dst;
    int srcid, dbid;
    long long expire;

    if (server.cluster_enabled) {
        addReplyError(c,""MOVE is not allowed in cluster mode"");
        return;
    }

    /* Obtain source and target DB pointers */
    src = c->db;
    srcid = c->db->id;

    if (getIntFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK)
        return;

    if (selectDb(c,dbid) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
        return;
    }
    dst = c->db;
    selectDb(c,srcid); /* Back to the source DB */

    /* If the user is moving using as target the same
     * DB as the source DB it is probably an error. */
    if (src == dst) {
        addReplyErrorObject(c,shared.sameobjecterr);
        return;
    }

    /* Check if the element exists and get a reference */
    o = lookupKeyWrite(c->db,c->argv[1]);
    if (!o) {
        addReply(c,shared.czero);
        return;
    }
    expire = getExpire(c->db,c->a...",1293.0,1353.0,1.0,63.0,61.0,53,11,59,10,0,38,8,8,5,20,,0,23,2,1,1,void
2276,106081,copyCommand,1,copyCommand,void copyCommand (client*),db.c,"void copyCommand(client *c) {
    robj *o;
    redisDb *src, *dst;
    int srcid, dbid;
    long long expire;
    int j, replace = 0, delete = 0;

    /* Obtain source and target DB pointers 
     * Default target DB is the same as the source DB 
     * Parse the REPLACE option and targetDB option. */
    src = c->db;
    dst = c->db;
    srcid = c->db->id;
    dbid = c->db->id;
    for (j = 3; j < c->argc; j++) {
        int additional = c->argc - j - 1;
        if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr, ""db"") && additional >= 1) {
            if (getIntFromObjectOrReply(c, c->argv[j+1], &dbid, NULL) != C_OK)
                return;

            if (selectDb(c, dbid) == C_ERR) {
                addReplyError(c,""DB index is out of range"");
                return;
            }
            dst = c->db;
            selectDb(c,srcid); /* Back to the source DB */
            j++; /* Consume additional arg. */
  ...",1355.0,1455.0,1.0,73.0,101.0,71,14,87,17,0,36,19,15,4,21,,0,26,2,1,1,void
2277,106471,scanDatabaseForReadyKeys,1,scanDatabaseForReadyKeys,void scanDatabaseForReadyKeys (redisDb*),db.c,"void scanDatabaseForReadyKeys(redisDb *db) {
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(db->blocking_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        dictEntry *kde = dictFind(db->dict,key->ptr);
        if (kde) {
            robj *value = dictGetVal(kde);
            signalKeyAsReady(db, key, value->type);
        }
    }
    dictReleaseIterator(di);
}",1461.0,1473.0,1.0,1.0,13.0,10,3,17,7,3,9,3,4,1,7,,0,7,2,1,1,void
2278,106523,scanDatabaseForDeletedKeys,1,scanDatabaseForDeletedKeys,"void scanDatabaseForDeletedKeys (redisDb*,redisDb*)",db.c,"void scanDatabaseForDeletedKeys(redisDb *emptied, redisDb *replaced_with) {
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(emptied->blocking_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        int existed = 0, exists = 0;
        int original_type = -1, curr_type = -1;

        dictEntry *kde = dictFind(emptied->dict, key->ptr);
        if (kde) {
            robj *value = dictGetVal(kde);
            original_type = value->type;
            existed = 1;
        }

        if (replaced_with) {
            dictEntry *kde = dictFind(replaced_with->dict, key->ptr);
            if (kde) {
                robj *value = dictGetVal(kde);
                curr_type = value->type;
                exists = 1;
            }
        }
        /* We want to try to unblock any client using a blocking XREADGROUP */
        if ((existed && !exists) || original_type != curr_type)
            signalDeletedKeyAsReady(emptied, key, original_type);
 ...",1478.0,1506.0,1.0,1.0,29.0,29,7,38,12,4,12,6,11,1,9,,0,10,4,2,2,void
2279,106639,dbSwapDatabases,1,dbSwapDatabases,"int dbSwapDatabases (int,int)",db.c,"int dbSwapDatabases(int id1, int id2) {
    if (id1 < 0 || id1 >= server.dbnum ||
        id2 < 0 || id2 >= server.dbnum) return C_ERR;
    if (id1 == id2) return C_OK;
    redisDb aux = server.db[id1];
    redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];

    /* Swapdb should make transaction fail if there is any
     * client watching keys */
    touchAllWatchedKeysInDb(db1, db2);
    touchAllWatchedKeysInDb(db2, db1);

    /* Try to unblock any XREADGROUP clients if the key no longer exists. */
    scanDatabaseForDeletedKeys(db1, db2);
    scanDatabaseForDeletedKeys(db2, db1);

    /* Swap hash tables. Note that we don't swap blocking_keys,
     * ready_keys and watched_keys, since we want clients to
     * remain in the same DB they were. */
    db1->dict = db2->dict;
    db1->expires = db2->expires;
    db1->avg_ttl = db2->avg_ttl;
    db1->expires_cursor = db2->expires_cursor;

    db2->dict = aux.dict;
    db2->expires = aux.expires;
    db2->avg_ttl = aux.avg_ttl;
   ...",1516.0,1557.0,1.0,47.0,42.0,46,10,43,6,1,22,3,3,0,6,,0,16,4,2,2,int
2280,106782,swapMainDbWithTempDb,1,swapMainDbWithTempDb,void swapMainDbWithTempDb (redisDb*),db.c,"void swapMainDbWithTempDb(redisDb *tempDb) {
    if (server.cluster_enabled) {
        /* Swap slots_to_keys from tempdb just loaded with main db slots_to_keys. */
        clusterSlotToKeyMapping *aux = server.db->slots_to_keys;
        server.db->slots_to_keys = tempDb->slots_to_keys;
        tempDb->slots_to_keys = aux;
    }

    for (int i=0; i<server.dbnum; i++) {
        redisDb aux = server.db[i];
        redisDb *activedb = &server.db[i], *newdb = &tempDb[i];

        /* Swapping databases should make transaction fail if there is any
         * client watching keys. */
        touchAllWatchedKeysInDb(activedb, newdb);

        /* Try to unblock any XREADGROUP clients if the key no longer exists. */
        scanDatabaseForDeletedKeys(activedb, newdb);

        /* Swap hash tables. Note that we don't swap blocking_keys,
         * ready_keys and watched_keys, since clients 
         * remain in the same DB they were. */
        activedb->dict = newdb->dict;
        activedb->e...",1562.0,1608.0,1.0,1.0,47.0,47,6,40,6,1,23,3,3,0,5,,0,18,2,1,1,void
2281,106919,swapdbCommand,1,swapdbCommand,void swapdbCommand (client*),db.c,"void swapdbCommand(client *c) {
    int id1, id2;

    /* Not allowed in cluster mode: we have just DB 0 there. */
    if (server.cluster_enabled) {
        addReplyError(c,""SWAPDB is not allowed in cluster mode"");
        return;
    }

    /* Get the two DBs indexes. */
    if (getIntFromObjectOrReply(c, c->argv[1], &id1,
        ""invalid first DB index"") != C_OK)
        return;

    if (getIntFromObjectOrReply(c, c->argv[2], &id2,
        ""invalid second DB index"") != C_OK)
        return;

    /* Swap... */
    if (dbSwapDatabases(id1,id2) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
        return;
    } else {
        RedisModuleSwapDbInfo si = {REDISMODULE_SWAPDBINFO_VERSION,id1,id2};
        moduleFireServerEvent(REDISMODULE_EVENT_SWAPDB,0,&si);
        server.dirty++;
        addReply(c,shared.ok);
    }
}",1611.0,1639.0,1.0,37.0,29.0,11,7,11,4,0,7,5,5,5,5,,0,5,2,1,1,void
2282,107010,removeExpire,1,removeExpire,"int removeExpire (redisDb*,robj*)",db.c,"int removeExpire(redisDb *db, robj *key) {
    return dictDelete(db->expires,key->ptr) == DICT_OK;
}",1645.0,1647.0,1.0,47.0,3.0,3,2,2,2,2,2,1,1,0,1,,0,1,4,2,2,int
2283,107028,setExpire,1,setExpire,"void setExpire (client*,redisDb*,robj*,long long)",db.c,"void setExpire(client *c, redisDb *db, robj *key, long long when) {
    dictEntry *kde, *de;

    /* Reuse the sds from the main dict in the expire dict */
    kde = dictFind(db->dict,key->ptr);
    serverAssertWithInfo(NULL,key,kde != NULL);
    de = dictAddOrFind(db->expires,dictGetKey(kde));
    dictSetSignedIntegerVal(de,when);

    int writable_slave = server.masterhost && server.repl_slave_ro == 0;
    if (c && writable_slave && !(c->flags & CLIENT_MASTER))
        rememberSlaveKeyWithExpire(db,key);
}",1653.0,1665.0,1.0,4.0,13.0,21,13,22,9,7,9,2,2,1,6,,0,6,8,4,4,void
2284,107109,getExpire,1,getExpire,"long long getExpire (redisDb*,robj*)",db.c,"long long getExpire(redisDb *db, robj *key) {
    dictEntry *de;

    /* No expire? return ASAP */
    if (dictSize(db->expires) == 0 ||
       (de = dictFind(db->expires,key->ptr)) == NULL) return -1;

    return dictGetSignedIntegerVal(de);
}",1669.0,1677.0,1.0,8.0,9.0,15,7,8,4,11,6,2,2,5,2,,0,5,4,2,2,long long
2285,107158,deleteExpiredKeyAndPropagate,1,deleteExpiredKeyAndPropagate,"void deleteExpiredKeyAndPropagate (redisDb*,robj*)",db.c,"void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) {
    mstime_t expire_latency;
    latencyStartMonitor(expire_latency);
    dbGenericDelete(db,keyobj,server.lazyfree_lazy_expire,DB_FLAG_KEY_EXPIRED);
    latencyEndMonitor(expire_latency);
    latencyAddSampleIfNeeded(""expire-del"",expire_latency);
    notifyKeyspaceEvent(NOTIFY_EXPIRED,""expired"",keyobj,db->id);
    signalModifiedKey(NULL, db, keyobj);
    propagateDeletion(db,keyobj,server.lazyfree_lazy_expire);
    server.stat_expiredkeys++;
}",1680.0,1690.0,1.0,4.0,11.0,17,8,25,5,1,8,1,1,0,7,,0,3,4,2,2,void
2286,107248,propagateDeletion,1,propagateDeletion,"void propagateDeletion (redisDb*,robj*,int)",db.c,"void propagateDeletion(redisDb *db, robj *key, int lazy) {
    robj *argv[2];

    argv[0] = lazy ? shared.unlink : shared.del;
    argv[1] = key;
    incrRefCount(argv[0]);
    incrRefCount(argv[1]);

    /* If the master decided to expire a key we must propagate it to replicas no matter what..
     * Even if module executed a command without asking for propagation. */
    int prev_replication_allowed = server.replication_allowed;
    server.replication_allowed = 1;
    alsoPropagate(db->id,argv,2,PROPAGATE_AOF|PROPAGATE_REPL);
    server.replication_allowed = prev_replication_allowed;

    decrRefCount(argv[0]);
    decrRefCount(argv[1]);
}",1710.0,1727.0,1.0,32.0,18.0,19,6,17,7,2,6,1,1,0,5,,0,1,6,3,3,void
2287,107464,getKeysPrepareResult,1,getKeysPrepareResult,"keyReference getKeysPrepareResult (getKeysResult*,int)",db.c,"keyReference *getKeysPrepareResult(getKeysResult *result, int numkeys) {
    /* GETKEYS_RESULT_INIT initializes keys to NULL, point it to the pre-allocated stack
     * buffer here. */
    if (!result->keys) {
        serverAssert(!result->numkeys);
        result->keys = result->keysbuf;
    }

    /* Resize if necessary */
    if (numkeys > result->size) {
        if (result->keys != result->keysbuf) {
            /* We're not using a static buffer, just (re)alloc */
            result->keys = zrealloc(result->keys, numkeys * sizeof(keyReference));
        } else {
            /* We are using a static buffer, copy its contents */
            result->keys = zmalloc(numkeys * sizeof(keyReference));
            if (result->numkeys)
                memcpy(result->keys, result->keysbuf, result->numkeys * sizeof(keyReference));
        }
        result->size = numkeys;
    }

    return result->keys;
}",1830.0,1853.0,1.0,8.0,24.0,26,11,16,3,15,14,4,5,4,2,,0,13,4,2,2,keyReference
2288,107570,getAllKeySpecsFlags,1,getAllKeySpecsFlags,"int64_t getAllKeySpecsFlags (redisCommand*,int)",db.c,"int64_t getAllKeySpecsFlags(struct redisCommand *cmd, int inv) {
    int64_t flags = 0;
    for (int j = 0; j < cmd->key_specs_num; j++) {
        keySpec *spec = cmd->key_specs + j;
        flags |= inv? ~spec->flags : spec->flags;
    }
    return flags;
}",1857.0,1864.0,1.0,1.0,8.0,11,6,12,5,3,4,2,2,1,0,,0,4,4,2,2,int64_t
2289,107615,getKeysUsingKeySpecs,1,getKeysUsingKeySpecs,"int getKeysUsingKeySpecs (redisCommand*,robj**,int,int,getKeysResult*)",db.c,"int getKeysUsingKeySpecs(struct redisCommand *cmd, robj **argv, int argc, int search_flags, getKeysResult *result) {
    int j, i, last, first, step;
    keyReference *keys;
    serverAssert(result->numkeys == 0); /* caller should initialize or reset it */

    for (j = 0; j < cmd->key_specs_num; j++) {
        keySpec *spec = cmd->key_specs + j;
        serverAssert(spec->begin_search_type != KSPEC_BS_INVALID);
        /* Skip specs that represent 'fake' keys */
        if ((spec->flags & CMD_KEY_NOT_KEY) && !(search_flags & GET_KEYSPEC_INCLUDE_NOT_KEYS)) {
            continue;
        }

        first = 0;
        if (spec->begin_search_type == KSPEC_BS_INDEX) {
            first = spec->bs.index.pos;
        } else if (spec->begin_search_type == KSPEC_BS_KEYWORD) {
            int start_index = spec->bs.keyword.startfrom > 0 ? spec->bs.keyword.startfrom : argc+spec->bs.keyword.startfrom;
            int end_index = spec->bs.keyword.startfrom > 0 ? argc-1: 1;
            for (i =...",1873.0,1986.0,1.0,4.0,114.0,86,21,57,15,1,20,18,26,7,3,,0,18,10,5,5,int
2290,108178,getKeysFromCommandWithSpecs,1,getKeysFromCommandWithSpecs,"int getKeysFromCommandWithSpecs (redisCommand*,robj**,int,int,getKeysResult*)",db.c,"int getKeysFromCommandWithSpecs(struct redisCommand *cmd, robj **argv, int argc, int search_flags, getKeysResult *result) {
    /* The command has at least one key-spec not marked as NOT_KEY */
    int has_keyspec = (getAllKeySpecsFlags(cmd, 1) & CMD_KEY_NOT_KEY);
    /* The command has at least one key-spec marked as VARIABLE_FLAGS */
    int has_varflags = (getAllKeySpecsFlags(cmd, 0) & CMD_KEY_VARIABLE_FLAGS);

    /* We prefer key-specs if there are any, and their flags are reliable. */
    if (has_keyspec && !has_varflags) {
        int ret = getKeysUsingKeySpecs(cmd,argv,argc,search_flags,result);
        if (ret >= 0)
            return ret;
        /* If the specs returned with an error (probably an INVALID or INCOMPLETE spec),
         * fallback to the callback method. */
    }

    /* Resort to getkeys callback methods. */
    if (cmd->flags & CMD_MODULE_GETKEYS)
        return moduleGetCommandKeysViaAPI(cmd,argv,argc,result);

    /* We use native getkeys as a last resor...",2000.0,2024.0,1.0,53.0,25.0,15,7,25,8,2,7,5,6,2,4,,0,6,10,5,5,int
2291,108266,doesCommandHaveKeys,1,doesCommandHaveKeys,int doesCommandHaveKeys (redisCommand*),db.c,"int doesCommandHaveKeys(struct redisCommand *cmd) {
    return cmd->getkeys_proc ||                                 /* has getkeys_proc (non modules) */
        (cmd->flags & CMD_MODULE_GETKEYS) ||                    /* module with GETKEYS */
        (getAllKeySpecsFlags(cmd, 1) & CMD_KEY_NOT_KEY);        /* has at least one key-spec not marked as NOT_KEY */
}",2027.0,2031.0,1.0,22.0,5.0,8,4,3,1,2,3,1,1,0,1,,0,2,2,1,1,int
2292,108398,doesCommandHaveChannelsWithFlags,1,doesCommandHaveChannelsWithFlags,"int doesCommandHaveChannelsWithFlags (redisCommand*,int)",db.c,"int doesCommandHaveChannelsWithFlags(struct redisCommand *cmd, int flags) {
    /* If a module declares get channels, we are just going to assume
     * has channels. This API is allowed to return false positives. */
    if (cmd->flags & CMD_MODULE_GETCHANNELS) {
        return 1;
    }
    for (ChannelSpecs *spec = commands_with_channels; spec->proc != NULL; spec += 1) {
        if (cmd->proc == spec->proc) {
            return !!(spec->flags & flags);
        }
    }
    return 0;
}",2057.0,2069.0,1.0,21.0,13.0,13,7,9,5,1,3,4,5,2,0,,0,3,4,2,2,int
2293,108451,getChannelsFromCommand,1,getChannelsFromCommand,"int getChannelsFromCommand (redisCommand*,robj**,int,getKeysResult*)",db.c,"int getChannelsFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    /* If a module declares get channels, use that. */
    if (cmd->flags & CMD_MODULE_GETCHANNELS) {
        return moduleGetCommandChannelsViaAPI(cmd, argv, argc, result);
    }
    /* Otherwise check the channel spec table */
    for (ChannelSpecs *spec = commands_with_channels; spec != NULL; spec += 1) {
        if (cmd->proc == spec->proc) {
            int start = spec->start;
            int stop = (spec->count == -1) ? argc : start + spec->count;
            if (stop > argc) stop = argc;
            int count = 0;
            keys = getKeysPrepareResult(result, stop - start);
            for (int i = start; i < stop; i++ ) {
                keys[count].pos = i;
                keys[count++].flags = spec->flags;
            }
            result->numkeys = count;
            return count;
        }
    }
    return 0;
}",2084.0,2107.0,1.0,21.0,24.0,34,15,40,12,1,6,6,11,2,2,,0,5,8,4,4,int
2294,108578,getKeysUsingLegacyRangeSpec,1,getKeysUsingLegacyRangeSpec,"int getKeysUsingLegacyRangeSpec (redisCommand*,robj**,int,getKeysResult*)",db.c,"int getKeysUsingLegacyRangeSpec(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int j, i = 0, last, first, step;
    keyReference *keys;
    UNUSED(argv);

    if (cmd->legacy_range_key_spec.begin_search_type == KSPEC_BS_INVALID) {
        result->numkeys = 0;
        return 0;
    }

    first = cmd->legacy_range_key_spec.bs.index.pos;
    last = cmd->legacy_range_key_spec.fk.range.lastkey;
    if (last >= 0)
        last += first;
    step = cmd->legacy_range_key_spec.fk.range.keystep;

    if (last < 0) last = argc+last;

    int count = ((last - first)+1);
    keys = getKeysPrepareResult(result, count);

    for (j = first; j <= last; j += step) {
        if (j >= argc || j < first) {
            /* Modules commands, and standard commands with a not fixed number
             * of arguments (negative arity parameter) do not have dispatch
             * time arity checks, so we need to handle the case where the user
             * passed an invalid nu...",2119.0,2161.0,1.0,4.0,43.0,53,16,44,12,0,10,7,10,3,1,,0,10,8,4,4,int
2295,108758,getKeysFromCommand,1,getKeysFromCommand,"int getKeysFromCommand (redisCommand*,robj**,int,getKeysResult*)",db.c,"int getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    if (cmd->flags & CMD_MODULE_GETKEYS) {
        return moduleGetCommandKeysViaAPI(cmd,argv,argc,result);
    } else if (cmd->getkeys_proc) {
        return cmd->getkeys_proc(cmd,argv,argc,result);
    } else {
        return getKeysUsingLegacyRangeSpec(cmd,argv,argc,result);
    }
}",2174.0,2182.0,1.0,21.0,9.0,3,3,5,4,2,2,2,2,1,1,,0,1,8,4,4,int
2296,108807,getKeysFreeResult,1,getKeysFreeResult,void getKeysFreeResult (getKeysResult*),db.c,"void getKeysFreeResult(getKeysResult *result) {
    if (result && result->keys != result->keysbuf)
        zfree(result->keys);
}",2185.0,2188.0,1.0,1.0,4.0,5,3,4,1,7,4,2,2,2,1,,0,3,2,1,1,void
2297,108827,genericGetKeys,1,genericGetKeys,"int genericGetKeys (int,int,int,int,robj**,int,getKeysResult*)",db.c,"int genericGetKeys(int storeKeyOfs, int keyCountOfs, int firstKeyOfs, int keyStep,
                    robj **argv, int argc, getKeysResult *result) {
    int i, num;
    keyReference *keys;

    num = atoi(argv[keyCountOfs]->ptr);
    /* Sanity check. Don't return any key if the command is going to
     * reply with syntax error. (no input keys). */
    if (num < 1 || num > (argc - firstKeyOfs)/keyStep) {
        result->numkeys = 0;
        return 0;
    }

    int numkeys = storeKeyOfs ? num + 1 : num;
    keys = getKeysPrepareResult(result, numkeys);
    result->numkeys = numkeys;

    /* Add all key positions for argv[firstKeyOfs...n] to keys[] */
    for (i = 0; i < num; i++) {
        keys[i].pos = firstKeyOfs+(i*keyStep);
        keys[i].flags = 0;
    } 

    if (storeKeyOfs) {
        keys[num].pos = storeKeyOfs;
        keys[num].flags = 0;
    } 
    return result->numkeys;
}",2203.0,2231.0,1.0,1.0,29.0,33,12,35,11,9,4,4,4,0,1,,0,4,14,7,7,int
2298,108938,sintercardGetKeys,1,sintercardGetKeys,"int sintercardGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int sintercardGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2233.0,2236.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2299,108961,zunionInterDiffStoreGetKeys,1,zunionInterDiffStoreGetKeys,"int zunionInterDiffStoreGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int zunionInterDiffStoreGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(1, 2, 3, 1, argv, argc, result);
}",2238.0,2241.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2300,108984,zunionInterDiffGetKeys,1,zunionInterDiffGetKeys,"int zunionInterDiffGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int zunionInterDiffGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2243.0,2246.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2301,109007,evalGetKeys,1,evalGetKeys,"int evalGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2248.0,2251.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2302,109030,functionGetKeys,1,functionGetKeys,"int functionGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int functionGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2253.0,2256.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2303,109053,lmpopGetKeys,1,lmpopGetKeys,"int lmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int lmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2258.0,2261.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2304,109076,blmpopGetKeys,1,blmpopGetKeys,"int blmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int blmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2263.0,2266.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2305,109099,zmpopGetKeys,1,zmpopGetKeys,"int zmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int zmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2268.0,2271.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2306,109122,bzmpopGetKeys,1,bzmpopGetKeys,"int bzmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int bzmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2273.0,2276.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
2307,109145,sortROGetKeys,1,sortROGetKeys,"int sortROGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    UNUSED(cmd);
    UNUSED(argv);
    UNUSED(argc);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* <sort-key> is always present. */
    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;
    return 1;
}",2288.0,2298.0,1.0,4.0,11.0,13,6,10,5,0,1,1,1,0,1,,0,1,8,4,4,int
2308,109203,sortGetKeys,1,sortGetKeys,"int sortGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, j, num, found_store = 0;
    keyReference *keys;
    UNUSED(cmd);

    num = 0;
    keys = getKeysPrepareResult(result, 2); /* Alloc 2 places for the worst case. */
    keys[num].pos = 1; /* <sort-key> is always present. */
    keys[num++].flags = CMD_KEY_RO | CMD_KEY_ACCESS;

    /* Search for STORE option. By default we consider options to don't
     * have arguments, so if we find an unknown option name we scan the
     * next. However there are options with 1 or 2 arguments, so we
     * provide a list here in order to skip the right number of args. */
    struct {
        char *name;
        int skip;
    } skiplist[] = {
        {""limit"", 2},
        {""get"", 1},
        {""by"", 1},
        {NULL, 0} /* End of elements. */
    };

    for (i = 2; i < argc; i++) {
        for (j = 0; skiplist[j].name != NULL; j++) {
            if (!strcasecmp(argv[i]->ptr,skiplist[j].name)) {
   ...",2309.0,2351.0,1.0,4.0,43.0,38,14,30,11,0,3,5,7,0,1,,0,3,8,4,4,int
2309,109381,migrateGetKeys,1,migrateGetKeys,"int migrateGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, j, num, first;
    keyReference *keys;
    UNUSED(cmd);

    /* Assume the obvious form. */
    first = 3;
    num = 1;

    /* But check for the extended one with the KEYS option. */
    struct {
        char* name;
        int skip;
    } skip_keywords[] = {       
        {""copy"", 0},
        {""replace"", 0},
        {""auth"", 1},
        {""auth2"", 2},
        {NULL, 0}
    };
    if (argc > 6) {
        for (i = 6; i < argc; i++) {
            if (!strcasecmp(argv[i]->ptr, ""keys"")) {
                if (sdslen(argv[3]->ptr) > 0) {
                    /* This is a syntax error. So ignore the keys and leave
                     * the syntax error to be handled by migrateCommand. */
                    num = 0; 
                } else {
                    first = i + 1;
                    num = argc - first;
                }
                break;
            }
            for (...",2354.0,2403.0,1.0,4.0,50.0,49,14,40,11,0,3,10,19,1,2,,0,3,8,4,4,int
2310,109569,georadiusGetKeys,1,georadiusGetKeys,"int georadiusGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, num;
    keyReference *keys;
    UNUSED(cmd);

    /* Check for the presence of the stored key in the command */
    int stored_key = -1;
    for (i = 5; i < argc; i++) {
        char *arg = argv[i]->ptr;
        /* For the case when user specifies both ""store"" and ""storedist"" options, the
         * second key specified would override the first key. This behavior is kept
         * the same as in georadiusCommand method.
         */
        if ((!strcasecmp(arg, ""store"") || !strcasecmp(arg, ""storedist"")) && ((i+1) < argc)) {
            stored_key = i+1;
            i++;
        }
    }
    num = 1 + (stored_key == -1 ? 0 : 1);

    /* Keys in the command come from two places:
     * argv[1] = key,
     * argv[5...n] = stored key if present
     */
    keys = getKeysPrepareResult(result, num);

    /* Add all key positions to keys[] */
    keys[0].pos = 1;
    keys[0].flags = 0...",2411.0,2446.0,1.0,4.0,36.0,38,15,30,9,0,2,4,5,0,1,,0,2,8,4,4,int
2311,109690,xreadGetKeys,1,xreadGetKeys,"int xreadGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, num = 0;
    keyReference *keys;
    UNUSED(cmd);

    /* We need to parse the options of the command in order to seek the first
     * ""STREAMS"" string which is actually the option. This is needed because
     * ""STREAMS"" could also be the name of the consumer group and even the
     * name of the stream key. */
    int streams_pos = -1;
    for (i = 1; i < argc; i++) {
        char *arg = argv[i]->ptr;
        if (!strcasecmp(arg, ""block"")) {
            i++; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""count"")) {
            i++; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""group"")) {
            i += 2; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""noack"")) {
            /* Nothing to do. */
        } else if (!strcasecmp(arg, ""streams"")) {
            streams_pos = i;
            break;
        } else {
            brea...",2452.0,2496.0,1.0,4.0,45.0,43,16,39,9,0,3,6,7,0,1,,0,3,8,4,4,int
2312,109874,setGetKeys,1,setGetKeys,"int setGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int setGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    UNUSED(cmd);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* We always know the position */
    result->numkeys = 1;

    for (int i = 3; i < argc; i++) {
        char *arg = argv[i]->ptr;
        if ((arg[0] == 'g' || arg[0] == 'G') &&
            (arg[1] == 'e' || arg[1] == 'E') &&
            (arg[2] == 't' || arg[2] == 'T') && arg[3] == '\0')
        {
            keys[0].flags = CMD_KEY_RW | CMD_KEY_ACCESS | CMD_KEY_UPDATE;
            return 1;
        }
    }

    keys[0].flags = CMD_KEY_OW | CMD_KEY_UPDATE;
    return 1;
}",2500.0,2521.0,1.0,4.0,22.0,46,11,21,7,0,2,3,4,0,1,,0,2,8,4,4,int
2313,110013,bitfieldGetKeys,1,bitfieldGetKeys,"int bitfieldGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int bitfieldGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    int readonly = 1;
    UNUSED(cmd);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* We always know the position */
    result->numkeys = 1;

    for (int i = 2; i < argc; i++) {
        int remargs = argc - i - 1; /* Remaining args other than current. */
        char *arg = argv[i]->ptr;
        if (!strcasecmp(arg, ""get"") && remargs >= 2) {
            i += 2;
        } else if ((!strcasecmp(arg, ""set"") || !strcasecmp(arg, ""incrby"")) && remargs >= 3) {
            readonly = 0;
            i += 3;
            break;
        } else if (!strcasecmp(arg, ""overflow"") && remargs >= 1) {
            i += 1;
        } else {
            readonly = 0; /* Syntax error. safer to assume non-RO. */
            break;
        }
    }

    if (readonly) {
        keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;
    } else {
        keys[0].flags = CMD_KEY_RW |...",2525.0,2557.0,1.0,4.0,33.0,26,13,21,9,0,2,4,5,0,1,,0,2,8,4,4,int
2314,110231,bugReportStart,1,bugReportStart,void bugReportStart (void),debug.c,"void bugReportStart(void) {
    pthread_mutex_lock(&bug_report_start_mutex);
    if (bug_report_start == 0) {
        serverLogRaw(LL_WARNING|LL_RAW,
        ""\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\n"");
        bug_report_start = 1;
    }
    pthread_mutex_unlock(&bug_report_start_mutex);
}",1166.0,1174.0,1.0,21.0,9.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
2315,110236,printCrashReport,1,printCrashReport,void printCrashReport (void),debug.c,"void printCrashReport(void) {
    /* Log INFO and CLIENT LIST */
    logServerInfo();

    /* Log the current client */
    logCurrentClient(server.current_client, ""CURRENT"");
    logCurrentClient(server.executing_client, ""EXECUTING"");

    /* Log modules info. Something we wanna do last since we fear it may crash. */
    logModulesInfo();

    /* Log debug config information, which are some values
     * which may be useful for debugging crashes. */
    logConfigDebugInfo();

    /* Run memory test in case the crash was triggered by memory corruption. */
    doFastMemoryTest();
}",2174.0,2191.0,1.0,1.0,18.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2316,110241,bugReportEnd,1,bugReportEnd,"void bugReportEnd (int,int)",debug.c,"void bugReportEnd(int killViaSignal, int sig) {
    struct sigaction act;

    serverLogRaw(LL_WARNING|LL_RAW,
""\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\n\n""
""       Please report the crash by opening an issue on github:\n\n""
""           http://github.com/redis/redis/issues\n\n""
""  If a Redis module was involved, please open in the module's repo instead.\n\n""
""  Suspect RAM error? Use redis-server --test-memory to verify it.\n\n""
""  Some other issues could be detected by redis-server --check-system\n""
);

    /* free(messages); Don't call free() with possibly corrupted memory. */
    if (server.daemonize && server.supervised == 0 && server.pidfile) unlink(server.pidfile);

    if (!killViaSignal) {
        /* To avoid issues with valgrind, we may wanna exit rahter than generate a signal */
        if (server.use_exit_on_panic) {
             /* Using _exit to bypass false leak reports by gcc ASAN */
             fflush(stdout);
            _exit(1);
  ...",2193.0,2225.0,1.0,17.0,33.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
2317,110253,xorDigest,1,xorDigest,"void xorDigest (unsigned char*,void*,size_t)",debug.c,"void xorDigest(unsigned char *digest, const void *ptr, size_t len) {
    SHA1_CTX ctx;
    unsigned char hash[20];
    int j;

    SHA1Init(&ctx);
    SHA1Update(&ctx,ptr,len);
    SHA1Final(hash,&ctx);

    for (j = 0; j < 20; j++)
        digest[j] ^= hash[j];
}",84.0,95.0,1.0,1.0,12.0,5,3,8,5,5,3,2,2,0,3,,0,0,6,3,3,void
2318,110292,xorStringObjectDigest,1,xorStringObjectDigest,"void xorStringObjectDigest (unsigned char*,robj*)",debug.c,"void xorStringObjectDigest(unsigned char *digest, robj *o) {
    o = getDecodedObject(o);
    xorDigest(digest,o->ptr,sdslen(o->ptr));
    decrRefCount(o);
}",97.0,101.0,1.0,1.0,5.0,3,2,6,2,0,4,1,1,0,4,,0,2,4,2,2,void
2319,110313,mixDigest,1,mixDigest,"void mixDigest (unsigned char*,void*,size_t)",debug.c,"void mixDigest(unsigned char *digest, const void *ptr, size_t len) {
    SHA1_CTX ctx;

    xorDigest(digest,ptr,len);
    SHA1Init(&ctx);
    SHA1Update(&ctx,digest,20);
    SHA1Final(digest,&ctx);
}",117.0,124.0,1.0,1.0,8.0,3,1,8,4,6,4,1,1,0,4,,0,0,6,3,3,void
2320,110337,mixStringObjectDigest,1,mixStringObjectDigest,"void mixStringObjectDigest (unsigned char*,robj*)",debug.c,"void mixStringObjectDigest(unsigned char *digest, robj *o) {
    o = getDecodedObject(o);
    mixDigest(digest,o->ptr,sdslen(o->ptr));
    decrRefCount(o);
}",126.0,130.0,1.0,1.0,5.0,3,2,6,2,1,4,1,1,0,4,,0,2,4,2,2,void
2321,110358,xorObjectDigest,1,xorObjectDigest,"void xorObjectDigest (redisDb*,robj*,unsigned char*,robj*)",debug.c,"void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {
    uint32_t aux = htonl(o->type);
    mixDigest(digest,&aux,sizeof(aux));
    long long expiretime = getExpire(db,keyobj);
    char buf[128];

    /* Save the key and associated value */
    if (o->type == OBJ_STRING) {
        mixStringObjectDigest(digest,o);
    } else if (o->type == OBJ_LIST) {
        listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
        listTypeEntry entry;
        while(listTypeNext(li,&entry)) {
            robj *eleobj = listTypeGet(&entry);
            mixStringObjectDigest(digest,eleobj);
            decrRefCount(eleobj);
        }
        listTypeReleaseIterator(li);
    } else if (o->type == OBJ_SET) {
        setTypeIterator *si = setTypeInitIterator(o);
        sds sdsele;
        while((sdsele = setTypeNextObject(si)) != NULL) {
            xorDigest(digest,sdsele,sdslen(sdsele));
            sdsfree(sdsele);
        }
        setTypeReleaseIterator(si);
 ...",140.0,269.0,1.0,19.0,130.0,9,7,13,6,1,4,3,3,0,4,,0,1,8,4,4,void
2322,110948,computeDatasetDigest,1,computeDatasetDigest,void computeDatasetDigest (unsigned char*),debug.c,"void computeDatasetDigest(unsigned char *final) {
    unsigned char digest[20];
    dictIterator *di = NULL;
    dictEntry *de;
    int j;
    uint32_t aux;

    memset(final,0,20); /* Start with a clean result */

    for (j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db+j;

        if (dictSize(db->dict) == 0) continue;
        di = dictGetSafeIterator(db->dict);

        /* hash the DB id, so the same dataset moved in a different
         * DB will lead to a different digest */
        aux = htonl(j);
        mixDigest(final,&aux,sizeof(aux));

        /* Iterate this DB writing every entry */
        while((de = dictNext(di)) != NULL) {
            sds key;
            robj *keyobj, *o;

            memset(digest,0,20); /* This key-val digest */
            key = dictGetKey(de);
            keyobj = createStringObject(key,sdslen(key));

            mixDigest(digest,key,sdslen(key));

            o = dictGetVal(de);
            xorObjectDigest(db,keyobj,digest,o);
...",277.0,317.0,1.0,12.0,41.0,26,10,41,12,0,17,5,6,4,13,,0,11,2,1,1,void
2323,111074,debugCommand,1,debugCommand,void debugCommand (client*),debug.c,"void debugCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""AOF-FLUSH-SLEEP <microsec>"",
""    Server will sleep before flushing the AOF, this is used for testing."",
""ASSERT"",
""    Crash by assertion failed."",
""CHANGE-REPL-ID"",
""    Change the replication IDs of the instance."",
""    Dangerous: should be used only for testing the replication subsystem."",
""CONFIG-REWRITE-FORCE-ALL"",
""    Like CONFIG REWRITE but writes all configuration options, including"",
""    keywords not listed in original configuration file or default values."",
""CRASH-AND-RECOVER [<milliseconds>]"",
""    Hard crash and restart after a <milliseconds> delay (default 0)."",
""DIGEST"",
""    Output a hex signature representing the current DB content."",
""DIGEST-VALUE <key> [<key> ...]"",
""    Output a hex signature of the values of all the specified keys."",
""ERROR <string>"",
""    Return a Redis protocol error with <string> as message. Useful for clients"",
""   ...",390.0,1049.0,1.0,8.0,660.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
2324,114303,_serverAssert,1,_serverAssert,"void _serverAssert (char*,char*,int)",redisassert.c,"void _serverAssert(const char *estr, const char *file, int line) {
    fprintf(stderr, ""=== ASSERTION FAILED ==="");
    fprintf(stderr, ""==> %s:%d '%s' is not true"",file,line,estr);
    raise(SIGSEGV);
}",42.0,46.0,1.0,1.0,5.0,7,3,6,4,353,6,2,2,0,6,,0,0,6,3,3,void
2325,114360,_serverAssertPrintClientInfo,1,_serverAssertPrintClientInfo,void _serverAssertPrintClientInfo (client*),debug.c,"void _serverAssertPrintClientInfo(const client *c) {
    int j;
    char conninfo[CONN_INFO_LEN];

    bugReportStart();
    serverLog(LL_WARNING,""=== ASSERTION FAILED CLIENT CONTEXT ==="");
    serverLog(LL_WARNING,""client->flags = %llu"", (unsigned long long) c->flags);
    serverLog(LL_WARNING,""client->conn = %s"", connGetInfo(c->conn, conninfo, sizeof(conninfo)));
    serverLog(LL_WARNING,""client->argc = %d"", c->argc);
    for (j=0; j < c->argc; j++) {
        char buf[128];
        char *arg;

        if (c->argv[j]->type == OBJ_STRING && sdsEncodedObject(c->argv[j])) {
            arg = (char*) c->argv[j]->ptr;
        } else {
            snprintf(buf,sizeof(buf),""Object type: %u, encoding: %u"",
                c->argv[j]->type, c->argv[j]->encoding);
            arg = buf;
        }
        serverLog(LL_WARNING,""client->argv[%d] = \""%s\"" (refcount: %d)"",
            j, arg, c->argv[j]->refcount);
    }
}",1070.0,1093.0,1.0,18.0,24.0,47,11,28,5,1,17,3,4,5,7,,0,11,2,1,1,void
2326,114572,serverLogObjectDebugInfo,1,serverLogObjectDebugInfo,void serverLogObjectDebugInfo (robj*),debug.c,"void serverLogObjectDebugInfo(const robj *o) {
    serverLog(LL_WARNING,""Object type: %u"", o->type);
    serverLog(LL_WARNING,""Object encoding: %u"", o->encoding);
    serverLog(LL_WARNING,""Object refcount: %d"", o->refcount);
#if UNSAFE_CRASH_REPORT
    /* This code is now disabled. o->ptr may be unreliable to print. in some
     * cases a ziplist could have already been freed by realloc, but not yet
     * updated to o->ptr. in other cases the call to ziplistLen may need to
     * iterate on all the items in the list (and possibly crash again).
     * For some cases it may be ok to crash here again, but these could cause
     * invalid memory access which will bother valgrind and also possibly cause
     * random memory portion to be ""leaked"" into the logfile. */
    if (o->type == OBJ_STRING && sdsEncodedObject(o)) {
        serverLog(LL_WARNING,""Object raw string len: %zu"", sdslen(o->ptr));
        if (sdslen(o->ptr) < 4096) {
            sds repr = sdscatrepr(sdsempty(),o->ptr,sd...",1095.0,1128.0,1.0,4.0,34.0,12,4,6,2,2,3,1,1,0,3,,0,0,2,1,1,void
2327,114640,_serverAssertPrintObject,1,_serverAssertPrintObject,void _serverAssertPrintObject (robj*),debug.c,"void _serverAssertPrintObject(const robj *o) {
    bugReportStart();
    serverLog(LL_WARNING,""=== ASSERTION FAILED OBJECT CONTEXT ==="");
    serverLogObjectDebugInfo(o);
}",1130.0,1134.0,1.0,4.0,5.0,3,3,2,2,1,3,1,1,0,3,,0,0,2,1,1,void
2328,114666,_serverAssertWithInfo,1,_serverAssertWithInfo,"void _serverAssertWithInfo (client*,robj*,char*,char*,int)",debug.c,"void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
    if (c) _serverAssertPrintClientInfo(c);
    if (o) _serverAssertPrintObject(o);
    _serverAssert(estr,file,line);
}",1136.0,1140.0,1.0,1.0,5.0,0,0,7,5,45,3,3,3,0,3,,0,0,10,5,5,void
2329,114689,_serverPanic,1,_serverPanic,"void _serverPanic (char*,int,char*...)",redisassert.c,"void _serverPanic(const char *file, int line, const char *msg, ...) {
    fprintf(stderr, ""------------------------------------------------"");
    fprintf(stderr, ""!!! Software Failure. Press left mouse button to continue"");
    fprintf(stderr, ""Guru Meditation: %s #%s:%d"",msg,file,line);
    abort();
}",48.0,53.0,1.0,1.0,6.0,11,4,14,6,34,7,2,2,0,7,,0,0,6,3,3,void
2330,114862,genClusterDebugString,1,genClusterDebugString,sds genClusterDebugString (sds),debug.c,"sds genClusterDebugString(sds infostring) {
    infostring = sdscatprintf(infostring, ""\r\n# Cluster info\r\n"");
    infostring = sdscatsds(infostring, genClusterInfoString()); 
    infostring = sdscatprintf(infostring, ""\n------ CLUSTER NODES OUTPUT ------\n"");
    infostring = sdscatsds(infostring, clusterGenNodesDescription(NULL, 0, 0));
    
    return infostring;
}",1857.0,1864.0,1.0,1.0,8.0,4,1,10,2,1,6,1,1,0,6,,0,6,2,1,1,sds
2331,114892,logServerInfo,1,logServerInfo,void logServerInfo (void),debug.c,"void logServerInfo(void) {
    sds infostring, clients;
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ INFO OUTPUT ------\n"");
    int all = 0, everything = 0;
    robj *argv[1];
    argv[0] = createStringObject(""all"", strlen(""all""));
    dict *section_dict = genInfoSectionDict(argv, 1, NULL, &all, &everything);
    infostring = genRedisInfoString(section_dict, all, everything);
    if (server.cluster_enabled){
        infostring = genClusterDebugString(infostring);
    }
    serverLogRaw(LL_WARNING|LL_RAW, infostring);
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ CLIENT LIST OUTPUT ------\n"");
    clients = getAllClientsInfoString(-1);
    serverLogRaw(LL_WARNING|LL_RAW, clients);
    sdsfree(infostring);
    sdsfree(clients);
    releaseInfoSectionDict(section_dict);
    decrRefCount(argv[0]);
}",1867.0,1886.0,1.0,17.0,20.0,21,7,22,8,0,13,2,2,0,13,,0,5,2,1,1,void
2332,115001,logConfigDebugInfo,1,logConfigDebugInfo,void logConfigDebugInfo (void),debug.c,"void logConfigDebugInfo(void) {
    sds configstring;
    configstring = getConfigDebugInfo();
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ CONFIG DEBUG OUTPUT ------\n"");
    serverLogRaw(LL_WARNING|LL_RAW, configstring);
    sdsfree(configstring);
}",1889.0,1895.0,1.0,17.0,7.0,5,3,3,1,0,4,1,1,0,4,,0,1,2,1,1,void
2333,115034,logModulesInfo,1,logModulesInfo,void logModulesInfo (void),debug.c,"void logModulesInfo(void) {
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ MODULES INFO OUTPUT ------\n"");
    sds infostring = modulesCollectInfo(sdsempty(), NULL, 1, 0);
    serverLogRaw(LL_WARNING|LL_RAW, infostring);
    sdsfree(infostring);
}",1898.0,1903.0,1.0,17.0,6.0,5,3,4,2,0,5,1,1,0,5,,0,2,2,1,1,void
2334,115071,logCurrentClient,1,logCurrentClient,"void logCurrentClient (client*,char*)",debug.c,"void logCurrentClient(client *cc, const char *title) {
    if (cc == NULL) return;

    sds client;
    int j;

    serverLog(LL_WARNING|LL_RAW, ""\n------ %s CLIENT INFO ------\n"", title);
    client = catClientInfoString(sdsempty(),cc);
    serverLog(LL_WARNING|LL_RAW,""%s\n"", client);
    sdsfree(client);
    serverLog(LL_WARNING|LL_RAW,""argc: '%d'\n"", cc->argc);
    for (j = 0; j < cc->argc; j++) {
        robj *decoded;
        decoded = getDecodedObject(cc->argv[j]);
        sds repr = sdscatrepr(sdsempty(),decoded->ptr, min(sdslen(decoded->ptr), 128));
        serverLog(LL_WARNING|LL_RAW,""argv[%d]: '%s'\n"", j, (char*)repr);
        if (!strcasecmp(decoded->ptr, ""auth"") || !strcasecmp(decoded->ptr, ""auth2"")) {
            sdsfree(repr);
            decrRefCount(decoded);
            break;
        }
        sdsfree(repr);
        decrRefCount(decoded);
    }
    /* Check if the first argument, usually a key, is found inside the
     * selected DB, and if so print info about the ...",1908.0,1947.0,1.0,4.0,40.0,65,14,44,11,0,29,7,8,2,23,,0,17,4,2,2,void
2335,115341,killMainThread,1,killMainThread,void killMainThread (void),debug.c,"static void killMainThread(void) {
    int err;
    if (pthread_self() != server.main_thread_id && pthread_cancel(server.main_thread_id) == 0) {
        if ((err = pthread_join(server.main_thread_id,NULL)) != 0) {
            serverLog(LL_WARNING, ""main thread can not be joined: %s"", strerror(err));
        } else {
            serverLog(LL_WARNING, ""main thread terminated"");
        }
    }
}",2019.0,2028.0,1.0,12.0,10.0,11,7,7,3,1,1,3,4,0,1,,0,0,2,1,1,void
2336,115412,killThreads,1,killThreads,void killThreads (void),debug.c,"void killThreads(void) {
    killMainThread();
    bioKillThreads();
    killIOThreads();
}",2034.0,2038.0,1.0,1.0,5.0,0,0,0,0,0,3,1,1,0,3,,0,0,2,1,1,void
2337,115425,dumpX86Calls,1,dumpX86Calls,"void dumpX86Calls (void*,size_t)",debug.c,"void dumpX86Calls(void *addr, size_t len) {
    size_t j;
    unsigned char *p = addr;
    Dl_info info;
    /* Hash table to best-effort avoid printing the same symbol
     * multiple times. */
    unsigned long ht[256] = {0};

    if (len < 5) return;
    for (j = 0; j < len-4; j++) {
        if (p[j] != 0xE8) continue; /* Not an E8 CALL opcode. */
        unsigned long target = (unsigned long)addr+j+5;
        uint32_t tmp;
        memcpy(&tmp, p+j+1, sizeof(tmp));
        target += tmp;
        if (dladdr((void*)target, &info) != 0 && info.dli_sname != NULL) {
            if (ht[target&0xff] != target) {
                printf(""Function at 0x%lx is %s\n"",target,info.dli_sname);
                ht[target&0xff] = target;
            }
            j += 4; /* Skip the 32 bit immediate. */
        }
    }
}",2060.0,2083.0,1.0,1.0,24.0,32,14,31,9,1,0,7,10,0,0,,0,0,4,2,2,void
2338,115534,dumpCodeAroundEIP,1,dumpCodeAroundEIP,void dumpCodeAroundEIP (void*),debug.c,"void dumpCodeAroundEIP(void *eip) {
    Dl_info info;
    if (dladdr(eip, &info) != 0) {
        serverLog(LL_WARNING|LL_RAW,
            ""\n------ DUMPING CODE AROUND EIP ------\n""
            ""Symbol: %s (base: %p)\n""
            ""Module: %s (base %p)\n""
            ""$ xxd -r -p /tmp/dump.hex /tmp/dump.bin\n""
            ""$ objdump --adjust-vma=%p -D -b binary -m i386:x86-64 /tmp/dump.bin\n""
            ""------\n"",
            info.dli_sname, info.dli_saddr, info.dli_fname, info.dli_fbase,
            info.dli_saddr);
        size_t len = (long)eip - (long)info.dli_saddr;
        unsigned long sz = sysconf(_SC_PAGESIZE);
        if (len < 1<<13) { /* we don't have functions over 8k (verified) */
            /* Find the address of the next page, which is our ""safety""
             * limit when dumping. Then try to dump just 128 bytes more
             * than EIP if there is room, or stop sooner. */
            void *base = (void *)info.dli_saddr;
            unsigned long next = ((u...",2085.0,2113.0,1.0,8.0,29.0,39,13,33,9,0,3,4,7,0,3,,0,0,2,1,1,void
2339,115677,sigsegvHandler,1,sigsegvHandler,"void sigsegvHandler (int,siginfo_t*,void*)",debug.c,"void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
    UNUSED(secret);
    UNUSED(info);

    bugReportStart();
    serverLog(LL_WARNING,
        ""Redis %s crashed by signal: %d, si_code: %d"", REDIS_VERSION, sig, info->si_code);
    if (sig == SIGSEGV || sig == SIGBUS) {
        serverLog(LL_WARNING,
        ""Accessing address: %p"", (void*)info->si_addr);
    }
    if (info->si_code == SI_USER && info->si_pid != -1) {
        serverLog(LL_WARNING, ""Killed by PID: %ld, UID: %d"", (long) info->si_pid, info->si_uid);
    }

#ifdef HAVE_BACKTRACE
    ucontext_t *uc = (ucontext_t*) secret;
    void *eip = getAndSetMcontextEip(uc, NULL);
    if (eip != NULL) {
        serverLog(LL_WARNING,
        ""Crashed running the instruction at: %p"", eip);
    }

    if (eip == info->si_addr) {
        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped
         * function pointer. In that case the call to backtrace will crash trying to access t...",2119.0,2172.0,1.0,4.0,54.0,26,10,20,7,0,6,3,3,0,6,,0,0,6,3,3,void
2340,115893,serverLogHexDump,1,serverLogHexDump,"void serverLogHexDump (int,char*,void*,size_t)",debug.c,"void serverLogHexDump(int level, char *descr, void *value, size_t len) {
    char buf[65], *b;
    unsigned char *v = value;
    char charset[] = ""0123456789abcdef"";

    serverLog(level,""%s (hexdump of %zu bytes):"", descr, len);
    b = buf;
    while(len) {
        b[0] = charset[(*v)>>4];
        b[1] = charset[(*v)&0xf];
        b[2] = '\0';
        b += 2;
        len--;
        v++;
        if (b-buf == 64 || len == 0) {
            serverLogRaw(level|LL_RAW,buf);
            b = buf;
        }
    }
    serverLogRaw(level|LL_RAW,""\n"");
}",2229.0,2249.0,1.0,4.0,21.0,30,15,30,9,1,3,3,4,0,3,,0,0,8,4,4,void
2341,116002,watchdogSignalHandler,1,watchdogSignalHandler,"void watchdogSignalHandler (int,siginfo_t*,void*)",debug.c,"void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
#ifdef HAVE_BACKTRACE
    ucontext_t *uc = (ucontext_t*) secret;
#else
    (void)secret;
#endif
    UNUSED(info);
    UNUSED(sig);

    serverLogFromHandler(LL_WARNING,""\n--- WATCHDOG TIMER EXPIRED ---"");
#ifdef HAVE_BACKTRACE
    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);
#else
    serverLogFromHandler(LL_WARNING,""Sorry: no support for backtrace()."");
#endif
    serverLogFromHandler(LL_WARNING,""--------\n"");
}",2254.0,2270.0,1.0,4.0,17.0,3,1,5,3,0,3,1,1,0,3,,0,0,6,3,3,void
2342,116039,watchdogScheduleSignal,1,watchdogScheduleSignal,void watchdogScheduleSignal (int),debug.c,"void watchdogScheduleSignal(int period) {
    struct itimerval it;

    /* Will stop the timer if period is 0. */
    it.it_value.tv_sec = period/1000;
    it.it_value.tv_usec = (period%1000)*1000;
    /* Don't automatically restart. */
    it.it_interval.tv_sec = 0;
    it.it_interval.tv_usec = 0;
    setitimer(ITIMER_REAL, &it, NULL);
}",2275.0,2285.0,1.0,1.0,11.0,16,6,9,4,2,0,1,1,0,0,,0,0,2,1,1,void
2343,116084,applyWatchdogPeriod,1,applyWatchdogPeriod,void applyWatchdogPeriod (void),debug.c,"void applyWatchdogPeriod(void) {
    struct sigaction act;

    /* Disable watchdog when period is 0 */
    if (server.watchdog_period == 0) {
        watchdogScheduleSignal(0); /* Stop the current timer. */

        /* Set the signal handler to SIG_IGN, this will also remove pending
         * signals from the queue. */
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        act.sa_handler = SIG_IGN;
        sigaction(SIGALRM, &act, NULL);
    } else {
        /* Setup the signal handler. */
        sigemptyset(&act.sa_mask);
        act.sa_flags = SA_SIGINFO;
        act.sa_sigaction = watchdogSignalHandler;
        sigaction(SIGALRM, &act, NULL);

        /* If the configured period is smaller than twice the timer period, it is
         * too short for the software watchdog to work reliably. Fix it now
         * if needed. */
        int min_period = (1000/server.hz)*2;
        if (server.watchdog_period < min_period) server.watchdog_period = min_period;
        wat...",2286.0,2313.0,1.0,1.0,28.0,9,4,8,5,2,1,2,2,0,1,,0,0,2,1,1,void
2344,116167,debugDelay,1,debugDelay,void debugDelay (int),debug.c,"void debugDelay(int usec) {
    /* Since even the shortest sleep results in context switch and system call,
     * the way we achieve short sleeps is by statistically sleeping less often. */
    if (usec < 0) usec = (rand() % -usec) == 0 ? 1: 0;
    if (usec) usleep(usec);
}",2317.0,2322.0,1.0,1.0,6.0,6,6,5,1,4,0,3,3,0,0,,0,0,2,1,1,void
2345,116215,activeDefragCycle,1,activeDefragCycle,void activeDefragCycle (void),defrag.c,"void activeDefragCycle(void) {
    /* Not implemented yet. */
}",1065.0,1067.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
2346,116220,activeDefragAlloc,1,activeDefragAlloc,void* activeDefragAlloc (void*),defrag.c,"void *activeDefragAlloc(void *ptr) {
    UNUSED(ptr);
    return NULL;
}",1069.0,1072.0,1.0,4.0,4.0,1,1,3,2,2,0,1,1,0,0,,0,0,2,1,1,void*
2347,116233,activeDefragStringOb,1,activeDefragStringOb,robj activeDefragStringOb (robj*),defrag.c,"robj *activeDefragStringOb(robj *ob) {
    UNUSED(ob);
    return NULL;
}",1074.0,1077.0,1.0,4.0,4.0,1,1,3,2,1,0,1,1,0,0,,0,0,2,1,1,robj
2348,116303,_dictExpandIfNeeded,1,_dictExpandIfNeeded,int _dictExpandIfNeeded (dict*),dict.c,"static int _dictExpandIfNeeded(dict *d)
{
    /* Incremental rehashing already in progress. Return. */
    if (dictIsRehashing(d)) return DICT_OK;

    /* If the hash table is empty expand it to the initial size. */
    if (DICTHT_SIZE(d->ht_size_exp[0]) == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the ""safe"" threshold, we resize doubling
     * the number of buckets. */
    if (!dictTypeExpandAllowed(d))
        return DICT_OK;
    if ((dict_can_resize == DICT_RESIZE_ENABLE &&
         d->ht_used[0] >= DICTHT_SIZE(d->ht_size_exp[0])) ||
        (dict_can_resize != DICT_RESIZE_FORBID &&
         d->ht_used[0] / DICTHT_SIZE(d->ht_size_exp[0]) > dict_force_resize_ratio))
    {
        return dictExpand(d, d->ht_used[0] + 1);
    }
    return DICT_OK;
}",1405.0,1427.0,1.0,8.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2349,116308,_dictNextExp,1,_dictNextExp,signed char _dictNextExp (long unsigned),dict.c,"static signed char _dictNextExp(unsigned long size)
{
    unsigned char e = DICT_HT_INITIAL_EXP;

    if (size >= LONG_MAX) return (8*sizeof(long)-1);
    while(1) {
        if (((unsigned long)1<<e) >= size)
            return e;
        e++;
    }
}",1431.0,1441.0,1.0,22.0,11.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,signed char
2350,116313,_dictInit,1,_dictInit,"int _dictInit (dict*,dictType*)",dict.c,"int _dictInit(dict *d, dictType *type)
{
    _dictReset(d, 0);
    _dictReset(d, 1);
    d->type = type;
    d->rehashidx = -1;
    d->pauserehash = 0;
    return DICT_OK;
}",198.0,206.0,1.0,11.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2351,116319,dictGetNext,1,dictGetNext,dictEntry* dictGetNext (dictEntry*),dict.c,"static dictEntry *dictGetNext(const dictEntry *de) {
    if (entryIsKey(de)) return NULL; /* there's no next */
    if (entryIsNoValue(de)) return decodeEntryNoValue(de)->next;
    return de->next;
}",831.0,835.0,1.0,1.0,5.0,0,0,0,0,12,0,1,1,0,0,,0,0,2,1,1,dictEntry
2352,116324,dictGetNextRef,1,dictGetNextRef,dictEntry** dictGetNextRef (dictEntry*),dict.c,"static dictEntry **dictGetNextRef(dictEntry *de) {
    if (entryIsKey(de)) return NULL;
    if (entryIsNoValue(de)) return &decodeEntryNoValue(de)->next;
    return &de->next;
}",839.0,843.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,dictEntry
2353,116329,dictSetNext,1,dictSetNext,"void dictSetNext (dictEntry*,dictEntry*)",dict.c,"static void dictSetNext(dictEntry *de, dictEntry *next) {
    assert(!entryIsKey(de));
    if (entryIsNoValue(de)) {
        dictEntryNoValue *entry = decodeEntryNoValue(de);
        entry->next = next;
    } else {
        de->next = next;
    }
}",845.0,853.0,1.0,4.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2354,116338,dictSetHashFunctionSeed,1,dictSetHashFunctionSeed,void dictSetHashFunctionSeed (uint8_t*),dict.c,"void dictSetHashFunctionSeed(uint8_t *seed) {
    memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));
}",95.0,97.0,1.0,1.0,3.0,1,1,3,2,0,2,1,1,0,0,,0,2,2,1,1,void
2355,116348,dictGetHashFunctionSeed,1,dictGetHashFunctionSeed,uint8_t dictGetHashFunctionSeed (void),dict.c,"uint8_t *dictGetHashFunctionSeed(void) {
    return dict_hash_function_seed;
}",99.0,101.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,2,1,1,uint8_t
2356,116355,siphash,1,siphash,"uint64_t siphash (uint8_t*,size_t,uint8_t*)",siphash.c,"uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {
#ifndef UNALIGNED_LE_CPU
    uint64_t hash;
    uint8_t *out = (uint8_t*) &hash;
#endif
    uint64_t v0 = 0x736f6d6570736575ULL;
    uint64_t v1 = 0x646f72616e646f6dULL;
    uint64_t v2 = 0x6c7967656e657261ULL;
    uint64_t v3 = 0x7465646279746573ULL;
    uint64_t k0 = U8TO64_LE(k);
    uint64_t k1 = U8TO64_LE(k + 8);
    uint64_t m;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
    const int left = inlen & 7;
    uint64_t b = ((uint64_t)inlen) << 56;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 8) {
        m = U8TO64_LE(in);
        v3 ^= m;

        SIPROUND;

        v0 ^= m;
    }

    switch (left) {
    case 7: b |= ((uint64_t)in[6]) << 48; /* fall-thru */
    case 6: b |= ((uint64_t)in[5]) << 40; /* fall-thru */
    case 5: b |= ((uint64_t)in[4]) << 32; /* fall-thru */
    case 4: b |= ((uint64_t)in[3]) << 24; /* fall-thru */
    case 3: b |...",127.0,184.0,1.0,18.0,58.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,uint64_t
2357,116362,siphash_nocase,1,siphash_nocase,"uint64_t siphash_nocase (uint8_t*,size_t,uint8_t*)",siphash.c,"uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)
{
#ifndef UNALIGNED_LE_CPU
    uint64_t hash;
    uint8_t *out = (uint8_t*) &hash;
#endif
    uint64_t v0 = 0x736f6d6570736575ULL;
    uint64_t v1 = 0x646f72616e646f6dULL;
    uint64_t v2 = 0x6c7967656e657261ULL;
    uint64_t v3 = 0x7465646279746573ULL;
    uint64_t k0 = U8TO64_LE(k);
    uint64_t k1 = U8TO64_LE(k + 8);
    uint64_t m;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
    const int left = inlen & 7;
    uint64_t b = ((uint64_t)inlen) << 56;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 8) {
        m = U8TO64_LE_NOCASE(in);
        v3 ^= m;

        SIPROUND;

        v0 ^= m;
    }

    switch (left) {
    case 7: b |= ((uint64_t)siptlw(in[6])) << 48; /* fall-thru */
    case 6: b |= ((uint64_t)siptlw(in[5])) << 40; /* fall-thru */
    case 5: b |= ((uint64_t)siptlw(in[4])) << 32; /* fall-thru */
    case 4: b |= ((uint64_t)siptlw(...",187.0,245.0,1.0,18.0,59.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,uint64_t
2358,116369,dictGenHashFunction,1,dictGenHashFunction,"uint64_t dictGenHashFunction (void*,size_t)",dict.c,"uint64_t dictGenHashFunction(const void *key, size_t len) {
    return siphash(key,len,dict_hash_function_seed);
}",109.0,111.0,1.0,1.0,3.0,0,0,3,3,5,2,1,1,0,1,,0,1,4,2,2,uint64_t
2359,116380,dictGenCaseHashFunction,1,dictGenCaseHashFunction,"uint64_t dictGenCaseHashFunction (unsigned char*,size_t)",dict.c,"uint64_t dictGenCaseHashFunction(const unsigned char *buf, size_t len) {
    return siphash_nocase(buf,len,dict_hash_function_seed);
}",113.0,115.0,1.0,1.0,3.0,0,0,3,3,3,2,1,1,0,1,,0,1,4,2,2,uint64_t
2360,116391,entryIsKey,1,entryIsKey,int entryIsKey (dictEntry*),dict.c,"static inline int entryIsKey(const dictEntry *de) {
    return (uintptr_t)(void *)de & 1;
}",129.0,131.0,1.0,1.0,3.0,3,2,1,1,14,0,1,1,0,0,,0,0,2,1,1,int
2361,116404,entryIsNormal,1,entryIsNormal,int entryIsNormal (dictEntry*),dict.c,"static inline int entryIsNormal(const dictEntry *de) {
    return ((uintptr_t)(void *)de & ENTRY_PTR_MASK) == ENTRY_PTR_NORMAL;
}",135.0,137.0,1.0,36.0,3.0,4,3,1,1,1,0,1,1,0,0,,0,0,2,1,1,int
2362,116423,entryIsNoValue,1,entryIsNoValue,int entryIsNoValue (dictEntry*),dict.c,"static inline int entryIsNoValue(const dictEntry *de) {
    return ((uintptr_t)(void *)de & ENTRY_PTR_MASK) == ENTRY_PTR_NO_VALUE;
}",141.0,143.0,1.0,36.0,3.0,4,3,1,1,1,0,1,1,0,0,,0,0,2,1,1,int
2363,116442,createEntryNoValue,1,createEntryNoValue,"dictEntry createEntryNoValue (void*,dictEntry*)",dict.c,"static inline dictEntry *createEntryNoValue(void *key, dictEntry *next) {
    dictEntryNoValue *entry = zmalloc(sizeof(*entry));
    entry->key = key;
    entry->next = next;
    return (dictEntry *)(void *)((uintptr_t)(void *)entry | ENTRY_PTR_NO_VALUE);
}",146.0,151.0,1.0,60.0,6.0,12,6,7,3,0,3,1,1,0,1,,0,3,4,2,2,dictEntry
2364,116479,encodeMaskedPtr,1,encodeMaskedPtr,"dictEntry encodeMaskedPtr (void*,unsigned int)",dict.c,"static inline dictEntry *encodeMaskedPtr(const void *ptr, unsigned int bits) {
    assert(((uintptr_t)ptr & ENTRY_PTR_MASK) == 0);
    return (dictEntry *)(void *)((uintptr_t)ptr | bits);
}",153.0,156.0,1.0,4.0,4.0,11,7,3,2,0,1,1,1,0,1,,0,0,4,2,2,dictEntry
2365,116515,decodeMaskedPtr,1,decodeMaskedPtr,void* decodeMaskedPtr (dictEntry*),dict.c,"static inline void *decodeMaskedPtr(const dictEntry *de) {
    assert(!entryIsKey(de));
    return (void *)((uintptr_t)(void *)de & ~ENTRY_PTR_MASK);
}",158.0,161.0,1.0,4.0,4.0,11,7,3,1,5,3,1,1,0,3,,0,0,2,1,1,void*
2366,116552,decodeEntryNoValue,1,decodeEntryNoValue,dictEntryNoValue decodeEntryNoValue (dictEntry*),dict.c,"static inline dictEntryNoValue *decodeEntryNoValue(const dictEntry *de) {
    return decodeMaskedPtr(de);
}",165.0,167.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,dictEntryNoValue
2367,116560,entryHasValue,1,entryHasValue,int entryHasValue (dictEntry*),dict.c,"static inline int entryHasValue(const dictEntry *de) {
    return entryIsNormal(de);
}",170.0,172.0,1.0,1.0,3.0,0,0,1,1,26,1,1,1,0,1,,0,0,2,1,1,int
2368,116568,_dictReset,1,_dictReset,"void _dictReset (dict*,int)",dict.c,"static void _dictReset(dict *d, int htidx)
{
    d->ht_table[htidx] = NULL;
    d->ht_size_exp[htidx] = -1;
    d->ht_used[htidx] = 0;
}",177.0,182.0,1.0,1.0,6.0,10,4,7,3,2,3,1,1,0,0,,0,3,4,2,2,void
2369,116596,dictCreate,1,dictCreate,dict dictCreate (dictType*),dict.c,"dict *dictCreate(dictType *type)
{
    size_t metasize = type->dictMetadataBytes ? type->dictMetadataBytes() : 0;
    dict *d = zmalloc(sizeof(*d) + metasize);
    if (metasize) {
        memset(dictMetadata(d), 0, metasize);
    }

    _dictInit(d,type);
    return d;
}",185.0,195.0,1.0,1.0,11.0,8,6,12,3,59,4,2,2,0,4,,0,2,2,1,1,dict
2370,116667,dictResize,1,dictResize,int dictResize (dict*),dict.c,"int dictResize(dict *d)
{
    unsigned long minimal;

    if (dict_can_resize != DICT_RESIZE_ENABLE || dictIsRehashing(d)) return DICT_ERR;
    minimal = d->ht_used[0];
    if (minimal < DICT_HT_INITIAL_SIZE)
        minimal = DICT_HT_INITIAL_SIZE;
    return dictExpand(d, minimal);
}",210.0,219.0,1.0,49.0,10.0,12,8,10,4,3,4,3,3,2,1,,0,3,2,1,1,int
2371,116719,_dictExpand,1,_dictExpand,"int _dictExpand (dict*,long unsigned,int*)",dict.c,"int _dictExpand(dict *d, unsigned long size, int* malloc_failed)
{
    if (malloc_failed) *malloc_failed = 0;

    /* the size is invalid if it is smaller than the number of
     * elements already inside the hash table */
    if (dictIsRehashing(d) || d->ht_used[0] > size)
        return DICT_ERR;

    /* the new hash table */
    dictEntry **new_ht_table;
    unsigned long new_ht_used;
    signed char new_ht_size_exp = _dictNextExp(size);

    /* Detect overflows */
    size_t newsize = 1ul<<new_ht_size_exp;
    if (newsize < size || newsize * sizeof(dictEntry*) < newsize)
        return DICT_ERR;

    /* Rehashing to the same table size is not useful. */
    if (new_ht_size_exp == d->ht_size_exp[0]) return DICT_ERR;

    /* Allocate the new hash table and initialize all pointers to NULL */
    if (malloc_failed) {
        new_ht_table = ztrycalloc(newsize*sizeof(dictEntry*));
        *malloc_failed = new_ht_table == NULL;
        if (*malloc_failed)
            return DICT_ERR;
 ...",224.0,272.0,1.0,8.0,49.0,51,13,41,9,2,13,8,9,4,2,,0,13,6,3,3,int
2372,116898,dictExpand,1,dictExpand,"int dictExpand (dict*,long unsigned)",dict.c,"int dictExpand(dict *d, unsigned long size) {
    return _dictExpand(d, size, NULL);
}",275.0,277.0,1.0,1.0,3.0,0,0,3,3,10,1,1,1,0,1,,0,0,4,2,2,int
2373,116909,dictTryExpand,1,dictTryExpand,"int dictTryExpand (dict*,long unsigned)",dict.c,"int dictTryExpand(dict *d, unsigned long size) {
    int malloc_failed;
    _dictExpand(d, size, &malloc_failed);
    return malloc_failed? DICT_ERR : DICT_OK;
}",280.0,284.0,1.0,26.0,5.0,2,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
2374,116930,dictRehash,1,dictRehash,"int dictRehash (dict*,int)",dict.c,"int dictRehash(dict *d, int n) {
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    unsigned long s0 = DICTHT_SIZE(d->ht_size_exp[0]);
    unsigned long s1 = DICTHT_SIZE(d->ht_size_exp[1]);
    if (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) return 0;
    if (dict_can_resize == DICT_RESIZE_AVOID && 
        ((s1 > s0 && s1 / s0 < dict_force_resize_ratio) ||
         (s1 < s0 && s0 / s1 < dict_force_resize_ratio)))
    {
        return 0;
    }

    while(n-- && d->ht_used[0] != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(DICTHT_SIZE(d->ht_size_exp[0]) > (unsigned long)d->rehashidx);
        while(d->ht_table[0][d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d->ht_table[0][d->rehashidx];
        /* Move all the keys in this bucket from ...",295.0,381.0,1.0,23.0,87.0,162,23,86,14,2,56,12,27,15,11,,0,49,4,2,2,int
2375,117464,timeInMilliseconds,1,timeInMilliseconds,long long timeInMilliseconds (void),dict.c,"long long timeInMilliseconds(void) {
    struct timeval tv;

    gettimeofday(&tv,NULL);
    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
}",383.0,388.0,1.0,1.0,6.0,7,6,4,2,2,0,1,1,0,0,,0,0,2,1,1,long long
2376,117488,dictRehashMilliseconds,1,dictRehashMilliseconds,"int dictRehashMilliseconds (dict*,int)",dict.c,"int dictRehashMilliseconds(dict *d, int ms) {
    if (d->pauserehash > 0) return 0;

    long long start = timeInMilliseconds();
    int rehashes = 0;

    while(dictRehash(d,100)) {
        rehashes += 100;
        if (timeInMilliseconds()-start > ms) break;
    }
    return rehashes;
}",393.0,404.0,1.0,1.0,12.0,7,5,8,4,2,4,5,5,3,3,,0,4,4,2,2,int
2377,117529,_dictRehashStep,1,_dictRehashStep,void _dictRehashStep (dict*),dict.c,"static void _dictRehashStep(dict *d) {
    if (d->pauserehash == 0) dictRehash(d,1);
}",414.0,416.0,1.0,1.0,3.0,2,2,2,1,6,2,2,2,1,1,,0,1,2,1,1,void
2378,117544,dictMetadata,1,dictMetadata,void* dictMetadata (dict*),dict.c,"void *dictMetadata(dict *d) {
    return &d->metadata;
}",419.0,421.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void*
2379,117554,dictAdd,1,dictAdd,"int dictAdd (dict*,void*,void*)",dict.c,"int dictAdd(dict *d, void *key, void *val)
{
    dictEntry *entry = dictAddRaw(d,key,NULL);

    if (!entry) return DICT_ERR;
    if (!d->type->no_value) dictSetVal(d, entry, val);
    return DICT_OK;
}",424.0,431.0,1.0,23.0,8.0,5,3,9,5,38,3,3,3,1,2,,0,2,6,3,3,int
2380,117592,dictAddRaw,1,dictAddRaw,"dictEntry dictAddRaw (dict*,void*,dictEntry**)",dict.c,"dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
{
    /* Get the position for the new key or NULL if the key already exists. */
    void *position = dictFindPositionForInsert(d, key, existing);
    if (!position) return NULL;

    /* Dup the key if necessary. */
    if (d->type->keyDup) key = d->type->keyDup(d, key);

    return dictInsertAtPosition(d, key, position);
}",451.0,461.0,1.0,1.0,11.0,7,3,14,5,11,5,3,3,1,3,,0,4,6,3,3,dictEntry
2381,117634,dictInsertAtPosition,1,dictInsertAtPosition,"dictEntry dictInsertAtPosition (dict*,void*,void*)",dict.c,"dictEntry *dictInsertAtPosition(dict *d, void *key, void *position) {
    dictEntry **bucket = position; /* It's a bucket, but the API hides that. */
    dictEntry *entry;
    /* If rehashing is ongoing, we insert in table 1, otherwise in table 0.
     * Assert that the provided bucket is the right table. */
    int htidx = dictIsRehashing(d) ? 1 : 0;
    assert(bucket >= &d->ht_table[htidx][0] &&
           bucket <= &d->ht_table[htidx][DICTHT_SIZE_MASK(d->ht_size_exp[htidx])]);
    size_t metasize = dictEntryMetadataSize(d);
    if (d->type->no_value) {
        assert(!metasize); /* Entry metadata + no value not supported. */
        if (d->type->keys_are_odd && !*bucket) {
            /* We can store the key directly in the destination bucket without the
             * allocated entry.
             *
             * TODO: Add a flag 'keys_are_even' and if set, we can use this
             * optimization for these dicts too. We can set the LSB bit when
             * stored as a di...",467.0,509.0,1.0,16.0,43.0,65,19,36,7,1,16,3,4,2,5,,0,11,6,3,3,dictEntry
2382,117868,dictReplace,1,dictReplace,"int dictReplace (dict*,void*,void*)",dict.c,"int dictReplace(dict *d, void *key, void *val)
{
    dictEntry *entry, *existing;

    /* Try to add the element. If the key
     * does not exists dictAdd will succeed. */
    entry = dictAddRaw(d,key,&existing);
    if (entry) {
        dictSetVal(d, entry, val);
        return 1;
    }

    /* Set the new value and free the old one. Note that it is important
     * to do that in this order, as the value may just be exactly the same
     * as the previous one. In this context, think to reference counting,
     * you want to increment (set), and then decrement (free), and not the
     * reverse. */
    void *oldval = dictGetVal(existing);
    dictSetVal(d, existing, val);
    if (d->type->valDestructor)
        d->type->valDestructor(d, oldval);
    return 0;
}",516.0,538.0,1.0,1.0,23.0,7,3,17,6,1,7,3,3,1,5,,0,4,6,3,3,int
2383,117919,dictAddOrFind,1,dictAddOrFind,"dictEntry dictAddOrFind (dict*,void*)",dict.c,"dictEntry *dictAddOrFind(dict *d, void *key) {
    dictEntry *entry, *existing;
    entry = dictAddRaw(d,key,&existing);
    return entry ? entry : existing;
}",547.0,551.0,1.0,1.0,5.0,3,3,7,4,2,1,1,1,0,1,,0,1,4,2,2,dictEntry
2384,117939,dictGenericDelete,1,dictGenericDelete,"dictEntry dictGenericDelete (dict*,void*,int)",dict.c,"static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
    uint64_t h, idx;
    dictEntry *he, *prevHe;
    int table;

    /* dict is empty */
    if (dictSize(d) == 0) return NULL;

    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);

    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        prevHe = NULL;
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key)) {
                /* Unlink the element from the list */
                if (prevHe)
                    dictSetNext(prevHe, dictGetNext(he));
                else
                    d->ht_table[table][idx] = dictGetNext(he);
                if (!nofree) {
                    dictFreeUnlinkedEntry(d, he);
                }
                d->ht_used[table]--;
                return he;
            }
            prevHe...",556.0,591.0,1.0,8.0,36.0,57,16,61,10,2,19,10,19,6,6,,0,16,6,3,3,dictEntry
2385,118155,dictDelete,1,dictDelete,"int dictDelete (dict*,void*)",dict.c,"int dictDelete(dict *ht, const void *key) {
    return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
}",595.0,597.0,1.0,41.0,3.0,1,1,2,2,32,1,1,1,0,1,,0,0,4,2,2,int
2386,118173,dictUnlink,1,dictUnlink,"dictEntry dictUnlink (dict*,void*)",dict.c,"dictEntry *dictUnlink(dict *d, const void *key) {
    return dictGenericDelete(d,key,1);
}",620.0,622.0,1.0,1.0,3.0,0,0,2,2,5,1,1,1,0,1,,0,0,4,2,2,dictEntry
2387,118184,dictFreeUnlinkedEntry,1,dictFreeUnlinkedEntry,"void dictFreeUnlinkedEntry (dict*,dictEntry*)",dict.c,"void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {
    if (he == NULL) return;
    dictFreeKey(d, he);
    dictFreeVal(d, he);
    if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
}",626.0,631.0,1.0,4.0,6.0,10,3,16,3,6,9,3,3,1,5,,0,6,4,2,2,void
2388,118247,_dictClear,1,_dictClear,"int _dictClear (dict*,int,void)",dict.c,"int _dictClear(dict *d, int htidx, void(callback)(dict*)) {
    unsigned long i;

    /* Free all the elements */
    for (i = 0; i < DICTHT_SIZE(d->ht_size_exp[htidx]) && d->ht_used[htidx] > 0; i++) {
        dictEntry *he, *nextHe;

        if (callback && (i & 65535) == 0) callback(d);

        if ((he = d->ht_table[htidx][i]) == NULL) continue;
        while(he) {
            nextHe = dictGetNext(he);
            dictFreeKey(d, he);
            dictFreeVal(d, he);
            if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
            d->ht_used[htidx]--;
            he = nextHe;
        }
    }
    /* Free the table and the allocated cache structure */
    zfree(d->ht_table[htidx]);
    /* Re-initialize the table */
    _dictReset(d, htidx);
    return DICT_OK; /* never fails */
}",634.0,658.0,1.0,20.0,25.0,41,14,43,7,4,19,7,11,6,8,,0,14,6,3,3,int
2389,118406,dictRelease,1,dictRelease,void dictRelease (dict*),dict.c,"void dictRelease(dict *d)
{
    _dictClear(d,0,NULL);
    _dictClear(d,1,NULL);
    zfree(d);
}",661.0,666.0,1.0,1.0,6.0,0,0,5,2,34,3,1,1,0,3,,0,0,2,1,1,void
2390,118421,dictFind,1,dictFind,"dictEntry dictFind (dict*,void*)",dict.c,"dictEntry *dictFind(dict *d, const void *key)
{
    dictEntry *he;
    uint64_t h, idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);
    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key))
                return he;
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",668.0,688.0,1.0,8.0,21.0,51,15,50,8,65,15,7,11,6,3,,0,14,4,2,2,dictEntry
2391,118598,dictFetchValue,1,dictFetchValue,"void* dictFetchValue (dict*,void*)",dict.c,"void *dictFetchValue(dict *d, const void *key) {
    dictEntry *he;

    he = dictFind(d,key);
    return he ? dictGetVal(he) : NULL;
}",690.0,695.0,1.0,1.0,6.0,2,2,6,4,28,2,1,1,0,2,,0,1,4,2,2,void*
2392,118616,dictTwoPhaseUnlinkFind,1,dictTwoPhaseUnlinkFind,"dictEntry dictTwoPhaseUnlinkFind (dict*,void*,dictEntry***,int*)",dict.c,"dictEntry *dictTwoPhaseUnlinkFind(dict *d, const void *key, dictEntry ***plink, int *table_index) {
    uint64_t h, idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);

    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        dictEntry **ref = &d->ht_table[table][idx];
        while (ref && *ref) {
            void *de_key = dictGetKey(*ref);
            if (key == de_key || dictCompareKeys(d, key, de_key)) {
                *table_index = table;
                *plink = ref;
                dictPauseRehashing(d);
                return *ref;
            }
            ref = dictGetNextRef(*ref);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",713.0,736.0,1.0,8.0,24.0,63,19,57,10,1,16,7,11,6,3,,0,15,8,4,4,dictEntry
2393,118817,dictTwoPhaseUnlinkFree,1,dictTwoPhaseUnlinkFree,"void dictTwoPhaseUnlinkFree (dict*,dictEntry*,dictEntry**,int)",dict.c,"void dictTwoPhaseUnlinkFree(dict *d, dictEntry *he, dictEntry **plink, int table_index) {
    if (he == NULL) return;
    d->ht_used[table_index]--;
    *plink = dictGetNext(he);
    dictFreeKey(d, he);
    dictFreeVal(d, he);
    if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
    dictResumeRehashing(d);
}",738.0,746.0,1.0,4.0,9.0,17,7,22,5,1,12,3,3,1,6,,0,9,8,4,4,void
2394,118900,dictSetKey,1,dictSetKey,"void dictSetKey (dict*,dictEntry*,void*)",dict.c,"void dictSetKey(dict *d, dictEntry* de, void *key) {
    assert(!d->type->no_value);
    if (d->type->keyDup)
        de->key = d->type->keyDup(d, key);
    else
        de->key = key;
}",748.0,754.0,1.0,4.0,7.0,16,7,7,3,2,7,2,2,1,2,,0,6,6,3,3,void
2395,118958,dictSetVal,1,dictSetVal,"void dictSetVal (dict*,dictEntry*,void*)",dict.c,"void dictSetVal(dict *d, dictEntry *de, void *val) {
    assert(entryHasValue(de));
    de->v.val = d->type->valDup ? d->type->valDup(d, val) : val;
}",756.0,759.0,1.0,4.0,4.0,12,7,8,3,10,7,1,1,0,4,,0,4,6,3,3,void
2396,119003,dictSetSignedIntegerVal,1,dictSetSignedIntegerVal,"void dictSetSignedIntegerVal (dictEntry*,int64_t)",dict.c,"void dictSetSignedIntegerVal(dictEntry *de, int64_t val) {
    assert(entryHasValue(de));
    de->v.s64 = val;
}",761.0,764.0,1.0,4.0,4.0,7,7,4,2,1,4,1,1,0,3,,0,1,4,2,2,void
2397,119033,dictSetUnsignedIntegerVal,1,dictSetUnsignedIntegerVal,"void dictSetUnsignedIntegerVal (dictEntry*,uint64_t)",dict.c,"void dictSetUnsignedIntegerVal(dictEntry *de, uint64_t val) {
    assert(entryHasValue(de));
    de->v.u64 = val;
}",766.0,769.0,1.0,4.0,4.0,7,7,4,2,6,4,1,1,0,3,,0,1,4,2,2,void
2398,119063,dictSetDoubleVal,1,dictSetDoubleVal,"void dictSetDoubleVal (dictEntry*,double)",dict.c,"void dictSetDoubleVal(dictEntry *de, double val) {
    assert(entryHasValue(de));
    de->v.d = val;
}",771.0,774.0,1.0,4.0,4.0,7,7,4,2,1,4,1,1,0,3,,0,1,4,2,2,void
2399,119093,dictIncrSignedIntegerVal,1,dictIncrSignedIntegerVal,"int64_t dictIncrSignedIntegerVal (dictEntry*,int64_t)",dict.c,"int64_t dictIncrSignedIntegerVal(dictEntry *de, int64_t val) {
    assert(entryHasValue(de));
    return de->v.s64 += val;
}",776.0,779.0,1.0,4.0,4.0,7,7,4,2,0,4,1,1,0,3,,0,1,4,2,2,int64_t
2400,119124,dictIncrUnsignedIntegerVal,1,dictIncrUnsignedIntegerVal,"uint64_t dictIncrUnsignedIntegerVal (dictEntry*,uint64_t)",dict.c,"uint64_t dictIncrUnsignedIntegerVal(dictEntry *de, uint64_t val) {
    assert(entryHasValue(de));
    return de->v.u64 += val;
}",781.0,784.0,1.0,4.0,4.0,7,7,4,2,0,4,1,1,0,3,,0,1,4,2,2,uint64_t
2401,119155,dictIncrDoubleVal,1,dictIncrDoubleVal,"double dictIncrDoubleVal (dictEntry*,double)",dict.c,"double dictIncrDoubleVal(dictEntry *de, double val) {
    assert(entryHasValue(de));
    return de->v.d += val;
}",786.0,789.0,1.0,4.0,4.0,7,7,4,2,0,4,1,1,0,3,,0,1,4,2,2,double
2402,119186,dictEntryMetadata,1,dictEntryMetadata,void* dictEntryMetadata (dictEntry*),dict.c,"void *dictEntryMetadata(dictEntry *de) {
    assert(entryHasValue(de));
    return &de->metadata;
}",792.0,795.0,1.0,4.0,4.0,6,6,3,1,12,4,1,1,0,3,,0,1,2,1,1,void*
2403,119213,dictGetKey,1,dictGetKey,void* dictGetKey (dictEntry*),dict.c,"void *dictGetKey(const dictEntry *de) {
    if (entryIsKey(de)) return (void*)de;
    if (entryIsNoValue(de)) return decodeEntryNoValue(de)->key;
    return de->key;
}",797.0,801.0,1.0,1.0,5.0,3,2,5,1,73,4,3,3,2,3,,0,3,2,1,1,void*
2404,119239,dictGetVal,1,dictGetVal,void* dictGetVal (dictEntry*),dict.c,"void *dictGetVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.val;
}",803.0,806.0,1.0,4.0,4.0,6,6,3,1,132,4,1,1,0,3,,0,1,2,1,1,void*
2405,119267,dictGetSignedIntegerVal,1,dictGetSignedIntegerVal,int64_t dictGetSignedIntegerVal (dictEntry*),dict.c,"int64_t dictGetSignedIntegerVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.s64;
}",808.0,811.0,1.0,4.0,4.0,6,6,3,1,3,4,1,1,0,3,,0,1,2,1,1,int64_t
2406,119295,dictGetUnsignedIntegerVal,1,dictGetUnsignedIntegerVal,uint64_t dictGetUnsignedIntegerVal (dictEntry*),dict.c,"uint64_t dictGetUnsignedIntegerVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.u64;
}",813.0,816.0,1.0,4.0,4.0,6,6,3,1,6,4,1,1,0,3,,0,1,2,1,1,uint64_t
2407,119323,dictGetDoubleVal,1,dictGetDoubleVal,double dictGetDoubleVal (dictEntry*),dict.c,"double dictGetDoubleVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.d;
}",818.0,821.0,1.0,4.0,4.0,6,6,3,1,1,4,1,1,0,3,,0,1,2,1,1,double
2408,119351,dictGetDoubleValPtr,1,dictGetDoubleValPtr,double* dictGetDoubleValPtr (dictEntry*),dict.c,"double *dictGetDoubleValPtr(dictEntry *de) {
    assert(entryHasValue(de));
    return &de->v.d;
}",824.0,827.0,1.0,4.0,4.0,7,7,3,1,0,4,1,1,0,3,,0,1,2,1,1,double*
2409,119476,dictMemUsage,1,dictMemUsage,size_t dictMemUsage (dict*),dict.c,"size_t dictMemUsage(const dict *d) {
    return dictSize(d) * sizeof(dictEntry) +
        dictSlots(d) * sizeof(dictEntry*);
}",857.0,860.0,1.0,11.0,4.0,29,10,10,2,8,6,1,1,0,0,,0,6,2,1,1,size_t
2410,119553,dictFingerprint,1,dictFingerprint,unsigned long long dictFingerprint (dict*),dict.c,"unsigned long long dictFingerprint(dict *d) {
    unsigned long long integers[6], hash = 0;
    int j;

    integers[0] = (long) d->ht_table[0];
    integers[1] = d->ht_size_exp[0];
    integers[2] = d->ht_used[0];
    integers[3] = (long) d->ht_table[1];
    integers[4] = d->ht_size_exp[1];
    integers[5] = d->ht_used[1];

    /* We hash N integers by summing every successive integer with the integer
     * hashing of the previous sum. Basically:
     *
     * Result = hash(hash(hash(int1)+int2)+int3) ...
     *
     * This way the same set of integers in a different order will (likely) hash
     * to a different number. */
    for (j = 0; j < 6; j++) {
        hash += integers[j];
        /* For the hashing step we use Tomas Wang's 64 bit integer hash. */
        hash = (~hash) + (hash << 21); // hash = (hash << 21) - hash - 1;
        hash = hash ^ (hash >> 24);
        hash = (hash + (hash << 3)) + (hash << 8); // hash * 265
        hash = hash ^ (hash >> 14);
        hash = (h...",872.0,902.0,1.0,1.0,31.0,57,11,42,4,0,6,2,2,0,0,,0,6,2,1,1,unsigned long long
2411,119698,dictInitIterator,1,dictInitIterator,"void dictInitIterator (dictIterator*,dict*)",dict.c,"void dictInitIterator(dictIterator *iter, dict *d)
{
    iter->d = d;
    iter->table = 0;
    iter->index = -1;
    iter->safe = 0;
    iter->entry = NULL;
    iter->nextEntry = NULL;
}",904.0,912.0,1.0,1.0,9.0,13,3,9,3,2,6,1,1,0,0,,0,6,4,2,2,void
2412,119735,dictInitSafeIterator,1,dictInitSafeIterator,"void dictInitSafeIterator (dictIterator*,dict*)",dict.c,"void dictInitSafeIterator(dictIterator *iter, dict *d)
{
    dictInitIterator(iter, d);
    iter->safe = 1;
}",914.0,918.0,1.0,1.0,5.0,2,2,3,2,0,2,1,1,0,1,,0,1,4,2,2,void
2413,119749,dictResetIterator,1,dictResetIterator,void dictResetIterator (dictIterator*),dict.c,"void dictResetIterator(dictIterator *iter)
{
    if (!(iter->index == -1 && iter->table == 0)) {
        if (iter->safe)
            dictResumeRehashing(iter->d);
        else
            assert(iter->fingerprint == dictFingerprint(iter->d));
    }
}",920.0,928.0,1.0,12.0,9.0,12,6,5,1,1,5,3,4,3,0,,0,5,2,1,1,void
2414,119808,dictGetIterator,1,dictGetIterator,dictIterator dictGetIterator (dict*),dict.c,"dictIterator *dictGetIterator(dict *d)
{
    dictIterator *iter = zmalloc(sizeof(*iter));
    dictInitIterator(iter, d);
    return iter;
}",930.0,935.0,1.0,1.0,6.0,3,3,5,2,77,2,1,1,0,2,,0,1,2,1,1,dictIterator
2415,119825,dictGetSafeIterator,1,dictGetSafeIterator,dictIterator dictGetSafeIterator (dict*),dict.c,"dictIterator *dictGetSafeIterator(dict *d) {
    dictIterator *i = dictGetIterator(d);

    i->safe = 1;
    return i;
}",937.0,942.0,1.0,1.0,6.0,3,2,4,2,36,2,1,1,0,1,,0,2,2,1,1,dictIterator
2416,119842,dictNext,1,dictNext,dictEntry dictNext (dictIterator*),dict.c,"dictEntry *dictNext(dictIterator *iter)
{
    while (1) {
        if (iter->entry == NULL) {
            if (iter->index == -1 && iter->table == 0) {
                if (iter->safe)
                    dictPauseRehashing(iter->d);
                else
                    iter->fingerprint = dictFingerprint(iter->d);
            }
            iter->index++;
            if (iter->index >= (long) DICTHT_SIZE(iter->d->ht_size_exp[iter->table])) {
                if (dictIsRehashing(iter->d) && iter->table == 0) {
                    iter->table++;
                    iter->index = 0;
                } else {
                    break;
                }
            }
            iter->entry = iter->d->ht_table[iter->table][iter->index];
        } else {
            iter->entry = iter->nextEntry;
        }
        if (iter->entry) {
            /* We need to save the 'next' here, the iterator user
             * may delete the entry we are returning. */
            iter->nextEntry = dictG...",944.0,975.0,1.0,20.0,32.0,60,12,29,2,112,28,8,20,15,1,,0,28,2,1,1,dictEntry
2417,120025,dictReleaseIterator,1,dictReleaseIterator,void dictReleaseIterator (dictIterator*),dict.c,"void dictReleaseIterator(dictIterator *iter)
{
    dictResetIterator(iter);
    zfree(iter);
}",977.0,981.0,1.0,1.0,5.0,0,0,2,1,124,2,1,1,0,2,,0,0,2,1,1,void
2418,120034,dictGetRandomKey,1,dictGetRandomKey,dictEntry dictGetRandomKey (dict*),dict.c,"dictEntry *dictGetRandomKey(dict *d)
{
    dictEntry *he, *orighe;
    unsigned long h;
    int listlen, listele;

    if (dictSize(d) == 0) return NULL;
    if (dictIsRehashing(d)) _dictRehashStep(d);
    if (dictIsRehashing(d)) {
        unsigned long s0 = DICTHT_SIZE(d->ht_size_exp[0]);
        do {
            /* We are sure there are no elements in indexes from 0
             * to rehashidx-1 */
            h = d->rehashidx + (randomULong() % (dictSlots(d) - d->rehashidx));
            he = (h >= s0) ? d->ht_table[1][h - s0] : d->ht_table[0][h];
        } while(he == NULL);
    } else {
        unsigned long m = DICTHT_SIZE_MASK(d->ht_size_exp[0]);
        do {
            h = randomULong() & m;
            he = d->ht_table[0][h];
        } while(he == NULL);
    }

    /* Now we found a non empty bucket, but it is a linked
     * list and we need to get a random element from the list.
     * The only sane way to do so is counting the elements and
     * select a random index. ...",985.0,1023.0,1.0,8.0,39.0,69,15,44,8,4,18,7,8,4,3,,0,17,2,1,1,dictEntry
2419,120300,dictGetSomeKeys,1,dictGetSomeKeys,"unsigned int dictGetSomeKeys (dict*,dictEntry**,unsigned int)",dict.c,"unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {
    unsigned long j; /* internal hash table id, 0 or 1. */
    unsigned long tables; /* 1 or 2 tables? */
    unsigned long stored = 0, maxsizemask;
    unsigned long maxsteps;

    if (dictSize(d) < count) count = dictSize(d);
    maxsteps = count*10;

    /* Try to do a rehashing work proportional to 'count'. */
    for (j = 0; j < count; j++) {
        if (dictIsRehashing(d))
            _dictRehashStep(d);
        else
            break;
    }

    tables = dictIsRehashing(d) ? 2 : 1;
    maxsizemask = DICTHT_SIZE_MASK(d->ht_size_exp[0]);
    if (tables > 1 && maxsizemask < DICTHT_SIZE_MASK(d->ht_size_exp[1]))
        maxsizemask = DICTHT_SIZE_MASK(d->ht_size_exp[1]);

    /* Pick a random point inside the larger table. */
    unsigned long i = randomULong() & maxsizemask;
    unsigned long emptylen = 0; /* Continuous empty entries so far. */
    while(stored < count && maxsteps--) {
        for (j = 0;...",1047.0,1125.0,1.0,8.0,79.0,141,19,82,11,2,30,13,26,14,3,,0,29,6,3,3,unsigned int
2420,120747,dictDefragBucket,1,dictDefragBucket,"void dictDefragBucket (dict*,dictEntry**,dictDefragFunctions*)",dict.c,"static void dictDefragBucket(dict *d, dictEntry **bucketref, dictDefragFunctions *defragfns) {
    dictDefragAllocFunction *defragalloc = defragfns->defragAlloc;
    dictDefragAllocFunction *defragkey = defragfns->defragKey;
    dictDefragAllocFunction *defragval = defragfns->defragVal;
    while (bucketref && *bucketref) {
        dictEntry *de = *bucketref, *newde = NULL;
        void *newkey = defragkey ? defragkey(dictGetKey(de)) : NULL;
        void *newval = defragval ? defragval(dictGetVal(de)) : NULL;
        if (entryIsKey(de)) {
            if (newkey) *bucketref = newkey;
            assert(entryIsKey(*bucketref));
        } else if (entryIsNoValue(de)) {
            dictEntryNoValue *entry = decodeEntryNoValue(de), *newentry;
            if ((newentry = defragalloc(entry))) {
                newde = encodeMaskedPtr(newentry, ENTRY_PTR_NO_VALUE);
                entry = newentry;
            }
            if (newkey) entry->key = newkey;
        } else {
            asser...",1130.0,1162.0,1.0,12.0,33.0,31,8,35,11,1,13,6,12,2,8,,0,9,6,3,3,void
2421,120945,dictGetFairRandomKey,1,dictGetFairRandomKey,dictEntry dictGetFairRandomKey (dict*),dict.c,"dictEntry *dictGetFairRandomKey(dict *d) {
    dictEntry *entries[GETFAIR_NUM_ENTRIES];
    unsigned int count = dictGetSomeKeys(d,entries,GETFAIR_NUM_ENTRIES);
    /* Note that dictGetSomeKeys() may return zero elements in an unlucky
     * run() even if there are actually elements inside the hash table. So
     * when we get zero, we call the true dictGetRandomKey() that will always
     * yield the element if the hash table has at least one. */
    if (count == 0) return dictGetRandomKey(d);
    unsigned int idx = rand() % count;
    return entries[idx];
}",1176.0,1186.0,1.0,23.0,11.0,5,4,9,4,8,2,2,2,0,2,,0,1,2,1,1,dictEntry
2422,120978,rev,1,rev,unsigned long rev (long unsigned),dict.c,"static unsigned long rev(unsigned long v) {
    unsigned long s = CHAR_BIT * sizeof(v); // bit size; must be power of 2
    unsigned long mask = ~0UL;
    while ((s >>= 1) > 0) {
        mask ^= (mask << s);
        v = ((v >> s) & mask) | ((v << s) & ~mask);
    }
    return v;
}",1190.0,1198.0,1.0,1.0,9.0,14,9,16,4,2,0,2,2,0,0,,0,0,2,1,1,unsigned long
2423,121023,dictScan,1,dictScan,"unsigned long dictScan (dict*,long unsigned,dictScanFunction*,void*)",dict.c,"unsigned long dictScan(dict *d,
                       unsigned long v,
                       dictScanFunction *fn,
                       void *privdata)
{
    return dictScanDefrag(d, v, fn, NULL, privdata);
}",1284.0,1290.0,1.0,1.0,7.0,0,0,5,5,4,1,1,1,0,1,,0,0,8,4,4,unsigned long
2424,121038,dictScanDefrag,1,dictScanDefrag,"unsigned long dictScanDefrag (dict*,long unsigned,dictScanFunction*,dictDefragFunctions*,void*)",dict.c,"unsigned long dictScanDefrag(dict *d,
                             unsigned long v,
                             dictScanFunction *fn,
                             dictDefragFunctions *defragfns,
                             void *privdata)
{
    int htidx0, htidx1;
    const dictEntry *de, *next;
    unsigned long m0, m1;

    if (dictSize(d) == 0) return 0;

    /* This is needed in case the scan callback tries to do dictFind or alike. */
    dictPauseRehashing(d);

    if (!dictIsRehashing(d)) {
        htidx0 = 0;
        m0 = DICTHT_SIZE_MASK(d->ht_size_exp[htidx0]);

        /* Emit entries at cursor */
        if (defragfns) {
            dictDefragBucket(d, &d->ht_table[htidx0][v & m0], defragfns);
        }
        de = d->ht_table[htidx0][v & m0];
        while (de) {
            next = dictGetNext(de);
            fn(privdata, de);
            de = next;
        }

        /* Set unmasked bits so incrementing the reversed cursor
         * operates on the masked bits */
 ...",1300.0,1390.0,1.0,8.0,91.0,49,17,46,8,1,15,5,7,3,4,,0,14,10,5,5,unsigned long
2425,121448,dictTypeExpandAllowed,1,dictTypeExpandAllowed,int dictTypeExpandAllowed (dict*),dict.c,"static int dictTypeExpandAllowed(dict *d) {
    if (d->type->expandAllowed == NULL) return 1;
    return d->type->expandAllowed(
                    DICTHT_SIZE(_dictNextExp(d->ht_used[0] + 1)) * sizeof(dictEntry*),
                    (double)d->ht_used[0] / DICTHT_SIZE(d->ht_size_exp[0]));
}",1397.0,1402.0,1.0,20.0,6.0,33,11,10,3,0,11,2,2,1,3,,0,10,2,1,1,int
2426,121732,dictFindPositionForInsert,1,dictFindPositionForInsert,"void* dictFindPositionForInsert (dict*,void*,dictEntry**)",dict.c,"void *dictFindPositionForInsert(dict *d, const void *key, dictEntry **existing) {
    unsigned long idx, table;
    dictEntry *he;
    uint64_t hash = dictHashKey(d, key);
    if (existing) *existing = NULL;
    if (dictIsRehashing(d)) _dictRehashStep(d);

    /* Expand the hash table if needed */
    if (_dictExpandIfNeeded(d) == DICT_ERR)
        return NULL;
    for (table = 0; table <= 1; table++) {
        idx = hash & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        /* Search if this slot does not already contain the given key */
        he = d->ht_table[table][idx];
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key)) {
                if (existing) *existing = he;
                return NULL;
            }
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) break;
    }

    /* If we are in the process of rehashing the hash table, the bucket is
     * always returned in the c...",1447.0,1476.0,1.0,20.0,30.0,59,16,58,10,1,16,10,16,5,4,,0,15,6,3,3,void*
2427,121935,dictEmpty,1,dictEmpty,"void dictEmpty (dict*,void)",dict.c,"void dictEmpty(dict *d, void(callback)(dict*)) {
    _dictClear(d,0,callback);
    _dictClear(d,1,callback);
    d->rehashidx = -1;
    d->pauserehash = 0;
}",1478.0,1483.0,1.0,1.0,6.0,5,3,6,2,4,4,1,1,0,2,,0,2,4,2,2,void
2428,121960,dictSetResizeEnabled,1,dictSetResizeEnabled,void dictSetResizeEnabled (dictResizeEnable),dict.c,"void dictSetResizeEnabled(dictResizeEnable enable) {
    dict_can_resize = enable;
}",1485.0,1487.0,1.0,1.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
2429,121968,dictGetHash,1,dictGetHash,"uint64_t dictGetHash (dict*,void*)",dict.c,"uint64_t dictGetHash(dict *d, const void *key) {
    return dictHashKey(d, key);
}",1489.0,1491.0,1.0,11.0,3.0,2,1,4,2,0,1,1,1,0,0,,0,1,4,2,2,uint64_t
2430,121986,dictFindEntryByPtrAndHash,1,dictFindEntryByPtrAndHash,"dictEntry dictFindEntryByPtrAndHash (dict*,void*,uint64_t)",dict.c,"dictEntry *dictFindEntryByPtrAndHash(dict *d, const void *oldptr, uint64_t hash) {
    dictEntry *he;
    unsigned long idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    for (table = 0; table <= 1; table++) {
        idx = hash & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        while(he) {
            if (oldptr == dictGetKey(he))
                return he;
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",1498.0,1514.0,1.0,8.0,17.0,37,14,30,7,0,10,6,10,4,2,,0,10,6,3,3,dictEntry
2431,122109,_dictGetStatsHt,1,_dictGetStatsHt,"size_t _dictGetStatsHt (char*,size_t,dict*,int,int)",dict.c,"size_t _dictGetStatsHt(char *buf, size_t bufsize, dict *d, int htidx, int full) {
    unsigned long i, slots = 0, chainlen, maxchainlen = 0;
    unsigned long totchainlen = 0;
    unsigned long clvector[DICT_STATS_VECTLEN];
    size_t l = 0;

    if (d->ht_used[htidx] == 0) {
        return snprintf(buf,bufsize,
            ""Hash table %d stats (%s):\n""
            ""No stats available for empty dictionaries\n"",
            htidx, (htidx == 0) ? ""main hash table"" : ""rehashing target"");
    }

    if (!full) {
        l += snprintf(buf+l,bufsize-l,
            ""Hash table %d stats (%s):\n""
            "" table size: %lu\n""
            "" number of elements: %lu\n"",
            htidx, (htidx == 0) ? ""main hash table"" : ""rehashing target"",
            DICTHT_SIZE(d->ht_size_exp[htidx]), d->ht_used[htidx]);

        /* Make sure there is a NULL term at the end. */
        buf[bufsize-1] = '\0';
        /* Unlike snprintf(), return the number of characters actually written. */
        retur...",1519.0,1594.0,1.0,27.0,76.0,120,18,110,14,2,19,14,16,5,1,,0,19,10,5,5,size_t
2432,122490,dictGetStats,1,dictGetStats,"void dictGetStats (char*,size_t,dict*,int)",dict.c,"void dictGetStats(char *buf, size_t bufsize, dict *d, int full) {
    size_t l;
    char *orig_buf = buf;
    size_t orig_bufsize = bufsize;

    l = _dictGetStatsHt(buf,bufsize,d,0,full);
    if (dictIsRehashing(d) && bufsize > l) {
        buf += l;
        bufsize -= l;
        _dictGetStatsHt(buf,bufsize,d,1,full);
    }
    /* Make sure there is a NULL term at the end. */
    orig_buf[orig_bufsize-1] = '\0';
}",1596.0,1609.0,1.0,8.0,14.0,13,10,23,7,0,3,2,2,1,2,,0,2,8,4,4,void
2433,122572,keyDup,1,dictType.keyDup,"void* dictType.keyDup (dict*,void*)",dict.h,"void *(*keyDup)(dict *d, const void *key);",53.0,53.0,10.0,45.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void*
2434,122578,valDup,1,dictType.valDup,"void* dictType.valDup (dict*,void*)",dict.h,"void *(*valDup)(dict *d, const void *obj);",54.0,54.0,10.0,45.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void*
2435,122597,valDestructor,1,dictType.valDestructor,"void dictType.valDestructor (dict*,void*)",dict.h,"void (*valDestructor)(dict *d, void *obj);",57.0,57.0,10.0,45.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2436,122603,expandAllowed,1,dictType.expandAllowed,"int dictType.expandAllowed (size_t,double)",dict.h,"int (*expandAllowed)(size_t moreMem, double usedRatio);",58.0,58.0,9.0,58.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2437,122616,dictMetadataBytes,1,dictType.dictMetadataBytes,size_t dictType.dictMetadataBytes (void),dict.h,size_t (*dictMetadataBytes)(void);,75.0,75.0,12.0,37.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
2438,122621,afterReplaceEntry,1,dictType.afterReplaceEntry,"void dictType.afterReplaceEntry (dict*,dictEntry*)",dict.h,"void (*afterReplaceEntry)(dict *d, dictEntry *entry);",78.0,78.0,10.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2439,123037,memrev16,1,memrev16,void memrev16 (void*),endianconv.c,"void memrev16(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[1];
    x[1] = t;
}",49.0,55.0,1.0,1.0,7.0,8,2,8,3,1,0,1,1,0,0,,0,0,2,1,1,void
2440,123064,memrev32,1,memrev32,void memrev32 (void*),endianconv.c,"void memrev32(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[3];
    x[3] = t;
    t = x[1];
    x[1] = x[2];
    x[2] = t;
}",59.0,68.0,1.0,1.0,10.0,15,2,14,3,5,0,1,1,0,0,,0,0,2,1,1,void
2441,123108,memrev64,1,memrev64,void memrev64 (void*),endianconv.c,"void memrev64(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[7];
    x[7] = t;
    t = x[1];
    x[1] = x[6];
    x[6] = t;
    t = x[2];
    x[2] = x[5];
    x[5] = t;
    t = x[3];
    x[3] = x[4];
    x[4] = t;
}",72.0,87.0,1.0,1.0,16.0,29,2,26,3,13,0,1,1,0,0,,0,0,2,1,1,void
2442,123186,intrev16,1,intrev16,uint16_t intrev16 (uint16_t),endianconv.c,"uint16_t intrev16(uint16_t v) {
    memrev16(&v);
    return v;
}",89.0,92.0,1.0,1.0,4.0,1,1,2,1,13,1,1,1,0,1,,0,0,2,1,1,uint16_t
2443,123196,intrev32,1,intrev32,uint32_t intrev32 (uint32_t),endianconv.c,"uint32_t intrev32(uint32_t v) {
    memrev32(&v);
    return v;
}",94.0,97.0,1.0,1.0,4.0,1,1,2,1,61,1,1,1,0,1,,0,0,2,1,1,uint32_t
2444,123206,intrev64,1,intrev64,uint64_t intrev64 (uint64_t),endianconv.c,"uint64_t intrev64(uint64_t v) {
    memrev64(&v);
    return v;
}",99.0,102.0,1.0,1.0,4.0,1,1,2,1,17,1,1,1,0,1,,0,0,2,1,1,uint64_t
2445,123284,ldbInit,1,ldbInit,void ldbInit (void),eval.c,"void ldbInit(void) {
    ldb.conn = NULL;
    ldb.active = 0;
    ldb.logs = listCreate();
    listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);
    ldb.children = listCreate();
    ldb.src = NULL;
    ldb.lines = 0;
    ldb.cbuf = sdsempty();
}",672.0,681.0,1.0,4.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2446,123305,ldbCatStackValue,1,ldbCatStackValue,"sds ldbCatStackValue (sds,lua_State*,int)",eval.c,"sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
    return ldbCatStackValueRec(s,lua,idx,0);
}",1126.0,1128.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,sds
2447,123312,dictLuaScriptDestructor,1,dictLuaScriptDestructor,"void dictLuaScriptDestructor (dict*,void*)",eval.c,"static void dictLuaScriptDestructor(dict *d, void *val) {
    UNUSED(d);
    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
    decrRefCount(((luaScript*)val)->body);
    zfree(val);
}",50.0,55.0,1.0,4.0,6.0,4,3,6,3,0,2,2,2,0,2,,0,0,4,2,2,void
2448,123338,dictStrCaseHash,1,dictStrCaseHash,uint64_t dictStrCaseHash (void*),eval.c,"static uint64_t dictStrCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, strlen((char*)key));
}",57.0,59.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
2449,123395,sha1hex,1,sha1hex,"void sha1hex (char*,char*,size_t)",eval.c,"void sha1hex(char *digest, char *script, size_t len) {
    SHA1_CTX ctx;
    unsigned char hash[20];
    char *cset = ""0123456789abcdef"";
    int j;

    SHA1Init(&ctx);
    SHA1Update(&ctx,(unsigned char*)script,len);
    SHA1Final(hash,&ctx);

    for (j = 0; j < 20; j++) {
        digest[j*2] = cset[((hash[j]&0xF0)>>4)];
        digest[j*2+1] = cset[(hash[j]&0xF)];
    }
    digest[40] = '\0';
}",112.0,127.0,1.0,1.0,16.0,23,9,20,7,3,3,2,2,0,3,,0,0,6,3,3,void
2450,123469,luaRedisBreakpointCommand,1,luaRedisBreakpointCommand,int luaRedisBreakpointCommand (lua_State*),eval.c,"int luaRedisBreakpointCommand(lua_State *lua) {
    if (ldb.active) {
        ldb.luabp = 1;
        lua_pushboolean(lua,1);
    } else {
        lua_pushboolean(lua,0);
    }
    return 1;
}",134.0,142.0,1.0,1.0,9.0,3,2,3,2,0,4,2,2,2,0,,0,4,2,1,1,int
2451,123494,luaRedisDebugCommand,1,luaRedisDebugCommand,int luaRedisDebugCommand (lua_State*),eval.c,"int luaRedisDebugCommand(lua_State *lua) {
    if (!ldb.active) return 0;
    int argc = lua_gettop(lua);
    sds log = sdscatprintf(sdsempty(),""<debug> line %d: "", ldb.currentline);
    while(argc--) {
        log = ldbCatStackValue(log,lua,-1 - argc);
        if (argc != 0) log = sdscatlen(log,"", "",2);
    }
    ldbLog(log);
    return 0;
}",149.0,159.0,1.0,1.0,11.0,11,7,14,4,0,9,4,5,2,5,,0,8,2,1,1,int
2452,123559,scriptingInit,1,scriptingInit,void scriptingInit (int),eval.c,"void scriptingInit(int setup) {
    lua_State *lua = lua_open();

    if (setup) {
        lctx.lua_client = NULL;
        server.script_disable_deny_script = 0;
        ldbInit();
    }

    /* Initialize a dictionary we use to map SHAs to scripts.
     * This is useful for replication, as we need to replicate EVALSHA
     * as EVAL, so we need to remember the associated script. */
    lctx.lua_scripts = dictCreate(&shaScriptObjectDictType);
    lctx.lua_scripts_mem = 0;

    luaRegisterRedisAPI(lua);

    /* register debug commands */
    lua_getglobal(lua,""redis"");

    /* redis.breakpoint */
    lua_pushstring(lua,""breakpoint"");
    lua_pushcfunction(lua,luaRedisBreakpointCommand);
    lua_settable(lua,-3);

    /* redis.debug */
    lua_pushstring(lua,""debug"");
    lua_pushcfunction(lua,luaRedisDebugCommand);
    lua_settable(lua,-3);

    /* redis.replicate_commands */
    lua_pushstring(lua, ""replicate_commands"");
    lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);
...",183.0,265.0,1.0,34.0,83.0,26,7,38,8,2,23,3,3,2,6,,0,19,2,1,1,void
2453,123698,scriptingRelease,1,scriptingRelease,void scriptingRelease (int),eval.c,"void scriptingRelease(int async) {
    if (async)
        freeLuaScriptsAsync(lctx.lua_scripts);
    else
        dictRelease(lctx.lua_scripts);
    lctx.lua_scripts_mem = 0;
    lua_close(lctx.lua);
}",269.0,276.0,1.0,1.0,8.0,4,2,4,2,1,7,2,2,0,1,,0,6,2,1,1,void
2454,123725,scriptingReset,1,scriptingReset,void scriptingReset (int),eval.c,"void scriptingReset(int async) {
    scriptingRelease(async);
    scriptingInit(0);
}",278.0,281.0,1.0,1.0,4.0,0,0,1,1,0,2,1,1,0,2,,0,0,2,1,1,void
2455,123734,evalCalcFunctionName,1,evalCalcFunctionName,"void evalCalcFunctionName (int,sds,char*)",eval.c,"static void evalCalcFunctionName(int evalsha, sds script, char *out_funcname) {
    /* We obtain the script SHA1, then check if this function is already
     * defined into the Lua state */
    out_funcname[0] = 'f';
    out_funcname[1] = '_';
    if (!evalsha) {
        /* Hash the code if this is an EVAL call */
        sha1hex(out_funcname+2,script,sdslen(script));
    } else {
        /* We already have the SHA if it is an EVALSHA */
        int j;
        char *sha = script;

        /* Convert to lowercase. We don't use tolower since the function
         * managed to always show up in the profiler output consuming
         * a non trivial amount of time. */
        for (j = 0; j < 40; j++)
            out_funcname[j+2] = (sha[j] >= 'A' && sha[j] <= 'Z') ?
                sha[j]+('a'-'A') : sha[j];
        out_funcname[42] = '\0';
    }
}",287.0,308.0,1.0,1.0,22.0,6,4,6,3,1,2,2,2,0,2,,0,1,6,3,3,void
2456,123812,evalExtractShebangFlags,1,evalExtractShebangFlags,"int evalExtractShebangFlags (sds,uint64_t*,ssize_t*,sds*)",eval.c,"int evalExtractShebangFlags(sds body, uint64_t *out_flags, ssize_t *out_shebang_len, sds *err) {
    ssize_t shebang_len = 0;
    uint64_t script_flags = SCRIPT_FLAG_EVAL_COMPAT_MODE;
    if (!strncmp(body, ""#!"", 2)) {
        int numparts,j;
        char *shebang_end = strchr(body, '\n');
        if (shebang_end == NULL) {
            if (err)
                *err = sdsnew(""Invalid script shebang"");
            return C_ERR;
        }
        shebang_len = shebang_end - body;
        sds shebang = sdsnewlen(body, shebang_len);
        sds *parts = sdssplitargs(shebang, &numparts);
        sdsfree(shebang);
        if (!parts || numparts == 0) {
            if (err)
                *err = sdsnew(""Invalid engine in script shebang"");
            sdsfreesplitres(parts, numparts);
            return C_ERR;
        }
        /* Verify lua interpreter was specified */
        if (strcmp(parts[0], ""#!lua"")) {
            if (err)
                *err = sdscatfmt(sdsempty(), ""Unexpected eng...",315.0,378.0,1.0,28.0,64.0,55,13,74,17,2,22,17,49,3,18,,0,14,8,4,4,int
2457,124099,evalGetCommandFlags,1,evalGetCommandFlags,"uint64_t evalGetCommandFlags (client*,uint64_t)",eval.c,"uint64_t evalGetCommandFlags(client *c, uint64_t cmd_flags) {
    char funcname[43];
    int evalsha = c->cmd->proc == evalShaCommand || c->cmd->proc == evalShaRoCommand;
    if (evalsha && sdslen(c->argv[1]->ptr) != 40)
        return cmd_flags;
    uint64_t script_flags;
    evalCalcFunctionName(evalsha, c->argv[1]->ptr, funcname);
    char *lua_cur_script = funcname + 2;
    c->cur_script = dictFind(lctx.lua_scripts, lua_cur_script);
    if (!c->cur_script) {
        if (evalsha)
            return cmd_flags;
        if (evalExtractShebangFlags(c->argv[1]->ptr, &script_flags, NULL, NULL) == C_ERR)
            return cmd_flags;
    } else {
        luaScript *l = dictGetVal(c->cur_script);
        script_flags = l->flags;
    }
    if (script_flags & SCRIPT_FLAG_EVAL_COMPAT_MODE)
        return cmd_flags;
    return scriptFlagsToCmdFlags(cmd_flags, script_flags);
}",382.0,403.0,1.0,83.0,22.0,31,14,27,9,0,14,6,8,5,5,,0,12,4,2,2,uint64_t
2458,124227,luaCreateFunction,1,luaCreateFunction,"sds luaCreateFunction (client*,robj*)",eval.c,"sds luaCreateFunction(client *c, robj *body) {
    char funcname[43];
    dictEntry *de;
    uint64_t script_flags;

    funcname[0] = 'f';
    funcname[1] = '_';
    sha1hex(funcname+2,body->ptr,sdslen(body->ptr));

    if ((de = dictFind(lctx.lua_scripts,funcname+2)) != NULL) {
        return dictGetKey(de);
    }

    /* Handle shebang header in script code */
    ssize_t shebang_len = 0;
    sds err = NULL;
    if (evalExtractShebangFlags(body->ptr, &script_flags, &shebang_len, &err) == C_ERR) {
        addReplyErrorSds(c, err);
        return NULL;
    }

    /* Note that in case of a shebang line we skip it but keep the line feed to conserve the user's line numbers */
    if (luaL_loadbuffer(lctx.lua,(char*)body->ptr + shebang_len,sdslen(body->ptr) - shebang_len,""@user_script"")) {
        if (c != NULL) {
            addReplyErrorFormat(c,
                ""Error compiling script (new function): %s"",
                lua_tostring(lctx.lua,-1));
        }
        lua_pop(lctx.lua...",422.0,470.0,1.0,81.0,49.0,56,16,58,14,1,36,5,6,7,16,,0,27,4,2,2,sds
2459,124439,evalGenericCommand,1,evalGenericCommand,"void evalGenericCommand (client*,int)",eval.c,"void evalGenericCommand(client *c, int evalsha) {
    lua_State *lua = lctx.lua;
    char funcname[43];
    long long numkeys;

    /* Get the number of arguments that are keys */
    if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)
        return;
    if (numkeys > (c->argc - 3)) {
        addReplyError(c,""Number of keys can't be greater than number of args"");
        return;
    } else if (numkeys < 0) {
        addReplyError(c,""Number of keys can't be negative"");
        return;
    }

    if (c->cur_script) {
        funcname[0] = 'f', funcname[1] = '_';
        memcpy(funcname+2, dictGetKey(c->cur_script), 40);
        funcname[42] = '\0';
    } else
        evalCalcFunctionName(evalsha, c->argv[1]->ptr, funcname);

    /* Push the pcall error handler function on the stack. */
    lua_getglobal(lua, ""__redis__err__handler"");

    /* Try to lookup the Lua function */
    lua_getfield(lua, LUA_REGISTRYINDEX, funcname);
    if (lua_isnil(lua,-1)) {
        lua...",472.0,539.0,1.0,68.0,68.0,63,18,65,15,2,32,9,11,10,11,,0,26,4,2,2,void
2460,124712,evalCommand,1,evalCommand,void evalCommand (client*),eval.c,"void evalCommand(client *c) {
    /* Explicitly feed monitor here so that lua commands appear after their
     * script command. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
    if (!(c->flags & CLIENT_LUA_DEBUG))
        evalGenericCommand(c,0);
    else
        evalGenericCommandWithDebugging(c,0);
}",541.0,549.0,1.0,21.0,9.0,9,5,7,2,1,6,2,2,1,2,,0,4,2,1,1,void
2461,124753,evalRoCommand,1,evalRoCommand,void evalRoCommand (client*),eval.c,"void evalRoCommand(client *c) {
    evalCommand(c);
}",551.0,553.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2462,124760,evalShaCommand,1,evalShaCommand,void evalShaCommand (client*),eval.c,"void evalShaCommand(client *c) {
    /* Explicitly feed monitor here so that lua commands appear after their
     * script command. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
    if (sdslen(c->argv[1]->ptr) != 40) {
        /* We know that a match is not possible if the provided SHA is
         * not the right length. So we return an error ASAP, this way
         * evalGenericCommand() can be implemented without string length
         * sanity check */
        addReplyErrorObject(c, shared.noscripterr);
        return;
    }
    if (!(c->flags & CLIENT_LUA_DEBUG))
        evalGenericCommand(c,1);
    else {
        addReplyError(c,""Please use EVAL instead of EVALSHA for debugging"");
        return;
    }
}",555.0,573.0,1.0,21.0,19.0,14,7,10,3,1,9,3,3,3,4,,0,6,2,1,1,void
2463,124820,evalShaRoCommand,1,evalShaRoCommand,void evalShaRoCommand (client*),eval.c,"void evalShaRoCommand(client *c) {
    evalShaCommand(c);
}",575.0,577.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2464,124827,scriptCommand,1,scriptCommand,void scriptCommand (client*),eval.c,"void scriptCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""DEBUG (YES|SYNC|NO)"",
""    Set the debug mode for subsequent scripts executed."",
""EXISTS <sha1> [<sha1> ...]"",
""    Return information about the existence of the scripts in the script cache."",
""FLUSH [ASYNC|SYNC]"",
""    Flush the Lua scripts cache. Very dangerous on replicas."",
""    When called without the optional mode argument, the behavior is determined by the"",
""    lazyfree-lazy-user-flush configuration directive. Valid modes are:"",
""    * ASYNC: Asynchronously flush the scripts cache."",
""    * SYNC: Synchronously flush the scripts cache."",
""KILL"",
""    Kill the currently executing Lua script."",
""LOAD <script>"",
""    Load a script into the scripts cache without executing it."",
NULL
        };
        addReplyHelp(c, help);
    } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,""flush"")) {
        int async = 0;
        if (c->argc == 3 && !strcasecm...",579.0,651.0,1.0,24.0,73.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
2465,125207,evalMemory,1,evalMemory,unsigned long evalMemory (void),eval.c,"unsigned long evalMemory(void) {
    return luaMemory(lctx.lua);
}",653.0,655.0,1.0,1.0,3.0,1,1,1,1,2,3,1,1,0,1,,0,2,2,1,1,unsigned long
2466,125217,evalScriptsDict,1,evalScriptsDict,dict evalScriptsDict (void),eval.c,"dict* evalScriptsDict(void) {
    return lctx.lua_scripts;
}",657.0,659.0,1.0,1.0,3.0,1,1,1,1,3,2,1,1,0,0,,0,2,2,1,1,dict
2467,125226,evalScriptsMemory,1,evalScriptsMemory,unsigned long evalScriptsMemory (void),eval.c,"unsigned long evalScriptsMemory(void) {
    return lctx.lua_scripts_mem +
            dictMemUsage(lctx.lua_scripts) +
            dictSize(lctx.lua_scripts) * sizeof(luaScript);
}",661.0,665.0,1.0,12.0,5.0,14,6,6,2,1,11,1,1,0,1,,0,10,2,1,1,unsigned long
2468,125318,ldbFlushLog,1,ldbFlushLog,void ldbFlushLog (list*),eval.c,"void ldbFlushLog(list *log) {
    listNode *ln;

    while((ln = listFirst(log)) != NULL)
        listDelNode(log,ln);
}",684.0,689.0,1.0,16.0,6.0,3,3,4,3,0,1,2,2,1,0,,0,1,2,1,1,void
2469,125338,ldbIsEnabled,1,ldbIsEnabled,int ldbIsEnabled (void),eval.c,"int ldbIsEnabled(void){
    return ldb.active && ldb.step;
}",691.0,693.0,1.0,1.0,3.0,3,2,2,1,3,4,1,1,0,0,,0,4,2,1,1,int
2470,125433,ldbLog,1,ldbLog,void ldbLog (sds),eval.c,"void ldbLog(sds entry) {
    listAddNodeTail(ldb.logs,entry);
}",717.0,719.0,1.0,1.0,3.0,1,1,2,2,45,3,1,1,0,1,,0,2,2,1,1,void
2471,125443,ldbLogWithMaxLen,1,ldbLogWithMaxLen,void ldbLogWithMaxLen (sds),eval.c,"void ldbLogWithMaxLen(sds entry) {
    int trimmed = 0;
    if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {
        sdsrange(entry,0,ldb.maxlen-1);
        entry = sdscatlen(entry,"" ..."",4);
        trimmed = 1;
    }
    ldbLog(entry);
    if (trimmed && ldb.maxlen_hint_sent == 0) {
        ldb.maxlen_hint_sent = 1;
        ldbLog(sdsnew(
        ""<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming.""));
    }
}",725.0,738.0,1.0,1.0,14.0,14,6,13,3,2,16,3,3,7,6,,0,13,2,1,1,void
2472,125500,ldbSendLogs,1,ldbSendLogs,void ldbSendLogs (void),eval.c,"void ldbSendLogs(void) {
    sds proto = sdsempty();
    proto = sdscatfmt(proto,""*%i\r\n"", (int)listLength(ldb.logs));
    while(listLength(ldb.logs)) {
        listNode *ln = listFirst(ldb.logs);
        proto = sdscatlen(proto,""+"",1);
        sdsmapchars(ln->value,""\r\n"",""  "",2);
        proto = sdscatsds(proto,ln->value);
        proto = sdscatlen(proto,""\r\n"",2);
        listDelNode(ldb.logs,ln);
    }
    if (connWrite(ldb.conn,proto,sdslen(proto)) == -1) {
        /* Avoid warning. We don't check the return value of write()
         * since the next read() will catch the I/O error and will
         * close the debugging session. */
    }
    sdsfree(proto);
}",743.0,760.0,1.0,44.0,18.0,22,6,24,3,3,28,3,3,8,10,,0,25,2,1,1,void
2473,125596,ldbStartSession,1,ldbStartSession,int ldbStartSession (client*),eval.c,"int ldbStartSession(client *c) {
    ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;
    if (ldb.forked) {
        pid_t cp = redisFork(CHILD_TYPE_LDB);
        if (cp == -1) {
            addReplyErrorFormat(c,""Fork() failed: can't run EVAL in debugging mode: %s"", strerror(errno));
            return 0;
        } else if (cp == 0) {
            /* Child. Let's ignore important signals handled by the parent. */
            struct sigaction act;
            sigemptyset(&act.sa_mask);
            act.sa_flags = 0;
            act.sa_handler = SIG_IGN;
            sigaction(SIGTERM, &act, NULL);
            sigaction(SIGINT, &act, NULL);

            /* Log the creation of the child and close the listening
             * socket to make sure if the parent crashes a reset is sent
             * to the clients. */
            serverLog(LL_NOTICE,""Redis forked for debugging eval"");
        } else {
            /* Parent */
            listAddNodeTail(ldb.children,(void*)(unsigned lon...",774.0,823.0,1.0,29.0,50.0,34,13,28,6,0,26,4,5,2,10,,0,21,2,1,1,int
2474,125803,ldbEndSession,1,ldbEndSession,void ldbEndSession (client*),eval.c,"void ldbEndSession(client *c) {
    /* Emit the remaining logs and an <endsession> mark. */
    ldbLog(sdsnew(""<endsession>""));
    ldbSendLogs();

    /* If it's a fork()ed session, we just exit. */
    if (ldb.forked) {
        writeToClient(c,0);
        serverLog(LL_NOTICE,""Lua debugging session child exiting"");
        exitFromChild(0);
    } else {
        serverLog(LL_NOTICE,
            ""Redis synchronous debugging eval session ended"");
    }

    /* Otherwise let's restore client's state. */
    connNonBlock(ldb.conn);
    connSendTimeout(ldb.conn,0);

    /* Close the client connection after sending the final EVAL reply
     * in order to signal the end of the debugging session. */
    c->flags |= CLIENT_CLOSE_AFTER_REPLY;

    /* Cleanup. */
    sdsfreesplitres(ldb.src,ldb.lines);
    ldb.lines = 0;
    ldb.active = 0;
}",827.0,854.0,1.0,8.0,28.0,14,6,10,3,0,24,2,2,2,9,,0,16,2,1,1,void
2475,125895,ldbRemoveChild,1,ldbRemoveChild,int ldbRemoveChild (pid_t),eval.c,"int ldbRemoveChild(pid_t pid) {
    listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);
    if (ln) {
        listDelNode(ldb.children,ln);
        return 1;
    }
    return 0;
}",859.0,866.0,1.0,1.0,8.0,5,3,6,3,0,6,2,2,0,2,,0,5,2,1,1,int
2476,125924,ldbPendingChildren,1,ldbPendingChildren,int ldbPendingChildren (void),eval.c,"int ldbPendingChildren(void) {
    return listLength(ldb.children);
}",870.0,872.0,1.0,11.0,3.0,3,2,2,1,1,4,1,1,0,0,,0,4,2,1,1,int
2477,125940,ldbKillForkedSessions,1,ldbKillForkedSessions,void ldbKillForkedSessions (void),eval.c,"void ldbKillForkedSessions(void) {
    listIter li;
    listNode *ln;

    listRewind(ldb.children,&li);
    while((ln = listNext(&li))) {
        pid_t pid = (unsigned long) ln->value;
        serverLog(LL_NOTICE,""Killing debugging session %ld"",(long)pid);
        kill(pid,SIGKILL);
    }
    listRelease(ldb.children);
    ldb.children = listCreate();
}",875.0,887.0,1.0,8.0,13.0,14,7,12,6,0,12,2,2,1,5,,0,9,2,1,1,void
2478,126020,ldbGetSourceLine,1,ldbGetSourceLine,char* ldbGetSourceLine (int),eval.c,"char *ldbGetSourceLine(int line) {
    int idx = line-1;
    if (idx < 0 || idx >= ldb.lines) return ""<out of range source code line>"";
    return ldb.src[idx];
}",902.0,906.0,1.0,1.0,5.0,8,7,7,3,1,4,2,2,2,0,,0,4,2,1,1,char*
2479,126050,ldbIsBreakpoint,1,ldbIsBreakpoint,int ldbIsBreakpoint (int),eval.c,"int ldbIsBreakpoint(int line) {
    int j;

    for (j = 0; j < ldb.bpcount; j++)
        if (ldb.bp[j] == line) return 1;
    return 0;
}",909.0,915.0,1.0,1.0,7.0,3,3,3,2,3,2,2,2,2,0,,0,2,2,1,1,int
2480,126081,ldbAddBreakpoint,1,ldbAddBreakpoint,int ldbAddBreakpoint (int),eval.c,"int ldbAddBreakpoint(int line) {
    if (line <= 0 || line > ldb.lines) return 0;
    if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
        ldb.bp[ldb.bpcount++] = line;
        return 1;
    }
    return 0;
}",920.0,927.0,1.0,49.0,8.0,13,10,8,2,0,9,3,3,5,1,,0,9,2,1,1,int
2481,126126,ldbDelBreakpoint,1,ldbDelBreakpoint,int ldbDelBreakpoint (int),eval.c,"int ldbDelBreakpoint(int line) {
    int j;

    for (j = 0; j < ldb.bpcount; j++) {
        if (ldb.bp[j] == line) {
            ldb.bpcount--;
            memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
            return 1;
        }
    }
    return 0;
}",931.0,942.0,1.0,1.0,12.0,15,8,13,3,0,12,3,4,4,0,,0,12,2,1,1,int
2482,126180,ldbReplParseCommand,1,ldbReplParseCommand,"sds ldbReplParseCommand (int*,char**)",eval.c,"sds *ldbReplParseCommand(int *argcp, char** err) {
    static char* protocol_error = ""protocol error"";
    sds *argv = NULL;
    int argc = 0;
    if (sdslen(ldb.cbuf) == 0) return NULL;

    /* Working on a copy is simpler in this case. We can modify it freely
     * for the sake of simpler parsing. */
    sds copy = sdsdup(ldb.cbuf);
    char *p = copy;

    /* This Redis protocol parser is a joke... just the simplest thing that
     * works in this context. It is also very forgiving regarding broken
     * protocol. */

    /* Seek and parse *<count>\r\n. */
    p = strchr(p,'*'); if (!p) goto protoerr;
    char *plen = p+1; /* Multi bulk len pointer. */
    p = strstr(p,""\r\n""); if (!p) goto keep_reading;
    *p = '\0'; p += 2;
    *argcp = atoi(plen);
    if (*argcp <= 0 || *argcp > 1024) goto protoerr;

    /* Parse each argument. */
    argv = zmalloc(sizeof(sds)*(*argcp));
    argc = 0;
    while(argc < *argcp) {
        /* reached the end but there should be more data to re...",947.0,998.0,1.0,1.0,52.0,62,17,64,12,1,12,21,18,4,8,,0,9,4,2,2,sds
2483,126396,ldbLogSourceLine,1,ldbLogSourceLine,void ldbLogSourceLine (int),eval.c,"void ldbLogSourceLine(int lnum) {
    char *line = ldbGetSourceLine(lnum);
    char *prefix;
    int bp = ldbIsBreakpoint(lnum);
    int current = ldb.currentline == lnum;

    if (current && bp)
        prefix = ""->#"";
    else if (current)
        prefix = ""-> "";
    else if (bp)
        prefix = ""  #"";
    else
        prefix = ""   "";
    sds thisline = sdscatprintf(sdsempty(),""%s%-3d %s"", prefix, lnum, line);
    ldbLog(thisline);
}",1001.0,1017.0,1.0,1.0,17.0,8,4,15,7,3,7,2,2,0,5,,0,6,2,1,1,void
2484,126460,ldbList,1,ldbList,"void ldbList (int,int)",eval.c,"void ldbList(int around, int context) {
    int j;

    for (j = 1; j <= ldb.lines; j++) {
        if (around != 0 && abs(around-j) > context) continue;
        ldbLogSourceLine(j);
    }
}",1024.0,1031.0,1.0,1.0,8.0,7,7,8,4,0,3,4,4,2,1,,0,2,4,2,2,void
2485,126495,ldbCatStackValueRec,1,ldbCatStackValueRec,"sds ldbCatStackValueRec (sds,lua_State*,int,int)",eval.c,"sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
    int t = lua_type(lua,idx);

    if (level++ == LDB_MAX_VALUES_DEPTH)
        return sdscat(s,""<max recursion level reached! Nested table?>"");

    switch(t) {
    case LUA_TSTRING:
        {
        size_t strl;
        char *strp = (char*)lua_tolstring(lua,idx,&strl);
        s = sdscatrepr(s,strp,strl);
        }
        break;
    case LUA_TBOOLEAN:
        s = sdscat(s,lua_toboolean(lua,idx) ? ""true"" : ""false"");
        break;
    case LUA_TNUMBER:
        s = sdscatprintf(s,""%g"",(double)lua_tonumber(lua,idx));
        break;
    case LUA_TNIL:
        s = sdscatlen(s,""nil"",3);
        break;
    case LUA_TTABLE:
        {
        int expected_index = 1; /* First index we expect in an array. */
        int is_array = 1; /* Will be set to null if check fails. */
        /* Note: we create two representations at the same time, one
         * assuming the table is an array, one assuming it is not. At the
     ...",1041.0,1122.0,1.0,19.0,82.0,48,12,98,23,0,22,15,14,2,22,,0,17,8,4,4,sds
2486,126813,ldbLogStackValue,1,ldbLogStackValue,"void ldbLogStackValue (lua_State*,char*)",eval.c,"void ldbLogStackValue(lua_State *lua, char *prefix) {
    sds s = sdsnew(prefix);
    s = ldbCatStackValue(s,lua,-1);
    ldbLogWithMaxLen(s);
}",1133.0,1137.0,1.0,1.0,5.0,3,2,6,3,4,3,1,1,0,3,,0,2,4,2,2,void
2487,126833,ldbRedisProtocolToHuman_Int,1,ldbRedisProtocolToHuman_Int,"char* ldbRedisProtocolToHuman_Int (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,reply+1,p-reply-1);
    return p+2;
}",1174.0,1178.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2488,126839,ldbRedisProtocolToHuman_Bulk,1,ldbRedisProtocolToHuman_Bulk,"char* ldbRedisProtocolToHuman_Bulk (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long bulklen;

    string2ll(reply+1,p-reply-1,&bulklen);
    if (bulklen == -1) {
        *o = sdscatlen(*o,""NULL"",4);
        return p+2;
    } else {
        *o = sdscatrepr(*o,p+2,bulklen);
        return p+2+bulklen+2;
    }
}",1180.0,1192.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2489,126845,ldbRedisProtocolToHuman_Status,1,ldbRedisProtocolToHuman_Status,"char* ldbRedisProtocolToHuman_Status (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');

    *o = sdscatrepr(*o,reply,p-reply);
    return p+2;
}",1194.0,1199.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,char*
2490,126851,ldbRedisProtocolToHuman_MultiBulk,1,ldbRedisProtocolToHuman_MultiBulk,"char* ldbRedisProtocolToHuman_MultiBulk (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    if (mbulklen == -1) {
        *o = sdscatlen(*o,""NULL"",4);
        return p;
    }
    *o = sdscatlen(*o,""["",1);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,""]"",1);
    return p;
}",1201.0,1219.0,1.0,1.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2491,126857,ldbRedisProtocolToHuman_Set,1,ldbRedisProtocolToHuman_Set,"char* ldbRedisProtocolToHuman_Set (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Set(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    *o = sdscatlen(*o,""~("",2);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,"")"",1);
    return p;
}",1221.0,1235.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2492,126863,ldbRedisProtocolToHuman_Map,1,ldbRedisProtocolToHuman_Map,"char* ldbRedisProtocolToHuman_Map (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Map(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    *o = sdscatlen(*o,""{"",1);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        *o = sdscatlen(*o,"" => "",4);
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,""}"",1);
    return p;
}",1237.0,1253.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2493,126869,ldbRedisProtocolToHuman_Null,1,ldbRedisProtocolToHuman_Null,"char* ldbRedisProtocolToHuman_Null (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Null(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,""(null)"",6);
    return p+2;
}",1255.0,1259.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2494,126875,ldbRedisProtocolToHuman_Bool,1,ldbRedisProtocolToHuman_Bool,"char* ldbRedisProtocolToHuman_Bool (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Bool(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    if (reply[1] == 't')
        *o = sdscatlen(*o,""#true"",5);
    else
        *o = sdscatlen(*o,""#false"",6);
    return p+2;
}",1261.0,1268.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2495,126881,ldbRedisProtocolToHuman_Double,1,ldbRedisProtocolToHuman_Double,"char* ldbRedisProtocolToHuman_Double (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Double(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,""(double) "",9);
    *o = sdscatlen(*o,reply+1,p-reply-1);
    return p+2;
}",1270.0,1275.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
2496,126887,ldbRedisProtocolToHuman,1,ldbRedisProtocolToHuman,"char* ldbRedisProtocolToHuman (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman(sds *o, char *reply) {
    char *p = reply;
    switch(*p) {
    case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;
    case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;
    case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;
    case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
    case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
    case '~': p = ldbRedisProtocolToHuman_Set(o,reply); break;
    case '%': p = ldbRedisProtocolToHuman_Map(o,reply); break;
    case '_': p = ldbRedisProtocolToHuman_Null(o,reply); break;
    case '#': p = ldbRedisProtocolToHuman_Bool(o,reply); break;
    case ',': p = ldbRedisProtocolToHuman_Double(o,reply); break;
    }
    return p;
}",1154.0,1169.0,1.0,1.0,16.0,12,2,34,3,1,10,12,2,0,10,,0,10,4,2,2,char*
2497,127491,ldbLogRedisReply,1,ldbLogRedisReply,void ldbLogRedisReply (char*),eval.c,"void ldbLogRedisReply(char *reply) {
    sds log = sdsnew(""<reply> "");
    ldbRedisProtocolToHuman(&log,reply);
    ldbLogWithMaxLen(log);
}",1280.0,1284.0,1.0,1.0,5.0,2,2,4,2,2,3,1,1,0,3,,0,1,2,1,1,void
2498,127507,ldbPrint,1,ldbPrint,"void ldbPrint (lua_State*,char*)",eval.c,"void ldbPrint(lua_State *lua, char *varname) {
    lua_Debug ar;

    int l = 0; /* Stack level. */
    while (lua_getstack(lua,l,&ar) != 0) {
        l++;
        const char *name;
        int i = 1; /* Variable index. */
        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
            i++;
            if (strcmp(varname,name) == 0) {
                ldbLogStackValue(lua,""<value> "");
                lua_pop(lua,1);
                return;
            } else {
                lua_pop(lua,1); /* Discard the var name on the stack. */
            }
        }
    }

    /* Let's try with global vars in two selected cases */
    if (!strcmp(varname,""ARGV"") || !strcmp(varname,""KEYS"")) {
        lua_getglobal(lua, varname);
        ldbLogStackValue(lua,""<value> "");
        lua_pop(lua,1);
    } else {
        ldbLog(sdsnew(""No such variable.""));
    }
}",1289.0,1317.0,1.0,1.0,29.0,13,7,22,7,0,2,5,8,0,2,,0,0,4,2,2,void
2499,127591,ldbPrintAll,1,ldbPrintAll,void ldbPrintAll (lua_State*),eval.c,"void ldbPrintAll(lua_State *lua) {
    lua_Debug ar;
    int vars = 0;

    if (lua_getstack(lua,0,&ar) != 0) {
        const char *name;
        int i = 1; /* Variable index. */
        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
            i++;
            if (!strstr(name,""(*temporary)"")) {
                sds prefix = sdscatprintf(sdsempty(),""<value> %s = "",name);
                ldbLogStackValue(lua,prefix);
                sdsfree(prefix);
                vars++;
            }
            lua_pop(lua,1);
        }
    }

    if (vars == 0) {
        ldbLog(sdsnew(""No local variables in the current context.""));
    }
}",1321.0,1343.0,1.0,1.0,23.0,12,6,19,7,0,6,5,8,0,6,,0,3,2,1,1,void
2500,127659,ldbBreak,1,ldbBreak,"void ldbBreak (sds*,int)",eval.c,"void ldbBreak(sds *argv, int argc) {
    if (argc == 1) {
        if (ldb.bpcount == 0) {
            ldbLog(sdsnew(""No breakpoints set. Use 'b <line>' to add one.""));
            return;
        } else {
            ldbLog(sdscatfmt(sdsempty(),""%i breakpoints set:"",ldb.bpcount));
            int j;
            for (j = 0; j < ldb.bpcount; j++)
                ldbLogSourceLine(ldb.bp[j]);
        }
    } else {
        int j;
        for (j = 1; j < argc; j++) {
            char *arg = argv[j];
            long line;
            if (!string2l(arg,sdslen(arg),&line)) {
                ldbLog(sdscatfmt(sdsempty(),""Invalid argument:'%s'"",arg));
            } else {
                if (line == 0) {
                    ldb.bpcount = 0;
                    ldbLog(sdsnew(""All breakpoints removed.""));
                } else if (line > 0) {
                    if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {
                        ldbLog(sdsnew(""Too many breakpoints set.""));
                    } ...",1346.0,1385.0,1.0,39.0,40.0,3,2,2,2,0,4,3,4,2,2,,0,3,4,2,2,void
2501,127812,ldbEval,1,ldbEval,"void ldbEval (lua_State*,sds*,int)",eval.c,"void ldbEval(lua_State *lua, sds *argv, int argc) {
    /* Glue the script together if it is composed of multiple arguments. */
    sds code = sdsjoinsds(argv+1,argc-1,"" "",1);
    sds expr = sdscatsds(sdsnew(""return ""),code);

    /* Try to compile it as an expression, prepending ""return "". */
    if (luaL_loadbuffer(lua,expr,sdslen(expr),""@ldb_eval"")) {
        lua_pop(lua,1);
        /* Failed? Try as a statement. */
        if (luaL_loadbuffer(lua,code,sdslen(code),""@ldb_eval"")) {
            ldbLog(sdscatfmt(sdsempty(),""<error> %s"",lua_tostring(lua,-1)));
            lua_pop(lua,1);
            sdsfree(code);
            sdsfree(expr);
            return;
        }
    }

    /* Call it. */
    sdsfree(code);
    sdsfree(expr);
    if (lua_pcall(lua,0,1,0)) {
        ldbLog(sdscatfmt(sdsempty(),""<error> %s"",lua_tostring(lua,-1)));
        lua_pop(lua,1);
        return;
    }
    ldbLogStackValue(lua,""<retval> "");
    lua_pop(lua,1);
}",1390.0,1418.0,1.0,1.0,29.0,6,4,23,5,0,16,4,5,2,16,,0,9,6,3,3,void
2502,127902,ldbRedis,1,ldbRedis,"void ldbRedis (lua_State*,sds*,int)",eval.c,"void ldbRedis(lua_State *lua, sds *argv, int argc) {
    int j;

    if (!lua_checkstack(lua, argc + 1)) {
        /* Increase the Lua stack if needed to make sure there is enough room
         * to push 'argc + 1' elements to the stack. On failure, return error.
         * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments
         * given by the user (without the first argument) and we also push the 'redis' global table and
         * 'redis.call' function so:
         * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/
        ldbLogRedisReply(""max lua stack reached"");
        return;
    }

    lua_getglobal(lua,""redis"");
    lua_pushstring(lua,""call"");
    lua_gettable(lua,-2);       /* Stack: redis, redis.call */
    for (j = 1; j < argc; j++)
        lua_pushlstring(lua,argv[j],sdslen(argv[j]));
    ldb.step = 1;               /* Force redis.call() to log. */
    lua_pcall(lua,argc-...",1424.0,1447.0,1.0,1.0,24.0,10,7,13,4,0,5,3,3,0,1,,0,4,6,3,3,void
2503,127970,ldbTrace,1,ldbTrace,void ldbTrace (lua_State*),eval.c,"void ldbTrace(lua_State *lua) {
    lua_Debug ar;
    int level = 0;

    while(lua_getstack(lua,level,&ar)) {
        lua_getinfo(lua,""Snl"",&ar);
        if(strstr(ar.short_src,""user_script"") != NULL) {
            ldbLog(sdscatprintf(sdsempty(),""%s %s:"",
                (level == 0) ? ""In"" : ""From"",
                ar.name ? ar.name : ""top level""));
            ldbLogSourceLine(ar.currentline);
        }
        level++;
    }
    if (level == 0) {
        ldbLog(sdsnew(""<error> Can't retrieve Lua stack.""));
    }
}",1451.0,1468.0,1.0,1.0,18.0,13,7,14,4,0,6,4,5,0,6,,0,3,2,1,1,void
2504,128033,ldbMaxlen,1,ldbMaxlen,"void ldbMaxlen (sds*,int)",eval.c,"void ldbMaxlen(sds *argv, int argc) {
    if (argc == 2) {
        int newval = atoi(argv[1]);
        ldb.maxlen_hint_sent = 1; /* User knows about this command. */
        if (newval != 0 && newval <= 60) newval = 60;
        ldb.maxlen = newval;
    }
    if (ldb.maxlen) {
        ldbLog(sdscatprintf(sdsempty(),""<value> replies are truncated at %d bytes."",(int)ldb.maxlen));
    } else {
        ldbLog(sdscatprintf(sdsempty(),""<value> replies are unlimited.""));
    }
}",1472.0,1484.0,1.0,1.0,13.0,14,8,11,4,0,11,4,5,2,3,,0,10,4,2,2,void
2505,128093,ldbRepl,1,ldbRepl,int ldbRepl (lua_State*),eval.c,"int ldbRepl(lua_State *lua) {
    sds *argv;
    int argc;
    char* err = NULL;

    /* We continue processing commands until a command that should return
     * to the Lua interpreter is found. */
    while(1) {
        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {
            char buf[1024];
            if (err) {
                luaPushError(lua, err);
                luaError(lua);
            }
            int nread = connRead(ldb.conn,buf,sizeof(buf));
            if (nread <= 0) {
                /* Make sure the script runs without user input since the
                 * client is no longer connected. */
                ldb.step = 0;
                ldb.bpcount = 0;
                return C_ERR;
            }
            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
            /* after 1M we will exit with an error
             * so that the client will not blow the memory
             */
            if (sdslen(ldb.cbuf) > 1<<20) {
                sdsfree(ldb.cbuf...",1489.0,1616.0,1.0,23.0,128.0,31,12,34,8,1,95,7,15,4,75,,0,56,2,1,1,int
2506,128624,luaLdbLineHook,1,luaLdbLineHook,"void luaLdbLineHook (lua_State*,lua_Debug*)",eval.c,"void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    lua_getstack(lua,0,ar);
    lua_getinfo(lua,""Sl"",ar);
    ldb.currentline = ar->currentline;

    int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;
    int timeout = 0;

    /* Events outside our script are not interesting. */
    if(strstr(ar->short_src,""user_script"") == NULL) return;

    /* Check if a timeout occurred. */
    if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {
        mstime_t elapsed = elapsedMs(rctx->start_time);
        mstime_t timelimit = server.busy_reply_threshold ?
                             server.busy_reply_threshold : 5000;
        if (elapsed >= timelimit) {
            timeout = 1;
            ldb.step = 1;
        } else {
            return; /* No timeout, ignore the COUNT event. */
        }
    }

    if (ldb.step || bp) {
        c...",1620.0,1667.0,1.0,49.0,48.0,49,12,45,12,0,37,7,10,5,13,,0,31,4,2,2,void
2507,128840,getLRUClock,1,getLRUClock,unsigned int getLRUClock (void),evict.c,"unsigned int getLRUClock(void) {
    return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
}",72.0,74.0,1.0,21.0,3.0,4,4,0,0,2,1,1,1,0,1,,0,0,2,1,1,unsigned int
2508,128859,LRU_CLOCK,1,LRU_CLOCK,unsigned int LRU_CLOCK (void),evict.c,"unsigned int LRU_CLOCK(void) {
    unsigned int lruclock;
    if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {
        lruclock = server.lruclock;
    } else {
        lruclock = getLRUClock();
    }
    return lruclock;
}",80.0,88.0,1.0,26.0,9.0,5,4,4,2,3,0,2,2,0,0,,0,0,2,1,1,unsigned int
2509,128888,estimateObjectIdleTime,1,estimateObjectIdleTime,unsigned long long estimateObjectIdleTime (robj*),evict.c,"unsigned long long estimateObjectIdleTime(robj *o) {
    unsigned long long lruclock = LRU_CLOCK();
    if (lruclock >= o->lru) {
        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;
    } else {
        return (lruclock + (LRU_CLOCK_MAX - o->lru)) *
                    LRU_CLOCK_RESOLUTION;
    }
}",92.0,100.0,1.0,37.0,9.0,6,5,5,2,3,1,2,2,0,1,,0,1,2,1,1,unsigned long long
2510,128934,evictionPoolAlloc,1,evictionPoolAlloc,void evictionPoolAlloc (void),evict.c,"void evictionPoolAlloc(void) {
    struct evictionPoolEntry *ep;
    int j;

    ep = zmalloc(sizeof(*ep)*EVPOOL_SIZE);
    for (j = 0; j < EVPOOL_SIZE; j++) {
        ep[j].idle = 0;
        ep[j].key = NULL;
        ep[j].cached = sdsnewlen(NULL,EVPOOL_CACHED_SDS_SIZE);
        ep[j].dbid = 0;
    }
    EvictionPoolLRU = ep;
}",123.0,135.0,1.0,29.0,13.0,19,7,16,4,1,3,2,2,0,2,,0,3,2,1,1,void
2511,128999,evictionPoolPopulate,1,evictionPoolPopulate,"void evictionPoolPopulate (int,dict*,dict*,evictionPoolEntry*)",evict.c,"void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {
    int j, k, count;
    dictEntry *samples[server.maxmemory_samples];

    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);
    for (j = 0; j < count; j++) {
        unsigned long long idle;
        sds key;
        robj *o;
        dictEntry *de;

        de = samples[j];
        key = dictGetKey(de);

        /* If the dictionary we are sampling from is not the main
         * dictionary (but the expires one) we need to lookup the key
         * again in the key dictionary to obtain the value object. */
        if (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) {
            if (sampledict != keydict) de = dictFind(keydict, key);
            o = dictGetVal(de);
        }

        /* Calculate the idle time according to the policy. This is called
         * idle just because the code initially handled LRU, but is in fact
         * just a score where an h...",146.0,241.0,1.0,39.0,96.0,43,11,45,15,1,7,9,15,0,7,,0,7,8,4,4,void
2512,129361,LFUGetTimeInMinutes,1,LFUGetTimeInMinutes,unsigned long LFUGetTimeInMinutes (void),evict.c,"unsigned long LFUGetTimeInMinutes(void) {
    return (server.unixtime/60) & 65535;
}",283.0,285.0,1.0,1.0,3.0,3,3,1,1,4,0,1,1,0,0,,0,0,2,1,1,unsigned long
2513,129374,LFUTimeElapsed,1,LFUTimeElapsed,unsigned long LFUTimeElapsed (long unsigned),evict.c,"unsigned long LFUTimeElapsed(unsigned long ldt) {
    unsigned long now = LFUGetTimeInMinutes();
    if (now >= ldt) return now-ldt;
    return 65535-ldt+now;
}",291.0,295.0,1.0,1.0,5.0,5,4,7,2,1,1,2,2,0,1,,0,1,2,1,1,unsigned long
2514,129398,LFULogIncr,1,LFULogIncr,uint8_t LFULogIncr (uint8_t),evict.c,"uint8_t LFULogIncr(uint8_t counter) {
    if (counter == 255) return 255;
    double r = (double)rand()/RAND_MAX;
    double baseval = counter - LFU_INIT_VAL;
    if (baseval < 0) baseval = 0;
    double p = 1.0/(baseval*server.lfu_log_factor+1);
    if (r < p) counter++;
    return counter;
}",299.0,307.0,1.0,31.0,9.0,15,10,14,6,1,0,4,4,0,0,,0,0,2,1,1,uint8_t
2515,129455,LFUDecrAndReturn,1,LFUDecrAndReturn,unsigned long LFUDecrAndReturn (robj*),evict.c,"unsigned long LFUDecrAndReturn(robj *o) {
    unsigned long ldt = o->lru >> 8;
    unsigned long counter = o->lru & 255;
    unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;
    if (num_periods)
        counter = (num_periods > counter) ? 0 : counter - num_periods;
    return counter;
}",319.0,326.0,1.0,1.0,8.0,15,9,15,5,3,1,2,2,0,1,,0,1,2,1,1,unsigned long
2516,129505,freeMemoryGetNotCountedMemory,1,freeMemoryGetNotCountedMemory,size_t freeMemoryGetNotCountedMemory (void),evict.c,"size_t freeMemoryGetNotCountedMemory(void) {
    size_t overhead = 0;

    /* Since all replicas and replication backlog share global replication
     * buffer, we think only the part of exceeding backlog size is the extra
     * separate consumption of replicas.
     *
     * Note that although the backlog is also initially incrementally grown
     * (pushing DELs consumes memory), it'll eventually stop growing and
     * remain constant in size, so even if its creation will cause some
     * eviction, it's capped, and also here to stay (no resonance effect)
     *
     * Note that, because we trim backlog incrementally in the background,
     * backlog size may exceeds our setting if slow replicas that reference
     * vast replication buffer blocks disconnect. To avoid massive eviction
     * loop, we don't count the delayed freed replication backlog into used
     * memory even if there are no replicas, i.e. we still regard this memory
     * as replicas'. */
    if ((long long)...",336.0,371.0,1.0,38.0,36.0,26,11,19,6,4,1,4,5,0,1,,0,0,2,1,1,size_t
2517,129584,getMaxmemoryState,1,getMaxmemoryState,"int getMaxmemoryState (size_t*,size_t*,size_t*,float*)",evict.c,"int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {
    size_t mem_reported, mem_used, mem_tofree;

    /* Check if we are over the memory usage limit. If we are not, no need
     * to subtract the slaves output buffers. We can just return ASAP. */
    mem_reported = zmalloc_used_memory();
    if (total) *total = mem_reported;

    /* We may return ASAP if there is no need to compute the level. */
    if (!server.maxmemory) {
        if (level) *level = 0;
        return C_OK;
    }
    if (mem_reported <= server.maxmemory && !level) return C_OK;

    /* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */
    mem_used = mem_reported;
    size_t overhead = freeMemoryGetNotCountedMemory();
    mem_used = (mem_used > overhead) ? mem_used-overhead : 0;

    /* Compute the ratio of memory usage. */
    if (level) *level = (float)mem_used / (float)server.maxmemory;

    if (mem_reported <= server.maxmemory) ret...",397.0,433.0,1.0,15.0,37.0,35,12,35,9,6,2,10,11,0,2,,0,2,8,4,4,int
2518,129716,overMaxmemoryAfterAlloc,1,overMaxmemoryAfterAlloc,int overMaxmemoryAfterAlloc (size_t),evict.c,"int overMaxmemoryAfterAlloc(size_t moremem) {
    if (!server.maxmemory) return  0; /* No limit. */

    /* Check quickly. */
    size_t mem_used = zmalloc_used_memory();
    if (mem_used + moremem <= server.maxmemory) return 0;

    size_t overhead = freeMemoryGetNotCountedMemory();
    mem_used = (mem_used > overhead) ? mem_used - overhead : 0;
    return mem_used + moremem > server.maxmemory;
}",438.0,448.0,1.0,1.0,11.0,14,8,14,4,1,2,3,3,0,2,,0,2,2,1,1,int
2519,129770,evictionTimeProc,1,evictionTimeProc,"int evictionTimeProc (aeEventLoop*,long long,void*)",evict.c,"static int evictionTimeProc(
        struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    if (performEvictions() == EVICT_RUNNING) return 0;  /* keep evicting */

    /* For EVICT_OK - things are good, no need to keep evicting.
     * For EVICT_FAIL - there is nothing left to evict.  */
    isEvictionProcRunning = 0;
    return AE_NOMORE;
}",455.0,467.0,1.0,4.0,13.0,6,4,7,4,0,2,2,2,1,1,,0,2,6,3,3,int
2520,129812,startEvictionTimeProc,1,startEvictionTimeProc,void startEvictionTimeProc (void),evict.c,"void startEvictionTimeProc(void) {
    if (!isEvictionProcRunning) {
        isEvictionProcRunning = 1;
        aeCreateTimeEvent(server.el, 0,
                evictionTimeProc, NULL, NULL);
    }
}",469.0,475.0,1.0,1.0,7.0,3,3,5,3,2,3,2,2,1,1,,0,2,2,1,1,void
2521,129832,isSafeToPerformEvictions,1,isSafeToPerformEvictions,int isSafeToPerformEvictions (void),evict.c,"static int isSafeToPerformEvictions(void) {
    /* - There must be no script in timeout condition.
     * - Nor we are loading data right now.  */
    if (isInsideYieldingLongCommand() || server.loading) return 0;

    /* By default replicas should ignore maxmemory
     * and just be masters exact copies. */
    if (server.masterhost && server.repl_slave_ignore_maxmemory) return 0;

    /* If 'evict' action is paused, for whatever reason, then return false */
    if (isPausedActionsWithUpdate(PAUSE_ACTION_EVICT)) return 0;

    return 1;
}",481.0,494.0,1.0,34.0,14.0,6,4,3,1,1,2,4,4,2,2,,0,2,2,1,1,int
2522,129869,evictionTimeLimitUs,1,evictionTimeLimitUs,unsigned long evictionTimeLimitUs (void),evict.c,"static unsigned long evictionTimeLimitUs(void) {
    serverAssert(server.maxmemory_eviction_tenacity >= 0);
    serverAssert(server.maxmemory_eviction_tenacity <= 100);

    if (server.maxmemory_eviction_tenacity <= 10) {
        /* A linear progression from 0..500us */
        return 50uL * server.maxmemory_eviction_tenacity;
    }

    if (server.maxmemory_eviction_tenacity < 100) {
        /* A 15% geometric progression, resulting in a limit of ~2 min at tenacity==99  */
        return (unsigned long)(500.0 * pow(1.15, server.maxmemory_eviction_tenacity - 10.0));
    }

    return ULONG_MAX;   /* No limit to eviction time */
}",497.0,512.0,1.0,4.0,16.0,22,10,7,2,1,2,3,3,0,2,,0,0,2,1,1,unsigned long
2523,129944,performEvictions,1,performEvictions,int performEvictions (void),evict.c,"int performEvictions(void) {
    /* Note, we don't goto update_metrics here because this check skips eviction
     * as if it wasn't triggered. it's a fake EVICT_OK. */
    if (!isSafeToPerformEvictions()) return EVICT_OK;

    int keys_freed = 0;
    size_t mem_reported, mem_tofree;
    long long mem_freed; /* May be negative */
    mstime_t latency, eviction_latency;
    long long delta;
    int slaves = listLength(server.slaves);
    int result = EVICT_FAIL;

    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK) {
        result = EVICT_OK;
        goto update_metrics;
    }

    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION) {
        result = EVICT_FAIL;  /* We need to free memory, but policy forbids. */
        goto update_metrics;
    }

    unsigned long eviction_time_limit_us = evictionTimeLimitUs();

    mem_freed = 0;

    latencyStartMonitor(latency);

    monotime evictionTimer;
    elapsedStart(&evictionTimer);

    /* Try to smoke-out bugs (se...",538.0,755.0,1.0,44.0,218.0,164,26,168,29,2,44,34,78,9,36,,0,27,2,1,1,int
2524,130781,activeExpireCycleTryExpire,1,activeExpireCycleTryExpire,"int activeExpireCycleTryExpire (redisDb*,dictEntry*,long long)",expire.c,"int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {
    long long t = dictGetSignedIntegerVal(de);
    if (now > t) {
        sds key = dictGetKey(de);
        robj *keyobj = createStringObject(key,sdslen(key));
        deleteExpiredKeyAndPropagate(db,keyobj);
        decrRefCount(keyobj);
        return 1;
    } else {
        return 0;
    }
}",54.0,65.0,1.0,1.0,12.0,4,2,12,6,2,6,2,2,0,6,,0,4,6,3,3,int
2525,130829,expireScanCallback,1,expireScanCallback,"void expireScanCallback (void*,dictEntry*)",expire.c,"void expireScanCallback(void *privdata, const dictEntry *const_de) {
    dictEntry *de = (dictEntry *)const_de;
    expireScanData *data = privdata;
    long long ttl  = dictGetSignedIntegerVal(de) - data->now;
    if (activeExpireCycleTryExpire(data->db, de, data->now)) {
        data->expired++;
        /* Propagate the DEL command */
        postExecutionUnitOperations();
    }
    if (ttl > 0) {
        /* We want the average TTL of keys yet not expired. */
        data->ttl_sum += ttl;
        data->ttl_samples++;
    }
    data->sampled++;
}",123.0,138.0,1.0,1.0,16.0,17,7,16,5,0,10,3,3,3,3,,0,9,4,2,2,void
2526,130887,activeExpireCycle,1,activeExpireCycle,void activeExpireCycle (int),expire.c,"void activeExpireCycle(int type) {
    /* Adjust the running parameters according to the configured expire
     * effort. The default effort is 1, and the maximum configurable effort
     * is 10. */
    unsigned long
    effort = server.active_expire_effort-1, /* Rescale from 0 to 9. */
    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +
                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/4*effort,
    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +
                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/4*effort,
    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +
                                  2*effort,
    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-
                                    effort;

    /* This function has some global state in order to continue the work
     * incrementally across calls. */
    static unsigned int current_db = 0; /* Next DB to test. */
    static int timel...",140.0,322.0,1.0,27.0,183.0,193,27,129,26,2,39,22,40,10,8,,0,37,2,1,1,void
2527,131464,expireSlaveKeys,1,expireSlaveKeys,void expireSlaveKeys (void),expire.c,"void expireSlaveKeys(void) {
    if (slaveKeysWithExpire == NULL ||
        dictSize(slaveKeysWithExpire) == 0) return;

    int cycles = 0, noexpire = 0;
    mstime_t start = mstime();
    while(1) {
        dictEntry *de = dictGetRandomKey(slaveKeysWithExpire);
        sds keyname = dictGetKey(de);
        uint64_t dbids = dictGetUnsignedIntegerVal(de);
        uint64_t new_dbids = 0;

        /* Check the key against every database corresponding to the
         * bits set in the value bitmap. */
        int dbid = 0;
        while(dbids && dbid < server.dbnum) {
            if ((dbids & 1) != 0) {
                redisDb *db = server.db+dbid;
                dictEntry *expire = dictFind(db->expires,keyname);
                int expired = 0;

                if (expire &&
                    activeExpireCycleTryExpire(server.db+dbid,expire,start))
                {
                    expired = 1;
                    /* Propagate the DEL (writable replicas do not propagate anythin...",363.0,421.0,1.0,8.0,59.0,50,18,50,14,0,22,14,24,13,9,,0,20,2,1,1,void
2528,131654,rememberSlaveKeyWithExpire,1,rememberSlaveKeyWithExpire,"void rememberSlaveKeyWithExpire (redisDb*,robj*)",expire.c,"void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
    if (slaveKeysWithExpire == NULL) {
        static dictType dt = {
            dictSdsHash,                /* hash function */
            NULL,                       /* key dup */
            NULL,                       /* val dup */
            dictSdsKeyCompare,          /* key compare */
            dictSdsDestructor,          /* key destructor */
            NULL,                       /* val destructor */
            NULL                        /* allow to expand */
        };
        slaveKeysWithExpire = dictCreate(&dt);
    }
    if (db->id > 63) return;

    dictEntry *de = dictAddOrFind(slaveKeysWithExpire,key->ptr);
    /* If the entry was just created, set it to a copy of the SDS string
     * representing the key: we don't want to need to take those keys
     * in sync with the main DB. The keys will be removed by expireSlaveKeys()
     * as it scans to find keys to remove. */
    if (dictGetKey(de) == key->p...",425.0,453.0,1.0,1.0,29.0,16,8,28,10,1,14,4,4,3,8,,0,11,4,2,2,void
2529,131732,getSlaveKeyWithExpireCount,1,getSlaveKeyWithExpireCount,size_t getSlaveKeyWithExpireCount (void),expire.c,"size_t getSlaveKeyWithExpireCount(void) {
    if (slaveKeysWithExpire == NULL) return 0;
    return dictSize(slaveKeysWithExpire);
}",456.0,459.0,1.0,11.0,4.0,6,4,5,2,1,6,2,2,1,0,,0,6,2,1,1,size_t
2530,131759,flushSlaveKeysWithExpireList,1,flushSlaveKeysWithExpireList,void flushSlaveKeysWithExpireList (void),expire.c,"void flushSlaveKeysWithExpireList(void) {
    if (slaveKeysWithExpire) {
        dictRelease(slaveKeysWithExpire);
        slaveKeysWithExpire = NULL;
    }
}",469.0,474.0,1.0,1.0,6.0,1,1,4,2,2,4,2,2,1,1,,0,3,2,1,1,void
2531,131772,checkAlreadyExpired,1,checkAlreadyExpired,int checkAlreadyExpired (long long),expire.c,"int checkAlreadyExpired(long long when) {
    /* EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past
     * should never be executed as a DEL when load the AOF or in the context
     * of a slave instance.
     *
     * Instead we add the already expired key to the database with expire time
     * (possibly in the past) and wait for an explicit DEL from the master. */
    return (when <= commandTimeSnapshot() && !server.loading && !server.masterhost);
}",476.0,484.0,1.0,1.0,9.0,7,4,3,2,2,1,1,1,0,1,,0,0,2,1,1,int
2532,131791,parseExtendedExpireArgumentsOrReply,1,parseExtendedExpireArgumentsOrReply,"int parseExtendedExpireArgumentsOrReply (client*,int*)",expire.c,"int parseExtendedExpireArgumentsOrReply(client *c, int *flags) {
    int nx = 0, xx = 0, gt = 0, lt = 0;

    int j = 3;
    while (j < c->argc) {
        char *opt = c->argv[j]->ptr;
        if (!strcasecmp(opt,""nx"")) {
            *flags |= EXPIRE_NX;
            nx = 1;
        } else if (!strcasecmp(opt,""xx"")) {
            *flags |= EXPIRE_XX;
            xx = 1;
        } else if (!strcasecmp(opt,""gt"")) {
            *flags |= EXPIRE_GT;
            gt = 1;
        } else if (!strcasecmp(opt,""lt"")) {
            *flags |= EXPIRE_LT;
            lt = 1;
        } else {
            addReplyErrorFormat(c, ""Unsupported option %s"", opt);
            return C_ERR;
        }
        j++;
    }

    if ((nx && xx) || (nx && gt) || (nx && lt)) {
        addReplyError(c, ""NX and XX, GT or LT options at the same time are not compatible"");
        return C_ERR;
    }

    if (gt && lt) {
        addReplyError(c, ""GT and LT options at the same time are not compatible"");
        return C_E...",498.0,534.0,1.0,22.0,37.0,24,11,24,8,1,4,5,6,1,2,,0,2,4,2,2,int
2533,131959,expireGenericCommand,1,expireGenericCommand,"void expireGenericCommand (client*,long long,int)",expire.c,"void expireGenericCommand(client *c, long long basetime, int unit) {
    robj *key = c->argv[1], *param = c->argv[2];
    long long when; /* unix time in milliseconds when the key will expire. */
    long long current_expire = -1;
    int flag = 0;

    /* checking optional flags */
    if (parseExtendedExpireArgumentsOrReply(c, &flag) != C_OK) {
        return;
    }

    if (getLongLongFromObjectOrReply(c, param, &when, NULL) != C_OK)
        return;

    /* EXPIRE allows negative numbers, but we can at least detect an
     * overflow by either unit conversion or basetime addition. */
    if (unit == UNIT_SECONDS) {
        if (when > LLONG_MAX / 1000 || when < LLONG_MIN / 1000) {
            addReplyErrorExpireTime(c);
            return;
        }
        when *= 1000;
    }

    if (when > LLONG_MAX - basetime) {
        addReplyErrorExpireTime(c);
        return;
    }
    when += basetime;

    /* No key, return zero. */
    if (lookupKeyWrite(c->db,key) == NULL) {
        ad...",549.0,664.0,1.0,57.0,116.0,72,25,80,15,4,25,17,30,5,18,,0,13,6,3,3,void
2534,132333,expireCommand,1,expireCommand,void expireCommand (client*),expire.c,"void expireCommand(client *c) {
    expireGenericCommand(c,commandTimeSnapshot(),UNIT_SECONDS);
}",667.0,669.0,1.0,49.0,3.0,0,0,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
2535,132344,expireatCommand,1,expireatCommand,void expireatCommand (client*),expire.c,"void expireatCommand(client *c) {
    expireGenericCommand(c,0,UNIT_SECONDS);
}",672.0,674.0,1.0,29.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2536,132355,pexpireCommand,1,pexpireCommand,void pexpireCommand (client*),expire.c,"void pexpireCommand(client *c) {
    expireGenericCommand(c,commandTimeSnapshot(),UNIT_MILLISECONDS);
}",677.0,679.0,1.0,49.0,3.0,0,0,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
2537,132366,pexpireatCommand,1,pexpireatCommand,void pexpireatCommand (client*),expire.c,"void pexpireatCommand(client *c) {
    expireGenericCommand(c,0,UNIT_MILLISECONDS);
}",682.0,684.0,1.0,29.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2538,132377,ttlGenericCommand,1,ttlGenericCommand,"void ttlGenericCommand (client*,int,int)",expire.c,"void ttlGenericCommand(client *c, int output_ms, int output_abs) {
    long long expire, ttl = -1;

    /* If the key does not exist at all, return -2 */
    if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
        addReplyLongLong(c,-2);
        return;
    }

    /* The key exists. Return -1 if it has no expire, or the actual
     * TTL value otherwise. */
    expire = getExpire(c->db,c->argv[1]);
    if (expire != -1) {
        ttl = output_abs ? expire : expire-commandTimeSnapshot();
        if (ttl < 0) ttl = 0;
    }
    if (ttl == -1) {
        addReplyLongLong(c,-1);
    } else {
        addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
    }
}",687.0,708.0,1.0,48.0,22.0,22,10,17,5,4,9,5,6,3,5,,0,7,6,3,3,void
2539,132468,ttlCommand,1,ttlCommand,void ttlCommand (client*),expire.c,"void ttlCommand(client *c) {
    ttlGenericCommand(c, 0, 0);
}",711.0,713.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2540,132477,pttlCommand,1,pttlCommand,void pttlCommand (client*),expire.c,"void pttlCommand(client *c) {
    ttlGenericCommand(c, 1, 0);
}",716.0,718.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2541,132486,expiretimeCommand,1,expiretimeCommand,void expiretimeCommand (client*),expire.c,"void expiretimeCommand(client *c) {
    ttlGenericCommand(c, 0, 1);
}",721.0,723.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2542,132495,pexpiretimeCommand,1,pexpiretimeCommand,void pexpiretimeCommand (client*),expire.c,"void pexpiretimeCommand(client *c) {
    ttlGenericCommand(c, 1, 1);
}",726.0,728.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2543,132504,persistCommand,1,persistCommand,void persistCommand (client*),expire.c,"void persistCommand(client *c) {
    if (lookupKeyWrite(c->db,c->argv[1])) {
        if (removeExpire(c->db,c->argv[1])) {
            signalModifiedKey(c,c->db,c->argv[1]);
            notifyKeyspaceEvent(NOTIFY_GENERIC,""persist"",c->argv[1],c->db->id);
            addReply(c,shared.cone);
            server.dirty++;
        } else {
            addReply(c,shared.czero);
        }
    } else {
        addReply(c,shared.czero);
    }
}",731.0,744.0,1.0,32.0,14.0,17,5,12,3,0,13,3,4,6,5,,0,10,2,1,1,void
2544,132581,touchCommand,1,touchCommand,void touchCommand (client*),expire.c,"void touchCommand(client *c) {
    int touched = 0;
    for (int j = 1; j < c->argc; j++)
        if (lookupKeyRead(c->db,c->argv[j]) != NULL) touched++;
    addReplyLongLong(c,touched);
}",747.0,752.0,1.0,1.0,6.0,4,3,6,3,0,2,2,2,1,1,,0,1,2,1,1,void
2545,132659,luaEngineLoadHook,1,luaEngineLoadHook,"void luaEngineLoadHook (lua_State*,lua_Debug*)",function_lua.c,"static void luaEngineLoadHook(lua_State *lua, lua_Debug *ar) {
    UNUSED(ar);
    loadCtx *load_ctx = luaGetFromRegistry(lua, REGISTRY_LOAD_CTX_NAME);
    serverAssert(load_ctx); /* Only supported inside script invocation */
    uint64_t duration = elapsedMs(load_ctx->start_time);
    if (duration > LOAD_TIMEOUT_MS) {
        lua_sethook(lua, luaEngineLoadHook, LUA_MASKLINE, 0);

        luaPushError(lua,""FUNCTION LOAD timeout"");
        luaError(lua);
    }
}",83.0,94.0,1.0,4.0,12.0,9,7,13,5,0,6,2,2,0,5,,0,3,4,2,2,void
2546,132718,luaEngineCreate,1,luaEngineCreate,"int luaEngineCreate (void*,functionLibInfo*,sds,sds*)",function_lua.c,"static int luaEngineCreate(void *engine_ctx, functionLibInfo *li, sds blob, sds *err) {
    int ret = C_ERR;
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;

    /* set load library globals */
    lua_getmetatable(lua, LUA_GLOBALSINDEX);
    lua_enablereadonlytable(lua, -1, 0); /* disable global protection */
    lua_getfield(lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);
    lua_setfield(lua, -2, ""__index"");
    lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 1); /* enable global protection */
    lua_pop(lua, 1); /* pop the metatable */

    /* compile the code */
    if (luaL_loadbuffer(lua, blob, sdslen(blob), ""@user_function"")) {
        *err = sdscatprintf(sdsempty(), ""Error compiling function: %s"", lua_tostring(lua, -1));
        lua_pop(lua, 1); /* pops the error */
        goto done;
    }
    serverAssert(lua_isfunction(lua, -1));

    loadCtx load_ctx = {
        .li = li,
        .start_time = getMonotonicUs(),
    };
    luaSaveOnRegi...",103.0,155.0,1.0,14.0,53.0,30,11,52,14,0,13,5,3,1,11,,0,8,8,4,4,int
2547,132909,luaEngineCall,1,luaEngineCall,"void luaEngineCall (scriptRunCtx*,void*,void*,robj**,size_t,robj**,size_t)",function_lua.c,"static void luaEngineCall(scriptRunCtx *run_ctx,
                          void *engine_ctx,
                          void *compiled_function,
                          robj **keys,
                          size_t nkeys,
                          robj **args,
                          size_t nargs)
{
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;
    luaFunctionCtx *f_ctx = compiled_function;

    /* Push error handler */
    lua_pushstring(lua, REGISTRY_ERROR_HANDLER_NAME);
    lua_gettable(lua, LUA_REGISTRYINDEX);

    lua_rawgeti(lua, LUA_REGISTRYINDEX, f_ctx->lua_function_ref);

    serverAssert(lua_isfunction(lua, -1));

    luaCallFunction(run_ctx, lua, keys, nkeys, args, nargs, 0);
    lua_pop(lua, 1); /* Pop error handler */
}",160.0,182.0,1.0,24.0,23.0,10,7,20,11,0,4,1,1,0,2,,0,2,14,7,7,void
2548,132976,luaEngineGetUsedMemoy,1,luaEngineGetUsedMemoy,size_t luaEngineGetUsedMemoy (void*),function_lua.c,"static size_t luaEngineGetUsedMemoy(void *engine_ctx) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    return luaMemory(lua_engine_ctx->lua);
}",184.0,187.0,1.0,1.0,4.0,2,2,3,2,0,2,1,1,0,1,,0,1,2,1,1,size_t
2549,132990,luaEngineFunctionMemoryOverhead,1,luaEngineFunctionMemoryOverhead,size_t luaEngineFunctionMemoryOverhead (void*),function_lua.c,"static size_t luaEngineFunctionMemoryOverhead(void *compiled_function) {
    return zmalloc_size(compiled_function);
}",189.0,191.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
2550,132998,luaEngineMemoryOverhead,1,luaEngineMemoryOverhead,size_t luaEngineMemoryOverhead (void*),function_lua.c,"static size_t luaEngineMemoryOverhead(void *engine_ctx) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    return zmalloc_size(lua_engine_ctx);
}",193.0,196.0,1.0,1.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,2,1,1,size_t
2551,133010,luaEngineFreeFunction,1,luaEngineFreeFunction,"void luaEngineFreeFunction (void*,void*)",function_lua.c,"static void luaEngineFreeFunction(void *engine_ctx, void *compiled_function) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;
    luaFunctionCtx *f_ctx = compiled_function;
    lua_unref(lua, f_ctx->lua_function_ref);
    zfree(f_ctx);
}",198.0,204.0,1.0,1.0,7.0,5,2,9,5,0,3,1,1,0,1,,0,2,4,2,2,void
2552,133037,luaRegisterFunctionArgsInitialize,1,luaRegisterFunctionArgsInitialize,"void luaRegisterFunctionArgsInitialize (registerFunctionArgs*,sds,sds,luaFunctionCtx*,uint64_t)",function_lua.c,"static void luaRegisterFunctionArgsInitialize(registerFunctionArgs *register_f_args,
    sds name,
    sds desc,
    luaFunctionCtx *lua_f_ctx,
    uint64_t flags)
{
    *register_f_args = (registerFunctionArgs){
        .name = name,
        .desc = desc,
        .lua_f_ctx = lua_f_ctx,
        .f_flags = flags,
    };
}",206.0,218.0,1.0,1.0,13.0,8,4,9,6,2,0,1,1,0,0,,0,0,10,5,5,void
2553,133068,luaRegisterFunctionArgsDispose,1,luaRegisterFunctionArgsDispose,"void luaRegisterFunctionArgsDispose (lua_State*,registerFunctionArgs*)",function_lua.c,"static void luaRegisterFunctionArgsDispose(lua_State *lua, registerFunctionArgs *register_f_args) {
    sdsfree(register_f_args->name);
    if (register_f_args->desc) sdsfree(register_f_args->desc);
    lua_unref(lua, register_f_args->lua_f_ctx->lua_function_ref);
    zfree(register_f_args->lua_f_ctx);
}",220.0,225.0,1.0,1.0,6.0,6,1,6,2,1,8,2,2,1,3,,0,5,4,2,2,void
2554,133217,luaRegisterFunctionReadNamedArgs,1,luaRegisterFunctionReadNamedArgs,"int luaRegisterFunctionReadNamedArgs (lua_State*,registerFunctionArgs*)",function_lua.c,"static int luaRegisterFunctionReadNamedArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    char *err = NULL;
    sds name = NULL;
    sds desc = NULL;
    luaFunctionCtx *lua_f_ctx = NULL;
    uint64_t flags = 0;
    if (!lua_istable(lua, 1)) {
        err = ""calling redis.register_function with a single argument is only applicable to Lua table (representing named arguments)."";
        goto error;
    }

    /* Iterating on all the named arguments */
    lua_pushnil(lua);
    while (lua_next(lua, -2)) {
        /* Stack now: table, key, value */
        if (!lua_isstring(lua, -2)) {
            err = ""named argument key given to redis.register_function is not a string"";
            goto error;
        }
        const char *key = lua_tostring(lua, -2);
        if (!strcasecmp(key, ""function_name"")) {
            if (!(name = luaGetStringSds(lua, -1))) {
                err = ""function_name argument given to redis.register_function must be a string"";
                goto...",271.0,351.0,1.0,61.0,81.0,24,4,41,9,1,7,16,15,1,6,,0,2,4,2,2,int
2555,133453,luaRegisterFunctionReadPositionalArgs,1,luaRegisterFunctionReadPositionalArgs,"int luaRegisterFunctionReadPositionalArgs (lua_State*,registerFunctionArgs*)",function_lua.c,"static int luaRegisterFunctionReadPositionalArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    char *err = NULL;
    sds name = NULL;
    sds desc = NULL;
    luaFunctionCtx *lua_f_ctx = NULL;
    if (!(name = luaGetStringSds(lua, 1))) {
        err = ""first argument to redis.register_function must be a string"";
        goto error;
    }

    if (!lua_isfunction(lua, 2)) {
        err = ""second argument to redis.register_function must be a function"";
        goto error;
    }

    int lua_function_ref = luaL_ref(lua, LUA_REGISTRYINDEX);

    lua_f_ctx = zmalloc(sizeof(*lua_f_ctx));
    lua_f_ctx->lua_function_ref = lua_function_ref;

    luaRegisterFunctionArgsInitialize(register_f_args, name, NULL, lua_f_ctx, 0);

    return C_OK;

error:
    if (name) sdsfree(name);
    if (desc) sdsfree(desc);
    luaPushError(lua, err);
    return C_ERR;
}",353.0,382.0,1.0,11.0,30.0,16,6,30,9,0,7,7,5,1,6,,0,3,4,2,2,int
2556,133543,luaRegisterFunctionReadArgs,1,luaRegisterFunctionReadArgs,"int luaRegisterFunctionReadArgs (lua_State*,registerFunctionArgs*)",function_lua.c,"static int luaRegisterFunctionReadArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    int argc = lua_gettop(lua);
    if (argc < 1 || argc > 2) {
        luaPushError(lua, ""wrong number of arguments to redis.register_function"");
        return C_ERR;
    }

    if (argc == 1) {
        return luaRegisterFunctionReadNamedArgs(lua, register_f_args);
    } else {
        return luaRegisterFunctionReadPositionalArgs(lua, register_f_args);
    }
}",384.0,396.0,1.0,15.0,13.0,6,6,8,3,1,2,3,3,0,2,,0,0,4,2,2,int
2557,133586,luaRegisterFunction,1,luaRegisterFunction,int luaRegisterFunction (lua_State*),function_lua.c,"static int luaRegisterFunction(lua_State *lua) {
    registerFunctionArgs register_f_args = {0};

    loadCtx *load_ctx = luaGetFromRegistry(lua, REGISTRY_LOAD_CTX_NAME);
    if (!load_ctx) {
        luaPushError(lua, ""redis.register_function can only be called on FUNCTION LOAD command"");
        return luaError(lua);
    }

    if (luaRegisterFunctionReadArgs(lua, &register_f_args) != C_OK) {
        return luaError(lua);
    }

    sds err = NULL;
    if (functionLibCreateFunction(register_f_args.name, register_f_args.lua_f_ctx, load_ctx->li, register_f_args.desc, register_f_args.f_flags, &err) != C_OK) {
        luaRegisterFunctionArgsDispose(lua, &register_f_args);
        luaPushError(lua, err);
        sdsfree(err);
        return luaError(lua);
    }

    return 0;
}",398.0,420.0,1.0,48.0,23.0,15,7,23,5,0,15,4,4,7,10,,0,8,2,1,1,int
2558,133669,luaEngineInitEngine,1,luaEngineInitEngine,int luaEngineInitEngine (void),function_lua.c,"int luaEngineInitEngine(void) {
    luaEngineCtx *lua_engine_ctx = zmalloc(sizeof(*lua_engine_ctx));
    lua_engine_ctx->lua = lua_open();

    luaRegisterRedisAPI(lua_engine_ctx->lua);

    /* Register the library commands table and fields and store it to registry */
    lua_newtable(lua_engine_ctx->lua); /* load library globals */
    lua_newtable(lua_engine_ctx->lua); /* load library `redis` table */

    lua_pushstring(lua_engine_ctx->lua, ""register_function"");
    lua_pushcfunction(lua_engine_ctx->lua, luaRegisterFunction);
    lua_settable(lua_engine_ctx->lua, -3);

    luaRegisterLogFunction(lua_engine_ctx->lua);
    luaRegisterVersion(lua_engine_ctx->lua);

    luaSetErrorMetatable(lua_engine_ctx->lua);
    lua_setfield(lua_engine_ctx->lua, -2, REDIS_API_NAME);

    luaSetErrorMetatable(lua_engine_ctx->lua);
    luaSetTableProtectionRecursively(lua_engine_ctx->lua); /* protect load library globals */
    lua_setfield(lua_engine_ctx->lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);...",423.0,505.0,1.0,42.0,83.0,58,7,58,12,1,45,1,1,0,12,,0,35,2,1,1,int
2559,133955,functionsVerifyName,1,functionsVerifyName,int functionsVerifyName (sds),functions.c,"static int functionsVerifyName(sds name) {
    if (sdslen(name) == 0) {
        return C_ERR;
    }
    for (size_t i = 0 ; i < sdslen(name) ; ++i) {
        char curr_char = name[i];
        if ((curr_char >= 'a' && curr_char <= 'z') ||
            (curr_char >= 'A' && curr_char <= 'Z') ||
            (curr_char >= '0' && curr_char <= '9') ||
            (curr_char == '_'))
        {
            continue;
        }
        return C_ERR;
    }
    return C_OK;
}",875.0,891.0,1.0,15.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
2560,134037,functionMallocSize,1,functionMallocSize,size_t functionMallocSize (functionInfo*),functions.c,"static size_t functionMallocSize(functionInfo *fi) {
    return zmalloc_size(fi) + sdsZmallocSize(fi->name)
            + (fi->desc ? sdsZmallocSize(fi->desc) : 0)
            + fi->li->ei->engine->get_function_memory_overhead(fi->function);
}",125.0,129.0,1.0,1.0,5.0,12,3,6,1,2,9,1,1,0,4,,0,5,2,1,1,size_t
2561,134074,libraryMallocSize,1,libraryMallocSize,size_t libraryMallocSize (functionLibInfo*),functions.c,"static size_t libraryMallocSize(functionLibInfo *li) {
    return zmalloc_size(li) + sdsZmallocSize(li->name)
            + sdsZmallocSize(li->code);
}",131.0,134.0,1.0,1.0,4.0,4,2,3,1,2,5,1,1,0,3,,0,2,2,1,1,size_t
2562,134166,engineLibraryFree,1,engineLibraryFree,void engineLibraryFree (functionLibInfo*),functions.c,"static void engineLibraryFree(functionLibInfo* li) {
    if (!li) {
        return;
    }
    dictRelease(li->functions);
    sdsfree(li->name);
    sdsfree(li->code);
    zfree(li);
}",158.0,166.0,1.0,1.0,9.0,4,2,5,1,3,7,2,2,0,4,,0,3,2,1,1,void
2563,134204,functionsLibCtxClear,1,functionsLibCtxClear,void functionsLibCtxClear (functionsLibCtx*),functions.c,"void functionsLibCtxClear(functionsLibCtx *lib_ctx) {
    dictEmpty(lib_ctx->functions, NULL);
    dictEmpty(lib_ctx->libraries, NULL);
    dictIterator *iter = dictGetIterator(lib_ctx->engines_stats);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionsLibEngineStats *stats = dictGetVal(entry);
        stats->n_functions = 0;
        stats->n_lib = 0;
    }
    dictReleaseIterator(iter);
    curr_functions_lib_ctx->cache_memory = 0;
}",174.0,186.0,1.0,1.0,13.0,13,2,16,6,2,13,2,2,1,6,,0,10,2,1,1,void
2564,134258,functionsLibCtxClearCurrent,1,functionsLibCtxClearCurrent,void functionsLibCtxClearCurrent (int),functions.c,"void functionsLibCtxClearCurrent(int async) {
    if (async) {
        functionsLibCtx *old_l_ctx = curr_functions_lib_ctx;
        curr_functions_lib_ctx = functionsLibCtxCreate();
        freeFunctionsAsync(old_l_ctx);
    } else {
        functionsLibCtxClear(curr_functions_lib_ctx);
    }
}",188.0,196.0,1.0,1.0,9.0,2,1,5,3,2,4,2,2,0,2,,0,3,2,1,1,void
2565,134279,functionsLibCtxFree,1,functionsLibCtxFree,void functionsLibCtxFree (functionsLibCtx*),functions.c,"void functionsLibCtxFree(functionsLibCtx *functions_lib_ctx) {
    functionsLibCtxClear(functions_lib_ctx);
    dictRelease(functions_lib_ctx->functions);
    dictRelease(functions_lib_ctx->libraries);
    dictRelease(functions_lib_ctx->engines_stats);
    zfree(functions_lib_ctx);
}",199.0,205.0,1.0,1.0,7.0,3,1,5,1,4,8,1,1,0,5,,0,3,2,1,1,void
2566,134300,functionsLibCtxSwapWithCurrent,1,functionsLibCtxSwapWithCurrent,void functionsLibCtxSwapWithCurrent (functionsLibCtx*),functions.c,"void functionsLibCtxSwapWithCurrent(functionsLibCtx *new_lib_ctx) {
    functionsLibCtxFree(curr_functions_lib_ctx);
    curr_functions_lib_ctx = new_lib_ctx;
}",209.0,212.0,1.0,1.0,4.0,1,1,3,2,2,3,1,1,0,1,,0,2,2,1,1,void
2567,134310,functionsLibCtxGetCurrent,1,functionsLibCtxGetCurrent,functionsLibCtx functionsLibCtxGetCurrent (void),functions.c,"functionsLibCtx* functionsLibCtxGetCurrent(void) {
    return curr_functions_lib_ctx;
}",215.0,217.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,0,,0,1,2,1,1,functionsLibCtx
2568,134317,functionsLibCtxCreate,1,functionsLibCtxCreate,functionsLibCtx functionsLibCtxCreate (void),functions.c,"functionsLibCtx* functionsLibCtxCreate(void) {
    functionsLibCtx *ret = zmalloc(sizeof(functionsLibCtx));
    ret->libraries = dictCreate(&librariesDictType);
    ret->functions = dictCreate(&functionDictType);
    ret->engines_stats = dictCreate(&engineStatsDictType);
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        engineInfo *ei = dictGetVal(entry);
        functionsLibEngineStats *stats = zcalloc(sizeof(*stats));
        dictAdd(ret->engines_stats, ei->name, stats);
    }
    dictReleaseIterator(iter);
    ret->cache_memory = 0;
    return ret;
}",220.0,235.0,1.0,1.0,16.0,22,5,24,11,4,20,2,2,1,10,,0,18,2,1,1,functionsLibCtx
2569,134393,functionLibCreateFunction,1,functionLibCreateFunction,"int functionLibCreateFunction (sds,void*,functionLibInfo*,sds,uint64_t,sds*)",functions.c,"int functionLibCreateFunction(sds name, void *function, functionLibInfo *li, sds desc, uint64_t f_flags, sds *err) {
    if (functionsVerifyName(name) != C_OK) {
        *err = sdsnew(""Library names can only contain letters, numbers, or underscores(_) and must be at least one character long"");
        return C_ERR;
    }

    if (dictFetchValue(li->functions, name)) {
        *err = sdsnew(""Function already exists in the library"");
        return C_ERR;
    }

    functionInfo *fi = zmalloc(sizeof(*fi));
    *fi = (functionInfo) {
        .name = name,
        .function = function,
        .li = li,
        .desc = desc,
        .f_flags = f_flags,
    };

    int res = dictAdd(li->functions, fi->name, fi);
    serverAssert(res == DICT_OK);

    return C_OK;
}",246.0,270.0,1.0,37.0,25.0,28,12,23,8,1,10,3,3,3,7,,0,9,12,6,6,int
2570,134502,engineLibraryCreate,1,engineLibraryCreate,"functionLibInfo engineLibraryCreate (sds,engineInfo*,sds)",functions.c,"static functionLibInfo* engineLibraryCreate(sds name, engineInfo *ei, sds code) {
    functionLibInfo *li = zmalloc(sizeof(*li));
    *li = (functionLibInfo) {
        .name = sdsdup(name),
        .functions = dictCreate(&libraryFunctionDictType),
        .ei = ei,
        .code = sdsdup(code),
    };
    return li;
}",272.0,281.0,1.0,1.0,10.0,12,6,12,6,1,5,1,1,0,4,,0,5,6,3,3,functionLibInfo
2571,134544,libraryUnlink,1,libraryUnlink,"void libraryUnlink (functionsLibCtx*,functionLibInfo*)",functions.c,"static void libraryUnlink(functionsLibCtx *lib_ctx, functionLibInfo* li) {
    dictIterator *iter = dictGetIterator(li->functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionInfo *fi = dictGetVal(entry);
        int ret = dictDelete(lib_ctx->functions, fi->name);
        serverAssert(ret == DICT_OK);
        lib_ctx->cache_memory -= functionMallocSize(fi);
    }
    dictReleaseIterator(iter);
    entry = dictUnlink(lib_ctx->libraries, li->name);
    dictSetVal(lib_ctx->libraries, entry, NULL);
    dictFreeUnlinkedEntry(lib_ctx->libraries, entry);
    lib_ctx->cache_memory -= libraryMallocSize(li);

    /* update stats */
    functionsLibEngineStats *stats = dictFetchValue(lib_ctx->engines_stats, li->ei->name);
    serverAssert(stats);
    stats->n_lib--;
    stats->n_functions -= dictSize(li->functions);
}",283.0,303.0,1.0,8.0,21.0,42,11,35,8,2,29,2,2,1,13,,0,22,4,2,2,void
2572,134687,libraryLink,1,libraryLink,"void libraryLink (functionsLibCtx*,functionLibInfo*)",functions.c,"static void libraryLink(functionsLibCtx *lib_ctx, functionLibInfo* li) {
    dictIterator *iter = dictGetIterator(li->functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionInfo *fi = dictGetVal(entry);
        dictAdd(lib_ctx->functions, fi->name, fi);
        lib_ctx->cache_memory += functionMallocSize(fi);
    }
    dictReleaseIterator(iter);

    dictAdd(lib_ctx->libraries, li->name, li);
    lib_ctx->cache_memory += libraryMallocSize(li);

    /* update stats */
    functionsLibEngineStats *stats = dictFetchValue(lib_ctx->engines_stats, li->ei->name);
    serverAssert(stats);
    stats->n_lib++;
    stats->n_functions += dictSize(li->functions);
}",305.0,323.0,1.0,4.0,19.0,33,10,29,7,4,24,2,2,1,10,,0,18,4,2,2,void
2573,134800,libraryJoin,1,libraryJoin,"int libraryJoin (functionsLibCtx*,functionsLibCtx*,int,sds*)",functions.c,"static int libraryJoin(functionsLibCtx *functions_lib_ctx_dst, functionsLibCtx *functions_lib_ctx_src, int replace, sds *err) {
    int ret = C_ERR;
    dictIterator *iter = NULL;
    /* Stores the libraries we need to replace in case a revert is required.
     * Only initialized when needed */
    list *old_libraries_list = NULL;
    dictEntry *entry = NULL;
    iter = dictGetIterator(functions_lib_ctx_src->libraries);
    while ((entry = dictNext(iter))) {
        functionLibInfo *li = dictGetVal(entry);
        functionLibInfo *old_li = dictFetchValue(functions_lib_ctx_dst->libraries, li->name);
        if (old_li) {
            if (!replace) {
                /* library already exists, failed the restore. */
                *err = sdscatfmt(sdsempty(), ""Library %s already exists"", li->name);
                goto done;
            } else {
                if (!old_libraries_list) {
                    old_libraries_list = listCreate();
                    listSetFreeMethod(old_li...",331.0,403.0,1.0,14.0,73.0,43,6,76,13,0,40,13,16,7,26,,0,29,8,4,4,int
2574,135043,functionsRegisterEngine,1,functionsRegisterEngine,"int functionsRegisterEngine (char*,engine*)",functions.c,"int functionsRegisterEngine(const char *engine_name, engine *engine) {
    sds engine_name_sds = sdsnew(engine_name);
    if (dictFetchValue(engines, engine_name_sds)) {
        serverLog(LL_WARNING, ""Same engine was registered twice"");
        sdsfree(engine_name_sds);
        return C_ERR;
    }

    client *c = createClient(NULL);
    c->flags |= (CLIENT_DENY_BLOCKING | CLIENT_SCRIPT);
    engineInfo *ei = zmalloc(sizeof(*ei));
    *ei = (engineInfo ) { .name = engine_name_sds, .engine = engine, .c = c,};

    dictAdd(engines, engine_name_sds, ei);

    engine_cache_memory += zmalloc_size(ei) + sdsZmallocSize(ei->name) +
            zmalloc_size(engine) +
            engine->get_engine_memory_overhead(engine->engine_ctx);

    return C_OK;
}",409.0,429.0,1.0,8.0,21.0,27,14,27,10,1,17,2,2,2,11,,0,10,4,2,2,int
2575,135157,functionStatsCommand,1,functionStatsCommand,void functionStatsCommand (client*),functions.c,"void functionStatsCommand(client *c) {
    if (scriptIsRunning() && scriptIsEval()) {
        addReplyErrorObject(c, shared.slowevalerr);
        return;
    }

    addReplyMapLen(c, 2);

    addReplyBulkCString(c, ""running_script"");
    if (!scriptIsRunning()) {
        addReplyNull(c);
    } else {
        addReplyMapLen(c, 3);
        addReplyBulkCString(c, ""name"");
        addReplyBulkCString(c, scriptCurrFunction());
        addReplyBulkCString(c, ""command"");
        client *script_client = scriptGetCaller();
        addReplyArrayLen(c, script_client->argc);
        for (int i = 0 ; i < script_client->argc ; ++i) {
            addReplyBulkCBuffer(c, script_client->argv[i]->ptr, sdslen(script_client->argv[i]->ptr));
        }
        addReplyBulkCString(c, ""duration_ms"");
        addReplyLongLong(c, scriptRunDuration());
    }

    addReplyBulkCString(c, ""engines"");
    addReplyMapLen(c, dictSize(engines));
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry ...",434.0,474.0,1.0,22.0,41.0,18,7,31,9,0,32,4,4,4,20,,0,19,2,1,1,void
2576,135320,functionListReplyFlags,1,functionListReplyFlags,"void functionListReplyFlags (client*,functionInfo*)",functions.c,"static void functionListReplyFlags(client *c, functionInfo *fi) {
    /* First count the number of flags we have */
    int flagcount = 0;
    for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
        if (fi->f_flags & flag->flag) {
            ++flagcount;
        }
    }

    addReplySetLen(c, flagcount);

    for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
        if (fi->f_flags & flag->flag) {
            addReplyStatus(c, flag->str);
        }
    }
}",476.0,492.0,1.0,1.0,17.0,13,4,16,5,1,4,5,7,2,2,,0,2,4,2,2,void
2577,135382,functionListCommand,1,functionListCommand,void functionListCommand (client*),functions.c,"void functionListCommand(client *c) {
    int with_code = 0;
    sds library_name = NULL;
    for (int i = 2 ; i < c->argc ; ++i) {
        robj *next_arg = c->argv[i];
        if (!with_code && !strcasecmp(next_arg->ptr, ""withcode"")) {
            with_code = 1;
            continue;
        }
        if (!library_name && !strcasecmp(next_arg->ptr, ""libraryname"")) {
            if (i >= c->argc - 1) {
                addReplyError(c, ""library name argument was not given"");
                return;
            }
            library_name = c->argv[++i]->ptr;
            continue;
        }
        addReplyErrorSds(c, sdscatfmt(sdsempty(), ""Unknown argument %s"", next_arg->ptr));
        return;
    }
    size_t reply_len = 0;
    void *len_ptr = NULL;
    if (library_name) {
        len_ptr = addReplyDeferredLen(c);
    } else {
        /* If no pattern is asked we know the reply len and we can just set it */
        addReplyArrayLen(c, dictSize(curr_functions_lib_ctx->libraries));
   ...",508.0,581.0,1.0,28.0,74.0,65,11,89,15,0,61,16,24,10,38,,0,40,2,1,1,void
2578,135707,functionDeleteCommand,1,functionDeleteCommand,void functionDeleteCommand (client*),functions.c,"void functionDeleteCommand(client *c) {
    robj *function_name = c->argv[2];
    functionLibInfo *li = dictFetchValue(curr_functions_lib_ctx->libraries, function_name->ptr);
    if (!li) {
        addReplyError(c, ""Library not found"");
        return;
    }

    libraryUnlink(curr_functions_lib_ctx, li);
    engineLibraryFree(li);
    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReply(c, shared.ok);
}",586.0,600.0,1.0,1.0,15.0,10,6,13,6,0,9,2,2,0,5,,0,5,2,1,1,void
2579,135752,functionKillCommand,1,functionKillCommand,void functionKillCommand (client*),functions.c,"void functionKillCommand(client *c) {
    scriptKill(c, 0);
}",603.0,605.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2580,135760,fcallGetCommandFlags,1,fcallGetCommandFlags,"uint64_t fcallGetCommandFlags (client*,uint64_t)",functions.c,"uint64_t fcallGetCommandFlags(client *c, uint64_t cmd_flags) {
    robj *function_name = c->argv[1];
    c->cur_script = dictFind(curr_functions_lib_ctx->functions, function_name->ptr);
    if (!c->cur_script)
        return cmd_flags;
    functionInfo *fi = dictGetVal(c->cur_script);
    uint64_t script_flags = fi->f_flags;
    return scriptFlagsToCmdFlags(cmd_flags, script_flags);
}",609.0,617.0,1.0,1.0,9.0,13,4,13,6,1,10,2,2,1,3,,0,9,4,2,2,uint64_t
2581,135810,fcallCommandGeneric,1,fcallCommandGeneric,"void fcallCommandGeneric (client*,int)",functions.c,"static void fcallCommandGeneric(client *c, int ro) {
    /* Functions need to be fed to monitors before the commands they execute. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);

    robj *function_name = c->argv[1];
    dictEntry *de = c->cur_script;
    if (!de)
        de = dictFind(curr_functions_lib_ctx->functions, function_name->ptr);
    if (!de) {
        addReplyError(c, ""Function not found"");
        return;
    }
    functionInfo *fi = dictGetVal(de);
    engine *engine = fi->li->ei->engine;

    long long numkeys;
    /* Get the number of arguments that are keys */
    if (getLongLongFromObject(c->argv[2], &numkeys) != C_OK) {
        addReplyError(c, ""Bad number of keys provided"");
        return;
    }
    if (numkeys > (c->argc - 3)) {
        addReplyError(c, ""Number of keys can't be greater than number of args"");
        return;
    } else if (numkeys < 0) {
        addReplyError(c, ""Number of keys can't be negative"");
        return;
 ...",619.0,656.0,1.0,55.0,38.0,47,10,42,10,2,28,6,6,7,10,,0,22,4,2,2,void
2582,135986,fcallCommand,1,fcallCommand,void fcallCommand (client*),functions.c,"void fcallCommand(client *c) {
    fcallCommandGeneric(c, 0);
}",661.0,663.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2583,135994,fcallroCommand,1,fcallroCommand,void fcallroCommand (client*),functions.c,"void fcallroCommand(client *c) {
    fcallCommandGeneric(c, 1);
}",668.0,670.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2584,136002,functionDumpCommand,1,functionDumpCommand,void functionDumpCommand (client*),functions.c,"void functionDumpCommand(client *c) {
    unsigned char buf[2];
    uint64_t crc;
    rio payload;
    rioInitWithBuffer(&payload, sdsempty());

    rdbSaveFunctions(&payload);

    /* RDB version */
    buf[0] = RDB_VERSION & 0xff;
    buf[1] = (RDB_VERSION >> 8) & 0xff;
    payload.io.buffer.ptr = sdscatlen(payload.io.buffer.ptr, buf, 2);

    /* CRC64 */
    crc = crc64(0, (unsigned char*) payload.io.buffer.ptr,
                sdslen(payload.io.buffer.ptr));
    memrev64ifbe(&crc);
    payload.io.buffer.ptr = sdscatlen(payload.io.buffer.ptr, &crc, 8);

    addReplyBulkSds(c, payload.io.buffer.ptr);
}",690.0,710.0,1.0,13.0,21.0,37,7,17,4,0,9,1,1,0,9,,0,5,2,1,1,void
2585,136111,functionRestoreCommand,1,functionRestoreCommand,void functionRestoreCommand (client*),functions.c,"void functionRestoreCommand(client *c) {
    if (c->argc > 4) {
        addReplySubcommandSyntaxError(c);
        return;
    }

    restorePolicy restore_replicy = restorePolicy_Append; /* default policy: APPEND */
    sds data = c->argv[2]->ptr;
    size_t data_len = sdslen(data);
    rio payload;
    sds err = NULL;

    if (c->argc == 4) {
        const char *restore_policy_str = c->argv[3]->ptr;
        if (!strcasecmp(restore_policy_str, ""append"")) {
            restore_replicy = restorePolicy_Append;
        } else if (!strcasecmp(restore_policy_str, ""replace"")) {
            restore_replicy = restorePolicy_Replace;
        } else if (!strcasecmp(restore_policy_str, ""flush"")) {
            restore_replicy = restorePolicy_Flush;
        } else {
            addReplyError(c, ""Wrong restore policy given, value should be either FLUSH, APPEND or REPLACE."");
            return;
        }
    }

    uint16_t rdbver;
    if (verifyDumpPayload((unsigned char*)data, data_len, &rdbver) ...",722.0,802.0,1.0,70.0,81.0,45,13,49,14,0,19,18,21,5,15,,0,13,2,1,1,void
2586,136358,functionFlushCommand,1,functionFlushCommand,void functionFlushCommand (client*),functions.c,"void functionFlushCommand(client *c) {
    if (c->argc > 3) {
        addReplySubcommandSyntaxError(c);
        return;
    }
    int async = 0;
    if (c->argc == 3 && !strcasecmp(c->argv[2]->ptr,""sync"")) {
        async = 0;
    } else if (c->argc == 3 && !strcasecmp(c->argv[2]->ptr,""async"")) {
        async = 1;
    } else if (c->argc == 2) {
        async = server.lazyfree_lazy_user_flush ? 1 : 0;
    } else {
        addReplyError(c,""FUNCTION FLUSH only supports SYNC|ASYNC option"");
        return;
    }

    functionsLibCtxClearCurrent(async);

    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReply(c,shared.ok);
}",805.0,828.0,1.0,1.0,24.0,14,9,10,4,0,6,3,3,3,3,,0,3,2,1,1,void
2587,136455,functionHelpCommand,1,functionHelpCommand,void functionHelpCommand (client*),functions.c,"void functionHelpCommand(client *c) {
    const char *help[] = {
""LOAD [REPLACE] <FUNCTION CODE>"",
""    Create a new library with the given library name and code."",
""DELETE <LIBRARY NAME>"",
""    Delete the given library."",
""LIST [LIBRARYNAME PATTERN] [WITHCODE]"",
""    Return general information on all the libraries:"",
""    * Library name"",
""    * The engine used to run the Library"",
""    * Library description"",
""    * Functions list"",
""    * Library code (if WITHCODE is given)"",
""    It also possible to get only function that matches a pattern using LIBRARYNAME argument."",
""STATS"",
""    Return information about the current function running:"",
""    * Function name"",
""    * Command used to run the function"",
""    * Duration in MS that the function is running"",
""    If no function is running, return nil"",
""    In addition, returns a list of available engines."",
""KILL"",
""    Kill the current running function."",
""FLUSH [ASYNC|SYNC]"",
""    Delete all the libraries."",
""    When called with...",831.0,872.0,1.0,1.0,42.0,2,2,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
2588,136579,functionExtractLibMetaData,1,functionExtractLibMetaData,"int functionExtractLibMetaData (sds,functionsLibMataData*,sds*)",functions.c,"int functionExtractLibMetaData(sds payload, functionsLibMataData *md, sds *err) {
    sds name = NULL;
    sds desc = NULL;
    sds engine = NULL;
    sds code = NULL;
    if (strncmp(payload, ""#!"", 2) != 0) {
        *err = sdsnew(""Missing library metadata"");
        return C_ERR;
    }
    char *shebang_end = strchr(payload, '\n');
    if (shebang_end == NULL) {
        *err = sdsnew(""Invalid library metadata"");
        return C_ERR;
    }
    size_t shebang_len = shebang_end - payload;
    sds shebang = sdsnewlen(payload, shebang_len);
    int numparts;
    sds *parts = sdssplitargs(shebang, &numparts);
    sdsfree(shebang);
    if (!parts || numparts == 0) {
        *err = sdsnew(""Invalid library metadata"");
        sdsfreesplitres(parts, numparts);
        return C_ERR;
    }
    engine = sdsdup(parts[0]);
    sdsrange(engine, 2, -1);
    for (int i = 1 ; i < numparts ; ++i) {
        sds part = parts[i];
        if (strncasecmp(part, ""name="", 5) == 0) {
            if (name) {...",893.0,954.0,1.0,15.0,62.0,49,12,69,15,1,27,16,15,0,24,,0,17,6,3,3,int
2589,136815,functionFreeLibMetaData,1,functionFreeLibMetaData,void functionFreeLibMetaData (functionsLibMataData*),functions.c,"void functionFreeLibMetaData(functionsLibMataData *md) {
    if (md->code) sdsfree(md->code);
    if (md->name) sdsfree(md->name);
    if (md->engine) sdsfree(md->engine);
}",956.0,960.0,1.0,1.0,5.0,6,1,6,1,2,9,4,4,3,3,,0,6,2,1,1,void
2590,136847,functionsCreateWithLibraryCtx,1,functionsCreateWithLibraryCtx,"sds functionsCreateWithLibraryCtx (sds,int,sds*,functionsLibCtx*)",functions.c,"sds functionsCreateWithLibraryCtx(sds code, int replace, sds* err, functionsLibCtx *lib_ctx) {
    dictIterator *iter = NULL;
    dictEntry *entry = NULL;
    functionLibInfo *new_li = NULL;
    functionLibInfo *old_li = NULL;
    functionsLibMataData md = {0};
    if (functionExtractLibMetaData(code, &md, err) != C_OK) {
        return NULL;
    }

    if (functionsVerifyName(md.name)) {
        *err = sdsnew(""Library names can only contain letters, numbers, or underscores(_) and must be at least one character long"");
        goto error;
    }

    engineInfo *ei = dictFetchValue(engines, md.engine);
    if (!ei) {
        *err = sdscatfmt(sdsempty(), ""Engine '%S' not found"", md.engine);
        goto error;
    }
    engine *engine = ei->engine;

    old_li = dictFetchValue(lib_ctx->libraries, md.name);
    if (old_li && !replace) {
        old_li = NULL;
        *err = sdscatfmt(sdsempty(), ""Library '%S' already exists"", md.name);
        goto error;
    }

    if (old_li) {
     ...",964.0,1038.0,1.0,54.0,75.0,61,12,80,15,2,47,20,15,13,27,,0,38,8,4,4,sds
2591,137107,functionLoadCommand,1,functionLoadCommand,void functionLoadCommand (client*),functions.c,"void functionLoadCommand(client *c) {
    int replace = 0;
    int argc_pos = 2;
    while (argc_pos < c->argc - 1) {
        robj *next_arg = c->argv[argc_pos++];
        if (!strcasecmp(next_arg->ptr, ""replace"")) {
            replace = 1;
            continue;
        }
        addReplyErrorFormat(c, ""Unknown option given: %s"", (char*)next_arg->ptr);
        return;
    }

    if (argc_pos >= c->argc) {
        addReplyError(c, ""Function code is missing"");
        return;
    }

    robj *code = c->argv[argc_pos];
    sds err = NULL;
    sds library_name = NULL;
    if (!(library_name = functionsCreateWithLibraryCtx(code->ptr, replace, &err, curr_functions_lib_ctx)))
    {
        addReplyErrorSds(c, err);
        return;
    }
    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReplyBulkSds(c, library_name);
}",1045.0,1075.0,1.0,1.0,31.0,27,11,31,10,0,10,6,6,4,5,,0,6,2,1,1,void
2592,137210,functionsMemory,1,functionsMemory,unsigned long functionsMemory (void),functions.c,"unsigned long functionsMemory(void) {
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry = NULL;
    size_t engines_nemory = 0;
    while ((entry = dictNext(iter))) {
        engineInfo *ei = dictGetVal(entry);
        engine *engine = ei->engine;
        engines_nemory += engine->get_used_memory(engine->engine_ctx);
    }
    dictReleaseIterator(iter);

    return engines_nemory;
}",1078.0,1090.0,1.0,1.0,13.0,10,3,16,7,1,8,2,2,1,5,,0,6,2,1,1,unsigned long
2593,137258,functionsMemoryOverhead,1,functionsMemoryOverhead,unsigned long functionsMemoryOverhead (void),functions.c,"unsigned long functionsMemoryOverhead(void) {
    size_t memory_overhead = dictMemUsage(engines);
    memory_overhead += dictMemUsage(curr_functions_lib_ctx->functions);
    memory_overhead += sizeof(functionsLibCtx);
    memory_overhead += curr_functions_lib_ctx->cache_memory;
    memory_overhead += engine_cache_memory;

    return memory_overhead;
}",1093.0,1101.0,1.0,1.0,9.0,8,4,11,5,1,8,1,1,0,2,,0,7,2,1,1,unsigned long
2594,137288,functionsNum,1,functionsNum,unsigned long functionsNum (void),functions.c,"unsigned long functionsNum(void) {
    return dictSize(curr_functions_lib_ctx->functions);
}",1104.0,1106.0,1.0,11.0,3.0,8,3,3,1,1,6,1,1,0,0,,0,6,2,1,1,unsigned long
2595,137314,functionsLibNum,1,functionsLibNum,unsigned long functionsLibNum (void),functions.c,"unsigned long functionsLibNum(void) {
    return dictSize(curr_functions_lib_ctx->libraries);
}",1108.0,1110.0,1.0,11.0,3.0,8,3,3,1,1,6,1,1,0,0,,0,6,2,1,1,unsigned long
2596,137340,functionsLibGet,1,functionsLibGet,dict functionsLibGet (void),functions.c,"dict* functionsLibGet(void) {
    return curr_functions_lib_ctx->libraries;
}",1112.0,1114.0,1.0,1.0,3.0,1,1,1,1,2,2,1,1,0,0,,0,2,2,1,1,dict
2597,137349,functionsLibCtxfunctionsLen,1,functionsLibCtxfunctionsLen,size_t functionsLibCtxfunctionsLen (functionsLibCtx*),functions.c,"size_t functionsLibCtxfunctionsLen(functionsLibCtx *functions_ctx) {
    return dictSize(functions_ctx->functions);
}",1116.0,1118.0,1.0,11.0,3.0,8,3,3,1,3,3,1,1,0,0,,0,3,2,1,1,size_t
2598,137375,functionsInit,1,functionsInit,int functionsInit (void),functions.c,"int functionsInit(void) {
    engines = dictCreate(&engineDictType);

    if (luaEngineInitEngine() != C_OK) {
        return C_ERR;
    }

    /* Must be initialized after engines initialization */
    curr_functions_lib_ctx = functionsLibCtxCreate();

    return C_OK;
}",1122.0,1133.0,1.0,33.0,12.0,5,4,3,3,1,6,2,2,1,3,,0,6,2,1,1,int
2599,137419,create,1,engine.create,"int engine.create (void*,functionLibInfo*,sds,sds*)",functions.h,"int (*create)(void *engine_ctx, functionLibInfo *li, sds code, sds *err);",58.0,58.0,9.0,76.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
2600,137427,call,1,engine.call,"void engine.call (scriptRunCtx*,void*,void*,robj**,size_t,robj**,size_t)",server.c,"void call(client *c, int flags) {
    long long dirty;
    uint64_t client_old_flags = c->flags;
    struct redisCommand *real_cmd = c->realcmd;
    client *prev_client = server.executing_client;
    server.executing_client = c;

    /* When call() is issued during loading the AOF we don't want commands called
     * from module, exec or LUA to go into the slowlog or to populate statistics. */
    int update_command_stats = !isAOFLoadingContext();

    /* We want to be aware of a client which is making a first time attempt to execute this command
     * and a client which is reprocessing command again (after being unblocked).
     * Blocked clients can be blocked in different places and not always it means the call() function has been
     * called. For example this is required for avoiding double logging to monitors.*/
    int reprocessing_command = flags & CMD_CALL_REPROCESSING;

    /* Initialization: clear the flags that must be set by the command on
     * demand, and initializ...",3475.0,3694.0,1.0,32.0,220.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2601,137438,get_used_memory,1,engine.get_used_memory,size_t engine.get_used_memory (void*),functions.h,size_t (*get_used_memory)(void *engine_ctx);,69.0,69.0,12.0,47.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
2602,137443,get_function_memory_overhead,1,engine.get_function_memory_overhead,size_t engine.get_function_memory_overhead (void*),functions.h,size_t (*get_function_memory_overhead)(void *compiled_function);,74.0,74.0,12.0,67.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
2603,137448,get_engine_memory_overhead,1,engine.get_engine_memory_overhead,size_t engine.get_engine_memory_overhead (void*),functions.h,size_t (*get_engine_memory_overhead)(void *engine_ctx);,77.0,77.0,12.0,58.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
2604,137584,zzlFirstInRange,1,zzlFirstInRange,"unsigned char* zzlFirstInRange (unsigned char*,zrangespec*)",t_zset.c,"unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;
    double score;

    /* If everything is out of range, return early. */
    if (!zzlIsInRange(zl,range)) return NULL;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        score = zzlGetScore(sptr);
        if (zslValueGteMin(score,range)) {
            /* Check if score <= max. */
            if (zslValueLteMax(score,range))
                return eptr;
            return NULL;
        }

        /* Move to next element. */
        eptr = lpNext(zl,sptr);
    }

    return NULL;
}",858.0,882.0,1.0,8.0,25.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,unsigned char*
2605,137590,zslValueLteMax,1,zslValueLteMax,"int zslValueLteMax (double,zrangespec*)",t_zset.c,"int zslValueLteMax(double value, zrangespec *spec) {
    return spec->maxex ? (value < spec->max) : (value <= spec->max);
}",310.0,312.0,1.0,1.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int
2606,137596,geoArrayCreate,1,geoArrayCreate,geoArray geoArrayCreate (void),geo.c,"geoArray *geoArrayCreate(void) {
    geoArray *ga = zmalloc(sizeof(*ga));
    /* It gets allocated on first geoArrayAppend() call. */
    ga->array = NULL;
    ga->buckets = 0;
    ga->used = 0;
    return ga;
}",54.0,61.0,1.0,1.0,8.0,9,4,7,2,1,4,1,1,0,1,,0,4,2,1,1,geoArray
2607,137625,geoArrayAppend,1,geoArrayAppend,"geoPoint geoArrayAppend (geoArray*,double*,double,double,char*)",geo.c,"geoPoint *geoArrayAppend(geoArray *ga, double *xy, double dist,
                         double score, char *member)
{
    if (ga->used == ga->buckets) {
        ga->buckets = (ga->buckets == 0) ? 8 : ga->buckets*2;
        ga->array = zrealloc(ga->array,sizeof(geoPoint)*ga->buckets);
    }
    geoPoint *gp = ga->array+ga->used;
    gp->longitude = xy[0];
    gp->latitude = xy[1];
    gp->dist = dist;
    gp->member = member;
    gp->score = score;
    ga->used++;
    return gp;
}",64.0,79.0,1.0,1.0,16.0,34,9,24,7,1,17,2,2,2,1,,0,17,10,5,5,geoPoint
2608,137718,geoArrayFree,1,geoArrayFree,void geoArrayFree (geoArray*),geo.c,"void geoArrayFree(geoArray *ga) {
    size_t i;
    for (i = 0; i < ga->used; i++) sdsfree(ga->array[i].member);
    zfree(ga->array);
    zfree(ga);
}",82.0,87.0,1.0,1.0,6.0,4,3,5,2,2,4,2,2,1,2,,0,2,2,1,1,void
2609,137750,decodeGeohash,1,decodeGeohash,"int decodeGeohash (double,double*)",geo.c,"int decodeGeohash(double bits, double *xy) {
    GeoHashBits hash = { .bits = (uint64_t)bits, .step = GEO_STEP_MAX };
    return geohashDecodeToLongLatWGS84(hash, xy);
}",92.0,95.0,1.0,57.0,4.0,5,3,6,4,4,1,1,1,0,1,,0,0,4,2,2,int
2610,137776,extractLongLatOrReply,1,extractLongLatOrReply,"int extractLongLatOrReply (client*,robj**,double*)",geo.c,"int extractLongLatOrReply(client *c, robj **argv, double *xy) {
    int i;
    for (i = 0; i < 2; i++) {
        if (getDoubleFromObjectOrReply(c, argv[i], xy + i, NULL) !=
            C_OK) {
            return C_ERR;
        }
    }
    if (xy[0] < GEO_LONG_MIN || xy[0] > GEO_LONG_MAX ||
        xy[1] < GEO_LAT_MIN  || xy[1] > GEO_LAT_MAX) {
        addReplyErrorFormat(c,
            ""-ERR invalid longitude,latitude pair %f,%f\r\n"",xy[0],xy[1]);
        return C_ERR;
    }
    return C_OK;
}",100.0,115.0,1.0,12.0,16.0,22,8,15,5,2,2,4,5,1,2,,0,1,6,3,3,int
2611,137868,longLatFromMember,1,longLatFromMember,"int longLatFromMember (robj*,robj*,double*)",geo.c,"int longLatFromMember(robj *zobj, robj *member, double *xy) {
    double score = 0;

    if (zsetScore(zobj, member->ptr, &score) == C_ERR) return C_ERR;
    if (!decodeGeohash(score, xy)) return C_ERR;
    return C_OK;
}",120.0,126.0,1.0,48.0,7.0,8,6,6,4,0,2,3,3,2,2,,0,2,6,3,3,int
2612,137913,extractUnitOrReply,1,extractUnitOrReply,"double extractUnitOrReply (client*,robj*)",geo.c,"double extractUnitOrReply(client *c, robj *unit) {
    char *u = unit->ptr;

    if (!strcasecmp(u, ""m"")) {
        return 1;
    } else if (!strcasecmp(u, ""km"")) {
        return 1000;
    } else if (!strcasecmp(u, ""ft"")) {
        return 0.3048;
    } else if (!strcasecmp(u, ""mi"")) {
        return 1609.34;
    } else {
        addReplyError(c,
            ""unsupported unit provided. please use M, KM, FT, MI"");
        return -1;
    }
}",134.0,150.0,1.0,1.0,17.0,3,3,3,2,3,0,2,2,0,0,,0,0,4,2,2,double
2613,137971,extractDistanceOrReply,1,extractDistanceOrReply,"int extractDistanceOrReply (client*,robj**,double*,double*)",geo.c,"int extractDistanceOrReply(client *c, robj **argv,
                              double *conversion, double *radius) {
    double distance;
    if (getDoubleFromObjectOrReply(c, argv[0], &distance,
                                   ""need numeric radius"") != C_OK) {
        return C_ERR;
    }

    if (distance < 0) {
        addReplyError(c,""radius cannot be negative"");
        return C_ERR;
    }
    if (radius) *radius = distance;

    double to_meters = extractUnitOrReply(c,argv[1]);
    if (to_meters < 0) {
        return C_ERR;
    }

    if (conversion) *conversion = to_meters;
    return C_OK;
}",156.0,177.0,1.0,61.0,22.0,14,7,15,6,1,3,6,6,1,3,,0,2,8,4,4,int
2614,138048,extractBoxOrReply,1,extractBoxOrReply,"int extractBoxOrReply (client*,robj**,double*,double*,double*)",geo.c,"int extractBoxOrReply(client *c, robj **argv, double *conversion,
                         double *width, double *height) {
    double h, w;
    if ((getDoubleFromObjectOrReply(c, argv[0], &w, ""need numeric width"") != C_OK) ||
        (getDoubleFromObjectOrReply(c, argv[1], &h, ""need numeric height"") != C_OK)) {
        return C_ERR;
    }

    if (h < 0 || w < 0) {
        addReplyError(c, ""height or width cannot be negative"");
        return C_ERR;
    }
    if (height) *height = h;
    if (width) *width = w;

    double to_meters = extractUnitOrReply(c,argv[2]);
    if (to_meters < 0) {
        return C_ERR;
    }

    if (conversion) *conversion = to_meters;
    return C_OK;
}",183.0,205.0,1.0,77.0,23.0,22,8,22,8,0,4,7,7,2,4,,0,3,10,5,5,int
2615,138151,addReplyDoubleDistance,1,addReplyDoubleDistance,"void addReplyDoubleDistance (client*,double)",geo.c,"void addReplyDoubleDistance(client *c, double d) {
    char dbuf[128];
    const int dlen = fixedpoint_d2string(dbuf, sizeof(dbuf), d, 4);
    addReplyBulkCBuffer(c, dbuf, dlen);
}",212.0,216.0,1.0,1.0,5.0,2,2,7,4,1,2,1,1,0,2,,0,1,4,2,2,void
2616,138171,geoWithinShape,1,geoWithinShape,"int geoWithinShape (GeoShape*,double,double*,double*)",geo.c,"int geoWithinShape(GeoShape *shape, double score, double *xy, double *distance) {
    if (!decodeGeohash(score,xy)) return C_ERR; /* Can't decode. */
    /* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in
     * reverse order: longitude first, latitude later. */
    if (shape->type == CIRCULAR_TYPE) {
        if (!geohashGetDistanceIfInRadiusWGS84(shape->xy[0], shape->xy[1], xy[0], xy[1],
                                               shape->t.radius*shape->conversion, distance))
            return C_ERR;
    } else if (shape->type == RECTANGLE_TYPE) {
        if (!geohashGetDistanceIfInRectangle(shape->t.r.width * shape->conversion,
                                             shape->t.r.height * shape->conversion,
                                             shape->xy[0], shape->xy[1], xy[0], xy[1], distance))
            return C_ERR;
    }
    return C_OK;
}",232.0,247.0,1.0,41.0,16.0,16,7,10,4,1,7,4,5,7,2,,0,7,8,4,4,int
2617,138297,geoGetPointsInRange,1,geoGetPointsInRange,"int geoGetPointsInRange (robj*,double,double,GeoShape*,geoArray*,long unsigned)",geo.c,"int geoGetPointsInRange(robj *zobj, double min, double max, GeoShape *shape, geoArray *ga, unsigned long limit) {
    /* minex 0 = include min in range; maxex 1 = exclude max in range */
    /* That's: min <= val < max */
    zrangespec range = { .min = min, .max = max, .minex = 0, .maxex = 1 };
    size_t origincount = ga->used;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr = NULL;
        unsigned int vlen = 0;
        long long vlong = 0;
        double score = 0;

        if ((eptr = zzlFirstInRange(zl, &range)) == NULL) {
            /* Nothing exists starting at our min.  No results. */
            return 0;
        }

        sptr = lpNext(zl, eptr);
        while (eptr) {
            double xy[2];
            double distance = 0;
            score = zzlGetScore(sptr);

            /* If we fell out of range, break. */
            if (!zslValueLteMax(score, &range))
   ...",261.0,323.0,1.0,26.0,63.0,41,10,58,21,1,14,9,15,5,10,,0,12,12,6,6,int
2618,138569,scoresOfGeoHashBox,1,scoresOfGeoHashBox,"void scoresOfGeoHashBox (GeoHashBits,GeoHashFix52Bits*,GeoHashFix52Bits*)",geo.c,"void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max) {
    /* We want to compute the sorted set scores that will include all the
     * elements inside the specified Geohash 'hash', which has as many
     * bits as specified by hash.step * 2.
     *
     * So if step is, for example, 3, and the hash value in binary
     * is 101010, since our score is 52 bits we want every element which
     * is in binary: 101010?????????????????????????????????????????????
     * Where ? can be 0 or 1.
     *
     * To get the min score we just use the initial hash value left
     * shifted enough to get the 52 bit value. Later we increment the
     * 6 bit prefix (see the hash.bits++ statement), and get the new
     * prefix: 101011, which we align again to 52 bits to get the maximum
     * value (which is excluded from the search). So we get everything
     * between the two following scores (represented in binary):
     *
     * 1010100000000000000000000000000...",328.0,352.0,1.0,1.0,25.0,6,4,5,3,1,3,1,1,0,2,,0,3,6,3,3,void
2619,138590,membersOfGeoHashBox,1,membersOfGeoHashBox,"int membersOfGeoHashBox (robj*,GeoHashBits,geoArray*,GeoShape*,long unsigned)",geo.c,"int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, GeoShape *shape, unsigned long limit) {
    GeoHashFix52Bits min, max;

    scoresOfGeoHashBox(hash,&min,&max);
    return geoGetPointsInRange(zobj, min, max, shape, ga, limit);
}",357.0,362.0,1.0,1.0,6.0,2,1,9,7,1,2,1,1,0,2,,0,0,10,5,5,int
2620,138615,membersOfAllNeighbors,1,membersOfAllNeighbors,"int membersOfAllNeighbors (robj*,GeoHashRadius*,GeoShape*,geoArray*,long unsigned)",geo.c,"int membersOfAllNeighbors(robj *zobj, const GeoHashRadius *n, GeoShape *shape, geoArray *ga, unsigned long limit) {
    GeoHashBits neighbors[9];
    unsigned int i, count = 0, last_processed = 0;
    int debugmsg = 0;

    neighbors[0] = n->hash;
    neighbors[1] = n->neighbors.north;
    neighbors[2] = n->neighbors.south;
    neighbors[3] = n->neighbors.east;
    neighbors[4] = n->neighbors.west;
    neighbors[5] = n->neighbors.north_east;
    neighbors[6] = n->neighbors.north_west;
    neighbors[7] = n->neighbors.south_east;
    neighbors[8] = n->neighbors.south_west;

    /* For each neighbor (*and* our own hashbox), get all the matching
     * members and add them to the potential result list. */
    for (i = 0; i < sizeof(neighbors) / sizeof(*neighbors); i++) {
        if (HASHISZERO(neighbors[i])) {
            if (debugmsg) D(""neighbors[%d] is zero"",i);
            continue;
        }

        /* Debugging info. */
        if (debugmsg) {
            GeoHashRange long_range,...",365.0,421.0,1.0,12.0,57.0,95,15,120,23,1,18,11,16,2,3,,0,15,10,5,5,int
2621,139073,sort_gp_asc,1,sort_gp_asc,"int sort_gp_asc (void*,void*)",geo.c,"static int sort_gp_asc(const void *a, const void *b) {
    const struct geoPoint *gpa = a, *gpb = b;
    /* We can't do adist - bdist because they are doubles and
     * the comparator returns an int. */
    if (gpa->dist > gpb->dist)
        return 1;
    else if (gpa->dist == gpb->dist)
        return 0;
    else
        return -1;
}",424.0,434.0,1.0,1.0,11.0,5,3,6,4,1,2,2,2,2,0,,0,2,4,2,2,int
2622,139116,sort_gp_desc,1,sort_gp_desc,"int sort_gp_desc (void*,void*)",geo.c,"static int sort_gp_desc(const void *a, const void *b) {
    return -sort_gp_asc(a, b);
}",436.0,438.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2623,139127,geoaddCommand,1,geoaddCommand,void geoaddCommand (client*),geo.c,"void geoaddCommand(client *c) {
    int xx = 0, nx = 0, longidx = 2;
    int i;

    /* Parse options. At the end 'longidx' is set to the argument position
     * of the longitude of the first element. */
    while (longidx < c->argc) {
        char *opt = c->argv[longidx]->ptr;
        if (!strcasecmp(opt,""nx"")) nx = 1;
        else if (!strcasecmp(opt,""xx"")) xx = 1;
        else if (!strcasecmp(opt,""ch"")) { /* Handle in zaddCommand. */ }
        else break;
        longidx++;
    }

    if ((c->argc - longidx) % 3 || (xx && nx)) {
        /* Need an odd number of arguments if we got this far... */
            addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Set up the vector for calling ZADD. */
    int elements = (c->argc - longidx) / 3;
    int argc = longidx+elements*2; /* ZADD key [CH] [NX|XX] score ele ... */
    robj **argv = zcalloc(argc*sizeof(robj*));
    argv[0] = createRawStringObject(""zadd"",4);
    for (i = 1; i < longidx; i++) {
        argv[i] =...",445.0,503.0,1.0,68.0,59.0,67,18,72,16,0,19,8,12,4,12,,0,12,2,1,1,void
2624,139389,georadiusGeneric,1,georadiusGeneric,"void georadiusGeneric (client*,int,int)",geo.c,"void georadiusGeneric(client *c, int srcKeyIndex, int flags) {
    robj *storekey = NULL;
    int storedist = 0; /* 0 for STORE, 1 for STOREDIST. */

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[srcKeyIndex]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Find long/lat to use for radius or box search based on inquiry type */
    int base_args;
    GeoShape shape = {0};
    if (flags & RADIUS_COORDS) {
        /* GEORADIUS or GEORADIUS_RO */
        base_args = 6;
        shape.type = CIRCULAR_TYPE;
        if (extractLongLatOrReply(c, c->argv + 2, shape.xy) == C_ERR) return;
        if (extractDistanceOrReply(c, c->argv+base_args-2, &shape.conversion, &shape.t.radius) != C_OK) return;
    } else if ((flags & RADIUS_MEMBER) && !zobj) {
        /* We don't have a source key, but we need to proceed with argument
         * parsing, so we know which reply to use depending on the STORE flag. */
        base_args = 5;
    } else if (flags & RA...",523.0,844.0,1.0,27.0,322.0,137,23,152,32,6,54,29,51,12,26,,0,35,6,3,3,void
2625,140793,georadiusCommand,1,georadiusCommand,void georadiusCommand (client*),geo.c,"void georadiusCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_COORDS);
}",847.0,849.0,1.0,27.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2626,140806,georadiusbymemberCommand,1,georadiusbymemberCommand,void georadiusbymemberCommand (client*),geo.c,"void georadiusbymemberCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_MEMBER);
}",852.0,854.0,1.0,27.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2627,140819,georadiusroCommand,1,georadiusroCommand,void georadiusroCommand (client*),geo.c,"void georadiusroCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_COORDS|RADIUS_NOSTORE);
}",857.0,859.0,1.0,27.0,3.0,3,2,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2628,140838,georadiusbymemberroCommand,1,georadiusbymemberroCommand,void georadiusbymemberroCommand (client*),geo.c,"void georadiusbymemberroCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_MEMBER|RADIUS_NOSTORE);
}",862.0,864.0,1.0,27.0,3.0,3,2,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2629,140857,geosearchCommand,1,geosearchCommand,void geosearchCommand (client*),geo.c,"void geosearchCommand(client *c) {
    georadiusGeneric(c, 1, GEOSEARCH);
}",866.0,868.0,1.0,27.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2630,140870,geosearchstoreCommand,1,geosearchstoreCommand,void geosearchstoreCommand (client*),geo.c,"void geosearchstoreCommand(client *c) {
    georadiusGeneric(c, 2, GEOSEARCH|GEOSEARCHSTORE);
}",870.0,872.0,1.0,27.0,3.0,3,2,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2631,140889,geohashCommand,1,geohashCommand,void geohashCommand (client*),geo.c,"void geohashCommand(client *c) {
    char *geoalphabet= ""0123456789bcdefghjkmnpqrstuvwxyz"";
    int j;

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Geohash elements one after the other, using a null bulk reply for
     * missing elements. */
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNull(c);
        } else {
            /* The internal format we use for geocoding is a bit different
             * than the standard, since we use as initial latitude range
             * -85,85, while the normal geohashing algorithm uses -90,90.
             * So we have to decode our position and re-encode using the
             * standard ranges in order to output a valid geohash string. */

            /* Decode... */
            double xy[2];
            if (!...",878.0,934.0,1.0,27.0,57.0,18,10,17,5,0,10,4,5,4,5,,0,8,2,1,1,void
2632,141081,geoposCommand,1,geoposCommand,void geoposCommand (client*),geo.c,"void geoposCommand(client *c) {
    int j;

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Report elements one after the other, using a null bulk reply for
     * missing elements. */
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNullArray(c);
        } else {
            /* Decode... */
            double xy[2];
            if (!decodeGeohash(score,xy)) {
                addReplyNullArray(c);
                continue;
            }
            addReplyArrayLen(c,2);
            addReplyHumanLongDouble(c,xy[0]);
            addReplyHumanLongDouble(c,xy[1]);
        }
    }
}",940.0,966.0,1.0,27.0,27.0,17,10,16,4,0,10,4,5,4,5,,0,8,2,1,1,void
2633,141177,geodistCommand,1,geodistCommand,void geodistCommand (client*),geo.c,"void geodistCommand(client *c) {
    double to_meter = 1;

    /* Check if there is the unit to extract, otherwise assume meters. */
    if (c->argc == 5) {
        to_meter = extractUnitOrReply(c,c->argv[4]);
        if (to_meter < 0) return;
    } else if (c->argc > 5) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Look up the requested zset */
    robj *zobj = NULL;
    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.null[c->resp]))
        == NULL || checkType(c, zobj, OBJ_ZSET)) return;

    /* Get the scores. We need both otherwise NULL is returned. */
    double score1, score2, xyxy[4];
    if (zsetScore(zobj, c->argv[2]->ptr, &score1) == C_ERR ||
        zsetScore(zobj, c->argv[3]->ptr, &score2) == C_ERR)
    {
        addReplyNull(c);
        return;
    }

    /* Decode & compute the distance. */
    if (!decodeGeohash(score1,xyxy) || !decodeGeohash(score2,xyxy+2))
        addReplyNull(c);
    else
        addReplyDoubleDistance(c,
...",973.0,1005.0,1.0,38.0,33.0,33,11,28,8,0,15,6,7,11,9,,0,13,2,1,1,void
2634,141357,interleave64,1,interleave64,"uint64_t interleave64 (uint32_t,uint32_t)",geohash.c,"static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                 0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                 0x0000FFFF0000FFFFULL};
    static const unsigned int S[] = {1, 2, 4, 8, 16};

    uint64_t x = xlo;
    uint64_t y = ylo;

    x = (x | (x << S[4])) & B[4];
    y = (y | (y << S[4])) & B[4];

    x = (x | (x << S[3])) & B[3];
    y = (y | (y << S[3])) & B[3];

    x = (x | (x << S[2])) & B[2];
    y = (y | (y << S[2])) & B[2];

    x = (x | (x << S[1])) & B[1];
    y = (y | (y << S[1])) & B[1];

    x = (x | (x << S[0])) & B[0];
    y = (y | (y << S[0])) & B[0];

    return x | (y << 1);
}",52.0,77.0,1.0,1.0,26.0,68,6,58,6,1,0,1,1,0,0,,0,0,4,2,2,uint64_t
2635,141525,deinterleave64,1,deinterleave64,uint64_t deinterleave64 (uint64_t),geohash.c,"static inline uint64_t deinterleave64(uint64_t interleaved) {
    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                 0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                 0x0000FFFF0000FFFFULL, 0x00000000FFFFFFFFULL};
    static const unsigned int S[] = {0, 1, 2, 4, 8, 16};

    uint64_t x = interleaved;
    uint64_t y = interleaved >> 1;

    x = (x | (x >> S[0])) & B[0];
    y = (y | (y >> S[0])) & B[0];

    x = (x | (x >> S[1])) & B[1];
    y = (y | (y >> S[1])) & B[1];

    x = (x | (x >> S[2])) & B[2];
    y = (y | (y >> S[2])) & B[2];

    x = (x | (x >> S[3])) & B[3];
    y = (y | (y >> S[3])) & B[3];

    x = (x | (x >> S[4])) & B[4];
    y = (y | (y >> S[4])) & B[4];

    x = (x | (x >> S[5])) & B[5];
    y = (y | (y >> S[5])) & B[5];

    return x | (y << 32);
}",82.0,110.0,1.0,1.0,29.0,81,7,68,5,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
2636,141722,geohashGetCoordRange,1,geohashGetCoordRange,"void geohashGetCoordRange (GeoHashRange*,GeoHashRange*)",geohash.c,"void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {
    /* These are constraints from EPSG:900913 / EPSG:3785 / OSGEO:41001 */
    /* We can't geocode at the north/south pole. */
    long_range->max = GEO_LONG_MAX;
    long_range->min = GEO_LONG_MIN;
    lat_range->max = GEO_LAT_MAX;
    lat_range->min = GEO_LAT_MIN;
}",112.0,119.0,1.0,22.0,8.0,10,3,4,2,4,4,1,1,0,0,,0,4,4,2,2,void
2637,141758,geohashEncode,1,geohashEncode,"int geohashEncode (GeoHashRange*,GeoHashRange*,double,double,uint8_t,GeoHashBits*)",geohash.c,"int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
                  double longitude, double latitude, uint8_t step,
                  GeoHashBits *hash) {
    /* Check basic arguments sanity. */
    if (hash == NULL || step > 32 || step == 0 ||
        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) return 0;

    /* Return an error when trying to index outside the supported
     * constraints. */
    if (longitude > GEO_LONG_MAX || longitude < GEO_LONG_MIN ||
        latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) return 0;

    hash->bits = 0;
    hash->step = step;

    if (latitude < lat_range->min || latitude > lat_range->max ||
        longitude < long_range->min || longitude > long_range->max) {
        return 0;
    }

    double lat_offset =
        (latitude - lat_range->min) / (lat_range->max - lat_range->min);
    double long_offset =
        (longitude - long_range->min) / (long_range->max - long_range->min);

    /* convert to fix...",121.0,151.0,1.0,8.0,31.0,69,15,46,9,3,14,4,4,4,1,,0,14,12,6,6,int
2638,141938,geohashEncodeType,1,geohashEncodeType,"int geohashEncodeType (double,double,uint8_t,GeoHashBits*)",geohash.c,"int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {
    GeoHashRange r[2] = {{0}};
    geohashGetCoordRange(&r[0], &r[1]);
    return geohashEncode(&r[0], &r[1], longitude, latitude, step, hash);
}",153.0,157.0,1.0,1.0,5.0,11,4,9,5,1,2,1,1,0,2,,0,0,8,4,4,int
2639,141975,geohashEncodeWGS84,1,geohashEncodeWGS84,"int geohashEncodeWGS84 (double,double,uint8_t,GeoHashBits*)",geohash.c,"int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,
                       GeoHashBits *hash) {
    return geohashEncodeType(longitude, latitude, step, hash);
}",159.0,162.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
2640,141989,geohashDecode,1,geohashDecode,"int geohashDecode (GeoHashRange,GeoHashRange,GeoHashBits,GeoHashArea*)",geohash.c,"int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
                   const GeoHashBits hash, GeoHashArea *area) {
    if (HASHISZERO(hash) || NULL == area || RANGEISZERO(lat_range) ||
        RANGEISZERO(long_range)) {
        return 0;
    }

    area->hash = hash;
    uint8_t step = hash.step;
    uint64_t hash_sep = deinterleave64(hash.bits); /* hash = [LAT][LONG] */

    double lat_scale = lat_range.max - lat_range.min;
    double long_scale = long_range.max - long_range.min;

    uint32_t ilato = hash_sep;       /* get lat part of deinterleaved hash */
    uint32_t ilono = hash_sep >> 32; /* shift over to get long part of hash */

    /* divide by 2**step.
     * Then, for 0-1 coordinate, multiply times scale and add
       to the min to get the absolute coordinate. */
    area->latitude.min =
        lat_range.min + (ilato * 1.0 / (1ull << step)) * lat_scale;
    area->latitude.max =
        lat_range.min + ((ilato + 1) * 1.0 / (1ull << step)) * la...",164.0,194.0,1.0,8.0,31.0,74,13,47,11,8,22,2,2,6,1,,0,22,8,4,4,int
2641,142173,geohashDecodeType,1,geohashDecodeType,"int geohashDecodeType (GeoHashBits,GeoHashArea*)",geohash.c,"int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {
    GeoHashRange r[2] = {{0}};
    geohashGetCoordRange(&r[0], &r[1]);
    return geohashDecode(r[0], r[1], hash, area);
}",196.0,200.0,1.0,1.0,5.0,9,4,7,3,2,2,1,1,0,2,,0,0,4,2,2,int
2642,142204,geohashDecodeWGS84,1,geohashDecodeWGS84,"int geohashDecodeWGS84 (GeoHashBits,GeoHashArea*)",geohash.c,"int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {
    return geohashDecodeType(hash, area);
}",202.0,204.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2643,142214,geohashDecodeAreaToLongLat,1,geohashDecodeAreaToLongLat,"int geohashDecodeAreaToLongLat (GeoHashArea*,double*)",geohash.c,"int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {
    if (!xy) return 0;
    xy[0] = (area->longitude.min + area->longitude.max) / 2;
    if (xy[0] > GEO_LONG_MAX) xy[0] = GEO_LONG_MAX;
    if (xy[0] < GEO_LONG_MIN) xy[0] = GEO_LONG_MIN;
    xy[1] = (area->latitude.min + area->latitude.max) / 2;
    if (xy[1] > GEO_LAT_MAX) xy[1] = GEO_LAT_MAX;
    if (xy[1] < GEO_LAT_MIN) xy[1] = GEO_LAT_MIN;
    return 1;
}",206.0,215.0,1.0,16.0,10.0,37,10,15,2,1,4,6,6,0,0,,0,4,4,2,2,int
2644,142330,geohashDecodeToLongLatType,1,geohashDecodeToLongLatType,"int geohashDecodeToLongLatType (GeoHashBits,double*)",geohash.c,"int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {
    GeoHashArea area = {{0}};
    if (!xy || !geohashDecodeType(hash, &area))
        return 0;
    return geohashDecodeAreaToLongLat(&area, xy);
}",217.0,222.0,1.0,1.0,6.0,8,5,6,3,1,2,2,2,1,2,,0,1,4,2,2,int
2645,142359,geohashDecodeToLongLatWGS84,1,geohashDecodeToLongLatWGS84,"int geohashDecodeToLongLatWGS84 (GeoHashBits,double*)",geohash.c,"int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {
    return geohashDecodeToLongLatType(hash, xy);
}",224.0,226.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
2646,142369,geohash_move_x,1,geohash_move_x,"void geohash_move_x (GeoHashBits*,int8_t)",geohash.c,"static void geohash_move_x(GeoHashBits *hash, int8_t d) {
    if (d == 0)
        return;

    uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
    uint64_t y = hash->bits & 0x5555555555555555ULL;

    uint64_t zz = 0x5555555555555555ULL >> (64 - hash->step * 2);

    if (d > 0) {
        x = x + (zz + 1);
    } else {
        x = x | zz;
        x = x - (zz + 1);
    }

    x &= (0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2));
    hash->bits = (x | y);
}",228.0,246.0,1.0,1.0,19.0,23,10,16,5,8,5,3,3,0,0,,0,5,4,2,2,void
2647,142453,geohash_move_y,1,geohash_move_y,"void geohash_move_y (GeoHashBits*,int8_t)",geohash.c,"static void geohash_move_y(GeoHashBits *hash, int8_t d) {
    if (d == 0)
        return;

    uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
    uint64_t y = hash->bits & 0x5555555555555555ULL;

    uint64_t zz = 0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2);
    if (d > 0) {
        y = y + (zz + 1);
    } else {
        y = y | zz;
        y = y - (zz + 1);
    }
    y &= (0x5555555555555555ULL >> (64 - hash->step * 2));
    hash->bits = (x | y);
}",248.0,264.0,1.0,1.0,17.0,23,10,16,5,8,5,3,3,0,0,,0,5,4,2,2,void
2648,142537,geohashNeighbors,1,geohashNeighbors,"void geohashNeighbors (GeoHashBits*,GeoHashNeighbors*)",geohash.c,"void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
    neighbors->east = *hash;
    neighbors->west = *hash;
    neighbors->north = *hash;
    neighbors->south = *hash;
    neighbors->south_east = *hash;
    neighbors->south_west = *hash;
    neighbors->north_east = *hash;
    neighbors->north_west = *hash;

    geohash_move_x(&neighbors->east, 1);
    geohash_move_y(&neighbors->east, 0);

    geohash_move_x(&neighbors->west, -1);
    geohash_move_y(&neighbors->west, 0);

    geohash_move_x(&neighbors->south, 0);
    geohash_move_y(&neighbors->south, -1);

    geohash_move_x(&neighbors->north, 0);
    geohash_move_y(&neighbors->north, 1);

    geohash_move_x(&neighbors->north_west, -1);
    geohash_move_y(&neighbors->north_west, 1);

    geohash_move_x(&neighbors->north_east, 1);
    geohash_move_y(&neighbors->north_east, 1);

    geohash_move_x(&neighbors->south_east, 1);
    geohash_move_y(&neighbors->south_east, -1);

    geohash_move_x(&neighbors->sout...",266.0,299.0,1.0,1.0,34.0,62,5,32,2,2,40,1,1,0,16,,0,24,4,2,2,void
2649,142869,deg_rad,1,deg_rad,double deg_rad (double),geohash_helper.c,static inline double deg_rad(double ang) { return ang * D_R; },57.0,57.0,1.0,56.0,1.0,2,2,2,2,8,0,1,1,0,0,,0,0,2,1,1,double
2650,142882,rad_deg,1,rad_deg,double rad_deg (double),geohash_helper.c,static inline double rad_deg(double ang) { return ang / D_R; },58.0,58.0,1.0,56.0,1.0,2,1,2,2,3,0,1,1,0,0,,0,0,2,1,1,double
2651,142895,geohashEstimateStepsByRadius,1,geohashEstimateStepsByRadius,"uint8_t geohashEstimateStepsByRadius (double,double)",geohash_helper.c,"uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
    if (range_meters == 0) return 26;
    int step = 1;
    while (range_meters < MERCATOR_MAX) {
        range_meters *= 2;
        step++;
    }
    step -= 2; /* Make sure range is included in most of the base cases. */

    /* Wider range towards the poles... Note: it is possible to do better
     * than this approximation by computing the distance between meridians
     * at this latitude, but this does the trick for now. */
    if (lat > 66 || lat < -66) {
        step--;
        if (lat > 80 || lat < -80) step--;
    }

    /* Frame to valid range. */
    if (step < 1) step = 1;
    if (step > 26) step = 26;
    return step;
}",62.0,83.0,1.0,1.0,22.0,20,10,18,4,1,1,7,8,1,0,,0,1,4,2,2,uint8_t
2652,142967,geohashBoundingBox,1,geohashBoundingBox,"int geohashBoundingBox (GeoShape*,double*)",geohash_helper.c,"int geohashBoundingBox(GeoShape *shape, double *bounds) {
    if (!bounds) return 0;
    double longitude = shape->xy[0];
    double latitude = shape->xy[1];
    double height = shape->conversion * (shape->type == CIRCULAR_TYPE ? shape->t.radius : shape->t.r.height/2);
    double width = shape->conversion * (shape->type == CIRCULAR_TYPE ? shape->t.radius : shape->t.r.width/2);

    const double lat_delta = rad_deg(height/EARTH_RADIUS_IN_METERS);
    const double long_delta_top = rad_deg(width/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude+lat_delta)));
    const double long_delta_bottom = rad_deg(width/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude-lat_delta)));
    /* The directions of the northern and southern hemispheres
     * are opposite, so we choice different points as min/max long/lat */
    int southern_hemisphere = latitude < 0 ? 1 : 0;
    bounds[0] = southern_hemisphere ? longitude-long_delta_bottom : longitude-long_delta_top;
    bounds[2] = southern_hemisphere ? longitude+l...",98.0,116.0,1.0,56.0,19.0,60,12,48,11,1,18,2,2,0,5,,0,18,4,2,2,int
2653,143135,geohashCalculateAreasByShapeWGS84,1,geohashCalculateAreasByShapeWGS84,GeoHashRadius geohashCalculateAreasByShapeWGS84 (GeoShape*),geohash_helper.c,"GeoHashRadius geohashCalculateAreasByShapeWGS84(GeoShape *shape) {
    GeoHashRange long_range, lat_range;
    GeoHashRadius radius;
    GeoHashBits hash;
    GeoHashNeighbors neighbors;
    GeoHashArea area;
    double min_lon, max_lon, min_lat, max_lat;
    int steps;

    geohashBoundingBox(shape, shape->bounds);
    min_lon = shape->bounds[0];
    min_lat = shape->bounds[1];
    max_lon = shape->bounds[2];
    max_lat = shape->bounds[3];

    double longitude = shape->xy[0];
    double latitude = shape->xy[1];
    /* radius_meters is calculated differently in different search types:
     * 1) CIRCULAR_TYPE, just use radius.
     * 2) RECTANGLE_TYPE, we use sqrt((width/2)^2 + (height/2)^2) to
     * calculate the distance from the center point to the corner */
    double radius_meters = shape->type == CIRCULAR_TYPE ? shape->t.radius :
            sqrt((shape->t.r.width/2)*(shape->t.r.width/2) + (shape->t.r.height/2)*(shape->t.r.height/2));
    radius_meters *= shape->conversion;
...",121.0,211.0,1.0,42.0,91.0,192,16,136,20,1,78,11,15,8,13,,0,66,2,1,1,GeoHashRadius
2654,143685,geohashAlign52Bits,1,geohashAlign52Bits,GeoHashFix52Bits geohashAlign52Bits (GeoHashBits),geohash_helper.c,"GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {
    uint64_t bits = hash.bits;
    bits <<= (52 - hash.step * 2);
    return bits;
}",213.0,217.0,1.0,1.0,5.0,5,4,5,2,3,2,1,1,0,0,,0,2,2,1,1,GeoHashFix52Bits
2655,143707,geohashGetLatDistance,1,geohashGetLatDistance,"double geohashGetLatDistance (double,double)",geohash_helper.c,"double geohashGetLatDistance(double lat1d, double lat2d) {
    return EARTH_RADIUS_IN_METERS * fabs(deg_rad(lat2d) - deg_rad(lat1d));
}",224.0,226.0,1.0,1.0,3.0,2,2,3,3,2,3,1,1,0,2,,0,1,4,2,2,double
2656,143722,geohashGetDistance,1,geohashGetDistance,"double geohashGetDistance (double,double,double,double)",geohash_helper.c,"double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {
    double lat1r, lon1r, lat2r, lon2r, u, v, a;
    lon1r = deg_rad(lon1d);
    lon2r = deg_rad(lon2d);
    v = sin((lon2r - lon1r) / 2);
    /* if v == 0 we can avoid doing expensive math when lons are practically the same */
    if (v == 0.0)
        return geohashGetLatDistance(lat1d, lat2d);
    lat1r = deg_rad(lat1d);
    lat2r = deg_rad(lat2d);
    u = sin((lat2r - lat1r) / 2);
    a = u * u + cos(lat1r) * cos(lat2r) * v * v;
    return 2.0 * EARTH_RADIUS_IN_METERS * asin(sqrt(a));
}",229.0,242.0,1.0,1.0,14.0,19,6,26,12,3,6,2,2,0,5,,0,5,8,4,4,double
2657,143801,geohashGetDistanceIfInRadius,1,geohashGetDistanceIfInRadius,"int geohashGetDistanceIfInRadius (double,double,double,double,double,double*)",geohash_helper.c,"int geohashGetDistanceIfInRadius(double x1, double y1,
                                 double x2, double y2, double radius,
                                 double *distance) {
    *distance = geohashGetDistance(x1, y1, x2, y2);
    if (*distance > radius) return 0;
    return 1;
}",244.0,250.0,1.0,1.0,7.0,4,3,7,6,1,1,2,2,0,1,,0,1,12,6,6,int
2658,143829,geohashGetDistanceIfInRadiusWGS84,1,geohashGetDistanceIfInRadiusWGS84,"int geohashGetDistanceIfInRadiusWGS84 (double,double,double,double,double,double*)",geohash_helper.c,"int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
                                      double y2, double radius,
                                      double *distance) {
    return geohashGetDistanceIfInRadius(x1, y1, x2, y2, radius, distance);
}",252.0,256.0,1.0,1.0,5.0,0,0,6,6,1,1,1,1,0,1,,0,0,12,6,6,int
2659,143847,geohashGetDistanceIfInRectangle,1,geohashGetDistanceIfInRectangle,"int geohashGetDistanceIfInRectangle (double,double,double,double,double,double,double*)",geohash_helper.c,"int geohashGetDistanceIfInRectangle(double width_m, double height_m, double x1, double y1,
                                    double x2, double y2, double *distance) {
    /* latitude distance is less expensive to compute than longitude distance
     * so we check first for the latitude condition */
    double lat_distance = geohashGetLatDistance(y2, y1);
    if (lat_distance > height_m/2) {
        return 0;
    }
    double lon_distance = geohashGetDistance(x2, y2, x1, y2);
    if (lon_distance > width_m/2) {
        return 0;
    }
    *distance = geohashGetDistance(x1, y1, x2, y2);
    return 1;
}",266.0,280.0,1.0,1.0,15.0,8,4,17,9,0,3,3,3,0,3,,0,3,14,7,7,int
2660,144007,MurmurHash64A,1,MurmurHash64A,"uint64_t MurmurHash64A (void*,int,unsigned int)",hyperloglog.c,"uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
    const uint64_t m = 0xc6a4a7935bd1e995;
    const int r = 47;
    uint64_t h = seed ^ (len * m);
    const uint8_t *data = (const uint8_t *)key;
    const uint8_t *end = data + (len-(len&7));

    while(data != end) {
        uint64_t k;

#if (BYTE_ORDER == LITTLE_ENDIAN)
    #ifdef USE_ALIGNED_ACCESS
        memcpy(&k,data,sizeof(uint64_t));
    #else
        k = *((uint64_t*)data);
    #endif
#else
        k = (uint64_t) data[0];
        k |= (uint64_t) data[1] << 8;
        k |= (uint64_t) data[2] << 16;
        k |= (uint64_t) data[3] << 24;
        k |= (uint64_t) data[4] << 32;
        k |= (uint64_t) data[5] << 40;
        k |= (uint64_t) data[6] << 48;
        k |= (uint64_t) data[7] << 56;
#endif

        k *= m;
        k ^= k >> r;
        k *= m;
        h ^= k;
        h *= m;
        data += 8;
    }

    switch(len & 7) {
    case 7: h ^= (uint64_t)data[6] << 48; /* fall-thru */
    case 6: h ^...",397.0,447.0,1.0,19.0,51.0,66,13,68,9,1,0,3,3,0,0,,0,0,6,3,3,uint64_t
2661,144240,hllPatLen,1,hllPatLen,"int hllPatLen (unsigned char*,size_t,long*)",hyperloglog.c,"int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {
    uint64_t hash, bit, index;
    int count;

    /* Count the number of zeroes starting from bit HLL_REGISTERS
     * (that is a power of two corresponding to the first bit we don't use
     * as index). The max run can be 64-P+1 = Q+1 bits.
     *
     * Note that the final ""1"" ending the sequence of zeroes must be
     * included in the count, so if we find ""001"" the count is 3, and
     * the smallest count possible is no zeroes at all, just a 1 bit
     * at the first position, that is a count of 1.
     *
     * This may sound like inefficient, but actually in the average case
     * there are high probabilities to find a 1 after a few iterations. */
    hash = MurmurHash64A(ele,elesize,0xadc83b19ULL);
    index = hash & HLL_P_MASK; /* Register index. */
    hash >>= HLL_P; /* Remove bits used to address the register. */
    hash |= ((uint64_t)1<<HLL_Q); /* Make sure the loop terminates
                          ...",452.0,480.0,1.0,19.0,29.0,16,8,16,7,2,1,2,2,0,1,,0,1,6,3,3,int
2662,144310,hllDenseSet,1,hllDenseSet,"int hllDenseSet (uint8_t*,long,uint8_t)",hyperloglog.c,"int hllDenseSet(uint8_t *registers, long index, uint8_t count) {
    uint8_t oldcount;

    HLL_DENSE_GET_REGISTER(oldcount,registers,index);
    if (count > oldcount) {
        HLL_DENSE_SET_REGISTER(registers,index,count);
        return 1;
    } else {
        return 0;
    }
}",494.0,504.0,1.0,4.0,11.0,50,13,51,13,3,0,2,2,0,0,,0,0,6,3,3,int
2663,144487,hllDenseAdd,1,hllDenseAdd,"int hllDenseAdd (uint8_t*,unsigned char*,size_t)",hyperloglog.c,"int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
    long index;
    uint8_t count = hllPatLen(ele,elesize,&index);
    /* Update the register if this element produced a longer run of zeroes. */
    return hllDenseSet(registers,index,count);
}",512.0,517.0,1.0,1.0,6.0,2,2,7,5,2,2,1,1,0,2,,0,1,6,3,3,int
2664,144508,hllDenseRegHisto,1,hllDenseRegHisto,"void hllDenseRegHisto (uint8_t*,int*)",hyperloglog.c,"void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
    int j;

    /* Redis default is to use 16384 registers 6 bits each. The code works
     * with other values by modifying the defines, but for our target value
     * we take a faster path with unrolled loops. */
    if (HLL_REGISTERS == 16384 && HLL_BITS == 6) {
        uint8_t *r = registers;
        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,
                      r10, r11, r12, r13, r14, r15;
        for (j = 0; j < 1024; j++) {
            /* Handle 16 registers per iteration. */
            r0 = r[0] & 63;
            r1 = (r[0] >> 6 | r[1] << 2) & 63;
            r2 = (r[1] >> 4 | r[2] << 4) & 63;
            r3 = (r[2] >> 2) & 63;
            r4 = r[3] & 63;
            r5 = (r[3] >> 6 | r[4] << 2) & 63;
            r6 = (r[4] >> 4 | r[5] << 4) & 63;
            r7 = (r[5] >> 2) & 63;
            r8 = r[6] & 63;
            r9 = (r[6] >> 6 | r[7] << 2) & 63;
            r10 = (r[7] >> 4 | r[8] << 4) & 63...",520.0,575.0,1.0,8.0,56.0,124,11,77,20,1,0,3,4,0,0,,0,0,4,2,2,void
2665,144905,hllSparseToDense,1,hllSparseToDense,int hllSparseToDense (robj*),hyperloglog.c,"int hllSparseToDense(robj *o) {
    sds sparse = o->ptr, dense;
    struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
    int idx = 0, runlen, regval;
    uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);

    /* If the representation is already the right one return ASAP. */
    hdr = (struct hllhdr*) sparse;
    if (hdr->encoding == HLL_DENSE) return C_OK;

    /* Create a string of the right size filled with zero bytes.
     * Note that the cached cardinality is set to 0 as a side effect
     * that is exactly the cardinality of an empty HLL. */
    dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
    hdr = (struct hllhdr*) dense;
    *hdr = *oldhdr; /* This will copy the magic and cached cardinality. */
    hdr->encoding = HLL_DENSE;

    /* Now read the sparse representation and set non-zero registers
     * accordingly. */
    p += HLL_HDR_SIZE;
    while(p < end) {
        if (HLL_SPARSE_IS_ZERO(p)) {
            runlen = HLL_SPARSE_ZERO_LEN(p);
            idx += runlen;
   ...",585.0,638.0,1.0,25.0,54.0,45,16,38,11,3,6,5,6,1,4,,0,4,2,1,1,int
2666,145237,hllSparseSet,1,hllSparseSet,"int hllSparseSet (robj*,long,uint8_t)",hyperloglog.c,"int hllSparseSet(robj *o, long index, uint8_t count) {
    struct hllhdr *hdr;
    uint8_t oldcount, *sparse, *end, *p, *prev, *next;
    long first, span;
    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;

    /* If the count is too big to be representable by the sparse representation
     * switch to dense representation. */
    if (count > HLL_SPARSE_VAL_MAX_VALUE) goto promote;

    /* When updating a sparse representation, sometimes we may need to enlarge the
     * buffer for up to 3 bytes in the worst case (XZERO split into XZERO-VAL-XZERO),
     * and the following code does the enlarge job.
     * Actually, we use a greedy strategy, enlarge more than 3 bytes to avoid the need
     * for future reallocates on incremental growth. But we do not allocate more than
     * 'server.hll_sparse_max_bytes' bytes for the sparse representation.
     * If the available size of hyperloglog sds string is not enough for the increment
     * we need, we promote the hypreloglog to ...",655.0,907.0,1.0,16.0,253.0,235,28,209,34,2,16,34,45,4,14,,0,10,6,3,3,int
2667,146271,hllSparseAdd,1,hllSparseAdd,"int hllSparseAdd (robj*,unsigned char*,size_t)",hyperloglog.c,"int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {
    long index;
    uint8_t count = hllPatLen(ele,elesize,&index);
    /* Update the register if this element produced a longer run of zeroes. */
    return hllSparseSet(o,index,count);
}",915.0,920.0,1.0,1.0,6.0,2,2,7,5,1,2,1,1,0,2,,0,1,6,3,3,int
2668,146545,hllSigma,1,hllSigma,double hllSigma (double),hyperloglog.c,"double hllSigma(double x) {
    if (x == 1.) return INFINITY;
    double zPrime;
    double y = 1;
    double z = x;
    do {
        x *= x;
        zPrime = z;
        z += x * y;
        y += y;
    } while(zPrime != z);
    return z;
}",983.0,995.0,1.0,1.0,13.0,9,6,17,5,1,0,3,3,0,0,,0,0,2,1,1,double
2669,146587,hllTau,1,hllTau,double hllTau (double),hyperloglog.c,"double hllTau(double x) {
    if (x == 0. || x == 1.) return 0.;
    double zPrime;
    double y = 1.0;
    double z = 1 - x;
    do {
        x = sqrt(x);
        zPrime = z;
        y *= 0.5;
        z -= pow(1 - x, 2)*y;
    } while(zPrime != z);
    return z / 3;
}",1000.0,1012.0,1.0,1.0,13.0,14,9,16,4,1,0,3,3,0,0,,0,0,2,1,1,double
2670,146642,hllCount,1,hllCount,"uint64_t hllCount (hllhdr*,int*)",hyperloglog.c,"uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
    double m = HLL_REGISTERS;
    double E;
    int j;
    /* Note that reghisto size could be just HLL_Q+2, because HLL_Q+1 is
     * the maximum frequency of the ""000...1"" sequence the hash function is
     * able to return. However it is slow to check for sanity of the
     * input: instead we history array at a safe size: overflows will
     * just write data to wrong, but correctly allocated, places. */
    int reghisto[64] = {0};

    /* Compute register histogram */
    if (hdr->encoding == HLL_DENSE) {
        hllDenseRegHisto(hdr->registers,reghisto);
    } else if (hdr->encoding == HLL_SPARSE) {
        hllSparseRegHisto(hdr->registers,
                         sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);
    } else if (hdr->encoding == HLL_RAW) {
        hllRawRegHisto(hdr->registers,reghisto);
    } else {
        serverPanic(""Unknown HyperLogLog encoding in hllCount()"");
    }

    /* Estimate cardinality from re...",1025.0,1060.0,1.0,15.0,36.0,31,14,25,6,4,5,3,3,1,3,,0,3,4,2,2,uint64_t
2671,146801,hllAdd,1,hllAdd,"int hllAdd (robj*,unsigned char*,size_t)",hyperloglog.c,"int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
    struct hllhdr *hdr = o->ptr;
    switch(hdr->encoding) {
    case HLL_DENSE: return hllDenseAdd(hdr->registers,ele,elesize);
    case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);
    default: return -1; /* Invalid representation. */
    }
}",1063.0,1070.0,1.0,9.0,8.0,5,3,9,4,2,4,2,2,1,2,,0,2,6,3,3,int
2672,146843,hllMerge,1,hllMerge,"int hllMerge (uint8_t*,robj*)",hyperloglog.c,"int hllMerge(uint8_t *max, robj *hll) {
    struct hllhdr *hdr = hll->ptr;
    int i;

    if (hdr->encoding == HLL_DENSE) {
        uint8_t val;

        for (i = 0; i < HLL_REGISTERS; i++) {
            HLL_DENSE_GET_REGISTER(val,hdr->registers,i);
            if (val > max[i]) max[i] = val;
        }
    } else {
        uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
        long runlen, regval;

        p += HLL_HDR_SIZE;
        i = 0;
        while(p < end) {
            if (HLL_SPARSE_IS_ZERO(p)) {
                runlen = HLL_SPARSE_ZERO_LEN(p);
                i += runlen;
                p++;
            } else if (HLL_SPARSE_IS_XZERO(p)) {
                runlen = HLL_SPARSE_XZERO_LEN(p);
                i += runlen;
                p += 2;
            } else {
                runlen = HLL_SPARSE_VAL_LEN(p);
                regval = HLL_SPARSE_VAL_VALUE(p);
                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
                while(runlen--) {
    ...",1080.0,1120.0,1.0,25.0,41.0,35,15,33,12,2,3,4,7,1,0,,0,3,4,2,2,int
2673,147141,createHLLObject,1,createHLLObject,robj createHLLObject (void),hyperloglog.c,"robj *createHLLObject(void) {
    robj *o;
    struct hllhdr *hdr;
    sds s;
    uint8_t *p;
    int sparselen = HLL_HDR_SIZE +
                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN-1)) /
                     HLL_SPARSE_XZERO_MAX_LEN)*2);
    int aux;

    /* Populate the sparse representation with as many XZERO opcodes as
     * needed to represent all the registers. */
    aux = HLL_REGISTERS;
    s = sdsnewlen(NULL,sparselen);
    p = (uint8_t*)s + HLL_HDR_SIZE;
    while(aux) {
        int xzero = HLL_SPARSE_XZERO_MAX_LEN;
        if (xzero > aux) xzero = aux;
        HLL_SPARSE_XZERO_SET(p,xzero);
        p += 2;
        aux -= xzero;
    }
    serverAssert((p-(uint8_t*)s) == sparselen);

    /* Create the actual object. */
    o = createObject(OBJ_STRING,s);
    hdr = o->ptr;
    memcpy(hdr->magic,""HYLL"",4);
    hdr->encoding = HLL_SPARSE;
    return o;
}",1126.0,1156.0,1.0,20.0,31.0,43,20,36,11,3,5,3,4,0,3,,0,4,2,1,1,robj
2674,147298,isHLLObjectOrReply,1,isHLLObjectOrReply,"int isHLLObjectOrReply (client*,robj*)",hyperloglog.c,"int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;

    /* Key exists, check type */
    if (checkType(c,o,OBJ_STRING))
        return C_ERR; /* Error already sent. */

    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;

    /* Magic should be ""HYLL"". */
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;

    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;

    /* Dense representation string length should match exactly. */
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;

    /* All tests passed. */
    return C_OK;

invalid:
    addReplyError(c,""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value."");
    return C_ERR;
}",1161.0,1189.0,1.0,22.0,29.0,40,17,18,4,3,10,12,7,9,4,,0,9,4,2,2,int
2675,147435,pfaddCommand,1,pfaddCommand,void pfaddCommand (client*),hyperloglog.c,"void pfaddCommand(client *c) {
    robj *o = lookupKeyWrite(c->db,c->argv[1]);
    struct hllhdr *hdr;
    int updated = 0, j;

    if (o == NULL) {
        /* Create the key with a string value of the exact length to
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */
        o = createHLLObject();
        dbAdd(c->db,c->argv[1],o);
        updated++;
    } else {
        if (isHLLObjectOrReply(c,o) != C_OK) return;
        o = dbUnshareStringValue(c->db,c->argv[1],o);
    }
    /* Perform the low level ADD operation for every element. */
    for (j = 2; j < c->argc; j++) {
        int retval = hllAdd(o, (unsigned char*)c->argv[j]->ptr,
                               sdslen(c->argv[j]->ptr));
        switch(retval) {
        case 1:
            updated++;
            break;
        case -1:
            addReplyError(c,invalid_hll_err);
            return;
        }
    }
    hdr = o->ptr;
    if (u...",1192.0,1229.0,1.0,39.0,38.0,42,12,40,10,0,22,6,6,1,9,,0,17,2,1,1,void
2676,147614,pfcountCommand,1,pfcountCommand,void pfcountCommand (client*),hyperloglog.c,"void pfcountCommand(client *c) {
    robj *o;
    struct hllhdr *hdr;
    uint64_t card;

    /* Case 1: multi-key keys, cardinality of the union.
     *
     * When multiple keys are specified, PFCOUNT actually computes
     * the cardinality of the merge of the N HLLs specified. */
    if (c->argc > 2) {
        uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;
        int j;

        /* Compute an HLL with M[i] = MAX(M[i]_j). */
        memset(max,0,sizeof(max));
        hdr = (struct hllhdr*) max;
        hdr->encoding = HLL_RAW; /* Special internal-only encoding. */
        registers = max + HLL_HDR_SIZE;
        for (j = 1; j < c->argc; j++) {
            /* Check type and size. */
            robj *o = lookupKeyRead(c->db,c->argv[j]);
            if (o == NULL) continue; /* Assume empty HLL for non existing var.*/
            if (isHLLObjectOrReply(c,o) != C_OK) return;

            /* Merge with this HLL with our 'max' HLL by setting max[i]
             * to MAX(max[i],hl...",1232.0,1325.0,1.0,20.0,94.0,27,12,34,10,0,16,8,14,4,8,,0,13,2,1,1,void
2677,147992,pfmergeCommand,1,pfmergeCommand,void pfmergeCommand (client*),hyperloglog.c,"void pfmergeCommand(client *c) {
    uint8_t max[HLL_REGISTERS];
    struct hllhdr *hdr;
    int j;
    int use_dense = 0; /* Use dense representation as target? */

    /* Compute an HLL with M[i] = MAX(M[i]_j).
     * We store the maximum into the max array of registers. We'll write
     * it to the target variable later. */
    memset(max,0,sizeof(max));
    for (j = 1; j < c->argc; j++) {
        /* Check type and size. */
        robj *o = lookupKeyRead(c->db,c->argv[j]);
        if (o == NULL) continue; /* Assume empty HLL for non existing var. */
        if (isHLLObjectOrReply(c,o) != C_OK) return;

        /* If at least one involved HLL is dense, use the dense representation
         * as target ASAP to save time and avoid the conversion step. */
        hdr = o->ptr;
        if (hdr->encoding == HLL_DENSE) use_dense = 1;

        /* Merge with this HLL with our 'max' HLL by setting max[i]
         * to MAX(max[i],hll[i]). */
        if (hllMerge(max,o) == C_ERR) {
        ...",1328.0,1399.0,1.0,16.0,72.0,57,12,62,10,0,31,15,17,6,14,,0,23,2,1,1,void
2678,148250,pfselftestCommand,1,pfselftestCommand,void pfselftestCommand (client*),hyperloglog.c,"void pfselftestCommand(client *c) {
    unsigned int j, i;
    sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);
    struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;
    robj *o = NULL;
    uint8_t bytecounters[HLL_REGISTERS];

    /* Test 1: access registers.
     * The test is conceived to test that the different counters of our data
     * structure are accessible and that setting their values both result in
     * the correct value to be retained and not affect adjacent values. */
    for (j = 0; j < HLL_TEST_CYCLES; j++) {
        /* Set the HLL counters and an array of unsigned byes of the
         * same size to the same set of random values. */
        for (i = 0; i < HLL_REGISTERS; i++) {
            unsigned int r = rand() & HLL_REGISTER_MAX;

            bytecounters[i] = r;
            HLL_DENSE_SET_REGISTER(hdr->registers,i,r);
        }
        /* Check that we are able to retrieve the same values. */
        for (i = 0; i < HLL_REGISTERS; i++) {
            u...",1407.0,1507.0,1.0,37.0,101.0,143,25,132,29,0,21,18,29,3,14,,0,12,2,1,1,void
2679,148748,pfdebugCommand,1,pfdebugCommand,void pfdebugCommand (client*),hyperloglog.c,"void pfdebugCommand(client *c) {
    char *cmd = c->argv[1]->ptr;
    struct hllhdr *hdr;
    robj *o;
    int j;

    o = lookupKeyWrite(c->db,c->argv[2]);
    if (o == NULL) {
        addReplyError(c,""The specified key does not exist"");
        return;
    }
    if (isHLLObjectOrReply(c,o) != C_OK) return;
    o = dbUnshareStringValue(c->db,c->argv[2],o);
    hdr = o->ptr;

    /* PFDEBUG GETREG <key> */
    if (!strcasecmp(cmd,""getreg"")) {
        if (c->argc != 3) goto arityerr;

        if (hdr->encoding == HLL_SPARSE) {
            if (hllSparseToDense(o) == C_ERR) {
                addReplyError(c,invalid_hll_err);
                return;
            }
            server.dirty++; /* Force propagation on encoding change. */
        }

        hdr = o->ptr;
        addReplyArrayLen(c,HLL_REGISTERS);
        for (j = 0; j < HLL_REGISTERS; j++) {
            uint8_t val;

            HLL_DENSE_GET_REGISTER(val,hdr->registers,j);
            addReplyLongLong(c,val);
        }
    ...",1516.0,1617.0,1.0,35.0,102.0,55,19,54,16,0,19,9,13,4,9,,0,14,2,1,1,void
2680,149262,_intsetValueEncoding,1,_intsetValueEncoding,uint8_t _intsetValueEncoding (int64_t),intset.c,"static uint8_t _intsetValueEncoding(int64_t v) {
    if (v < INT32_MIN || v > INT32_MAX)
        return INTSET_ENC_INT64;
    else if (v < INT16_MIN || v > INT16_MAX)
        return INTSET_ENC_INT32;
    else
        return INTSET_ENC_INT16;
}",46.0,53.0,1.0,15.0,8.0,4,4,5,4,4,0,2,2,0,0,,0,0,2,1,1,uint8_t
2681,149304,_intsetGetEncoded,1,_intsetGetEncoded,"int64_t _intsetGetEncoded (intset*,int,uint8_t)",intset.c,"static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {
    int64_t v64;
    int32_t v32;
    int16_t v16;

    if (enc == INTSET_ENC_INT64) {
        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));
        memrev64ifbe(&v64);
        return v64;
    } else if (enc == INTSET_ENC_INT32) {
        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));
        memrev32ifbe(&v32);
        return v32;
    } else {
        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));
        memrev16ifbe(&v16);
        return v16;
    }
}",56.0,74.0,1.0,15.0,19.0,9,6,9,5,1,2,2,2,0,1,,0,1,6,3,3,int64_t
2682,149397,_intsetGet,1,_intsetGet,"int64_t _intsetGet (intset*,int)",intset.c,"static int64_t _intsetGet(intset *is, int pos) {
    return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));
}",77.0,79.0,1.0,36.0,3.0,2,1,4,2,7,4,1,1,0,2,,0,3,4,2,2,int64_t
2683,149416,_intsetSet,1,_intsetSet,"void _intsetSet (intset*,int,int64_t)",intset.c,"static void _intsetSet(intset *is, int pos, int64_t value) {
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        ((int64_t*)is->contents)[pos] = value;
        memrev64ifbe(((int64_t*)is->contents)+pos);
    } else if (encoding == INTSET_ENC_INT32) {
        ((int32_t*)is->contents)[pos] = value;
        memrev32ifbe(((int32_t*)is->contents)+pos);
    } else {
        ((int16_t*)is->contents)[pos] = value;
        memrev16ifbe(((int16_t*)is->contents)+pos);
    }
}",82.0,95.0,1.0,24.0,14.0,12,7,10,5,2,6,2,2,0,2,,0,5,6,3,3,void
2684,149512,intsetNew,1,intsetNew,intset intsetNew (void),intset.c,"intset *intsetNew(void) {
    intset *is = zmalloc(sizeof(intset));
    is->encoding = intrev32ifbe(INTSET_ENC_INT16);
    is->length = 0;
    return is;
}",98.0,103.0,1.0,19.0,6.0,7,3,6,3,2,4,1,1,0,2,,0,4,2,1,1,intset
2685,149539,intsetResize,1,intsetResize,"intset intsetResize (intset*,uint32_t)",intset.c,"static intset *intsetResize(intset *is, uint32_t len) {
    uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);
    assert(size <= SIZE_MAX - sizeof(intset));
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}",106.0,111.0,1.0,34.0,6.0,15,11,12,5,2,5,1,1,0,3,,0,4,4,2,2,intset
2686,149590,intsetSearch,1,intsetSearch,"uint8_t intsetSearch (intset*,int64_t,uint32_t*)",intset.c,"static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;
    int64_t cur = -1;

    /* The value can never be found when the set is empty */
    if (intrev32ifbe(is->length) == 0) {
        if (pos) *pos = 0;
        return 0;
    } else {
        /* Check for the case where we know we cannot find the value,
         * but do know the insert position. */
        if (value > _intsetGet(is,max)) {
            if (pos) *pos = intrev32ifbe(is->length);
            return 0;
        } else if (value < _intsetGet(is,0)) {
            if (pos) *pos = 0;
            return 0;
        }
    }

    while(max >= min) {
        mid = ((unsigned int)min + (unsigned int)max) >> 1;
        cur = _intsetGet(is,mid);
        if (value > cur) {
            min = mid+1;
        } else if (value < cur) {
            max = mid-1;
        } else {
            break;
        }
    }

    if (value == cur) {
        if (pos) *pos =...",117.0,156.0,1.0,23.0,40.0,27,11,27,7,2,7,7,10,3,3,,0,7,6,3,3,uint8_t
2687,149762,intsetUpgradeAndAdd,1,intsetUpgradeAndAdd,"intset intsetUpgradeAndAdd (intset*,int64_t)",intset.c,"static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    int prepend = value < 0 ? 1 : 0;

    /* First set new encoding and resize */
    is->encoding = intrev32ifbe(newenc);
    is = intsetResize(is,intrev32ifbe(is->length)+1);

    /* Upgrade back-to-front so we don't overwrite values.
     * Note that the ""prepend"" variable is used to make sure we have an empty
     * space at either the beginning or the end of the intset. */
    while(length--)
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));

    /* Set the value at the beginning or the end. */
    if (prepend)
        _intsetSet(is,0,value);
    else
        _intsetSet(is,intrev32ifbe(is->length),value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}",159.0,182.0,1.0,21.0,24.0,22,6,25,6,1,19,3,3,0,9,,0,18,4,2,2,intset
2688,149881,intsetMoveTail,1,intsetMoveTail,"void intsetMoveTail (intset*,uint32_t,uint32_t)",intset.c,"static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
    void *src, *dst;
    uint32_t bytes = intrev32ifbe(is->length)-from;
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        src = (int64_t*)is->contents+from;
        dst = (int64_t*)is->contents+to;
        bytes *= sizeof(int64_t);
    } else if (encoding == INTSET_ENC_INT32) {
        src = (int32_t*)is->contents+from;
        dst = (int32_t*)is->contents+to;
        bytes *= sizeof(int32_t);
    } else {
        src = (int16_t*)is->contents+from;
        dst = (int16_t*)is->contents+to;
        bytes *= sizeof(int16_t);
    }
    memmove(dst,src,bytes);
}",184.0,203.0,1.0,21.0,20.0,19,8,20,8,1,8,2,2,0,2,,0,8,6,3,3,void
2689,150006,intsetAdd,1,intsetAdd,"intset intsetAdd (intset*,int64_t,uint8_t*)",intset.c,"intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 1;

    /* Upgrade encoding if necessary. If we need to upgrade, we know that
     * this value should be either appended (if > 0) or prepended (if < 0),
     * because it lies outside the range of existing values. */
    if (valenc > intrev32ifbe(is->encoding)) {
        /* This always succeeds, so we don't need to curry *success. */
        return intsetUpgradeAndAdd(is,value);
    } else {
        /* Abort if the value is already present in the set.
         * This call will populate ""pos"" with the right position to insert
         * the value when it cannot be found. */
        if (intsetSearch(is,value,&pos)) {
            if (success) *success = 0;
            return is;
        }

        is = intsetResize(is,intrev32ifbe(is->length)+1);
        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
    }

...",206.0,233.0,1.0,17.0,28.0,11,5,16,5,1,11,3,3,3,6,,0,9,6,3,3,intset
2690,150117,intsetRemove,1,intsetRemove,"intset intsetRemove (intset*,int64_t,int*)",intset.c,"intset *intsetRemove(intset *is, int64_t value, int *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 0;

    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {
        uint32_t len = intrev32ifbe(is->length);

        /* We know we can delete */
        if (success) *success = 1;

        /* Overwrite value with tail and update length */
        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);
        is = intsetResize(is,len-1);
        is->length = intrev32ifbe(len-1);
    }
    return is;
}",236.0,253.0,1.0,18.0,18.0,21,9,26,6,0,12,5,7,4,7,,0,11,6,3,3,intset
2691,150207,intsetFind,1,intsetFind,"uint8_t intsetFind (intset*,int64_t)",intset.c,"uint8_t intsetFind(intset *is, int64_t value) {
    uint8_t valenc = _intsetValueEncoding(value);
    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);
}",256.0,259.0,1.0,21.0,4.0,5,4,8,4,0,5,1,1,0,3,,0,3,4,2,2,uint8_t
2692,150235,intsetRandom,1,intsetRandom,int64_t intsetRandom (intset*),intset.c,"int64_t intsetRandom(intset *is) {
    uint32_t len = intrev32ifbe(is->length);
    assert(len); /* avoid division by zero on corrupt intset payload. */
    return _intsetGet(is,rand()%len);
}",262.0,266.0,1.0,19.0,5.0,8,7,7,2,0,5,1,1,0,3,,0,3,2,1,1,int64_t
2693,150273,intsetMax,1,intsetMax,int64_t intsetMax (intset*),intset.c,"int64_t intsetMax(intset *is) {
    uint32_t len = intrev32ifbe(is->length);
    return _intsetGet(is, len - 1);
}",269.0,272.0,1.0,19.0,4.0,4,3,5,2,0,4,1,1,0,2,,0,3,2,1,1,int64_t
2694,150296,intsetMin,1,intsetMin,int64_t intsetMin (intset*),intset.c,"int64_t intsetMin(intset *is) {
    return _intsetGet(is, 0);
}",275.0,277.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int64_t
2695,150305,intsetGet,1,intsetGet,"uint8_t intsetGet (intset*,uint32_t,int64_t*)",intset.c,"uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {
    if (pos < intrev32ifbe(is->length)) {
        *value = _intsetGet(is,pos);
        return 1;
    }
    return 0;
}",281.0,287.0,1.0,14.0,7.0,5,4,6,3,1,4,2,2,3,2,,0,4,6,3,3,uint8_t
2696,150335,intsetLen,1,intsetLen,uint32_t intsetLen (intset*),intset.c,"uint32_t intsetLen(const intset *is) {
    return intrev32ifbe(is->length);
}",290.0,292.0,1.0,11.0,3.0,2,1,2,1,1,3,1,1,0,1,,0,2,2,1,1,uint32_t
2697,150350,intsetBlobLen,1,intsetBlobLen,size_t intsetBlobLen (intset*),intset.c,"size_t intsetBlobLen(intset *is) {
    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);
}",295.0,297.0,1.0,34.0,3.0,8,5,5,2,0,6,1,1,0,2,,0,4,2,1,1,size_t
2698,150380,intsetValidateIntegrity,1,intsetValidateIntegrity,"int intsetValidateIntegrity (unsigned char*,size_t,int)",intset.c,"int intsetValidateIntegrity(const unsigned char *p, size_t size, int deep) {
    intset *is = (intset *)p;
    /* check that we can actually read the header. */
    if (size < sizeof(*is))
        return 0;

    uint32_t encoding = intrev32ifbe(is->encoding);

    size_t record_size;
    if (encoding == INTSET_ENC_INT64) {
        record_size = INTSET_ENC_INT64;
    } else if (encoding == INTSET_ENC_INT32) {
        record_size = INTSET_ENC_INT32;
    } else if (encoding == INTSET_ENC_INT16){
        record_size = INTSET_ENC_INT16;
    } else {
        return 0;
    }

    /* check that the size matches (all records are inside the buffer). */
    uint32_t count = intrev32ifbe(is->length);
    if (sizeof(*is) + count*record_size != size)
        return 0;

    /* check that the set is not empty. */
    if (count==0)
        return 0;

    if (!deep)
        return 1;

    /* check that there are no dup or out of order records. */
    int64_t prev = _intsetGet(is,0);
    for (uint32_t...",302.0,343.0,1.0,24.0,42.0,28,12,32,11,0,8,8,9,0,4,,0,8,6,3,3,int
2699,150648,dictStringHash,1,dictStringHash,uint64_t dictStringHash (void*),latency.c,"uint64_t dictStringHash(const void *key) {
    return dictGenHashFunction(key, strlen(key));
}",45.0,47.0,1.0,1.0,3.0,0,0,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
2700,150675,THPGetAnonHugePagesSize,1,THPGetAnonHugePagesSize,int THPGetAnonHugePagesSize (void),latency.c,"int THPGetAnonHugePagesSize(void) {
    return zmalloc_get_smap_bytes_by_field(""AnonHugePages:"",-1);
}",66.0,68.0,1.0,1.0,3.0,1,1,0,0,1,1,1,1,0,1,,0,0,2,1,1,int
2701,150685,latencyMonitorInit,1,latencyMonitorInit,void latencyMonitorInit (void),latency.c,"void latencyMonitorInit(void) {
    server.latency_events = dictCreate(&latencyTimeSeriesDictType);
}",75.0,77.0,1.0,1.0,3.0,3,3,2,2,1,2,1,1,0,1,,0,2,2,1,1,void
2702,150697,latencyAddSample,1,latencyAddSample,"void latencyAddSample (char*,mstime_t)",latency.c,"void latencyAddSample(const char *event, mstime_t latency) {
    struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
    time_t now = time(NULL);
    int prev;

    /* Create the time series if it does not exist. */
    if (ts == NULL) {
        ts = zmalloc(sizeof(*ts));
        ts->idx = 0;
        ts->max = 0;
        memset(ts->samples,0,sizeof(ts->samples));
        dictAdd(server.latency_events,zstrdup(event),ts);
    }

    if (latency > ts->max) ts->max = latency;

    /* If the previous sample is in the same second, we update our old sample
     * if this latency is > of the old one, or just return. */
    prev = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;
    if (ts->samples[prev].time == now) {
        if (latency > ts->samples[prev].latency)
            ts->samples[prev].latency = latency;
        return;
    }

    ts->samples[ts->idx].time = now;
    ts->samples[ts->idx].latency = latency;

    ts->idx++;
    if (ts->idx == LATENCY_TS_LEN) ...",83.0,113.0,1.0,22.0,31.0,52,12,40,7,14,21,6,7,4,4,,0,20,4,2,2,void
2703,150853,latencyResetEvent,1,latencyResetEvent,int latencyResetEvent (char*),latency.c,"int latencyResetEvent(char *event_to_reset) {
    dictIterator *di;
    dictEntry *de;
    int resets = 0;

    di = dictGetSafeIterator(server.latency_events);
    while((de = dictNext(di)) != NULL) {
        char *event = dictGetKey(de);

        if (event_to_reset == NULL || strcasecmp(event,event_to_reset) == 0) {
            dictDelete(server.latency_events, event);
            resets++;
        }
    }
    dictReleaseIterator(di);
    return resets;
}",120.0,136.0,1.0,1.0,17.0,11,6,17,7,0,5,3,4,1,5,,0,3,2,1,1,int
2704,150905,analyzeLatencyForEvent,1,analyzeLatencyForEvent,"void analyzeLatencyForEvent (char*,latencyStats*)",latency.c,"void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
    struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
    int j;
    uint64_t sum;

    ls->all_time_high = ts ? ts->max : 0;
    ls->avg = 0;
    ls->min = 0;
    ls->max = 0;
    ls->mad = 0;
    ls->samples = 0;
    ls->period = 0;
    if (!ts) return;

    /* First pass, populate everything but the MAD. */
    sum = 0;
    for (j = 0; j < LATENCY_TS_LEN; j++) {
        if (ts->samples[j].time == 0) continue;
        ls->samples++;
        if (ls->samples == 1) {
            ls->min = ls->max = ts->samples[j].latency;
        } else {
            if (ls->min > ts->samples[j].latency)
                ls->min = ts->samples[j].latency;
            if (ls->max < ts->samples[j].latency)
                ls->max = ts->samples[j].latency;
        }
        sum += ts->samples[j].latency;

        /* Track the oldest event time in ls->period. */
        if (ls->period == 0 || ts->samples[j].time <...",145.0,199.0,1.0,20.0,55.0,90,15,61,8,1,34,14,18,9,1,,0,34,4,2,2,void
2705,151215,createLatencyReport,1,createLatencyReport,sds createLatencyReport (void),latency.c,"sds createLatencyReport(void) {
    sds report = sdsempty();
    int advise_better_vm = 0;       /* Better virtual machines. */
    int advise_slowlog_enabled = 0; /* Enable slowlog. */
    int advise_slowlog_tuning = 0;  /* Reconfigure slowlog. */
    int advise_slowlog_inspect = 0; /* Check your slowlog. */
    int advise_disk_contention = 0; /* Try to lower disk contention. */
    int advise_scheduler = 0;       /* Intrinsic latency. */
    int advise_data_writeback = 0;  /* data=writeback. */
    int advise_no_appendfsync = 0;  /* don't fsync during rewrites. */
    int advise_local_disk = 0;      /* Avoid remote disks. */
    int advise_ssd = 0;             /* Use an SSD drive. */
    int advise_write_load_info = 0; /* Print info about AOF and write load. */
    int advise_hz = 0;              /* Use higher HZ. */
    int advise_large_objects = 0;   /* Deletion of large objects. */
    int advise_mass_eviction = 0;   /* Avoid mass eviction of keys. */
    int advise_relax_fsync...",202.0,457.0,1.0,8.0,256.0,125,17,123,27,0,20,22,39,2,14,,0,18,2,1,1,sds
2706,151901,fillCommandCDF,1,fillCommandCDF,"void fillCommandCDF (client*,hdr_histogram*)",latency.c,"void fillCommandCDF(client *c, struct hdr_histogram* histogram) {
    addReplyMapLen(c,2);
    addReplyBulkCString(c,""calls"");
    addReplyLongLong(c,(long long) histogram->total_count);
    addReplyBulkCString(c,""histogram_usec"");
    void *replylen = addReplyDeferredLen(c);
    int samples = 0;
    struct hdr_iter iter;
    hdr_iter_log_init(&iter,histogram,1024,2);
    int64_t previous_count = 0;
    while (hdr_iter_next(&iter)) {
        const int64_t micros = iter.highest_equivalent_value / 1000;
        const int64_t cumulative_count = iter.cumulative_count;
        if(cumulative_count > previous_count){
            addReplyLongLong(c,(long long) micros);
            addReplyLongLong(c,(long long) cumulative_count);
            samples++;
        }
        previous_count = cumulative_count;
    }
    setDeferredMapLen(c,replylen,samples);
}",468.0,489.0,1.0,1.0,22.0,17,8,28,8,3,8,3,4,0,8,,0,1,4,2,2,void
2707,151986,latencyAllCommandsFillCDF,1,latencyAllCommandsFillCDF,"void latencyAllCommandsFillCDF (client*,dict*,int*)",latency.c,"void latencyAllCommandsFillCDF(client *c, dict *commands, int *command_with_data) {
    dictIterator *di = dictGetSafeIterator(commands);
    dictEntry *de;
    struct redisCommand *cmd;

    while((de = dictNext(di)) != NULL) {
        cmd = (struct redisCommand *) dictGetVal(de);
        if (cmd->latency_histogram) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            fillCommandCDF(c, cmd->latency_histogram);
            (*command_with_data)++;
        }

        if (cmd->subcommands) {
            latencyAllCommandsFillCDF(c, cmd->subcommands_dict, command_with_data);
        }
    }
    dictReleaseIterator(di);
}",493.0,511.0,1.0,1.0,19.0,13,6,19,7,0,13,4,6,3,7,,0,10,6,3,3,void
2708,152049,latencySpecificCommandsFillCDF,1,latencySpecificCommandsFillCDF,void latencySpecificCommandsFillCDF (client*),latency.c,"void latencySpecificCommandsFillCDF(client *c) {
    void *replylen = addReplyDeferredLen(c);
    int command_with_data = 0;
    for (int j = 2; j < c->argc; j++){
        struct redisCommand *cmd = lookupCommandBySds(c->argv[j]->ptr);
        /* If the command does not exist we skip the reply */
        if (cmd == NULL) {
            continue;
        }

        if (cmd->latency_histogram) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            fillCommandCDF(c, cmd->latency_histogram);
            command_with_data++;
        }

        if (cmd->subcommands_dict) {
            dictEntry *de;
            dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);

            while ((de = dictNext(di)) != NULL) {
                struct redisCommand *sub = dictGetVal(de);
                if (sub->latency_histogram) {
                    addReplyBulkCBuffer(c, sub->fullname, sdslen(sub->fullname));
                    fillCommandCDF(c, sub->latency_...",515.0,547.0,1.0,1.0,33.0,26,7,37,9,0,25,8,15,5,13,,0,19,2,1,1,void
2709,152168,latencyCommandReplyWithSamples,1,latencyCommandReplyWithSamples,"void latencyCommandReplyWithSamples (client*,latencyTimeSeries*)",latency.c,"void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {
    void *replylen = addReplyDeferredLen(c);
    int samples = 0, j;

    for (j = 0; j < LATENCY_TS_LEN; j++) {
        int i = (ts->idx + j) % LATENCY_TS_LEN;

        if (ts->samples[i].time == 0) continue;
        addReplyArrayLen(c,2);
        addReplyLongLong(c,ts->samples[i].time);
        addReplyLongLong(c,ts->samples[i].latency);
        samples++;
    }
    setDeferredArrayLen(c,replylen,samples);
}",551.0,565.0,1.0,20.0,15.0,19,9,21,6,0,9,4,4,1,5,,0,5,4,2,2,void
2710,152248,latencyCommandReplyWithLatestEvents,1,latencyCommandReplyWithLatestEvents,void latencyCommandReplyWithLatestEvents (client*),latency.c,"void latencyCommandReplyWithLatestEvents(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c,dictSize(server.latency_events));
    di = dictGetIterator(server.latency_events);
    while((de = dictNext(di)) != NULL) {
        char *event = dictGetKey(de);
        struct latencyTimeSeries *ts = dictGetVal(de);
        int last = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;

        addReplyArrayLen(c,4);
        addReplyBulkCString(c,event);
        addReplyLongLong(c,ts->samples[last].time);
        addReplyLongLong(c,ts->samples[last].latency);
        addReplyLongLong(c,ts->max);
    }
    dictReleaseIterator(di);
}",569.0,587.0,1.0,23.0,19.0,26,8,27,8,0,15,2,2,1,11,,0,8,2,1,1,void
2711,152348,latencyCommandGenSparkeline,1,latencyCommandGenSparkeline,"sds latencyCommandGenSparkeline (char*,latencyTimeSeries*)",latency.c,"sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {
    int j;
    struct sequence *seq = createSparklineSequence();
    sds graph = sdsempty();
    uint32_t min = 0, max = 0;

    for (j = 0; j < LATENCY_TS_LEN; j++) {
        int i = (ts->idx + j) % LATENCY_TS_LEN;
        int elapsed;
        char buf[64];

        if (ts->samples[i].time == 0) continue;
        /* Update min and max. */
        if (seq->length == 0) {
            min = max = ts->samples[i].latency;
        } else {
            if (ts->samples[i].latency > max) max = ts->samples[i].latency;
            if (ts->samples[i].latency < min) min = ts->samples[i].latency;
        }
        /* Use as label the number of seconds / minutes / hours / days
         * ago the event happened. */
        elapsed = time(NULL) - ts->samples[i].time;
        if (elapsed < 60)
            snprintf(buf,sizeof(buf),""%ds"",elapsed);
        else if (elapsed < 3600)
            snprintf(buf,sizeof(buf),""%dm"",ela...",590.0,632.0,1.0,20.0,43.0,40,11,43,11,0,14,7,9,2,7,,0,12,4,2,2,sds
2712,152604,latencyCommand,1,latencyCommand,void latencyCommand (client*),latency.c,"void latencyCommand(client *c) {
    struct latencyTimeSeries *ts;

    if (!strcasecmp(c->argv[1]->ptr,""history"") && c->argc == 3) {
        /* LATENCY HISTORY <event> */
        ts = dictFetchValue(server.latency_events,c->argv[2]->ptr);
        if (ts == NULL) {
            addReplyArrayLen(c,0);
        } else {
            latencyCommandReplyWithSamples(c,ts);
        }
    } else if (!strcasecmp(c->argv[1]->ptr,""graph"") && c->argc == 3) {
        /* LATENCY GRAPH <event> */
        sds graph;
        dictEntry *de;
        char *event;

        de = dictFind(server.latency_events,c->argv[2]->ptr);
        if (de == NULL) goto nodataerr;
        ts = dictGetVal(de);
        event = dictGetKey(de);

        graph = latencyCommandGenSparkeline(event,ts);
        addReplyVerbatim(c,graph,sdslen(graph),""txt"");
        sdsfree(graph);
    } else if (!strcasecmp(c->argv[1]->ptr,""latest"") && c->argc == 2) {
        /* LATENCY LATEST */
        latencyCommandReplyWithLatestEvents(c);
 ...",643.0,727.0,1.0,1.0,85.0,17,8,10,4,0,7,3,4,2,3,,0,5,2,1,1,void
2713,152945,durationAddSample,1,durationAddSample,"void durationAddSample (int,monotime)",latency.c,"void durationAddSample(int type, monotime duration) {
    if (type >= EL_DURATION_TYPE_NUM) {
        return;
    }
    durationStats* ds = &server.duration_stats[type];
    ds->cnt++;
    ds->sum += duration;
    if (duration > ds->max) {
        ds->max = duration;
    }
}",729.0,739.0,1.0,1.0,11.0,13,9,12,5,3,4,3,3,1,0,,0,4,4,2,2,void
2714,153073,lazyfreeFreeObject,1,lazyfreeFreeObject,void lazyfreeFreeObject (void[]*),lazyfree.c,"void lazyfreeFreeObject(void *args[]) {
    robj *o = (robj *) args[0];
    decrRefCount(o);
    atomicDecr(lazyfree_objects,1);
    atomicIncr(lazyfreed_objects,1);
}",11.0,16.0,1.0,1.0,6.0,3,3,5,4,0,3,1,1,0,1,,0,2,2,1,1,void
2715,153094,lazyfreeFreeDatabase,1,lazyfreeFreeDatabase,void lazyfreeFreeDatabase (void[]*),lazyfree.c,"void lazyfreeFreeDatabase(void *args[]) {
    dict *ht1 = (dict *) args[0];
    dict *ht2 = (dict *) args[1];

    size_t numkeys = dictSize(ht1);
    dictRelease(ht1);
    dictRelease(ht2);
    atomicDecr(lazyfree_objects,numkeys);
    atomicIncr(lazyfreed_objects,numkeys);
}",21.0,30.0,1.0,21.0,10.0,12,5,14,6,0,6,1,1,0,2,,0,4,2,1,1,void
2716,153142,lazyFreeTrackingTable,1,lazyFreeTrackingTable,void lazyFreeTrackingTable (void[]*),lazyfree.c,"void lazyFreeTrackingTable(void *args[]) {
    rax *rt = args[0];
    size_t len = rt->numele;
    freeTrackingRadixTree(rt);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",33.0,39.0,1.0,1.0,7.0,4,3,9,5,0,4,1,1,0,1,,0,3,2,1,1,void
2717,153167,lazyFreeLuaScripts,1,lazyFreeLuaScripts,void lazyFreeLuaScripts (void[]*),lazyfree.c,"void lazyFreeLuaScripts(void *args[]) {
    dict *lua_scripts = args[0];
    long long len = dictSize(lua_scripts);
    dictRelease(lua_scripts);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",42.0,48.0,1.0,20.0,7.0,8,4,11,5,0,5,1,1,0,1,,0,4,2,1,1,void
2718,153203,lazyFreeFunctionsCtx,1,lazyFreeFunctionsCtx,void lazyFreeFunctionsCtx (void[]*),lazyfree.c,"void lazyFreeFunctionsCtx(void *args[]) {
    functionsLibCtx *functions_lib_ctx = args[0];
    size_t len = functionsLibCtxfunctionsLen(functions_lib_ctx);
    functionsLibCtxFree(functions_lib_ctx);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",51.0,57.0,1.0,1.0,7.0,3,2,9,5,0,4,1,1,0,2,,0,3,2,1,1,void
2719,153227,lazyFreeReplicationBacklogRefMem,1,lazyFreeReplicationBacklogRefMem,void lazyFreeReplicationBacklogRefMem (void[]*),lazyfree.c,"void lazyFreeReplicationBacklogRefMem(void *args[]) {
    list *blocks = args[0];
    rax *index = args[1];
    long long len = listLength(blocks);
    len += raxSize(index);
    listRelease(blocks);
    raxFree(index);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",60.0,69.0,1.0,20.0,10.0,7,4,15,6,0,6,1,1,0,3,,0,3,2,1,1,void
2720,153267,lazyfreeGetPendingObjectsCount,1,lazyfreeGetPendingObjectsCount,size_t lazyfreeGetPendingObjectsCount (void),lazyfree.c,"size_t lazyfreeGetPendingObjectsCount(void) {
    size_t aux;
    atomicGet(lazyfree_objects,aux);
    return aux;
}",72.0,76.0,1.0,1.0,5.0,0,0,3,2,1,1,1,1,0,0,,0,1,2,1,1,size_t
2721,153278,lazyfreeGetFreedObjectsCount,1,lazyfreeGetFreedObjectsCount,size_t lazyfreeGetFreedObjectsCount (void),lazyfree.c,"size_t lazyfreeGetFreedObjectsCount(void) {
    size_t aux;
    atomicGet(lazyfreed_objects,aux);
    return aux;
}",79.0,83.0,1.0,1.0,5.0,0,0,3,2,1,1,1,1,0,0,,0,1,2,1,1,size_t
2722,153289,lazyfreeResetStats,1,lazyfreeResetStats,void lazyfreeResetStats (void),lazyfree.c,"void lazyfreeResetStats(void) {
    atomicSet(lazyfreed_objects,0);
}",85.0,87.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
2723,153297,lazyfreeGetFreeEffort,1,lazyfreeGetFreeEffort,"size_t lazyfreeGetFreeEffort (robj*,robj*,int)",lazyfree.c,"size_t lazyfreeGetFreeEffort(robj *key, robj *obj, int dbid) {
    if (obj->type == OBJ_LIST && obj->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = obj->ptr;
        return ql->len;
    } else if (obj->type == OBJ_SET && obj->encoding == OBJ_ENCODING_HT) {
        dict *ht = obj->ptr;
        return dictSize(ht);
    } else if (obj->type == OBJ_ZSET && obj->encoding == OBJ_ENCODING_SKIPLIST){
        zset *zs = obj->ptr;
        return zs->zsl->length;
    } else if (obj->type == OBJ_HASH && obj->encoding == OBJ_ENCODING_HT) {
        dict *ht = obj->ptr;
        return dictSize(ht);
    } else if (obj->type == OBJ_STREAM) {
        size_t effort = 0;
        stream *s = obj->ptr;

        /* Make a best effort estimate to maintain constant runtime. Every macro
         * node in the Stream is one allocation. */
        effort += s->rax->numnodes;

        /* Every consumer group is an allocation and so are the entries in its
         * PEL. We use size of the first g...",104.0,149.0,1.0,21.0,46.0,8,4,5,2,1,1,2,2,0,0,,0,1,6,3,3,size_t
2724,153565,freeObjAsync,1,freeObjAsync,"void freeObjAsync (robj*,robj*,int)",lazyfree.c,"void freeObjAsync(robj *key, robj *obj, int dbid) {
    size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid);
    /* Note that if the object is shared, to reclaim it now it is not
     * possible. This rarely happens, however sometimes the implementation
     * of parts of the Redis core may call incrRefCount() to protect
     * objects, and then call dbDelete(). */
    if (free_effort > LAZYFREE_THRESHOLD && obj->refcount == 1) {
        atomicIncr(lazyfree_objects,1);
        bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj);
    } else {
        decrRefCount(obj);
    }
}",159.0,171.0,1.0,22.0,13.0,5,5,8,5,1,3,2,2,0,2,,0,2,6,3,3,void
2725,153603,emptyDbAsync,1,emptyDbAsync,void emptyDbAsync (redisDb*),lazyfree.c,"void emptyDbAsync(redisDb *db) {
    dict *oldht1 = db->dict, *oldht2 = db->expires;
    db->dict = dictCreate(&dbDictType);
    db->expires = dictCreate(&dbExpiresDictType);
    atomicIncr(lazyfree_objects,dictSize(oldht1));
    bioCreateLazyFreeJob(lazyfreeFreeDatabase,2,oldht1,oldht2);
}",176.0,182.0,1.0,32.0,7.0,15,5,14,6,1,10,1,1,0,3,,0,9,2,1,1,void
2726,153655,freeTrackingRadixTreeAsync,1,freeTrackingRadixTreeAsync,void freeTrackingRadixTreeAsync (rax*),lazyfree.c,"void freeTrackingRadixTreeAsync(rax *tracking) {
    /* Because this rax has only keys and no values so we use numnodes. */
    if (tracking->numnodes > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,tracking->numele);
        bioCreateLazyFreeJob(lazyFreeTrackingTable,1,tracking);
    } else {
        freeTrackingRadixTree(tracking);
    }
}",186.0,194.0,1.0,29.0,9.0,3,2,4,2,0,4,2,2,1,1,,0,3,2,1,1,void
2727,153682,freeLuaScriptsAsync,1,freeLuaScriptsAsync,void freeLuaScriptsAsync (dict*),lazyfree.c,"void freeLuaScriptsAsync(dict *lua_scripts) {
    if (dictSize(lua_scripts) > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,dictSize(lua_scripts));
        bioCreateLazyFreeJob(lazyFreeLuaScripts,1,lua_scripts);
    } else {
        dictRelease(lua_scripts);
    }
}",197.0,204.0,1.0,8.0,8.0,11,4,8,2,1,6,2,2,2,1,,0,5,2,1,1,void
2728,153731,freeFunctionsAsync,1,freeFunctionsAsync,void freeFunctionsAsync (functionsLibCtx*),lazyfree.c,"void freeFunctionsAsync(functionsLibCtx *functions_lib_ctx) {
    if (functionsLibCtxfunctionsLen(functions_lib_ctx) > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,functionsLibCtxfunctionsLen(functions_lib_ctx));
        bioCreateLazyFreeJob(lazyFreeFunctionsCtx,1,functions_lib_ctx);
    } else {
        functionsLibCtxFree(functions_lib_ctx);
    }
}",207.0,214.0,1.0,57.0,8.0,1,1,4,2,1,4,2,2,1,3,,0,2,2,1,1,void
2729,153756,freeReplicationBacklogRefMemAsync,1,freeReplicationBacklogRefMemAsync,"void freeReplicationBacklogRefMemAsync (list*,rax*)",lazyfree.c,"void freeReplicationBacklogRefMemAsync(list *blocks, rax *index) {
    if (listLength(blocks) > LAZYFREE_THRESHOLD ||
        raxSize(index) > LAZYFREE_THRESHOLD)
    {
        atomicIncr(lazyfree_objects,listLength(blocks)+raxSize(index));
        bioCreateLazyFreeJob(lazyFreeReplicationBacklogRefMem,2,blocks,index);
    } else {
        listRelease(blocks);
        raxFree(index);
    }
}",217.0,227.0,1.0,8.0,11.0,6,4,9,3,1,6,2,2,2,3,,0,4,4,2,2,void
2730,153836,lpAssertValidEntry,1,lpAssertValidEntry,"void lpAssertValidEntry (unsigned char*,size_t,unsigned char*)",listpack.c,"static inline void lpAssertValidEntry(unsigned char* lp, size_t lpbytes, unsigned char *p) {
    assert(lpValidateNext(lp, &p, lpbytes));
}",1341.0,1343.0,1.0,4.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,6,3,3,void
2731,153900,lpStringToInt64,1,lpStringToInt64,"int lpStringToInt64 (char*,long unsigned,int64_t*)",listpack.c,"int lpStringToInt64(const char *s, unsigned long slen, int64_t *value) {
    const char *p = s;
    unsigned long plen = 0;
    int negative = 0;
    uint64_t v;

    /* Abort if length indicates this cannot possibly be an int */
    if (slen == 0 || slen >= LONG_STR_SIZE)
        return 0;

    /* Special case: first and only digit is 0. */
    if (slen == 1 && p[0] == '0') {
        if (value != NULL) *value = 0;
        return 1;
    }

    if (p[0] == '-') {
        negative = 1;
        p++; plen++;

        /* Abort on only a negative sign. */
        if (plen == slen)
            return 0;
    }

    /* First digit should be 1-9, otherwise the string should just be 0. */
    if (p[0] >= '1' && p[0] <= '9') {
        v = p[0]-'0';
        p++; plen++;
    } else {
        return 0;
    }

    while (plen < slen && p[0] >= '0' && p[0] <= '9') {
        if (v > (UINT64_MAX / 10)) /* Overflow. */
            return 0;
        v *= 10;

        if (v > (UINT64_MAX - (p[0]-'0'))) /...",176.0,235.0,1.0,29.0,60.0,57,18,46,10,1,0,14,20,0,0,,0,0,6,3,3,int
2732,154110,lpNew,1,lpNew,unsigned char* lpNew (size_t),listpack.c,"unsigned char *lpNew(size_t capacity) {
    unsigned char *lp = lp_malloc(capacity > LP_HDR_SIZE+1 ? capacity : LP_HDR_SIZE+1);
    if (lp == NULL) return NULL;
    lpSetTotalBytes(lp,LP_HDR_SIZE+1);
    lpSetNumElements(lp,0);
    lp[LP_HDR_SIZE] = LP_EOF;
    return lp;
}",242.0,249.0,1.0,24.0,8.0,34,8,17,3,5,1,2,2,0,1,,0,1,2,1,1,unsigned char*
2733,154221,lpFree,1,lpFree,void lpFree (unsigned char*),listpack.c,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}",252.0,254.0,1.0,4.0,3.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void
2734,154230,lpShrinkToFit,1,lpShrinkToFit,unsigned char* lpShrinkToFit (unsigned char*),listpack.c,"unsigned char* lpShrinkToFit(unsigned char *lp) {
    size_t size = lpGetTotalBytes(lp);
    if (size < lp_malloc_size(lp)) {
        return lp_realloc(lp, size);
    } else {
        return lp;
    }
}",257.0,264.0,1.0,18.0,8.0,13,5,13,3,3,2,2,2,1,2,,0,1,2,1,1,unsigned char*
2735,154289,lpEncodeIntegerGetType,1,lpEncodeIntegerGetType,"void lpEncodeIntegerGetType (int64_t,unsigned char*,uint64_t*)",listpack.c,"static inline void lpEncodeIntegerGetType(int64_t v, unsigned char *intenc, uint64_t *enclen) {
    if (v >= 0 && v <= 127) {
        /* Single byte 0-127 integer. */
        intenc[0] = v;
        *enclen = 1;
    } else if (v >= -4096 && v <= 4095) {
        /* 13 bit integer. */
        if (v < 0) v = ((int64_t)1<<13)+v;
        intenc[0] = (v>>8)|LP_ENCODING_13BIT_INT;
        intenc[1] = v&0xff;
        *enclen = 2;
    } else if (v >= -32768 && v <= 32767) {
        /* 16 bit integer. */
        if (v < 0) v = ((int64_t)1<<16)+v;
        intenc[0] = LP_ENCODING_16BIT_INT;
        intenc[1] = v&0xff;
        intenc[2] = v>>8;
        *enclen = 3;
    } else if (v >= -8388608 && v <= 8388607) {
        /* 24 bit integer. */
        if (v < 0) v = ((int64_t)1<<24)+v;
        intenc[0] = LP_ENCODING_24BIT_INT;
        intenc[1] = v&0xff;
        intenc[2] = (v>>8)&0xff;
        intenc[3] = v>>16;
        *enclen = 4;
    } else if (v >= -2147483648 && v <= 2147483647) {
        /*...",267.0,316.0,1.0,27.0,50.0,7,6,5,3,3,0,2,2,0,0,,0,0,6,3,3,void
2736,154627,lpEncodeGetType,1,lpEncodeGetType,"int lpEncodeGetType (unsigned char*,uint32_t,unsigned char*,uint64_t*)",listpack.c,"static inline int lpEncodeGetType(unsigned char *ele, uint32_t size, unsigned char *intenc, uint64_t *enclen) {
    int64_t v;
    if (lpStringToInt64((const char*)ele, size, &v)) {
        lpEncodeIntegerGetType(v, intenc, enclen);
        return LP_ENCODING_INT;
    } else {
        if (size < 64) *enclen = 1+size;
        else if (size < 4096) *enclen = 2+size;
        else *enclen = 5+(uint64_t)size;
        return LP_ENCODING_STRING;
    }
}",329.0,340.0,1.0,15.0,12.0,2,2,6,5,1,2,2,2,1,2,,0,1,8,4,4,int
2737,154693,lpEncodeBacklen,1,lpEncodeBacklen,"unsigned long lpEncodeBacklen (unsigned char*,uint64_t)",listpack.c,"static inline unsigned long lpEncodeBacklen(unsigned char *buf, uint64_t l) {
    if (l <= 127) {
        if (buf) buf[0] = l;
        return 1;
    } else if (l < 16383) {
        if (buf) {
            buf[0] = l>>7;
            buf[1] = (l&127)|128;
        }
        return 2;
    } else if (l < 2097151) {
        if (buf) {
            buf[0] = l>>14;
            buf[1] = ((l>>7)&127)|128;
            buf[2] = (l&127)|128;
        }
        return 3;
    } else if (l < 268435455) {
        if (buf) {
            buf[0] = l>>21;
            buf[1] = ((l>>14)&127)|128;
            buf[2] = ((l>>7)&127)|128;
            buf[3] = (l&127)|128;
        }
        return 4;
    } else {
        if (buf) {
            buf[0] = l>>28;
            buf[1] = ((l>>21)&127)|128;
            buf[2] = ((l>>14)&127)|128;
            buf[3] = ((l>>7)&127)|128;
            buf[4] = (l&127)|128;
        }
        return 5;
    }
}",347.0,382.0,1.0,1.0,36.0,3,3,4,2,7,0,3,4,0,0,,0,0,4,2,2,unsigned long
2738,154887,lpDecodeBacklen,1,lpDecodeBacklen,uint64_t lpDecodeBacklen (unsigned char*),listpack.c,"static inline uint64_t lpDecodeBacklen(unsigned char *p) {
    uint64_t val = 0;
    uint64_t shift = 0;
    do {
        val |= (uint64_t)(p[0] & 127) << shift;
        if (!(p[0] & 128)) break;
        shift += 7;
        p--;
        if (shift > 28) return UINT64_MAX;
    } while(1);
    return val;
}",386.0,397.0,1.0,1.0,12.0,11,8,11,4,2,0,5,6,0,0,,0,0,2,1,1,uint64_t
2739,155043,lpCurrentEncodedSizeUnsafe,1,lpCurrentEncodedSizeUnsafe,uint32_t lpCurrentEncodedSizeUnsafe (unsigned char*),listpack.c,"static inline uint32_t lpCurrentEncodedSizeUnsafe(unsigned char *p) {
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1+LP_ENCODING_6BIT_STR_LEN(p);
    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 2;
    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 3;
    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 4;
    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 5;
    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 9;
    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2+LP_ENCODING_12BIT_STR_LEN(p);
    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5+LP_ENCODING_32BIT_STR_LEN(p);
    if (p[0] == LP_EOF) return 1;
    return 0;
}",428.0,440.0,1.0,8.0,13.0,59,6,29,1,4,0,11,11,0,0,,0,0,2,1,1,uint32_t
2740,155260,lpCurrentEncodedSizeBytes,1,lpCurrentEncodedSizeBytes,uint32_t lpCurrentEncodedSizeBytes (unsigned char*),listpack.c,"static inline uint32_t lpCurrentEncodedSizeBytes(unsigned char *p) {
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1;
    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2;
    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5;
    if (p[0] == LP_EOF) return 1;
    return 0;
}",446.0,458.0,1.0,8.0,13.0,38,3,19,1,2,0,11,11,0,0,,0,0,2,1,1,uint32_t
2741,155422,lpSkip,1,lpSkip,unsigned char* lpSkip (unsigned char*),listpack.c,"unsigned char *lpSkip(unsigned char *p) {
    unsigned long entrylen = lpCurrentEncodedSizeUnsafe(p);
    entrylen += lpEncodeBacklen(NULL,entrylen);
    p += entrylen;
    return p;
}",464.0,469.0,1.0,1.0,6.0,3,2,8,3,4,2,1,1,0,2,,0,1,2,1,1,unsigned char*
2742,155442,lpNext,1,lpNext,"unsigned char* lpNext (unsigned char*,unsigned char*)",listpack.c,"unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
    assert(p);
    p = lpSkip(p);
    if (p[0] == LP_EOF) return NULL;
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",474.0,480.0,1.0,4.0,7.0,7,7,10,3,43,4,2,2,0,4,,0,2,4,2,2,unsigned char*
2743,155485,lpPrev,1,lpPrev,"unsigned char* lpPrev (unsigned char*,unsigned char*)",listpack.c,"unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {
    assert(p);
    if (p-lp == LP_HDR_SIZE) return NULL;
    p--; /* Seek the first backlen byte of the last element. */
    uint64_t prevlen = lpDecodeBacklen(p);
    prevlen += lpEncodeBacklen(NULL,prevlen);
    p -= prevlen-1; /* Seek the first byte of the previous entry. */
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",485.0,494.0,1.0,4.0,10.0,11,10,17,4,4,5,2,2,0,5,,0,2,4,2,2,unsigned char*
2744,155541,lpFirst,1,lpFirst,unsigned char* lpFirst (unsigned char*),listpack.c,"unsigned char *lpFirst(unsigned char *lp) {
    unsigned char *p = lp + LP_HDR_SIZE; /* Skip the header. */
    if (p[0] == LP_EOF) return NULL;
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",498.0,503.0,1.0,28.0,6.0,4,4,8,3,16,2,2,2,0,2,,0,1,2,1,1,unsigned char*
2745,155572,lpLast,1,lpLast,unsigned char* lpLast (unsigned char*),listpack.c,"unsigned char *lpLast(unsigned char *lp) {
    unsigned char *p = lp+lpGetTotalBytes(lp)-1; /* Seek EOF element. */
    return lpPrev(lp,p); /* Will return NULL if EOF is the only element. */
}",507.0,510.0,1.0,26.0,4.0,14,6,9,2,0,1,1,1,0,1,,0,0,2,1,1,unsigned char*
2746,155618,lpLength,1,lpLength,unsigned long lpLength (unsigned char*),listpack.c,"unsigned long lpLength(unsigned char *lp) {
    uint32_t numele = lpGetNumElements(lp);
    if (numele != LP_HDR_NUMELE_UNKNOWN) return numele;

    /* Too many elements inside the listpack. We need to scan in order
     * to get the total number. */
    uint32_t count = 0;
    unsigned char *p = lpFirst(lp);
    while(p) {
        count++;
        p = lpNext(lp,p);
    }

    /* If the count is again within range of the header numele field,
     * set it. */
    if (count < LP_HDR_NUMELE_UNKNOWN) lpSetNumElements(lp,count);
    return count;
}",517.0,534.0,1.0,22.0,18.0,19,9,24,5,14,2,4,4,0,2,,0,2,2,1,1,unsigned long
2747,155702,lpGetWithSize,1,lpGetWithSize,"unsigned char* lpGetWithSize (unsigned char*,int64_t*,unsigned char*,uint64_t*)",listpack.c,"static inline unsigned char *lpGetWithSize(unsigned char *p, int64_t *count, unsigned char *intbuf, uint64_t *entry_size) {
    int64_t val;
    uint64_t uval, negstart, negmax;

    assert(p); /* assertion for valgrind (avoid NPD) */
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) {
        negstart = UINT64_MAX; /* 7 bit ints are always positive. */
        negmax = 0;
        uval = p[0] & 0x7f;
        if (entry_size) *entry_size = LP_ENCODING_7BIT_UINT_ENTRY_SIZE;
    } else if (LP_ENCODING_IS_6BIT_STR(p[0])) {
        *count = LP_ENCODING_6BIT_STR_LEN(p);
        if (entry_size) *entry_size = 1 + *count + lpEncodeBacklen(NULL, *count + 1);
        return p+1;
    } else if (LP_ENCODING_IS_13BIT_INT(p[0])) {
        uval = ((p[0]&0x1f)<<8) | p[1];
        negstart = (uint64_t)1<<12;
        negmax = 8191;
        if (entry_size) *entry_size = LP_ENCODING_13BIT_INT_ENTRY_SIZE;
    } else if (LP_ENCODING_IS_16BIT_INT(p[0])) {
        uval = (uint64_t)p[1] |
               (uint64_t)p[2]<...",572.0,660.0,1.0,4.0,89.0,26,12,25,9,2,2,5,6,0,2,,0,1,8,4,4,unsigned char*
2748,156324,lpGet,1,lpGet,"unsigned char* lpGet (unsigned char*,int64_t*,unsigned char*)",listpack.c,"unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf) {
    return lpGetWithSize(p, count, intbuf, NULL);
}",662.0,664.0,1.0,1.0,3.0,0,0,4,4,6,1,1,1,0,1,,0,0,6,3,3,unsigned char*
2749,156337,lpGetValue,1,lpGetValue,"unsigned char* lpGetValue (unsigned char*,unsigned int*,long long*)",listpack.c,"unsigned char *lpGetValue(unsigned char *p, unsigned int *slen, long long *lval) {
    unsigned char *vstr;
    int64_t ele_len;

    vstr = lpGet(p, &ele_len, NULL);
    if (vstr) {
        *slen = ele_len;
    } else {
        *lval = ele_len;
    }
    return vstr;
}",671.0,682.0,1.0,1.0,12.0,4,3,8,5,21,1,2,2,0,1,,0,1,6,3,3,unsigned char*
2750,156368,lpFind,1,lpFind,"unsigned char* lpFind (unsigned char*,unsigned char*,unsigned char*,uint32_t,unsigned int)",listpack.c,"unsigned char *lpFind(unsigned char *lp, unsigned char *p, unsigned char *s, 
                      uint32_t slen, unsigned int skip) {
    int skipcnt = 0;
    unsigned char vencoding = 0;
    unsigned char *value;
    int64_t ll, vll;
    uint64_t entry_size = 123456789; /* initialized to avoid warning. */
    uint32_t lp_bytes = lpBytes(lp);

    assert(p);
    while (p) {
        if (skipcnt == 0) {
            value = lpGetWithSize(p, &ll, NULL, &entry_size);
            if (value) {
                /* check the value doesn't reach outside the listpack before accessing it */
                assert(p >= lp + LP_HDR_SIZE && p + entry_size < lp + lp_bytes);
                if (slen == ll && memcmp(value, s, slen) == 0) {
                    return p;
                }
            } else {
                /* Find out if the searched field can be encoded. Note that
                 * we do it only the first time, once done vencoding is set
                 * to non-zero and vll is s...",686.0,750.0,1.0,4.0,65.0,32,13,39,12,2,5,8,15,0,5,,0,2,10,5,5,unsigned char*
2751,156581,lpInsert,1,lpInsert,"unsigned char* lpInsert (unsigned char*,unsigned char*,unsigned char*,uint32_t,unsigned char*,int,unsigned char**)",listpack.c,"unsigned char *lpInsert(unsigned char *lp, unsigned char *elestr, unsigned char *eleint,
                        uint32_t size, unsigned char *p, int where, unsigned char **newp)
{
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
    unsigned char backlen[LP_MAX_BACKLEN_SIZE];

    uint64_t enclen; /* The length of the encoded element. */
    int delete = (elestr == NULL && eleint == NULL);

    /* when deletion, it is conceptually replacing the element with a
     * zero-length element. So whatever we get passed as 'where', set
     * it to LP_REPLACE. */
    if (delete) where = LP_REPLACE;

    /* If we need to insert after the current element, we just jump to the
     * next element (that could be the EOF one) and handle the case of
     * inserting before. So the function will actually deal with just two
     * cases: LP_BEFORE and LP_REPLACE. */
    if (where == LP_AFTER) {
        p = lpSkip(p);
        where = LP_BEFORE;
        ASSERT_INTEGRITY(lp, p);
    }

    /* Store ...",780.0,927.0,1.0,25.0,148.0,142,23,152,22,6,10,19,27,3,10,,0,7,14,7,7,unsigned char*
2752,157167,lpInsertString,1,lpInsertString,"unsigned char* lpInsertString (unsigned char*,unsigned char*,uint32_t,unsigned char*,int,unsigned char**)",listpack.c,"unsigned char *lpInsertString(unsigned char *lp, unsigned char *s, uint32_t slen,
                              unsigned char *p, int where, unsigned char **newp)
{
    return lpInsert(lp, s, NULL, slen, p, where, newp);
}",930.0,934.0,1.0,1.0,5.0,0,0,7,7,1,1,1,1,0,1,,0,0,12,6,6,unsigned char*
2753,157186,lpInsertInteger,1,lpInsertInteger,"unsigned char* lpInsertInteger (unsigned char*,long long,unsigned char*,int,unsigned char**)",listpack.c,"unsigned char *lpInsertInteger(unsigned char *lp, long long lval, unsigned char *p, int where, unsigned char **newp) {
    uint64_t enclen; /* The length of the encoded element. */
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];

    lpEncodeIntegerGetType(lval, intenc, &enclen);
    return lpInsert(lp, NULL, intenc, enclen, p, where, newp);
}",938.0,944.0,1.0,25.0,7.0,1,1,10,8,3,2,1,1,0,2,,0,0,10,5,5,unsigned char*
2754,157211,lpPrepend,1,lpPrepend,"unsigned char* lpPrepend (unsigned char*,unsigned char*,uint32_t)",listpack.c,"unsigned char *lpPrepend(unsigned char *lp, unsigned char *s, uint32_t slen) {
    unsigned char *p = lpFirst(lp);
    if (!p) return lpAppend(lp, s, slen);
    return lpInsert(lp, s, NULL, slen, p, LP_BEFORE, NULL);
}",947.0,951.0,1.0,42.0,5.0,2,2,12,5,2,3,2,2,0,3,,0,1,6,3,3,unsigned char*
2755,157243,lpPrependInteger,1,lpPrependInteger,"unsigned char* lpPrependInteger (unsigned char*,long long)",listpack.c,"unsigned char *lpPrependInteger(unsigned char *lp, long long lval) {
    unsigned char *p = lpFirst(lp);
    if (!p) return lpAppendInteger(lp, lval);
    return lpInsertInteger(lp, lval, p, LP_BEFORE, NULL);
}",954.0,958.0,1.0,40.0,5.0,2,2,9,4,0,3,2,2,0,3,,0,1,4,2,2,unsigned char*
2756,157271,lpAppend,1,lpAppend,"unsigned char* lpAppend (unsigned char*,unsigned char*,uint32_t)",listpack.c,"unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
    uint64_t listpack_bytes = lpGetTotalBytes(lp);
    unsigned char *eofptr = lp + listpack_bytes - 1;
    return lpInsert(lp,ele,NULL,size,eofptr,LP_BEFORE,NULL);
}",963.0,967.0,1.0,30.0,5.0,15,6,15,6,5,1,1,1,0,1,,0,0,6,3,3,unsigned char*
2757,157330,lpAppendInteger,1,lpAppendInteger,"unsigned char* lpAppendInteger (unsigned char*,long long)",listpack.c,"unsigned char *lpAppendInteger(unsigned char *lp, long long lval) {
    uint64_t listpack_bytes = lpGetTotalBytes(lp);
    unsigned char *eofptr = lp + listpack_bytes - 1;
    return lpInsertInteger(lp, lval, eofptr, LP_BEFORE, NULL);
}",970.0,974.0,1.0,30.0,5.0,15,6,13,5,2,1,1,1,0,1,,0,0,4,2,2,unsigned char*
2758,157386,lpReplace,1,lpReplace,"unsigned char* lpReplace (unsigned char*,unsigned char**,unsigned char*,uint32_t)",listpack.c,"unsigned char *lpReplace(unsigned char *lp, unsigned char **p, unsigned char *s, uint32_t slen) {
    return lpInsert(lp, s, NULL, slen, *p, LP_REPLACE, p);
}",979.0,981.0,1.0,43.0,3.0,1,1,6,5,1,1,1,1,0,1,,0,0,8,4,4,unsigned char*
2759,157406,lpReplaceInteger,1,lpReplaceInteger,"unsigned char* lpReplaceInteger (unsigned char*,unsigned char**,long long)",listpack.c,"unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **p, long long lval) {
    return lpInsertInteger(lp, lval, *p, LP_REPLACE, p);
}",987.0,989.0,1.0,41.0,3.0,1,1,4,3,3,1,1,1,0,1,,0,0,6,3,3,unsigned char*
2760,157423,lpDelete,1,lpDelete,"unsigned char* lpDelete (unsigned char*,unsigned char*,unsigned char**)",listpack.c,"unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {
    return lpInsert(lp,NULL,NULL,0,p,LP_REPLACE,newp);
}",995.0,997.0,1.0,37.0,3.0,0,0,5,4,2,1,1,1,0,1,,0,0,6,3,3,unsigned char*
2761,157441,lpDeleteRangeWithEntry,1,lpDeleteRangeWithEntry,"unsigned char* lpDeleteRangeWithEntry (unsigned char*,unsigned char**,long unsigned)",listpack.c,"unsigned char *lpDeleteRangeWithEntry(unsigned char *lp, unsigned char **p, unsigned long num) {
    size_t bytes = lpBytes(lp);
    unsigned long deleted = 0;
    unsigned char *eofptr = lp + bytes - 1;
    unsigned char *first, *tail;
    first = tail = *p;

    if (num == 0) return lp;  /* Nothing to delete, return ASAP. */

    /* Find the next entry to the last entry that needs to be deleted.
     * lpLength may be unreliable due to corrupt data, so we cannot
     * treat 'num' as the number of elements to be deleted. */
    while (num--) {
        deleted++;
        tail = lpSkip(tail);
        if (tail[0] == LP_EOF) break;
        lpAssertValidEntry(lp, bytes, tail);
    }

    /* Store the offset of the element 'first', so that we can obtain its
     * address again after a reallocation. */
    unsigned long poff = first-lp;

    /* Move tail to the front of the listpack */
    memmove(first, tail, eofptr - tail + 1);
    lpSetTotalBytes(lp, bytes - (tail - first));
    uint...",1000.0,1036.0,1.0,23.0,37.0,66,13,65,12,3,4,7,7,0,4,,0,3,6,3,3,unsigned char*
2762,157652,lpDeleteRange,1,lpDeleteRange,"unsigned char* lpDeleteRange (unsigned char*,long,long unsigned)",listpack.c,"unsigned char *lpDeleteRange(unsigned char *lp, long index, unsigned long num) {
    unsigned char *p;
    uint32_t numele = lpGetNumElements(lp);

    if (num == 0) return lp; /* Nothing to delete, return ASAP. */
    if ((p = lpSeek(lp, index)) == NULL) return lp;

    /* If we know we're gonna delete beyond the end of the listpack, we can just move
     * the EOF marker, and there's no need to iterate through the entries,
     * but if we can't be sure how many entries there are, we rather avoid calling lpLength
     * since that means an additional iteration on all elements.
     *
     * Note that index could overflow, but we use the value after seek, so when we
     * use it no overflow happens. */
    if (numele != LP_HDR_NUMELE_UNKNOWN && index < 0) index = (long)numele + index;
    if (numele != LP_HDR_NUMELE_UNKNOWN && (numele - (unsigned long)index) <= num) {
        p[0] = LP_EOF;
        lpSetTotalBytes(lp, p - lp + 1);
        lpSetNumElements(lp, index);
        lp = ...",1039.0,1064.0,1.0,22.0,26.0,53,14,45,7,3,2,5,5,1,2,,0,2,6,3,3,unsigned char*
2763,157831,lpBatchDelete,1,lpBatchDelete,"unsigned char* lpBatchDelete (unsigned char*,unsigned char**,long unsigned)",listpack.c,"unsigned char *lpBatchDelete(unsigned char *lp, unsigned char **ps, unsigned long count) {
    if (count == 0) return lp;
    unsigned char *dst = ps[0];
    size_t total_bytes = lpGetTotalBytes(lp);
    unsigned char *lp_end = lp + total_bytes; /* After the EOF element. */
    assert(lp_end[-1] == LP_EOF);
    /*
     * ----+--------+-----------+--------+---------+-----+---+
     * ... | Delete | Keep      | Delete | Keep    | ... |EOF|
     * ... |xxxxxxxx|           |xxxxxxxx|         | ... |   |
     * ----+--------+-----------+--------+---------+-----+---+
     *     ^        ^           ^                            ^
     *     |        |           |                            |
     *     ps[i]    |           ps[i+1]                      |
     *     skip     keep_start  keep_end                     lp_end
     *
     * The loop memmoves the bytes between keep_start and keep_end to dst.
     */
    for (unsigned long i = 0; i < count; i++) {
        unsigned char *skip = ps[i...",1069.0,1113.0,1.0,25.0,45.0,92,20,73,15,1,6,7,9,0,6,,0,1,6,3,3,unsigned char*
2764,158134,lpMerge,1,lpMerge,"unsigned char* lpMerge (unsigned char**,unsigned char**)",listpack.c,"unsigned char *lpMerge(unsigned char **first, unsigned char **second) {
    /* If any params are null, we can't merge, so NULL. */
    if (first == NULL || *first == NULL || second == NULL || *second == NULL)
        return NULL;

    /* Can't merge same list into itself. */
    if (*first == *second)
        return NULL;

    size_t first_bytes = lpBytes(*first);
    unsigned long first_len = lpLength(*first);

    size_t second_bytes = lpBytes(*second);
    unsigned long second_len = lpLength(*second);

    int append;
    unsigned char *source, *target;
    size_t target_bytes, source_bytes;
    /* Pick the largest listpack so we can resize easily in-place.
     * We must also track if we are now appending or prepending to
     * the target listpack. */
    if (first_bytes >= second_bytes) {
        /* retain first, append second to first. */
        target = *first;
        target_bytes = first_bytes;
        source = *second;
        source_bytes = second_bytes;
        append ...",1130.0,1210.0,1.0,82.0,81.0,75,15,78,16,1,7,6,6,0,7,,0,5,4,2,2,unsigned char*
2765,158434,lpDup,1,lpDup,unsigned char* lpDup (unsigned char*),listpack.c,"unsigned char *lpDup(unsigned char *lp) {
    size_t lpbytes = lpBytes(lp);
    unsigned char *newlp = lp_malloc(lpbytes);
    memcpy(newlp, lp, lpbytes);
    return newlp;
}",1212.0,1217.0,1.0,27.0,6.0,2,1,10,4,0,2,1,1,0,2,,0,2,2,1,1,unsigned char*
2766,158459,lpBytes,1,lpBytes,size_t lpBytes (unsigned char*),listpack.c,"size_t lpBytes(unsigned char *lp) {
    return lpGetTotalBytes(lp);
}",1220.0,1222.0,1.0,11.0,3.0,11,3,5,1,19,0,1,1,0,0,,0,0,2,1,1,size_t
2767,158495,lpEstimateBytesRepeatedInteger,1,lpEstimateBytesRepeatedInteger,"size_t lpEstimateBytesRepeatedInteger (long long,long unsigned)",listpack.c,"size_t lpEstimateBytesRepeatedInteger(long long lval, unsigned long rep) {
    uint64_t enclen;
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
    lpEncodeIntegerGetType(lval, intenc, &enclen);
    unsigned long backlen = lpEncodeBacklen(NULL, enclen);
    return LP_HDR_SIZE + (enclen + backlen) * rep + 1;
}",1225.0,1231.0,1.0,25.0,7.0,6,4,9,6,0,2,1,1,0,2,,0,1,4,2,2,size_t
2768,158526,lpSeek,1,lpSeek,"unsigned char* lpSeek (unsigned char*,long)",listpack.c,"unsigned char *lpSeek(unsigned char *lp, long index) {
    int forward = 1; /* Seek forward by default. */

    /* We want to seek from left to right or the other way around
     * depending on the listpack length and the element position.
     * However if the listpack length cannot be obtained in constant time,
     * we always seek from left to right. */
    uint32_t numele = lpGetNumElements(lp);
    if (numele != LP_HDR_NUMELE_UNKNOWN) {
        if (index < 0) index = (long)numele+index;
        if (index < 0) return NULL; /* Index still < 0 means out of range. */
        if (index >= (long)numele) return NULL; /* Out of range the other side. */
        /* We want to scan right-to-left if the element we are looking for
         * is past the half of the listpack. */
        if (index > (long)numele/2) {
            forward = 0;
            /* Right to left scanning always expects a negative index. Convert
             * our index to negative form. */
            index -= numele...",1238.0,1280.0,1.0,22.0,43.0,25,14,31,7,13,2,8,13,0,2,,0,2,4,2,2,unsigned char*
2769,158689,lpValidateNext,1,lpValidateNext,"int lpValidateNext (unsigned char*,unsigned char**,size_t)",listpack.c,"int lpValidateNext(unsigned char *lp, unsigned char **pp, size_t lpbytes) {
#define OUT_OF_RANGE(p) ( \
        (p) < lp + LP_HDR_SIZE || \
        (p) > lp + lpbytes - 1)
    unsigned char *p = *pp;
    if (!p)
        return 0;

    /* Before accessing p, make sure it's valid. */
    if (OUT_OF_RANGE(p))
        return 0;

    if (*p == LP_EOF) {
        *pp = NULL;
        return 1;
    }

    /* check that we can read the encoded size */
    uint32_t lenbytes = lpCurrentEncodedSizeBytes(p);
    if (!lenbytes)
        return 0;

    /* make sure the encoded entry length doesn't reach outside the edge of the listpack */
    if (OUT_OF_RANGE(p + lenbytes))
        return 0;

    /* get the entry length and encoded backlen. */
    unsigned long entrylen = lpCurrentEncodedSizeUnsafe(p);
    unsigned long encodedBacklen = lpEncodeBacklen(NULL,entrylen);
    entrylen += encodedBacklen;

    /* make sure the entry doesn't reach outside the edge of the listpack */
    if (OUT_OF_RANGE(p ...",1292.0,1338.0,1.0,8.0,47.0,41,11,45,9,1,4,8,8,0,4,,0,4,6,3,3,int
2770,158862,lpValidateIntegrity,1,lpValidateIntegrity,"int lpValidateIntegrity (unsigned char*,size_t,int,listpackValidateEntryCB,void*)",listpack.c,"int lpValidateIntegrity(unsigned char *lp, size_t size, int deep, 
                        listpackValidateEntryCB entry_cb, void *cb_userdata) {
    /* Check that we can actually read the header. (and EOF) */
    if (size < LP_HDR_SIZE + 1)
        return 0;

    /* Check that the encoded size in the header must match the allocated size. */
    size_t bytes = lpGetTotalBytes(lp);
    if (bytes != size)
        return 0;

    /* The last byte must be the terminator. */
    if (lp[size-1] != LP_EOF)
        return 0;

    if (!deep)
        return 1;

    /* Validate the individual entries. */
    uint32_t count = 0;
    uint32_t numele = lpGetNumElements(lp);
    unsigned char *p = lp + LP_HDR_SIZE;
    while(p && p[0] != LP_EOF) {
        unsigned char *prev = p;

        /* Validate this entry and move to the next entry in advance
         * to avoid callback crash due to corrupt listpack. */
        if (!lpValidateNext(lp, &p, bytes))
            return 0;

        /* Optionally ...",1348.0,1394.0,1.0,15.0,47.0,43,12,38,11,2,1,10,12,1,1,,0,1,10,5,5,int
2771,159036,lpCompare,1,lpCompare,"unsigned int lpCompare (unsigned char*,unsigned char*,uint32_t)",listpack.c,"unsigned int lpCompare(unsigned char *p, unsigned char *s, uint32_t slen) {
    unsigned char *value;
    int64_t sz;
    if (p[0] == LP_EOF) return 0;

    value = lpGet(p, &sz, NULL);
    if (value) {
        return (slen == sz) && memcmp(value,s,slen) == 0;
    } else {
        /* We use lpStringToInt64() to get an integer representation of the
         * string 's' and compare it to 'sval', it's much faster than convert
         * integer to string and comparing. */
        int64_t sval;
        if (lpStringToInt64((const char*)s, slen, &sval))
            return sz == sval;
    }

    return 0;
}",1398.0,1416.0,1.0,16.0,19.0,7,5,11,6,1,1,3,3,0,1,,0,1,6,3,3,unsigned int
2772,159111,lpSaveValue,1,lpSaveValue,"void lpSaveValue (unsigned char*,unsigned int,int64_t,listpackEntry*)",listpack.c,"static inline void lpSaveValue(unsigned char *val, unsigned int len, int64_t lval, listpackEntry *dest) {
    dest->sval = val;
    dest->slen = len;
    dest->lval = lval;
}",1424.0,1428.0,1.0,1.0,5.0,6,2,6,4,5,3,1,1,0,0,,0,3,8,4,4,void
2773,159134,lpRandomPair,1,lpRandomPair,"void lpRandomPair (unsigned char*,long unsigned,listpackEntry*,listpackEntry*)",listpack.c,"void lpRandomPair(unsigned char *lp, unsigned long total_count, listpackEntry *key, listpackEntry *val) {
    unsigned char *p;

    /* Avoid div by zero on corrupt listpack */
    assert(total_count);

    /* Generate even numbers, because listpack saved K-V pair */
    int r = (rand() % total_count) * 2;
    assert((p = lpSeek(lp, r)));
    key->sval = lpGetValue(p, &(key->slen), &(key->lval));

    if (!val)
        return;
    assert((p = lpNext(lp, p)));
    val->sval = lpGetValue(p, &(val->slen), &(val->lval));
}",1434.0,1449.0,1.0,4.0,16.0,30,10,19,6,0,13,2,2,0,7,,0,10,8,4,4,void
2774,159235,lpRandomEntries,1,lpRandomEntries,"void lpRandomEntries (unsigned char*,unsigned int,listpackEntry*)",listpack.c,"void lpRandomEntries(unsigned char *lp, unsigned int count, listpackEntry *entries) {
    struct pick {
        unsigned int index;
        unsigned int order;
    } *picks = lp_malloc(count * sizeof(struct pick));
    unsigned int total_size = lpLength(lp);
    assert(total_size);
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = rand() % total_size;
        picks[i].order = i;
    }

    /* Sort by index. */
    qsort(picks, count, sizeof(struct pick), uintCompare);

    /* Iterate over listpack in index order and store the values in the entries
     * array respecting the original order. */
    unsigned char *p = lpFirst(lp);
    unsigned int j = 0; /* index in listpack */
    for (unsigned int i = 0; i < count; i++) {
        /* Advance listpack pointer to until we reach 'index' listpack. */
        while (j < picks[i].index) {
            p = lpNext(lp, p);
            j++;
        }
        int storeorder = picks[i].order;
        unsigned int len = 0;
  ...",1454.0,1486.0,1.0,15.0,33.0,37,13,48,15,1,8,4,5,0,8,,0,5,6,3,3,void
2775,159381,lpRandomPairs,1,lpRandomPairs,"void lpRandomPairs (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)",listpack.c,"void lpRandomPairs(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    unsigned char *p, *key, *value;
    unsigned int klen = 0, vlen = 0;
    long long klval = 0, vlval = 0;

    /* Notice: the index member must be first due to the use in uintCompare */
    typedef struct {
        unsigned int index;
        unsigned int order;
    } rand_pick;
    rand_pick *picks = lp_malloc(sizeof(rand_pick)*count);
    unsigned int total_size = lpLength(lp)/2;

    /* Avoid div by zero on corrupt listpack */
    assert(total_size);

    /* create a pool of random indexes (some may be duplicate). */
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = (rand() % total_size) * 2; /* Generate even indexes */
        /* keep track of the order we picked them */
        picks[i].order = i;
    }

    /* sort by indexes. */
    qsort(picks, count, sizeof(rand_pick), uintCompare);

    /* fetch the elements form the listpack into a output array re...",1492.0,1537.0,1.0,23.0,46.0,57,17,69,19,0,12,5,8,0,12,,0,7,8,4,4,void
2776,159590,lpRandomPairsUnique,1,lpRandomPairsUnique,"unsigned int lpRandomPairsUnique (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)",listpack.c,"unsigned int lpRandomPairsUnique(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    unsigned char *p, *key;
    unsigned int klen = 0;
    long long klval = 0;
    unsigned int total_size = lpLength(lp)/2;
    unsigned int index = 0;
    if (count > total_size)
        count = total_size;

    p = lpFirst(lp);
    unsigned int picked = 0, remaining = count;
    while (picked < count && p) {
        assert((p = lpNextRandom(lp, p, &index, remaining, 1)));
        key = lpGetValue(p, &klen, &klval);
        lpSaveValue(key, klen, klval, &keys[picked]);
        assert((p = lpNext(lp, p)));
        index++;
        if (vals) {
            key = lpGetValue(p, &klen, &klval);
            lpSaveValue(key, klen, klval, &vals[picked]);
        }
        p = lpNext(lp, p);
        remaining--;
        picked++;
        index++;
    }
    return picked;
}",1545.0,1572.0,1.0,8.0,28.0,38,13,52,12,2,11,4,5,0,11,,0,7,8,4,4,unsigned int
2777,159736,lpNextRandom,1,lpNextRandom,"unsigned char* lpNextRandom (unsigned char*,unsigned char*,unsigned int*,unsigned int,int)",listpack.c,"unsigned char *lpNextRandom(unsigned char *lp, unsigned char *p, unsigned int *index,
                            unsigned int remaining, int even_only)
{
    /* To only iterate once, every time we try to pick a member, the probability
     * we pick it is the quotient of the count left we want to pick and the
     * count still we haven't visited. This way, we could make every member be
     * equally likely to be picked. */
    unsigned int i = *index;
    unsigned int total_size = lpLength(lp);
    while (i < total_size && p != NULL) {
        if (even_only && i % 2 != 0) {
            p = lpNext(lp, p);
            i++;
            continue;
        }

        /* Do we pick this element? */
        unsigned int available = total_size - i;
        if (even_only) available /= 2;
        double randomDouble = ((double)rand()) / RAND_MAX;
        double threshold = ((double)remaining) / available;
        if (randomDouble <= threshold) {
            *index = i;
            return p;...",1598.0,1629.0,1.0,1.0,32.0,25,12,34,12,4,3,6,8,0,3,,0,3,10,5,5,unsigned char*
2778,159829,lpRepr,1,lpRepr,void lpRepr (unsigned char*),listpack.c,"void lpRepr(unsigned char *lp) {
    unsigned char *p, *vstr;
    int64_t vlen;
    unsigned char intbuf[LP_INTBUF_SIZE];
    int index = 0;

    printf(""{total bytes %zu} {num entries %lu}\n"", lpBytes(lp), lpLength(lp));
        
    p = lpFirst(lp);
    while(p) {
        uint32_t encoded_size_bytes = lpCurrentEncodedSizeBytes(p);
        uint32_t encoded_size = lpCurrentEncodedSizeUnsafe(p);
        unsigned long back_len = lpEncodeBacklen(NULL, encoded_size);
        printf(
            ""{\n""
                ""\taddr: 0x%08lx,\n""
                ""\tindex: %2d,\n""
                ""\toffset: %1lu,\n""
                ""\thdr+entrylen+backlen: %2lu,\n""
                ""\thdrlen: %3u,\n""
                ""\tbacklen: %2lu,\n""
                ""\tpayload: %1u\n"",
            (long unsigned)p,
            index,
            (unsigned long) (p-lp),
            encoded_size + back_len,
            encoded_size_bytes,
            back_len,
            encoded_size - encoded_size_bytes);
      ...",1632.0,1680.0,1.0,25.0,49.0,20,10,40,12,1,8,5,9,0,8,,0,6,2,1,1,void
2779,160261,is_leap_year,1,is_leap_year,int is_leap_year (time_t),localtime.c,"static int is_leap_year(time_t year) {
    if (year % 4) return 0;         /* A year not divisible by 4 is not leap. */
    else if (year % 100) return 1;  /* If div by 4 and not 100 is surely leap. */
    else if (year % 400) return 0;  /* If div by 100 *and* not by 400 is not leap. */
    else return 1;                  /* If div by 100 and 400 is leap. */
}",52.0,57.0,1.0,1.0,6.0,1,1,1,1,2,0,2,2,0,0,,0,0,2,1,1,int
2780,160295,nolocks_localtime,1,nolocks_localtime,"void nolocks_localtime (tm*,time_t,time_t,int)",localtime.c,"void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst) {
    const time_t secs_min = 60;
    const time_t secs_hour = 3600;
    const time_t secs_day = 3600*24;

    t -= tz;                            /* Adjust for timezone. */
    t += 3600*dst;                      /* Adjust for daylight time. */
    time_t days = t / secs_day;         /* Days passed since epoch. */
    time_t seconds = t % secs_day;      /* Remaining seconds. */

    tmp->tm_isdst = dst;
    tmp->tm_hour = seconds / secs_hour;
    tmp->tm_min = (seconds % secs_hour) / secs_min;
    tmp->tm_sec = (seconds % secs_hour) % secs_min;

    /* 1/1/1970 was a Thursday, that is, day 4 from the POV of the tm structure
     * where sunday = 0, so to calculate the day of the week we have to add 4
     * and take the modulo by 7. */
    tmp->tm_wday = (days+4)%7;

    /* Calculate the current year. */
    tmp->tm_year = 1970;
    while(1) {
        /* Leap years have one day more. */
        time_t days_this_ye...",59.0,104.0,1.0,1.0,46.0,59,13,52,11,0,2,5,5,0,2,,0,1,8,4,4,void
2781,160499,reqresSaveClientReplyOffset,1,reqresSaveClientReplyOffset,void reqresSaveClientReplyOffset (client*),logreqres.c,"inline void reqresSaveClientReplyOffset(client *c) {
    UNUSED(c);
}",301.0,303.0,1.0,4.0,3.0,1,1,2,1,2,0,1,1,0,0,,0,0,2,1,1,void
2782,160510,reqresAppendRequest,1,reqresAppendRequest,size_t reqresAppendRequest (client*),logreqres.c,"inline size_t reqresAppendRequest(client *c) {
    UNUSED(c);
    return 0;
}",305.0,308.0,1.0,4.0,4.0,1,1,2,1,1,0,1,1,0,0,,0,0,2,1,1,size_t
2783,160523,reqresAppendResponse,1,reqresAppendResponse,size_t reqresAppendResponse (client*),logreqres.c,"inline size_t reqresAppendResponse(client *c) {
    UNUSED(c);
    return 0;
}",310.0,313.0,1.0,4.0,4.0,1,1,2,1,2,0,1,1,0,0,,0,0,2,1,1,size_t
2784,160547,lolwut5Command,1,lolwut5Command,void lolwut5Command (client*),lolwut5.c,"void lolwut5Command(client *c) {
    long cols = 66;
    long squares_per_row = 8;
    long squares_per_col = 12;

    /* Parse the optional arguments if any. */
    if (c->argc > 1 &&
        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
        return;

    if (c->argc > 2 &&
        getLongFromObjectOrReply(c,c->argv[2],&squares_per_row,NULL) != C_OK)
        return;

    if (c->argc > 3 &&
        getLongFromObjectOrReply(c,c->argv[3],&squares_per_col,NULL) != C_OK)
        return;

    /* Limits. We want LOLWUT to be always reasonably fast and cheap to execute
     * so we have maximum number of columns, rows, and output resolution. */
    if (cols < 1) cols = 1;
    if (cols > 1000) cols = 1000;
    if (squares_per_row < 1) squares_per_row = 1;
    if (squares_per_row > 200) squares_per_row = 200;
    if (squares_per_col < 1) squares_per_col = 1;
    if (squares_per_col > 200) squares_per_col = 200;

    /* Generate some computer art and reply. */
    lwCanvas *ca...",140.0,177.0,1.0,61.0,38.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2785,160557,lolwutUnstableCommand,1,lolwutUnstableCommand,void lolwutUnstableCommand (client*),lolwut.c,"void lolwutUnstableCommand(client *c) {
    sds rendered = sdsnew(""Redis ver. "");
    rendered = sdscat(rendered,REDIS_VERSION);
    rendered = sdscatlen(rendered,""\n"",1);
    addReplyVerbatim(c,rendered,sdslen(rendered),""txt"");
    sdsfree(rendered);
}",45.0,51.0,1.0,31.0,7.0,3,1,9,2,0,6,1,1,0,6,,0,4,2,1,1,void
2786,160588,lolwutCommand,1,lolwutCommand,void lolwutCommand (client*),lolwut.c,"void lolwutCommand(client *c) {
    char *v = REDIS_VERSION;
    char verstr[64];

    if (c->argc >= 3 && !strcasecmp(c->argv[1]->ptr,""version"")) {
        long ver;
        if (getLongFromObjectOrReply(c,c->argv[2],&ver,NULL) != C_OK) return;
        snprintf(verstr,sizeof(verstr),""%u.0.0"",(unsigned int)ver);
        v = verstr;

        /* Adjust argv/argc to filter the ""VERSION ..."" option, since the
         * specific LOLWUT version implementations don't know about it
         * and expect their arguments. */
        c->argv += 2;
        c->argc -= 2;
    }

    if ((v[0] == '5' && v[1] == '.' && v[2] != '9') ||
        (v[0] == '4' && v[1] == '.' && v[2] == '9'))
        lolwut5Command(c);
    else if ((v[0] == '6' && v[1] == '.' && v[2] != '9') ||
             (v[0] == '5' && v[1] == '.' && v[2] == '9'))
        lolwut6Command(c);
    else
        lolwutUnstableCommand(c);

    /* Fix back argc/argv in case of VERSION argument. */
    if (v == verstr) {
        c->argv -= 2...",54.0,85.0,1.0,14.0,32.0,41,14,25,5,0,9,5,6,4,2,,0,8,2,1,1,void
2787,160756,lwCreateCanvas,1,lwCreateCanvas,"lwCanvas lwCreateCanvas (int,int,int)",lolwut.c,"lwCanvas *lwCreateCanvas(int width, int height, int bgcolor) {
    lwCanvas *canvas = zmalloc(sizeof(*canvas));
    canvas->width = width;
    canvas->height = height;
    canvas->pixels = zmalloc((size_t)width*height);
    memset(canvas->pixels,bgcolor,(size_t)width*height);
    return canvas;
}",93.0,100.0,1.0,1.0,8.0,14,6,14,4,1,6,1,1,0,2,,0,6,6,3,3,lwCanvas
2788,160802,lwFreeCanvas,1,lwFreeCanvas,void lwFreeCanvas (lwCanvas*),lolwut.c,"void lwFreeCanvas(lwCanvas *canvas) {
    zfree(canvas->pixels);
    zfree(canvas);
}",103.0,106.0,1.0,1.0,4.0,1,1,2,1,0,3,1,1,0,2,,0,1,2,1,1,void
2789,160813,lwDrawPixel,1,lwDrawPixel,"void lwDrawPixel (lwCanvas*,int,int,int)",lolwut.c,"void lwDrawPixel(lwCanvas *canvas, int x, int y, int color) {
    if (x < 0 || x >= canvas->width ||
        y < 0 || y >= canvas->height) return;
    canvas->pixels[x+y*canvas->width] = color;
}",112.0,116.0,1.0,1.0,5.0,15,8,11,4,2,4,2,2,2,0,,0,4,8,4,4,void
2790,160856,lwGetPixel,1,lwGetPixel,"int lwGetPixel (lwCanvas*,int,int)",lolwut.c,"int lwGetPixel(lwCanvas *canvas, int x, int y) {
    if (x < 0 || x >= canvas->width ||
        y < 0 || y >= canvas->height) return 0;
    return canvas->pixels[x+y*canvas->width];
}",119.0,123.0,1.0,1.0,5.0,14,7,10,3,9,4,2,2,2,0,,0,4,6,3,3,int
2791,160898,lwDrawLine,1,lwDrawLine,"void lwDrawLine (lwCanvas*,int,int,int,int,int)",lolwut.c,"void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
    int dx = abs(x2-x1);
    int dy = abs(y2-y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx-dy, e2;

    while(1) {
        lwDrawPixel(canvas,x1,y1,color);
        if (x1 == x2 && y1 == y2) break;
        e2 = err*2;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}",126.0,146.0,1.0,1.0,21.0,26,11,37,12,0,1,6,8,0,1,,0,0,12,6,6,void
2792,160995,lwDrawSquare,1,lwDrawSquare,"void lwDrawSquare (lwCanvas*,int,int,float,float,int)",lolwut.c,"void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle, int color) {
    int px[4], py[4];

    /* Adjust the desired size according to the fact that the square inscribed
     * into a circle of radius 1 has the side of length SQRT(2). This way
     * size becomes a simple multiplication factor we can use with our
     * coordinates to magnify them. */
    size /= 1.4142135623;
    size = round(size);

    /* Compute the four points. */
    float k = M_PI/4 + angle;
    for (int j = 0; j < 4; j++) {
        px[j] = round(sin(k) * size + x);
        py[j] = round(cos(k) * size + y);
        k += M_PI/2;
    }

    /* Draw the square. */
    for (int j = 0; j < 4; j++)
        lwDrawLine(canvas,px[j],py[j],px[(j+1)%4],py[(j+1)%4],color);
}",167.0,188.0,1.0,1.0,22.0,19,8,22,9,1,0,3,3,0,0,,0,0,12,6,6,void
2793,161165,lwTranslatePixelsGroup,1,lwTranslatePixelsGroup,"void lwTranslatePixelsGroup (int,char*)",lolwut5.c,"void lwTranslatePixelsGroup(int byte, char *output) {
    int code = 0x2800 + byte;
    /* Convert to unicode. This is in the U0800-UFFFF range, so we need to
     * emit it like this in three bytes:
     * 1110xxxx 10xxxxxx 10xxxxxx. */
    output[0] = 0xE0 | (code >> 12);          /* 1110-xxxx */
    output[1] = 0x80 | ((code >> 6) & 0x3F);  /* 10-xxxxxx */
    output[2] = 0x80 | (code & 0x3F);         /* 10-xxxxxx */
}",54.0,62.0,1.0,1.0,9.0,15,6,8,3,1,0,1,1,0,0,,0,0,4,2,2,void
2794,161206,lwDrawSchotter,1,lwDrawSchotter,"lwCanvas lwDrawSchotter (int,int,int)",lolwut5.c,"lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_col) {
    /* Calculate the canvas size. */
    int canvas_width = console_cols*2;
    int padding = canvas_width > 4 ? 2 : 0;
    float square_side = (float)(canvas_width-padding*2) / squares_per_row;
    int canvas_height = square_side * squares_per_col + padding*2;
    lwCanvas *canvas = lwCreateCanvas(canvas_width, canvas_height, 0);

    for (int y = 0; y < squares_per_col; y++) {
        for (int x = 0; x < squares_per_row; x++) {
            int sx = x * square_side + square_side/2 + padding;
            int sy = y * square_side + square_side/2 + padding;
            /* Rotate and translate randomly as we go down to lower
             * rows. */
            float angle = 0;
            if (y > 1) {
                float r1 = (float)rand() / (float) RAND_MAX / squares_per_col * y;
                float r2 = (float)rand() / (float) RAND_MAX / squares_per_col * y;
                float r3 = (float)ra...",71.0,102.0,1.0,1.0,32.0,65,12,65,17,0,2,7,19,0,2,,0,1,6,3,3,lwCanvas
2795,161409,renderCanvas,1,renderCanvas,sds renderCanvas (lwCanvas*),lolwut6.c,"static sds renderCanvas(lwCanvas *canvas) {
    sds text = sdsempty();
    for (int y = 0; y < canvas->height; y++) {
        for (int x = 0; x < canvas->width; x++) {
            int color = lwGetPixel(canvas,x,y);
            char *ce; /* Color escape sequence. */

            /* Note that we set both the foreground and background color.
             * This way we are able to get a more consistent result among
             * different terminals implementations. */
            switch(color) {
            case 0: ce = ""0;30;40m""; break;    /* Black */
            case 1: ce = ""0;90;100m""; break;   /* Gray 1 */
            case 2: ce = ""0;37;47m""; break;    /* Gray 2 */
            case 3: ce = ""0;97;107m""; break;   /* White */
            default: ce = ""0;30;40m""; break;   /* Just for safety. */
            }
            text = sdscatprintf(text,""\033[%s \033[0m"",ce);
        }
        if (y != canvas->height-1) text = sdscatlen(text,""\n"",1);
    }
    return text;
}",47.0,69.0,1.0,1.0,23.0,31,7,50,6,0,15,12,30,11,12,,0,14,2,1,1,sds
2796,161876,generateSkyscraper,1,generateSkyscraper,"void generateSkyscraper (lwCanvas*,skyscraper*)",lolwut6.c,"void generateSkyscraper(lwCanvas *canvas, struct skyscraper *si) {
    int starty = canvas->height-1;
    int endy = starty - si->height + 1;
    for (int y = starty; y >= endy; y--) {
        for (int x = si->xoff; x < si->xoff+si->width; x++) {
            /* The roof is four pixels less wide. */
            if (y == endy && (x <= si->xoff+1 || x >= si->xoff+si->width-2))
                continue;
            int color = si->color;
            /* Alter the color if this is a place where we want to
             * draw a window. We check that we are in the inner part of the
             * skyscraper, so that windows are far from the borders. */
            if (si->windows &&
                x > si->xoff+1 &&
                x < si->xoff+si->width-2 &&
                y > endy+1 &&
                y < starty-1)
            {
                /* Calculate the x,y position relative to the start of
                 * the window area. */
                int relx = x - (si->xoff+1);
      ...",82.0,120.0,1.0,1.0,39.0,64,13,53,9,2,17,9,24,10,2,,0,16,4,2,2,void
2797,162062,generateSkyline,1,generateSkyline,void generateSkyline (lwCanvas*),lolwut6.c,"void generateSkyline(lwCanvas *canvas) {
    struct skyscraper si;

    /* First draw the background skyscraper without windows, using the
     * two different grays. We use two passes to make sure that the lighter
     * ones are always in the background. */
    for (int color = 2; color >= 1; color--) {
        si.color = color;
        for (int offset = -10; offset < canvas->width;) {
            offset += rand() % 8;
            si.xoff = offset;
            si.width = 10 + rand()%9;
            if (color == 2)
                si.height = canvas->height/2 + rand()%canvas->height/2;
            else
                si.height = canvas->height/2 + rand()%canvas->height/3;
            si.windows = 0;
            generateSkyscraper(canvas, &si);
            if (color == 2)
                offset += si.width/2;
            else
                offset += si.width+1;
        }
    }

    /* Now draw the foreground skyscraper with the windows. */
    si.color = 0;
    for (int offset = -...",123.0,160.0,1.0,1.0,38.0,66,12,40,4,0,23,7,13,3,2,,0,21,2,1,1,void
2798,162412,lzf_compress,1,lzf_compress,"size_t lzf_compress (void*,size_t,void*,size_t)",lzf_c.c,"size_t
lzf_compress (const void *const in_data, size_t in_len,
	      void *out_data, size_t out_len
#if LZF_STATE_ARG
              , LZF_STATE htab
#endif
              )
{
#if !LZF_STATE_ARG
  LZF_STATE htab;
#endif
  const u8 *ip = (const u8 *)in_data;
        u8 *op = (u8 *)out_data;
  const u8 *in_end  = ip + in_len;
        u8 *out_end = op + out_len;
  const u8 *ref;

  /* off requires a type wide enough to hold a general pointer difference.
   * ISO C doesn't have that (size_t might not be enough and ptrdiff_t only
   * works for differences within a single object). We also assume that no
   * no bit pattern traps. Since the only platform that is both non-POSIX
   * and fails to support both assumptions is windows 64 bit, we make a
   * special workaround for it.
   */
#if defined (WIN32) && defined (_M_X64)
  unsigned _int64 off; /* workaround for missing POSIX compliance */
#else
  size_t off;
#endif
  unsigned int hval;
  int lit;

  if (!in_len || !out_len)
    return 0...",108.0,301.0,1.0,4.0,194.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,size_t
2799,162420,lzf_decompress,1,lzf_decompress,"size_t lzf_decompress (void*,size_t,void*,size_t)",lzf_d.c,"size_t
lzf_decompress (const void *const in_data,  size_t in_len,
                void             *out_data, size_t out_len)
{
  u8 const *ip = (const u8 *)in_data;
  u8       *op = (u8 *)out_data;
  u8 const *const in_end  = ip + in_len;
  u8       *const out_end = op + out_len;

  while (ip < in_end)
    {
      unsigned int ctrl;
      ctrl = *ip++;

      if (ctrl < (1 << 5)) /* literal run */
        {
          ctrl++;

          if (op + ctrl > out_end)
            {
              SET_ERRNO (E2BIG);
              return 0;
            }

#if CHECK_INPUT
          if (ip + ctrl > in_end)
            {
              SET_ERRNO (EINVAL);
              return 0;
            }
#endif

#ifdef lzf_movsb
          lzf_movsb (op, ip, ctrl);
#else
          switch (ctrl)
            {
              case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;
              case 28: *op++ = *ip++; case 27: *op++ = *ip++; case 26: *op++ = *ip++; case 25:...",59.0,188.0,1.0,14.0,130.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,size_t
2800,163872,memtest_progress_start,1,memtest_progress_start,"void memtest_progress_start (char*,int)",memtest.c,"void memtest_progress_start(char *title, int pass) {
    int j;

    printf(""\x1b[H\x1b[2J"");    /* Cursor home, clear screen. */
    /* Fill with dots. */
    for (j = 0; j < ws.ws_col*(ws.ws_row-2); j++) printf(""."");
    printf(""Please keep the test running several minutes per GB of memory.\n"");
    printf(""Also check http://www.memtest86.com/ and http://pyropus.ca/software/memtester/"");
    printf(""\x1b[H\x1b[2K"");          /* Cursor home, clear current line.  */
    printf(""%s [%d]\n"", title, pass); /* Print title. */
    progress_printed = 0;
    progress_full = (size_t)ws.ws_col*(ws.ws_row-3);
    fflush(stdout);
}",73.0,86.0,1.0,1.0,14.0,13,6,11,7,5,6,2,2,2,0,,0,6,4,2,2,void
2801,163929,memtest_progress_end,1,memtest_progress_end,void memtest_progress_end (void),memtest.c,"void memtest_progress_end(void) {
    printf(""\x1b[H\x1b[2J"");    /* Cursor home, clear screen. */
}",88.0,90.0,1.0,1.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
2802,163936,memtest_progress_step,1,memtest_progress_step,"void memtest_progress_step (size_t,size_t,char)",memtest.c,"void memtest_progress_step(size_t curr, size_t size, char c) {
    size_t chars = ((unsigned long long)curr*progress_full)/size, j;

    for (j = 0; j < chars-progress_printed; j++) printf(""%c"",c);
    progress_printed = chars;
    fflush(stdout);
}",92.0,98.0,1.0,1.0,7.0,8,6,11,7,5,3,2,2,1,0,,0,3,6,3,3,void
2803,163974,memtest_addressing,1,memtest_addressing,"int memtest_addressing (long unsigned*,size_t,int)",memtest.c,"int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
    unsigned long words = bytes/sizeof(unsigned long);
    unsigned long j, *p;

    /* Fill */
    p = l;
    for (j = 0; j < words; j++) {
        *p = (unsigned long)p;
        p++;
        if ((j & 0xffff) == 0 && interactive)
            memtest_progress_step(j,words*2,'A');
    }
    /* Test */
    p = l;
    for (j = 0; j < words; j++) {
        if (*p != (unsigned long)p) {
            if (interactive) {
                printf(""\n*** MEMORY ADDRESSING ERROR: %p contains %lu\n"",
                    (void*) p, *p);
                exit(1);
            }
            return 1;
        }
        p++;
        if ((j & 0xffff) == 0 && interactive)
            memtest_progress_step(j+words,words*2,'A');
    }
    return 0;
}",103.0,131.0,1.0,1.0,29.0,28,13,31,7,2,2,7,12,0,2,,0,0,6,3,3,int
2804,164084,memtest_fill_random,1,memtest_fill_random,"void memtest_fill_random (long unsigned*,size_t,int)",memtest.c,"void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
    unsigned long step = 4096/sizeof(unsigned long);
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long iwords = words/step;  /* words per iteration */
    unsigned long off, w, *l1, *l2;
    uint64_t rseed = UINT64_C(0xd13133de9afdb566); /* Just a random seed. */
    uint64_t rout = 0;

    assert((bytes & 4095) == 0);
    for (off = 0; off < step; off++) {
        l1 = l+off;
        l2 = l1+words;
        for (w = 0; w < iwords; w++) {
            xorshift64star_next();
            *l1 = *l2 = (unsigned long) rout;
            l1 += step;
            l2 += step;
            if ((w & 0xffff) == 0 && interactive)
                memtest_progress_step(w+iwords*off,words,'R');
        }
    }
}",148.0,169.0,1.0,12.0,22.0,38,14,44,13,2,1,4,7,0,1,,0,0,6,3,3,void
2805,164222,memtest_fill_value,1,memtest_fill_value,"void memtest_fill_value (long unsigned*,size_t,long unsigned,long unsigned,char,int)",memtest.c,"void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
                        unsigned long v2, char sym, int interactive)
{
    unsigned long step = 4096/sizeof(unsigned long);
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long iwords = words/step;  /* words per iteration */
    unsigned long off, w, *l1, *l2, v;

    assert((bytes & 4095) == 0);
    for (off = 0; off < step; off++) {
        l1 = l+off;
        l2 = l1+words;
        v = (off & 1) ? v2 : v1;
        for (w = 0; w < iwords; w++) {
#ifdef MEMTEST_32BIT
            *l1 = *l2 = ((unsigned long)     v) |
                        (((unsigned long)    v) << 16);
#else
            *l1 = *l2 = ((unsigned long)     v) |
                        (((unsigned long)    v) << 16) |
                        (((unsigned long)    v) << 32) |
                        (((unsigned long)    v) << 48);
#endif
            l1 += step;
            l2 += step;
            if ((w & 0xffff) == 0 && inte...",173.0,202.0,1.0,1.0,30.0,43,15,42,15,4,1,4,7,0,1,,0,0,12,6,6,void
2806,164355,memtest_compare,1,memtest_compare,"int memtest_compare (long unsigned*,size_t,int)",memtest.c,"int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long w, *l1, *l2;

    assert((bytes & 4095) == 0);
    l1 = l;
    l2 = l1+words;
    for (w = 0; w < words; w++) {
        if (*l1 != *l2) {
            if (interactive) {
                printf(""\n*** MEMORY ERROR DETECTED: %p != %p (%lu vs %lu)\n"",
                    (void*)l1, (void*)l2, *l1, *l2);
                exit(1);
            }
            return 1;
        }
        l1 ++;
        l2 ++;
        if ((w & 0xffff) == 0 && interactive)
            memtest_progress_step(w,words,'=');
    }
    return 0;
}",204.0,226.0,1.0,1.0,23.0,23,12,25,8,1,1,5,9,0,1,,0,0,6,3,3,int
2807,164444,memtest_compare_times,1,memtest_compare_times,"int memtest_compare_times (long unsigned*,size_t,int,int,int)",memtest.c,"int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
                          int interactive)
{
    int j;
    int errors = 0;

    for (j = 0; j < times; j++) {
        if (interactive) memtest_progress_start(""Compare"",pass);
        errors += memtest_compare(m,bytes,interactive);
        if (interactive) memtest_progress_end();
    }
    return errors;
}",228.0,240.0,1.0,1.0,13.0,4,3,12,7,12,3,4,6,0,3,,0,0,10,5,5,int
2808,164487,memtest_test,1,memtest_test,"int memtest_test (long unsigned*,size_t,int,int)",memtest.c,"int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
    int pass = 0;
    int errors = 0;

    while (pass != passes) {
        pass++;

        if (interactive) memtest_progress_start(""Addressing test"",pass);
        errors += memtest_addressing(m,bytes,interactive);
        if (interactive) memtest_progress_end();

        if (interactive) memtest_progress_start(""Random fill"",pass);
        memtest_fill_random(m,bytes,interactive);
        if (interactive) memtest_progress_end();
        errors += memtest_compare_times(m,bytes,pass,4,interactive);

        if (interactive) memtest_progress_start(""Solid fill"",pass);
        memtest_fill_value(m,bytes,0,(unsigned long)-1,'S',interactive);
        if (interactive) memtest_progress_end();
        errors += memtest_compare_times(m,bytes,pass,4,interactive);

        if (interactive) memtest_progress_start(""Checkerboard fill"",pass);
        memtest_fill_value(m,bytes,ULONG_ONEZERO,ULONG_ZEROONE,'C',interactiv...",247.0,274.0,1.0,35.0,28.0,10,6,46,6,1,15,10,18,0,15,,0,0,8,4,4,int
2809,164607,memtest_preserving_test,1,memtest_preserving_test,"int memtest_preserving_test (long unsigned*,size_t,int)",memtest.c,"int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
    unsigned long backup[MEMTEST_BACKUP_WORDS];
    unsigned long *p = m;
    unsigned long *end = (unsigned long*) (((unsigned char*)m)+(bytes-MEMTEST_DECACHE_SIZE));
    size_t left = bytes;
    int errors = 0;

    if (bytes & 4095) return 0; /* Can't test across 4k page boundaries. */
    if (bytes < 4096*2) return 0; /* Can't test a single page. */

    while(left) {
        /* If we have to test a single final page, go back a single page
         * so that we can test two pages, since the code can't test a single
         * page but at least two. */
        if (left == 4096) {
            left += 4096;
            p -= 4096/sizeof(unsigned long);
        }

        int pass = 0;
        size_t len = (left > sizeof(backup)) ? sizeof(backup) : left;

        /* Always test an even number of pages. */
        if (len/4096 % 2) len -= 4096;

        memcpy(backup,p,len); /* Backup. */
        while(pass != p...",292.0,345.0,1.0,25.0,54.0,50,19,74,11,0,13,10,19,0,13,,0,0,6,3,3,int
2810,164869,memtest_alloc_and_test,1,memtest_alloc_and_test,"void memtest_alloc_and_test (size_t,int)",memtest.c,"void memtest_alloc_and_test(size_t megabytes, int passes) {
    size_t bytes = megabytes*1024*1024;
    unsigned long *m = malloc(bytes);

    if (m == NULL) {
        fprintf(stderr,""Unable to allocate %zu megabytes: %s"",
            megabytes, strerror(errno));
        exit(1);
    }
    memtest_test(m,bytes,passes,1);
    free(m);
}",348.0,359.0,1.0,1.0,12.0,5,3,13,7,1,1,2,2,0,1,,0,0,4,2,2,void
2811,164908,memtest,1,memtest,"void memtest (size_t,int)",memtest.c,"void memtest(size_t megabytes, int passes) {
#if !defined(__HAIKU__)
    if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
        ws.ws_col = 80;
        ws.ws_row = 20;
    }
#else
    ws.ws_col = 80;
    ws.ws_row = 20;
#endif
    memtest_alloc_and_test(megabytes,passes);
    printf(""\nYour memory passed this test.\n"");
    printf(""Please if you are still in doubt use the following two tools:\n"");
    printf(""1) memtest86: http://www.memtest86.com/\n"");
    printf(""2) memtester: http://pyropus.ca/software/memtester/\n"");
    exit(0);
}",361.0,377.0,1.0,1.0,17.0,7,5,6,4,0,4,2,2,1,1,,0,3,4,2,2,void
2812,165104,free_privdata,1,RedisModuleBlockedClient.free_privdata,"void RedisModuleBlockedClient.free_privdata (RedisModuleCtx*,void*)",module.c,"void (*free_privdata)(RedisModuleCtx*,void*);",271.0,271.0,10.0,48.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2813,165166,free_pd,1,RedisModulePostExecUnitJob.free_pd,void RedisModulePostExecUnitJob.free_pd (void*),module.c,void (*free_pd)(void*);,335.0,335.0,10.0,26.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2814,165332,autoMemoryCollect,1,autoMemoryCollect,void autoMemoryCollect (RedisModuleCtx*),module.c,"void autoMemoryCollect(RedisModuleCtx *ctx) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
    /* Clear the AUTO_MEMORY flag from the context, otherwise the functions
     * we call to free the resources, will try to scan the auto release
     * queue to mark the entries as freed. */
    ctx->flags &= ~REDISMODULE_CTX_AUTO_MEMORY;
    int j;
    for (j = 0; j < ctx->amqueue_used; j++) {
        void *ptr = ctx->amqueue[j].ptr;
        switch(ctx->amqueue[j].type) {
        case REDISMODULE_AM_STRING: decrRefCount(ptr); break;
        case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;
        case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;
        case REDISMODULE_AM_DICT: RM_FreeDict(NULL,ptr); break;
        case REDISMODULE_AM_INFO: RM_FreeServerInfo(NULL,ptr); break;
        }
    }
    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
    zfree(ctx->amqueue);
    ctx->amqueue = NULL;
    ctx->amqueue_len = 0;
    ctx->amqueue_used = 0;
}",2492.0,2514.0,1.0,23.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2815,165337,moduleCreateArgvFromUserFormat,1,moduleCreateArgvFromUserFormat,"robj** moduleCreateArgvFromUserFormat (char*,char*,int*,int*,va_list)",module.c,"robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {
    int argc = 0, argv_size, j;
    robj **argv = NULL;

    /* As a first guess to avoid useless reallocations, size argv to
     * hold one argument for each char specifier in 'fmt'. */
    argv_size = strlen(fmt)+1; /* +1 because of the command name. */
    argv = zrealloc(argv,sizeof(robj*)*argv_size);

    /* Build the arguments vector based on the format specifier. */
    argv[0] = createStringObject(cmdname,strlen(cmdname));
    argc++;

    /* Create the client and dispatch the command. */
    const char *p = fmt;
    while(*p) {
        if (*p == 'c') {
            char *cstr = va_arg(ap,char*);
            argv[argc++] = createStringObject(cstr,strlen(cstr));
        } else if (*p == 's') {
            robj *obj = va_arg(ap,void*);
            if (obj->refcount == OBJ_STATIC_REFCOUNT)
                obj = createStringObject(obj->ptr,sdslen(obj->ptr));
        ...",6014.0,6100.0,1.0,33.0,87.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,robj
2816,165346,RM_ZsetRangeStop,1,RM_ZsetRangeStop,void RM_ZsetRangeStop (RedisModuleKey*),module.c,"void RM_ZsetRangeStop(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return;
    /* Free resources if needed. */
    if (key->u.zset.type == REDISMODULE_ZSET_RANGE_LEX)
        zslFreeLexRange(&key->u.zset.lrs);
    /* Setup sensible values so that misused iteration API calls when an
     * iterator is not active will result into something more sensible
     * than crashing. */
    zsetKeyReset(key);
}",4795.0,4804.0,1.0,43.0,10.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2817,165356,moduleInitKeyTypeSpecific,1,moduleInitKeyTypeSpecific,void moduleInitKeyTypeSpecific (RedisModuleKey*),module.c,"static void moduleInitKeyTypeSpecific(RedisModuleKey *key) {
    switch (key->value->type) {
    case OBJ_ZSET: zsetKeyReset(key); break;
    case OBJ_STREAM: key->u.stream.signalready = 0; break;
    }
}",3964.0,3969.0,1.0,9.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
2818,165373,moduleValidateCommandInfo,1,moduleValidateCommandInfo,int moduleValidateCommandInfo (RedisModuleCommandInfo*),module.c,"static int moduleValidateCommandInfo(const RedisModuleCommandInfo *info) {
    const RedisModuleCommandInfoVersion *version = info->version;
    if (!version) {
        serverLog(LL_WARNING, ""Invalid command info: version missing"");
        return 0;
    }

    /* No validation for the fields summary, complexity, since, tips (strings or
     * NULL) and arity (any integer). */

    /* History: If since is set, changes must also be set. */
    if (info->history) {
        for (size_t j = 0;
             moduleCmdHistoryEntryAt(version, info->history, j)->since;
             j++)
        {
            if (!moduleCmdHistoryEntryAt(version, info->history, j)->changes) {
                serverLog(LL_WARNING, ""Invalid command info: history[%zd].changes missing"", j);
                return 0;
            }
        }
    }

    /* Key specs. */
    if (info->key_specs) {
        for (size_t j = 0;
             moduleCmdKeySpecAt(version, info->key_specs, j)->begin_search_type;
             ...",1953.0,2047.0,1.0,8.0,95.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2819,165378,moduleConvertKeySpecsFlags,1,moduleConvertKeySpecsFlags,"int64_t moduleConvertKeySpecsFlags (int64_t,int)",module.c,"static int64_t moduleConvertKeySpecsFlags(int64_t flags, int from_api) {
    int64_t out = 0;
    int64_t map[][2] = {
        {REDISMODULE_CMD_KEY_RO, CMD_KEY_RO},
        {REDISMODULE_CMD_KEY_RW, CMD_KEY_RW},
        {REDISMODULE_CMD_KEY_OW, CMD_KEY_OW},
        {REDISMODULE_CMD_KEY_RM, CMD_KEY_RM},
        {REDISMODULE_CMD_KEY_ACCESS, CMD_KEY_ACCESS},
        {REDISMODULE_CMD_KEY_INSERT, CMD_KEY_INSERT},
        {REDISMODULE_CMD_KEY_UPDATE, CMD_KEY_UPDATE},
        {REDISMODULE_CMD_KEY_DELETE, CMD_KEY_DELETE},
        {REDISMODULE_CMD_KEY_NOT_KEY, CMD_KEY_NOT_KEY},
        {REDISMODULE_CMD_KEY_INCOMPLETE, CMD_KEY_INCOMPLETE},
        {REDISMODULE_CMD_KEY_VARIABLE_FLAGS, CMD_KEY_VARIABLE_FLAGS},
        {0,0}};

    int from_idx = from_api ? 0 : 1, to_idx = !from_idx;
    for (int i=0; map[i][0]; i++)
        if (flags & map[i][from_idx]) out |= map[i][to_idx];
    return out;
}",2051.0,2071.0,1.0,9.0,21.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int64_t
2820,165392,moduleConvertArgType,1,moduleConvertArgType,"redisCommandArgType moduleConvertArgType (RedisModuleCommandArgType,int*)",module.c,"static redisCommandArgType moduleConvertArgType(RedisModuleCommandArgType type, int *error) {
    if (error) *error = 0;
    switch (type) {
    case REDISMODULE_ARG_TYPE_STRING: return ARG_TYPE_STRING;
    case REDISMODULE_ARG_TYPE_INTEGER: return ARG_TYPE_INTEGER;
    case REDISMODULE_ARG_TYPE_DOUBLE: return ARG_TYPE_DOUBLE;
    case REDISMODULE_ARG_TYPE_KEY: return ARG_TYPE_KEY;
    case REDISMODULE_ARG_TYPE_PATTERN: return ARG_TYPE_PATTERN;
    case REDISMODULE_ARG_TYPE_UNIX_TIME: return ARG_TYPE_UNIX_TIME;
    case REDISMODULE_ARG_TYPE_PURE_TOKEN: return ARG_TYPE_PURE_TOKEN;
    case REDISMODULE_ARG_TYPE_ONEOF: return ARG_TYPE_ONEOF;
    case REDISMODULE_ARG_TYPE_BLOCK: return ARG_TYPE_BLOCK;
    default:
        if (error) *error = 1;
        return -1;
    }
}",2172.0,2188.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,redisCommandArgType
2821,165398,moduleConvertArgFlags,1,moduleConvertArgFlags,int moduleConvertArgFlags (int),module.c,"static int moduleConvertArgFlags(int flags) {
    int realflags = 0;
    if (flags & REDISMODULE_CMD_ARG_OPTIONAL) realflags |= CMD_ARG_OPTIONAL;
    if (flags & REDISMODULE_CMD_ARG_MULTIPLE) realflags |= CMD_ARG_MULTIPLE;
    if (flags & REDISMODULE_CMD_ARG_MULTIPLE_TOKEN) realflags |= CMD_ARG_MULTIPLE_TOKEN;
    return realflags;
}",2190.0,2196.0,1.0,16.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2822,165403,moduleCreateContext,1,moduleCreateContext,"void moduleCreateContext (RedisModuleCtx*,RedisModule*,int)",module.c,"void moduleCreateContext(RedisModuleCtx *out_ctx, RedisModule *module, int ctx_flags) {
    memset(out_ctx, 0 ,sizeof(RedisModuleCtx));
    out_ctx->getapifuncptr = (void*)(unsigned long)&RM_GetApi;
    out_ctx->module = module;
    out_ctx->flags = ctx_flags;
    if (ctx_flags & REDISMODULE_CTX_TEMP_CLIENT)
        out_ctx->client = moduleAllocTempClient();
    else if (ctx_flags & REDISMODULE_CTX_NEW_CLIENT)
        out_ctx->client = createClient(NULL);

    /* Calculate the initial yield time for long blocked contexts.
     * in loading we depend on the server hz, but in other cases we also wait
     * for busy_reply_threshold.
     * Note that in theory we could have started processing BUSY_MODULE_YIELD_EVENTS
     * sooner, and only delay the processing for clients till the busy_reply_threshold,
     * but this carries some overheads of frequently marking clients with BLOCKED_POSTPONE
     * and releasing them, i.e. if modules only block for short periods. */
    if (server.loa...",875.0,907.0,1.0,20.0,33.0,0,0,0,0,21,0,1,1,0,0,,0,0,6,3,3,void
2823,165410,RM_Alloc,1,RM_Alloc,void* RM_Alloc (size_t),module.c,"void *RM_Alloc(size_t bytes) {
    /* Use 'zmalloc_usable()' instead of 'zmalloc()' to allow the compiler
     * to recognize the additional memory size, which means that modules can
     * use the memory reported by 'RM_MallocUsableSize()' safely. In theory this
     * isn't really needed since this API can't be inlined (not even for embedded
     * modules like TLS (we use function pointers for module APIs), and the API doesn't
     * have the malloc_size attribute, but it's hard to predict how smart future compilers
     * will be, so better safe than sorry. */
    return zmalloc_usable(bytes,NULL);
}",520.0,529.0,1.0,1.0,10.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void*
2824,165419,RM_TryAlloc,1,RM_TryAlloc,void* RM_TryAlloc (size_t),module.c,"void *RM_TryAlloc(size_t bytes) {
    return ztrymalloc_usable(bytes,NULL);
}",533.0,535.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void*
2825,165428,RM_Calloc,1,RM_Calloc,"void* RM_Calloc (size_t,size_t)",module.c,"void *RM_Calloc(size_t nmemb, size_t size) {
    return zcalloc_usable(nmemb*size,NULL);
}",541.0,543.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,void*
2826,165440,RM_Realloc,1,RM_Realloc,"void* RM_Realloc (void*,size_t)",module.c,"void* RM_Realloc(void *ptr, size_t bytes) {
    return zrealloc_usable(ptr,bytes,NULL);
}",546.0,548.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,void*
2827,165451,RM_Free,1,RM_Free,void RM_Free (void*),module.c,"void RM_Free(void *ptr) {
    zfree(ptr);
}",553.0,555.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
2828,165458,RM_Strdup,1,RM_Strdup,char* RM_Strdup (char*),module.c,"char *RM_Strdup(const char *str) {
    return zstrdup(str);
}",558.0,560.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,char*
2829,165466,poolAllocRelease,1,poolAllocRelease,void poolAllocRelease (RedisModuleCtx*),module.c,"void poolAllocRelease(RedisModuleCtx *ctx) {
    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;

    while(head != NULL) {
        next = head->next;
        zfree(head);
        head = next;
    }
    ctx->pa_head = NULL;
}",567.0,576.0,1.0,1.0,10.0,8,3,11,4,1,4,2,2,0,1,,0,3,2,1,1,void
2830,165498,RM_PoolAlloc,1,RM_PoolAlloc,"void* RM_PoolAlloc (RedisModuleCtx*,size_t)",module.c,"void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
    if (bytes == 0) return NULL;
    RedisModulePoolAllocBlock *b = ctx->pa_head;
    size_t left = b ? b->size - b->used : 0;

    /* Fix alignment. */
    if (left >= bytes) {
        size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;
        while (bytes < alignment && alignment/2 >= bytes) alignment /= 2;
        if (b->used % alignment)
            b->used += alignment - (b->used % alignment);
        left = (b->used > b->size) ? 0 : b->size - b->used;
    }

    /* Create a new block if needed. */
    if (left < bytes) {
        size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;
        if (blocksize < bytes) blocksize = bytes;
        b = zmalloc(sizeof(*b) + blocksize);
        b->size = blocksize;
        b->used = 0;
        b->next = ctx->pa_head;
        ctx->pa_head = b;
    }

    char *retval = b->memory + b->used;
    b->used += bytes;
    return retval;
}",590.0,618.0,1.0,27.0,29.0,54,16,50,9,0,19,7,10,1,1,,0,19,4,2,2,void*
2831,165659,moduleAllocTempClient,1,moduleAllocTempClient,client moduleAllocTempClient (void),module.c,"client *moduleAllocTempClient(void) {
    client *c = NULL;

    if (moduleTempClientCount > 0) {
        c = moduleTempClients[--moduleTempClientCount];
        if (moduleTempClientCount < moduleTempClientMinCount)
            moduleTempClientMinCount = moduleTempClientCount;
    } else {
        c = createClient(NULL);
        c->flags |= CLIENT_MODULE;
        c->user = NULL; /* Root user */
    }
    return c;
}",624.0,637.0,1.0,20.0,14.0,7,5,11,5,3,7,3,4,3,0,,0,7,2,1,1,client
2832,165709,freeRedisModuleAsyncRMCallPromise,1,freeRedisModuleAsyncRMCallPromise,void freeRedisModuleAsyncRMCallPromise (RedisModuleAsyncRMCallPromise*),module.c,"static void freeRedisModuleAsyncRMCallPromise(RedisModuleAsyncRMCallPromise *promise) {
    if (--promise->ref_count > 0) {
        return;
    }
    /* When the promise is finally freed it can not have a client attached to it.
     * Either releasing the client or RM_CallReplyPromiseAbort would have removed it. */
    serverAssert(!promise->c);
    zfree(promise);
}",639.0,647.0,1.0,4.0,9.0,11,8,4,1,1,5,2,2,1,2,,0,3,2,1,1,void
2833,165746,moduleReleaseTempClient,1,moduleReleaseTempClient,void moduleReleaseTempClient (client*),module.c,"void moduleReleaseTempClient(client *c) {
    if (moduleTempClientCount == moduleTempClientCap) {
        moduleTempClientCap = moduleTempClientCap ? moduleTempClientCap*2 : 32;
        moduleTempClients = zrealloc(moduleTempClients, sizeof(c)*moduleTempClientCap);
    }
    clearClientConnectionState(c);
    listEmpty(c->reply);
    c->reply_bytes = 0;
    c->duration = 0;
    resetClient(c);
    c->bufpos = 0;
    c->flags = CLIENT_MODULE;
    c->user = NULL; /* Root user */
    c->cmd = c->lastcmd = c->realcmd = NULL;
    if (c->bstate.async_rm_call_handle) {
        RedisModuleAsyncRMCallPromise *promise = c->bstate.async_rm_call_handle;
        promise->c = NULL; /* Remove the client from the promise so it will no longer be possible to abort it. */
        freeRedisModuleAsyncRMCallPromise(promise);
        c->bstate.async_rm_call_handle = NULL;
    }
    moduleTempClients[moduleTempClientCount++] = c;
}",649.0,670.0,1.0,15.0,22.0,38,10,33,6,7,28,3,3,3,5,,0,24,2,1,1,void
2834,165857,moduleCreateEmptyKey,1,moduleCreateEmptyKey,"int moduleCreateEmptyKey (RedisModuleKey*,int)",module.c,"int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
    robj *obj;

    /* The key must be open for writing and non existing to proceed. */
    if (!(key->mode & REDISMODULE_WRITE) || key->value)
        return REDISMODULE_ERR;

    switch(type) {
    case REDISMODULE_KEYTYPE_LIST:
        obj = createListListpackObject();
        break;
    case REDISMODULE_KEYTYPE_ZSET:
        obj = createZsetListpackObject();
        break;
    case REDISMODULE_KEYTYPE_HASH:
        obj = createHashObject();
        break;
    case REDISMODULE_KEYTYPE_STREAM:
        obj = createStreamObject();
        break;
    default: return REDISMODULE_ERR;
    }
    dbAdd(key->db,key->key,obj);
    key->value = obj;
    moduleInitKeyTypeSpecific(key);
    return REDISMODULE_OK;
}",684.0,710.0,1.0,22.0,27.0,14,6,13,3,5,11,7,3,2,6,,0,9,4,2,2,int
2835,165943,moduleFreeKeyIterator,1,moduleFreeKeyIterator,void moduleFreeKeyIterator (RedisModuleKey*),module.c,"static void moduleFreeKeyIterator(RedisModuleKey *key) {
    serverAssert(key->iter != NULL);
    switch (key->value->type) {
    case OBJ_LIST: listTypeReleaseIterator(key->iter); break;
    case OBJ_STREAM:
        streamIteratorStop(key->iter);
        zfree(key->iter);
        break;
    default: serverAssert(0); /* No key->iter for other types. */
    }
    key->iter = NULL;
}",713.0,724.0,1.0,4.0,12.0,17,7,8,2,7,11,4,2,1,5,,0,6,2,1,1,void
2836,166016,moduleFreeListIterator,1,moduleFreeListIterator,void moduleFreeListIterator (void*),module.c,"static void moduleFreeListIterator(void *data) {
    RedisModuleKey *key = (RedisModuleKey*)data;
    serverAssert(key->value->type == OBJ_LIST);
    if (key->iter) moduleFreeKeyIterator(key);
}",728.0,732.0,1.0,4.0,5.0,10,7,5,2,0,4,2,2,1,2,,0,2,2,1,1,void
2837,166054,moduleDelKeyIfEmpty,1,moduleDelKeyIfEmpty,int moduleDelKeyIfEmpty (RedisModuleKey*),module.c,"int moduleDelKeyIfEmpty(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) return 0;
    int isempty;
    robj *o = key->value;

    switch(o->type) {
    case OBJ_LIST: isempty = listTypeLength(o) == 0; break;
    case OBJ_SET: isempty = setTypeSize(o) == 0; break;
    case OBJ_ZSET: isempty = zsetLength(o) == 0; break;
    case OBJ_HASH: isempty = hashTypeLength(o) == 0; break;
    case OBJ_STREAM: isempty = streamLength(o) == 0; break;
    default: isempty = 0;
    }

    if (isempty) {
        if (key->iter) moduleFreeKeyIterator(key);
        dbDelete(key->db,key->key);
        key->value = NULL;
        return 1;
    } else {
        return 0;
    }
}",744.0,766.0,1.0,22.0,23.0,26,7,24,4,7,14,10,6,3,7,,0,12,2,1,1,int
2838,166178,RM_GetApi,1,RM_GetApi,"int RM_GetApi (char*,void**)",module.c,"int RM_GetApi(const char *funcname, void **targetPtrPtr) {
    /* Lookup the requested module API and store the function pointer into the
     * target pointer. The function returns REDISMODULE_ERR if there is no such
     * named API, otherwise REDISMODULE_OK.
     *
     * This function is not meant to be used by modules developer, it is only
     * used implicitly by including redismodule.h. */
    dictEntry *he = dictFind(server.moduleapi, funcname);
    if (!he) return REDISMODULE_ERR;
    *targetPtrPtr = dictGetVal(he);
    return REDISMODULE_OK;
}",778.0,789.0,1.0,20.0,12.0,5,4,6,4,0,2,2,2,0,2,,0,2,4,2,2,int
2839,166209,modulePostExecutionUnitOperations,1,modulePostExecutionUnitOperations,void modulePostExecutionUnitOperations (void),module.c,"void modulePostExecutionUnitOperations(void) {
    if (server.execution_nesting)
        return;

    if (server.busy_module_yield_flags) {
        blockingOperationEnds();
        server.busy_module_yield_flags = BUSY_MODULE_YIELD_NONE;
        if (server.current_client)
            unprotectClient(server.current_client);
        unblockPostponedClients();
    }
}",791.0,802.0,1.0,41.0,12.0,6,2,5,1,1,3,4,5,0,3,,0,0,2,1,1,void
2840,166243,moduleFreeContext,1,moduleFreeContext,void moduleFreeContext (RedisModuleCtx*),module.c,"void moduleFreeContext(RedisModuleCtx *ctx) {
    /* See comment in moduleCreateContext */
    if (!(ctx->flags & (REDISMODULE_CTX_THREAD_SAFE|REDISMODULE_CTX_COMMAND))) {
        exitExecutionUnit();
        postExecutionUnitOperations();
    }
    autoMemoryCollect(ctx);
    poolAllocRelease(ctx);
    if (ctx->postponed_arrays) {
        zfree(ctx->postponed_arrays);
        ctx->postponed_arrays_count = 0;
        serverLog(LL_WARNING,
            ""API misuse detected in module %s: ""
            ""RedisModule_ReplyWith*(REDISMODULE_POSTPONED_LEN) ""
            ""not matched by the same number of RedisModule_SetReply*Len() ""
            ""calls."",
            ctx->module->name);
    }
    /* If this context has a temp client, we return it back to the pool.
     * If this context created a new client (e.g detached context), we free it.
     * If the client is assigned manually, e.g ctx->client = someClientInstance,
     * none of these flags will be set and we do not attempt to free i...",805.0,831.0,1.0,24.0,27.0,19,8,10,2,26,14,4,4,3,7,,0,7,2,1,1,void
2841,166341,moduleParseReply,1,moduleParseReply,"CallReply moduleParseReply (client*,RedisModuleCtx*)",module.c,"static CallReply *moduleParseReply(client *c, RedisModuleCtx *ctx) {
    /* Convert the result of the Redis command into a module reply. */
    sds proto = sdsnewlen(c->buf,c->bufpos);
    c->bufpos = 0;
    while(listLength(c->reply)) {
        clientReplyBlock *o = listNodeValue(listFirst(c->reply));

        proto = sdscatlen(proto,o->buf,o->used);
        listDelNode(c->reply,listFirst(c->reply));
    }
    CallReply *reply = callReplyCreate(proto, c->deferred_reply_errors, ctx);
    c->deferred_reply_errors = NULL; /* now the responsibility of the reply object. */
    return reply;
}",833.0,846.0,1.0,10.0,14.0,23,2,22,6,1,17,2,2,2,4,,0,16,4,2,2,CallReply
2842,166426,moduleCallCommandUnblockedHandler,1,moduleCallCommandUnblockedHandler,void moduleCallCommandUnblockedHandler (client*),module.c,"void moduleCallCommandUnblockedHandler(client *c) {
    RedisModuleCtx ctx;
    RedisModuleAsyncRMCallPromise *promise = c->bstate.async_rm_call_handle;
    serverAssert(promise);
    RedisModule *module = promise->module;
    if (!promise->on_unblocked) {
        moduleReleaseTempClient(c);
        return; /* module did not set any unblock callback. */
    }
    moduleCreateContext(&ctx, module, REDISMODULE_CTX_TEMP_CLIENT);
    selectDb(ctx.client, c->db->id);

    CallReply *reply = moduleParseReply(c, NULL);
    module->in_call++;
    promise->on_unblocked(&ctx, reply, promise->private_data);
    module->in_call--;

    moduleFreeContext(&ctx);
    moduleReleaseTempClient(c);
}",848.0,867.0,1.0,4.0,20.0,25,12,23,6,1,16,2,2,1,7,,0,10,2,1,1,void
2843,166628,RedisModuleCommandDispatcher,1,RedisModuleCommandDispatcher,void RedisModuleCommandDispatcher (client*),module.c,"void RedisModuleCommandDispatcher(client *c) {
    RedisModuleCommand *cp = c->cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_COMMAND);

    ctx.client = c;
    cp->func(&ctx,(void**)c->argv,c->argc);
    moduleFreeContext(&ctx);

    /* In some cases processMultibulkBuffer uses sdsMakeRoomFor to
     * expand the query buffer, and in order to avoid a big object copy
     * the query buffer SDS may be used directly as the SDS string backing
     * the client argument vectors: sometimes this will result in the SDS
     * string having unused space at the end. Later if a module takes ownership
     * of the RedisString, such space will be wasted forever. Inside the
     * Redis core this is not a problem because tryObjectEncoding() is called
     * before storing strings in the key space. Here we need to do it
     * for the module. */
    for (int i = 0; i < c->argc; i++) {
        /* Only do the work if the module took ownership of...",911.0,935.0,1.0,42.0,25.0,23,9,18,4,0,12,3,4,2,3,,0,9,2,1,1,void
2844,166707,moduleGetCommandKeysViaAPI,1,moduleGetCommandKeysViaAPI,"int moduleGetCommandKeysViaAPI (redisCommand*,robj**,int,getKeysResult*)",module.c,"int moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    RedisModuleCommand *cp = cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_KEYS_POS_REQUEST);

    /* Initialize getKeysResult */
    getKeysPrepareResult(result, MAX_KEYS_BUFFER);
    ctx.keys_result = result;

    cp->func(&ctx,(void**)argv,argc);
    /* We currently always use the array allocated by RM_KeyAtPos() and don't try
     * to optimize for the pre-allocated buffer.
     */
    moduleFreeContext(&ctx);
    return result->numkeys;
}",946.0,961.0,1.0,42.0,16.0,12,6,13,6,2,8,1,1,0,3,,0,5,8,4,4,int
2845,166760,moduleGetCommandChannelsViaAPI,1,moduleGetCommandChannelsViaAPI,"int moduleGetCommandChannelsViaAPI (redisCommand*,robj**,int,getKeysResult*)",module.c,"int moduleGetCommandChannelsViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    RedisModuleCommand *cp = cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_CHANNELS_POS_REQUEST);

    /* Initialize getKeysResult */
    getKeysPrepareResult(result, MAX_KEYS_BUFFER);
    ctx.keys_result = result;

    cp->func(&ctx,(void**)argv,argc);
    /* We currently always use the array allocated by RM_RM_ChannelAtPosWithFlags() and don't try
     * to optimize for the pre-allocated buffer. */
    moduleFreeContext(&ctx);
    return result->numkeys;
}",966.0,980.0,1.0,42.0,15.0,12,6,13,6,1,8,1,1,0,3,,0,5,8,4,4,int
2846,166813,RM_IsKeysPositionRequest,1,RM_IsKeysPositionRequest,int RM_IsKeysPositionRequest (RedisModuleCtx*),module.c,"int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;
}",993.0,995.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
2847,166830,RM_KeyAtPosWithFlags,1,RM_KeyAtPosWithFlags,"void RM_KeyAtPosWithFlags (RedisModuleCtx*,int,int)",module.c,"void RM_KeyAtPosWithFlags(RedisModuleCtx *ctx, int pos, int flags) {
    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) || !ctx->keys_result) return;
    if (pos <= 0) return;

    getKeysResult *res = ctx->keys_result;

    /* Check overflow */
    if (res->numkeys == res->size) {
        int newsize = res->size + (res->size > 8192 ? 8192 : res->size);
        getKeysPrepareResult(res, newsize);
    }

    res->keys[res->numkeys].pos = pos;
    res->keys[res->numkeys].flags = moduleConvertKeySpecsFlags(flags, 1);
    res->numkeys++;
}",1017.0,1032.0,1.0,23.0,16.0,32,14,20,5,1,15,4,4,4,2,,0,14,6,3,3,void
2848,166924,RM_KeyAtPos,1,RM_KeyAtPos,"void RM_KeyAtPos (RedisModuleCtx*,int)",module.c,"void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
    /* Default flags require full access */
    int flags = moduleConvertKeySpecsFlags(CMD_KEY_FULL_ACCESS, 0);
    RM_KeyAtPosWithFlags(ctx, pos, flags);
}",1037.0,1041.0,1.0,43.0,5.0,6,3,4,3,0,2,1,1,0,2,,0,1,4,2,2,void
2849,166952,RM_IsChannelsPositionRequest,1,RM_IsChannelsPositionRequest,int RM_IsChannelsPositionRequest (RedisModuleCtx*),module.c,"int RM_IsChannelsPositionRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_CHANNELS_POS_REQUEST) != 0;
}",1046.0,1048.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
2850,166969,RM_ChannelAtPosWithFlags,1,RM_ChannelAtPosWithFlags,"void RM_ChannelAtPosWithFlags (RedisModuleCtx*,int,int)",module.c,"void RM_ChannelAtPosWithFlags(RedisModuleCtx *ctx, int pos, int flags) {
    if (!(ctx->flags & REDISMODULE_CTX_CHANNELS_POS_REQUEST) || !ctx->keys_result) return;
    if (pos <= 0) return;

    getKeysResult *res = ctx->keys_result;

    /* Check overflow */
    if (res->numkeys == res->size) {
        int newsize = res->size + (res->size > 8192 ? 8192 : res->size);
        getKeysPrepareResult(res, newsize);
    }

    int new_flags = 0;
    if (flags & REDISMODULE_CMD_CHANNEL_SUBSCRIBE) new_flags |= CMD_CHANNEL_SUBSCRIBE;
    if (flags & REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE) new_flags |= CMD_CHANNEL_UNSUBSCRIBE;
    if (flags & REDISMODULE_CMD_CHANNEL_PUBLISH) new_flags |= CMD_CHANNEL_PUBLISH;
    if (flags & REDISMODULE_CMD_CHANNEL_PATTERN) new_flags |= CMD_CHANNEL_PATTERN;

    res->keys[res->numkeys].pos = pos;
    res->keys[res->numkeys].flags = new_flags;
    res->numkeys++;
}",1076.0,1097.0,1.0,23.0,22.0,45,14,29,6,0,14,8,8,4,1,,0,13,6,3,3,void
2851,167129,isCommandNameValid,1,isCommandNameValid,int isCommandNameValid (char*),module.c,"int isCommandNameValid(const char *name) {
    const char *block_chars = "" \r\n|@=,"";

    if (strpbrk(name, block_chars))
        return 0;
    return 1;
}",1111.0,1117.0,1.0,1.0,7.0,1,1,3,2,2,0,2,2,0,0,,0,0,2,1,1,int
2852,167147,commandFlagsFromString,1,commandFlagsFromString,int64_t commandFlagsFromString (char*),module.c,"int64_t commandFlagsFromString(char *s) {
    int count, j;
    int64_t flags = 0;
    sds *tokens = sdssplitlen(s,strlen(s),"" "",1,&count);
    for (j = 0; j < count; j++) {
        char *t = tokens[j];
        if (!strcasecmp(t,""write"")) flags |= CMD_WRITE;
        else if (!strcasecmp(t,""readonly"")) flags |= CMD_READONLY;
        else if (!strcasecmp(t,""admin"")) flags |= CMD_ADMIN;
        else if (!strcasecmp(t,""deny-oom"")) flags |= CMD_DENYOOM;
        else if (!strcasecmp(t,""deny-script"")) flags |= CMD_NOSCRIPT;
        else if (!strcasecmp(t,""allow-loading"")) flags |= CMD_LOADING;
        else if (!strcasecmp(t,""pubsub"")) flags |= CMD_PUBSUB;
        else if (!strcasecmp(t,""random"")) { /* Deprecated. Silently ignore. */ }
        else if (!strcasecmp(t,""blocking"")) flags |= CMD_BLOCKING;
        else if (!strcasecmp(t,""allow-stale"")) flags |= CMD_STALE;
        else if (!strcasecmp(t,""no-monitor"")) flags |= CMD_SKIP_MONITOR;
        else if (!strcasecmp(t,""no-slowlog"")) flags ...",1123.0,1154.0,1.0,45.0,32.0,11,8,18,6,2,2,4,5,0,2,,0,1,2,1,1,int64_t
2853,167493,moduleCreateCommandProxy,1,moduleCreateCommandProxy,"RedisModuleCommand* moduleCreateCommandProxy (RedisModule*,sds,sds,RedisModuleCmdFunc,int64_t,int,int,int)",module.c,"RedisModuleCommand *moduleCreateCommandProxy(struct RedisModule *module, sds declared_name, sds fullname, RedisModuleCmdFunc cmdfunc, int64_t flags, int firstkey, int lastkey, int keystep) {
    struct redisCommand *rediscmd;
    RedisModuleCommand *cp;

    /* Create a command ""proxy"", which is a structure that is referenced
     * in the command table, so that the generic command that works as
     * binding between modules and Redis, can know what function to call
     * and what the module is. */
    cp = zcalloc(sizeof(*cp));
    cp->module = module;
    cp->func = cmdfunc;
    cp->rediscmd = zcalloc(sizeof(*rediscmd));
    cp->rediscmd->declared_name = declared_name; /* SDS for module commands */
    cp->rediscmd->fullname = fullname;
    cp->rediscmd->group = COMMAND_GROUP_MODULE;
    cp->rediscmd->proc = RedisModuleCommandDispatcher;
    cp->rediscmd->flags = flags | CMD_MODULE;
    cp->rediscmd->module_cmd = cp;
    if (firstkey != 0) {
        cp->rediscmd->key_specs_num =...",1287.0,1327.0,1.0,34.0,41.0,0,0,0,0,2,0,1,1,0,0,,0,0,16,8,8,RedisModuleCommand
2854,167505,RM_CreateCommand,1,RM_CreateCommand,"int RM_CreateCommand (RedisModuleCtx*,char*,RedisModuleCmdFunc,char*,int,int,int)",module.c,"int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
    if (!ctx->module->onload)
        return REDISMODULE_ERR;
    int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
    if (flags == -1) return REDISMODULE_ERR;
    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
        return REDISMODULE_ERR;

    /* Check if the command name is valid. */
    if (!isCommandNameValid(name))
        return REDISMODULE_ERR;

    /* Check if the command name is busy. */
    if (lookupCommandByCString(name) != NULL)
        return REDISMODULE_ERR;

    sds declared_name = sdsnew(name);
    RedisModuleCommand *cp = moduleCreateCommandProxy(ctx->module, declared_name, sdsdup(declared_name), cmdfunc, flags, firstkey, lastkey, keystep);
    cp->rediscmd->arity = cmdfunc ? -1 : -2; /* Default value, can be changed later via dedicated API */

    serverAssert(dictAdd(serve...",1254.0,1278.0,1.0,15.0,25.0,40,14,31,12,0,19,6,6,3,13,,0,15,14,7,7,int
2855,167969,RM_GetCommand,1,RM_GetCommand,"RedisModuleCommand RM_GetCommand (RedisModuleCtx*,char*)",module.c,"RedisModuleCommand *RM_GetCommand(RedisModuleCtx *ctx, const char *name) {
    struct redisCommand *cmd = lookupCommandByCString(name);

    if (!cmd || !(cmd->flags & CMD_MODULE))
        return NULL;

    RedisModuleCommand *cp = cmd->module_cmd;
    if (cp->module != ctx->module)
        return NULL;

    return cp;
}",1338.0,1349.0,1.0,31.0,12.0,12,7,11,5,0,5,3,3,3,1,,0,5,4,2,2,RedisModuleCommand
2856,168016,RM_CreateSubcommand,1,RM_CreateSubcommand,"int RM_CreateSubcommand (RedisModuleCommand*,char*,RedisModuleCmdFunc,char*,int,int,int)",module.c,"int RM_CreateSubcommand(RedisModuleCommand *parent, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
    if (!parent->module->onload)
        return REDISMODULE_ERR;
    int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
    if (flags == -1) return REDISMODULE_ERR;
    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
        return REDISMODULE_ERR;

    struct redisCommand *parent_cmd = parent->rediscmd;

    if (parent_cmd->parent)
        return REDISMODULE_ERR; /* We don't allow more than one level of subcommands */

    RedisModuleCommand *parent_cp = parent_cmd->module_cmd;
    if (parent_cp->func)
        return REDISMODULE_ERR; /* A parent command should be a pure container of subcommands */

    /* Check if the command name is valid. */
    if (!isCommandNameValid(name))
        return REDISMODULE_ERR;

    /* Check if the command name is busy within the parent command. */
    sds...",1378.0,1412.0,1.0,15.0,35.0,32,12,37,15,0,18,8,8,6,8,,0,16,14,7,7,int
2857,168177,moduleCmdHistoryEntryAt,1,moduleCmdHistoryEntryAt,"RedisModuleCommandHistoryEntry moduleCmdHistoryEntryAt (RedisModuleCommandInfoVersion*,RedisModuleCommandHistoryEntry*,int)",module.c,"static RedisModuleCommandHistoryEntry *
moduleCmdHistoryEntryAt(const RedisModuleCommandInfoVersion *version,
                        RedisModuleCommandHistoryEntry *entries, int index) {
    off_t offset = index * version->sizeof_historyentry;
    return (RedisModuleCommandHistoryEntry *)((char *)(entries) + offset);
}",1416.0,1421.0,1.0,1.0,6.0,6,5,5,4,2,1,1,1,0,0,,0,1,6,3,3,RedisModuleCommandHistoryEntry
2858,168200,moduleCmdKeySpecAt,1,moduleCmdKeySpecAt,"RedisModuleCommandKeySpec moduleCmdKeySpecAt (RedisModuleCommandInfoVersion*,RedisModuleCommandKeySpec*,int)",module.c,"static RedisModuleCommandKeySpec *
moduleCmdKeySpecAt(const RedisModuleCommandInfoVersion *version,
                   RedisModuleCommandKeySpec *keyspecs, int index) {
    off_t offset = index * version->sizeof_keyspec;
    return (RedisModuleCommandKeySpec *)((char *)(keyspecs) + offset);
}",1422.0,1427.0,1.0,1.0,6.0,6,5,5,4,2,1,1,1,0,0,,0,1,6,3,3,RedisModuleCommandKeySpec
2859,168223,moduleCmdArgAt,1,moduleCmdArgAt,"RedisModuleCommandArg moduleCmdArgAt (RedisModuleCommandInfoVersion*,RedisModuleCommandArg*,int)",module.c,"static RedisModuleCommandArg *
moduleCmdArgAt(const RedisModuleCommandInfoVersion *version,
               const RedisModuleCommandArg *args, int index) {
    off_t offset = index * version->sizeof_arg;
    return (RedisModuleCommandArg *)((char *)(args) + offset);
}",1428.0,1433.0,1.0,1.0,6.0,6,5,5,4,2,1,1,1,0,0,,0,1,6,3,3,RedisModuleCommandArg
2860,168246,populateArgsStructure,1,populateArgsStructure,int populateArgsStructure (redisCommandArg*),module.c,"int populateArgsStructure(struct redisCommandArg *args) {
    if (!args)
        return 0;
    int count = 0;
    while (args->name) {
        serverAssert(count < INT_MAX);
        args->num_args = populateArgsStructure(args->subargs);
        count++;
        args++;
    }
    return count;
}",1437.0,1448.0,1.0,8.0,12.0,13,9,10,3,1,4,3,3,1,1,,0,3,2,1,1,int
2861,168296,matchAclCategoryFlag,1,matchAclCategoryFlag,"int matchAclCategoryFlag (char*,int64_t*)",module.c,"int matchAclCategoryFlag(char *flag, int64_t *acl_categories_flags) {
    uint64_t this_flag = ACLGetCommandCategoryFlagByName(flag);
    if (this_flag) {
        *acl_categories_flags |= (int64_t) this_flag;
        return 1;
    }
    return 0; /* Unrecognized */
}",1455.0,1462.0,1.0,1.0,8.0,3,3,5,3,1,1,2,2,0,1,,0,1,4,2,2,int
2862,168320,categoryFlagsFromString,1,categoryFlagsFromString,int64_t categoryFlagsFromString (char*),module.c,"int64_t categoryFlagsFromString(char *aclflags) {
    int count, j;
    int64_t acl_categories_flags = 0;
    sds *tokens = sdssplitlen(aclflags,strlen(aclflags),"" "",1,&count);
    for (j = 0; j < count; j++) {
        char *t = tokens[j];
        if (!matchAclCategoryFlag(t, &acl_categories_flags)) {
            serverLog(LL_WARNING,""Unrecognized categories flag %s on module load"", t);
            break;
        }
    }
    sdsfreesplitres(tokens,count);
    if (j != count) return -1; /* Some token not processed correctly. */
    return acl_categories_flags;
}",1469.0,1483.0,1.0,12.0,15.0,14,9,20,7,1,4,5,5,1,4,,0,2,2,1,1,int64_t
2863,168399,RM_SetCommandACLCategories,1,RM_SetCommandACLCategories,"int RM_SetCommandACLCategories (RedisModuleCommand*,char*)",module.c,"int RM_SetCommandACLCategories(RedisModuleCommand *command, const char *aclflags) {
    if (!command || !command->module || !command->module->onload) return REDISMODULE_ERR;
    int64_t categories_flags = aclflags ? categoryFlagsFromString((char*)aclflags) : 0;
    if (categories_flags == -1) return REDISMODULE_ERR;
    struct redisCommand *rcmd = command->rediscmd;
    rcmd->acl_categories = categories_flags; /* ACL categories flags for module command */
    command->module->num_commands_with_acl_categories++;
    return REDISMODULE_OK;
}",1497.0,1505.0,1.0,73.0,9.0,20,9,12,4,0,6,3,3,2,1,,0,6,4,2,2,int
2864,168466,RM_SetCommandInfo,1,RM_SetCommandInfo,"int RM_SetCommandInfo (RedisModuleCommand*,RedisModuleCommandInfo*)",module.c,"int RM_SetCommandInfo(RedisModuleCommand *command, const RedisModuleCommandInfo *info) {
    if (!moduleValidateCommandInfo(info)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    struct redisCommand *cmd = command->rediscmd;

    /* Check if any info has already been set. Overwriting info involves freeing
     * the old info, which is not implemented. */
    if (cmd->summary || cmd->complexity || cmd->since || cmd->history ||
        cmd->tips || cmd->args ||
        !(cmd->key_specs_num == 0 ||
          /* Allow key spec populated from legacy (first,last,step) to exist. */
          (cmd->key_specs_num == 1 &&
           cmd->key_specs[0].begin_search_type == KSPEC_BS_INDEX &&
           cmd->key_specs[0].find_keys_type == KSPEC_FK_RANGE))) {
        errno = EEXIST;
        return REDISMODULE_ERR;
    }

    if (info->summary) cmd->summary = zstrdup(info->summary);
    if (info->complexity) cmd->complexity = zstrdup(info->complexity);
    if (info->since) cmd-...",1808.0,1945.0,1.0,15.0,138.0,282,18,186,31,0,112,26,30,25,27,,0,105,4,2,2,int
2865,170144,moduleCopyCommandArgs,1,moduleCopyCommandArgs,"struct redisCommandArg moduleCopyCommandArgs (RedisModuleCommandArg*,RedisModuleCommandInfoVersion*)",module.c,"static struct redisCommandArg *moduleCopyCommandArgs(RedisModuleCommandArg *args,
                                                     const RedisModuleCommandInfoVersion *version) {
    size_t count = 0;
    while (moduleCmdArgAt(version, args, count)->name) count++;
    serverAssert(count < SIZE_MAX / sizeof(struct redisCommandArg));
    struct redisCommandArg *realargs = zcalloc((count+1) * sizeof(redisCommandArg));

    for (size_t j = 0; j < count; j++) {
        RedisModuleCommandArg *arg = moduleCmdArgAt(version, args, j);
        realargs[j].name = zstrdup(arg->name);
        realargs[j].type = moduleConvertArgType(arg->type, NULL);
        if (arg->type == REDISMODULE_ARG_TYPE_KEY)
            realargs[j].key_spec_index = arg->key_spec_index;
        else
            realargs[j].key_spec_index = -1;
        if (arg->token) realargs[j].token = zstrdup(arg->token);
        if (arg->summary) realargs[j].summary = zstrdup(arg->summary);
        if (arg->since) realargs[j].since...",2146.0,2170.0,1.0,4.0,25.0,64,14,58,10,1,29,10,17,8,12,,0,28,4,2,2,struct redisCommandArg
2866,170483,moduleGetHandleByName,1,moduleGetHandleByName,void* moduleGetHandleByName (char*),module.c,"void *moduleGetHandleByName(char *modulename) {
    return dictFetchValue(modules,modulename);
}",2199.0,2201.0,1.0,1.0,3.0,0,0,2,2,1,2,1,1,0,1,,0,1,2,1,1,void*
2867,170492,moduleIsModuleCommand,1,moduleIsModuleCommand,"int moduleIsModuleCommand (void*,redisCommand*)",module.c,"int moduleIsModuleCommand(void *module_handle, struct redisCommand *cmd) {
    if (cmd->proc != RedisModuleCommandDispatcher)
        return 0;
    if (module_handle == NULL)
        return 0;
    RedisModuleCommand *cp = cmd->module_cmd;
    return (cp->module == module_handle);
}",2204.0,2211.0,1.0,1.0,8.0,7,4,7,4,1,3,3,3,1,0,,0,3,4,2,2,int
2868,170544,moduleListFree,1,moduleListFree,void moduleListFree (void*),module.c,"void moduleListFree(void *config) {
    ModuleConfig *module_config = (ModuleConfig *) config;
    sdsfree(module_config->name);
    zfree(config);
}",2221.0,2225.0,1.0,1.0,5.0,3,3,4,2,0,3,1,1,0,2,,0,1,2,1,1,void
2869,170561,RM_SetModuleAttribs,1,RM_SetModuleAttribs,"void RM_SetModuleAttribs (RedisModuleCtx*,char*,int,int)",module.c,"void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
    /* Called by RM_Init() to setup the `ctx->module` structure.
     *
     * This is an internal function, Redis modules developers don't need
     * to use it. */
    RedisModule *module;

    if (ctx->module != NULL) return;
    module = zmalloc(sizeof(*module));
    module->name = sdsnew(name);
    module->ver = ver;
    module->apiver = apiver;
    module->types = listCreate();
    module->usedby = listCreate();
    module->using = listCreate();
    module->filters = listCreate();
    module->module_configs = listCreate();
    listSetMatchMethod(module->module_configs, moduleListConfigMatch);
    listSetFreeMethod(module->module_configs, moduleListFree);
    module->in_call = 0;
    module->configs_initialized = 0;
    module->in_hook = 0;
    module->options = 0;
    module->info_cb = 0;
    module->defrag_cb = 0;
    module->loadmod = NULL;
    module->num_commands_with_acl_categories = 0;...",2227.0,2256.0,1.0,4.0,30.0,49,5,31,6,0,30,2,2,1,7,,0,30,8,4,4,void
2870,170701,RM_IsModuleNameBusy,1,RM_IsModuleNameBusy,int RM_IsModuleNameBusy (char*),module.c,"int RM_IsModuleNameBusy(const char *name) {
    sds modulename = sdsnew(name);
    dictEntry *de = dictFind(modules,modulename);
    sdsfree(modulename);
    return de != NULL;
}",2260.0,2265.0,1.0,1.0,6.0,3,2,8,5,0,4,1,1,0,3,,0,3,2,1,1,int
2871,170723,RM_Milliseconds,1,RM_Milliseconds,mstime_t RM_Milliseconds (void),module.c,"mstime_t RM_Milliseconds(void) {
    return mstime();
}",2268.0,2270.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,mstime_t
2872,170730,RM_MonotonicMicroseconds,1,RM_MonotonicMicroseconds,uint64_t RM_MonotonicMicroseconds (void),module.c,"uint64_t RM_MonotonicMicroseconds(void) {
    return getMonotonicUs();
}",2273.0,2275.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
2873,170737,RM_Microseconds,1,RM_Microseconds,ustime_t RM_Microseconds (void),module.c,"ustime_t RM_Microseconds(void) {
    return ustime();
}",2278.0,2280.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,ustime_t
2874,170753,RM_BlockedClientMeasureTimeStart,1,RM_BlockedClientMeasureTimeStart,int RM_BlockedClientMeasureTimeStart (RedisModuleBlockedClient*),module.c,"int RM_BlockedClientMeasureTimeStart(RedisModuleBlockedClient *bc) {
    elapsedStart(&(bc->background_timer));
    return REDISMODULE_OK;
}",2298.0,2301.0,1.0,11.0,4.0,2,2,1,1,0,2,1,1,0,1,,0,1,2,1,1,int
2875,170767,RM_BlockedClientMeasureTimeEnd,1,RM_BlockedClientMeasureTimeEnd,int RM_BlockedClientMeasureTimeEnd (RedisModuleBlockedClient*),module.c,"int RM_BlockedClientMeasureTimeEnd(RedisModuleBlockedClient *bc) {
    // If the counter is 0 then we haven't called RM_BlockedClientMeasureTimeStart
    if (!bc->background_timer)
        return REDISMODULE_ERR;
    bc->background_duration += elapsedUs(bc->background_timer);
    return REDISMODULE_OK;
}",2308.0,2314.0,1.0,15.0,7.0,5,3,3,1,0,4,2,2,1,1,,0,3,2,1,1,int
2876,170794,RM_Yield,1,RM_Yield,"void RM_Yield (RedisModuleCtx*,int,char*)",module.c,"void RM_Yield(RedisModuleCtx *ctx, int flags, const char *busy_reply) {
    static int yield_nesting = 0;
    /* Avoid nested calls to RM_Yield */
    if (yield_nesting)
        return;
    yield_nesting++;

    long long now = getMonotonicUs();
    if (now >= ctx->next_yield_time) {
        /* In loading mode, there's no need to handle busy_module_yield_reply,
         * and busy_module_yield_flags, since redis is anyway rejecting all
         * commands with -LOADING. */
        if (server.loading) {
            /* Let redis process events */
            processEventsWhileBlocked();
        } else {
            const char *prev_busy_module_yield_reply = server.busy_module_yield_reply;
            server.busy_module_yield_reply = busy_reply;
            /* start the blocking operation if not already started. */
            if (!server.busy_module_yield_flags) {
                server.busy_module_yield_flags = BUSY_MODULE_YIELD_EVENTS;
                blockingOperationStarts();
    ...",2337.0,2379.0,1.0,49.0,43.0,12,8,11,4,0,4,4,5,1,2,,0,3,6,3,3,void
2877,170913,RM_SetModuleOptions,1,RM_SetModuleOptions,"void RM_SetModuleOptions (RedisModuleCtx*,int)",module.c,"void RM_SetModuleOptions(RedisModuleCtx *ctx, int options) {
    ctx->module->options = options;
}",2404.0,2406.0,1.0,1.0,3.0,3,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
2878,170926,RM_SignalModifiedKey,1,RM_SignalModifiedKey,"int RM_SignalModifiedKey (RedisModuleCtx*,robj*)",module.c,"int RM_SignalModifiedKey(RedisModuleCtx *ctx, RedisModuleString *keyname) {
    signalModifiedKey(ctx->client,ctx->client->db,keyname);
    return REDISMODULE_OK;
}",2415.0,2418.0,1.0,46.0,4.0,3,1,3,2,0,3,1,1,0,1,,0,2,4,2,2,int
2879,170946,RM_AutoMemory,1,RM_AutoMemory,void RM_AutoMemory (RedisModuleCtx*),module.c,"void RM_AutoMemory(RedisModuleCtx *ctx) {
    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
}",2439.0,2441.0,1.0,18.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
2880,170960,autoMemoryAdd,1,autoMemoryAdd,"void autoMemoryAdd (RedisModuleCtx*,int,void*)",module.c,"void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
    if (ctx->amqueue_used == ctx->amqueue_len) {
        ctx->amqueue_len *= 2;
        if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;
        ctx->amqueue = zrealloc(ctx->amqueue,sizeof(struct AutoMemEntry)*ctx->amqueue_len);
    }
    ctx->amqueue[ctx->amqueue_used].type = type;
    ctx->amqueue[ctx->amqueue_used].ptr = ptr;
    ctx->amqueue_used++;
}",2444.0,2454.0,1.0,23.0,11.0,31,13,17,4,20,15,4,5,4,1,,0,15,6,3,3,void
2881,171046,autoMemoryFreed,1,autoMemoryFreed,"int autoMemoryFreed (RedisModuleCtx*,int,void*)",module.c,"int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;

    int count = (ctx->amqueue_used+1)/2;
    for (int j = 0; j < count; j++) {
        for (int side = 0; side < 2; side++) {
            /* For side = 0 check right side of the array, for
             * side = 1 check the left side instead (zig-zag scanning). */
            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;
            if (ctx->amqueue[i].type == type &&
                ctx->amqueue[i].ptr == ptr)
            {
                ctx->amqueue[i].type = REDISMODULE_AM_FREED;

                /* Switch the freed element and the last element, to avoid growing
                 * the queue unnecessarily if we allocate/free in a loop */
                if (i != ctx->amqueue_used-1) {
                    ctx->amqueue[i] = ctx->amqueue[ctx->amqueue_used-1];
                }

                /* Reduce the size of the queue because we either moved...",2461.0,2489.0,1.0,23.0,29.0,43,16,28,7,2,11,6,12,4,0,,0,11,6,3,3,int
2882,171306,RM_CreateString,1,RM_CreateString,"robj RM_CreateString (RedisModuleCtx*,char*,size_t)",module.c,"RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {
    RedisModuleString *o = createStringObject(ptr,len);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",2530.0,2534.0,1.0,17.0,5.0,2,2,8,5,9,2,2,2,0,2,,0,1,6,3,3,robj
2883,171334,RM_CreateStringPrintf,1,RM_CreateStringPrintf,"robj RM_CreateStringPrintf (RedisModuleCtx*,char*...)",module.c,"RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {
    sds s = sdsempty();

    va_list ap;
    va_start(ap, fmt);
    s = sdscatvprintf(s, fmt, ap);
    va_end(ap);

    RedisModuleString *o = createObject(OBJ_STRING, s);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);

    return o;
}",2544.0,2556.0,1.0,17.0,13.0,4,2,15,6,0,4,2,2,0,4,,0,3,4,2,2,robj
2884,171377,RM_CreateStringFromLongLong,1,RM_CreateStringFromLongLong,"robj RM_CreateStringFromLongLong (RedisModuleCtx*,long long)",module.c,"RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {
    char buf[LONG_STR_SIZE];
    size_t len = ll2string(buf,sizeof(buf),ll);
    return RM_CreateString(ctx,buf,len);
}",2567.0,2571.0,1.0,17.0,5.0,2,2,7,4,0,2,1,1,0,2,,0,1,4,2,2,robj
2885,171397,RM_CreateStringFromULongLong,1,RM_CreateStringFromULongLong,"robj RM_CreateStringFromULongLong (RedisModuleCtx*,long long unsigned)",module.c,"RedisModuleString *RM_CreateStringFromULongLong(RedisModuleCtx *ctx, unsigned long long ull) {
    char buf[LONG_STR_SIZE];
    size_t len = ull2string(buf,sizeof(buf),ull);
    return RM_CreateString(ctx,buf,len);
}",2581.0,2585.0,1.0,17.0,5.0,2,2,7,4,0,2,1,1,0,2,,0,1,4,2,2,robj
2886,171417,RM_CreateStringFromDouble,1,RM_CreateStringFromDouble,"robj RM_CreateStringFromDouble (RedisModuleCtx*,double)",module.c,"RedisModuleString *RM_CreateStringFromDouble(RedisModuleCtx *ctx, double d) {
    char buf[MAX_D2STRING_CHARS];
    size_t len = d2string(buf,sizeof(buf),d);
    return RM_CreateString(ctx,buf,len);
}",2592.0,2596.0,1.0,17.0,5.0,2,2,7,4,0,2,1,1,0,2,,0,1,4,2,2,robj
2887,171437,RM_CreateStringFromLongDouble,1,RM_CreateStringFromLongDouble,"robj RM_CreateStringFromLongDouble (RedisModuleCtx*,long double,int)",module.c,"RedisModuleString *RM_CreateStringFromLongDouble(RedisModuleCtx *ctx, long double ld, int humanfriendly) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    size_t len = ld2string(buf,sizeof(buf),ld,
        (humanfriendly ? LD_STR_HUMAN : LD_STR_AUTO));
    return RM_CreateString(ctx,buf,len);
}",2606.0,2611.0,1.0,17.0,6.0,3,3,10,7,0,2,1,1,0,2,,0,1,6,3,3,robj
2888,171462,RM_CreateStringFromString,1,RM_CreateStringFromString,"robj RM_CreateStringFromString (RedisModuleCtx*,robj*)",module.c,"RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {
    RedisModuleString *o = dupStringObject(str);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",2621.0,2625.0,1.0,17.0,5.0,2,2,7,4,1,2,2,2,0,2,,0,1,4,2,2,robj
2889,171488,RM_CreateStringFromStreamID,1,RM_CreateStringFromStreamID,"robj RM_CreateStringFromStreamID (RedisModuleCtx*,RedisModuleStreamID*)",module.c,"RedisModuleString *RM_CreateStringFromStreamID(RedisModuleCtx *ctx, const RedisModuleStreamID *id) {
    streamID streamid = {id->ms, id->seq};
    RedisModuleString *o = createObjectFromStreamID(&streamid);
    if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, o);
    return o;
}",2632.0,2637.0,1.0,17.0,6.0,7,5,10,5,0,4,2,2,0,2,,0,3,4,2,2,robj
2890,171525,RM_FreeString,1,RM_FreeString,"void RM_FreeString (RedisModuleCtx*,robj*)",module.c,"void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
    decrRefCount(str);
    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);
}",2651.0,2654.0,1.0,40.0,4.0,1,1,5,3,0,2,2,2,0,2,,0,0,4,2,2,void
2891,171544,RM_RetainString,1,RM_RetainString,"void RM_RetainString (RedisModuleCtx*,robj*)",module.c,"void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
    if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {
        /* Increment the string reference counting only if we can't
         * just remove the object from the list of objects that should
         * be reclaimed. Why we do that, instead of just incrementing
         * the refcount in any case, and let the automatic FreeString()
         * call at the end to bring the refcount back at the desired
         * value? Because this way we ensure that the object refcount
         * value is 1 (instead of going to 2 to be dropped later to 1)
         * after the call to this function. This is needed for functions
         * like RedisModule_StringAppendBuffer() to work. */
        incrRefCount(str);
    }
}",2688.0,2701.0,1.0,42.0,14.0,3,3,5,3,0,2,2,2,1,2,,0,1,4,2,2,void
2892,171565,RM_HoldString,1,RM_HoldString,"robj RM_HoldString (RedisModuleCtx*,robj*)",module.c,"RedisModuleString* RM_HoldString(RedisModuleCtx *ctx, RedisModuleString *str) {
    if (str->refcount == OBJ_STATIC_REFCOUNT) {
        return RM_CreateStringFromString(ctx, str);
    }

    incrRefCount(str);
    if (ctx != NULL) {
        /*
         * Put the str in the auto memory management of the ctx.
         * It might already be there, in this case, the ref count will
         * be 2 and we will decrease the ref count twice and free the
         * object in the auto memory free function.
         *
         * Why we can not do the same trick of just remove the object
         * from the auto memory (like in RM_RetainString)?
         * This code shows the issue:
         *
         * RM_AutoMemory(ctx);
         * str1 = RM_CreateString(ctx, ""test"", 4);
         * str2 = RM_HoldString(ctx, str1);
         * RM_FreeString(str1);
         * RM_FreeString(str2);
         *
         * If after the RM_HoldString we would just remove the string from
         * the auto memory, th...",2730.0,2767.0,1.0,17.0,38.0,4,4,10,4,0,3,3,3,0,3,,0,0,4,2,2,robj
2893,171601,RM_StringPtrLen,1,RM_StringPtrLen,"const char* RM_StringPtrLen (robj*,size_t*)",module.c,"const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
    if (str == NULL) {
        const char *errmsg = ""(NULL string reply referenced in module)"";
        if (len) *len = strlen(errmsg);
        return errmsg;
    }
    if (len) *len = sdslen(str->ptr);
    return str->ptr;
}",2772.0,2780.0,1.0,34.0,9.0,8,4,11,4,0,1,4,5,0,1,,0,1,4,2,2,const char*
2894,171640,RM_StringToLongLong,1,RM_StringToLongLong,"int RM_StringToLongLong (robj*,long long*)",module.c,"int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {
    return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :
                                                     REDISMODULE_ERR;
}",2790.0,2793.0,1.0,30.0,4.0,3,2,3,2,0,2,1,1,0,2,,0,1,4,2,2,int
2895,171663,RM_StringToULongLong,1,RM_StringToULongLong,"int RM_StringToULongLong (robj*,long long unsigned*)",module.c,"int RM_StringToULongLong(const RedisModuleString *str, unsigned long long *ull) {
    return string2ull(str->ptr,ull) ? REDISMODULE_OK : REDISMODULE_ERR;
}",2799.0,2801.0,1.0,31.0,3.0,2,2,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2896,171682,RM_StringToDouble,1,RM_StringToDouble,"int RM_StringToDouble (robj*,double*)",module.c,"int RM_StringToDouble(const RedisModuleString *str, double *d) {
    int retval = getDoubleFromObject(str,d);
    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
}",2806.0,2809.0,1.0,28.0,4.0,3,3,4,3,0,1,1,1,0,1,,0,1,4,2,2,int
2897,171707,RM_StringToLongDouble,1,RM_StringToLongDouble,"int RM_StringToLongDouble (robj*,long double*)",module.c,"int RM_StringToLongDouble(const RedisModuleString *str, long double *ld) {
    int retval = string2ld(str->ptr,sdslen(str->ptr),ld);
    return retval ? REDISMODULE_OK : REDISMODULE_ERR;
}",2814.0,2817.0,1.0,32.0,4.0,4,3,5,3,0,2,1,1,0,2,,0,2,4,2,2,int
2898,171734,RM_StringToStreamID,1,RM_StringToStreamID,"int RM_StringToStreamID (robj*,RedisModuleStreamID*)",module.c,"int RM_StringToStreamID(const RedisModuleString *str, RedisModuleStreamID *id) {
    streamID streamid;
    if (streamParseID(str, &streamid) == C_OK) {
        id->ms = streamid.ms;
        id->seq = streamid.seq;
        return REDISMODULE_OK;
    } else {
        return REDISMODULE_ERR;
    }
}",2824.0,2833.0,1.0,30.0,10.0,8,5,6,3,0,5,2,2,1,1,,0,5,4,2,2,int
2899,171775,RM_StringCompare,1,RM_StringCompare,"int RM_StringCompare (robj*,robj*)",module.c,"int RM_StringCompare(const RedisModuleString *a, const RedisModuleString *b) {
    return compareStringObjects(a,b);
}",2838.0,2840.0,1.0,27.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2900,171785,moduleAssertUnsharedString,1,moduleAssertUnsharedString,robj moduleAssertUnsharedString (robj*),module.c,"RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
    if (str->refcount != 1) {
        serverLog(LL_WARNING,
            ""Module attempted to use an in-place string modify operation ""
            ""with a string referenced multiple times. Please check the code ""
            ""for API usage correctness."");
        return NULL;
    }
    if (str->encoding == OBJ_ENCODING_EMBSTR) {
        /* Note: here we ""leak"" the additional allocation that was
         * used in order to store the embedded string in the object. */
        str->ptr = sdsnewlen(str->ptr,sdslen(str->ptr));
        str->encoding = OBJ_ENCODING_RAW;
    } else if (str->encoding == OBJ_ENCODING_INT) {
        /* Convert the string from integer to raw encoding. */
        str->ptr = sdsfromlonglong((long)str->ptr);
        str->encoding = OBJ_ENCODING_RAW;
    }
    return str;
}",2844.0,2863.0,1.0,17.0,20.0,13,7,9,3,1,3,3,3,0,3,,0,2,2,1,1,robj
2901,171875,RM_StringAppendBuffer,1,RM_StringAppendBuffer,"int RM_StringAppendBuffer (RedisModuleCtx*,robj*,char*,size_t)",module.c,"int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {
    UNUSED(ctx);
    str = moduleAssertUnsharedString(str);
    if (str == NULL) return REDISMODULE_ERR;
    str->ptr = sdscatlen(str->ptr,buf,len);
    return REDISMODULE_OK;
}",2868.0,2874.0,1.0,47.0,7.0,6,4,10,5,0,2,2,2,0,2,,0,2,8,4,4,int
2902,171916,RM_TrimStringAllocation,1,RM_TrimStringAllocation,void RM_TrimStringAllocation (robj*),module.c,"void RM_TrimStringAllocation(RedisModuleString *str) {
    if (!str) return;
    trimStringObjectIfNeeded(str, 1);
}",2899.0,2902.0,1.0,29.0,4.0,1,1,2,1,0,1,2,2,0,1,,0,0,2,1,1,void
2903,171929,RM_WrongArity,1,RM_WrongArity,int RM_WrongArity (RedisModuleCtx*),module.c,"int RM_WrongArity(RedisModuleCtx *ctx) {
    addReplyErrorArity(ctx->client);
    return REDISMODULE_OK;
}",2935.0,2938.0,1.0,11.0,4.0,1,1,1,1,0,2,1,1,0,1,,0,1,2,1,1,int
2904,171942,moduleGetReplyClient,1,moduleGetReplyClient,client moduleGetReplyClient (RedisModuleCtx*),module.c,"client *moduleGetReplyClient(RedisModuleCtx *ctx) {
    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {
        if (ctx->blocked_client)
            return ctx->blocked_client->reply_client;
        else
            return NULL;
    } else {
        /* If this is a non thread safe context, just return the client
         * that is running the command if any. This may be NULL as well
         * in the case of contexts that are not executed with associated
         * clients, like timer contexts. */
        return ctx->client;
    }
}",2954.0,2967.0,1.0,21.0,14.0,6,3,3,1,19,3,3,4,2,0,,0,3,2,1,1,client
2905,171979,RM_ReplyWithLongLong,1,RM_ReplyWithLongLong,"int RM_ReplyWithLongLong (RedisModuleCtx*,long long)",module.c,"int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyLongLong(c,ll);
    return REDISMODULE_OK;
}",2971.0,2976.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
2906,172006,RM_ReplyWithError,1,RM_ReplyWithError,"int RM_ReplyWithError (RedisModuleCtx*,char*)",module.c,"int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyErrorFormat(c,""-%s"",err);
    return REDISMODULE_OK;
}",2992.0,2997.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
2907,172034,RM_ReplyWithErrorFormat,1,RM_ReplyWithErrorFormat,"int RM_ReplyWithErrorFormat (RedisModuleCtx*,char*...)",module.c,"int RM_ReplyWithErrorFormat(RedisModuleCtx *ctx, const char *fmt, ...) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;

    int len = strlen(fmt) + 2; /* 1 for the \0 and 1 for the hyphen */
    char *hyphenfmt = zmalloc(len);
    snprintf(hyphenfmt, len, ""-%s"", fmt);

    va_list ap;
    va_start(ap, fmt);
    addReplyErrorFormatInternal(c, 0, hyphenfmt, ap);
    va_end(ap);

    zfree(hyphenfmt);

    return REDISMODULE_OK;
}",3013.0,3029.0,1.0,26.0,17.0,5,3,18,7,0,4,2,2,0,4,,0,2,4,2,2,int
2908,172088,RM_ReplyWithSimpleString,1,RM_ReplyWithSimpleString,"int RM_ReplyWithSimpleString (RedisModuleCtx*,char*)",module.c,"int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyProto(c,""+"",1);
    addReplyProto(c,msg,strlen(msg));
    addReplyProto(c,""\r\n"",2);
    return REDISMODULE_OK;
}",3036.0,3043.0,1.0,26.0,8.0,2,2,9,4,0,4,2,2,0,4,,0,1,4,2,2,int
2909,172125,moduleReplyWithCollection,1,moduleReplyWithCollection,"int moduleReplyWithCollection (RedisModuleCtx*,long,int)",module.c,"int moduleReplyWithCollection(RedisModuleCtx *ctx, long len, int type) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    if (len == REDISMODULE_POSTPONED_LEN) {
        ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*
                (ctx->postponed_arrays_count+1));
        ctx->postponed_arrays[ctx->postponed_arrays_count] =
            addReplyDeferredLen(c);
        ctx->postponed_arrays_count++;
    } else if (len == 0) {
        switch (type) {
        case COLLECTION_REPLY_ARRAY:
            addReply(c, shared.emptyarray);
            break;
        case COLLECTION_REPLY_MAP:
            addReply(c, shared.emptymap[c->resp]);
            break;
        case COLLECTION_REPLY_SET:
            addReply(c, shared.emptyset[c->resp]);
            break;
        case COLLECTION_REPLY_ATTRIBUTE:
            addReplyAttributeLen(c,len);
            break;
        default:
            serverPanic(""Invalid module empty reply ...",3050.0,3094.0,1.0,26.0,45.0,17,9,13,5,4,9,3,3,0,3,,0,9,6,3,3,int
2910,172301,RM_ReplyWithArray,1,RM_ReplyWithArray,"int RM_ReplyWithArray (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_ARRAY);
}",3105.0,3107.0,1.0,47.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2911,172314,RM_ReplyWithMap,1,RM_ReplyWithMap,"int RM_ReplyWithMap (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithMap(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_MAP);
}",3122.0,3124.0,1.0,47.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2912,172327,RM_ReplyWithSet,1,RM_ReplyWithSet,"int RM_ReplyWithSet (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithSet(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_SET);
}",3139.0,3141.0,1.0,47.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2913,172340,RM_ReplyWithAttribute,1,RM_ReplyWithAttribute,"int RM_ReplyWithAttribute (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithAttribute(RedisModuleCtx *ctx, long len) {
    if (ctx->client->resp == 2) return REDISMODULE_ERR;
 
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_ATTRIBUTE);
}",3155.0,3159.0,1.0,39.0,5.0,3,2,3,2,0,2,2,2,1,1,,0,1,4,2,2,int
2914,172366,RM_ReplyWithNullArray,1,RM_ReplyWithNullArray,int RM_ReplyWithNullArray (RedisModuleCtx*),module.c,"int RM_ReplyWithNullArray(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyNullArray(c);
    return REDISMODULE_OK;
}",3169.0,3174.0,1.0,26.0,6.0,2,2,5,3,0,2,2,2,0,2,,0,1,2,1,1,int
2915,172391,RM_ReplyWithEmptyArray,1,RM_ReplyWithEmptyArray,int RM_ReplyWithEmptyArray (RedisModuleCtx*),module.c,"int RM_ReplyWithEmptyArray(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReply(c,shared.emptyarray);
    return REDISMODULE_OK;
}",3179.0,3184.0,1.0,26.0,6.0,3,3,6,4,0,2,2,2,0,2,,0,1,2,1,1,int
2916,172419,moduleReplySetCollectionLength,1,moduleReplySetCollectionLength,"void moduleReplySetCollectionLength (RedisModuleCtx*,long,int)",module.c,"void moduleReplySetCollectionLength(RedisModuleCtx *ctx, long len, int type) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return;
    if (ctx->postponed_arrays_count == 0) {
        serverLog(LL_WARNING,
            ""API misuse detected in module %s: ""
            ""RedisModule_ReplySet*Length() called without previous ""
            ""RedisModule_ReplyWith*(ctx,REDISMODULE_POSTPONED_LEN) ""
            ""call."", ctx->module->name);
            return;
    }
    ctx->postponed_arrays_count--;
    switch(type) {
    case COLLECTION_REPLY_ARRAY:
        setDeferredArrayLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_MAP:
        setDeferredMapLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_SET:
        setDeferredSetLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_ATTRIBUTE:
        setDeferredAttributeLen(...",3186.0,3218.0,1.0,8.0,33.0,29,9,30,6,4,22,9,5,2,8,,0,15,6,3,3,void
2917,172561,RM_ReplySetArrayLength,1,RM_ReplySetArrayLength,"void RM_ReplySetArrayLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_ARRAY);
}",3246.0,3248.0,1.0,45.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
2918,172573,RM_ReplySetMapLength,1,RM_ReplySetMapLength,"void RM_ReplySetMapLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetMapLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_MAP);
}",3254.0,3256.0,1.0,45.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
2919,172585,RM_ReplySetSetLength,1,RM_ReplySetSetLength,"void RM_ReplySetSetLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetSetLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_SET);
}",3260.0,3262.0,1.0,45.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
2920,172597,RM_ReplySetAttributeLength,1,RM_ReplySetAttributeLength,"void RM_ReplySetAttributeLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetAttributeLength(RedisModuleCtx *ctx, long len) {
    if (ctx->client->resp == 2) return;
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_ATTRIBUTE);
}",3268.0,3271.0,1.0,45.0,4.0,3,2,3,2,0,2,2,2,1,1,,0,1,4,2,2,void
2921,172619,RM_ReplyWithStringBuffer,1,RM_ReplyWithStringBuffer,"int RM_ReplyWithStringBuffer (RedisModuleCtx*,char*,size_t)",module.c,"int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulkCBuffer(c,(char*)buf,len);
    return REDISMODULE_OK;
}",3276.0,3281.0,1.0,26.0,6.0,3,3,7,5,0,2,2,2,0,2,,0,1,6,3,3,int
2922,172650,RM_ReplyWithCString,1,RM_ReplyWithCString,"int RM_ReplyWithCString (RedisModuleCtx*,char*)",module.c,"int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulkCString(c,(char*)buf);
    return REDISMODULE_OK;
}",3287.0,3292.0,1.0,26.0,6.0,3,3,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
2923,172679,RM_ReplyWithString,1,RM_ReplyWithString,"int RM_ReplyWithString (RedisModuleCtx*,robj*)",module.c,"int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulk(c,str);
    return REDISMODULE_OK;
}",3297.0,3302.0,1.0,44.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
2924,172706,RM_ReplyWithEmptyString,1,RM_ReplyWithEmptyString,int RM_ReplyWithEmptyString (RedisModuleCtx*),module.c,"int RM_ReplyWithEmptyString(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReply(c,shared.emptybulk);
    return REDISMODULE_OK;
}",3307.0,3312.0,1.0,26.0,6.0,3,3,6,4,0,2,2,2,0,2,,0,1,2,1,1,int
2925,172734,RM_ReplyWithVerbatimStringType,1,RM_ReplyWithVerbatimStringType,"int RM_ReplyWithVerbatimStringType (RedisModuleCtx*,char*,size_t,char*)",module.c,"int RM_ReplyWithVerbatimStringType(RedisModuleCtx *ctx, const char *buf, size_t len, const char *ext) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyVerbatim(c, buf, len, ext);
    return REDISMODULE_OK;
}",3318.0,3323.0,1.0,26.0,6.0,2,2,8,6,1,2,2,2,0,2,,0,1,8,4,4,int
2926,172765,RM_ReplyWithVerbatimString,1,RM_ReplyWithVerbatimString,"int RM_ReplyWithVerbatimString (RedisModuleCtx*,char*,size_t)",module.c,"int RM_ReplyWithVerbatimString(RedisModuleCtx *ctx, const char *buf, size_t len) {
	return RM_ReplyWithVerbatimStringType(ctx, buf, len, ""txt"");
}",3329.0,3331.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
2927,172778,RM_ReplyWithNull,1,RM_ReplyWithNull,int RM_ReplyWithNull (RedisModuleCtx*),module.c,"int RM_ReplyWithNull(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyNull(c);
    return REDISMODULE_OK;
}",3336.0,3341.0,1.0,26.0,6.0,2,2,5,3,0,2,2,2,0,2,,0,1,2,1,1,int
2928,172803,RM_ReplyWithBool,1,RM_ReplyWithBool,"int RM_ReplyWithBool (RedisModuleCtx*,int)",module.c,"int RM_ReplyWithBool(RedisModuleCtx *ctx, int b) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBool(c,b);
    return REDISMODULE_OK;
}",3350.0,3355.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
2929,172830,RM_ReplyWithCallReply,1,RM_ReplyWithCallReply,"int RM_ReplyWithCallReply (RedisModuleCtx*,RedisModuleCallReply*)",module.c,"int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    if (c->resp == 2 && callReplyIsResp3(reply)) {
        /* The reply is in RESP3 format and the client is RESP2,
         * so it isn't possible to send this reply to the client. */
        return REDISMODULE_ERR;
    }
    size_t proto_len;
    const char *proto = callReplyGetProto(reply, &proto_len);
    addReplyProto(c, proto, proto_len);
    /* Propagate the error list from that reply to the other client, to do some
     * post error reply handling, like statistics.
     * Note that if the original reply had an array with errors, and the module
     * replied with just a portion of the original reply, and not the entire
     * reply, the errors are currently not propagated and the errors stats
     * will not get propagated. */
    list *errors = callReplyDeferredErrorList(reply);
    if (errors)
        deferredAft...",3370.0,3391.0,1.0,26.0,22.0,8,5,17,7,0,7,4,4,2,6,,0,5,4,2,2,int
2930,172891,RM_ReplyWithDouble,1,RM_ReplyWithDouble,"int RM_ReplyWithDouble (RedisModuleCtx*,double)",module.c,"int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyDouble(c,d);
    return REDISMODULE_OK;
}",3405.0,3410.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
2931,172918,RM_ReplyWithBigNumber,1,RM_ReplyWithBigNumber,"int RM_ReplyWithBigNumber (RedisModuleCtx*,char*,size_t)",module.c,"int RM_ReplyWithBigNumber(RedisModuleCtx *ctx, const char *bignum, size_t len) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBigNum(c, bignum, len);
    return REDISMODULE_OK;
}",3420.0,3425.0,1.0,26.0,6.0,2,2,7,5,0,2,2,2,0,2,,0,1,6,3,3,int
2932,172947,RM_ReplyWithLongDouble,1,RM_ReplyWithLongDouble,"int RM_ReplyWithLongDouble (RedisModuleCtx*,long double)",module.c,"int RM_ReplyWithLongDouble(RedisModuleCtx *ctx, long double ld) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyHumanLongDouble(c, ld);
    return REDISMODULE_OK;
}",3435.0,3440.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
2933,172974,RM_Replicate,1,RM_Replicate,"int RM_Replicate (RedisModuleCtx*,char*,char*...)",module.c,"int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
    struct redisCommand *cmd;
    robj **argv = NULL;
    int argc = 0, flags = 0, j;
    va_list ap;

    cmd = lookupCommandByCString((char*)cmdname);
    if (!cmd) return REDISMODULE_ERR;

    /* Create the client and dispatch the command. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    va_end(ap);
    if (argv == NULL) return REDISMODULE_ERR;

    /* Select the propagation target. Usually is AOF + replicas, however
     * the caller can exclude one or the other using the ""A"" or ""R""
     * modifiers. */
    int target = 0;
    if (!(flags & REDISMODULE_ARGV_NO_AOF)) target |= PROPAGATE_AOF;
    if (!(flags & REDISMODULE_ARGV_NO_REPLICAS)) target |= PROPAGATE_REPL;

    alsoPropagate(ctx->client->db->id,argv,argc,target);

    /* Release the argv. */
    for (j = 0; j < argc; j++) decrRefCount(argv[j]);
    zfree(argv);
    server.dirty++;
    re...",3483.0,3512.0,1.0,21.0,30.0,24,11,32,12,0,5,6,6,0,4,,0,3,6,3,3,int
2934,173103,RM_ReplicateVerbatim,1,RM_ReplicateVerbatim,int RM_ReplicateVerbatim (RedisModuleCtx*),module.c,"int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
    alsoPropagate(ctx->client->db->id,
        ctx->client->argv,ctx->client->argc,
        PROPAGATE_AOF|PROPAGATE_REPL);
    server.dirty++;
    return REDISMODULE_OK;
}",3525.0,3531.0,1.0,8.0,7.0,10,4,4,2,0,4,1,1,0,1,,0,3,2,1,1,int
2935,173141,RM_GetClientId,1,RM_GetClientId,unsigned long long RM_GetClientId (RedisModuleCtx*),module.c,"unsigned long long RM_GetClientId(RedisModuleCtx *ctx) {
    if (ctx->client == NULL) return 0;
    return ctx->client->id;
}",3556.0,3559.0,1.0,1.0,4.0,4,2,3,2,0,2,2,2,1,0,,0,2,2,1,1,unsigned long long
2936,173161,RM_GetClientUserNameById,1,RM_GetClientUserNameById,"robj RM_GetClientUserNameById (RedisModuleCtx*,uint64_t)",module.c,"RedisModuleString *RM_GetClientUserNameById(RedisModuleCtx *ctx, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL) {
        errno = ENOENT;
        return NULL;
    }
    
    if (client->user == NULL) {
        errno = ENOTSUP;
        return NULL;
    }

    sds name = sdsnew(client->user->name);
    robj *str = createObject(OBJ_STRING, name);
    autoMemoryAdd(ctx, REDISMODULE_AM_STRING, str);
    return str;
}",3565.0,3581.0,1.0,17.0,17.0,10,3,19,9,0,6,3,3,1,4,,0,5,4,2,2,robj
2937,173219,modulePopulateClientInfoStructure,1,modulePopulateClientInfoStructure,"int modulePopulateClientInfoStructure (void*,client*,int)",module.c,"int modulePopulateClientInfoStructure(void *ci, client *client, int structver) {
    if (structver != 1) return REDISMODULE_ERR;

    RedisModuleClientInfoV1 *ci1 = ci;
    memset(ci1,0,sizeof(*ci1));
    ci1->version = structver;
    if (client->flags & CLIENT_MULTI)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_MULTI;
    if (client->flags & CLIENT_PUBSUB)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_PUBSUB;
    if (client->flags & CLIENT_UNIX_SOCKET)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET;
    if (client->flags & CLIENT_TRACKING)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_TRACKING;
    if (client->flags & CLIENT_BLOCKED)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_BLOCKED;
    if (client->conn->type == connectionTypeTls())
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_SSL;

    int port;
    connAddrPeerName(client->conn,ci1->addr,sizeof(ci1->addr),&port);
    ci1->port = port;
    ci1->db = client->db->id;
    ci1->id = client->id;...",3589.0,3614.0,1.0,31.0,26.0,50,9,29,5,2,11,8,8,7,2,,0,10,6,3,3,int
2938,173497,RM_GetClientInfoById,1,RM_GetClientInfoById,"int RM_GetClientInfoById (void*,uint64_t)",module.c,"int RM_GetClientInfoById(void *ci, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL) return REDISMODULE_ERR;
    if (ci == NULL) return REDISMODULE_OK;

    /* Fill the info structure if passed. */
    uint64_t structver = ((uint64_t*)ci)[0];
    return modulePopulateClientInfoStructure(ci,client,structver);
}",3679.0,3687.0,1.0,31.0,9.0,6,4,11,5,0,2,3,3,0,2,,0,1,4,2,2,int
2939,173539,RM_GetClientNameById,1,RM_GetClientNameById,"robj RM_GetClientNameById (RedisModuleCtx*,uint64_t)",module.c,"RedisModuleString *RM_GetClientNameById(RedisModuleCtx *ctx, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL || client->name == NULL) return NULL;
    robj *name = client->name;
    incrRefCount(name);
    autoMemoryAdd(ctx, REDISMODULE_AM_STRING, name);
    return name;
}",3693.0,3700.0,1.0,17.0,8.0,7,4,13,5,0,5,2,2,1,3,,0,3,4,2,2,robj
2940,173579,RM_SetClientNameById,1,RM_SetClientNameById,"int RM_SetClientNameById (uint64_t,robj*)",module.c,"int RM_SetClientNameById(uint64_t id, RedisModuleString *name) {
    client *client = lookupClientByID(id);
    if (client == NULL) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    if (clientSetName(client, name, NULL) == C_ERR) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",3710.0,3721.0,1.0,38.0,12.0,6,3,11,7,0,2,3,3,1,2,,0,2,4,2,2,int
2941,173624,RM_PublishMessage,1,RM_PublishMessage,"int RM_PublishMessage (RedisModuleCtx*,robj*,robj*)",module.c,"int RM_PublishMessage(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) {
    UNUSED(ctx);
    return pubsubPublishMessageAndPropagateToCluster(channel, message, 0);
}",3724.0,3727.0,1.0,43.0,4.0,1,1,4,3,0,1,1,1,0,1,,0,0,6,3,3,int
2942,173642,RM_PublishMessageShard,1,RM_PublishMessageShard,"int RM_PublishMessageShard (RedisModuleCtx*,robj*,robj*)",module.c,"int RM_PublishMessageShard(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) {
    UNUSED(ctx);
    return pubsubPublishMessageAndPropagateToCluster(channel, message, 1);
}",3730.0,3733.0,1.0,48.0,4.0,1,1,4,3,0,1,1,1,0,1,,0,0,6,3,3,int
2943,173660,RM_GetSelectedDb,1,RM_GetSelectedDb,int RM_GetSelectedDb (RedisModuleCtx*),module.c,"int RM_GetSelectedDb(RedisModuleCtx *ctx) {
    return ctx->client->db->id;
}",3736.0,3738.0,1.0,1.0,3.0,3,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
2944,173673,RM_GetContextFlags,1,RM_GetContextFlags,int RM_GetContextFlags (RedisModuleCtx*),module.c,"int RM_GetContextFlags(RedisModuleCtx *ctx) {
    int flags = 0;

    /* Client specific flags */
    if (ctx) {
        if (ctx->client) {
            if (ctx->client->flags & CLIENT_DENY_BLOCKING)
                flags |= REDISMODULE_CTX_FLAGS_DENY_BLOCKING;
            /* Module command received from MASTER, is replicated. */
            if (ctx->client->flags & CLIENT_MASTER)
                flags |= REDISMODULE_CTX_FLAGS_REPLICATED;
            if (ctx->client->resp == 3) {
                flags |= REDISMODULE_CTX_FLAGS_RESP3;
            }
        }

        /* For DIRTY flags, we need the blocked client if used */
        client *c = ctx->blocked_client ? ctx->blocked_client->client : ctx->client;
        if (c && (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC))) {
            flags |= REDISMODULE_CTX_FLAGS_MULTI_DIRTY;
        }
    }

    if (scriptIsRunning())
        flags |= REDISMODULE_CTX_FLAGS_LUA;

    if (server.in_exec)
        flags |= REDISMODULE_CTX_FLAGS_MULTI...",3810.0,3899.0,1.0,37.0,90.0,73,15,52,7,0,11,21,30,7,3,,0,11,2,1,1,int
2945,174102,RM_AvoidReplicaTraffic,1,RM_AvoidReplicaTraffic,int RM_AvoidReplicaTraffic (void),module.c,"int RM_AvoidReplicaTraffic(void) {
    return !!(isPausedActionsWithUpdate(PAUSE_ACTION_REPLICA));
}",3921.0,3923.0,1.0,40.0,3.0,3,2,0,0,0,1,1,1,0,1,,0,0,2,1,1,int
2946,174116,RM_SelectDb,1,RM_SelectDb,"int RM_SelectDb (RedisModuleCtx*,int)",module.c,"int RM_SelectDb(RedisModuleCtx *ctx, int newid) {
    int retval = selectDb(ctx->client,newid);
    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
}",3935.0,3938.0,1.0,22.0,4.0,4,4,4,3,0,2,1,1,0,1,,0,2,4,2,2,int
2947,174143,RM_KeyExists,1,RM_KeyExists,"int RM_KeyExists (RedisModuleCtx*,robj*)",module.c,"int RM_KeyExists(RedisModuleCtx *ctx, robj *keyname) {
    robj *value = lookupKeyReadWithFlags(ctx->client->db, keyname, LOOKUP_NOTOUCH);
    return (value != NULL);
}",3946.0,3949.0,1.0,67.0,4.0,5,4,5,4,0,2,1,1,0,1,,0,2,4,2,2,int
2948,174168,moduleInitKey,1,moduleInitKey,"void moduleInitKey (RedisModuleKey*,RedisModuleCtx*,robj*,robj*,int)",module.c,"static void moduleInitKey(RedisModuleKey *kp, RedisModuleCtx *ctx, robj *keyname, robj *value, int mode){
    kp->ctx = ctx;
    kp->db = ctx->client->db;
    kp->key = keyname;
    incrRefCount(keyname);
    kp->value = value;
    kp->iter = NULL;
    kp->mode = mode;
    if (kp->value) moduleInitKeyTypeSpecific(kp);
}",3952.0,3961.0,1.0,1.0,10.0,15,2,15,6,2,10,2,2,1,2,,0,8,10,5,5,void
2949,174253,RM_OpenKey,1,RM_OpenKey,"RedisModuleKey RM_OpenKey (RedisModuleCtx*,robj*,int)",module.c,"RedisModuleKey *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {
    RedisModuleKey *kp;
    robj *value;
    int flags = 0;
    flags |= (mode & REDISMODULE_OPEN_KEY_NOTOUCH? LOOKUP_NOTOUCH: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NONOTIFY? LOOKUP_NONOTIFY: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOSTATS? LOOKUP_NOSTATS: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOEXPIRE? LOOKUP_NOEXPIRE: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOEFFECTS? LOOKUP_NOEFFECTS: 0);

    if (mode & REDISMODULE_WRITE) {
        value = lookupKeyWriteWithFlags(ctx->client->db,keyname, flags);
    } else {
        value = lookupKeyReadWithFlags(ctx->client->db,keyname, flags);
        if (value == NULL) {
            return NULL;
        }
    }

    /* Setup the key handle. */
    kp = zmalloc(sizeof(*kp));
    moduleInitKey(kp, ctx, keyname, value, mode);
    autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);
    return kp;
}",3992.0,4016.0,1.0,21.0,25.0,35,8,26,6,0,5,2,2,0,4,,0,3,6,3,3,RedisModuleKey
2950,174451,moduleCloseKey,1,moduleCloseKey,void moduleCloseKey (RedisModuleKey*),module.c,"static void moduleCloseKey(RedisModuleKey *key) {
    int signal = SHOULD_SIGNAL_MODIFIED_KEYS(key->ctx);
    if ((key->mode & REDISMODULE_WRITE) && signal)
        signalModifiedKey(key->ctx->client,key->db,key->key);
    if (key->value) {
        if (key->iter) moduleFreeKeyIterator(key);
        switch (key->value->type) {
        case OBJ_ZSET:
            RM_ZsetRangeStop(key);
            break;
        case OBJ_STREAM:
            if (key->u.stream.signalready)
                /* One or more RM_StreamAdd() have been done. */
                signalKeyAsReady(key->db, key->key, OBJ_STREAM);
            break;
        }
    }
    serverAssert(key->iter == NULL);
    decrRefCount(key->key);
}",4036.0,4055.0,1.0,17.0,20.0,35,12,20,3,2,21,8,10,5,6,,0,15,2,1,1,void
2951,174603,RM_KeyType,1,RM_KeyType,int RM_KeyType (RedisModuleKey*),module.c,"int RM_KeyType(RedisModuleKey *key) {
    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;
    /* We map between defines so that we are free to change the internal
     * defines as desired. */
    switch(key->value->type) {
    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;
    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;
    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;
    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;
    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;
    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;
    case OBJ_STREAM: return REDISMODULE_KEYTYPE_STREAM;
    default: return REDISMODULE_KEYTYPE_EMPTY;
    }
}",4067.0,4081.0,1.0,51.0,15.0,6,3,5,2,2,2,3,3,2,0,,0,2,2,1,1,int
2952,174691,RM_ValueLength,1,RM_ValueLength,size_t RM_ValueLength (RedisModuleKey*),module.c,"size_t RM_ValueLength(RedisModuleKey *key) {
    if (key == NULL || key->value == NULL) return 0;
    switch(key->value->type) {
    case OBJ_STRING: return stringObjectLen(key->value);
    case OBJ_LIST: return listTypeLength(key->value);
    case OBJ_SET: return setTypeSize(key->value);
    case OBJ_ZSET: return zsetLength(key->value);
    case OBJ_HASH: return hashTypeLength(key->value);
    case OBJ_STREAM: return streamLength(key->value);
    default: return 0;
    }
}",4088.0,4099.0,1.0,9.0,12.0,12,3,11,2,0,14,3,3,2,6,,0,8,2,1,1,size_t
2953,174773,RM_DeleteKey,1,RM_DeleteKey,int RM_DeleteKey (RedisModuleKey*),module.c,"int RM_DeleteKey(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value) {
        dbDelete(key->db,key->key);
        key->value = NULL;
    }
    return REDISMODULE_OK;
}",4105.0,4112.0,1.0,22.0,8.0,9,5,6,2,2,6,3,3,2,1,,0,5,2,1,1,int
2954,174815,RM_UnlinkKey,1,RM_UnlinkKey,int RM_UnlinkKey (RedisModuleKey*),module.c,"int RM_UnlinkKey(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value) {
        dbAsyncDelete(key->db,key->key);
        key->value = NULL;
    }
    return REDISMODULE_OK;
}",4119.0,4126.0,1.0,22.0,8.0,9,5,6,2,0,6,3,3,2,1,,0,5,2,1,1,int
2955,174857,RM_GetExpire,1,RM_GetExpire,mstime_t RM_GetExpire (RedisModuleKey*),module.c,"mstime_t RM_GetExpire(RedisModuleKey *key) {
    mstime_t expire = getExpire(key->db,key->key);
    if (expire == -1 || key->value == NULL)
        return REDISMODULE_NO_EXPIRE;
    expire -= commandTimeSnapshot();
    return expire >= 0 ? expire : 0;
}",4131.0,4137.0,1.0,15.0,7.0,12,8,9,3,0,5,2,2,1,2,,0,4,2,1,1,mstime_t
2956,174899,RM_SetExpire,1,RM_SetExpire,"int RM_SetExpire (RedisModuleKey*,mstime_t)",module.c,"int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL || (expire < 0 && expire != REDISMODULE_NO_EXPIRE))
        return REDISMODULE_ERR;
    if (expire != REDISMODULE_NO_EXPIRE) {
        expire += commandTimeSnapshot();
        setExpire(key->ctx->client,key->db,key->key,expire);
    } else {
        removeExpire(key->db,key->key);
    }
    return REDISMODULE_OK;
}",4148.0,4158.0,1.0,22.0,11.0,19,11,11,3,0,7,3,3,2,2,,0,5,4,2,2,int
2957,174975,RM_GetAbsExpire,1,RM_GetAbsExpire,mstime_t RM_GetAbsExpire (RedisModuleKey*),module.c,"mstime_t RM_GetAbsExpire(RedisModuleKey *key) {
    mstime_t expire = getExpire(key->db,key->key);
    if (expire == -1 || key->value == NULL)
        return REDISMODULE_NO_EXPIRE;
    return expire;
}",4163.0,4168.0,1.0,15.0,6.0,9,5,7,3,0,4,2,2,1,1,,0,4,2,1,1,mstime_t
2958,175009,RM_SetAbsExpire,1,RM_SetAbsExpire,"int RM_SetAbsExpire (RedisModuleKey*,mstime_t)",module.c,"int RM_SetAbsExpire(RedisModuleKey *key, mstime_t expire) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL || (expire < 0 && expire != REDISMODULE_NO_EXPIRE))
        return REDISMODULE_ERR;
    if (expire != REDISMODULE_NO_EXPIRE) {
        setExpire(key->ctx->client,key->db,key->key,expire);
    } else {
        removeExpire(key->db,key->key);
    }
    return REDISMODULE_OK;
}",4179.0,4188.0,1.0,22.0,10.0,18,10,10,3,0,6,3,3,2,1,,0,5,4,2,2,int
2959,175082,RM_ResetDataset,1,RM_ResetDataset,"void RM_ResetDataset (int,int)",module.c,"void RM_ResetDataset(int restart_aof, int async) {
    if (restart_aof && server.aof_state != AOF_OFF) stopAppendOnly();
    flushAllDataAndResetRDB((async? EMPTYDB_ASYNC: EMPTYDB_NO_FLAGS) | EMPTYDB_NOFUNCTIONS);
    if (server.aof_enabled && restart_aof) restartAOFAfterSYNC();
}",4194.0,4198.0,1.0,43.0,5.0,9,6,5,3,0,3,3,3,0,3,,0,0,4,2,2,void
2960,175125,RM_DbSize,1,RM_DbSize,unsigned long long RM_DbSize (RedisModuleCtx*),module.c,"unsigned long long RM_DbSize(RedisModuleCtx *ctx) {
    return dictSize(ctx->client->db->dict);
}",4201.0,4203.0,1.0,11.0,3.0,14,3,3,1,0,3,1,1,0,0,,0,3,2,1,1,unsigned long long
2961,175163,RM_RandomKey,1,RM_RandomKey,robj RM_RandomKey (RedisModuleCtx*),module.c,"RedisModuleString *RM_RandomKey(RedisModuleCtx *ctx) {
    robj *key = dbRandomKey(ctx->client->db);
    autoMemoryAdd(ctx,REDISMODULE_AM_STRING,key);
    return key;
}",4206.0,4210.0,1.0,17.0,5.0,3,2,5,2,0,3,1,1,0,2,,0,2,2,1,1,robj
2962,175185,RM_GetKeyNameFromOptCtx,1,RM_GetKeyNameFromOptCtx,robj RM_GetKeyNameFromOptCtx (RedisModuleKeyOptCtx*),module.c,"const RedisModuleString *RM_GetKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->from_key;
}",4213.0,4215.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
2963,175194,RM_GetToKeyNameFromOptCtx,1,RM_GetToKeyNameFromOptCtx,robj RM_GetToKeyNameFromOptCtx (RedisModuleKeyOptCtx*),module.c,"const RedisModuleString *RM_GetToKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->to_key;
}",4218.0,4220.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
2964,175203,RM_GetDbIdFromOptCtx,1,RM_GetDbIdFromOptCtx,int RM_GetDbIdFromOptCtx (RedisModuleKeyOptCtx*),module.c,"int RM_GetDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->from_dbid;
}",4223.0,4225.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
2965,175212,RM_GetToDbIdFromOptCtx,1,RM_GetToDbIdFromOptCtx,int RM_GetToDbIdFromOptCtx (RedisModuleKeyOptCtx*),module.c,"int RM_GetToDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->to_dbid;
}",4228.0,4230.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
2966,175221,RM_StringSet,1,RM_StringSet,"int RM_StringSet (RedisModuleKey*,robj*)",module.c,"int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
    RM_DeleteKey(key);
    setKey(key->ctx->client,key->db,key->key,str,SETKEY_NO_SIGNAL);
    key->value = str;
    return REDISMODULE_OK;
}",4241.0,4247.0,1.0,38.0,7.0,12,6,9,2,0,8,2,2,2,2,,0,6,4,2,2,int
2967,175274,RM_StringDMA,1,RM_StringDMA,"char* RM_StringDMA (RedisModuleKey*,size_t*,int)",module.c,"char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
    /* We need to return *some* pointer for empty keys, we just return
     * a string literal pointer, that is the advantage to be mapped into
     * a read only memory page, so the module will segfault if a write
     * attempt is performed. */
    char *emptystring = ""<dma-empty-string>"";
    if (key->value == NULL) {
        *len = 0;
        return emptystring;
    }

    if (key->value->type != OBJ_STRING) return NULL;

    /* For write access, and even for read access if the object is encoded,
     * we unshare the string (that has the side effect of decoding it). */
    if ((mode & REDISMODULE_WRITE) || key->value->encoding != OBJ_ENCODING_RAW)
        key->value = dbUnshareStringValue(key->db, key->key, key->value);

    *len = sdslen(key->value->ptr);
    return key->value->ptr;
}",4278.0,4298.0,1.0,28.0,21.0,25,8,16,5,0,11,4,4,3,2,,0,11,6,3,3,char*
2968,175359,RM_StringTruncate,1,RM_StringTruncate,"int RM_StringTruncate (RedisModuleKey*,size_t)",module.c,"int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;
    if (newlen > 512*1024*1024) return REDISMODULE_ERR;

    /* Empty key and new len set to 0. Just return REDISMODULE_OK without
     * doing anything. */
    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;

    if (key->value == NULL) {
        /* Empty key: create it with the new size. */
        robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));
        setKey(key->ctx->client,key->db,key->key,o,SETKEY_NO_SIGNAL);
        key->value = o;
        decrRefCount(o);
    } else {
        /* Unshare and resize. */
        key->value = dbUnshareStringValue(key->db, key->key, key->value);
        size_t curlen = sdslen(key->value->ptr);
        if (newlen > curlen) {
            key->value->ptr = sdsgrowzero(key->value->ptr,newlen);
        } else if (newlen < cu...",4312.0,4341.0,1.0,22.0,30.0,25,10,19,4,0,13,6,6,5,4,,0,11,4,2,2,int
2969,175558,moduleListIteratorSeek,1,moduleListIteratorSeek,"int moduleListIteratorSeek (RedisModuleKey*,long,int)",module.c,"int moduleListIteratorSeek(RedisModuleKey *key, long index, int mode) {
    if (!key) {
        errno = EINVAL;
        return 0;
    } else if (!key->value || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return 0;
    } if (!(key->mode & mode)) {
        errno = EBADF;
        return 0;
    }

    long length = listTypeLength(key->value);
    if (index < -length || index >= length) {
        errno = EDOM; /* Invalid index */
        return 0;
    }

    if (key->iter == NULL) {
        /* No existing iterator. Create one. */
        key->iter = listTypeInitIterator(key->value, index, LIST_TAIL);
        serverAssert(key->iter != NULL);
        serverAssert(listTypeNext(key->iter, &key->u.list.entry));
        key->u.list.index = index;
        return 1;
    }

    /* There's an existing iterator. Make sure the requested index has the same
     * sign as the iterator's index. */
    if      (index < 0 && key->u.list.index >= 0) index += length;
    else if (index...",4375.0,4417.0,1.0,50.0,43.0,79,18,44,10,4,26,8,8,5,8,,0,20,6,3,3,int
2970,175843,RM_ListPush,1,RM_ListPush,"int RM_ListPush (RedisModuleKey*,int,robj*)",module.c,"int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
    if (!key || !ele) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key->value != NULL && key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }

    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;
    if (key->iter) moduleFreeKeyIterator(key);
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);
    listTypeTryConversionAppend(key->value, &ele, 0, 0, moduleFreeListIterator, key);
    listTypePush(key->value, ele,
        (where == REDISMODULE_LIST_HEAD) ? LIST_HEAD : LIST_TAIL);
    return REDISMODULE_OK;
}",4430.0,4450.0,1.0,48.0,21.0,26,11,21,7,0,12,7,7,6,4,,0,8,6,3,3,int
2971,175994,RM_ListPop,1,RM_ListPop,"robj RM_ListPop (RedisModuleKey*,int)",module.c,"RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
    if (!key) {
        errno = EINVAL;
        return NULL;
    } else if (key->value == NULL || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return NULL;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return NULL;
    }
    if (key->iter) moduleFreeKeyIterator(key);
    robj *ele = listTypePop(key->value,
        (where == REDISMODULE_LIST_HEAD) ? LIST_HEAD : LIST_TAIL);
    robj *decoded = getDecodedObject(ele);
    decrRefCount(ele);
    if (!moduleDelKeyIfEmpty(key))
        listTypeTryConversion(key->value, LIST_CONV_SHRINKING, moduleFreeListIterator, key);
    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);
    return decoded;
}",4464.0,4484.0,1.0,17.0,21.0,11,5,19,8,0,11,4,4,2,7,,0,7,4,2,2,robj
2972,176107,RM_ListGet,1,RM_ListGet,"robj RM_ListGet (RedisModuleKey*,long)",module.c,"RedisModuleString *RM_ListGet(RedisModuleKey *key, long index) {
    if (moduleListIteratorSeek(key, index, REDISMODULE_READ)) {
        robj *elem = listTypeGet(&key->u.list.entry);
        robj *decoded = getDecodedObject(elem);
        decrRefCount(elem);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, decoded);
        return decoded;
    } else {
        return NULL;
    }
}",4503.0,4513.0,1.0,17.0,11.0,8,5,10,4,0,7,2,2,1,5,,0,5,4,2,2,robj
2973,176156,RM_ListSet,1,RM_ListSet,"int RM_ListSet (RedisModuleKey*,long,robj*)",module.c,"int RM_ListSet(RedisModuleKey *key, long index, RedisModuleString *value) {
    if (!value) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    if (!key->value || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    }
    listTypeTryConversionAppend(key->value, &value, 0, 0, moduleFreeListIterator, key);
    if (moduleListIteratorSeek(key, index, REDISMODULE_WRITE)) {
        listTypeReplace(&key->u.list.entry, value);
        /* A note in quicklist.c forbids use of iterator after insert, so
         * probably also after replace. */
        moduleFreeKeyIterator(key);
        return REDISMODULE_OK;
    } else {
        return REDISMODULE_ERR;
    }
}",4530.0,4549.0,1.0,48.0,20.0,16,8,15,6,0,8,4,4,3,4,,0,5,6,3,3,int
2974,176239,RM_ListInsert,1,RM_ListInsert,"int RM_ListInsert (RedisModuleKey*,long,robj*)",module.c,"int RM_ListInsert(RedisModuleKey *key, long index, RedisModuleString *value) {
    if (!value) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key != NULL && key->value == NULL &&
               (index == 0 || index == -1)) {
        /* Insert in empty key => push. */
        return RM_ListPush(key, REDISMODULE_LIST_TAIL, value);
    } else if (key != NULL && key->value != NULL &&
               key->value->type == OBJ_LIST &&
               (index == (long)listTypeLength(key->value) || index == -1)) {
        /* Insert after the last element => push tail. */
        return RM_ListPush(key, REDISMODULE_LIST_TAIL, value);
    } else if (key != NULL && key->value != NULL &&
               key->value->type == OBJ_LIST &&
               (index == 0 || index == -(long)listTypeLength(key->value) - 1)) {
        /* Insert before the first element => push head. */
        return RM_ListPush(key, REDISMODULE_LIST_HEAD, value);
    }
    listTypeTryConversionAppend(ke...",4566.0,4595.0,1.0,51.0,30.0,12,8,14,6,0,6,3,3,1,4,,0,3,6,3,3,int
2975,176432,RM_ListDelete,1,RM_ListDelete,"int RM_ListDelete (RedisModuleKey*,long)",module.c,"int RM_ListDelete(RedisModuleKey *key, long index) {
    if (moduleListIteratorSeek(key, index, REDISMODULE_WRITE)) {
        listTypeDelete(key->iter, &key->u.list.entry);
        if (moduleDelKeyIfEmpty(key)) return REDISMODULE_OK;
        listTypeTryConversion(key->value, LIST_CONV_SHRINKING, moduleFreeListIterator, key);
        if (!key->iter) return REDISMODULE_OK; /* Return ASAP if iterator has been freed */
        if (listTypeNext(key->iter, &key->u.list.entry)) {
            /* After delete entry at position 'index', we need to update
             * 'key->u.list.index' according to the following cases:
             * 1) [1, 2, 3] => dir: forward, index: 0  => [2, 3] => index: still 0
             * 2) [1, 2, 3] => dir: forward, index: -3 => [2, 3] => index: -2
             * 3) [1, 2, 3] => dir: reverse, index: 2  => [1, 2] => index: 1
             * 4) [1, 2, 3] => dir: reverse, index: -1 => [1, 2] => index: still -1 */
            listTypeIterator *li = key->iter;
      ...",4608.0,4635.0,1.0,43.0,28.0,28,10,18,5,0,15,6,11,7,5,,0,13,4,2,2,int
2976,176567,moduleZsetAddFlagsToCoreFlags,1,moduleZsetAddFlagsToCoreFlags,int moduleZsetAddFlagsToCoreFlags (int),module.c,"int moduleZsetAddFlagsToCoreFlags(int flags) {
    int retflags = 0;
    if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_IN_XX;
    if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_IN_NX;
    if (flags & REDISMODULE_ZADD_GT) retflags |= ZADD_IN_GT;
    if (flags & REDISMODULE_ZADD_LT) retflags |= ZADD_IN_LT;
    return retflags;
}",4645.0,4652.0,1.0,16.0,8.0,13,3,10,2,2,0,5,5,0,0,,0,0,2,1,1,int
2977,176642,moduleZsetAddFlagsFromCoreFlags,1,moduleZsetAddFlagsFromCoreFlags,int moduleZsetAddFlagsFromCoreFlags (int),module.c,"int moduleZsetAddFlagsFromCoreFlags(int flags) {
    int retflags = 0;
    if (flags & ZADD_OUT_ADDED) retflags |= REDISMODULE_ZADD_ADDED;
    if (flags & ZADD_OUT_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;
    if (flags & ZADD_OUT_NOP) retflags |= REDISMODULE_ZADD_NOP;
    return retflags;
}",4655.0,4661.0,1.0,16.0,7.0,10,3,8,2,2,0,4,4,0,0,,0,0,2,1,1,int
2978,176701,RM_ZsetAdd,1,RM_ZsetAdd,"int RM_ZsetAdd (RedisModuleKey*,double,robj*,int*)",module.c,"int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {
    int in_flags = 0, out_flags = 0;
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
    if (flagsptr) in_flags = moduleZsetAddFlagsToCoreFlags(*flagsptr);
    if (zsetAdd(key->value,score,ele->ptr,in_flags,&out_flags,NULL) == 0) {
        if (flagsptr) *flagsptr = 0;
        moduleDelKeyIfEmpty(key);
        return REDISMODULE_ERR;
    }
    if (flagsptr) *flagsptr = moduleZsetAddFlagsFromCoreFlags(out_flags);
    return REDISMODULE_OK;
}",4695.0,4708.0,1.0,50.0,14.0,23,10,23,7,0,10,8,9,6,5,,0,8,8,4,4,int
2979,176813,RM_ZsetIncrby,1,RM_ZsetIncrby,"int RM_ZsetIncrby (RedisModuleKey*,double,robj*,int*,double*)",module.c,"int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {
    int in_flags = 0, out_flags = 0;
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
    if (flagsptr) in_flags = moduleZsetAddFlagsToCoreFlags(*flagsptr);
    in_flags |= ZADD_IN_INCR;
    if (zsetAdd(key->value,score,ele->ptr,in_flags,&out_flags,newscore) == 0) {
        if (flagsptr) *flagsptr = 0;
        moduleDelKeyIfEmpty(key);
        return REDISMODULE_ERR;
    }
    if (flagsptr) *flagsptr = moduleZsetAddFlagsFromCoreFlags(out_flags);
    return REDISMODULE_OK;
}",4723.0,4737.0,1.0,53.0,15.0,24,10,24,8,0,10,8,9,6,5,,0,8,10,5,5,int
2980,176933,RM_ZsetRem,1,RM_ZsetRem,"int RM_ZsetRem (RedisModuleKey*,robj*,int*)",module.c,"int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value != NULL && zsetDel(key->value,ele->ptr)) {
        if (deleted) *deleted = 1;
        moduleDelKeyIfEmpty(key);
    } else {
        if (deleted) *deleted = 0;
    }
    return REDISMODULE_OK;
}",4757.0,4767.0,1.0,36.0,11.0,16,8,10,4,0,7,5,6,6,2,,0,6,6,3,3,int
2981,177012,RM_ZsetScore,1,RM_ZsetScore,"int RM_ZsetScore (RedisModuleKey*,robj*,double*)",module.c,"int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
    if (key->value == NULL) return REDISMODULE_ERR;
    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;
    return REDISMODULE_OK;
}",4777.0,4782.0,1.0,38.0,6.0,9,4,6,4,0,4,4,4,4,1,,0,4,6,3,3,int
2982,177148,RM_ZsetRangeEndReached,1,RM_ZsetRangeEndReached,int RM_ZsetRangeEndReached (RedisModuleKey*),module.c,"int RM_ZsetRangeEndReached(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 1;
    return key->u.zset.er;
}",4807.0,4810.0,1.0,43.0,4.0,9,5,3,1,0,3,2,2,2,0,,0,3,2,1,1,int
2983,177179,zsetInitScoreRange,1,zsetInitScoreRange,"int zsetInitScoreRange (RedisModuleKey*,double,double,int,int,int)",module.c,"int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {
    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;

    RM_ZsetRangeStop(key);
    key->u.zset.type = REDISMODULE_ZSET_RANGE_SCORE;
    key->u.zset.er = 0;

    /* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */
    zrangespec *zrs = &key->u.zset.rs;
    zrs->min = min;
    zrs->max = max;
    zrs->minex = minex;
    zrs->maxex = maxex;

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        key->u.zset.current = first ? zzlFirstInRange(key->value->ptr,zrs) :
                                      zzlLastInRange(key->value->ptr,zrs);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = key->value->ptr;
        zskiplist *zsl = zs->zsl;
        key->u.zset.current = first ? zslFirstInRange(zsl,zrs) :
                                      zslLastI...",4818.0,4846.0,1.0,43.0,29.0,47,9,25,8,2,18,4,4,4,3,,0,17,12,6,6,int
2984,177374,RM_ZsetFirstInScoreRange,1,RM_ZsetFirstInScoreRange,"int RM_ZsetFirstInScoreRange (RedisModuleKey*,double,double,int,int)",module.c,"int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
    return zsetInitScoreRange(key,min,max,minex,maxex,1);
}",4863.0,4865.0,1.0,1.0,3.0,0,0,5,5,0,1,1,1,0,1,,0,0,10,5,5,int
2985,177391,RM_ZsetLastInScoreRange,1,RM_ZsetLastInScoreRange,"int RM_ZsetLastInScoreRange (RedisModuleKey*,double,double,int,int)",module.c,"int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
    return zsetInitScoreRange(key,min,max,minex,maxex,0);
}",4869.0,4871.0,1.0,1.0,3.0,0,0,5,5,0,1,1,1,0,1,,0,0,10,5,5,int
2986,177408,zsetInitLexRange,1,zsetInitLexRange,"int zsetInitLexRange (RedisModuleKey*,robj*,robj*,int)",module.c,"int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {
    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;

    RM_ZsetRangeStop(key);
    key->u.zset.er = 0;

    /* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */
    zlexrangespec *zlrs = &key->u.zset.lrs;
    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;

    /* Set the range type to lex only after successfully parsing the range,
     * otherwise we don't want the zlexrangespec to be freed. */
    key->u.zset.type = REDISMODULE_ZSET_RANGE_LEX;

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        key->u.zset.current = first ? zzlFirstInLexRange(key->value->ptr,zlrs) :
                                      zzlLastInLexRange(key->value->ptr,zlrs);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = key->value->ptr;
     ...",4882.0,4911.0,1.0,42.0,30.0,41,10,20,6,2,15,5,5,5,4,,0,14,8,4,4,int
2987,177596,RM_ZsetFirstInLexRange,1,RM_ZsetFirstInLexRange,"int RM_ZsetFirstInLexRange (RedisModuleKey*,robj*,robj*)",module.c,"int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
    return zsetInitLexRange(key,min,max,1);
}",4925.0,4927.0,1.0,48.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
2988,177609,RM_ZsetLastInLexRange,1,RM_ZsetLastInLexRange,"int RM_ZsetLastInLexRange (RedisModuleKey*,robj*,robj*)",module.c,"int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
    return zsetInitLexRange(key,min,max,0);
}",4931.0,4933.0,1.0,47.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
2989,177622,RM_ZsetRangeCurrentElement,1,RM_ZsetRangeCurrentElement,"robj RM_ZsetRangeCurrentElement (RedisModuleKey*,double*)",module.c,"RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {
    RedisModuleString *str;

    if (!key->value || key->value->type != OBJ_ZSET) return NULL;
    if (key->u.zset.current == NULL) return NULL;
    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr, *sptr;
        eptr = key->u.zset.current;
        sds ele = lpGetObject(eptr);
        if (score) {
            sptr = lpNext(key->value->ptr,eptr);
            *score = zzlGetScore(sptr);
        }
        str = createObject(OBJ_STRING,ele);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zskiplistNode *ln = key->u.zset.current;
        if (score) *score = ln->score;
        str = createStringObject(ln->ele,sdslen(ln->ele));
    } else {
        serverPanic(""Unsupported zset encoding"");
    }
    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);
    return str;
}",4938.0,4961.0,1.0,17.0,24.0,25,8,22,7,0,12,5,6,4,5,,0,11,4,2,2,robj
2990,177773,RM_ZsetRangeNext,1,RM_ZsetRangeNext,int RM_ZsetRangeNext (RedisModuleKey*),module.c,"int RM_ZsetRangeNext(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 0;
    if (!key->u.zset.type || !key->u.zset.current) return 0; /* No active iterator. */

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = key->value->ptr;
        unsigned char *eptr = key->u.zset.current;
        unsigned char *next;
        next = lpNext(zl,eptr); /* Skip element. */
        if (next) next = lpNext(zl,next); /* Skip score. */
        if (next == NULL) {
            key->u.zset.er = 1;
            return 0;
        } else {
            /* Are we still within the range? */
            if (key->u.zset.type == REDISMODULE_ZSET_RANGE_SCORE) {
                /* Fetch the next element score for the
                 * range check. */
                unsigned char *saved_next = next;
                next = lpNext(zl,next); /* Skip next element. */
                double score = zzlGetScore(next); /* Obtain the next score. */
       ...",4966.0,5025.0,1.0,43.0,60.0,32,7,19,5,0,10,6,8,5,2,,0,10,2,1,1,int
2991,178133,RM_ZsetRangePrev,1,RM_ZsetRangePrev,int RM_ZsetRangePrev (RedisModuleKey*),module.c,"int RM_ZsetRangePrev(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 0;
    if (!key->u.zset.type || !key->u.zset.current) return 0; /* No active iterator. */

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = key->value->ptr;
        unsigned char *eptr = key->u.zset.current;
        unsigned char *prev;
        prev = lpPrev(zl,eptr); /* Go back to previous score. */
        if (prev) prev = lpPrev(zl,prev); /* Back to previous ele. */
        if (prev == NULL) {
            key->u.zset.er = 1;
            return 0;
        } else {
            /* Are we still within the range? */
            if (key->u.zset.type == REDISMODULE_ZSET_RANGE_SCORE) {
                /* Fetch the previous element score for the
                 * range check. */
                unsigned char *saved_prev = prev;
                prev = lpNext(zl,prev); /* Skip element to get the score.*/
                double score = zzlGetScore(prev)...",5030.0,5089.0,1.0,43.0,60.0,32,7,19,5,0,10,6,8,5,2,,0,10,2,1,1,int
2992,178489,RM_HashSet,1,RM_HashSet,"int RM_HashSet (RedisModuleKey*,int...)",module.c,"int RM_HashSet(RedisModuleKey *key, int flags, ...) {
    va_list ap;
    if (!key || (flags & ~(REDISMODULE_HASH_NX |
                           REDISMODULE_HASH_XX |
                           REDISMODULE_HASH_CFIELDS |
                           REDISMODULE_HASH_COUNT_ALL))) {
        errno = EINVAL;
        return 0;
    } else if (key->value && key->value->type != OBJ_HASH) {
        errno = ENOTSUP;
        return 0;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return 0;
    }
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);

    int count = 0;
    va_start(ap, flags);
    while(1) {
        RedisModuleString *field, *value;
        /* Get the field and value objects. */
        if (flags & REDISMODULE_HASH_CFIELDS) {
            char *cfield = va_arg(ap,char*);
            if (cfield == NULL) break;
            field = createRawStringObject(cfield,strlen(cfield));
        } else {
            field = va_arg(a...",5164.0,5237.0,1.0,27.0,74.0,65,14,58,15,0,15,17,28,1,10,,0,8,4,2,2,int
2993,178811,RM_HashGet,1,RM_HashGet,"int RM_HashGet (RedisModuleKey*,int...)",module.c,"int RM_HashGet(RedisModuleKey *key, int flags, ...) {
    va_list ap;
    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;

    va_start(ap, flags);
    while(1) {
        RedisModuleString *field, **valueptr;
        int *existsptr;
        /* Get the field object and the value pointer to pointer. */
        if (flags & REDISMODULE_HASH_CFIELDS) {
            char *cfield = va_arg(ap,char*);
            if (cfield == NULL) break;
            field = createRawStringObject(cfield,strlen(cfield));
        } else {
            field = va_arg(ap,RedisModuleString*);
            if (field == NULL) break;
        }

        /* Query the hash for existence or value object. */
        if (flags & REDISMODULE_HASH_EXISTS) {
            existsptr = va_arg(ap,int*);
            if (key->value)
                *existsptr = hashTypeExists(key->value,field->ptr);
            else
                *existsptr = 0;
        } else {
            valueptr = va_arg(ap,RedisModuleSt...",5280.0,5326.0,1.0,42.0,47.0,18,8,18,7,0,7,9,15,3,3,,0,6,4,2,2,int
2994,178979,RM_StreamAdd,1,RM_StreamAdd,"int RM_StreamAdd (RedisModuleKey*,int,RedisModuleStreamID*,robj**,long)",module.c,"int RM_StreamAdd(RedisModuleKey *key, int flags, RedisModuleStreamID *id, RedisModuleString **argv, long numfields) {
    /* Validate args */
    if (!key || (numfields != 0 && !argv) || /* invalid key or argv */
        (flags & ~(REDISMODULE_STREAM_ADD_AUTOID)) || /* invalid flags */
        (!(flags & REDISMODULE_STREAM_ADD_AUTOID) && !id)) { /* id required */
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key->value && key->value->type != OBJ_STREAM) {
        errno = ENOTSUP; /* wrong type */
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF; /* key not open for writing */
        return REDISMODULE_ERR;
    } else if (!(flags & REDISMODULE_STREAM_ADD_AUTOID) &&
               id->ms == 0 && id->seq == 0) {
        errno = EDOM; /* ID out of range */
        return REDISMODULE_ERR;
    }

    /* Create key if necessary */
    int created = 0;
    if (key->value == NULL) {
        moduleCreateEmptyKey...",5369.0,5428.0,1.0,74.0,60.0,58,13,45,15,0,16,9,10,4,3,,0,14,10,5,5,int
2995,179248,RM_StreamDelete,1,RM_StreamDelete,"int RM_StreamDelete (RedisModuleKey*,RedisModuleStreamID*)",module.c,"int RM_StreamDelete(RedisModuleKey *key, RedisModuleStreamID *id) {
    if (!key || !id) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP; /* wrong type */
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE) ||
               key->iter != NULL) {
        errno = EBADF; /* key not opened for writing or iterator started */
        return REDISMODULE_ERR;
    }
    stream *s = key->value->ptr;
    streamID streamid = {id->ms, id->seq};
    if (streamDeleteItem(s, &streamid)) {
        return REDISMODULE_OK;
    } else {
        errno = ENOENT; /* no entry with this id */
        return REDISMODULE_ERR;
    }
}",5448.0,5468.0,1.0,15.0,21.0,12,6,11,6,0,4,3,3,1,1,,0,4,4,2,2,int
2996,179357,RM_StreamIteratorStart,1,RM_StreamIteratorStart,"int RM_StreamIteratorStart (RedisModuleKey*,int,RedisModuleStreamID*,RedisModuleStreamID*)",module.c,"int RM_StreamIteratorStart(RedisModuleKey *key, int flags, RedisModuleStreamID *start, RedisModuleStreamID *end) {
    /* check args */
    if (!key ||
        (flags & ~(REDISMODULE_STREAM_ITERATOR_EXCLUSIVE |
                   REDISMODULE_STREAM_ITERATOR_REVERSE))) {
        errno = EINVAL; /* key missing or invalid flags */
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR; /* not a stream */
    } else if (key->iter) {
        errno = EBADF; /* iterator already started */
        return REDISMODULE_ERR;
    }

    /* define range for streamIteratorStart() */
    streamID lower, upper;
    if (start) lower = (streamID){start->ms, start->seq};
    if (end)   upper = (streamID){end->ms,   end->seq};
    if (flags & REDISMODULE_STREAM_ITERATOR_EXCLUSIVE) {
        if ((start && streamIncrID(&lower) != C_OK) ||
            (end   && streamDecrID(&upper) != C_OK)) {
            errno...",5519.0,5556.0,1.0,19.0,38.0,57,17,39,13,0,13,6,7,2,4,,0,12,8,4,4,int
2997,179576,RM_StreamIteratorStop,1,RM_StreamIteratorStop,int RM_StreamIteratorStop (RedisModuleKey*),module.c,"int RM_StreamIteratorStop(RedisModuleKey *key) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }
    streamIteratorStop(key->iter);
    zfree(key->iter);
    key->iter = NULL;
    return REDISMODULE_OK;
}",5570.0,5585.0,1.0,15.0,16.0,6,3,7,4,0,5,2,2,0,2,,0,3,2,1,1,int
2998,179649,RM_StreamIteratorNextID,1,RM_StreamIteratorNextID,"int RM_StreamIteratorNextID (RedisModuleKey*,RedisModuleStreamID*,long*)",module.c,"int RM_StreamIteratorNextID(RedisModuleKey *key, RedisModuleStreamID *id, long *numfields) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    int64_t *num_ptr = &key->u.stream.numfieldsleft;
    streamID *streamid_ptr = &key->u.stream.currentid;
    if (streamIteratorGetID(si, streamid_ptr, num_ptr)) {
        if (id) {
            id->ms = streamid_ptr->ms;
            id->seq = streamid_ptr->seq;
        }
        if (numfields) *numfields = *num_ptr;
        return REDISMODULE_OK;
    } else {
        /* No entry found. */
        key->u.stream.currentid.ms = 0; /* for RM_StreamIteratorDelete() */
        key->u.stream.currentid.seq = 0;
        key->u.stream.numfieldsleft = 0; /* for RM_StreamIteratorNextField...",5612.0,5641.0,1.0,15.0,30.0,23,6,20,8,0,8,5,7,1,1,,0,8,6,3,3,int
2999,179810,RM_StreamIteratorNextField,1,RM_StreamIteratorNextField,"int RM_StreamIteratorNextField (RedisModuleKey*,robj**,robj**)",module.c,"int RM_StreamIteratorNextField(RedisModuleKey *key, RedisModuleString **field_ptr, RedisModuleString **value_ptr) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    } else if (key->u.stream.numfieldsleft <= 0) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    unsigned char *field, *value;
    int64_t field_len, value_len;
    streamIteratorGetField(si, &field, &value, &field_len, &value_len);
    if (field_ptr) {
        *field_ptr = createRawStringObject((char *)field, field_len);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, *field_ptr);
    }
    if (value_ptr) {
        *value_ptr = createRawStringObject((char *)value, value_len);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, *val...",5668.0,5696.0,1.0,52.0,29.0,22,8,23,10,0,9,4,4,0,5,,0,6,6,3,3,int
3000,179960,RM_StreamIteratorDelete,1,RM_StreamIteratorDelete,int RM_StreamIteratorDelete (RedisModuleKey*),module.c,"int RM_StreamIteratorDelete(RedisModuleKey *key) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE) || !key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    } else if (key->u.stream.currentid.ms == 0 &&
               key->u.stream.currentid.seq == 0) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    streamIteratorRemoveEntry(si, &key->u.stream.currentid);
    key->u.stream.currentid.ms = 0; /* Make sure repeated Delete() fails */
    key->u.stream.currentid.seq = 0;
    key->u.stream.numfieldsleft = 0; /* Make sure NextField() fails */
    return REDISMODULE_OK;
}",5711.0,5732.0,1.0,15.0,22.0,22,5,10,4,0,6,2,2,0,1,,0,5,2,1,1,int
3001,180112,RM_StreamTrimByLength,1,RM_StreamTrimByLength,"long long RM_StreamTrimByLength (RedisModuleKey*,int,long long)",module.c,"long long RM_StreamTrimByLength(RedisModuleKey *key, int flags, long long length) {
    if (!key || (flags & ~(REDISMODULE_STREAM_TRIM_APPROX)) || length < 0) {
        errno = EINVAL;
        return -1;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return -1;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return -1;
    }
    int approx = flags & REDISMODULE_STREAM_TRIM_APPROX ? 1 : 0;
    return streamTrimByLength((stream *)key->value->ptr, length, approx);
}",5749.0,5762.0,1.0,27.0,14.0,16,11,10,6,0,2,2,2,0,1,,0,1,6,3,3,long long
3002,180210,RM_StreamTrimByID,1,RM_StreamTrimByID,"long long RM_StreamTrimByID (RedisModuleKey*,int,RedisModuleStreamID*)",module.c,"long long RM_StreamTrimByID(RedisModuleKey *key, int flags, RedisModuleStreamID *id) {
    if (!key || (flags & ~(REDISMODULE_STREAM_TRIM_APPROX)) || !id) {
        errno = EINVAL;
        return -1;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return -1;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return -1;
    }
    int approx = flags & REDISMODULE_STREAM_TRIM_APPROX ? 1 : 0;
    streamID minid = (streamID){id->ms, id->seq};
    return streamTrimByID((stream *)key->value->ptr, minid, approx);
}",5779.0,5793.0,1.0,27.0,15.0,21,11,13,7,0,4,2,2,0,1,,0,3,6,3,3,long long
3003,180385,RM_CallReplyType,1,RM_CallReplyType,int RM_CallReplyType (RedisModuleCallReply*),module.c,"int RM_CallReplyType(RedisModuleCallReply *reply) {
    return callReplyType(reply);
}",5848.0,5850.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
3004,180393,RM_CallReplyLength,1,RM_CallReplyLength,size_t RM_CallReplyLength (RedisModuleCallReply*),module.c,"size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
    return callReplyGetLen(reply);
}",5853.0,5855.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
3005,180401,RM_CallReplyArrayElement,1,RM_CallReplyArrayElement,"RedisModuleCallReply RM_CallReplyArrayElement (RedisModuleCallReply*,size_t)",module.c,"RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {
    return callReplyGetArrayElement(reply, idx);
}",5859.0,5861.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,RedisModuleCallReply
3006,180411,RM_CallReplyInteger,1,RM_CallReplyInteger,long long RM_CallReplyInteger (RedisModuleCallReply*),module.c,"long long RM_CallReplyInteger(RedisModuleCallReply *reply) {
    return callReplyGetLongLong(reply);
}",5864.0,5866.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,long long
3007,180419,RM_CallReplyDouble,1,RM_CallReplyDouble,double RM_CallReplyDouble (RedisModuleCallReply*),module.c,"double RM_CallReplyDouble(RedisModuleCallReply *reply) {
    return callReplyGetDouble(reply);
}",5869.0,5871.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,double
3008,180427,RM_CallReplyBigNumber,1,RM_CallReplyBigNumber,"const char* RM_CallReplyBigNumber (RedisModuleCallReply*,size_t*)",module.c,"const char *RM_CallReplyBigNumber(RedisModuleCallReply *reply, size_t *len) {
    return callReplyGetBigNumber(reply, len);
}",5874.0,5876.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,const char*
3009,180437,RM_CallReplyVerbatim,1,RM_CallReplyVerbatim,"const char* RM_CallReplyVerbatim (RedisModuleCallReply*,size_t*,char**)",module.c,"const char *RM_CallReplyVerbatim(RedisModuleCallReply *reply, size_t *len, const char **format) {
    return callReplyGetVerbatim(reply, len, format);
}",5880.0,5882.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,const char*
3010,180449,RM_CallReplyBool,1,RM_CallReplyBool,int RM_CallReplyBool (RedisModuleCallReply*),module.c,"int RM_CallReplyBool(RedisModuleCallReply *reply) {
    return callReplyGetBool(reply);
}",5885.0,5887.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
3011,180457,RM_CallReplySetElement,1,RM_CallReplySetElement,"RedisModuleCallReply RM_CallReplySetElement (RedisModuleCallReply*,size_t)",module.c,"RedisModuleCallReply *RM_CallReplySetElement(RedisModuleCallReply *reply, size_t idx) {
    return callReplyGetSetElement(reply, idx);
}",5891.0,5893.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,RedisModuleCallReply
3012,180467,RM_CallReplyMapElement,1,RM_CallReplyMapElement,"int RM_CallReplyMapElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)",module.c,"int RM_CallReplyMapElement(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) {
    if (callReplyGetMapElement(reply, idx, key, val) == C_OK){
        return REDISMODULE_OK;
    }
    return REDISMODULE_ERR;
}",5903.0,5908.0,1.0,56.0,6.0,1,1,4,4,0,1,2,2,1,1,,0,1,8,4,4,int
3013,180494,RM_CallReplyAttribute,1,RM_CallReplyAttribute,RedisModuleCallReply RM_CallReplyAttribute (RedisModuleCallReply*),module.c,"RedisModuleCallReply *RM_CallReplyAttribute(RedisModuleCallReply *reply) {
    return callReplyGetAttribute(reply);
}",5911.0,5913.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,RedisModuleCallReply
3014,180502,RM_CallReplyAttributeElement,1,RM_CallReplyAttributeElement,"int RM_CallReplyAttributeElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)",module.c,"int RM_CallReplyAttributeElement(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) {
    if (callReplyGetAttributeElement(reply, idx, key, val) == C_OK){
        return REDISMODULE_OK;
    }
    return REDISMODULE_ERR;
}",5923.0,5928.0,1.0,62.0,6.0,1,1,4,4,0,1,2,2,1,1,,0,1,8,4,4,int
3015,180529,RM_CallReplyPromiseSetUnblockHandler,1,RM_CallReplyPromiseSetUnblockHandler,"void RM_CallReplyPromiseSetUnblockHandler (RedisModuleCallReply*,RedisModuleOnUnblocked,void*)",module.c,"void RM_CallReplyPromiseSetUnblockHandler(RedisModuleCallReply *reply, RedisModuleOnUnblocked on_unblock, void *private_data) {
    RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
    promise->on_unblocked = on_unblock;
    promise->private_data = private_data;
}",5932.0,5936.0,1.0,1.0,5.0,5,2,6,4,0,3,1,1,0,1,,0,3,6,3,3,void
3016,180551,RM_CallReplyPromiseAbort,1,RM_CallReplyPromiseAbort,"int RM_CallReplyPromiseAbort (RedisModuleCallReply*,void**)",module.c,"int RM_CallReplyPromiseAbort(RedisModuleCallReply *reply, void **private_data) {
    RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
    if (!promise->c) return REDISMODULE_ERR; /* Promise can not be aborted, either already aborted or already finished. */
    if (!(promise->c->flags & CLIENT_BLOCKED)) return REDISMODULE_ERR; /* Client is not blocked anymore, can not abort it. */

    /* Client is still blocked, remove it from any blocking state and release it. */
    if (private_data) *private_data = promise->private_data;
    promise->private_data = NULL;
    promise->on_unblocked = NULL;
    unblockClient(promise->c, 0);
    moduleReleaseTempClient(promise->c);
    return REDISMODULE_OK;
}",5949.0,5961.0,1.0,28.0,13.0,17,6,13,4,0,10,4,4,2,3,,0,8,4,2,2,int
3017,180622,RM_CallReplyStringPtr,1,RM_CallReplyStringPtr,"const char* RM_CallReplyStringPtr (RedisModuleCallReply*,size_t*)",module.c,"const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {
    size_t private_len;
    if (!len) len = &private_len;
    return callReplyGetString(reply, len);
}",5964.0,5968.0,1.0,1.0,5.0,3,3,5,3,0,1,2,2,0,1,,0,0,4,2,2,const char*
3018,180641,RM_CreateStringFromCallReply,1,RM_CreateStringFromCallReply,robj RM_CreateStringFromCallReply (RedisModuleCallReply*),module.c,"RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
    RedisModuleCtx* ctx = callReplyGetPrivateData(reply);
    size_t len;
    const char *str;
    switch(callReplyType(reply)) {
        case REDISMODULE_REPLY_STRING:
        case REDISMODULE_REPLY_ERROR:
            str = callReplyGetString(reply, &len);
            return RM_CreateString(ctx, str, len);
        case REDISMODULE_REPLY_INTEGER: {
            char buf[64];
            int len = ll2string(buf,sizeof(buf),callReplyGetLongLong(reply));
            return RM_CreateString(ctx ,buf,len);
            }
        default:
            return NULL;
    }
}",5972.0,5989.0,1.0,17.0,18.0,5,3,17,6,0,7,2,2,1,7,,0,5,2,1,1,robj
3019,180699,RM_SetContextUser,1,RM_SetContextUser,"void RM_SetContextUser (RedisModuleCtx*,RedisModuleUser*)",module.c,"void RM_SetContextUser(RedisModuleCtx *ctx, const RedisModuleUser *user) {
    ctx->user = user;
}",5992.0,5994.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
3020,181178,RM_Call,1,RM_Call,"RedisModuleCallReply RM_Call (RedisModuleCtx*,char*,char*...)",module.c,"RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
    client *c = NULL;
    robj **argv = NULL;
    int argc = 0, flags = 0;
    va_list ap;
    RedisModuleCallReply *reply = NULL;
    int replicate = 0; /* Replicate this command? */
    int error_as_call_replies = 0; /* return errors as RedisModuleCallReply object */
    uint64_t cmd_flags;

    /* Handle arguments. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    replicate = flags & REDISMODULE_ARGV_REPLICATE;
    error_as_call_replies = flags & REDISMODULE_ARGV_CALL_REPLIES_AS_ERRORS;
    va_end(ap);

    c = moduleAllocTempClient();

    if (!(flags & REDISMODULE_ARGV_ALLOW_BLOCK)) {
        /* We do not want to allow block, the module do not expect it */
        c->flags |= CLIENT_DENY_BLOCKING;
    }
    c->db = ctx->client->db;
    c->argv = argv;
    /* We have to assign argv_len, which is equal to argc in that case (RM_Call)
 ...",6206.0,6509.0,1.0,24.0,304.0,291,23,283,44,0,101,65,104,13,51,,0,94,6,3,3,RedisModuleCallReply
3021,182341,RM_CallReplyProto,1,RM_CallReplyProto,"const char* RM_CallReplyProto (RedisModuleCallReply*,size_t*)",module.c,"const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {
    return callReplyGetProto(reply, len);
}",6513.0,6515.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,const char*
3022,182355,moduleTypeEncodeId,1,moduleTypeEncodeId,"uint64_t moduleTypeEncodeId (char*,int)",module.c,"uint64_t moduleTypeEncodeId(const char *name, int encver) {
    /* We use 64 symbols so that we can map each character into 6 bits
     * of the final output. */
    const char *cset = ModuleTypeNameCharSet;
    if (strlen(name) != 9) return 0;
    if (encver < 0 || encver > 1023) return 0;

    uint64_t id = 0;
    for (int j = 0; j < 9; j++) {
        char *p = strchr(cset,name[j]);
        if (!p) return 0;
        unsigned long pos = p-cset;
        id = (id << 6) | pos;
    }
    id = (id << 10) | encver;
    return id;
}",6555.0,6571.0,1.0,1.0,17.0,19,10,23,8,3,1,5,6,0,0,,0,1,4,2,2,uint64_t
3023,182436,moduleTypeLookupModuleByNameInternal,1,moduleTypeLookupModuleByNameInternal,"moduleType moduleTypeLookupModuleByNameInternal (char*,int)",module.c,"moduleType *moduleTypeLookupModuleByNameInternal(const char *name, int ignore_case) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *mt = ln->value;
            if ((!ignore_case && memcmp(name,mt->name,sizeof(mt->name)) == 0)
                || (ignore_case && !strcasecmp(name, mt->name)))
            {
                dictReleaseIterator(di);
                return mt;
            }
        }
    }
    dictReleaseIterator(di);
    return NULL;
}",6576.0,6598.0,1.0,1.0,23.0,20,9,24,10,2,10,4,7,2,7,,0,7,4,2,2,moduleType
3024,182515,moduleTypeLookupModuleByName,1,moduleTypeLookupModuleByName,moduleType moduleTypeLookupModuleByName (char*),module.c,"moduleType *moduleTypeLookupModuleByName(const char *name) {
    return moduleTypeLookupModuleByNameInternal(name, 0);
}",6600.0,6602.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,moduleType
3025,182524,moduleTypeLookupModuleByNameIgnoreCase,1,moduleTypeLookupModuleByNameIgnoreCase,moduleType moduleTypeLookupModuleByNameIgnoreCase (char*),module.c,"moduleType *moduleTypeLookupModuleByNameIgnoreCase(const char *name) {
    return moduleTypeLookupModuleByNameInternal(name, 1);
}",6605.0,6607.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,moduleType
3026,182533,moduleTypeLookupModuleByID,1,moduleTypeLookupModuleByID,moduleType moduleTypeLookupModuleByID (uint64_t),module.c,"moduleType *moduleTypeLookupModuleByID(uint64_t id) {
    static struct {
        uint64_t id;
        moduleType *mt;
    } cache[MODULE_LOOKUP_CACHE_SIZE];

    /* Search in cache to start. */
    int j;
    for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)
        if (cache[j].id == id) return cache[j].mt;

    /* Slow module by module lookup. */
    moduleType *mt = NULL;
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL && mt == NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *this_mt = ln->value;
            /* Compare only the 54 bit module identifier and not the
             * encoding version. */
            if (this_mt->id >> 10 == id >> 10) {
                mt = this_mt;
                break;
            }
        }
    }
    dictReleaseIt...",6614.0,6654.0,1.0,12.0,41.0,32,10,36,12,0,9,7,9,2,6,,0,7,2,1,1,moduleType
3027,182665,moduleTypeNameByID,1,moduleTypeNameByID,"void moduleTypeNameByID (char*,uint64_t)",module.c,"void moduleTypeNameByID(char *name, uint64_t moduleid) {
    const char *cset = ModuleTypeNameCharSet;

    name[9] = '\0';
    char *p = name+8;
    moduleid >>= 10;
    for (int j = 0; j < 9; j++) {
        *p-- = cset[moduleid & 63];
        moduleid >>= 6;
    }
}",6660.0,6670.0,1.0,1.0,11.0,12,7,12,6,0,1,2,2,0,0,,0,1,4,2,2,void
3028,182735,moduleNameFromCommand,1,moduleNameFromCommand,const char* moduleNameFromCommand (redisCommand*),module.c,"const char *moduleNameFromCommand(struct redisCommand *cmd) {
    serverAssert(cmd->proc == RedisModuleCommandDispatcher);

    RedisModuleCommand *cp = cmd->module_cmd;
    return cp->module->name;
}",6679.0,6684.0,1.0,4.0,6.0,10,7,4,2,1,4,1,1,0,1,,0,3,2,1,1,const char*
3029,182770,moduleTypeDupOrReply,1,moduleTypeDupOrReply,"robj moduleTypeDupOrReply (client*,robj*,robj*,int,robj*)",module.c,"robj *moduleTypeDupOrReply(client *c, robj *fromkey, robj *tokey, int todb, robj *value) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;
    if (!mt->copy && !mt->copy2) {
        addReplyError(c, ""not supported for this module key"");
        return NULL;
    }
    void *newval = NULL;
    if (mt->copy2 != NULL) {
        RedisModuleKeyOptCtx ctx = {fromkey, tokey, c->db->id, todb};
        newval = mt->copy2(&ctx, mv->value);
    } else {
        newval = mt->copy(fromkey, tokey, mv->value);
    }
     
    if (!newval) {
        addReplyError(c, ""module key failed to copy"");
        return NULL;
    }
    return createModuleObject(mt, newval);
}",6689.0,6709.0,1.0,1.0,21.0,21,7,26,10,1,6,4,4,0,3,,0,3,10,5,5,robj
3030,182867,RM_CreateDataType,1,RM_CreateDataType,"moduleType RM_CreateDataType (RedisModuleCtx*,char*,int,void*)",module.c,"moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {
    if (!ctx->module->onload)
        return NULL;
    uint64_t id = moduleTypeEncodeId(name,encver);
    if (id == 0) return NULL;
    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;

    long typemethods_version = ((long*)typemethods_ptr)[0];
    if (typemethods_version == 0) return NULL;

    struct typemethods {
        uint64_t version;
        moduleTypeLoadFunc rdb_load;
        moduleTypeSaveFunc rdb_save;
        moduleTypeRewriteFunc aof_rewrite;
        moduleTypeMemUsageFunc mem_usage;
        moduleTypeDigestFunc digest;
        moduleTypeFreeFunc free;
        struct {
            moduleTypeAuxLoadFunc aux_load;
            moduleTypeAuxSaveFunc aux_save;
            int aux_save_triggers;
        } v2;
        struct {
            moduleTypeFreeEffortFunc free_effort;
            moduleTypeUnlinkFunc unlink;
            moduleTypeCopyFunc copy;
      ...",6832.0,6904.0,1.0,1.0,73.0,99,11,68,9,0,7,9,9,2,4,,0,6,8,4,4,moduleType
3031,183142,RM_ModuleTypeSetValue,1,RM_ModuleTypeSetValue,"int RM_ModuleTypeSetValue (RedisModuleKey*,moduleType*,void*)",module.c,"int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
    RM_DeleteKey(key);
    robj *o = createModuleObject(mt,value);
    setKey(key->ctx->client,key->db,key->key,o,SETKEY_NO_SIGNAL);
    decrRefCount(o);
    key->value = o;
    return REDISMODULE_OK;
}",6910.0,6918.0,1.0,22.0,9.0,13,6,13,4,0,10,2,2,2,4,,0,7,6,3,3,int
3032,183204,RM_ModuleTypeGetType,1,RM_ModuleTypeGetType,moduleType RM_ModuleTypeGetType (RedisModuleKey*),module.c,"moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
    if (key == NULL ||
        key->value == NULL ||
        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
    moduleValue *mv = key->value->ptr;
    return mv->type;
}",6925.0,6931.0,1.0,27.0,7.0,10,5,9,3,0,4,2,2,2,1,,0,4,2,1,1,moduleType
3033,183241,RM_ModuleTypeGetValue,1,RM_ModuleTypeGetValue,void* RM_ModuleTypeGetValue (RedisModuleKey*),module.c,"void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
    if (key == NULL ||
        key->value == NULL ||
        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
    moduleValue *mv = key->value->ptr;
    return mv->value;
}",6939.0,6945.0,1.0,27.0,7.0,10,5,9,3,0,4,2,2,2,1,,0,4,2,1,1,void*
3034,183278,moduleRDBLoadError,1,moduleRDBLoadError,void moduleRDBLoadError (RedisModuleIO*),module.c,"void moduleRDBLoadError(RedisModuleIO *io) {
    if (io->type->module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS) {
        io->error = 1;
        return;
    }
    serverPanic(
        ""Error loading data from RDB (short read or EOF). ""
        ""Read performed by module '%s' about type '%s' ""
        ""after reading '%llu' bytes of a value ""
        ""for key named: '%s'."",
        io->type->module->name,
        io->type->name,
        (unsigned long long)io->bytes,
        io->key? (char*)io->key->ptr: ""(null)"");
}",6954.0,6968.0,1.0,36.0,15.0,20,7,7,1,4,8,2,2,1,1,,0,7,2,1,1,void
3035,183341,moduleAllDatatypesHandleErrors,1,moduleAllDatatypesHandleErrors,int moduleAllDatatypesHandleErrors (void),module.c,"int moduleAllDatatypesHandleErrors(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (listLength(module->types) &&
            !(module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS))
        {
            dictReleaseIterator(di);
            return 0;
        }
    }
    dictReleaseIterator(di);
    return 1;
}",6973.0,6988.0,1.0,12.0,16.0,12,7,12,5,1,9,3,4,4,5,,0,7,2,1,1,int
3036,183396,moduleAllModulesHandleReplAsyncLoad,1,moduleAllModulesHandleReplAsyncLoad,int moduleAllModulesHandleReplAsyncLoad (void),module.c,"int moduleAllModulesHandleReplAsyncLoad(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!(module->options & REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD)) {
            dictReleaseIterator(di);
            return 0;
        }
    }
    dictReleaseIterator(di);
    return 1;
}",6993.0,7006.0,1.0,32.0,14.0,8,6,10,5,0,7,3,4,2,5,,0,5,2,1,1,int
3037,183440,RM_IsIOError,1,RM_IsIOError,int RM_IsIOError (RedisModuleIO*),module.c,"int RM_IsIOError(RedisModuleIO *io) {
    return io->error;
}",7011.0,7013.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3038,183449,flushRedisModuleIOBuffer,1,flushRedisModuleIOBuffer,int flushRedisModuleIOBuffer (RedisModuleIO*),module.c,"static int flushRedisModuleIOBuffer(RedisModuleIO *io) {
    if (!io->pre_flush_buffer) return 0;

    /* We have data that must be flushed before saving the current data.
     * Lets flush it. */
    sds pre_flush_buffer = io->pre_flush_buffer;
    io->pre_flush_buffer = NULL;
    ssize_t retval = rdbWriteRaw(io->rio, pre_flush_buffer, sdslen(pre_flush_buffer));
    sdsfree(pre_flush_buffer);
    if (retval >= 0) io->bytes += retval;
    return retval;
}",7015.0,7026.0,1.0,1.0,12.0,11,5,14,4,5,8,3,3,1,3,,0,7,2,1,1,int
3039,183497,RM_SaveUnsigned,1,RM_SaveUnsigned,"void RM_SaveUnsigned (RedisModuleIO*,uint64_t)",module.c,"void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveLen(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7031.0,7046.0,1.0,37.0,16.0,17,5,14,3,1,9,8,5,2,3,,0,9,4,2,2,void
3040,183565,RM_LoadUnsigned,1,RM_LoadUnsigned,uint64_t RM_LoadUnsigned (RedisModuleIO*),module.c,"uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;
    uint64_t value;
    int retval = rdbLoadLenByRef(io->rio, NULL, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",7051.0,7063.0,1.0,18.0,13.0,9,6,12,5,1,6,6,4,1,3,,0,5,2,1,1,uint64_t
3041,183618,RM_SaveSigned,1,RM_SaveSigned,"void RM_SaveSigned (RedisModuleIO*,int64_t)",module.c,"void RM_SaveSigned(RedisModuleIO *io, int64_t value) {
    union {uint64_t u; int64_t i;} conv;
    conv.i = value;
    RM_SaveUnsigned(io,conv.u);
}",7066.0,7070.0,1.0,1.0,5.0,3,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
3042,183635,RM_LoadSigned,1,RM_LoadSigned,int64_t RM_LoadSigned (RedisModuleIO*),module.c,"int64_t RM_LoadSigned(RedisModuleIO *io) {
    union {uint64_t u; int64_t i;} conv;
    conv.u = RM_LoadUnsigned(io);
    return conv.i;
}",7073.0,7077.0,1.0,1.0,5.0,3,2,3,2,0,1,1,1,0,1,,0,1,2,1,1,int64_t
3043,183651,RM_SaveString,1,RM_SaveString,"void RM_SaveString (RedisModuleIO*,robj*)",module.c,"void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveStringObject(io->rio, s);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7085.0,7100.0,1.0,38.0,16.0,17,5,14,3,0,9,8,5,2,3,,0,9,4,2,2,void
3044,183719,RM_SaveStringBuffer,1,RM_SaveStringBuffer,"void RM_SaveStringBuffer (RedisModuleIO*,char*,size_t)",module.c,"void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7104.0,7119.0,1.0,41.0,16.0,18,6,15,4,1,9,8,5,2,3,,0,9,6,3,3,void
3045,183791,moduleLoadString,1,moduleLoadString,"void* moduleLoadString (RedisModuleIO*,int,size_t*)",module.c,"void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
    if (io->error) return NULL;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;
    void *s = rdbGenericLoadStringObject(io->rio,
              plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);
    if (s == NULL) goto loaderr;
    return s;

loaderr:
    moduleRDBLoadError(io);
    return NULL;
}",7122.0,7134.0,1.0,18.0,13.0,9,6,15,6,2,6,6,4,1,3,,0,5,6,3,3,void*
3046,183852,RM_LoadString,1,RM_LoadString,robj RM_LoadString (RedisModuleIO*),module.c,"RedisModuleString *RM_LoadString(RedisModuleIO *io) {
    return moduleLoadString(io,0,NULL);
}",7145.0,7147.0,1.0,17.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,robj
3047,183862,RM_LoadStringBuffer,1,RM_LoadStringBuffer,"char* RM_LoadStringBuffer (RedisModuleIO*,size_t*)",module.c,"char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
    return moduleLoadString(io,1,lenptr);
}",7156.0,7158.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,char*
3048,183873,RM_SaveDouble,1,RM_SaveDouble,"void RM_SaveDouble (RedisModuleIO*,double)",module.c,"void RM_SaveDouble(RedisModuleIO *io, double value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveBinaryDoubleValue(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7163.0,7178.0,1.0,37.0,16.0,17,5,14,3,0,9,8,5,2,3,,0,9,4,2,2,void
3049,183941,RM_LoadDouble,1,RM_LoadDouble,double RM_LoadDouble (RedisModuleIO*),module.c,"double RM_LoadDouble(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;
    double value;
    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",7182.0,7194.0,1.0,18.0,13.0,9,6,11,5,0,6,6,4,1,3,,0,5,2,1,1,double
3050,183993,RM_SaveFloat,1,RM_SaveFloat,"void RM_SaveFloat (RedisModuleIO*,float)",module.c,"void RM_SaveFloat(RedisModuleIO *io, float value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveBinaryFloatValue(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7199.0,7214.0,1.0,37.0,16.0,17,5,14,3,0,9,8,5,2,3,,0,9,4,2,2,void
3051,184061,RM_LoadFloat,1,RM_LoadFloat,float RM_LoadFloat (RedisModuleIO*),module.c,"float RM_LoadFloat(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;
    float value;
    int retval = rdbLoadBinaryFloatValue(io->rio, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",7218.0,7230.0,1.0,18.0,13.0,9,6,11,5,0,6,6,4,1,3,,0,5,2,1,1,float
3052,184113,RM_SaveLongDouble,1,RM_SaveLongDouble,"void RM_SaveLongDouble (RedisModuleIO*,long double)",module.c,"void RM_SaveLongDouble(RedisModuleIO *io, long double value) {
    if (io->error) return;
    char buf[MAX_LONG_DOUBLE_CHARS];
    /* Long double has different number of bits in different platforms, so we
     * save it as a string type. */
    size_t len = ld2string(buf,sizeof(buf),value,LD_STR_HEX);
    RM_SaveStringBuffer(io,buf,len);
}",7235.0,7242.0,1.0,13.0,8.0,3,3,9,5,0,3,2,2,1,2,,0,2,4,2,2,void
3053,184139,RM_LoadLongDouble,1,RM_LoadLongDouble,long double RM_LoadLongDouble (RedisModuleIO*),module.c,"long double RM_LoadLongDouble(RedisModuleIO *io) {
    if (io->error) return 0;
    long double value;
    size_t len;
    char* str = RM_LoadStringBuffer(io,&len);
    if (!str) return 0;
    string2ld(str,len,&value);
    RM_Free(str);
    return value;
}",7246.0,7255.0,1.0,1.0,10.0,5,4,10,4,0,4,3,3,1,3,,0,2,2,1,1,long double
3054,184175,rdbSaveModulesAux,1,rdbSaveModulesAux,"ssize_t rdbSaveModulesAux (rio*,int)",module.c,"ssize_t rdbSaveModulesAux(rio *rdb, int when) {
    size_t total_written = 0;
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *mt = ln->value;
            if ((!mt->aux_save && !mt->aux_save2) || !(mt->aux_save_triggers & when))
                continue;
            ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
            if (ret==-1) {
                dictReleaseIterator(di);
                return -1;
            }
            total_written += ret;
        }
    }

    dictReleaseIterator(di);
    return total_written;
}",7259.0,7285.0,1.0,1.0,27.0,25,11,28,12,2,11,6,10,2,8,,0,8,4,2,2,ssize_t
3055,184269,RM_DigestAddStringBuffer,1,RM_DigestAddStringBuffer,"void RM_DigestAddStringBuffer (RedisModuleDigest*,char*,size_t)",module.c,"void RM_DigestAddStringBuffer(RedisModuleDigest *md, const char *ele, size_t len) {
    mixDigest(md->o,ele,len);
}",7329.0,7331.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,1,,0,1,6,3,3,void
3056,184282,RM_DigestAddLongLong,1,RM_DigestAddLongLong,"void RM_DigestAddLongLong (RedisModuleDigest*,long long)",module.c,"void RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {
    char buf[LONG_STR_SIZE];
    size_t len = ll2string(buf,sizeof(buf),ll);
    mixDigest(md->o,buf,len);
}",7335.0,7339.0,1.0,13.0,5.0,3,3,7,4,0,3,1,1,0,2,,0,2,4,2,2,void
3057,184303,RM_DigestEndSequence,1,RM_DigestEndSequence,void RM_DigestEndSequence (RedisModuleDigest*),module.c,"void RM_DigestEndSequence(RedisModuleDigest *md) {
    xorDigest(md->x,md->o,sizeof(md->o));
    memset(md->o,0,sizeof(md->o));
}",7342.0,7345.0,1.0,1.0,4.0,7,2,5,1,0,6,1,1,0,1,,0,5,2,1,1,void
3058,184328,RM_LoadDataTypeFromStringEncver,1,RM_LoadDataTypeFromStringEncver,"void* RM_LoadDataTypeFromStringEncver (robj*,moduleType*,int)",module.c,"void *RM_LoadDataTypeFromStringEncver(const RedisModuleString *str, const moduleType *mt, int encver) {
    rio payload;
    RedisModuleIO io;
    void *ret;

    rioInitWithBuffer(&payload, str->ptr);
    moduleInitIOContext(io,(moduleType *)mt,&payload,NULL,-1);

    /* All RM_Save*() calls always write a version 2 compatible format, so we
     * need to make sure we read the same.
     */
    ret = mt->rdb_load(&io,encver);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    return ret;
}",7361.0,7378.0,1.0,44.0,18.0,29,6,26,7,1,14,2,2,1,3,,0,11,6,3,3,void*
3059,184423,RM_LoadDataTypeFromString,1,RM_LoadDataTypeFromString,"void* RM_LoadDataTypeFromString (robj*,moduleType*)",module.c,"void *RM_LoadDataTypeFromString(const RedisModuleString *str, const moduleType *mt) {
    return RM_LoadDataTypeFromStringEncver(str, mt, 0);
}",7383.0,7385.0,1.0,38.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void*
3060,184434,RM_SaveDataTypeToString,1,RM_SaveDataTypeToString,"robj RM_SaveDataTypeToString (RedisModuleCtx*,void*,moduleType*)",module.c,"RedisModuleString *RM_SaveDataTypeToString(RedisModuleCtx *ctx, void *data, const moduleType *mt) {
    rio payload;
    RedisModuleIO io;

    rioInitWithBuffer(&payload,sdsempty());
    moduleInitIOContext(io,(moduleType *)mt,&payload,NULL,-1);
    mt->rdb_save(&io,data);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    if (io.error) {
        return NULL;
    } else {
        robj *str = createObject(OBJ_STRING,payload.io.buffer.ptr);
        if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,str);
        return str;
    }
}",7394.0,7412.0,1.0,17.0,19.0,28,6,25,5,0,16,3,3,2,4,,0,13,6,3,3,robj
3061,184558,RM_GetKeyNameFromDigest,1,RM_GetKeyNameFromDigest,robj RM_GetKeyNameFromDigest (RedisModuleDigest*),module.c,"const RedisModuleString *RM_GetKeyNameFromDigest(RedisModuleDigest *dig) {
    return dig->key;
}",7415.0,7417.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
3062,184567,RM_GetDbIdFromDigest,1,RM_GetDbIdFromDigest,int RM_GetDbIdFromDigest (RedisModuleDigest*),module.c,"int RM_GetDbIdFromDigest(RedisModuleDigest *dig) {
    return dig->dbid;
}",7420.0,7422.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3063,184576,RM_EmitAOF,1,RM_EmitAOF,"void RM_EmitAOF (RedisModuleIO*,char*,char*...)",module.c,"void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
    if (io->error) return;
    struct redisCommand *cmd;
    robj **argv = NULL;
    int argc = 0, flags = 0, j;
    va_list ap;

    cmd = lookupCommandByCString((char*)cmdname);
    if (!cmd) {
        serverLog(LL_WARNING,
            ""Fatal: AOF method for module data type '%s' tried to ""
            ""emit unknown command '%s'"",
            io->type->name, cmdname);
        io->error = 1;
        errno = EINVAL;
        return;
    }

    /* Emit the arguments into the AOF in Redis protocol format. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    va_end(ap);
    if (argv == NULL) {
        serverLog(LL_WARNING,
            ""Fatal: AOF method for module data type '%s' tried to ""
            ""call RedisModule_EmitAOF() with wrong format specifiers '%s'"",
            io->type->name, fmt);
        io->error = 1;
        errno = EINVAL;
        return;
...",7432.0,7476.0,1.0,8.0,45.0,45,11,46,13,0,19,7,8,7,8,,0,15,6,3,3,void
3064,184759,RM_GetContextFromIO,1,RM_GetContextFromIO,RedisModuleCtx RM_GetContextFromIO (RedisModuleIO*),module.c,"RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
    if (io->ctx) return io->ctx; /* Can't have more than one... */
    io->ctx = zmalloc(sizeof(RedisModuleCtx));
    moduleCreateContext(io->ctx, io->type->module, REDISMODULE_CTX_NONE);
    return io->ctx;
}",7482.0,7487.0,1.0,51.0,6.0,9,3,7,2,0,8,2,2,1,2,,0,7,2,1,1,RedisModuleCtx
3065,184796,RM_GetKeyNameFromIO,1,RM_GetKeyNameFromIO,robj RM_GetKeyNameFromIO (RedisModuleIO*),module.c,"const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
    return io->key;
}",7492.0,7494.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
3066,184805,RM_GetKeyNameFromModuleKey,1,RM_GetKeyNameFromModuleKey,robj RM_GetKeyNameFromModuleKey (RedisModuleKey*),module.c,"const RedisModuleString *RM_GetKeyNameFromModuleKey(RedisModuleKey *key) {
    return key ? key->key : NULL;
}",7497.0,7499.0,1.0,6.0,3.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,robj
3067,184817,RM_GetDbIdFromModuleKey,1,RM_GetDbIdFromModuleKey,int RM_GetDbIdFromModuleKey (RedisModuleKey*),module.c,"int RM_GetDbIdFromModuleKey(RedisModuleKey *key) {
    return key ? key->db->id : -1;
}",7502.0,7504.0,1.0,1.0,3.0,4,3,2,1,0,1,1,1,0,0,,0,1,2,1,1,int
3068,184832,RM_GetDbIdFromIO,1,RM_GetDbIdFromIO,int RM_GetDbIdFromIO (RedisModuleIO*),module.c,"int RM_GetDbIdFromIO(RedisModuleIO *io) {
    return io->dbid;
}",7509.0,7511.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3069,184841,moduleLogRaw,1,moduleLogRaw,"void moduleLogRaw (RedisModule*,char*,char*,va_list)",module.c,"void moduleLogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {
    char msg[LOG_MAX_LEN];
    size_t name_len;
    int level;

    if (!strcasecmp(levelstr,""debug"")) level = LL_DEBUG;
    else if (!strcasecmp(levelstr,""verbose"")) level = LL_VERBOSE;
    else if (!strcasecmp(levelstr,""notice"")) level = LL_NOTICE;
    else if (!strcasecmp(levelstr,""warning"")) level = LL_WARNING;
    else level = LL_VERBOSE; /* Default. */

    if (level < server.verbosity) return;

    name_len = snprintf(msg, sizeof(msg),""<%s> "", module? module->name: ""module"");
    vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);
    serverLogRaw(level,msg);
}",7523.0,7539.0,1.0,13.0,17.0,11,9,17,8,2,2,3,3,0,1,,0,1,8,4,4,void
3070,184943,RM_Log,1,RM_Log,"void RM_Log (RedisModuleCtx*,char*,char*...)",module.c,"void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    moduleLogRaw(ctx? ctx->module: NULL,levelstr,fmt,ap);
    va_end(ap);
}",7559.0,7564.0,1.0,1.0,6.0,2,2,9,5,0,2,1,1,0,1,,0,1,6,3,3,void
3071,184966,RM_LogIOError,1,RM_LogIOError,"void RM_LogIOError (RedisModuleIO*,char*,char*...)",module.c,"void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    moduleLogRaw(io->type->module,levelstr,fmt,ap);
    va_end(ap);
}",7571.0,7576.0,1.0,1.0,6.0,2,1,7,4,0,2,1,1,0,1,,0,1,6,3,3,void
3072,184988,RM__Assert,1,RM__Assert,"void RM__Assert (char*,char*,int)",module.c,"void RM__Assert(const char *estr, const char *file, int line) {
    _serverAssert(estr, file, line);
}",7586.0,7588.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
3073,184999,RM_LatencyAddSample,1,RM_LatencyAddSample,"void RM_LatencyAddSample (char*,mstime_t)",module.c,"void RM_LatencyAddSample(const char *event, mstime_t latency) {
    if (latency >= server.latency_monitor_threshold)
        latencyAddSample(event, latency);
}",7593.0,7596.0,1.0,1.0,4.0,2,2,4,3,0,1,2,2,0,1,,0,0,4,2,2,void
3074,185015,unblockClientFromModule,1,unblockClientFromModule,void unblockClientFromModule (client*),module.c,"void unblockClientFromModule(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Call the disconnection callback if any. Note that
     * bc->disconnect_callback is set to NULL if the client gets disconnected
     * by the module itself or because of a timeout, so the callback will NOT
     * get called if this is not an actual disconnection event. */
    if (bc->disconnect_callback) {
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_NONE);
        ctx.blocked_privdata = bc->privdata;
        ctx.client = bc->client;
        bc->disconnect_callback(&ctx,bc);
        moduleFreeContext(&ctx);
    }

    /* If we made it here and client is still blocked it means that the command
     * timed-out, client was killed or disconnected and disconnect_callback was
     * not implemented (or it was, but RM_UnblockClient was not called from
     * within it, as it should).
     * We must call moduleUnblockClient in or...",7617.0,7652.0,1.0,46.0,36.0,21,6,18,4,0,14,3,3,3,3,,0,11,2,1,1,void
3075,185084,moduleBlockClient,1,moduleBlockClient,"RedisModuleBlockedClient moduleBlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleAuthCallback,RedisModuleCmdFunc,void,long long,robj**,int,void*,int)",module.c,"RedisModuleBlockedClient *moduleBlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                            RedisModuleAuthCallback auth_reply_callback,
                                            RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                            long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata,
                                            int flags) {
    client *c = ctx->client;
    int islua = scriptIsRunning();
    int ismulti = server.in_exec;

    c->bstate.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    ctx->module->blocked_clients++;

    /* We need to handle the invalid operation of calling modules blocking
     * commands from Lua or MULTI. We actually create an already aborted
     * (client set to NULL) blocked client handle, and actually reply ...",7674.0,7739.0,1.0,66.0,66.0,75,11,62,17,4,34,5,6,1,7,,0,32,20,10,10,RedisModuleBlockedClient
3076,185378,RM_RegisterAuthCallback,1,RM_RegisterAuthCallback,"void RM_RegisterAuthCallback (RedisModuleCtx*,RedisModuleAuthCallback)",module.c,"void RM_RegisterAuthCallback(RedisModuleCtx *ctx, RedisModuleAuthCallback cb) {
    RedisModuleAuthCtx *auth_ctx = zmalloc(sizeof(RedisModuleAuthCtx));
    auth_ctx->module = ctx->module;
    auth_ctx->auth_cb = cb;
    listAddNodeHead(moduleAuthCallbacks, auth_ctx);
}",7794.0,7799.0,1.0,1.0,6.0,7,3,8,5,0,6,1,1,0,2,,0,5,4,2,2,void
3077,185405,moduleInvokeFreePrivDataCallback,1,moduleInvokeFreePrivDataCallback,"void moduleInvokeFreePrivDataCallback (client*,RedisModuleBlockedClient*)",module.c,"void moduleInvokeFreePrivDataCallback(client *c, RedisModuleBlockedClient *bc) {
    if (bc->privdata && bc->free_privdata) {
        RedisModuleCtx ctx;
        int ctx_flags = c == NULL ? REDISMODULE_CTX_BLOCKED_DISCONNECTED : REDISMODULE_CTX_NONE;
        moduleCreateContext(&ctx, bc->module, ctx_flags);
        ctx.blocked_privdata = bc->privdata;
        ctx.client = bc->client;
        bc->free_privdata(&ctx,bc->privdata);
        moduleFreeContext(&ctx);
    }
}",7802.0,7812.0,1.0,36.0,11.0,19,8,16,5,1,10,2,2,1,3,,0,7,4,2,2,void
3078,185469,moduleUnregisterAuthCBs,1,moduleUnregisterAuthCBs,void moduleUnregisterAuthCBs (RedisModule*),module.c,"void moduleUnregisterAuthCBs(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(moduleAuthCallbacks, &li);
    while ((ln = listNext(&li))) {
        RedisModuleAuthCtx *ctx = listNodeValue(ln);
        if (ctx->module == module) {
            listDelNode(moduleAuthCallbacks, ln);
            zfree(ctx);
        }
    }
}",7815.0,7826.0,1.0,34.0,12.0,7,4,12,5,3,8,3,4,2,4,,0,5,2,1,1,void
3079,185508,attemptNextAuthCb,1,attemptNextAuthCb,"int attemptNextAuthCb (client*,robj*,robj*,robj**)",module.c,"int attemptNextAuthCb(client *c, robj *username, robj *password, robj **err) {
    int handle_next_callback = c->module_auth_ctx == NULL;
    RedisModuleAuthCtx *cur_auth_ctx = NULL;
    listNode *ln;
    listIter li;
    listRewind(moduleAuthCallbacks, &li);
    int result = REDISMODULE_AUTH_NOT_HANDLED;
    while((ln = listNext(&li))) {
        cur_auth_ctx = listNodeValue(ln);
        /* Skip over the previously attempted auth contexts. */
        if (!handle_next_callback) {
            handle_next_callback = cur_auth_ctx == c->module_auth_ctx;
            continue;
        }
        /* Remove the module auth complete flag before we attempt the next cb. */
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, cur_auth_ctx->module, REDISMODULE_CTX_NONE);
        ctx.client = c;
        *err = NULL;
        c->module_auth_ctx = cur_auth_ctx;
        result = cur_auth_ctx->auth_cb(&ctx, username, password, err);
        mo...",7830.0,7857.0,1.0,17.0,28.0,30,9,35,12,1,13,6,6,1,4,,0,10,8,4,4,int
3080,185625,attemptBlockedAuthReplyCallback,1,attemptBlockedAuthReplyCallback,"int attemptBlockedAuthReplyCallback (client*,robj*,robj*,robj**)",module.c,"int attemptBlockedAuthReplyCallback(client *c, robj *username, robj *password, robj **err) {
    int result = REDISMODULE_AUTH_NOT_HANDLED;
    if (!c->module_blocked_client) return result;
    RedisModuleBlockedClient *bc = (RedisModuleBlockedClient *) c->module_blocked_client;
    bc->client = c;
    if (bc->auth_reply_cb) {
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_REPLY);
        ctx.blocked_privdata = bc->privdata;
        ctx.blocked_ready_key = NULL;
        ctx.client = bc->client;
        ctx.blocked_client = bc;
        result = bc->auth_reply_cb(&ctx, username, password, err);
        moduleFreeContext(&ctx);
    }
    moduleInvokeFreePrivDataCallback(c, bc);
    c->module_blocked_client = NULL;
    c->lastcmd->microseconds += bc->background_duration;
    bc->module->blocked_clients--;
    zfree(bc);
    return result;
}",7864.0,7885.0,1.0,17.0,22.0,35,9,34,8,1,20,3,3,2,4,,0,16,8,4,4,int
3081,185742,checkModuleAuthentication,1,checkModuleAuthentication,"int checkModuleAuthentication (client*,robj*,robj*,robj**)",module.c,"int checkModuleAuthentication(client *c, robj *username, robj *password, robj **err) {
    if (!listLength(moduleAuthCallbacks)) return AUTH_NOT_HANDLED;
    int result = attemptBlockedAuthReplyCallback(c, username, password, err);
    if (result == REDISMODULE_AUTH_NOT_HANDLED) {
        result = attemptNextAuthCb(c, username, password, err);
    }
    if (c->flags & CLIENT_BLOCKED) {
        /* Modules are expected to return REDISMODULE_AUTH_HANDLED when blocking clients. */
        serverAssert(result == REDISMODULE_AUTH_HANDLED);
        return AUTH_BLOCKED;
    }
    c->module_auth_ctx = NULL;
    if (result == REDISMODULE_AUTH_NOT_HANDLED) {
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        return AUTH_NOT_HANDLED;
    }
    if (c->flags & CLIENT_MODULE_AUTH_HAS_RESULT) {
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        if (c->authenticated) return AUTH_OK;
    }
    return AUTH_ERR;
}",7897.0,7918.0,1.0,9.0,22.0,26,11,27,11,1,12,7,8,6,3,,0,11,8,4,4,int
3082,185866,moduleTryServeClientBlockedOnKey,1,moduleTryServeClientBlockedOnKey,"int moduleTryServeClientBlockedOnKey (client*,robj*)",module.c,"int moduleTryServeClientBlockedOnKey(client *c, robj *key) {
    int served = 0;
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Protect against re-processing: don't serve clients that are already
     * in the unblocking list for any reason (including RM_UnblockClient()
     * explicit call). See #6798. */
    if (bc->unblocked) return 0;

    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_REPLY);
    ctx.blocked_ready_key = key;
    ctx.blocked_privdata = bc->privdata;
    ctx.client = bc->client;
    ctx.blocked_client = bc;
    if (bc->reply_callback(&ctx,(void**)c->argv,c->argc) == REDISMODULE_OK)
        served = 1;
    moduleFreeContext(&ctx);
    return served;
}",7927.0,7946.0,1.0,42.0,20.0,26,7,21,5,0,14,3,3,4,2,,0,12,4,2,2,int
3083,185955,RM_BlockClient,1,RM_BlockClient,"RedisModuleBlockedClient RM_BlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long)",module.c,"RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                         RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                         long long timeout_ms) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, NULL,0,NULL,0);
}",7987.0,7991.0,1.0,1.0,5.0,0,0,8,6,0,1,1,1,0,1,,0,0,10,5,5,RedisModuleBlockedClient
3084,185976,RM_BlockClientOnAuth,1,RM_BlockClientOnAuth,"RedisModuleBlockedClient RM_BlockClientOnAuth (RedisModuleCtx*,RedisModuleAuthCallback,void)",module.c,"RedisModuleBlockedClient *RM_BlockClientOnAuth(RedisModuleCtx *ctx, RedisModuleAuthCallback reply_callback,
                                               void (*free_privdata)(RedisModuleCtx*,void*)) {
    if (!clientHasModuleAuthInProgress(ctx->client)) {
        addReplyError(ctx->client, ""Module blocking client on auth when not currently undergoing module authentication"");
        return NULL;
    }
    RedisModuleBlockedClient *bc = moduleBlockClient(ctx,NULL,reply_callback,NULL,free_privdata,0, NULL,0,NULL,0);
    if (ctx->client->flags & CLIENT_BLOCKED) {
        ctx->client->flags |= CLIENT_PENDING_COMMAND;
    }
    return bc;
}",7997.0,8008.0,1.0,9.0,12.0,14,6,16,5,0,7,3,3,3,2,,0,6,6,3,3,RedisModuleBlockedClient
3085,186045,RM_BlockClientGetPrivateData,1,RM_BlockClientGetPrivateData,void* RM_BlockClientGetPrivateData (RedisModuleBlockedClient*),module.c,"void *RM_BlockClientGetPrivateData(RedisModuleBlockedClient *blocked_client) {
    return blocked_client->privdata;
}",8011.0,8013.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void*
3086,186054,RM_BlockClientSetPrivateData,1,RM_BlockClientSetPrivateData,"void RM_BlockClientSetPrivateData (RedisModuleBlockedClient*,void*)",module.c,"void RM_BlockClientSetPrivateData(RedisModuleBlockedClient *blocked_client, void *private_data) {
    blocked_client->privdata = private_data;
}",8016.0,8018.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
3087,186065,RM_BlockClientOnKeys,1,RM_BlockClientOnKeys,"RedisModuleBlockedClient RM_BlockClientOnKeys (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,robj**,int,void*)",module.c,"RedisModuleBlockedClient *RM_BlockClientOnKeys(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                               RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                               long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, keys,numkeys,privdata,0);
}",8078.0,8082.0,1.0,69.0,5.0,0,0,9,9,0,1,1,1,0,1,,0,0,16,8,8,RedisModuleBlockedClient
3088,186089,RM_BlockClientOnKeysWithFlags,1,RM_BlockClientOnKeysWithFlags,"RedisModuleBlockedClient RM_BlockClientOnKeysWithFlags (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,robj**,int,void*,int)",module.c,"RedisModuleBlockedClient *RM_BlockClientOnKeysWithFlags(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                                        RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                                        long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata,
                                                        int flags) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, keys,numkeys,privdata,flags);
}",8093.0,8098.0,1.0,78.0,6.0,0,0,10,10,0,1,1,1,0,1,,0,0,18,9,9,RedisModuleBlockedClient
3089,186114,RM_SignalKeyAsReady,1,RM_SignalKeyAsReady,"void RM_SignalKeyAsReady (RedisModuleCtx*,robj*)",module.c,"void RM_SignalKeyAsReady(RedisModuleCtx *ctx, RedisModuleString *key) {
    signalKeyAsReady(ctx->client->db, key, OBJ_MODULE);
}",8103.0,8105.0,1.0,46.0,3.0,2,1,2,2,0,2,1,1,0,1,,0,1,4,2,2,void
3090,186130,moduleUnblockClientByHandle,1,moduleUnblockClientByHandle,"int moduleUnblockClientByHandle (RedisModuleBlockedClient*,void*)",module.c,"int moduleUnblockClientByHandle(RedisModuleBlockedClient *bc, void *privdata) {
    pthread_mutex_lock(&moduleUnblockedClientsMutex);
    if (!bc->blocked_on_keys) bc->privdata = privdata;
    bc->unblocked = 1;
    if (listLength(moduleUnblockedClients) == 0) {
        if (write(server.module_pipe[1],""A"",1) != 1) {
            /* Ignore the error, this is best-effort. */
        }
    }
    listAddNodeTail(moduleUnblockedClients,bc);
    pthread_mutex_unlock(&moduleUnblockedClientsMutex);
    return REDISMODULE_OK;
}",8108.0,8120.0,1.0,8.0,13.0,13,8,11,5,2,10,4,5,4,1,,0,9,4,2,2,int
3091,186187,moduleUnblockClient,1,moduleUnblockClient,void moduleUnblockClient (client*),module.c,"void moduleUnblockClient(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    moduleUnblockClientByHandle(bc,NULL);
}",8124.0,8127.0,1.0,1.0,4.0,3,3,4,3,1,2,1,1,0,1,,0,1,2,1,1,void
3092,186203,moduleClientIsBlockedOnKeys,1,moduleClientIsBlockedOnKeys,int moduleClientIsBlockedOnKeys (client*),module.c,"int moduleClientIsBlockedOnKeys(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    return bc->blocked_on_keys;
}",8131.0,8134.0,1.0,1.0,4.0,4,3,3,2,1,2,1,1,0,0,,0,2,2,1,1,int
3093,186220,RM_UnblockClient,1,RM_UnblockClient,"int RM_UnblockClient (RedisModuleBlockedClient*,void*)",module.c,"int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
    if (bc->blocked_on_keys) {
        /* In theory the user should always pass the timeout handler as an
         * argument, but better to be safe than sorry. */
        if (bc->timeout_callback == NULL) return REDISMODULE_ERR;
        if (bc->unblocked) return REDISMODULE_OK;
        if (bc->client) moduleBlockedClientTimedOut(bc->client);
    }
    moduleUnblockClientByHandle(bc,privdata);
    return REDISMODULE_OK;
}",8155.0,8165.0,1.0,49.0,11.0,6,2,8,3,1,7,5,8,4,2,,0,5,4,2,2,int
3094,186267,RM_AbortBlock,1,RM_AbortBlock,int RM_AbortBlock (RedisModuleBlockedClient*),module.c,"int RM_AbortBlock(RedisModuleBlockedClient *bc) {
    bc->reply_callback = NULL;
    bc->disconnect_callback = NULL;
    bc->auth_reply_cb = NULL;
    return RM_UnblockClient(bc,NULL);
}",8169.0,8174.0,1.0,1.0,6.0,6,2,8,2,0,4,1,1,0,1,,0,3,2,1,1,int
3095,186291,RM_SetDisconnectCallback,1,RM_SetDisconnectCallback,"void RM_SetDisconnectCallback (RedisModuleBlockedClient*,RedisModuleDisconnectFunc)",module.c,"void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {
    bc->disconnect_callback = callback;
}",8192.0,8194.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
3096,186302,moduleHandleBlockedClients,1,moduleHandleBlockedClients,void moduleHandleBlockedClients (void),module.c,"void moduleHandleBlockedClients(void) {
    listNode *ln;
    RedisModuleBlockedClient *bc;

    pthread_mutex_lock(&moduleUnblockedClientsMutex);
    while (listLength(moduleUnblockedClients)) {
        ln = listFirst(moduleUnblockedClients);
        bc = ln->value;
        client *c = bc->client;
        listDelNode(moduleUnblockedClients,ln);
        pthread_mutex_unlock(&moduleUnblockedClientsMutex);

        /* Release the lock during the loop, as long as we don't
         * touch the shared list. */

        /* Call the reply callback if the client is valid and we have
         * any callback. However the callback is not called if the client
         * was blocked on keys (RM_BlockClientOnKeys()), because we already
         * called such callback in moduleTryServeClientBlockedOnKey() when
         * the key was signaled as ready. */
        long long prev_error_replies = server.stat_total_error_replies;
        uint64_t reply_us = 0;
        if (c && !bc->blocked_on_keys && b...",8204.0,8298.0,1.0,11.0,95.0,85,11,81,11,1,54,9,17,12,13,,0,43,2,1,1,void
3097,186584,moduleBlockedClientMayTimeout,1,moduleBlockedClientMayTimeout,int moduleBlockedClientMayTimeout (client*),module.c,"int moduleBlockedClientMayTimeout(client *c) {
    if (c->bstate.btype != BLOCKED_MODULE)
        return 1;

    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    return (bc && bc->timeout_callback != NULL);
}",8303.0,8309.0,1.0,1.0,7.0,9,5,7,4,0,3,2,2,1,0,,0,3,2,1,1,int
3098,186616,moduleBlockedClientTimedOut,1,moduleBlockedClientTimedOut,void moduleBlockedClientTimedOut (client*),module.c,"void moduleBlockedClientTimedOut(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Protect against re-processing: don't serve clients that are already
     * in the unblocking list for any reason (including RM_UnblockClient()
     * explicit call). See #6798. */
    if (bc->unblocked) return;

    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_TIMEOUT);
    ctx.client = bc->client;
    ctx.blocked_client = bc;
    ctx.blocked_privdata = bc->privdata;
    long long prev_error_replies = server.stat_total_error_replies;
    bc->timeout_callback(&ctx,(void**)c->argv,c->argc);
    moduleFreeContext(&ctx);
    updateStatsOnUnblock(c, bc->background_duration, 0, server.stat_total_error_replies != prev_error_replies);

    /* For timeout events, we do not want to call the disconnect callback,
     * because the blocked client will be automatically disconnected in
     * this case, and the user can still hook using...",8315.0,8337.0,1.0,42.0,23.0,28,7,24,6,1,16,2,2,1,3,,0,13,2,1,1,void
3099,186705,RM_IsBlockedReplyRequest,1,RM_IsBlockedReplyRequest,int RM_IsBlockedReplyRequest (RedisModuleCtx*),module.c,"int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;
}",8341.0,8343.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3100,186722,RM_IsBlockedTimeoutRequest,1,RM_IsBlockedTimeoutRequest,int RM_IsBlockedTimeoutRequest (RedisModuleCtx*),module.c,"int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;
}",8347.0,8349.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3101,186739,RM_GetBlockedClientPrivateData,1,RM_GetBlockedClientPrivateData,void* RM_GetBlockedClientPrivateData (RedisModuleCtx*),module.c,"void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
    return ctx->blocked_privdata;
}",8352.0,8354.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void*
3102,186748,RM_GetBlockedClientReadyKey,1,RM_GetBlockedClientReadyKey,robj RM_GetBlockedClientReadyKey (RedisModuleCtx*),module.c,"RedisModuleString *RM_GetBlockedClientReadyKey(RedisModuleCtx *ctx) {
    return ctx->blocked_ready_key;
}",8358.0,8360.0,1.0,17.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
3103,186757,RM_GetBlockedClientHandle,1,RM_GetBlockedClientHandle,RedisModuleBlockedClient RM_GetBlockedClientHandle (RedisModuleCtx*),module.c,"RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
    return ctx->blocked_client;
}",8366.0,8368.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,RedisModuleBlockedClient
3104,186766,RM_BlockedClientDisconnected,1,RM_BlockedClientDisconnected,int RM_BlockedClientDisconnected (RedisModuleCtx*),module.c,"int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;
}",8373.0,8375.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3105,186783,RM_GetThreadSafeContext,1,RM_GetThreadSafeContext,RedisModuleCtx RM_GetThreadSafeContext (RedisModuleBlockedClient*),module.c,"RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
    RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));
    RedisModule *module = bc ? bc->module : NULL;
    int flags = REDISMODULE_CTX_THREAD_SAFE;

    /* Creating a new client object is costly. To avoid that, we have an
     * internal pool of client objects. In blockClient(), a client object is
     * assigned to bc->thread_safe_ctx_client to be used for the thread safe
     * context.
     * For detached thread safe contexts, we create a new client object.
     * Otherwise, as this function can be called from different threads, we
     * would need to synchronize access to internal pool of client objects.
     * Assuming creating detached context is rare and not that performance
     * critical, we avoid synchronizing access to the client pool by creating
     * a new client */
    if (!bc) flags |= REDISMODULE_CTX_NEW_CLIENT;
    moduleCreateContext(ctx, module, flags);
    /* Even when the context is associate...",8401.0,8432.0,1.0,16.0,32.0,28,7,25,5,0,14,4,5,1,3,,0,12,2,1,1,RedisModuleCtx
3106,186878,RM_GetDetachedThreadSafeContext,1,RM_GetDetachedThreadSafeContext,RedisModuleCtx RM_GetDetachedThreadSafeContext (RedisModuleCtx*),module.c,"RedisModuleCtx *RM_GetDetachedThreadSafeContext(RedisModuleCtx *ctx) {
    RedisModuleCtx *new_ctx = zmalloc(sizeof(*new_ctx));
    /* We create a new client object for the detached context.
     * See RM_GetThreadSafeContext() for more information */
    moduleCreateContext(new_ctx, ctx->module,
                        REDISMODULE_CTX_THREAD_SAFE|REDISMODULE_CTX_NEW_CLIENT);
    return new_ctx;
}",8439.0,8446.0,1.0,24.0,8.0,7,6,5,2,0,3,1,1,0,2,,0,2,2,1,1,RedisModuleCtx
3107,186908,RM_FreeThreadSafeContext,1,RM_FreeThreadSafeContext,void RM_FreeThreadSafeContext (RedisModuleCtx*),module.c,"void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
    moduleFreeContext(ctx);
    zfree(ctx);
}",8449.0,8452.0,1.0,1.0,4.0,0,0,2,1,0,2,1,1,0,2,,0,0,2,1,1,void
3108,186917,moduleGILAfterLock,1,moduleGILAfterLock,void moduleGILAfterLock (void),module.c,"void moduleGILAfterLock(void) {
    /* We should never get here if we already inside a module
     * code block which already opened a context. */
    serverAssert(server.execution_nesting == 0);
    /* Bump up the nesting level to prevent immediate propagation
     * of possible RM_Call from th thread */
    enterExecutionUnit(1, 0);
}",8454.0,8461.0,1.0,4.0,8.0,6,6,1,1,2,2,1,1,0,2,,0,0,2,1,1,void
3109,186943,RM_ThreadSafeContextLock,1,RM_ThreadSafeContextLock,void RM_ThreadSafeContextLock (RedisModuleCtx*),module.c,"void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {
    UNUSED(ctx);
    moduleAcquireGIL();
    moduleGILAfterLock();
}",8466.0,8470.0,1.0,4.0,5.0,1,1,2,1,0,2,1,1,0,2,,0,0,2,1,1,void
3110,186956,RM_ThreadSafeContextTryLock,1,RM_ThreadSafeContextTryLock,int RM_ThreadSafeContextTryLock (RedisModuleCtx*),module.c,"int RM_ThreadSafeContextTryLock(RedisModuleCtx *ctx) {
    UNUSED(ctx);

    int res = moduleTryAcquireGIL();
    if(res != 0) {
        errno = res;
        return REDISMODULE_ERR;
    }
    moduleGILAfterLock();
    return REDISMODULE_OK;
}",8478.0,8488.0,1.0,4.0,11.0,4,3,6,3,0,2,2,2,0,2,,0,1,2,1,1,int
3111,186988,moduleGILBeforeUnlock,1,moduleGILBeforeUnlock,void moduleGILBeforeUnlock (void),module.c,"void moduleGILBeforeUnlock(void) {
    /* We should never get here if we already inside a module
     * code block which already opened a context, except
     * the bump-up from moduleGILAcquired. */
    serverAssert(server.execution_nesting == 1);
    /* Restore nesting level and propagate pending commands
     * (because it's unclear when thread safe contexts are
     * released we have to propagate here). */
    exitExecutionUnit();
    postExecutionUnitOperations();
}",8490.0,8500.0,1.0,4.0,11.0,6,6,1,1,1,3,1,1,0,3,,0,0,2,1,1,void
3112,187013,RM_ThreadSafeContextUnlock,1,RM_ThreadSafeContextUnlock,void RM_ThreadSafeContextUnlock (RedisModuleCtx*),module.c,"void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {
    UNUSED(ctx);
    moduleGILBeforeUnlock();
    moduleReleaseGIL();
}",8503.0,8507.0,1.0,4.0,5.0,1,1,2,1,0,2,1,1,0,2,,0,0,2,1,1,void
3113,187026,moduleAcquireGIL,1,moduleAcquireGIL,void moduleAcquireGIL (void),module.c,"void moduleAcquireGIL(void) {
    pthread_mutex_lock(&moduleGIL);
}",8509.0,8511.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
3114,187034,moduleTryAcquireGIL,1,moduleTryAcquireGIL,int moduleTryAcquireGIL (void),module.c,"int moduleTryAcquireGIL(void) {
    return pthread_mutex_trylock(&moduleGIL);
}",8513.0,8515.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
3115,187043,moduleReleaseGIL,1,moduleReleaseGIL,void moduleReleaseGIL (void),module.c,"void moduleReleaseGIL(void) {
    pthread_mutex_unlock(&moduleGIL);
}",8517.0,8519.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
3116,187051,RM_SubscribeToKeyspaceEvents,1,RM_SubscribeToKeyspaceEvents,"int RM_SubscribeToKeyspaceEvents (RedisModuleCtx*,int,RedisModuleNotificationFunc)",module.c,"int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {
    RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));
    sub->module = ctx->module;
    sub->event_mask = types;
    sub->notify_callback = callback;
    sub->active = 0;

    listAddNodeTail(moduleKeyspaceSubscribers, sub);
    return REDISMODULE_OK;
}",8594.0,8603.0,1.0,11.0,10.0,12,4,11,5,0,8,1,1,0,2,,0,7,6,3,3,int
3117,187094,firePostExecutionUnitJobs,1,firePostExecutionUnitJobs,void firePostExecutionUnitJobs (void),module.c,"void firePostExecutionUnitJobs(void) {
    /* Avoid propagation of commands.
     * In that way, postExecutionUnitOperations will prevent
     * recursive calls to firePostExecutionUnitJobs.
     * This is a special case where we need to increase 'execution_nesting'
     * but we do not want to update the cached time */
    enterExecutionUnit(0, 0);
    while (listLength(modulePostExecUnitJobs) > 0) {
        listNode *ln = listFirst(modulePostExecUnitJobs);
        RedisModulePostExecUnitJob *job = listNodeValue(ln);
        listDelNode(modulePostExecUnitJobs, ln);

        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, job->module, REDISMODULE_CTX_TEMP_CLIENT);
        selectDb(ctx.client, job->dbid);

        job->callback(&ctx, job->pd);
        if (job->free_pd) job->free_pd(job->pd);

        moduleFreeContext(&ctx);
        zfree(job);
    }
    exitExecutionUnit();
}",8605.0,8628.0,1.0,11.0,24.0,18,6,22,4,1,22,3,4,3,8,,0,14,2,1,1,void
3118,187179,RM_AddPostNotificationJob,1,RM_AddPostNotificationJob,"int RM_AddPostNotificationJob (RedisModuleCtx*,RedisModulePostNotificationJobFunc,void*,void)",module.c,"int RM_AddPostNotificationJob(RedisModuleCtx *ctx, RedisModulePostNotificationJobFunc callback, void *privdata, void (*free_privdata)(void*)) {
    if (server.loading|| (server.masterhost && server.repl_slave_ro)) {
        return REDISMODULE_ERR;
    }
    RedisModulePostExecUnitJob *job = zmalloc(sizeof(*job));
    job->module = ctx->module;
    job->callback = callback;
    job->pd = privdata;
    job->free_pd = free_privdata;
    job->dbid = ctx->client->db->id;

    listAddNodeTail(modulePostExecUnitJobs, job);
    return REDISMODULE_OK;
}",8647.0,8660.0,1.0,15.0,14.0,22,7,17,7,0,9,2,2,0,2,,0,8,8,4,4,int
3119,187260,RM_NotifyKeyspaceEvent,1,RM_NotifyKeyspaceEvent,"int RM_NotifyKeyspaceEvent (RedisModuleCtx*,int,char*,robj*)",module.c,"int RM_NotifyKeyspaceEvent(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key) {
    if (!ctx || !ctx->client)
        return REDISMODULE_ERR;
    notifyKeyspaceEvent(type, (char *)event, key, ctx->client->db->id);
    return REDISMODULE_OK;
}",8669.0,8674.0,1.0,77.0,6.0,8,4,6,4,0,3,2,2,1,1,,0,2,8,4,4,int
3120,187298,moduleNotifyKeyspaceEvent,1,moduleNotifyKeyspaceEvent,"void moduleNotifyKeyspaceEvent (int,char*,robj*,int)",module.c,"void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {
    /* Don't do anything if there aren't any subscribers */
    if (listLength(moduleKeyspaceSubscribers) == 0) return;

    /* Ugly hack to handle modules which use write commands from within
     * notify_callback, which they should NOT do!
     * Modules should use RedisModules_AddPostNotificationJob instead.
     *
     * Anyway, we want any propagated commands from within notify_callback
     * to be propagated inside a MULTI/EXEC together with the original
     * command that caused the KSN.
     * Note that it's only relevant for KSNs which are not generated from within
     * call(), for example active-expiry and eviction (because anyway
     * execution_nesting is incremented from within call())
     *
     * In order to do that we increment the execution_nesting counter, thus
     * preventing postExecutionUnitOperations (from within moduleFreeContext)
     * from propagating commands from C...",8679.0,8732.0,1.0,8.0,54.0,36,13,27,10,1,20,4,5,7,7,,0,14,8,4,4,void
3121,187426,moduleUnsubscribeNotifications,1,moduleUnsubscribeNotifications,void moduleUnsubscribeNotifications (RedisModule*),module.c,"void moduleUnsubscribeNotifications(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(moduleKeyspaceSubscribers,&li);
    while((ln = listNext(&li))) {
        RedisModuleKeyspaceSubscriber *sub = ln->value;
        if (sub->module == module) {
            listDelNode(moduleKeyspaceSubscribers, ln);
            zfree(sub);
        }
    }
}",8735.0,8746.0,1.0,1.0,12.0,7,4,11,5,1,8,3,4,2,4,,0,5,2,1,1,void
3122,187554,RM_RegisterClusterMessageReceiver,1,RM_RegisterClusterMessageReceiver,"void RM_RegisterClusterMessageReceiver (RedisModuleCtx*,uint8_t,RedisModuleClusterMessageReceiver)",module.c,"void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {
    if (!server.cluster_enabled) return;

    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
    moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;
    while(r) {
        if (r->module_id == module_id) {
            /* Found! Set or delete. */
            if (callback) {
                r->callback = callback;
            } else {
                /* Delete the receiver entry if the user is setting
                 * it to NULL. Just unlink the receiver node from the
                 * linked list. */
                if (prev)
                    prev->next = r->next;
                else
                    clusterReceivers[type]->next = r->next;
                zfree(r);
            }
            return;
        }
        prev = r;
        r = r->next;
    }

    /* Not found, let's add it. */
    if (callback) {
        r = zmalloc(si...",8796.0,8831.0,1.0,1.0,36.0,30,8,33,9,0,14,6,9,1,2,,0,14,6,3,3,void
3123,187678,RM_SendClusterMessage,1,RM_SendClusterMessage,"int RM_SendClusterMessage (RedisModuleCtx*,char*,uint8_t,char*,uint32_t)",module.c,"int RM_SendClusterMessage(RedisModuleCtx *ctx, const char *target_id, uint8_t type, const char *msg, uint32_t len) {
    if (!server.cluster_enabled) return REDISMODULE_ERR;
    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
    if (clusterSendModuleMessageToTarget(target_id,module_id,type,msg,len) == C_OK)
        return REDISMODULE_OK;
    else
        return REDISMODULE_ERR;
}",8840.0,8847.0,1.0,40.0,8.0,6,5,8,7,0,3,3,3,1,2,,0,3,10,5,5,int
3124,187729,RM_GetClusterNodesList,1,RM_GetClusterNodesList,"char** RM_GetClusterNodesList (RedisModuleCtx*,size_t*)",module.c,"char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
    UNUSED(ctx);

    if (!server.cluster_enabled) return NULL;
    size_t count = dictSize(server.cluster->nodes);
    char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
    dictIterator *di = dictGetIterator(server.cluster->nodes);
    dictEntry *de;
    int j = 0;
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) continue;
        ids[j] = zmalloc(REDISMODULE_NODE_ID_LEN);
        memcpy(ids[j],node->name,REDISMODULE_NODE_ID_LEN);
        j++;
    }
    *numnodes = j;
    ids[j] = NULL; /* Null term so that FreeClusterNodesList does not need
                    * to also get the count argument. */
    dictReleaseIterator(di);
    return ids;
}",8871.0,8892.0,1.0,4.0,22.0,37,13,32,10,0,8,5,5,2,6,,0,7,4,2,2,char**
3125,187863,RM_FreeClusterNodesList,1,RM_FreeClusterNodesList,void RM_FreeClusterNodesList (char**),module.c,"void RM_FreeClusterNodesList(char **ids) {
    if (ids == NULL) return;
    for (int j = 0; ids[j]; j++) zfree(ids[j]);
    zfree(ids);
}",8895.0,8899.0,1.0,1.0,5.0,3,3,6,3,0,1,3,3,0,1,,0,0,2,1,1,void
3126,187952,RM_GetClusterNodeInfo,1,RM_GetClusterNodeInfo,"int RM_GetClusterNodeInfo (RedisModuleCtx*,char*,char*,char*,int*,int*)",module.c,"int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {
    UNUSED(ctx);

    clusterNode *node = clusterLookupNode(id, strlen(id));
    if (node == NULL ||
        node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
    {
        return REDISMODULE_ERR;
    }

    if (ip) redis_strlcpy(ip,node->ip,NET_IP_STR_LEN);

    if (master_id) {
        /* If the information is not available, the function will set the
         * field to zero bytes, so that when the field can't be populated the
         * function kinda remains predictable. */
        if (node->flags & CLUSTER_NODE_SLAVE && node->slaveof)
            memcpy(master_id,node->slaveof->name,REDISMODULE_NODE_ID_LEN);
        else
            memset(master_id,0,REDISMODULE_NODE_ID_LEN);
    }
    if (port) *port = getNodeDefaultClientPort(node);

    /* As usually we have to remap flags for modules, in order to ensure
     * we can provide binary compatibility. */
...",8937.0,8972.0,1.0,4.0,36.0,42,10,33,8,0,14,13,20,9,3,,0,13,12,6,6,int
3127,188228,moduleTimerHandler,1,moduleTimerHandler,"int moduleTimerHandler (aeEventLoop*,long long,void*)",module.c,"int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    /* To start let's try to fire all the timers already expired. */
    raxIterator ri;
    raxStart(&ri,Timers);
    uint64_t now = ustime();
    long long next_period = 0;
    while(1) {
        raxSeek(&ri,""^"",NULL,0);
        if (!raxNext(&ri)) break;
        uint64_t expiretime;
        memcpy(&expiretime,ri.key,sizeof(expiretime));
        expiretime = ntohu64(expiretime);
        if (now >= expiretime) {
            RedisModuleTimer *timer = ri.data;
            RedisModuleCtx ctx;
            moduleCreateContext(&ctx,timer->module,REDISMODULE_CTX_TEMP_CLIENT);
            selectDb(ctx.client, timer->dbid);
            timer->callback(&ctx,timer->data);
            moduleFreeContext(&ctx);
            raxRemove(Timers,(unsigned char*)ri.key,ri.key_len,NULL);
            zfree(timer);
        } else {
            /* We call us...",9034.0,9080.0,1.0,4.0,47.0,32,11,41,11,0,24,7,8,3,12,,0,16,6,3,3,int
3128,188395,RM_CreateTimer,1,RM_CreateTimer,"RedisModuleTimerID RM_CreateTimer (RedisModuleCtx*,mstime_t,RedisModuleTimerProc,void*)",module.c,"RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {
    RedisModuleTimer *timer = zmalloc(sizeof(*timer));
    timer->module = ctx->module;
    timer->callback = callback;
    timer->data = data;
    timer->dbid = ctx->client ? ctx->client->db->id : 0;
    uint64_t expiretime = ustime()+period*1000;
    uint64_t key;

    while(1) {
        key = htonu64(expiretime);
        if (raxFind(Timers, (unsigned char*)&key,sizeof(key)) == raxNotFound) {
            raxInsert(Timers,(unsigned char*)&key,sizeof(key),timer,NULL);
            break;
        } else {
            expiretime++;
        }
    }

    /* We need to install the main event loop timer if it's not already
     * installed, or we may need to refresh its period if we just installed
     * a timer that will expire sooner than any other else (i.e. the timer
     * we just installed is the first timer in the Timers rax). */
    if (aeTimer != -1) {
        raxIt...",9094.0,9137.0,1.0,14.0,44.0,45,13,45,13,0,27,7,8,5,11,,0,21,8,4,4,RedisModuleTimerID
3129,188551,RM_StopTimer,1,RM_StopTimer,"int RM_StopTimer (RedisModuleCtx*,RedisModuleTimerID,void**)",module.c,"int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
    if (timer == raxNotFound || timer->module != ctx->module)
        return REDISMODULE_ERR;
    if (data) *data = timer->data;
    raxRemove(Timers,(unsigned char*)&id,sizeof(id),NULL);
    zfree(timer);
    return REDISMODULE_OK;
}",9143.0,9151.0,1.0,15.0,9.0,15,9,16,7,0,8,3,3,2,3,,0,6,6,3,3,int
3130,188610,RM_GetTimerInfo,1,RM_GetTimerInfo,"int RM_GetTimerInfo (RedisModuleCtx*,RedisModuleTimerID,uint64_t*,void**)",module.c,"int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {
    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
    if (timer == raxNotFound || timer->module != ctx->module)
        return REDISMODULE_ERR;
    if (remaining) {
        int64_t rem = ntohu64(id)-ustime();
        if (rem < 0) rem = 0;
        *remaining = rem/1000; /* Scale to milliseconds. */
    }
    if (data) *data = timer->data;
    return REDISMODULE_OK;
}",9159.0,9170.0,1.0,15.0,12.0,19,12,19,8,0,7,5,6,2,3,,0,7,8,4,4,int
3131,188686,moduleHoldsTimer,1,moduleHoldsTimer,int moduleHoldsTimer (RedisModule*),module.c,"int moduleHoldsTimer(struct RedisModule *module) {
    raxIterator iter;
    int found = 0;
    raxStart(&iter,Timers);
    raxSeek(&iter,""^"",NULL,0);
    while (raxNext(&iter)) {
        RedisModuleTimer *timer = iter.data;
        if (timer->module == module) {
            found = 1;
            break;
        }
    }
    raxStop(&iter);
    return found;
}",9174.0,9188.0,1.0,1.0,15.0,10,5,13,6,0,7,4,4,2,4,,0,4,2,1,1,int
3132,188747,eventLoopToAeMask,1,eventLoopToAeMask,int eventLoopToAeMask (int),module.c,"static int eventLoopToAeMask(int mask) {
    int aeMask = 0;
    if (mask & REDISMODULE_EVENTLOOP_READABLE)
        aeMask |= AE_READABLE;
    if (mask & REDISMODULE_EVENTLOOP_WRITABLE)
        aeMask |= AE_WRITABLE;
    return aeMask;
}",9208.0,9215.0,1.0,15.0,8.0,3,2,6,2,2,0,3,3,0,0,,0,0,2,1,1,int
3133,188782,eventLoopFromAeMask,1,eventLoopFromAeMask,int eventLoopFromAeMask (int),module.c,"static int eventLoopFromAeMask(int ae_mask) {
    int mask = 0;
    if (ae_mask & AE_READABLE)
        mask |= REDISMODULE_EVENTLOOP_READABLE;
    if (ae_mask & AE_WRITABLE)
        mask |= REDISMODULE_EVENTLOOP_WRITABLE;
    return mask;
}",9217.0,9224.0,1.0,18.0,8.0,3,2,6,2,2,0,3,3,0,0,,0,0,2,1,1,int
3134,188817,eventLoopCbReadable,1,eventLoopCbReadable,"void eventLoopCbReadable (aeEventLoop*,int,void*,int)",module.c,"static void eventLoopCbReadable(struct aeEventLoop *ae, int fd, void *user_data, int ae_mask) {
    UNUSED(ae);
    EventLoopData *data = user_data;
    data->rFunc(fd, data->user_data, eventLoopFromAeMask(ae_mask));
}",9226.0,9230.0,1.0,4.0,5.0,4,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
3135,188845,eventLoopCbWritable,1,eventLoopCbWritable,"void eventLoopCbWritable (aeEventLoop*,int,void*,int)",module.c,"static void eventLoopCbWritable(struct aeEventLoop *ae, int fd, void *user_data, int ae_mask) {
    UNUSED(ae);
    EventLoopData *data = user_data;
    data->wFunc(fd, data->user_data, eventLoopFromAeMask(ae_mask));
}",9232.0,9236.0,1.0,4.0,5.0,4,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
3136,188873,RM_EventLoopAdd,1,RM_EventLoopAdd,"int RM_EventLoopAdd (int,int,RedisModuleEventLoopFunc,void*)",module.c,"int RM_EventLoopAdd(int fd, int mask, RedisModuleEventLoopFunc func, void *user_data) {
    if (fd < 0 || fd >= aeGetSetSize(server.el)) {
        errno = ERANGE;
        return REDISMODULE_ERR;
    }

    if (!func || mask & ~(REDISMODULE_EVENTLOOP_READABLE |
                          REDISMODULE_EVENTLOOP_WRITABLE)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* We are going to register stub callbacks to 'ae' for two reasons:
     *
     * - ""ae"" callback signature is different from RedisModuleEventLoopCallback,
     *   that will be handled it in our stub callbacks.
     * - We need to remap 'mask' value to provide binary compatibility.
     *
     * For the stub callbacks, saving user 'callback' and 'user_data' in an
     * EventLoopData object and passing it to ae, later, we'll extract
     * 'callback' and 'user_data' from that.
     */
    EventLoopData *data = aeGetFileClientData(server.el, fd);
    if (!data)
        data = zcalloc(sizeof(*data));

...",9263.0,9311.0,1.0,15.0,49.0,33,14,36,11,0,10,9,10,3,7,,0,9,8,4,4,int
3137,189028,RM_EventLoopDel,1,RM_EventLoopDel,"int RM_EventLoopDel (int,int)",module.c,"int RM_EventLoopDel(int fd, int mask) {
    if (fd < 0 || fd >= aeGetSetSize(server.el)) {
        errno = ERANGE;
        return REDISMODULE_ERR;
    }

    if (mask & ~(REDISMODULE_EVENTLOOP_READABLE |
                 REDISMODULE_EVENTLOOP_WRITABLE)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* After deleting the event, if fd does not have any registered event
     * anymore, we can free the EventLoopData object. */
    EventLoopData *data = aeGetFileClientData(server.el, fd);
    aeDeleteFileEvent(server.el, fd, eventLoopToAeMask(mask));
    if (aeGetFileEvents(server.el, fd) == AE_NONE)
        zfree(data);

    errno = 0;
    return REDISMODULE_OK;
}",9327.0,9348.0,1.0,15.0,22.0,15,9,18,7,0,6,4,4,2,6,,0,4,4,2,2,int
3138,189107,RM_EventLoopAddOneShot,1,RM_EventLoopAddOneShot,"int RM_EventLoopAddOneShot (RedisModuleEventLoopOneShotFunc,void*)",module.c,"int RM_EventLoopAddOneShot(RedisModuleEventLoopOneShotFunc func, void *user_data) {
    if (!func) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    EventLoopOneShot *oneshot = zmalloc(sizeof(*oneshot));
    oneshot->func = func;
    oneshot->user_data = user_data;

    pthread_mutex_lock(&moduleEventLoopMutex);
    if (!moduleEventLoopOneShots) moduleEventLoopOneShots = listCreate();
    listAddNodeTail(moduleEventLoopOneShots, oneshot);
    pthread_mutex_unlock(&moduleEventLoopMutex);

    if (write(server.module_pipe[1],""A"",1) != 1) {
        /* Pipe is non-blocking, write() may fail if it's full. */
    }

    errno = 0;
    return REDISMODULE_OK;
}",9354.0,9375.0,1.0,15.0,22.0,17,9,17,8,0,10,4,4,1,3,,0,9,4,2,2,int
3139,189176,eventLoopHandleOneShotEvents,1,eventLoopHandleOneShotEvents,void eventLoopHandleOneShotEvents (void),module.c,"static void eventLoopHandleOneShotEvents(void) {
    pthread_mutex_lock(&moduleEventLoopMutex);
    if (moduleEventLoopOneShots) {
        while (listLength(moduleEventLoopOneShots)) {
            listNode *ln = listFirst(moduleEventLoopOneShots);
            EventLoopOneShot *oneshot = ln->value;
            listDelNode(moduleEventLoopOneShots, ln);
            /* Unlock mutex before the callback. Another oneshot event can be
             * added in the callback, it will need to lock the mutex. */
            pthread_mutex_unlock(&moduleEventLoopMutex);
            oneshot->func(oneshot->user_data);
            zfree(oneshot);
            /* Lock again for the next iteration */
            pthread_mutex_lock(&moduleEventLoopMutex);
        }
    }
    pthread_mutex_unlock(&moduleEventLoopMutex);
}",9379.0,9396.0,1.0,15.0,18.0,11,3,17,4,1,17,3,4,4,2,,0,15,2,1,1,void
3140,189231,moduleNotifyUserChanged,1,moduleNotifyUserChanged,void moduleNotifyUserChanged (client*),module.c,"void moduleNotifyUserChanged(client *c) {
    if (c->auth_callback) {
        c->auth_callback(c->id, c->auth_callback_privdata);

        /* The callback will fire exactly once, even if the user remains
         * the same. It is expected to completely clean up the state
         * so all references are cleared here. */
        c->auth_callback = NULL;
        c->auth_callback_privdata = NULL;
        c->auth_module = NULL;
    }
}",9410.0,9421.0,1.0,1.0,12.0,10,2,10,2,5,7,2,2,1,0,,0,7,2,1,1,void
3141,189266,revokeClientAuthentication,1,revokeClientAuthentication,void revokeClientAuthentication (client*),module.c,"void revokeClientAuthentication(client *c) {
    /* Freeing the client would result in moduleNotifyUserChanged() to be
     * called later, however since we use revokeClientAuthentication() also
     * in moduleFreeAuthenticatedClients() to implement module unloading, we
     * do this action ASAP: this way if the module is unloaded, when the client
     * is eventually freed we don't rely on the module to still exist. */
    moduleNotifyUserChanged(c);

    c->user = DefaultUser;
    c->authenticated = 0;
    /* We will write replies to this client later, so we can't close it
     * directly even if async. */
    if (c == server.current_client) {
        c->flags |= CLIENT_CLOSE_AFTER_COMMAND;
    } else {
        freeClientAsync(c);
    }
}",9423.0,9440.0,1.0,20.0,18.0,8,5,7,3,2,4,2,2,0,1,,0,3,2,1,1,void
3142,189303,moduleFreeAuthenticatedClients,1,moduleFreeAuthenticatedClients,void moduleFreeAuthenticatedClients (RedisModule*),module.c,"static void moduleFreeAuthenticatedClients(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (!c->auth_module) continue;

        RedisModule *auth_module = (RedisModule *) c->auth_module;
        if (auth_module == module) {
            revokeClientAuthentication(c);
        }
    }
}",9445.0,9458.0,1.0,20.0,14.0,13,8,14,7,1,6,5,6,2,3,,0,4,2,1,1,void
3143,189356,RM_CreateModuleUser,1,RM_CreateModuleUser,RedisModuleUser RM_CreateModuleUser (char*),module.c,"RedisModuleUser *RM_CreateModuleUser(const char *name) {
    RedisModuleUser *new_user = zmalloc(sizeof(RedisModuleUser));
    new_user->user = ACLCreateUnlinkedUser();
    new_user->free_user = 1;

    /* Free the previous temporarily assigned name to assign the new one */
    sdsfree(new_user->user->name);
    new_user->user->name = sdsnew(name);
    return new_user;
}",9480.0,9489.0,1.0,1.0,10.0,11,3,8,3,0,8,1,1,0,4,,0,7,2,1,1,RedisModuleUser
3144,189393,RM_FreeModuleUser,1,RM_FreeModuleUser,int RM_FreeModuleUser (RedisModuleUser*),module.c,"int RM_FreeModuleUser(RedisModuleUser *user) {
    if (user->free_user)
        ACLFreeUserAndKillClients(user->user);
    zfree(user);
    return REDISMODULE_OK;
}",9493.0,9498.0,1.0,11.0,6.0,2,1,3,1,0,4,2,2,1,2,,0,2,2,1,1,int
3145,189413,RM_SetModuleUserACL,1,RM_SetModuleUserACL,"int RM_SetModuleUserACL (RedisModuleUser*,char*)",module.c,"int RM_SetModuleUserACL(RedisModuleUser *user, const char* acl) {
    return ACLSetUser(user->user, acl, -1);
}",9507.0,9509.0,1.0,1.0,3.0,2,2,2,2,0,2,1,1,0,1,,0,1,4,2,2,int
3146,189427,RM_SetModuleUserACLString,1,RM_SetModuleUserACLString,"int RM_SetModuleUserACLString (RedisModuleCtx*,RedisModuleUser*,char*,robj**)",module.c,"int RM_SetModuleUserACLString(RedisModuleCtx *ctx, RedisModuleUser *user, const char *acl, RedisModuleString **error) {
    serverAssert(user != NULL);

    int argc;
    sds *argv = sdssplitargs(acl, &argc);

    sds err = ACLStringSetUser(user->user, NULL, argv, argc);

    sdsfreesplitres(argv, argc);

    if (err) {
        if (error) {
            *error = createObject(OBJ_STRING, err);
            if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, *error);
        } else {
            sdsfree(err);
        }

        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",9518.0,9540.0,1.0,91.0,23.0,13,9,20,8,0,7,4,7,0,6,,0,4,8,4,4,int
3147,189510,RM_GetModuleUserACLString,1,RM_GetModuleUserACLString,robj RM_GetModuleUserACLString (RedisModuleUser*),module.c,"RedisModuleString *RM_GetModuleUserACLString(RedisModuleUser *user) {
    serverAssert(user != NULL);

    return ACLDescribeUser(user->user);
}",9545.0,9549.0,1.0,17.0,5.0,6,6,3,2,0,3,1,1,0,2,,0,1,2,1,1,robj
3148,189536,RM_GetCurrentUserName,1,RM_GetCurrentUserName,robj RM_GetCurrentUserName (RedisModuleCtx*),module.c,"RedisModuleString *RM_GetCurrentUserName(RedisModuleCtx *ctx) {
    return RM_CreateString(ctx,ctx->client->user->name,sdslen(ctx->client->user->name));
}",9557.0,9559.0,1.0,17.0,3.0,6,1,3,1,0,4,1,1,0,2,,0,3,2,1,1,robj
3149,189559,RM_GetModuleUserFromUserName,1,RM_GetModuleUserFromUserName,RedisModuleUser RM_GetModuleUserFromUserName (robj*),module.c,"RedisModuleUser *RM_GetModuleUserFromUserName(RedisModuleString *name) {
    /* First, verify that the user exist */
    user *acl_user = ACLGetUserByName(name->ptr, sdslen(name->ptr));
    if (acl_user == NULL) {
        return NULL;
    }

    RedisModuleUser *new_user = zmalloc(sizeof(RedisModuleUser));
    new_user->user = acl_user;
    new_user->free_user = 0;
    return new_user;
}",9572.0,9583.0,1.0,46.0,12.0,10,4,12,5,0,5,2,2,0,3,,0,5,2,1,1,RedisModuleUser
3150,189600,RM_ACLCheckCommandPermissions,1,RM_ACLCheckCommandPermissions,"int RM_ACLCheckCommandPermissions (RedisModuleUser*,robj**,int)",module.c,"int RM_ACLCheckCommandPermissions(RedisModuleUser *user, RedisModuleString **argv, int argc) {
    int keyidxptr;
    struct redisCommand *cmd;

    /* Find command */
    if ((cmd = lookupCommand(argv, argc)) == NULL) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }

    if (ACLCheckAllUserCommandPerm(user->user, cmd, argv, argc, &keyidxptr) != ACL_OK) {
        errno = EACCES;
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",9593.0,9609.0,1.0,57.0,17.0,7,5,13,9,0,3,3,3,3,2,,0,3,6,3,3,int
3151,189651,RM_ACLCheckKeyPermissions,1,RM_ACLCheckKeyPermissions,"int RM_ACLCheckKeyPermissions (RedisModuleUser*,robj*,int)",module.c,"int RM_ACLCheckKeyPermissions(RedisModuleUser *user, RedisModuleString *key, int flags) {
    const int allow_mask = (REDISMODULE_CMD_KEY_ACCESS
        | REDISMODULE_CMD_KEY_INSERT
        | REDISMODULE_CMD_KEY_DELETE
        | REDISMODULE_CMD_KEY_UPDATE);

    if ((flags & allow_mask) != flags) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    int keyspec_flags = moduleConvertKeySpecsFlags(flags, 0);
    if (ACLUserCheckKeyPerm(user->user, key->ptr, sdslen(key->ptr), keyspec_flags) != ACL_OK) {
        errno = EACCES;
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",9626.0,9644.0,1.0,53.0,19.0,17,6,14,8,0,4,3,3,3,3,,0,4,6,3,3,int
3152,189733,RM_ACLCheckChannelPermissions,1,RM_ACLCheckChannelPermissions,"int RM_ACLCheckChannelPermissions (RedisModuleUser*,robj*,int)",module.c,"int RM_ACLCheckChannelPermissions(RedisModuleUser *user, RedisModuleString *ch, int flags) {
    const int allow_mask = (REDISMODULE_CMD_CHANNEL_PUBLISH
        | REDISMODULE_CMD_CHANNEL_SUBSCRIBE
        | REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE
        | REDISMODULE_CMD_CHANNEL_PATTERN);

    if ((flags & allow_mask) != flags) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* Unsubscribe permissions are currently always allowed. */
    if (flags & REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE){
        return REDISMODULE_OK;
    }

    int is_pattern = flags & REDISMODULE_CMD_CHANNEL_PATTERN;
    if (ACLUserCheckChannelPerm(user->user, ch->ptr, is_pattern) != ACL_OK)
        return REDISMODULE_ERR;

    return REDISMODULE_OK;
}",9656.0,9677.0,1.0,57.0,22.0,19,6,12,7,0,2,4,4,2,1,,0,2,6,3,3,int
3153,189825,moduleGetACLLogEntryReason,1,moduleGetACLLogEntryReason,int moduleGetACLLogEntryReason (RedisModuleACLLogEntryReason),module.c,"int moduleGetACLLogEntryReason(RedisModuleACLLogEntryReason reason) {
    int acl_reason = 0;
    switch (reason) {
        case REDISMODULE_ACL_LOG_AUTH: acl_reason = ACL_DENIED_AUTH; break;
        case REDISMODULE_ACL_LOG_KEY: acl_reason = ACL_DENIED_KEY; break;
        case REDISMODULE_ACL_LOG_CHANNEL: acl_reason = ACL_DENIED_CHANNEL; break;
        case REDISMODULE_ACL_LOG_CMD: acl_reason = ACL_DENIED_CMD; break;
        default: break;
    }
    return acl_reason;
}",9680.0,9690.0,1.0,52.0,11.0,5,1,11,6,2,0,7,2,0,0,,0,0,2,1,1,int
3154,189873,RM_ACLAddLogEntry,1,RM_ACLAddLogEntry,"int RM_ACLAddLogEntry (RedisModuleCtx*,RedisModuleUser*,robj*,RedisModuleACLLogEntryReason)",module.c,"int RM_ACLAddLogEntry(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleString *object, RedisModuleACLLogEntryReason reason) {
    int acl_reason = moduleGetACLLogEntryReason(reason);
    if (!acl_reason) return REDISMODULE_ERR;
    addACLLogEntry(ctx->client, acl_reason, ACL_LOG_CTX_MODULE, -1, user->user->name, sdsdup(object->ptr));
    return REDISMODULE_OK;
}",9696.0,9701.0,1.0,66.0,6.0,7,4,7,5,0,5,2,2,0,3,,0,4,8,4,4,int
3155,189917,RM_ACLAddLogEntryByUserName,1,RM_ACLAddLogEntryByUserName,"int RM_ACLAddLogEntryByUserName (RedisModuleCtx*,robj*,robj*,RedisModuleACLLogEntryReason)",module.c,"int RM_ACLAddLogEntryByUserName(RedisModuleCtx *ctx, RedisModuleString *username, RedisModuleString *object, RedisModuleACLLogEntryReason reason) {
    int acl_reason = moduleGetACLLogEntryReason(reason);
    if (!acl_reason) return REDISMODULE_ERR;
    addACLLogEntry(ctx->client, acl_reason, ACL_LOG_CTX_MODULE, -1, username->ptr, sdsdup(object->ptr));
    return REDISMODULE_OK;
}",9707.0,9712.0,1.0,53.0,6.0,6,4,7,5,0,4,2,2,0,3,,0,3,8,4,4,int
3156,189959,authenticateClientWithUser,1,authenticateClientWithUser,"int authenticateClientWithUser (RedisModuleCtx*,user*,RedisModuleUserChangedFunc,void*,uint64_t*)",module.c,"static int authenticateClientWithUser(RedisModuleCtx *ctx, user *user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    if (user->flags & USER_FLAG_DISABLED) {
        return REDISMODULE_ERR;
    }

    /* Avoid settings which are meaningless and will be lost */
    if (!ctx->client || (ctx->client->flags & CLIENT_MODULE)) {
        return REDISMODULE_ERR;
    }

    moduleNotifyUserChanged(ctx->client);

    ctx->client->user = user;
    ctx->client->authenticated = 1;

    if (clientHasModuleAuthInProgress(ctx->client)) {
        ctx->client->flags |= CLIENT_MODULE_AUTH_HAS_RESULT;
    }

    if (callback) {
        ctx->client->auth_callback = callback;
        ctx->client->auth_callback_privdata = privdata;
        ctx->client->auth_module = ctx->module;
    }

    if (client_id) {
        *client_id = ctx->client->id;
    }

    return REDISMODULE_OK;
}",9734.0,9764.0,1.0,22.0,31.0,38,8,21,6,2,15,6,6,5,1,,0,14,10,5,5,int
3157,190089,RM_AuthenticateClientWithUser,1,RM_AuthenticateClientWithUser,"int RM_AuthenticateClientWithUser (RedisModuleCtx*,RedisModuleUser*,RedisModuleUserChangedFunc,void*,uint64_t*)",module.c,"int RM_AuthenticateClientWithUser(RedisModuleCtx *ctx, RedisModuleUser *module_user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    return authenticateClientWithUser(ctx, module_user->user, callback, privdata, client_id);
}",9772.0,9774.0,1.0,1.0,3.0,1,1,5,5,0,2,1,1,0,1,,0,1,10,5,5,int
3158,190107,RM_AuthenticateClientWithACLUser,1,RM_AuthenticateClientWithACLUser,"int RM_AuthenticateClientWithACLUser (RedisModuleCtx*,char*,size_t,RedisModuleUserChangedFunc,void*,uint64_t*)",module.c,"int RM_AuthenticateClientWithACLUser(RedisModuleCtx *ctx, const char *name, size_t len, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    user *acl_user = ACLGetUserByName(name, len);

    if (!acl_user) {
        return REDISMODULE_ERR;
    }
    return authenticateClientWithUser(ctx, acl_user, callback, privdata, client_id);
}",9781.0,9788.0,1.0,15.0,8.0,2,2,9,7,0,2,2,2,0,2,,0,1,12,6,6,int
3159,190138,RM_DeauthenticateAndCloseClient,1,RM_DeauthenticateAndCloseClient,"int RM_DeauthenticateAndCloseClient (RedisModuleCtx*,uint64_t)",module.c,"int RM_DeauthenticateAndCloseClient(RedisModuleCtx *ctx, uint64_t client_id) {
    UNUSED(ctx);
    client *c = lookupClientByID(client_id);
    if (c == NULL) return REDISMODULE_ERR;

    /* Revoke also marks client to be closed ASAP */
    revokeClientAuthentication(c);
    return REDISMODULE_OK;
}",9802.0,9810.0,1.0,4.0,9.0,3,3,7,4,0,2,2,2,0,2,,0,1,4,2,2,int
3160,190170,RM_RedactClientCommandArgument,1,RM_RedactClientCommandArgument,"int RM_RedactClientCommandArgument (RedisModuleCtx*,int)",module.c,"int RM_RedactClientCommandArgument(RedisModuleCtx *ctx, int pos) {
    if (!ctx || !ctx->client || pos <= 0 || ctx->client->argc <= pos) {
        return REDISMODULE_ERR;
    }
    redactClientCommandArgument(ctx->client, pos);
    return REDISMODULE_OK;
}",9822.0,9828.0,1.0,15.0,7.0,11,4,7,2,0,4,2,2,2,1,,0,3,4,2,2,int
3161,190210,RM_GetClientCertificate,1,RM_GetClientCertificate,"robj RM_GetClientCertificate (RedisModuleCtx*,uint64_t)",module.c,"RedisModuleString *RM_GetClientCertificate(RedisModuleCtx *ctx, uint64_t client_id) {
    client *c = lookupClientByID(client_id);
    if (c == NULL) return NULL;

    sds cert = connGetPeerCert(c->conn);
    if (!cert) return NULL;

    RedisModuleString *s = createObject(OBJ_STRING, cert);
    if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, s);

    return s;
}",9842.0,9853.0,1.0,17.0,12.0,7,5,16,6,0,5,4,4,0,4,,0,4,4,2,2,robj
3162,190262,RM_CreateDict,1,RM_CreateDict,RedisModuleDict RM_CreateDict (RedisModuleCtx*),module.c,"RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
    struct RedisModuleDict *d = zmalloc(sizeof(*d));
    d->rax = raxNew();
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);
    return d;
}",9876.0,9881.0,1.0,39.0,6.0,6,5,8,3,0,4,2,2,0,3,,0,3,2,1,1,RedisModuleDict
3163,190315,RM_DictSize,1,RM_DictSize,uint64_t RM_DictSize (RedisModuleDict*),module.c,"uint64_t RM_DictSize(RedisModuleDict *d) {
    return raxSize(d->rax);
}",9893.0,9895.0,1.0,1.0,3.0,1,1,1,1,0,2,1,1,0,1,,0,1,2,1,1,uint64_t
3164,190325,RM_DictSetC,1,RM_DictSetC,"int RM_DictSetC (RedisModuleDict*,void*,size_t,void*)",module.c,"int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
    int retval = raxTryInsert(d->rax,key,keylen,ptr,NULL);
    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
}",9901.0,9904.0,1.0,27.0,4.0,4,4,7,6,1,2,1,1,0,1,,0,2,8,4,4,int
3165,190355,RM_DictReplaceC,1,RM_DictReplaceC,"int RM_DictReplaceC (RedisModuleDict*,void*,size_t,void*)",module.c,"int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
    int retval = raxInsert(d->rax,key,keylen,ptr,NULL);
    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
}",9908.0,9911.0,1.0,27.0,4.0,4,4,7,6,1,2,1,1,0,1,,0,2,8,4,4,int
3166,190385,RM_DictSet,1,RM_DictSet,"int RM_DictSet (RedisModuleDict*,robj*,void*)",module.c,"int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
    return RM_DictSetC(d,key->ptr,sdslen(key->ptr),ptr);
}",9914.0,9916.0,1.0,35.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
3167,190403,RM_DictReplace,1,RM_DictReplace,"int RM_DictReplace (RedisModuleDict*,robj*,void*)",module.c,"int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
    return RM_DictReplaceC(d,key->ptr,sdslen(key->ptr),ptr);
}",9919.0,9921.0,1.0,39.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
3168,190421,RM_DictGetC,1,RM_DictGetC,"void* RM_DictGetC (RedisModuleDict*,void*,size_t,int*)",module.c,"void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {
    void *res = raxFind(d->rax,key,keylen);
    if (nokey) *nokey = (res == raxNotFound);
    return (res == raxNotFound) ? NULL : res;
}",9928.0,9932.0,1.0,1.0,5.0,7,5,12,7,1,2,2,2,0,1,,0,2,8,4,4,void*
3169,190454,RM_DictGet,1,RM_DictGet,"void* RM_DictGet (RedisModuleDict*,robj*,int*)",module.c,"void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
    return RM_DictGetC(d,key->ptr,sdslen(key->ptr),nokey);
}",9935.0,9937.0,1.0,37.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,void*
3170,190472,RM_DictDelC,1,RM_DictDelC,"int RM_DictDelC (RedisModuleDict*,void*,size_t,void*)",module.c,"int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {
    int retval = raxRemove(d->rax,key,keylen,oldval);
    return retval ? REDISMODULE_OK : REDISMODULE_ERR;
}",9946.0,9949.0,1.0,20.0,4.0,3,3,6,5,1,2,1,1,0,1,,0,2,8,4,4,int
3171,190499,RM_DictDel,1,RM_DictDel,"int RM_DictDel (RedisModuleDict*,robj*,void*)",module.c,"int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
    return RM_DictDelC(d,key->ptr,sdslen(key->ptr),oldval);
}",9952.0,9954.0,1.0,35.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
3172,190517,RM_DictIteratorStartC,1,RM_DictIteratorStartC,"RedisModuleDictIter RM_DictIteratorStartC (RedisModuleDict*,char*,void*,size_t)",module.c,"RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {
    RedisModuleDictIter *di = zmalloc(sizeof(*di));
    di->dict = d;
    raxStart(&di->ri,d->rax);
    raxSeek(&di->ri,op,key,keylen);
    return di;
}",9976.0,9982.0,1.0,1.0,7.0,10,5,11,5,1,7,1,1,0,3,,0,5,8,4,4,RedisModuleDictIter
3173,190555,RM_DictIteratorStart,1,RM_DictIteratorStart,"RedisModuleDictIter RM_DictIteratorStart (RedisModuleDict*,char*,robj*)",module.c,"RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {
    return RM_DictIteratorStartC(d,op,key->ptr,sdslen(key->ptr));
}",9986.0,9988.0,1.0,78.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,RedisModuleDictIter
3174,190573,RM_DictIteratorStop,1,RM_DictIteratorStop,void RM_DictIteratorStop (RedisModuleDictIter*),module.c,"void RM_DictIteratorStop(RedisModuleDictIter *di) {
    raxStop(&di->ri);
    zfree(di);
}",9992.0,9995.0,1.0,1.0,4.0,2,2,2,1,0,3,1,1,0,2,,0,1,2,1,1,void
3175,190585,RM_DictIteratorReseekC,1,RM_DictIteratorReseekC,"int RM_DictIteratorReseekC (RedisModuleDictIter*,char*,void*,size_t)",module.c,"int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
    return raxSeek(&di->ri,op,key,keylen);
}",10004.0,10006.0,1.0,1.0,3.0,2,2,4,4,1,2,1,1,0,1,,0,1,8,4,4,int
3176,190602,RM_DictIteratorReseek,1,RM_DictIteratorReseek,"int RM_DictIteratorReseek (RedisModuleDictIter*,char*,robj*)",module.c,"int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
    return RM_DictIteratorReseekC(di,op,key->ptr,sdslen(key->ptr));
}",10010.0,10012.0,1.0,67.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
3177,190620,RM_DictNextC,1,RM_DictNextC,"void* RM_DictNextC (RedisModuleDictIter*,size_t*,void**)",module.c,"void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
    if (!raxNext(&di->ri)) return NULL;
    if (keylen) *keylen = di->ri.key_len;
    if (dataptr) *dataptr = di->ri.data;
    return di->ri.key;
}",10039.0,10044.0,1.0,1.0,6.0,13,6,9,4,1,5,4,4,2,1,,0,5,6,3,3,void*
3178,190665,RM_DictPrevC,1,RM_DictPrevC,"void* RM_DictPrevC (RedisModuleDictIter*,size_t*,void**)",module.c,"void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
    if (!raxPrev(&di->ri)) return NULL;
    if (keylen) *keylen = di->ri.key_len;
    if (dataptr) *dataptr = di->ri.data;
    return di->ri.key;
}",10049.0,10054.0,1.0,1.0,6.0,13,6,9,4,1,5,4,4,2,1,,0,5,6,3,3,void*
3179,190710,RM_DictNext,1,RM_DictNext,"robj RM_DictNext (RedisModuleCtx*,RedisModuleDictIter*,void**)",module.c,"RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
    size_t keylen;
    void *key = RM_DictNextC(di,&keylen,dataptr);
    if (key == NULL) return NULL;
    return RM_CreateString(ctx,key,keylen);
}",10063.0,10068.0,1.0,17.0,6.0,3,3,10,6,0,2,2,2,0,2,,0,1,6,3,3,robj
3180,190738,RM_DictPrev,1,RM_DictPrev,"robj RM_DictPrev (RedisModuleCtx*,RedisModuleDictIter*,void**)",module.c,"RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
    size_t keylen;
    void *key = RM_DictPrevC(di,&keylen,dataptr);
    if (key == NULL) return NULL;
    return RM_CreateString(ctx,key,keylen);
}",10073.0,10078.0,1.0,17.0,6.0,3,3,10,6,0,2,2,2,0,2,,0,1,6,3,3,robj
3181,190766,RM_DictCompareC,1,RM_DictCompareC,"int RM_DictCompareC (RedisModuleDictIter*,char*,void*,size_t)",module.c,"int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
    int res = raxCompare(&di->ri,op,key,keylen);
    return res ? REDISMODULE_OK : REDISMODULE_ERR;
}",10092.0,10096.0,1.0,32.0,5.0,6,4,7,5,0,4,2,2,2,2,,0,4,8,4,4,int
3182,190805,RM_DictCompare,1,RM_DictCompare,"int RM_DictCompare (RedisModuleDictIter*,char*,robj*)",module.c,"int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
    int res = raxCompare(&di->ri,op,key->ptr,sdslen(key->ptr));
    return res ? REDISMODULE_OK : REDISMODULE_ERR;
}",10100.0,10104.0,1.0,60.0,5.0,8,4,7,4,0,5,2,2,2,3,,0,5,6,3,3,int
3183,190848,RM_InfoEndDictField,1,RM_InfoEndDictField,int RM_InfoEndDictField (RedisModuleInfoCtx*),module.c,"int RM_InfoEndDictField(RedisModuleInfoCtx *ctx) {
    if (!ctx->in_dict_field)
        return REDISMODULE_ERR;
    /* trim the last ',' if found. */
    if (ctx->info[sdslen(ctx->info)-1]==',')
        sdsIncrLen(ctx->info, -1);
    ctx->info = sdscat(ctx->info, ""\r\n"");
    ctx->in_dict_field = 0;
    return REDISMODULE_OK;
}",10169.0,10178.0,1.0,15.0,10.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
3184,190853,RM_InfoAddSection,1,RM_InfoAddSection,"int RM_InfoAddSection (RedisModuleInfoCtx*,char*)",module.c,"int RM_InfoAddSection(RedisModuleInfoCtx *ctx, const char *name) {
    sds full_name = sdsdup(ctx->module->name);
    if (name != NULL && strlen(name) > 0)
        full_name = sdscatfmt(full_name, ""_%s"", name);

    /* Implicitly end dicts, instead of returning an error which is likely un checked. */
    if (ctx->in_dict_field)
        RM_InfoEndDictField(ctx);

    /* proceed only if:
     * 1) no section was requested (emit all)
     * 2) the module name was requested (emit all)
     * 3) this specific section was requested. */
    if (ctx->requested_sections) {
        if ((!full_name || !dictFind(ctx->requested_sections, full_name)) &&
            (!dictFind(ctx->requested_sections, ctx->module->name)))
        {
            sdsfree(full_name);
            ctx->in_section = 0;
            return REDISMODULE_ERR;
        }
    }
    if (ctx->sections++) ctx->info = sdscat(ctx->info,""\r\n"");
    ctx->info = sdscatfmt(ctx->info, ""# %S\r\n"", full_name);
    ctx->in_section = 1;
    ...",10119.0,10146.0,1.0,19.0,28.0,30,8,26,4,0,22,6,7,8,9,,0,19,4,2,2,int
3185,190965,RM_InfoBeginDictField,1,RM_InfoBeginDictField,"int RM_InfoBeginDictField (RedisModuleInfoCtx*,char*)",module.c,"int RM_InfoBeginDictField(RedisModuleInfoCtx *ctx, const char *name) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    /* Implicitly end dicts, instead of returning an error which is likely un checked. */
    if (ctx->in_dict_field)
        RM_InfoEndDictField(ctx);
    char *tmpmodname, *tmpname;
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:"",
        getSafeInfoString(ctx->module->name, strlen(ctx->module->name), &tmpmodname),
        getSafeInfoString(name, strlen(name), &tmpname));
    if (tmpmodname != NULL) zfree(tmpmodname);
    if (tmpname != NULL) zfree(tmpname);
    ctx->in_dict_field = 1;
    return REDISMODULE_OK;
}",10151.0,10166.0,1.0,15.0,16.0,16,5,18,5,0,13,5,5,2,6,,0,10,4,2,2,int
3186,191095,RM_InfoAddFieldString,1,RM_InfoAddFieldString,"int RM_InfoAddFieldString (RedisModuleInfoCtx*,char*,robj*)",module.c,"int RM_InfoAddFieldString(RedisModuleInfoCtx *ctx, const char *field, RedisModuleString *value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%S,"",
            field,
            (sds)value->ptr);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%S\r\n"",
        ctx->module->name,
        field,
        (sds)value->ptr);
    return REDISMODULE_OK;
}",10183.0,10199.0,1.0,70.0,17.0,15,4,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
3187,191160,RM_InfoAddFieldCString,1,RM_InfoAddFieldCString,"int RM_InfoAddFieldCString (RedisModuleInfoCtx*,char*,char*)",module.c,"int RM_InfoAddFieldCString(RedisModuleInfoCtx *ctx, const char *field, const char *value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%s,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%s\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10202.0,10218.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
3188,191217,RM_InfoAddFieldDouble,1,RM_InfoAddFieldDouble,"int RM_InfoAddFieldDouble (RedisModuleInfoCtx*,char*,double)",module.c,"int RM_InfoAddFieldDouble(RedisModuleInfoCtx *ctx, const char *field, double value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatprintf(ctx->info,
            ""%s=%.17g,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatprintf(ctx->info,
        ""%s_%s:%.17g\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10221.0,10237.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
3189,191274,RM_InfoAddFieldLongLong,1,RM_InfoAddFieldLongLong,"int RM_InfoAddFieldLongLong (RedisModuleInfoCtx*,char*,long long)",module.c,"int RM_InfoAddFieldLongLong(RedisModuleInfoCtx *ctx, const char *field, long long value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%I,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%I\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10240.0,10256.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
3190,191331,RM_InfoAddFieldULongLong,1,RM_InfoAddFieldULongLong,"int RM_InfoAddFieldULongLong (RedisModuleInfoCtx*,char*,long long unsigned)",module.c,"int RM_InfoAddFieldULongLong(RedisModuleInfoCtx *ctx, const char *field, unsigned long long value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%U,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%U\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10259.0,10275.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
3191,191388,RM_RegisterInfoFunc,1,RM_RegisterInfoFunc,"int RM_RegisterInfoFunc (RedisModuleCtx*,RedisModuleInfoFunc)",module.c,"int RM_RegisterInfoFunc(RedisModuleCtx *ctx, RedisModuleInfoFunc cb) {
    ctx->module->info_cb = cb;
    return REDISMODULE_OK;
}",10279.0,10282.0,1.0,11.0,4.0,3,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,int
3192,191405,modulesCollectInfo,1,modulesCollectInfo,"sds modulesCollectInfo (sds,dict*,int,int)",module.c,"sds modulesCollectInfo(sds info, dict *sections_dict, int for_crash_report, int sections) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!module->info_cb)
            continue;
        RedisModuleInfoCtx info_ctx = {module, sections_dict, info, sections, 0, 0};
        module->info_cb(&info_ctx, for_crash_report);
        /* Implicitly end dicts (no way to handle errors, and we must add the newline). */
        if (info_ctx.in_dict_field)
            RM_InfoEndDictField(&info_ctx);
        info = info_ctx.info;
        sections = info_ctx.sections;
    }
    dictReleaseIterator(di);
    return info;
}",10284.0,10302.0,1.0,1.0,19.0,16,7,24,10,2,11,5,6,3,5,,0,9,8,4,4,sds
3193,191478,RM_GetServerInfo,1,RM_GetServerInfo,"RedisModuleServerInfoData RM_GetServerInfo (RedisModuleCtx*,char*)",module.c,"RedisModuleServerInfoData *RM_GetServerInfo(RedisModuleCtx *ctx, const char *section) {
    struct RedisModuleServerInfoData *d = zmalloc(sizeof(*d));
    d->rax = raxNew();
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_INFO,d);
    int all = 0, everything = 0;
    robj *argv[1];
    argv[0] = section ? createStringObject(section, strlen(section)) : NULL;
    dict *section_dict = genInfoSectionDict(argv, section ? 1 : 0, NULL, &all, &everything);
    sds info = genRedisInfoString(section_dict, all, everything);
    int totlines, i;
    sds *lines = sdssplitlen(info, sdslen(info), ""\r\n"", 2, &totlines);
    for(i=0; i<totlines; i++) {
        sds line = lines[i];
        if (line[0]=='#') continue;
        char *sep = strchr(line, ':');
        if (!sep) continue;
        unsigned char *key = (unsigned char*)line;
        size_t keylen = (intptr_t)sep-(intptr_t)line;
        sds val = sdsnewlen(sep+1,sdslen(line)-((intptr_t)sep-(intptr_t)line)-1);
        if (!raxTryInsert(d-...",10310.0,10337.0,1.0,39.0,28.0,43,14,61,17,0,18,9,10,2,16,,0,12,4,2,2,RedisModuleServerInfoData
3194,191689,RM_ServerInfoGetField,1,RM_ServerInfoGetField,"robj RM_ServerInfoGetField (RedisModuleCtx*,RedisModuleServerInfoData*,char*)",module.c,"RedisModuleString *RM_ServerInfoGetField(RedisModuleCtx *ctx, RedisModuleServerInfoData *data, const char* field) {
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) return NULL;
    RedisModuleString *o = createStringObject(val,sdslen(val));
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",10352.0,10358.0,1.0,17.0,7.0,6,5,15,7,0,5,3,3,0,4,,0,4,6,3,3,robj
3195,191737,RM_ServerInfoGetFieldC,1,RM_ServerInfoGetFieldC,"const char* RM_ServerInfoGetFieldC (RedisModuleServerInfoData*,char*)",module.c,"const char *RM_ServerInfoGetFieldC(RedisModuleServerInfoData *data, const char* field) {
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) return NULL;
    return val;
}",10361.0,10365.0,1.0,1.0,5.0,4,4,8,5,0,2,2,2,0,1,,0,2,4,2,2,const char*
3196,191764,RM_ServerInfoGetFieldSigned,1,RM_ServerInfoGetFieldSigned,"long long RM_ServerInfoGetFieldSigned (RedisModuleServerInfoData*,char*,int*)",module.c,"long long RM_ServerInfoGetFieldSigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    long long ll;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2ll(val,sdslen(val),&ll)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return ll;
}",10370.0,10383.0,1.0,32.0,14.0,12,7,16,6,0,4,6,8,2,3,,0,4,6,3,3,long long
3197,191831,RM_ServerInfoGetFieldUnsigned,1,RM_ServerInfoGetFieldUnsigned,"unsigned long long RM_ServerInfoGetFieldUnsigned (RedisModuleServerInfoData*,char*,int*)",module.c,"unsigned long long RM_ServerInfoGetFieldUnsigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    unsigned long long ll;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2ull(val,&ll)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return ll;
}",10388.0,10401.0,1.0,32.0,14.0,12,7,15,6,0,3,6,8,1,2,,0,3,6,3,3,unsigned long long
3198,191896,RM_ServerInfoGetFieldDouble,1,RM_ServerInfoGetFieldDouble,"double RM_ServerInfoGetFieldDouble (RedisModuleServerInfoData*,char*,int*)",module.c,"double RM_ServerInfoGetFieldDouble(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    double dbl;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2d(val,sdslen(val),&dbl)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return dbl;
}",10406.0,10419.0,1.0,32.0,14.0,12,7,16,6,0,4,6,8,2,3,,0,4,6,3,3,double
3199,191963,RM_GetRandomBytes,1,RM_GetRandomBytes,"void RM_GetRandomBytes (unsigned char*,size_t)",module.c,"void RM_GetRandomBytes(unsigned char *dst, size_t len) {
    getRandomBytes(dst,len);
}",10429.0,10431.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
3200,191972,RM_GetRandomHexChars,1,RM_GetRandomHexChars,"void RM_GetRandomHexChars (char*,size_t)",module.c,"void RM_GetRandomHexChars(char *dst, size_t len) {
    getRandomHexChars(dst,len);
}",10436.0,10438.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
3201,191981,RM_ExportSharedAPI,1,RM_ExportSharedAPI,"int RM_ExportSharedAPI (RedisModuleCtx*,char*,void*)",module.c,"int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
    RedisModuleSharedAPI *sapi = zmalloc(sizeof(*sapi));
    sapi->module = ctx->module;
    sapi->func = func;
    if (dictAdd(server.sharedapi, (char*)apiname, sapi) != DICT_OK) {
        zfree(sapi);
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",10456.0,10465.0,1.0,59.0,10.0,11,7,10,5,0,6,2,2,1,3,,0,5,6,3,3,int
3202,192031,RM_GetSharedAPI,1,RM_GetSharedAPI,"void* RM_GetSharedAPI (RedisModuleCtx*,char*)",module.c,"void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
    dictEntry *de = dictFind(server.sharedapi, apiname);
    if (de == NULL) return NULL;
    RedisModuleSharedAPI *sapi = dictGetVal(de);
    if (listSearchKey(sapi->module->usedby,ctx->module) == NULL) {
        listAddNodeTail(sapi->module->usedby,ctx->module);
        listAddNodeTail(ctx->module->using,sapi->module);
    }
    return sapi->func;
}",10500.0,10509.0,1.0,1.0,10.0,15,4,16,6,0,12,3,3,3,5,,0,10,4,2,2,void*
3203,192092,moduleUnregisterSharedAPI,1,moduleUnregisterSharedAPI,int moduleUnregisterSharedAPI (RedisModule*),module.c,"int moduleUnregisterSharedAPI(RedisModule *module) {
    int count = 0;
    dictIterator *di = dictGetSafeIterator(server.sharedapi);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        const char *apiname = dictGetKey(de);
        RedisModuleSharedAPI *sapi = dictGetVal(de);
        if (sapi->module == module) {
            dictDelete(server.sharedapi,apiname);
            zfree(sapi);
            count++;
        }
    }
    dictReleaseIterator(di);
    return count;
}",10517.0,10532.0,1.0,1.0,16.0,11,6,18,8,2,8,3,4,2,7,,0,5,2,1,1,int
3204,192147,moduleUnregisterUsedAPI,1,moduleUnregisterUsedAPI,int moduleUnregisterUsedAPI (RedisModule*),module.c,"int moduleUnregisterUsedAPI(RedisModule *module) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(module->using,&li);
    while((ln = listNext(&li))) {
        RedisModule *used = ln->value;
        listNode *ln = listSearchKey(used->usedby,module);
        if (ln) {
            listDelNode(used->usedby,ln);
            count++;
        }
    }
    return count;
}",10538.0,10553.0,1.0,1.0,16.0,11,4,15,5,2,8,3,4,1,4,,0,6,2,1,1,int
3205,192197,moduleUnregisterFilters,1,moduleUnregisterFilters,int moduleUnregisterFilters (RedisModule*),module.c,"int moduleUnregisterFilters(RedisModule *module) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(module->filters,&li);
    while((ln = listNext(&li))) {
        RedisModuleCommandFilter *filter = ln->value;
        listNode *ln = listSearchKey(moduleCommandFilters,filter);
        if (ln) {
            listDelNode(moduleCommandFilters,ln);
            count++;
        }
        zfree(filter);
    }
    return count;
}",10559.0,10575.0,1.0,1.0,17.0,9,4,16,6,1,9,3,4,1,5,,0,6,2,1,1,int
3206,192245,RM_RegisterCommandFilter,1,RM_RegisterCommandFilter,"RedisModuleCommandFilter RM_RegisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilterFunc,int)",module.c,"RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, int flags) {
    RedisModuleCommandFilter *filter = zmalloc(sizeof(*filter));
    filter->module = ctx->module;
    filter->callback = callback;
    filter->flags = flags;

    listAddNodeTail(moduleCommandFilters, filter);
    listAddNodeTail(ctx->module->filters, filter);
    return filter;
}",10632.0,10641.0,1.0,1.0,10.0,12,4,13,5,0,9,1,1,0,3,,0,7,6,3,3,RedisModuleCommandFilter
3207,192288,RM_UnregisterCommandFilter,1,RM_UnregisterCommandFilter,"int RM_UnregisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilter*)",module.c,"int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) {
    listNode *ln;

    /* A module can only remove its own filters */
    if (filter->module != ctx->module) return REDISMODULE_ERR;

    ln = listSearchKey(moduleCommandFilters,filter);
    if (!ln) return REDISMODULE_ERR;
    listDelNode(moduleCommandFilters,ln);

    ln = listSearchKey(ctx->module->filters,filter);
    if (!ln) return REDISMODULE_ERR;    /* Shouldn't happen */
    listDelNode(ctx->module->filters,ln);

    zfree(filter);

    return REDISMODULE_OK;
}",10645.0,10662.0,1.0,46.0,18.0,11,4,15,4,0,11,4,4,2,5,,0,8,4,2,2,int
3208,192354,moduleCallCommandFilters,1,moduleCallCommandFilters,void moduleCallCommandFilters (client*),module.c,"void moduleCallCommandFilters(client *c) {
    if (listLength(moduleCommandFilters) == 0) return;

    listIter li;
    listNode *ln;
    listRewind(moduleCommandFilters,&li);

    RedisModuleCommandFilterCtx filter = {
        .argv = c->argv,
        .argv_len = c->argv_len,
        .argc = c->argc,
        .c = c
    };

    while((ln = listNext(&li))) {
        RedisModuleCommandFilter *f = ln->value;

        /* Skip filter if REDISMODULE_CMDFILTER_NOSELF is set and module is
         * currently processing a command.
         */
        if ((f->flags & REDISMODULE_CMDFILTER_NOSELF) && f->module->in_call) continue;

        /* Call filter */
        f->callback(&filter);
    }

    c->argv = filter.argv;
    c->argv_len = filter.argv_len;
    c->argc = filter.argc;
}",10664.0,10693.0,1.0,8.0,30.0,33,9,27,9,3,19,5,5,6,2,,0,18,2,1,1,void
3209,192460,RM_CommandFilterArgsCount,1,RM_CommandFilterArgsCount,int RM_CommandFilterArgsCount (RedisModuleCommandFilterCtx*),module.c,"int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
{
    return fctx->argc;
}",10698.0,10701.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3210,192469,RM_CommandFilterArgGet,1,RM_CommandFilterArgGet,"robj RM_CommandFilterArgGet (RedisModuleCommandFilterCtx*,int)",module.c,"RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)
{
    if (pos < 0 || pos >= fctx->argc) return NULL;
    return fctx->argv[pos];
}",10706.0,10710.0,1.0,17.0,5.0,6,5,6,3,0,2,2,2,1,0,,0,2,4,2,2,robj
3211,192494,RM_CommandFilterArgInsert,1,RM_CommandFilterArgInsert,"int RM_CommandFilterArgInsert (RedisModuleCommandFilterCtx*,int,robj*)",module.c,"int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
{
    int i;

    if (pos < 0 || pos > fctx->argc) return REDISMODULE_ERR;

    if (fctx->argv_len < fctx->argc+1) {
        fctx->argv_len = fctx->argc+1;
        fctx->argv = zrealloc(fctx->argv, fctx->argv_len*sizeof(RedisModuleString *));
    }
    for (i = fctx->argc; i > pos; i--) {
        fctx->argv[i] = fctx->argv[i-1];
    }
    fctx->argv[pos] = arg;
    fctx->argc++;

    return REDISMODULE_OK;
}",10717.0,10734.0,1.0,74.0,18.0,32,11,23,5,0,14,4,4,3,1,,0,14,6,3,3,int
3212,192592,RM_CommandFilterArgReplace,1,RM_CommandFilterArgReplace,"int RM_CommandFilterArgReplace (RedisModuleCommandFilterCtx*,int,robj*)",module.c,"int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
{
    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;

    decrRefCount(fctx->argv[pos]);
    fctx->argv[pos] = arg;

    return REDISMODULE_OK;
}",10741.0,10749.0,1.0,75.0,9.0,9,6,8,3,0,4,2,2,1,1,,0,3,6,3,3,int
3213,192631,RM_CommandFilterArgDelete,1,RM_CommandFilterArgDelete,"int RM_CommandFilterArgDelete (RedisModuleCommandFilterCtx*,int)",module.c,"int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
{
    int i;
    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;

    decrRefCount(fctx->argv[pos]);
    for (i = pos; i < fctx->argc-1; i++) {
        fctx->argv[i] = fctx->argv[i+1];
    }
    fctx->argc--;

    return REDISMODULE_OK;
}",10754.0,10766.0,1.0,45.0,13.0,18,9,14,3,0,7,3,3,2,1,,0,6,4,2,2,int
3214,192695,RM_CommandFilterGetClientId,1,RM_CommandFilterGetClientId,unsigned long long RM_CommandFilterGetClientId (RedisModuleCommandFilterCtx*),module.c,"unsigned long long RM_CommandFilterGetClientId(RedisModuleCommandFilterCtx *fctx) {
    return fctx->c->id;
}",10769.0,10771.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned long long
3215,192706,RM_MallocSize,1,RM_MallocSize,size_t RM_MallocSize (void*),module.c,"size_t RM_MallocSize(void* ptr) {
    return zmalloc_size(ptr);
}",10779.0,10781.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
3216,192714,RM_MallocUsableSize,1,RM_MallocUsableSize,size_t RM_MallocUsableSize (void*),module.c,"size_t RM_MallocUsableSize(void *ptr) {
    /* It is safe to use 'zmalloc_usable_size()' to manipulate additional
     * memory space, as we guarantee that the compiler can recognize this
     * after 'RM_Alloc', 'RM_TryAlloc', 'RM_Realloc', or 'RM_Calloc'. */
    return zmalloc_usable_size(ptr);
}",10785.0,10790.0,1.0,1.0,6.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
3217,192722,RM_MallocSizeString,1,RM_MallocSizeString,size_t RM_MallocSizeString (robj*),module.c,"size_t RM_MallocSizeString(RedisModuleString* str) {
    serverAssert(str->type == OBJ_STRING);
    return sizeof(*str) + getStringObjectSdsUsedMemory(str);
}",10794.0,10797.0,1.0,27.0,4.0,9,9,3,1,0,2,1,1,0,2,,0,0,2,1,1,size_t
3218,192752,RM_MallocSizeDict,1,RM_MallocSizeDict,size_t RM_MallocSizeDict (RedisModuleDict*),module.c,"size_t RM_MallocSizeDict(RedisModuleDict* dict) {
    size_t size = sizeof(RedisModuleDict) + sizeof(rax);
    size += dict->rax->numnodes * sizeof(raxNode);
    /* For more info about this weird line, see streamRadixTreeMemoryUsage */
    size += dict->rax->numnodes * sizeof(long)*30;
    return size;
}",10803.0,10809.0,1.0,1.0,7.0,15,6,10,6,0,2,1,1,0,0,,0,2,2,1,1,size_t
3219,192789,RM_GetUsedMemoryRatio,1,RM_GetUsedMemoryRatio,float RM_GetUsedMemoryRatio (void),module.c,"float RM_GetUsedMemoryRatio(void){
    float level;
    getMaxmemoryState(NULL, NULL, NULL, &level);
    return level;
}",10819.0,10823.0,1.0,1.0,5.0,1,1,5,2,0,1,1,1,0,1,,0,0,2,1,1,float
3220,192820,moduleScanCallback,1,moduleScanCallback,"void moduleScanCallback (void*,dictEntry*)",module.c,"static void moduleScanCallback(void *privdata, const dictEntry *de) {
    ScanCBData *data = privdata;
    sds key = dictGetKey(de);
    robj* val = dictGetVal(de);
    RedisModuleString *keyname = createObject(OBJ_STRING,sdsdup(key));

    /* Setup the key handle. */
    RedisModuleKey kp = {0};
    moduleInitKey(&kp, data->ctx, keyname, val, REDISMODULE_READ);

    data->fn(data->ctx, keyname, &kp, data->user_data);

    moduleCloseKey(&kp);
    decrRefCount(keyname);
}",10841.0,10855.0,1.0,4.0,15.0,14,5,20,7,0,11,1,1,0,7,,0,8,4,2,2,void
3221,192885,RM_ScanCursorCreate,1,RM_ScanCursorCreate,RedisModuleScanCursor RM_ScanCursorCreate (void),module.c,"RedisModuleScanCursor *RM_ScanCursorCreate(void) {
    RedisModuleScanCursor* cursor = zmalloc(sizeof(*cursor));
    cursor->cursor = 0;
    cursor->done = 0;
    return cursor;
}",10858.0,10863.0,1.0,1.0,6.0,7,4,5,1,0,3,1,1,0,1,,0,3,2,1,1,RedisModuleScanCursor
3222,192909,RM_ScanCursorRestart,1,RM_ScanCursorRestart,void RM_ScanCursorRestart (RedisModuleScanCursor*),module.c,"void RM_ScanCursorRestart(RedisModuleScanCursor *cursor) {
    cursor->cursor = 0;
    cursor->done = 0;
}",10866.0,10869.0,1.0,1.0,4.0,4,2,2,1,0,2,1,1,0,0,,0,2,2,1,1,void
3223,192924,RM_ScanCursorDestroy,1,RM_ScanCursorDestroy,void RM_ScanCursorDestroy (RedisModuleScanCursor*),module.c,"void RM_ScanCursorDestroy(RedisModuleScanCursor *cursor) {
    zfree(cursor);
}",10872.0,10874.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3224,192931,RM_Scan,1,RM_Scan,"int RM_Scan (RedisModuleCtx*,RedisModuleScanCursor*,RedisModuleScanCB,void*)",module.c,"int RM_Scan(RedisModuleCtx *ctx, RedisModuleScanCursor *cursor, RedisModuleScanCB fn, void *privdata) {
    if (cursor->done) {
        errno = ENOENT;
        return 0;
    }
    int ret = 1;
    ScanCBData data = { ctx, privdata, fn };
    cursor->cursor = dictScan(ctx->client->db->dict, cursor->cursor, moduleScanCallback, &data);
    if (cursor->cursor == 0) {
        cursor->done = 1;
        ret = 0;
    }
    errno = 0;
    return ret;
}",10932.0,10946.0,1.0,1.0,15.0,18,5,17,8,0,7,3,3,2,1,,0,7,8,4,4,int
3225,193011,moduleScanKeyCallback,1,moduleScanKeyCallback,"void moduleScanKeyCallback (void*,dictEntry*)",module.c,"static void moduleScanKeyCallback(void *privdata, const dictEntry *de) {
    ScanKeyCBData *data = privdata;
    sds key = dictGetKey(de);
    robj *o = data->key->value;
    robj *field = createStringObject(key, sdslen(key));
    robj *value = NULL;
    if (o->type == OBJ_SET) {
        value = NULL;
    } else if (o->type == OBJ_HASH) {
        sds val = dictGetVal(de);
        value = createStringObject(val, sdslen(val));
    } else if (o->type == OBJ_ZSET) {
        double *val = (double*)dictGetVal(de);
        value = createStringObjectFromLongDouble(*val, 0);
    }

    data->fn(data->key, field, value, data->user_data);
    decrRefCount(field);
    if (value) decrRefCount(value);
}",10955.0,10974.0,1.0,19.0,20.0,13,3,22,8,0,9,3,3,0,5,,0,7,4,2,2,void
3226,193122,RM_ScanKey,1,RM_ScanKey,"int RM_ScanKey (RedisModuleKey*,RedisModuleScanCursor*,RedisModuleScanKeyCB,void*)",module.c,"int RM_ScanKey(RedisModuleKey *key, RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, void *privdata) {
    if (key == NULL || key->value == NULL) {
        errno = EINVAL;
        return 0;
    }
    dict *ht = NULL;
    robj *o = key->value;
    if (o->type == OBJ_SET) {
        if (o->encoding == OBJ_ENCODING_HT)
            ht = o->ptr;
    } else if (o->type == OBJ_HASH) {
        if (o->encoding == OBJ_ENCODING_HT)
            ht = o->ptr;
    } else if (o->type == OBJ_ZSET) {
        if (o->encoding == OBJ_ENCODING_SKIPLIST)
            ht = ((zset *)o->ptr)->dict;
    } else {
        errno = EINVAL;
        return 0;
    }
    if (cursor->done) {
        errno = ENOENT;
        return 0;
    }
    int ret = 1;
    if (ht) {
        ScanKeyCBData data = { key, privdata, fn };
        cursor->cursor = dictScan(ht, cursor->cursor, moduleScanKeyCallback, &data);
        if (cursor->cursor == 0) {
            cursor->done = 1;
            ret = 0;
        }
    } else if (...",11024.0,11094.0,1.0,19.0,71.0,29,6,32,12,0,8,7,9,3,1,,0,8,8,4,4,int
3227,193464,RM_Fork,1,RM_Fork,"int RM_Fork (RedisModuleForkDoneHandler,void*)",module.c,"int RM_Fork(RedisModuleForkDoneHandler cb, void *user_data) {
    pid_t childpid;

    if ((childpid = redisFork(CHILD_TYPE_MODULE)) == 0) {
        /* Child */
        redisSetProcTitle(""redis-module-fork"");
    } else if (childpid == -1) {
        serverLog(LL_WARNING,""Can't fork for module: %s"", strerror(errno));
    } else {
        /* Parent */
        moduleForkInfo.done_handler = cb;
        moduleForkInfo.done_handler_user_data = user_data;
        serverLog(LL_VERBOSE, ""Module fork started pid: %ld "", (long) childpid);
    }
    return childpid;
}",11112.0,11127.0,1.0,30.0,16.0,2,2,2,1,0,2,2,2,1,2,,0,1,4,2,2,int
3228,193546,RM_SendChildHeartbeat,1,RM_SendChildHeartbeat,void RM_SendChildHeartbeat (double),module.c,"void RM_SendChildHeartbeat(double progress) {
    sendChildInfoGeneric(CHILD_INFO_TYPE_CURRENT_INFO, 0, progress, ""Module fork"");
}",11133.0,11135.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
3229,193556,RM_ExitFromChild,1,RM_ExitFromChild,int RM_ExitFromChild (int),module.c,"int RM_ExitFromChild(int retcode) {
    sendChildCowInfo(CHILD_INFO_TYPE_MODULE_COW_SIZE, ""Module fork"");
    exitFromChild(retcode);
    return REDISMODULE_OK;
}",11140.0,11144.0,1.0,11.0,5.0,0,0,2,2,0,2,1,1,0,2,,0,0,2,1,1,int
3230,193570,TerminateModuleForkChild,1,TerminateModuleForkChild,"int TerminateModuleForkChild (int,int)",module.c,"int TerminateModuleForkChild(int child_pid, int wait) {
    /* Module child should be active and pid should match. */
    if (server.child_type != CHILD_TYPE_MODULE ||
        server.child_pid != child_pid) return C_ERR;

    int statloc;
    serverLog(LL_VERBOSE,""Killing running module fork child: %ld"",
        (long) server.child_pid);
    if (kill(server.child_pid,SIGUSR1) != -1 && wait) {
        while(waitpid(server.child_pid, &statloc, 0) !=
              server.child_pid);
    }
    /* Reset the buffer accumulating changes while the child saves. */
    resetChildState();
    moduleForkInfo.done_handler = NULL;
    moduleForkInfo.done_handler_user_data = NULL;
    return C_OK;
}",11149.0,11166.0,1.0,29.0,18.0,23,10,15,7,1,6,4,5,0,2,,0,4,4,2,2,int
3231,193659,RM_KillForkChild,1,RM_KillForkChild,int RM_KillForkChild (int),module.c,"int RM_KillForkChild(int child_pid) {
    /* Kill module child, wait for child exit. */
    if (TerminateModuleForkChild(child_pid,1) == C_OK)
        return REDISMODULE_OK;
    else
        return REDISMODULE_ERR;
}",11170.0,11176.0,1.0,49.0,7.0,1,1,1,1,0,1,2,2,1,1,,0,1,2,1,1,int
3232,193683,ModuleForkDoneHandler,1,ModuleForkDoneHandler,"void ModuleForkDoneHandler (int,int)",module.c,"void ModuleForkDoneHandler(int exitcode, int bysignal) {
    serverLog(LL_NOTICE,
        ""Module fork exited pid: %ld, retcode: %d, bysignal: %d"",
        (long) server.child_pid, exitcode, bysignal);
    if (moduleForkInfo.done_handler) {
        moduleForkInfo.done_handler(exitcode, bysignal,
            moduleForkInfo.done_handler_user_data);
    }

    moduleForkInfo.done_handler = NULL;
    moduleForkInfo.done_handler_user_data = NULL;
}",11178.0,11189.0,1.0,4.0,12.0,12,5,13,5,0,11,2,2,2,1,,0,10,4,2,2,void
3233,193786,RM_SubscribeToServerEvent,1,RM_SubscribeToServerEvent,"int RM_SubscribeToServerEvent (RedisModuleCtx*,RedisModuleEvent,RedisModuleEventCallback)",module.c,"int RM_SubscribeToServerEvent(RedisModuleCtx *ctx, RedisModuleEvent event, RedisModuleEventCallback callback) {
    RedisModuleEventListener *el;

    /* Protect in case of calls from contexts without a module reference. */
    if (ctx->module == NULL) return REDISMODULE_ERR;
    if (event.id >= _REDISMODULE_EVENT_NEXT) return REDISMODULE_ERR;
    if (event.dataver > moduleEventVersions[event.id]) return REDISMODULE_ERR; /* Module compiled with a newer redismodule.h than we support */

    /* Search an event matching this module and event ID. */
    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);
    while((ln = listNext(&li))) {
        el = ln->value;
        if (el->module == ctx->module && el->event.id == event.id)
            break; /* Matching event found. */
    }

    /* Modify or remove the event listener if we already had one. */
    if (ln) {
        if (callback == NULL) {
            listDelNode(RedisModule_EventListeners,ln);
            ...",11511.0,11547.0,1.0,36.0,37.0,32,11,32,9,0,23,9,10,10,6,,0,19,6,3,3,int
3234,193925,RM_IsSubEventSupported,1,RM_IsSubEventSupported,"int RM_IsSubEventSupported (RedisModuleEvent,int64_t)",module.c,"int RM_IsSubEventSupported(RedisModuleEvent event, int64_t subevent) {
    switch (event.id) {
    case REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED:
        return subevent < _REDISMODULE_EVENT_REPLROLECHANGED_NEXT;
    case REDISMODULE_EVENT_PERSISTENCE:
        return subevent < _REDISMODULE_SUBEVENT_PERSISTENCE_NEXT;
    case REDISMODULE_EVENT_FLUSHDB:
        return subevent < _REDISMODULE_SUBEVENT_FLUSHDB_NEXT;
    case REDISMODULE_EVENT_LOADING:
        return subevent < _REDISMODULE_SUBEVENT_LOADING_NEXT;
    case REDISMODULE_EVENT_CLIENT_CHANGE:
        return subevent < _REDISMODULE_SUBEVENT_CLIENT_CHANGE_NEXT;
    case REDISMODULE_EVENT_SHUTDOWN:
        return subevent < _REDISMODULE_SUBEVENT_SHUTDOWN_NEXT;
    case REDISMODULE_EVENT_REPLICA_CHANGE:
        return subevent < _REDISMODULE_EVENT_REPLROLECHANGED_NEXT;
    case REDISMODULE_EVENT_MASTER_LINK_CHANGE:
        return subevent < _REDISMODULE_SUBEVENT_MASTER_NEXT;
    case REDISMODULE_EVENT_CRON_LOOP:
        return...",11553.0,11593.0,1.0,9.0,41.0,18,2,18,2,0,1,3,2,1,0,,0,1,4,2,2,int
3235,194116,moduleFireServerEvent,1,moduleFireServerEvent,"void moduleFireServerEvent (uint64_t,int,void*)",module.c,"void moduleFireServerEvent(uint64_t eid, int subid, void *data) {
    /* Fast path to return ASAP if there is nothing to do, avoiding to
     * setup the iterator and so forth: we want this call to be extremely
     * cheap if there are no registered modules. */
    if (listLength(RedisModule_EventListeners) == 0) return;

    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);
    while((ln = listNext(&li))) {
        RedisModuleEventListener *el = ln->value;
        if (el->event.id == eid) {
            RedisModuleCtx ctx;
            if (eid == REDISMODULE_EVENT_CLIENT_CHANGE) {
                /* In the case of client changes, we're pushing the real client
                 * so the event handler can mutate it if needed. For example,
                 * to change its authentication state in a way that does not
                 * depend on specific commands executed later.
                 */
                moduleCreateContext(&ctx,el->module,REDISMODUL...",11609.0,11689.0,1.0,8.0,81.0,43,12,35,13,28,20,7,14,5,7,,0,14,6,3,3,void
3236,194489,moduleUnsubscribeAllServerEvents,1,moduleUnsubscribeAllServerEvents,void moduleUnsubscribeAllServerEvents (RedisModule*),module.c,"void moduleUnsubscribeAllServerEvents(RedisModule *module) {
    RedisModuleEventListener *el;
    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);

    while((ln = listNext(&li))) {
        el = ln->value;
        if (el->module == module) {
            listDelNode(RedisModule_EventListeners,ln);
            zfree(el);
        }
    }
}",11693.0,11706.0,1.0,1.0,14.0,7,4,11,5,1,8,3,4,2,4,,0,5,2,1,1,void
3237,194525,processModuleLoadingProgressEvent,1,processModuleLoadingProgressEvent,void processModuleLoadingProgressEvent (int),module.c,"void processModuleLoadingProgressEvent(int is_aof) {
    long long now = server.ustime;
    static long long next_event = 0;
    if (now >= next_event) {
        /* Fire the loading progress modules end event. */
        int progress = -1;
        if (server.loading_total_bytes)
            progress = (server.loading_loaded_bytes<<10) / server.loading_total_bytes;
        RedisModuleLoadingProgressV1 fi = {REDISMODULE_LOADING_PROGRESS_VERSION,
                                     server.hz,
                                     progress};
        moduleFireServerEvent(REDISMODULE_EVENT_LOADING_PROGRESS,
                              is_aof?
                                REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF:
                                REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB,
                              &fi);
        /* decide when the next event should fire. */
        next_event = now + 1000000 / server.hz;
    }
}",11708.0,11727.0,1.0,43.0,20.0,21,10,18,6,2,1,3,4,0,1,,0,0,2,1,1,void
3238,194600,moduleNotifyKeyUnlink,1,moduleNotifyKeyUnlink,"void moduleNotifyKeyUnlink (robj*,robj*,int,int)",module.c,"void moduleNotifyKeyUnlink(robj *key, robj *val, int dbid, int flags) {
    server.lazy_expire_disabled++;
    int subevent = REDISMODULE_SUBEVENT_KEY_DELETED;
    if (flags & DB_FLAG_KEY_EXPIRED) {
        subevent = REDISMODULE_SUBEVENT_KEY_EXPIRED;
    } else if (flags & DB_FLAG_KEY_EVICTED) {
        subevent = REDISMODULE_SUBEVENT_KEY_EVICTED;
    } else if (flags & DB_FLAG_KEY_OVERWRITE) {
        subevent = REDISMODULE_SUBEVENT_KEY_OVERWRITTEN;
    }
    KeyInfo info = {dbid, key, val, REDISMODULE_READ};
    moduleFireServerEvent(REDISMODULE_EVENT_KEY, subevent, &info);

    if (val->type == OBJ_MODULE) {
        moduleValue *mv = val->ptr;
        moduleType *mt = mv->type;
        /* We prefer to use the enhanced version. */
        if (mt->unlink2 != NULL) {
            RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
            mt->unlink2(&ctx,mv->value);
        } else if (mt->unlink != NULL) {
            mt->unlink(key,mv->value);
        }
    }
    server.lazy_exp...",11731.0,11756.0,1.0,19.0,26.0,26,12,25,11,1,3,4,5,0,1,,0,2,8,4,4,void
3239,194750,moduleGetFreeEffort,1,moduleGetFreeEffort,"size_t moduleGetFreeEffort (robj*,robj*,int)",module.c,"size_t moduleGetFreeEffort(robj *key, robj *val, int dbid) {
    moduleValue *mv = val->ptr;
    moduleType *mt = mv->type;
    size_t effort = 1;
    /* We prefer to use the enhanced version. */
    if (mt->free_effort2 != NULL) {
        RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
        effort = mt->free_effort2(&ctx,mv->value);
    } else if (mt->free_effort != NULL) {
        effort = mt->free_effort(key,mv->value);
    }  

    return effort;
}",11761.0,11774.0,1.0,1.0,14.0,14,6,16,8,1,2,2,2,0,0,,0,2,6,3,3,size_t
3240,194821,moduleGetMemUsage,1,moduleGetMemUsage,"size_t moduleGetMemUsage (robj*,robj*,size_t,int)",module.c,"size_t moduleGetMemUsage(robj *key, robj *val, size_t sample_size, int dbid) {
    moduleValue *mv = val->ptr;
    moduleType *mt = mv->type;
    size_t size = 0;
    /* We prefer to use the enhanced version. */
    if (mt->mem_usage2 != NULL) {
        RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
        size = mt->mem_usage2(&ctx, mv->value, sample_size);
    } else if (mt->mem_usage != NULL) {
        size = mt->mem_usage(mv->value);
    } 

    return size;
}",11778.0,11791.0,1.0,1.0,14.0,14,6,17,9,0,2,2,2,0,0,,0,2,8,4,4,size_t
3241,194893,dictCStringKeyHash,1,dictCStringKeyHash,uint64_t dictCStringKeyHash (void*),module.c,"uint64_t dictCStringKeyHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
}",11800.0,11802.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
3242,194937,moduleRegisterApi,1,moduleRegisterApi,"int moduleRegisterApi (char*,void*)",module.c,"int moduleRegisterApi(const char *funcname, void *funcptr) {
    return dictAdd(server.moduleapi, (char*)funcname, funcptr);
}",11819.0,11821.0,1.0,1.0,3.0,2,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
3243,194952,moduleRegisterCoreAPI,1,moduleRegisterCoreAPI,void moduleRegisterCoreAPI (void),module.c,"void moduleRegisterCoreAPI(void) {
    server.moduleapi = dictCreate(&moduleAPIDictType);
    server.sharedapi = dictCreate(&moduleAPIDictType);
    REGISTER_API(Alloc);
    REGISTER_API(TryAlloc);
    REGISTER_API(Calloc);
    REGISTER_API(Realloc);
    REGISTER_API(Free);
    REGISTER_API(Strdup);
    REGISTER_API(CreateCommand);
    REGISTER_API(GetCommand);
    REGISTER_API(CreateSubcommand);
    REGISTER_API(SetCommandInfo);
    REGISTER_API(SetCommandACLCategories);
    REGISTER_API(SetModuleAttribs);
    REGISTER_API(IsModuleNameBusy);
    REGISTER_API(WrongArity);
    REGISTER_API(ReplyWithLongLong);
    REGISTER_API(ReplyWithError);
    REGISTER_API(ReplyWithErrorFormat);
    REGISTER_API(ReplyWithSimpleString);
    REGISTER_API(ReplyWithArray);
    REGISTER_API(ReplyWithMap);
    REGISTER_API(ReplyWithSet);
    REGISTER_API(ReplyWithAttribute);
    REGISTER_API(ReplyWithNullArray);
    REGISTER_API(ReplyWithEmptyArray);
    REGISTER_API(ReplySetArrayLength);
    REGISTER_A...",13494.0,13849.0,1.0,4.0,356.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3244,194973,moduleInitModulesSystem,1,moduleInitModulesSystem,void moduleInitModulesSystem (void),module.c,"void moduleInitModulesSystem(void) {
    moduleUnblockedClients = listCreate();
    server.loadmodule_queue = listCreate();
    server.module_configs_queue = dictCreate(&sdsKeyValueHashDictType);
    modules = dictCreate(&modulesDictType);
    moduleAuthCallbacks = listCreate();

    /* Set up the keyspace notification subscriber list and static client */
    moduleKeyspaceSubscribers = listCreate();

    modulePostExecUnitJobs = listCreate();

    /* Set up filter list */
    moduleCommandFilters = listCreate();

    moduleRegisterCoreAPI();

    /* Create a pipe for module threads to be able to wake up the redis main thread.
     * Make the pipe non blocking. This is just a best effort aware mechanism
     * and we do not want to block not in the read nor in the write half.
     * Enable close-on-exec flag on pipes in case of the fork-exec system calls in
     * sentinels or redis servers. */
    if (anetPipe(server.module_pipe, O_CLOEXEC|O_NONBLOCK, O_CLOEXEC|O_NONBLOCK) == -1) {...",11847.0,11887.0,1.0,8.0,41.0,32,15,22,16,0,26,2,2,1,14,,0,23,2,1,1,void
3245,195079,modulesCron,1,modulesCron,void modulesCron (void),module.c,"void modulesCron(void) {
    /* Check number of temporary clients in the pool and free the unused ones
     * since the last cron. moduleTempClientMinCount tracks minimum count of
     * clients in the pool since the last cron. This is the number of clients
     * that we didn't use for the last cron period. */

    /* Limit the max client count to be freed at once to avoid latency spikes.*/
    int iteration = 50;
    /* We are freeing clients if we have more than 8 unused clients. Keeping
     * small amount of clients to avoid client allocation costs if temporary
     * clients are required after some idle period. */
    const unsigned int min_client = 8;
    while (iteration > 0 && moduleTempClientCount > 0 && moduleTempClientMinCount > min_client) {
        client *c = moduleTempClients[--moduleTempClientCount];
        freeClient(c);
        iteration--;
        moduleTempClientMinCount--;
    }
    moduleTempClientMinCount = moduleTempClientCount;

    /* Shrink moduleTempCli...",11889.0,11914.0,1.0,1.0,26.0,21,9,22,8,1,16,3,3,5,2,,0,15,2,1,1,void
3246,195143,moduleLoadQueueEntryFree,1,moduleLoadQueueEntryFree,void moduleLoadQueueEntryFree (moduleLoadQueueEntry*),module.c,"void moduleLoadQueueEntryFree(struct moduleLoadQueueEntry *loadmod) {
    if (!loadmod) return;
    sdsfree(loadmod->path);
    for (int i = 0; i < loadmod->argc; i++) {
        decrRefCount(loadmod->argv[i]);
    }
    zfree(loadmod->argv);
    zfree(loadmod);
}",11916.0,11924.0,1.0,1.0,9.0,8,5,9,2,2,8,3,3,1,4,,0,4,2,1,1,void
3247,195183,moduleRemoveConfigs,1,moduleRemoveConfigs,void moduleRemoveConfigs (RedisModule*),module.c,"void moduleRemoveConfigs(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(module->module_configs, &li);
    while ((ln = listNext(&li))) {
        ModuleConfig *config = listNodeValue(ln);
        sds module_name = sdsnew(module->name);
        sds full_name = sdscat(sdscat(module_name, "".""), config->name); /* ModuleName.ModuleConfig */
        removeConfig(full_name);
        sdsfree(full_name);
    }
}",11927.0,11938.0,1.0,31.0,12.0,10,3,14,6,2,11,2,2,1,7,,0,8,2,1,1,void
3248,195233,moduleLoadFromQueue,1,moduleLoadFromQueue,void moduleLoadFromQueue (void),module.c,"void moduleLoadFromQueue(void) {
    listIter li;
    listNode *ln;

    listRewind(server.loadmodule_queue,&li);
    while((ln = listNext(&li))) {
        struct moduleLoadQueueEntry *loadmod = ln->value;
        if (moduleLoad(loadmod->path,(void **)loadmod->argv,loadmod->argc, 0)
            == C_ERR)
        {
            serverLog(LL_WARNING,
                ""Can't load module from %s: server aborting"",
                loadmod->path);
            exit(1);
        }
        moduleLoadQueueEntryFree(loadmod);
        listDelNode(server.loadmodule_queue, ln);
    }
    if (dictSize(server.module_configs_queue)) {
        serverLog(LL_WARNING, ""Module Configuration detected without loadmodule directive or no ApplyConfig call: aborting"");
        exit(1);
    }
}",11949.0,11971.0,1.0,15.0,23.0,28,11,18,4,0,12,4,5,5,7,,0,7,2,1,1,void
3249,195351,moduleFreeModuleStructure,1,moduleFreeModuleStructure,void moduleFreeModuleStructure (RedisModule*),module.c,"void moduleFreeModuleStructure(struct RedisModule *module) {
    listRelease(module->types);
    listRelease(module->filters);
    listRelease(module->usedby);
    listRelease(module->using);
    listRelease(module->module_configs);
    sdsfree(module->name);
    moduleLoadQueueEntryFree(module->loadmod);
    zfree(module);
}",11973.0,11982.0,1.0,1.0,10.0,7,1,8,1,2,15,1,1,0,8,,0,7,2,1,1,void
3250,195386,moduleFreeArgs,1,moduleFreeArgs,"void moduleFreeArgs (redisCommandArg*,int)",module.c,"void moduleFreeArgs(struct redisCommandArg *args, int num_args) {
    for (int j = 0; j < num_args; j++) {
        zfree((char *)args[j].name);
        zfree((char *)args[j].token);
        zfree((char *)args[j].summary);
        zfree((char *)args[j].since);
        zfree((char *)args[j].deprecated_since);
        zfree((char *)args[j].display_text);

        if (args[j].subargs) {
            moduleFreeArgs(args[j].subargs, args[j].num_args);
        }
    }
    zfree(args);
}",11984.0,11998.0,1.0,1.0,15.0,26,5,22,3,1,7,3,4,0,7,,0,0,4,2,2,void
3251,195472,moduleFreeCommand,1,moduleFreeCommand,"int moduleFreeCommand (RedisModule*,redisCommand*)",module.c,"int moduleFreeCommand(struct RedisModule *module, struct redisCommand *cmd) {
    if (cmd->proc != RedisModuleCommandDispatcher)
        return C_ERR;

    RedisModuleCommand *cp = cmd->module_cmd;
    if (cp->module != module)
        return C_ERR;

    /* Free everything except cmd->fullname and cmd itself. */
    for (int j = 0; j < cmd->key_specs_num; j++) {
        if (cmd->key_specs[j].notes)
            zfree((char *)cmd->key_specs[j].notes);
        if (cmd->key_specs[j].begin_search_type == KSPEC_BS_KEYWORD)
            zfree((char *)cmd->key_specs[j].bs.keyword.keyword);
    }
    zfree(cmd->key_specs);
    for (int j = 0; cmd->tips && cmd->tips[j]; j++)
        zfree((char *)cmd->tips[j]);
    zfree(cmd->tips);
    for (int j = 0; cmd->history && cmd->history[j].since; j++) {
        zfree((char *)cmd->history[j].since);
        zfree((char *)cmd->history[j].changes);
    }
    zfree(cmd->history);
    zfree((char *)cmd->summary);
    zfree((char *)cmd->since);
    zfree(...",12006.0,12058.0,1.0,15.0,53.0,82,13,60,9,1,56,13,17,12,23,,0,36,4,2,2,int
3252,195770,moduleUnregisterCommands,1,moduleUnregisterCommands,void moduleUnregisterCommands (RedisModule*),module.c,"void moduleUnregisterCommands(struct RedisModule *module) {
    /* Unregister all the commands registered by this module. */
    dictIterator *di = dictGetSafeIterator(server.commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (moduleFreeCommand(module, cmd) != C_OK) continue;

        serverAssert(dictDelete(server.commands, cmd->fullname) == DICT_OK);
        serverAssert(dictDelete(server.orig_commands, cmd->fullname) == DICT_OK);
        sdsfree((sds)cmd->declared_name);
        sdsfree(cmd->fullname);
        zfree(cmd);
    }
    dictReleaseIterator(di);
}",12060.0,12075.0,1.0,46.0,16.0,23,9,17,6,2,16,4,4,2,12,,0,8,2,1,1,void
3253,195864,parseLoadexArguments,1,parseLoadexArguments,"int parseLoadexArguments (robj***,int*)",module.c,"int parseLoadexArguments(RedisModuleString ***module_argv, int *module_argc) {
    int args_specified = 0;
    RedisModuleString **argv = *module_argv;
    int argc = *module_argc;
    for (int i = 0; i < argc; i++) {
        char *arg_val = argv[i]->ptr;
        if (!strcasecmp(arg_val, ""CONFIG"")) {
            if (i + 2 >= argc) {
                serverLog(LL_NOTICE, ""CONFIG specified without name value pair"");
                return REDISMODULE_ERR;
            }
            sds name = sdsdup(argv[i + 1]->ptr);
            sds value = sdsdup(argv[i + 2]->ptr);
            if (!dictReplace(server.module_configs_queue, name, value)) sdsfree(name);
            i += 2;
        } else if (!strcasecmp(arg_val, ""ARGS"")) {
            args_specified = 1;
            i++;
            if (i >= argc) {
                *module_argv = NULL;
                *module_argc = 0;
            } else {
                *module_argv = argv + i;
                *module_argc = argc - i;
            }
   ...",12080.0,12116.0,1.0,25.0,37.0,32,11,30,11,0,5,6,11,1,5,,0,3,4,2,2,int
3254,196059,moduleLoad,1,moduleLoad,"int moduleLoad (char*,void**,int,int)",module.c,"int moduleLoad(const char *path, void **module_argv, int module_argc, int is_loadex) {
    int (*onload)(void *, void **, int);
    void *handle;

    struct stat st;
    if (stat(path, &st) == 0) {
        /* This check is best effort */
        if (!(st.st_mode & (S_IXUSR  | S_IXGRP | S_IXOTH))) {
            serverLog(LL_WARNING, ""Module %s failed to load: It does not have execute permissions."", path);
            return C_ERR;
        }
    }

    handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);
    if (handle == NULL) {
        serverLog(LL_WARNING, ""Module %s failed to load: %s"", path, dlerror());
        return C_ERR;
    }
    onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,""RedisModule_OnLoad"");
    if (onload == NULL) {
        dlclose(handle);
        serverLog(LL_WARNING,
            ""Module %s does not export RedisModule_OnLoad() ""
            ""symbol. Module not loaded."",path);
        return C_ERR;
    }
    RedisModuleCtx ctx;
    moduleCreateContext(&...",12120.0,12211.0,1.0,12.0,92.0,121,18,87,20,1,53,12,14,5,26,,0,30,8,4,4,int
3255,196526,moduleUnload,1,moduleUnload,"int moduleUnload (sds,char**)",module.c,"int moduleUnload(sds name, const char **errmsg) {
    struct RedisModule *module = dictFetchValue(modules,name);

    if (module == NULL) {
        *errmsg = ""no such module with that name"";
        return C_ERR;
    } else if (listLength(module->types)) {
        *errmsg = ""the module exports one or more module-side data ""
                  ""types, can't unload"";
        return C_ERR;
    } else if (listLength(module->usedby)) {
        *errmsg = ""the module exports APIs used by other modules. ""
                  ""Please unload them first and try again"";
        return C_ERR;
    } else if (module->blocked_clients) {
        *errmsg = ""the module has blocked clients. ""
                  ""Please wait for them to be unblocked and try again"";
        return C_ERR;
    } else if (moduleHoldsTimer(module)) {
        *errmsg = ""the module holds timer that is not fired. ""
                  ""Please stop the timer or wait until it fires."";
        return C_ERR;
    }

    /* Give module a c...",12216.0,12290.0,1.0,15.0,75.0,38,11,44,12,1,27,6,8,1,19,,0,9,4,2,2,int
3256,196810,modulePipeReadable,1,modulePipeReadable,"void modulePipeReadable (aeEventLoop*,int,void*,int)",module.c,"void modulePipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);
    UNUSED(privdata);

    char buf[128];
    while (read(fd, buf, sizeof(buf)) == sizeof(buf));

    /* Handle event loop events if pipe was written from event loop API */
    eventLoopHandleOneShotEvents();
}",12292.0,12303.0,1.0,4.0,12.0,7,3,12,5,0,1,2,2,0,1,,0,0,8,4,4,void
3257,196853,addReplyLoadedModules,1,addReplyLoadedModules,void addReplyLoadedModules (client*),module.c,"void addReplyLoadedModules(client *c) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    addReplyArrayLen(c,dictSize(modules));
    while ((de = dictNext(di)) != NULL) {
        sds name = dictGetKey(de);
        struct RedisModule *module = dictGetVal(de);
        sds path = module->loadmod->path;
        addReplyMapLen(c,4);
        addReplyBulkCString(c,""name"");
        addReplyBulkCBuffer(c,name,sdslen(name));
        addReplyBulkCString(c,""ver"");
        addReplyLongLong(c,module->ver);
        addReplyBulkCString(c,""path"");
        addReplyBulkCBuffer(c,path,sdslen(path));
        addReplyBulkCString(c,""args"");
        addReplyArrayLen(c,module->loadmod->argc);
        for (int i = 0; i < module->loadmod->argc; i++) {
            addReplyBulk(c,module->loadmod->argv[i]);
        }
    }
    dictReleaseIterator(di);
}",12307.0,12330.0,1.0,23.0,24.0,23,6,37,9,1,29,3,4,2,18,,0,17,2,1,1,void
3258,196970,genModulesInfoStringRenderModulesList,1,genModulesInfoStringRenderModulesList,sds genModulesInfoStringRenderModulesList (list*),module.c,"sds genModulesInfoStringRenderModulesList(list *l) {
    listIter li;
    listNode *ln;
    listRewind(l,&li);
    sds output = sdsnew(""["");
    while((ln = listNext(&li))) {
        RedisModule *module = ln->value;
        output = sdscat(output,module->name);
        if (ln != listLast(l))
            output = sdscat(output,""|"");
    }
    output = sdscat(output,""]"");
    return output;
}",12334.0,12347.0,1.0,18.0,14.0,12,4,18,5,2,9,3,4,2,6,,0,8,2,1,1,sds
3259,197028,genModulesInfoStringRenderModuleOptions,1,genModulesInfoStringRenderModuleOptions,sds genModulesInfoStringRenderModuleOptions (RedisModule*),module.c,"sds genModulesInfoStringRenderModuleOptions(struct RedisModule *module) {
    sds output = sdsnew(""["");
    if (module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS)
        output = sdscat(output,""handle-io-errors|"");
    if (module->options & REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD)
        output = sdscat(output,""handle-repl-async-load|"");
    if (module->options & REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED)
        output = sdscat(output,""no-implicit-signal-modified|"");
    output = sdstrim(output,""|"");
    output = sdscat(output,""]"");
    return output;
}",12350.0,12361.0,1.0,26.0,12.0,15,4,15,2,1,9,4,4,3,6,,0,9,2,1,1,sds
3260,197098,genModulesInfoString,1,genModulesInfoString,sds genModulesInfoString (sds),module.c,"sds genModulesInfoString(sds info) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        sds name = dictGetKey(de);
        struct RedisModule *module = dictGetVal(de);

        sds usedby = genModulesInfoStringRenderModulesList(module->usedby);
        sds using = genModulesInfoStringRenderModulesList(module->using);
        sds options = genModulesInfoStringRenderModuleOptions(module);
        info = sdscatfmt(info,
            ""module:name=%S,ver=%i,api=%i,filters=%i,""
            ""usedby=%S,using=%S,options=%S\r\n"",
                name, module->ver, module->apiver,
                (int)listLength(module->filters), usedby, using, options);
        sdsfree(usedby);
        sdsfree(using);
        sdsfree(options);
    }
    dictReleaseIterator(di);
    return info;
}",12369.0,12391.0,1.0,21.0,23.0,17,4,30,10,1,19,2,2,1,12,,0,15,2,1,1,sds
3261,197183,isModuleConfigNameRegistered,1,isModuleConfigNameRegistered,"int isModuleConfigNameRegistered (RedisModule*,sds)",module.c,"int isModuleConfigNameRegistered(RedisModule *module, sds name) {
    listNode *match = listSearchKey(module->module_configs, (void *) name);
    return match != NULL;
}",12398.0,12401.0,1.0,1.0,4.0,4,4,5,4,1,2,1,1,0,1,,0,2,4,2,2,int
3262,197203,moduleVerifyConfigFlags,1,moduleVerifyConfigFlags,"int moduleVerifyConfigFlags (unsigned int,configType)",module.c,"int moduleVerifyConfigFlags(unsigned int flags, configType type) {
    if ((flags & ~(REDISMODULE_CONFIG_DEFAULT
                    | REDISMODULE_CONFIG_IMMUTABLE
                    | REDISMODULE_CONFIG_SENSITIVE
                    | REDISMODULE_CONFIG_HIDDEN
                    | REDISMODULE_CONFIG_PROTECTED
                    | REDISMODULE_CONFIG_DENY_LOADING
                    | REDISMODULE_CONFIG_BITFLAGS
                    | REDISMODULE_CONFIG_MEMORY))) {
        serverLogRaw(LL_WARNING, ""Invalid flag(s) for configuration"");
        return REDISMODULE_ERR;
    }
    if (type != NUMERIC_CONFIG && flags & REDISMODULE_CONFIG_MEMORY) {
        serverLogRaw(LL_WARNING, ""Numeric flag provided for non-numeric configuration."");
        return REDISMODULE_ERR;
    }
    if (type != ENUM_CONFIG && flags & REDISMODULE_CONFIG_BITFLAGS) {
        serverLogRaw(LL_WARNING, ""Enum flag provided for non-enum configuration."");
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",12404.0,12425.0,1.0,19.0,22.0,24,6,7,4,1,3,4,4,0,3,,0,0,4,2,2,int
3263,197316,moduleVerifyConfigName,1,moduleVerifyConfigName,int moduleVerifyConfigName (sds),module.c,"int moduleVerifyConfigName(sds name) {
    if (sdslen(name) == 0) {
        serverLogRaw(LL_WARNING, ""Module config names cannot be an empty string."");
        return REDISMODULE_ERR;
    }
    for (size_t i = 0 ; i < sdslen(name) ; ++i) {
        char curr_char = name[i];
        if ((curr_char >= 'a' && curr_char <= 'z') ||
            (curr_char >= 'A' && curr_char <= 'Z') ||
            (curr_char >= '0' && curr_char <= '9') ||
            (curr_char == '_') || (curr_char == '-'))
        {
            continue;
        }
        serverLog(LL_WARNING, ""Invalid character %c in Module Config name %s."", curr_char, name);
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",12427.0,12445.0,1.0,21.0,19.0,23,10,18,4,1,4,5,5,2,4,,0,2,2,1,1,int
3264,197422,propagateErrorString,1,propagateErrorString,"void propagateErrorString (robj*,char**)",module.c,"static void propagateErrorString(RedisModuleString *err_in, const char **err) {
    if (err_in) {
        redis_strlcpy(configerr, err_in->ptr, CONFIG_ERR_SIZE);
        decrRefCount(err_in);
        *err = configerr;
    }
}",12451.0,12457.0,1.0,33.0,7.0,3,3,6,3,5,4,2,2,0,2,,0,2,4,2,2,void
3265,197445,setModuleBoolConfig,1,setModuleBoolConfig,"int setModuleBoolConfig (ModuleConfig*,int,char**)",module.c,"int setModuleBoolConfig(ModuleConfig *config, int val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_bool(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12459.0,12464.0,1.0,4.0,6.0,9,6,11,6,2,3,1,1,0,1,,0,2,6,3,3,int
3266,197488,setModuleStringConfig,1,setModuleStringConfig,"int setModuleStringConfig (ModuleConfig*,sds,char**)",module.c,"int setModuleStringConfig(ModuleConfig *config, sds strval, const char **err) {
    RedisModuleString *error = NULL;
    RedisModuleString *new = createStringObject(strval, sdslen(strval));
    int return_code = config->set_fn.set_string(config->name, new, config->privdata, &error);
    propagateErrorString(error, err);
    decrRefCount(new);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12466.0,12473.0,1.0,4.0,8.0,10,6,15,7,2,6,1,1,0,4,,0,4,6,3,3,int
3267,197542,setModuleEnumConfig,1,setModuleEnumConfig,"int setModuleEnumConfig (ModuleConfig*,int,char**)",module.c,"int setModuleEnumConfig(ModuleConfig *config, int val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_enum(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12475.0,12480.0,1.0,4.0,6.0,9,6,11,6,2,3,1,1,0,1,,0,2,6,3,3,int
3268,197585,setModuleNumericConfig,1,setModuleNumericConfig,"int setModuleNumericConfig (ModuleConfig*,long long,char**)",module.c,"int setModuleNumericConfig(ModuleConfig *config, long long val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_numeric(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12482.0,12487.0,1.0,4.0,6.0,9,6,11,6,1,3,1,1,0,1,,0,2,6,3,3,int
3269,197628,getModuleBoolConfig,1,getModuleBoolConfig,int getModuleBoolConfig (ModuleConfig*),module.c,"int getModuleBoolConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_bool(module_config->name, module_config->privdata);
}",12491.0,12493.0,1.0,1.0,3.0,4,2,3,1,3,2,1,1,0,0,,0,2,2,1,1,int
3270,197646,getModuleStringConfig,1,getModuleStringConfig,sds getModuleStringConfig (ModuleConfig*),module.c,"sds getModuleStringConfig(ModuleConfig *module_config) {
    RedisModuleString *val = module_config->get_fn.get_string(module_config->name, module_config->privdata);
    return val ? sdsdup(val->ptr) : NULL;
}",12495.0,12498.0,1.0,4.0,4.0,7,4,7,3,3,3,1,1,0,1,,0,2,2,1,1,sds
3271,197676,getModuleEnumConfig,1,getModuleEnumConfig,int getModuleEnumConfig (ModuleConfig*),module.c,"int getModuleEnumConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_enum(module_config->name, module_config->privdata);
}",12500.0,12502.0,1.0,1.0,3.0,4,2,3,1,3,2,1,1,0,0,,0,2,2,1,1,int
3272,197694,getModuleNumericConfig,1,getModuleNumericConfig,long long getModuleNumericConfig (ModuleConfig*),module.c,"long long getModuleNumericConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_numeric(module_config->name, module_config->privdata);
}",12504.0,12506.0,1.0,1.0,3.0,4,2,3,1,3,2,1,1,0,0,,0,2,2,1,1,long long
3273,197712,loadModuleConfigs,1,loadModuleConfigs,int loadModuleConfigs (RedisModule*),module.c,"int loadModuleConfigs(RedisModule *module) {
    listIter li;
    listNode *ln;
    const char *err = NULL;
    listRewind(module->module_configs, &li);
    while ((ln = listNext(&li))) {
        ModuleConfig *module_config = listNodeValue(ln);
        sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module->name, module_config->name);
        dictEntry *config_argument = dictFind(server.module_configs_queue, config_name);
        if (config_argument) {
            if (!performModuleConfigSetFromName(dictGetKey(config_argument), dictGetVal(config_argument), &err)) {
                serverLog(LL_WARNING, ""Issue during loading of configuration %s : %s"", (sds) dictGetKey(config_argument), err);
                sdsfree(config_name);
                dictEmpty(server.module_configs_queue, NULL);
                return REDISMODULE_ERR;
            }
        } else {
            if (!performModuleConfigSetDefaultFromName(config_name, &err)) {
                serverLog(LL_WARNING, ""Issue att...",12510.0,12539.0,1.0,38.0,30.0,22,8,29,9,1,19,4,7,4,14,,0,13,2,1,1,int
3274,197870,addModuleConfigApply,1,addModuleConfigApply,"void addModuleConfigApply (list*,ModuleConfig*)",module.c,"void addModuleConfigApply(list *module_configs, ModuleConfig *module_config) {
    if (!module_config->apply_fn) return;
    listIter li;
    listNode *ln;
    ModuleConfig *pending_apply;
    listRewind(module_configs, &li);
    while ((ln = listNext(&li))) {
        pending_apply = listNodeValue(ln);
        if (pending_apply->apply_fn == module_config->apply_fn && pending_apply->privdata == module_config->privdata) {
            return;
        }
    }
    listAddNodeTail(module_configs, module_config);
}",12542.0,12555.0,1.0,24.0,14.0,14,6,14,5,0,9,4,5,6,3,,0,7,4,2,2,void
3275,197926,moduleConfigApplyConfig,1,moduleConfigApplyConfig,"int moduleConfigApplyConfig (list*,char**,char**)",module.c,"int moduleConfigApplyConfig(list *module_configs, const char **err, const char **err_arg_name) {
    if (!listLength(module_configs)) return 1;
    listIter li;
    listNode *ln;
    ModuleConfig *module_config;
    RedisModuleString *error = NULL;
    RedisModuleCtx ctx;

    listRewind(module_configs, &li);
    while ((ln = listNext(&li))) {
        module_config = listNodeValue(ln);
        moduleCreateContext(&ctx, module_config->module, REDISMODULE_CTX_NONE);
        if (module_config->apply_fn(&ctx, module_config->privdata, &error)) {
            if (err_arg_name) *err_arg_name = module_config->name;
            propagateErrorString(error, err);
            moduleFreeContext(&ctx);
            return 0;
        }
        moduleFreeContext(&ctx);
    }
    return 1;
}",12558.0,12579.0,1.0,9.0,22.0,19,5,24,9,2,12,5,8,4,6,,0,7,6,3,3,int
3276,198017,createModuleConfig,1,createModuleConfig,"ModuleConfig createModuleConfig (sds,RedisModuleConfigApplyFunc,void*,RedisModule*)",module.c,"ModuleConfig *createModuleConfig(sds name, RedisModuleConfigApplyFunc apply_fn, void *privdata, RedisModule *module) {
    ModuleConfig *new_config = zmalloc(sizeof(ModuleConfig));
    new_config->name = sdsdup(name);
    new_config->apply_fn = apply_fn;
    new_config->privdata = privdata;
    new_config->module = module;
    return new_config;
}",12586.0,12593.0,1.0,1.0,8.0,10,3,11,6,4,6,1,1,0,2,,0,6,8,4,4,ModuleConfig
3277,198054,moduleConfigValidityCheck,1,moduleConfigValidityCheck,"int moduleConfigValidityCheck (RedisModule*,sds,unsigned int,configType)",module.c,"int moduleConfigValidityCheck(RedisModule *module, sds name, unsigned int flags, configType type) {
    if (!module->onload) {
        errno = EBUSY;
        return REDISMODULE_ERR;
    }
    if (moduleVerifyConfigFlags(flags, type) || moduleVerifyConfigName(name)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    if (isModuleConfigNameRegistered(module, name)) {
        serverLog(LL_WARNING, ""Configuration by the name: %s already registered"", name);
        errno = EALREADY;
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",12595.0,12610.0,1.0,15.0,16.0,9,7,14,9,4,5,4,4,4,4,,0,4,8,4,4,int
3278,198125,maskModuleConfigFlags,1,maskModuleConfigFlags,unsigned int maskModuleConfigFlags (unsigned int),module.c,"unsigned int maskModuleConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_DEFAULT) new_flags |= MODIFIABLE_CONFIG;
    if (flags & REDISMODULE_CONFIG_IMMUTABLE) new_flags |= IMMUTABLE_CONFIG;
    if (flags & REDISMODULE_CONFIG_HIDDEN) new_flags |= HIDDEN_CONFIG;
    if (flags & REDISMODULE_CONFIG_PROTECTED) new_flags |= PROTECTED_CONFIG;
    if (flags & REDISMODULE_CONFIG_DENY_LOADING) new_flags |= DENY_LOADING_CONFIG;
    return new_flags;
}",12612.0,12620.0,1.0,16.0,9.0,14,3,12,2,4,0,6,6,0,0,,0,0,2,1,1,unsigned int
3279,198212,maskModuleNumericConfigFlags,1,maskModuleNumericConfigFlags,unsigned int maskModuleNumericConfigFlags (unsigned int),module.c,"unsigned int maskModuleNumericConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_MEMORY) new_flags |= MEMORY_CONFIG;
    return new_flags;
}",12622.0,12626.0,1.0,16.0,5.0,4,3,4,2,1,0,2,2,0,0,,0,0,2,1,1,unsigned int
3280,198239,maskModuleEnumConfigFlags,1,maskModuleEnumConfigFlags,unsigned int maskModuleEnumConfigFlags (unsigned int),module.c,"unsigned int maskModuleEnumConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_BITFLAGS) new_flags |= MULTI_ARG_CONFIG;
    return new_flags;
}",12628.0,12632.0,1.0,16.0,5.0,4,3,4,2,1,0,2,2,0,0,,0,0,2,1,1,unsigned int
3281,198266,RM_RegisterStringConfig,1,RM_RegisterStringConfig,"int RM_RegisterStringConfig (RedisModuleCtx*,char*,char*,unsigned int,RedisModuleConfigGetStringFunc,RedisModuleConfigSetStringFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterStringConfig(RedisModuleCtx *ctx, const char *name, const char *default_val, unsigned int flags, RedisModuleConfigGetStringFunc getfn, RedisModuleConfigSetStringFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, NUMERIC_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_string = getfn;
    new_config->set_fn.set_string = setfn;
    listAddNodeTail(module->module_configs, new_config);
    flags = maskModuleConfigFlags(flags);
    addModuleStringConfig(module->name, name, flags, new_config, default_val ? sdsnew(default_val) : NULL);
    return REDISMODULE_OK;
}",12709.0,12724.0,1.0,15.0,16.0,14,4,30,13,0,12,2,2,1,9,,0,8,16,8,8,int
3282,198351,RM_RegisterBoolConfig,1,RM_RegisterBoolConfig,"int RM_RegisterBoolConfig (RedisModuleCtx*,char*,int,unsigned int,RedisModuleConfigGetBoolFunc,RedisModuleConfigSetBoolFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterBoolConfig(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, RedisModuleConfigGetBoolFunc getfn, RedisModuleConfigSetBoolFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, BOOL_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_bool = getfn;
    new_config->set_fn.set_bool = setfn;
    listAddNodeTail(module->module_configs, new_config);
    flags = maskModuleConfigFlags(flags);
    addModuleBoolConfig(module->name, name, flags, new_config, default_val);
    return REDISMODULE_OK;
}",12729.0,12744.0,1.0,15.0,16.0,13,3,28,12,0,11,2,2,1,8,,0,7,16,8,8,int
3283,198432,RM_RegisterEnumConfig,1,RM_RegisterEnumConfig,"int RM_RegisterEnumConfig (RedisModuleCtx*,char*,int,unsigned int,char**,int*,int,RedisModuleConfigGetEnumFunc,RedisModuleConfigSetEnumFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterEnumConfig(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, const char **enum_values, const int *int_values, int num_enum_vals, RedisModuleConfigGetEnumFunc getfn, RedisModuleConfigSetEnumFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, ENUM_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_enum = getfn;
    new_config->set_fn.set_enum = setfn;
    configEnum *enum_vals = zmalloc((num_enum_vals + 1) * sizeof(configEnum));
    for (int i = 0; i < num_enum_vals; i++) {
        enum_vals[i].name = zstrdup(enum_values[i]);
        enum_vals[i].val = int_values[i];
    }
    enum_vals[num_enum_vals].name = NULL;
    enum_vals...",12775.0,12797.0,1.0,15.0,23.0,34,9,49,19,0,14,3,3,1,11,,0,10,22,11,11,int
3284,198575,RM_RegisterNumericConfig,1,RM_RegisterNumericConfig,"int RM_RegisterNumericConfig (RedisModuleCtx*,char*,long long,unsigned int,long long,long long,RedisModuleConfigGetNumericFunc,RedisModuleConfigSetNumericFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterNumericConfig(RedisModuleCtx *ctx, const char *name, long long default_val, unsigned int flags, long long min, long long max, RedisModuleConfigGetNumericFunc getfn, RedisModuleConfigSetNumericFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, NUMERIC_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_numeric = getfn;
    new_config->set_fn.set_numeric = setfn;
    listAddNodeTail(module->module_configs, new_config);
    unsigned int numeric_flags = maskModuleNumericConfigFlags(flags);
    flags = maskModuleConfigFlags(flags);
    addModuleNumericConfig(module->name, name, flags, new_config, default_val, numeric_flags, min, max);
    return REDISMODUL...",12803.0,12819.0,1.0,15.0,17.0,14,3,33,15,0,12,2,2,1,9,,0,8,20,10,10,int
3285,198666,RM_LoadConfigs,1,RM_LoadConfigs,int RM_LoadConfigs (RedisModuleCtx*),module.c,"int RM_LoadConfigs(RedisModuleCtx *ctx) {
    if (!ctx || !ctx->module || !ctx->module->onload) {
        return REDISMODULE_ERR;
    }
    RedisModule *module = ctx->module;
    /* Load configs from conf file or arguments from loadex */
    if (loadModuleConfigs(module)) return REDISMODULE_ERR;
    return REDISMODULE_OK;
}",12826.0,12834.0,1.0,15.0,9.0,10,4,6,2,0,4,3,3,3,1,,0,4,2,1,1,int
3286,198715,RM_RdbStreamCreateFromFile,1,RM_RdbStreamCreateFromFile,RedisModuleRdbStream RM_RdbStreamCreateFromFile (char*),module.c,"RedisModuleRdbStream *RM_RdbStreamCreateFromFile(const char *filename) {
    RedisModuleRdbStream *stream = zmalloc(sizeof(*stream));
    stream->type = REDISMODULE_RDB_STREAM_FILE;
    stream->data.filename = zstrdup(filename);
    return stream;
}",12855.0,12860.0,1.0,19.0,6.0,8,5,6,2,0,4,1,1,0,2,,0,4,2,1,1,RedisModuleRdbStream
3287,198744,RM_RdbStreamFree,1,RM_RdbStreamFree,void RM_RdbStreamFree (RedisModuleRdbStream*),module.c,"void RM_RdbStreamFree(RedisModuleRdbStream *stream) {
    switch (stream->type) {
    case REDISMODULE_RDB_STREAM_FILE:
        zfree(stream->data.filename);
        break;
    default:
        serverAssert(0);
        break;
    }
    zfree(stream);
}",12863.0,12873.0,1.0,9.0,11.0,7,6,3,1,0,5,4,2,1,3,,0,2,2,1,1,void
3288,198784,RM_RdbLoad,1,RM_RdbLoad,"int RM_RdbLoad (RedisModuleCtx*,RedisModuleRdbStream*,int)",module.c,"int RM_RdbLoad(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) {
    UNUSED(ctx);

    if (!stream || flags != 0) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* Not allowed on replicas. */
    if (server.masterhost != NULL) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    }

    /* Drop replicas if exist. */
    disconnectSlaves();
    freeReplicationBacklog();

    if (server.aof_state != AOF_OFF) stopAppendOnly();

    /* Kill existing RDB fork as it is saving outdated data. Also killing it
     * will prevent COW memory issue. */
    if (server.child_type == CHILD_TYPE_RDB) killRDBChild();

    emptyData(-1,EMPTYDB_NO_FLAGS,NULL);

    /* rdbLoad() can go back to the networking and process network events. If
     * RM_RdbLoad() is called inside a command callback, we don't want to
     * process the current client. Otherwise, we may free the client or try to
     * process next message while we are already in the command callba...",12889.0,12934.0,1.0,4.0,46.0,33,12,28,11,0,12,9,9,0,10,,0,3,6,3,3,int
3289,198942,RM_RdbSave,1,RM_RdbSave,"int RM_RdbSave (RedisModuleCtx*,RedisModuleRdbStream*,int)",module.c,"int RM_RdbSave(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) {
    UNUSED(ctx);

    if (!stream || flags != 0) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    serverAssert(stream->type == REDISMODULE_RDB_STREAM_FILE);

    if (rdbSaveToFile(stream->data.filename) != C_OK) {
        return REDISMODULE_ERR;
    }

    errno = 0;
    return REDISMODULE_OK;
}",12949.0,12965.0,1.0,4.0,17.0,15,11,9,5,0,4,3,3,2,2,,0,3,6,3,3,int
3290,199011,moduleCommand,1,moduleCommand,void moduleCommand (client*),module.c,"void moduleCommand(client *c) {
    char *subcmd = c->argv[1]->ptr;

    if (c->argc == 2 && !strcasecmp(subcmd,""help"")) {
        const char *help[] = {
""LIST"",
""    Return a list of loaded modules."",
""LOAD <path> [<arg> ...]"",
""    Load a module library from <path>, passing to it any optional arguments."",
""LOADEX <path> [[CONFIG NAME VALUE] [CONFIG NAME VALUE]] [ARGS ...]"",
""    Load a module library from <path>, while passing it module configurations and optional arguments."",
""UNLOAD <name>"",
""    Unload a module."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(subcmd,""load"") && c->argc >= 3) {
        robj **argv = NULL;
        int argc = 0;

        if (c->argc > 3) {
            argc = c->argc - 3;
            argv = &c->argv[3];
        }

        if (moduleLoad(c->argv[2]->ptr,(void **)argv,argc, 0) == C_OK)
            addReply(c,shared.ok);
        else
            addReplyError(c,
                ""Error loading the extension. Please check the ...",12974.0,13038.0,1.0,65.0,65.0,10,7,8,4,0,3,2,2,1,1,,0,2,2,1,1,void
3291,199319,moduleCount,1,moduleCount,size_t moduleCount (void),module.c,"size_t moduleCount(void) {
    return dictSize(modules);
}",13041.0,13043.0,1.0,11.0,3.0,5,3,3,1,5,5,1,1,0,0,,0,5,2,1,1,size_t
3292,199339,RM_SetLRU,1,RM_SetLRU,"int RM_SetLRU (RedisModuleKey*,mstime_t)",module.c,"int RM_SetLRU(RedisModuleKey *key, mstime_t lru_idle) {
    if (!key->value)
        return REDISMODULE_ERR;
    if (objectSetLRUOrLFU(key->value, -1, lru_idle, lru_idle>=0 ? LRU_CLOCK() : 0, 1))
        return REDISMODULE_OK;
    return REDISMODULE_ERR;
}",13052.0,13058.0,1.0,15.0,7.0,6,5,4,2,0,4,3,3,4,2,,0,4,4,2,2,int
3293,199379,RM_GetLRU,1,RM_GetLRU,"int RM_GetLRU (RedisModuleKey*,mstime_t*)",module.c,"int RM_GetLRU(RedisModuleKey *key, mstime_t *lru_idle) {
    *lru_idle = -1;
    if (!key->value)
        return REDISMODULE_ERR;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU)
        return REDISMODULE_OK;
    *lru_idle = estimateObjectIdleTime(key->value);
    return REDISMODULE_OK;
}",13064.0,13072.0,1.0,15.0,9.0,11,8,5,3,0,3,3,3,1,1,,0,3,4,2,2,int
3294,199426,RM_SetLFU,1,RM_SetLFU,"int RM_SetLFU (RedisModuleKey*,long long)",module.c,"int RM_SetLFU(RedisModuleKey *key, long long lfu_freq) {
    if (!key->value)
        return REDISMODULE_ERR;
    if (objectSetLRUOrLFU(key->value, lfu_freq, -1, 0, 1))
        return REDISMODULE_OK;
    return REDISMODULE_ERR;
}",13079.0,13085.0,1.0,15.0,7.0,4,3,3,2,0,3,3,3,3,1,,0,3,4,2,2,int
3295,199461,RM_GetLFU,1,RM_GetLFU,"int RM_GetLFU (RedisModuleKey*,long long*)",module.c,"int RM_GetLFU(RedisModuleKey *key, long long *lfu_freq) {
    *lfu_freq = -1;
    if (!key->value)
        return REDISMODULE_ERR;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU)
        *lfu_freq = LFUDecrAndReturn(key->value);
    return REDISMODULE_OK;
}",13090.0,13097.0,1.0,15.0,8.0,11,8,5,3,0,3,3,3,1,1,,0,3,4,2,2,int
3296,199561,RM_ModuleTypeReplaceValue,1,RM_ModuleTypeReplaceValue,"int RM_ModuleTypeReplaceValue (RedisModuleKey*,moduleType*,void*,void**)",module.c,"int RM_ModuleTypeReplaceValue(RedisModuleKey *key, moduleType *mt, void *new_value, void **old_value) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter)
        return REDISMODULE_ERR;
    if (!key->value || key->value->type != OBJ_MODULE)
        return REDISMODULE_ERR;

    moduleValue *mv = key->value->ptr;
    if (mv->type != mt)
        return REDISMODULE_ERR;

    if (old_value)
        *old_value = mv->value;
    mv->value = new_value;

    return REDISMODULE_OK;
}",13188.0,13203.0,1.0,22.0,16.0,22,8,13,5,0,8,5,5,5,0,,0,8,8,4,4,int
3297,199646,RM_GetCommandKeysWithFlags,1,RM_GetCommandKeysWithFlags,"int* RM_GetCommandKeysWithFlags (RedisModuleCtx*,robj**,int,int*,int**)",module.c,"int *RM_GetCommandKeysWithFlags(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys, int **out_flags) {
    UNUSED(ctx);
    struct redisCommand *cmd;
    int *res = NULL;

    /* Find command */
    if ((cmd = lookupCommand(argv,argc)) == NULL) {
        errno = ENOENT;
        return NULL;
    }

    /* Bail out if command has no keys */
    if (!doesCommandHaveKeys(cmd)) {
        errno = 0;
        return NULL;
    }

    if ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity)) {
        errno = EINVAL;
        return NULL;
    }

    getKeysResult result = GETKEYS_RESULT_INIT;
    getKeysFromCommand(cmd, argv, argc, &result);

    *num_keys = result.numkeys;
    if (!result.numkeys) {
        errno = 0;
        getKeysFreeResult(&result);
        return NULL;
    }

    /* The return value here expects an array of key positions */
    unsigned long int size = sizeof(int) * result.numkeys;
    res = zmalloc(size);
    if (out_flags)
        *out_fla...",13225.0,13269.0,1.0,53.0,45.0,50,18,55,15,1,16,8,9,7,7,,0,14,10,5,5,int*
3298,199816,RM_GetCommandKeys,1,RM_GetCommandKeys,"int* RM_GetCommandKeys (RedisModuleCtx*,robj**,int,int*)",module.c,"int *RM_GetCommandKeys(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys) {
    return RM_GetCommandKeysWithFlags(ctx, argv, argc, num_keys, NULL);
}",13272.0,13274.0,1.0,44.0,3.0,0,0,5,5,0,1,1,1,0,1,,0,0,8,4,4,int*
3299,199831,RM_GetCurrentCommandName,1,RM_GetCurrentCommandName,const char* RM_GetCurrentCommandName (RedisModuleCtx*),module.c,"const char *RM_GetCurrentCommandName(RedisModuleCtx *ctx) {
    if (!ctx || !ctx->client || !ctx->client->cmd)
        return NULL;

    return (const char*)ctx->client->cmd->fullname;
}",13277.0,13282.0,1.0,1.0,6.0,12,4,5,2,0,3,2,2,2,0,,0,3,2,1,1,const char*
3300,199870,RM_RegisterDefragFunc,1,RM_RegisterDefragFunc,"int RM_RegisterDefragFunc (RedisModuleCtx*,RedisModuleDefragFunc)",module.c,"int RM_RegisterDefragFunc(RedisModuleCtx *ctx, RedisModuleDefragFunc cb) {
    ctx->module->defrag_cb = cb;
    return REDISMODULE_OK;
}",13301.0,13304.0,1.0,11.0,4.0,3,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,int
3301,199887,RM_DefragShouldStop,1,RM_DefragShouldStop,int RM_DefragShouldStop (RedisModuleDefragCtx*),module.c,"int RM_DefragShouldStop(RedisModuleDefragCtx *ctx) {
    return (ctx->endtime != 0 && ctx->endtime < ustime());
}",13320.0,13322.0,1.0,1.0,3.0,5,4,2,1,0,3,1,1,0,1,,0,2,2,1,1,int
3302,199904,RM_DefragCursorSet,1,RM_DefragCursorSet,"int RM_DefragCursorSet (RedisModuleDefragCtx*,long unsigned)",module.c,"int RM_DefragCursorSet(RedisModuleDefragCtx *ctx, unsigned long cursor) {
    if (!ctx->cursor)
        return REDISMODULE_ERR;

    *ctx->cursor = cursor;
    return REDISMODULE_OK;
}",13346.0,13352.0,1.0,15.0,7.0,5,4,3,2,0,2,2,2,1,0,,0,2,4,2,2,int
3303,199930,RM_DefragCursorGet,1,RM_DefragCursorGet,"int RM_DefragCursorGet (RedisModuleDefragCtx*,long unsigned*)",module.c,"int RM_DefragCursorGet(RedisModuleDefragCtx *ctx, unsigned long *cursor) {
    if (!ctx->cursor)
        return REDISMODULE_ERR;

    *cursor = *ctx->cursor;
    return REDISMODULE_OK;
}",13360.0,13366.0,1.0,15.0,7.0,6,4,3,2,0,2,2,2,1,0,,0,2,4,2,2,int
3304,199957,RM_DefragAlloc,1,RM_DefragAlloc,"void* RM_DefragAlloc (RedisModuleDefragCtx*,void*)",module.c,"void *RM_DefragAlloc(RedisModuleDefragCtx *ctx, void *ptr) {
    UNUSED(ctx);
    return activeDefragAlloc(ptr);
}",13379.0,13382.0,1.0,4.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void*
3305,199972,RM_DefragRedisModuleString,1,RM_DefragRedisModuleString,"robj RM_DefragRedisModuleString (RedisModuleDefragCtx*,robj*)",module.c,"RedisModuleString *RM_DefragRedisModuleString(RedisModuleDefragCtx *ctx, RedisModuleString *str) {
    UNUSED(ctx);
    return activeDefragStringOb(str);
}",13394.0,13397.0,1.0,17.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,robj
3306,199987,moduleLateDefrag,1,moduleLateDefrag,"int moduleLateDefrag (robj*,robj*,long unsigned*,long long,int)",module.c,"int moduleLateDefrag(robj *key, robj *value, unsigned long *cursor, long long endtime, int dbid) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;

    RedisModuleDefragCtx defrag_ctx = { endtime, cursor, key, dbid};

    /* Invoke callback. Note that the callback may be missing if the key has been
     * replaced with a different type since our last visit.
     */
    int ret = 0;
    if (mt->defrag)
        ret = mt->defrag(&defrag_ctx, key, &mv->value);

    if (!ret) {
        *cursor = 0;    /* No more work to do */
        return 0;
    }

    return 1;
}",13405.0,13424.0,1.0,1.0,20.0,16,6,18,9,0,2,3,3,0,0,,0,2,10,5,5,int
3307,200050,moduleDefragValue,1,moduleDefragValue,"int moduleDefragValue (robj*,robj*,int)",module.c,"int moduleDefragValue(robj *key, robj *value, int dbid) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;

    /* Try to defrag moduleValue itself regardless of whether or not
     * defrag callbacks are provided.
     */
    moduleValue *newmv = activeDefragAlloc(mv);
    if (newmv) {
        value->ptr = mv = newmv;
    }

    if (!mt->defrag)
        return 1;

    /* Use free_effort to determine complexity of module value, and if
     * necessary schedule it for defragLater instead of quick immediate
     * defrag.
     */
    size_t effort = moduleGetFreeEffort(key, value, dbid);
    if (!effort)
        effort = SIZE_MAX;
    if (effort > server.active_defrag_max_scan_fields) {
        return 0;  /* Defrag later */
    }

    RedisModuleDefragCtx defrag_ctx = { 0, NULL, key, dbid };
    mt->defrag(&defrag_ctx, key, &mv->value);
    return 1;
}",13432.0,13461.0,1.0,1.0,30.0,21,7,28,11,0,4,5,5,0,2,,0,4,6,3,3,int
3308,200136,moduleDefragGlobals,1,moduleDefragGlobals,void moduleDefragGlobals (void),module.c,"void moduleDefragGlobals(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!module->defrag_cb)
            continue;
        RedisModuleDefragCtx defrag_ctx = { 0, NULL, NULL, -1};
        module->defrag_cb(&defrag_ctx);
    }
    dictReleaseIterator(di);
}",13464.0,13476.0,1.0,1.0,13.0,11,7,14,6,0,7,4,4,2,4,,0,6,2,1,1,void
3309,200184,RM_GetKeyNameFromDefragCtx,1,RM_GetKeyNameFromDefragCtx,robj RM_GetKeyNameFromDefragCtx (RedisModuleDefragCtx*),module.c,"const RedisModuleString *RM_GetKeyNameFromDefragCtx(RedisModuleDefragCtx *ctx) {
    return ctx->key;
}",13481.0,13483.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
3310,200193,RM_GetDbIdFromDefragCtx,1,RM_GetDbIdFromDefragCtx,int RM_GetDbIdFromDefragCtx (RedisModuleDefragCtx*),module.c,"int RM_GetDbIdFromDefragCtx(RedisModuleDefragCtx *ctx) {
    return ctx->dbid;
}",13488.0,13490.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
3311,203405,RevokeCommand_RedisCommand,1,RevokeCommand_RedisCommand,"int RevokeCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int RevokeCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (global_auth_client_id) {
        RedisModule_DeauthenticateAndCloseClient(ctx, global_auth_client_id);
        return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
    } else {
        return RedisModule_ReplyWithError(ctx, ""Global user currently not used"");    
    }
}",44.0,54.0,1.0,4.0,11.0,2,1,8,4,0,4,2,2,1,2,,0,2,6,3,3,int
3312,203440,ResetCommand_RedisCommand,1,ResetCommand_RedisCommand,"int ResetCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int ResetCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModule_FreeModuleUser(global);
    global = RedisModule_CreateModuleUser(""global"");
    RedisModule_SetModuleUserACL(global, ""allcommands"");
    RedisModule_SetModuleUserACL(global, ""allkeys"");
    RedisModule_SetModuleUserACL(global, ""on"");

    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",58.0,69.0,1.0,4.0,12.0,3,2,10,4,0,11,1,1,0,6,,0,6,6,3,3,int
3313,203478,HelloACL_UserChanged,1,HelloACL_UserChanged,"void HelloACL_UserChanged (uint64_t,void*)",modules\helloacl.c,"void HelloACL_UserChanged(uint64_t client_id, void *privdata) {
    REDISMODULE_NOT_USED(privdata);
    REDISMODULE_NOT_USED(client_id);
    global_auth_client_id = 0;
}",73.0,77.0,1.0,4.0,5.0,3,2,5,3,0,1,1,1,0,0,,0,1,4,2,2,void
3314,203499,AuthGlobalCommand_RedisCommand,1,AuthGlobalCommand_RedisCommand,"int AuthGlobalCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int AuthGlobalCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (global_auth_client_id) {
        return RedisModule_ReplyWithError(ctx, ""Global user currently used"");    
    }

    RedisModule_AuthenticateClientWithUser(ctx, global, HelloACL_UserChanged, NULL, &global_auth_client_id);

    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",81.0,92.0,1.0,4.0,12.0,3,2,11,6,0,6,2,2,1,3,,0,3,6,3,3,int
3315,203536,HelloACL_Reply,1,HelloACL_Reply,"int HelloACL_Reply (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int HelloACL_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    size_t length;

    RedisModuleString *user_string = RedisModule_GetBlockedClientPrivateData(ctx);
    const char *name = RedisModule_StringPtrLen(user_string, &length);

    if (RedisModule_AuthenticateClientWithACLUser(ctx, name, length, NULL, NULL, NULL) == 
            REDISMODULE_ERR) {
        return RedisModule_ReplyWithError(ctx, ""Invalid Username or password"");    
    }
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",97.0,110.0,1.0,4.0,14.0,6,4,17,7,0,5,2,2,1,5,,0,3,6,3,3,int
3316,203589,HelloACL_Timeout,1,HelloACL_Timeout,"int HelloACL_Timeout (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int HelloACL_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    return RedisModule_ReplyWithSimpleString(ctx, ""Request timedout"");
}",113.0,117.0,1.0,4.0,5.0,2,1,5,3,0,1,1,1,0,1,,0,0,6,3,3,int
3317,203612,HelloACL_FreeData,1,HelloACL_FreeData,"void HelloACL_FreeData (RedisModuleCtx*,void*)",modules\helloacl.c,"void HelloACL_FreeData(RedisModuleCtx *ctx, void *privdata) {
    REDISMODULE_NOT_USED(ctx);
    RedisModule_FreeString(NULL, privdata);
}",120.0,123.0,1.0,4.0,4.0,1,1,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
3318,203627,HelloACL_ThreadMain,1,HelloACL_ThreadMain,void* HelloACL_ThreadMain (void*),modules\helloacl.c,"void *HelloACL_ThreadMain(void *args) {
    void **targs = args;
    RedisModuleBlockedClient *bc = targs[0];
    RedisModuleString *user = targs[1];
    RedisModule_Free(targs);

    RedisModule_UnblockClient(bc,user);
    return NULL;
}",126.0,134.0,1.0,1.0,9.0,5,2,10,5,0,2,1,1,0,2,,0,0,2,1,1,void*
3319,203655,AuthAsyncCommand_RedisCommand,1,AuthAsyncCommand_RedisCommand,"int AuthAsyncCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int AuthAsyncCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    pthread_t tid;
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx, HelloACL_Reply, HelloACL_Timeout, HelloACL_FreeData, TIMEOUT_TIME);
    

    void **targs = RedisModule_Alloc(sizeof(void*)*2);
    targs[0] = bc;
    targs[1] = RedisModule_CreateStringFromString(NULL, argv[1]);

    if (pthread_create(&tid, NULL, HelloACL_ThreadMain, targs) != 0) {
        RedisModule_AbortBlock(bc);
        return RedisModule_ReplyWithError(ctx, ""-ERR Can't start thread"");
    }

    return REDISMODULE_OK;
}",138.0,155.0,1.0,117.0,18.0,12,6,16,8,0,6,3,3,0,6,,0,3,6,3,3,int
3320,203724,RedisModule_OnLoad,1,RedisModule_OnLoad,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx,""helloworld"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    /* Log the list of parameters passing loading the module. */
    for (int j = 0; j < argc; j++) {
        const char *s = RedisModule_StringPtrLen(argv[j],NULL);
        printf(""Module loaded with ARGV[%d] = %s\n"", j, s);
    }

    if (RedisModule_CreateCommand(ctx,""hello.simple"",
        HelloSimple_RedisCommand,""readonly"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.native"",
        HelloPushNative_RedisCommand,""write deny-oom"",1,1,1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.call"",
        HelloPushCall_RedisCommand,""write deny-oom"",1,1,1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.call2"",
     ...",545.0,621.0,1.0,44.0,77.0,9,3,14,5,0,14,6,6,5,9,,0,11,6,3,3,int
3321,203867,HelloBlock_Reply,1,HelloBlock_Reply,"int HelloBlock_Reply (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModuleString *keyname = RedisModule_GetBlockedClientReadyKey(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,keyname,REDISMODULE_READ);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_MODULE ||
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        RedisModule_CloseKey(key);
        return REDISMODULE_ERR;
    }

    /* In case the key is able to serve our blocked client, let's directly
     * use our original command implementation to make this example simpler. */
    RedisModule_CloseKey(key);
    return HelloTypeRange_RedisCommand(ctx,argv,argc-1);
}",199.0,217.0,1.0,4.0,19.0,4,3,8,4,0,2,1,1,0,2,,0,1,6,3,3,int
3322,203896,HelloBlock_Timeout,1,HelloBlock_Timeout,"int HelloBlock_Timeout (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    return RedisModule_ReplyWithSimpleString(ctx,""Request timedout"");
}",220.0,224.0,1.0,4.0,5.0,2,1,5,3,0,1,1,1,0,1,,0,0,6,3,3,int
3323,203919,HelloBlock_FreeData,1,HelloBlock_FreeData,"void HelloBlock_FreeData (RedisModuleCtx*,void*)",modules\hellotype.c,"void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {
    REDISMODULE_NOT_USED(ctx);
    RedisModule_Free(privdata);
}",227.0,230.0,1.0,4.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void
3324,203933,HelloBlock_ThreadMain,1,HelloBlock_ThreadMain,void* HelloBlock_ThreadMain (void*),modules\helloblock.c,"void *HelloBlock_ThreadMain(void *arg) {
    void **targ = arg;
    RedisModuleBlockedClient *bc = targ[0];
    long long delay = (unsigned long)targ[1];
    RedisModule_Free(targ);

    sleep(delay);
    int *r = RedisModule_Alloc(sizeof(int));
    *r = rand();
    RedisModule_UnblockClient(bc,r);
    return NULL;
}",63.0,74.0,1.0,1.0,12.0,10,5,14,7,0,3,1,1,0,3,,0,1,2,1,1,void*
3325,203975,HelloBlock_Disconnected,1,HelloBlock_Disconnected,"void HelloBlock_Disconnected (RedisModuleCtx*,RedisModuleBlockedClient*)",modules\helloblock.c,"void HelloBlock_Disconnected(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc) {
    RedisModule_Log(ctx,""warning"",""Blocked client %p disconnected!"",
        (void*)bc);

    /* Here you should cleanup your state / threads, and if possible
     * call RedisModule_UnblockClient(), or notify the thread that will
     * call the function ASAP. */
}",84.0,91.0,1.0,1.0,8.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
3326,203988,HelloBlock_RedisCommand,1,HelloBlock_RedisCommand,"int HelloBlock_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloblock.c,"int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    long long delay;
    long long timeout;

    if (RedisModule_StringToLongLong(argv[1],&delay) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    if (RedisModule_StringToLongLong(argv[2],&timeout) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    pthread_t tid;
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx,HelloBlock_Reply,HelloBlock_Timeout,HelloBlock_FreeData,timeout);

    /* Here we set a disconnection handler, however since this module will
     * block in sleep() in a thread, there is not much we can do in the
     * callback, so this is just to show you the API. */
    RedisModule_SetDisconnectCallback(bc,HelloBlock_Disconnected);

    /* Now that we setup a blocking client, we need to pass the control
     * to the thr...",96.0,129.0,1.0,56.0,34.0,19,7,23,10,0,10,5,5,2,10,,0,4,6,3,3,int
3327,204092,HelloKeys_ThreadMain,1,HelloKeys_ThreadMain,void* HelloKeys_ThreadMain (void*),modules\helloblock.c,"void *HelloKeys_ThreadMain(void *arg) {
    RedisModuleBlockedClient *bc = arg;
    RedisModuleCtx *ctx = RedisModule_GetThreadSafeContext(bc);
    long long cursor = 0;
    size_t replylen = 0;

    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    do {
        RedisModule_ThreadSafeContextLock(ctx);
        RedisModuleCallReply *reply = RedisModule_Call(ctx,
            ""SCAN"",""l"",(long long)cursor);
        RedisModule_ThreadSafeContextUnlock(ctx);

        RedisModuleCallReply *cr_cursor =
            RedisModule_CallReplyArrayElement(reply,0);
        RedisModuleCallReply *cr_keys =
            RedisModule_CallReplyArrayElement(reply,1);

        RedisModuleString *s = RedisModule_CreateStringFromCallReply(cr_cursor);
        RedisModule_StringToLongLong(s,&cursor);
        RedisModule_FreeString(ctx,s);

        size_t items = RedisModule_CallReplyLength(cr_keys);
        for (size_t j = 0; j < items; j++) {
            RedisModuleCallReply *ele =
                ...",138.0,174.0,1.0,35.0,37.0,17,7,41,13,0,17,3,4,0,17,,0,7,2,1,1,void*
3328,204203,HelloKeys_RedisCommand,1,HelloKeys_RedisCommand,"int HelloKeys_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloblock.c,"int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    if (argc != 1) return RedisModule_WrongArity(ctx);

    pthread_t tid;

    /* Note that when blocking the client we do not set any callback: no
     * timeout is possible since we passed '0', nor we need a reply callback
     * because we'll use the thread safe context to accumulate a reply. */
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx,NULL,NULL,NULL,0);

    /* Now that we setup a blocking client, we need to pass the control
     * to the thread. However we need to pass arguments to the thread:
     * the reference to the blocked client handle. */
    if (pthread_create(&tid,NULL,HelloKeys_ThreadMain,bc) != 0) {
        RedisModule_AbortBlock(bc);
        return RedisModule_ReplyWithError(ctx,""-ERR Can't start thread"");
    }
    return REDISMODULE_OK;
}",180.0,199.0,1.0,4.0,20.0,5,4,14,6,0,4,3,3,0,4,,0,1,6,3,3,int
3329,204345,PingallCommand_RedisCommand,1,PingallCommand_RedisCommand,"int PingallCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellocluster.c,"int PingallCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PING,""Hey"",3);
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",43.0,49.0,1.0,4.0,7.0,2,1,7,4,0,2,1,1,0,2,,0,0,6,3,3,int
3330,204376,ListCommand_RedisCommand,1,ListCommand_RedisCommand,"int ListCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellocluster.c,"int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    size_t numnodes;
    char **ids = RedisModule_GetClusterNodesList(ctx,&numnodes);
    if (ids == NULL) {
        return RedisModule_ReplyWithError(ctx,""Cluster not enabled"");
    }

    RedisModule_ReplyWithArray(ctx,numnodes);
    for (size_t j = 0; j < numnodes; j++) {
        int port;
        RedisModule_GetClusterNodeInfo(ctx,ids[j],NULL,NULL,&port,NULL);
        RedisModule_ReplyWithArray(ctx,2);
        RedisModule_ReplyWithStringBuffer(ctx,ids[j],REDISMODULE_NODE_ID_LEN);
        RedisModule_ReplyWithLongLong(ctx,port);
    }
    RedisModule_FreeClusterNodesList(ids);
    return REDISMODULE_OK;
}",52.0,72.0,1.0,4.0,21.0,10,6,29,8,0,8,3,3,0,8,,0,1,6,3,3,int
3331,204458,PingReceiver,1,PingReceiver,"void PingReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)",modules\hellocluster.c,"void PingReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    RedisModule_Log(ctx,""notice"",""PING (type %d) RECEIVED from %.*s: '%.*s'"",
        type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
    RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PONG,""Ohi!"",4);
    RedisModuleCallReply *reply = RedisModule_Call(ctx, ""INCR"", ""c"", ""pings_received"");
    RedisModule_FreeCallReply(reply);
}",75.0,81.0,1.0,13.0,7.0,2,2,10,7,0,4,1,1,0,4,,0,1,10,5,5,void
3332,204498,PongReceiver,1,PongReceiver,"void PongReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)",modules\hellocluster.c,"void PongReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    RedisModule_Log(ctx,""notice"",""PONG (type %d) RECEIVED from %.*s: '%.*s'"",
        type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
}",84.0,87.0,1.0,13.0,4.0,1,1,5,5,0,1,1,1,0,1,,0,0,10,5,5,void
3333,204631,cmd_SET,1,cmd_SET,"int cmd_SET (RedisModuleCtx*,RedisModuleString**,int)",modules\hellodict.c,"int cmd_SET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    RedisModule_DictSet(Keyspace,argv[1],argv[2]);
    /* We need to keep a reference to the value stored at the key, otherwise
     * it would be freed when this callback returns. */
    RedisModule_RetainString(NULL,argv[2]);
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",47.0,54.0,1.0,1.0,8.0,4,2,8,5,0,5,2,2,0,4,,0,1,6,3,3,int
3334,204663,cmd_GET,1,cmd_GET,"int cmd_GET (RedisModuleCtx*,RedisModuleString**,int)",modules\hellodict.c,"int cmd_GET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    RedisModuleString *val = RedisModule_DictGet(Keyspace,argv[1],NULL);
    if (val == NULL) {
        return RedisModule_ReplyWithNull(ctx);
    } else {
        return RedisModule_ReplyWithString(ctx, val);
    }
}",60.0,68.0,1.0,1.0,9.0,4,4,9,6,0,4,3,3,0,3,,0,2,6,3,3,int
3335,204701,cmd_KEYRANGE,1,cmd_KEYRANGE,"int cmd_KEYRANGE (RedisModuleCtx*,RedisModuleString**,int)",modules\hellodict.c,"int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    /* Parse the count argument. */
    long long count;
    if (RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    /* Seek the iterator. */
    RedisModuleDictIter *iter = RedisModule_DictIteratorStart(
        Keyspace, "">="", argv[1]);

    /* Reply with the matching items. */
    char *key;
    size_t keylen;
    long long replylen = 0; /* Keep track of the emitted array len. */
    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    while((key = RedisModule_DictNextC(iter,&keylen,NULL)) != NULL) {
        if (replylen >= count) break;
        if (RedisModule_DictCompare(iter,""<="",argv[2]) == REDISMODULE_ERR)
            break;
        RedisModule_ReplyWithStringBuffer(ctx,key,keylen);
        replylen++;
    }
    RedisModule_ReplySetArrayLength(...",74.0,104.0,1.0,56.0,31.0,15,8,26,10,0,11,8,8,3,10,,0,5,6,3,3,int
3336,204959,flushdbCallback,1,flushdbCallback,"void flushdbCallback (RedisModuleCtx*,RedisModuleEvent,uint64_t,void*)",modules\hellohook.c,"void flushdbCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void *data)
{
    REDISMODULE_NOT_USED(ctx);
    REDISMODULE_NOT_USED(e);

    RedisModuleFlushInfo *fi = data;
    if (sub == REDISMODULE_SUBEVENT_FLUSHDB_START) {
        if (fi->dbnum != -1) {
            RedisModuleCallReply *reply;
            reply = RedisModule_Call(ctx,""DBSIZE"","""");
            long long numkeys = RedisModule_CallReplyInteger(reply);
            printf(""FLUSHDB event of database %d started (%lld keys in DB)\n"",
                fi->dbnum, numkeys);
            RedisModule_FreeCallReply(reply);
        } else {
            printf(""FLUSHALL event started\n"");
        }
    } else {
        if (fi->dbnum != -1) {
            printf(""FLUSHDB event of database %d ended\n"",fi->dbnum);
        } else {
            printf(""FLUSHALL event ended\n"");
        }
    }
}",52.0,76.0,1.0,4.0,25.0,10,6,15,7,0,3,3,4,0,3,,0,2,8,4,4,void
3337,205106,timerHandler,1,timerHandler,"void timerHandler (RedisModuleCtx*,void*)",modules\hellotimer.c,"void timerHandler(RedisModuleCtx *ctx, void *data) {
    REDISMODULE_NOT_USED(ctx);
    printf(""Fired %s!\n"", (char *)data);
    RedisModule_Free(data);
}",40.0,44.0,1.0,4.0,5.0,2,1,4,2,0,1,1,1,0,1,,0,0,4,2,2,void
3338,205125,TimerCommand_RedisCommand,1,TimerCommand_RedisCommand,"int TimerCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotimer.c,"int TimerCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    for (int j = 0; j < 10; j++) {
        int delay = rand() % 5000;
        char *buf = RedisModule_Alloc(256);
        snprintf(buf,256,""After %d"", delay);
        RedisModuleTimerID tid = RedisModule_CreateTimer(ctx,delay,timerHandler,buf);
        REDISMODULE_NOT_USED(tid);
    }
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",47.0,59.0,1.0,4.0,13.0,9,4,17,7,0,3,2,2,0,3,,0,2,6,3,3,int
3339,205274,createHelloTypeObject,1,createHelloTypeObject,struct HelloTypeObject createHelloTypeObject (void),modules\hellotype.c,"struct HelloTypeObject *createHelloTypeObject(void) {
    struct HelloTypeObject *o;
    o = RedisModule_Alloc(sizeof(*o));
    o->head = NULL;
    o->len = 0;
    return o;
}",63.0,69.0,1.0,1.0,7.0,7,4,6,2,2,3,1,1,0,1,,0,3,2,1,1,struct HelloTypeObject
3340,205298,HelloTypeInsert,1,HelloTypeInsert,"void HelloTypeInsert (HelloTypeObject*,int64_t)",modules\hellotype.c,"void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {
    struct HelloTypeNode *next = o->head, *newnode, *prev = NULL;

    while(next && next->value < ele) {
        prev = next;
        next = next->next;
    }
    newnode = RedisModule_Alloc(sizeof(*newnode));
    newnode->value = ele;
    newnode->next = next;
    if (prev) {
        prev->next = newnode;
    } else {
        o->head = newnode;
    }
    o->len++;
}",71.0,87.0,1.0,1.0,17.0,20,7,21,6,2,8,3,3,1,1,,0,8,4,2,2,void
3341,205367,HelloTypeReleaseObject,1,HelloTypeReleaseObject,void HelloTypeReleaseObject (HelloTypeObject*),modules\hellotype.c,"void HelloTypeReleaseObject(struct HelloTypeObject *o) {
    struct HelloTypeNode *cur, *next;
    cur = o->head;
    while(cur) {
        next = cur->next;
        RedisModule_Free(cur);
        cur = next;
    }
    RedisModule_Free(o);
}",89.0,98.0,1.0,1.0,10.0,5,2,9,3,1,4,2,2,0,2,,0,2,2,1,1,void
3342,205394,HelloTypeInsert_RedisCommand,1,HelloTypeInsert_RedisCommand,"int HelloTypeInsert_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 3) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long value;
    if ((RedisModule_StringToLongLong(argv[2],&value) != REDISMODULE_OK)) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid value: must be a signed 64 bit integer"");
    }

    /* Create an empty value object if the key is currently empty. */
    struct HelloTypeObject *hto;
    if (type == REDISMODULE_KEYTYPE_EMPTY) {
        hto = createHelloTypeObject();
        RedisModule_ModuleTypeSetValue(key,Hel...",103.0,137.0,1.0,8.0,35.0,17,9,27,8,0,17,5,5,3,14,,0,8,6,3,3,int
3343,205510,HelloTypeRange_RedisCommand,1,HelloTypeRange_RedisCommand,"int HelloTypeRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 4) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long first, count;
    if (RedisModule_StringToLongLong(argv[2],&first) != REDISMODULE_OK ||
        RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK ||
        first < 0 || count < 0)
    {
        return RedisModule_ReplyWithError(ctx,
            ""ERR invalid first or count parameters"");
    }

    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
    struct HelloTypeNode *node = hto ? hto->he...",140.0,173.0,1.0,8.0,34.0,33,14,36,12,1,17,5,5,4,13,,0,10,6,3,3,int
3344,205655,HelloTypeLen_RedisCommand,1,HelloTypeLen_RedisCommand,"int HelloTypeLen_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 2) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
    RedisModule_ReplyWithLongLong(ctx,hto ? hto->len : 0);
    return REDISMODULE_OK;
}",176.0,192.0,1.0,8.0,17.0,13,8,17,7,0,10,3,3,2,8,,0,6,6,3,3,int
3345,205835,HelloTypeBRange_RedisCommand,1,HelloTypeBRange_RedisCommand,"int HelloTypeBRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeBRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 5) return RedisModule_WrongArity(ctx);
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    /* Parse the timeout before even trying to serve the client synchronously,
     * so that we always fail ASAP on syntax errors. */
    long long timeout;
    if (RedisModule_StringToLongLong(argv[4],&timeout) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,
            ""ERR invalid timeout parameter"");
    }

    /* Can we serve the reply synchronously? */
    if (type != REDISMODULE_KEYTYPE_EMPTY) {
        retu...",235.0,264.0,1.0,8.0,30.0,17,9,24,8,0,12,5,5,3,11,,0,6,6,3,3,int
3346,205945,HelloTypeRdbLoad,1,HelloTypeRdbLoad,"void* HelloTypeRdbLoad (RedisModuleIO*,int)",modules\hellotype.c,"void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {
    if (encver != 0) {
        /* RedisModule_Log(""warning"",""Can't load data with version %d"", encver);*/
        return NULL;
    }
    uint64_t elements = RedisModule_LoadUnsigned(rdb);
    struct HelloTypeObject *hto = createHelloTypeObject();
    while(elements--) {
        int64_t ele = RedisModule_LoadSigned(rdb);
        HelloTypeInsert(hto,ele);
    }
    return hto;
}",268.0,280.0,1.0,1.0,13.0,5,3,11,6,0,4,3,3,0,4,,0,3,4,2,2,void*
3347,205981,HelloTypeRdbSave,1,HelloTypeRdbSave,"void HelloTypeRdbSave (RedisModuleIO*,void*)",modules\hellotype.c,"void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    RedisModule_SaveUnsigned(rdb,hto->len);
    while(node) {
        RedisModule_SaveSigned(rdb,node->value);
        node = node->next;
    }
}",282.0,290.0,1.0,1.0,9.0,7,2,11,4,0,6,2,2,0,2,,0,4,4,2,2,void
3348,206015,HelloTypeAofRewrite,1,HelloTypeAofRewrite,"void HelloTypeAofRewrite (RedisModuleIO*,RedisModuleString*,void*)",modules\hellotype.c,"void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    while(node) {
        RedisModule_EmitAOF(aof,""HELLOTYPE.INSERT"",""sl"",key,node->value);
        node = node->next;
    }
}",292.0,299.0,1.0,1.0,8.0,6,2,10,5,0,4,2,2,0,1,,0,3,6,3,3,void
3349,206048,HelloTypeMemUsage,1,HelloTypeMemUsage,size_t HelloTypeMemUsage (void*),modules\hellotype.c,"size_t HelloTypeMemUsage(const void *value) {
    const struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    return sizeof(*hto) + sizeof(*node)*hto->len;
}",303.0,307.0,1.0,1.0,5.0,10,6,7,3,0,2,1,1,0,0,,0,2,2,1,1,size_t
3350,206075,HelloTypeFree,1,HelloTypeFree,void HelloTypeFree (void*),modules\hellotype.c,"void HelloTypeFree(void *value) {
    HelloTypeReleaseObject(value);
}",309.0,311.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3351,206082,HelloTypeDigest,1,HelloTypeDigest,"void HelloTypeDigest (RedisModuleDigest*,void*)",modules\hellotype.c,"void HelloTypeDigest(RedisModuleDigest *md, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    while(node) {
        RedisModule_DigestAddLongLong(md,node->value);
        node = node->next;
    }
    RedisModule_DigestEndSequence(md);
}",313.0,321.0,1.0,1.0,9.0,6,2,10,4,0,5,2,2,0,2,,0,3,4,2,2,void
3352,206291,HelloSimple_RedisCommand,1,HelloSimple_RedisCommand,"int HelloSimple_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloSimple_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    RedisModule_ReplyWithLongLong(ctx,RedisModule_GetSelectedDb(ctx));
    return REDISMODULE_OK;
}",48.0,53.0,1.0,4.0,6.0,2,1,6,3,0,2,1,1,0,2,,0,1,6,3,3,int
3353,206318,HelloPushNative_RedisCommand,1,HelloPushNative_RedisCommand,"int HelloPushNative_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloPushNative_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    RedisModule_ListPush(key,REDISMODULE_LIST_TAIL,argv[2]);
    size_t newlen = RedisModule_ValueLength(key);
    RedisModule_CloseKey(key);
    RedisModule_ReplyWithLongLong(ctx,newlen);
    return REDISMODULE_OK;
}",61.0,73.0,1.0,8.0,13.0,8,5,12,5,0,6,2,2,0,6,,0,2,6,3,3,int
3354,206374,HelloPushCall_RedisCommand,1,HelloPushCall_RedisCommand,"int HelloPushCall_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloPushCall_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""RPUSH"",""ss"",argv[1],argv[2]);
    long long len = RedisModule_CallReplyInteger(reply);
    RedisModule_FreeCallReply(reply);
    RedisModule_ReplyWithLongLong(ctx,len);
    return REDISMODULE_OK;
}",80.0,91.0,1.0,11.0,12.0,5,3,11,5,0,5,2,2,0,5,,0,2,6,3,3,int
3355,206416,HelloPushCall2_RedisCommand,1,HelloPushCall2_RedisCommand,"int HelloPushCall2_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloPushCall2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""RPUSH"",""ss"",argv[1],argv[2]);
    RedisModule_ReplyWithCallReply(ctx,reply);
    RedisModule_FreeCallReply(reply);
    return REDISMODULE_OK;
}",96.0,106.0,1.0,11.0,11.0,4,3,9,4,0,4,2,2,0,4,,0,1,6,3,3,int
3356,206453,HelloListSumLen_RedisCommand,1,HelloListSumLen_RedisCommand,"int HelloListSumLen_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloListSumLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""LRANGE"",""sll"",argv[1],(long long)0,(long long)-1);
    size_t strlen = 0;
    size_t items = RedisModule_CallReplyLength(reply);
    size_t j;
    for (j = 0; j < items; j++) {
        RedisModuleCallReply *ele = RedisModule_CallReplyArrayElement(reply,j);
        strlen += RedisModule_CallReplyLength(ele);
    }
    RedisModule_FreeCallReply(reply);
    RedisModule_ReplyWithLongLong(ctx,strlen);
    return REDISMODULE_OK;
}",111.0,128.0,1.0,11.0,18.0,12,7,19,8,0,7,3,3,0,7,,0,3,6,3,3,int
3357,206525,HelloListSplice_RedisCommand,1,HelloListSplice_RedisCommand,"int HelloListSplice_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloListSplice_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
        REDISMODULE_READ|REDISMODULE_WRITE);

    /* Src and dst key must be empty or lists. */
    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
    {
        RedisModule_CloseKey(srckey);
        RedisModule_CloseKey(dstkey);
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long count;
    if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
        (count < 0)) {
        RedisModule_Cl...",134.0,175.0,1.0,8.0,42.0,28,12,36,9,0,21,7,7,5,21,,0,9,6,3,3,int
3358,206687,HelloListSpliceAuto_RedisCommand,1,HelloListSpliceAuto_RedisCommand,"int HelloListSpliceAuto_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloListSpliceAuto_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    RedisModule_AutoMemory(ctx);

    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
        REDISMODULE_READ|REDISMODULE_WRITE);

    /* Src and dst key must be empty or lists. */
    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long count;
    if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
        (count < 0))
    {
        return RedisModule_ReplyWithError(ctx,""ERR inval...",179.0,216.0,1.0,8.0,38.0,28,12,29,9,0,15,7,7,5,15,,0,9,6,3,3,int
3359,206836,HelloRandArray_RedisCommand,1,HelloRandArray_RedisCommand,"int HelloRandArray_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloRandArray_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    long long count;
    if (RedisModule_StringToLongLong(argv[1],&count) != REDISMODULE_OK ||
        count < 0)
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");

    /* To reply with an array, we call RedisModule_ReplyWithArray() followed
     * by other ""count"" calls to other reply functions in order to generate
     * the elements of the array. */
    RedisModule_ReplyWithArray(ctx,count);
    while(count--) RedisModule_ReplyWithLongLong(ctx,rand());
    return REDISMODULE_OK;
}",221.0,234.0,1.0,56.0,14.0,7,6,9,4,0,4,4,4,1,4,,0,1,6,3,3,int
3360,206885,HelloRepl1_RedisCommand,1,HelloRepl1_RedisCommand,"int HelloRepl1_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    RedisModule_AutoMemory(ctx);

    /* This will be replicated *after* the two INCR statements, since
     * the Call() replication has precedence, so the actual replication
     * stream will be:
     *
     * MULTI
     * INCR foo
     * INCR bar
     * ECHO c foo
     * EXEC
     */
    RedisModule_Replicate(ctx,""ECHO"",""c"",""foo"");

    /* Using the ""!"" modifier we replicate the command if it
     * modified the dataset in some way. */
    RedisModule_Call(ctx,""INCR"",""c!"",""foo"");
    RedisModule_Call(ctx,""INCR"",""c!"",""bar"");

    RedisModule_ReplyWithLongLong(ctx,0);

    return REDISMODULE_OK;
}",240.0,266.0,1.0,4.0,27.0,2,1,9,3,0,5,1,1,0,5,,0,0,6,3,3,int
3361,206928,HelloRepl2_RedisCommand,1,HelloRepl2_RedisCommand,"int HelloRepl2_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloRepl2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_LIST)
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);

    size_t listlen = RedisModule_ValueLength(key);
    long long sum = 0;

    /* Rotate and increment. */
    while(listlen--) {
        RedisModuleString *ele = RedisModule_ListPop(key,REDISMODULE_LIST_TAIL);
        long long val;
        if (RedisModule_StringToLongLong(ele,&val) != REDISMODULE_OK) val = 0;
        val++;
        sum += val;
        RedisModuleString *newele = RedisModule_CreateStringFromLongLong(ctx,val);
        RedisModule_ListPush(key,REDISMODULE_LIST_HEAD,newele);
    }
    RedisModule_ReplyWithLongLong(...",278.0,304.0,1.0,8.0,27.0,17,9,28,9,0,12,5,6,2,12,,0,6,6,3,3,int
3362,207039,HelloToggleCase_RedisCommand,1,HelloToggleCase_RedisCommand,"int HelloToggleCase_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloToggleCase_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    int keytype = RedisModule_KeyType(key);
    if (keytype != REDISMODULE_KEYTYPE_STRING &&
        keytype != REDISMODULE_KEYTYPE_EMPTY)
    {
        RedisModule_CloseKey(key);
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    if (keytype == REDISMODULE_KEYTYPE_STRING) {
        size_t len, j;
        char *s = RedisModule_StringDMA(key,&len,REDISMODULE_WRITE);
        for (j = 0; j < len; j++) {
            if (isupper(s[j])) {
                s[j] = tolower(s[j]);
            } else {
                s[j] = toupper(s[j]);
            }
        }
    }

    RedisModule_CloseKey(key);
    RedisModule_ReplyWithSimpleString(ctx,""OK"");
    RedisModule_ReplicateVerbatim(ctx);
    return REDISMODU...",314.0,344.0,1.0,8.0,31.0,20,9,27,8,0,9,6,9,0,9,,0,3,6,3,3,int
3363,207166,HelloMoreExpire_RedisCommand,1,HelloMoreExpire_RedisCommand,"int HelloMoreExpire_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloMoreExpire_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    if (argc != 3) return RedisModule_WrongArity(ctx);

    mstime_t addms, expire;

    if (RedisModule_StringToLongLong(argv[2],&addms) != REDISMODULE_OK)
        return RedisModule_ReplyWithError(ctx,""ERR invalid expire time"");

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    expire = RedisModule_GetExpire(key);
    if (expire != REDISMODULE_NO_EXPIRE) {
        expire += addms;
        RedisModule_SetExpire(key,expire);
    }
    return RedisModule_ReplyWithSimpleString(ctx,""OK"");
}",350.0,367.0,1.0,56.0,18.0,13,8,17,6,0,8,4,4,1,8,,0,3,6,3,3,int
3364,207242,HelloZsumRange_RedisCommand,1,HelloZsumRange_RedisCommand,"int HelloZsumRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloZsumRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    double score_start, score_end;
    if (argc != 4) return RedisModule_WrongArity(ctx);

    if (RedisModule_StringToDouble(argv[2],&score_start) != REDISMODULE_OK ||
        RedisModule_StringToDouble(argv[3],&score_end) != REDISMODULE_OK)
    {
        return RedisModule_ReplyWithError(ctx,""ERR invalid range"");
    }

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    double scoresum_a = 0;
    double scoresum_b = 0;

    RedisModule_ZsetFirstInScoreRange(key,score_start,score_end,0,0);
    while(!RedisModule_ZsetRangeEndReached(key)) {
        double score;
        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
        RedisModule_FreeString(ctx,ele);
       ...",375.0,421.0,1.0,60.0,47.0,24,9,46,10,0,23,6,6,5,23,,0,8,6,3,3,int
3365,207400,HelloLexRange_RedisCommand,1,HelloLexRange_RedisCommand,"int HelloLexRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloLexRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 6) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    if (RedisModule_ZsetFirstInLexRange(key,argv[2],argv[3]) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""invalid range"");
    }

    int arraylen = 0;
    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    while(!RedisModule_ZsetRangeEndReached(key)) {
        double score;
        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
        RedisModule_ReplyWithString(ctx,ele);
        RedisModule_FreeString(ctx,ele);
        RedisModule_ZsetRangeNext(key);
    ...",430.0,459.0,1.0,8.0,30.0,16,9,28,7,0,16,5,5,3,16,,0,5,6,3,3,int
3366,207512,HelloHCopy_RedisCommand,1,HelloHCopy_RedisCommand,"int HelloHCopy_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 4) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_HASH &&
        type != REDISMODULE_KEYTYPE_EMPTY)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    /* Get the old field value. */
    RedisModuleString *oldval;
    RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);
    if (oldval) {
        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);
    }
    RedisModule_ReplyWithLongLong(ctx,oldval != NULL);
    return REDISMODULE_OK;
}",468.0,489.0,1.0,8.0,22.0,14,7,23,7,0,8,4,4,0,8,,0,2,6,3,3,int
3367,207606,HelloLeftPad_RedisCommand,1,HelloLeftPad_RedisCommand,"int HelloLeftPad_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloLeftPad_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    long long padlen;

    if (argc != 4) return RedisModule_WrongArity(ctx);

    if ((RedisModule_StringToLongLong(argv[2],&padlen) != REDISMODULE_OK) ||
        (padlen< 0)) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid padding length"");
    }
    size_t strlen, chlen;
    const char *str = RedisModule_StringPtrLen(argv[1], &strlen);
    const char *ch = RedisModule_StringPtrLen(argv[3], &chlen);

    /* If the string is already larger than the target len, just return
     * the string itself. */
    if (strlen >= (size_t)padlen)
        return RedisModule_ReplyWithString(ctx,argv[1]);

    /* Padding must be a single character in this simple implementation. */
    if (chlen != 1)
        return RedisModule_ReplyWithError(ctx,
            ""ERR padding must be a single char"");

    /* Here we use our pool al...",509.0,541.0,1.0,58.0,33.0,23,10,36,10,0,10,6,6,1,10,,0,4,6,3,3,int
3368,208091,getMonotonicUs,1,getMonotonicUs,monotime getMonotonicUs (void),monotonic.c,monotime (*getMonotonicUs)(void) = NULL;,12.0,12.0,10.0,39.0,1.0,0,0,0,0,24,0,1,1,0,0,,0,0,2,1,1,monotime
3369,208126,monotonicInit_posix,1,monotonicInit_posix,void monotonicInit_posix (void),monotonic.c,"static void monotonicInit_posix(void) {
    /* Ensure that CLOCK_MONOTONIC is supported.  This should be supported
     * on any reasonably current OS.  If the assertion below fails, provide
     * an appropriate alternate implementation.  */
    struct timespec ts;
    int rc = clock_gettime(CLOCK_MONOTONIC, &ts);
    assert(rc == 0);

    snprintf(monotonic_info_string, sizeof(monotonic_info_string),
            ""POSIX clock_gettime"");
    getMonotonicUs = getMonotonicUs_posix;
}",143.0,154.0,1.0,1.0,12.0,5,4,7,5,1,2,1,1,0,0,,0,2,2,1,1,void
3370,208151,monotonicInit,1,monotonicInit,const char* monotonicInit (void),monotonic.c,"const char * monotonicInit(void) {
    #if defined(USE_PROCESSOR_CLOCK) && defined(__x86_64__) && defined(__linux__)
    if (getMonotonicUs == NULL) monotonicInit_x86linux();
    #endif

    #if defined(USE_PROCESSOR_CLOCK) && defined(__aarch64__)
    if (getMonotonicUs == NULL) monotonicInit_aarch64();
    #endif

    if (getMonotonicUs == NULL) monotonicInit_posix();

    return monotonic_info_string;
}",158.0,170.0,1.0,1.0,13.0,1,1,3,3,2,2,2,2,0,1,,0,1,2,1,1,const char*
3371,208164,monotonicInfoString,1,monotonicInfoString,const char* monotonicInfoString (void),monotonic.c,"const char *monotonicInfoString(void) {
    return monotonic_info_string;
}",172.0,174.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,0,,0,1,2,1,1,const char*
3372,208221,elapsedStart,1,elapsedStart,void elapsedStart (monotime*),monotonic.h,"static inline void elapsedStart(monotime *start_time) {
    *start_time = getMonotonicUs();
}",49.0,51.0,1.0,1.0,3.0,2,2,1,1,4,1,1,1,0,1,,0,1,2,1,1,void
3373,208230,elapsedUs,1,elapsedUs,uint64_t elapsedUs (monotime),monotonic.h,"static inline uint64_t elapsedUs(monotime start_time) {
    return getMonotonicUs() - start_time;
}",53.0,55.0,1.0,1.0,3.0,1,1,1,1,7,1,1,1,0,1,,0,0,2,1,1,uint64_t
3374,208239,elapsedMs,1,elapsedMs,uint64_t elapsedMs (monotime),monotonic.h,"static inline uint64_t elapsedMs(monotime start_time) {
    return elapsedUs(start_time) / 1000;
}",57.0,59.0,1.0,1.0,3.0,1,1,1,1,5,1,1,1,0,1,,0,0,2,1,1,uint64_t
3375,208271,init_genrand64,1,init_genrand64,void init_genrand64 (long long unsigned),mt19937-64.c,"void init_genrand64(unsigned long long seed)
{
    mt[0] = seed;
    for (mti=1; mti<NN; mti++)
        mt[mti] =  (6364136223846793005ULL * (mt[mti-1] ^ (mt[mti-1] >> 62)) + mti);
}",73.0,78.0,1.0,20.0,6.0,4,3,4,3,4,3,2,2,1,0,,0,3,2,1,1,void
3376,208314,init_by_array64,1,init_by_array64,"void init_by_array64 (long long unsigned[],long long unsigned)",mt19937-64.c,"void init_by_array64(unsigned long long init_key[],
                     unsigned long long key_length)
{
    unsigned long long i, j, k;
    init_genrand64(19650218ULL);
    i=1; j=0;
    k = (NN>key_length ? NN : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 62)) * 3935559000370003845ULL))
          + init_key[j] + j; /* non linear */
        i++; j++;
        if (i>=NN) { mt[0] = mt[NN-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=NN-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 62)) * 2862933555777941757ULL))
          - i; /* non linear */
        i++;
        if (i>=NN) { mt[0] = mt[NN-1]; i=1; }
    }

    mt[0] = 1ULL << 63; /* MSB is 1; assuring non-zero initial array */
}",83.0,105.0,1.0,9.0,23.0,53,12,43,6,0,14,6,9,0,1,,0,13,4,2,2,void
3377,208477,genrand64_int64,1,genrand64_int64,unsigned long long genrand64_int64 (void),mt19937-64.c,"unsigned long long genrand64_int64(void)
{
    int i;
    unsigned long long x;
    static unsigned long long mag01[2]={0ULL, MATRIX_A};

    if (mti >= NN) { /* generate NN words at one time */

        /* if init_genrand64() has not been called, */
        /* a default initial seed is used     */
        if (mti == NN+1)
            init_genrand64(5489ULL);

        for (i=0;i<NN-MM;i++) {
            x = (mt[i]&UM)|(mt[i+1]&LM);
            mt[i] = mt[i+MM] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
        }
        for (;i<NN-1;i++) {
            x = (mt[i]&UM)|(mt[i+1]&LM);
            mt[i] = mt[i+(MM-NN)] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
        }
        x = (mt[NN-1]&UM)|(mt[0]&LM);
        mt[NN-1] = mt[MM-1] ^ (x>>1) ^ mag01[(int)(x&1ULL)];

        mti = 0;
    }

    x = mt[mti++];

    x ^= (x >> 29) & 0x5555555555555555ULL;
    x ^= (x << 17) & 0x71D67FFFEDA60000ULL;
    x ^= (x << 37) & 0xFFF7EEE000000000ULL;
    x ^= (x >> 43);

    return x;
}",108.0,143.0,1.0,46.0,36.0,74,15,51,5,7,18,5,8,2,1,,0,17,2,1,1,unsigned long long
3378,208712,genrand64_int63,1,genrand64_int63,long long genrand64_int63 (void),mt19937-64.c,"long long genrand64_int63(void)
{
    return (long long)(genrand64_int64() >> 1);
}",146.0,149.0,1.0,1.0,4.0,2,2,0,0,0,1,1,1,0,1,,0,0,2,1,1,long long
3379,208723,genrand64_real1,1,genrand64_real1,double genrand64_real1 (void),mt19937-64.c,"double genrand64_real1(void)
{
    return (genrand64_int64() >> 11) * (1.0/9007199254740991.0);
}",152.0,155.0,1.0,1.0,4.0,3,3,0,0,0,1,1,1,0,1,,0,0,2,1,1,double
3380,208736,genrand64_real2,1,genrand64_real2,double genrand64_real2 (void),mt19937-64.c,"double genrand64_real2(void)
{
    return (genrand64_int64() >> 11) * (1.0/9007199254740992.0);
}",158.0,161.0,1.0,1.0,4.0,3,3,0,0,0,1,1,1,0,1,,0,0,2,1,1,double
3381,208749,genrand64_real3,1,genrand64_real3,double genrand64_real3 (void),mt19937-64.c,"double genrand64_real3(void)
{
    return ((genrand64_int64() >> 12) + 0.5) * (1.0/4503599627370496.0);
}",164.0,167.0,1.0,1.0,4.0,4,4,0,0,0,1,1,1,0,1,,0,0,2,1,1,double
3382,208817,initClientMultiState,1,initClientMultiState,void initClientMultiState (client*),multi.c,"void initClientMultiState(client *c) {
    c->mstate.commands = NULL;
    c->mstate.count = 0;
    c->mstate.cmd_flags = 0;
    c->mstate.cmd_inv_flags = 0;
    c->mstate.argv_len_sums = 0;
    c->mstate.alloc_count = 0;
}",35.0,42.0,1.0,1.0,8.0,18,3,7,2,2,6,1,1,0,0,,0,6,2,1,1,void
3383,208864,freeClientMultiState,1,freeClientMultiState,void freeClientMultiState (client*),multi.c,"void freeClientMultiState(client *c) {
    int j;

    for (j = 0; j < c->mstate.count; j++) {
        int i;
        multiCmd *mc = c->mstate.commands+j;

        for (i = 0; i < mc->argc; i++)
            decrRefCount(mc->argv[i]);
        zfree(mc->argv);
    }
    zfree(c->mstate.commands);
}",45.0,57.0,1.0,1.0,13.0,14,5,11,4,2,7,3,4,2,2,,0,5,2,1,1,void
3384,208924,queueMultiCommand,1,queueMultiCommand,"void queueMultiCommand (client*,uint64_t)",multi.c,"void queueMultiCommand(client *c, uint64_t cmd_flags) {
    multiCmd *mc;

    /* No sense to waste memory if the transaction is already aborted.
     * this is useful in case client sends these in a pipeline, or doesn't
     * bother to read previous responses and didn't notice the multi was already
     * aborted. */
    if (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC))
        return;
    if (c->mstate.count == 0) {
        /* If a client is using multi/exec, assuming it is used to execute at least
         * two commands. Hence, creating by default size of 2. */
        c->mstate.commands = zmalloc(sizeof(multiCmd)*2);
        c->mstate.alloc_count = 2;
    }
    if (c->mstate.count == c->mstate.alloc_count) {
        c->mstate.alloc_count = c->mstate.alloc_count < INT_MAX/2 ? c->mstate.alloc_count*2 : INT_MAX;
        c->mstate.commands = zrealloc(c->mstate.commands, sizeof(multiCmd)*(c->mstate.alloc_count));
    }
    mc = c->mstate.commands+c->mstate.count;
    mc->cmd = c...",60.0,96.0,1.0,20.0,37.0,83,16,41,7,2,34,4,4,4,2,,0,34,4,2,2,void
3385,209131,discardTransaction,1,discardTransaction,void discardTransaction (client*),multi.c,"void discardTransaction(client *c) {
    freeClientMultiState(c);
    initClientMultiState(c);
    c->flags &= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);
    unwatchAllKeys(c);
}",98.0,103.0,1.0,18.0,6.0,7,4,4,1,7,4,1,1,0,3,,0,1,2,1,1,void
3386,209164,flagTransaction,1,flagTransaction,void flagTransaction (client*),multi.c,"void flagTransaction(client *c) {
    if (c->flags & CLIENT_MULTI)
        c->flags |= CLIENT_DIRTY_EXEC;
}",107.0,110.0,1.0,19.0,4.0,5,3,2,1,2,2,2,2,1,0,,0,2,2,1,1,void
3387,209189,multiCommand,1,multiCommand,void multiCommand (client*),multi.c,"void multiCommand(client *c) {
    if (c->flags & CLIENT_MULTI) {
        addReplyError(c,""MULTI calls can not be nested"");
        return;
    }
    c->flags |= CLIENT_MULTI;

    addReply(c,shared.ok);
}",112.0,120.0,1.0,19.0,9.0,6,4,5,2,0,4,2,2,1,2,,0,2,2,1,1,void
3388,209223,discardCommand,1,discardCommand,void discardCommand (client*),multi.c,"void discardCommand(client *c) {
    if (!(c->flags & CLIENT_MULTI)) {
        addReplyError(c,""DISCARD without MULTI"");
        return;
    }
    discardTransaction(c);
    addReply(c,shared.ok);
}",122.0,129.0,1.0,21.0,8.0,5,5,5,2,0,4,2,2,1,3,,0,1,2,1,1,void
3389,209251,execCommandAbort,1,execCommandAbort,"void execCommandAbort (client*,sds)",multi.c,"void execCommandAbort(client *c, sds error) {
    discardTransaction(c);

    if (error[0] == '-') error++;
    addReplyErrorFormat(c, ""-EXECABORT Transaction discarded because of: %s"", error);

    /* Send EXEC to clients waiting data from MONITOR. We did send a MULTI
     * already, and didn't send any of the queued commands, now we'll just send
     * EXEC so it is clear that the transaction is over. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
}",136.0,146.0,1.0,1.0,11.0,8,5,10,3,2,6,2,2,0,3,,0,3,4,2,2,void
3390,209288,execCommand,1,execCommand,void execCommand (client*),multi.c,"void execCommand(client *c) {
    int j;
    robj **orig_argv;
    int orig_argc, orig_argv_len;
    struct redisCommand *orig_cmd;

    if (!(c->flags & CLIENT_MULTI)) {
        addReplyError(c,""EXEC without MULTI"");
        return;
    }

    /* EXEC with expired watched key is disallowed*/
    if (isWatchedKeyExpired(c)) {
        c->flags |= (CLIENT_DIRTY_CAS);
    }

    /* Check if we need to abort the EXEC because:
     * 1) Some WATCHed key was touched.
     * 2) There was a previous error while queueing commands.
     * A failed EXEC in the first case returns a multi bulk nil object
     * (technically it is not an error but a special behavior), while
     * in the second an EXECABORT error is returned. */
    if (c->flags & (CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC)) {
        if (c->flags & CLIENT_DIRTY_EXEC) {
            addReplyErrorObject(c, shared.execaborterr);
        } else {
            addReply(c, shared.nullarray[c->resp]);
        }

        discardTransaction(c);...",148.0,256.0,1.0,21.0,109.0,110,12,81,13,0,45,13,13,5,10,,0,37,2,1,1,void
3391,209716,watchedKeyLinkToClients,1,watchedKeyLinkToClients,"void watchedKeyLinkToClients (list*,watchedKey*)",multi.c,"static inline void watchedKeyLinkToClients(list *clients, watchedKey *wk) {
    wk->node.value = clients; /* Point the value back to the list */
    listLinkNodeTail(clients, &wk->node); /* Link the embedded node */
}",283.0,286.0,1.0,1.0,4.0,5,4,4,2,1,3,1,1,0,1,,0,2,4,2,2,void
3392,209735,watchedKeyGetClients,1,watchedKeyGetClients,list watchedKeyGetClients (watchedKey*),multi.c,"static inline list *watchedKeyGetClients(watchedKey *wk) {
    return listNodeValue(&wk->node); /* embedded node->value points back to the list */
}",289.0,291.0,1.0,11.0,3.0,5,2,2,1,1,2,1,1,0,0,,0,2,2,1,1,list
3393,209753,watchedKeyGetClientNode,1,watchedKeyGetClientNode,listNode watchedKeyGetClientNode (watchedKey*),multi.c,"static inline listNode *watchedKeyGetClientNode(watchedKey *wk) {
    return &wk->node;
}",295.0,297.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,listNode
3394,209763,watchForKey,1,watchForKey,"void watchForKey (client*,robj*)",multi.c,"void watchForKey(client *c, robj *key) {
    list *clients = NULL;
    listIter li;
    listNode *ln;
    watchedKey *wk;

    /* Check if we are already watching for this key */
    listRewind(c->watched_keys,&li);
    while((ln = listNext(&li))) {
        wk = listNodeValue(ln);
        if (wk->db == c->db && equalStringObjects(key,wk->key))
            return; /* Key already watched */
    }
    /* This key is not already watched in this DB. Let's add it */
    clients = dictFetchValue(c->db->watched_keys,key);
    if (!clients) {
        clients = listCreate();
        dictAdd(c->db->watched_keys,key,clients);
        incrRefCount(key);
    }
    /* Add the new key to the list of keys watched by this client */
    wk = zmalloc(sizeof(*wk));
    wk->key = key;
    wk->client = c;
    wk->db = c->db;
    wk->expired = keyIsExpired(c->db, key);
    incrRefCount(key);
    listAddNodeTail(c->watched_keys, wk);
    watchedKeyLinkToClients(clients, wk);
}",300.0,329.0,1.0,13.0,30.0,33,8,38,7,0,26,4,5,5,12,,0,20,4,2,2,void
3395,209881,unwatchAllKeys,1,unwatchAllKeys,void unwatchAllKeys (client*),multi.c,"void unwatchAllKeys(client *c) {
    listIter li;
    listNode *ln;

    if (listLength(c->watched_keys) == 0) return;
    listRewind(c->watched_keys,&li);
    while((ln = listNext(&li))) {
        list *clients;
        watchedKey *wk;

        /* Remove the client's wk from the list of clients watching the key. */
        wk = listNodeValue(ln);
        clients = watchedKeyGetClients(wk);
        serverAssertWithInfo(c,NULL,clients != NULL);
        listUnlinkNode(clients, watchedKeyGetClientNode(wk));
        /* Kill the entry at all if this was the only client */
        if (listLength(clients) == 0)
            dictDelete(wk->db->watched_keys, wk->key);
        /* Remove this watched key from the client->watched list */
        listDelNode(c->watched_keys,ln);
        decrRefCount(wk->key);
        zfree(wk);
    }
}",333.0,356.0,1.0,8.0,24.0,23,9,27,6,5,19,4,5,4,10,,0,12,2,1,1,void
3396,209984,isWatchedKeyExpired,1,isWatchedKeyExpired,int isWatchedKeyExpired (client*),multi.c,"int isWatchedKeyExpired(client *c) {
    listIter li;
    listNode *ln;
    watchedKey *wk;
    if (listLength(c->watched_keys) == 0) return 0;
    listRewind(c->watched_keys,&li);
    while ((ln = listNext(&li))) {
        wk = listNodeValue(ln);
        if (wk->expired) continue; /* was expired when WATCH was called */
        if (keyIsExpired(wk->db, wk->key)) return 1;
    }

    return 0;
}",360.0,373.0,1.0,8.0,14.0,13,4,12,4,1,10,6,7,7,3,,0,9,2,1,1,int
3397,210048,touchWatchedKey,1,touchWatchedKey,"void touchWatchedKey (redisDb*,robj*)",multi.c,"void touchWatchedKey(redisDb *db, robj *key) {
    list *clients;
    listIter li;
    listNode *ln;

    if (dictSize(db->watched_keys) == 0) return;
    clients = dictFetchValue(db->watched_keys, key);
    if (!clients) return;

    /* Mark all the clients watching this key as CLIENT_DIRTY_CAS */
    /* Check if we are already watching for this key */
    listRewind(clients,&li);
    while((ln = listNext(&li))) {
        watchedKey *wk = redis_member2struct(watchedKey, node, ln);
        client *c = wk->client;

        if (wk->expired) {
            /* The key was already expired when WATCH was called. */
            if (db == wk->db &&
                equalStringObjects(key, wk->key) &&
                dictFind(db->dict, key->ptr) == NULL)
            {
                /* Already expired key is deleted, so logically no change. Clear
                 * the flag. Deleted keys are not flagged as expired. */
                wk->expired = 0;
                goto skip_client;
        ...",377.0,416.0,1.0,8.0,40.0,34,11,31,10,1,17,9,9,10,6,,0,15,4,2,2,void
3398,210176,touchAllWatchedKeysInDb,1,touchAllWatchedKeysInDb,"void touchAllWatchedKeysInDb (redisDb*,redisDb*)",multi.c,"void touchAllWatchedKeysInDb(redisDb *emptied, redisDb *replaced_with) {
    listIter li;
    listNode *ln;
    dictEntry *de;

    if (dictSize(emptied->watched_keys) == 0) return;

    dictIterator *di = dictGetSafeIterator(emptied->watched_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        int exists_in_emptied = dictFind(emptied->dict, key->ptr) != NULL;
        if (exists_in_emptied ||
            (replaced_with && dictFind(replaced_with->dict, key->ptr)))
        {
            list *clients = dictGetVal(de);
            if (!clients) continue;
            listRewind(clients,&li);
            while((ln = listNext(&li))) {
                watchedKey *wk = redis_member2struct(watchedKey, node, ln);
                if (wk->expired) {
                    if (!replaced_with || !dictFind(replaced_with->dict, key->ptr)) {
                        /* Expired key now deleted. No logical change. Clear the
                         * flag. Deleted ke...",425.0,468.0,1.0,8.0,44.0,43,13,41,14,4,21,10,20,10,10,,0,19,4,2,2,void
3399,210358,watchCommand,1,watchCommand,void watchCommand (client*),multi.c,"void watchCommand(client *c) {
    int j;

    if (c->flags & CLIENT_MULTI) {
        addReplyError(c,""WATCH inside MULTI is not allowed"");
        return;
    }
    /* No point in watching if the client is already dirty. */
    if (c->flags & CLIENT_DIRTY_CAS) {
        addReply(c,shared.ok);
        return;
    }
    for (j = 1; j < c->argc; j++)
        watchForKey(c,c->argv[j]);
    addReply(c,shared.ok);
}",470.0,485.0,1.0,19.0,16.0,11,6,10,3,0,6,4,4,3,3,,0,3,2,1,1,void
3400,210420,unwatchCommand,1,unwatchCommand,void unwatchCommand (client*),multi.c,"void unwatchCommand(client *c) {
    unwatchAllKeys(c);
    c->flags &= (~CLIENT_DIRTY_CAS);
    addReply(c,shared.ok);
}",487.0,491.0,1.0,18.0,5.0,4,4,4,2,0,3,1,1,0,2,,0,1,2,1,1,void
3401,210442,multiStateMemOverhead,1,multiStateMemOverhead,size_t multiStateMemOverhead (client*),multi.c,"size_t multiStateMemOverhead(client *c) {
    size_t mem = c->mstate.argv_len_sums;
    /* Add watched keys overhead, Note: this doesn't take into account the watched keys themselves, because they aren't managed per-client. */
    mem += listLength(c->watched_keys) * (sizeof(listNode) + sizeof(watchedKey));
    /* Reserved memory for queued multi commands. */
    mem += c->mstate.alloc_count * sizeof(multiCmd);
    return mem;
}",493.0,500.0,1.0,11.0,8.0,16,7,11,5,1,4,1,1,0,0,,0,4,2,1,1,size_t
3402,210508,setProtocolError,1,setProtocolError,"void setProtocolError (char*,client*)",networking.c,"static void setProtocolError(const char *errstr, client *c) {
    if (server.verbosity <= LL_VERBOSE || c->flags & CLIENT_MASTER) {
        sds client = catClientInfoString(sdsempty(),c);

        /* Sample some protocol to given an idea about what was inside. */
        char buf[256];
        if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {
            snprintf(buf,sizeof(buf),""Query buffer during protocol error: '%s'"", c->querybuf+c->qb_pos);
        } else {
            snprintf(buf,sizeof(buf),""Query buffer during protocol error: '%.*s' (... more %zu bytes ...) '%.*s'"", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2);
        }

        /* Remove non printable chars. */
        char *p = buf;
        while (*p != '\0') {
            if (!isprint(*p)) *p = '.';
            p++;
        }

        /* Log all the client and protocol info. */
        int loglevel = (c->fla...",2213.0,2240.0,1.0,28.0,28.0,0,0,0,0,8,0,1,1,0,0,,0,0,4,2,2,void
3403,210520,postponeClientRead,1,postponeClientRead,int postponeClientRead (client*),networking.c,"int postponeClientRead(client *c) {
    if (server.io_threads_active &&
        server.io_threads_do_reads &&
        !ProcessingEventsWhileBlocked &&
        !(c->flags & (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_BLOCKED)) &&
        io_threads_op == IO_THREADS_OP_IDLE)
    {
        listAddNodeHead(server.clients_pending_read,c);
        c->pending_read_list_node = listFirst(server.clients_pending_read);
        return 1;
    } else {
        return 0;
    }
}",4416.0,4429.0,1.0,22.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3404,210525,getClientSockname,1,getClientSockname,char* getClientSockname (client*),networking.c,"char *getClientSockname(client *c) {
    char sockname[NET_ADDR_STR_LEN] = {0};

    if (c->sockname == NULL) {
        genClientAddrString(c,sockname,sizeof(sockname),0);
        c->sockname = sdsnew(sockname);
    }
    return c->sockname;
}",2760.0,2768.0,1.0,18.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,char*
3405,210534,sdsZmallocSize,1,sdsZmallocSize,size_t sdsZmallocSize (sds),networking.c,"size_t sdsZmallocSize(sds s) {
    void *sh = sdsAllocPtr(s);
    return zmalloc_size(sh);
}",49.0,52.0,1.0,1.0,4.0,1,1,3,2,10,2,1,1,0,2,,0,1,2,1,1,size_t
3406,210547,getStringObjectSdsUsedMemory,1,getStringObjectSdsUsedMemory,size_t getStringObjectSdsUsedMemory (robj*),networking.c,"size_t getStringObjectSdsUsedMemory(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    switch(o->encoding) {
    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
    default: return 0; /* Just integer encoding for now. */
    }
}",56.0,63.0,1.0,4.0,8.0,10,8,9,3,2,3,2,2,0,3,,0,0,2,1,1,size_t
3407,210601,getStringObjectLen,1,getStringObjectLen,size_t getStringObjectLen (robj*),networking.c,"size_t getStringObjectLen(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    switch(o->encoding) {
    case OBJ_ENCODING_RAW: return sdslen(o->ptr);
    case OBJ_ENCODING_EMBSTR: return sdslen(o->ptr);
    default: return 0; /* Just integer encoding for now. */
    }
}",67.0,74.0,1.0,4.0,8.0,9,6,8,2,2,3,2,2,0,3,,0,0,2,1,1,size_t
3408,210654,dupClientReplyValue,1,dupClientReplyValue,void* dupClientReplyValue (void*),networking.c,"void *dupClientReplyValue(void *o) {
    clientReplyBlock *old = o;
    clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
    memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
    return buf;
}",77.0,82.0,1.0,1.0,6.0,8,4,10,4,0,3,1,1,0,1,,0,3,2,1,1,void*
3409,210684,freeClientReplyValue,1,freeClientReplyValue,void freeClientReplyValue (void*),networking.c,"void freeClientReplyValue(void *o) {
    zfree(o);
}",84.0,86.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3410,210691,linkClient,1,linkClient,void linkClient (client*),networking.c,"void linkClient(client *c) {
    listAddNodeTail(server.clients,c);
    /* Note that we remember the linked list node where the client is stored,
     * this way removing the client in unlinkClient() will not require
     * a linear scan, but just a constant time operation. */
    c->client_list_node = listLast(server.clients);
    uint64_t id = htonu64(c->id);
    raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
}",90.0,98.0,1.0,26.0,9.0,13,6,13,4,1,6,1,1,0,3,,0,4,2,1,1,void
3411,210739,clientSetDefaultAuth,1,clientSetDefaultAuth,void clientSetDefaultAuth (client*),networking.c,"static void clientSetDefaultAuth(client *c) {
    /* If the default user does not require authentication, the user is
     * directly authenticated. */
    c->user = DefaultUser;
    c->authenticated = (c->user->flags & USER_FLAG_NOPASS) &&
                       !(c->user->flags & USER_FLAG_DISABLED);
}",102.0,108.0,1.0,41.0,7.0,14,6,5,2,2,4,1,1,0,0,,0,4,2,1,1,void
3412,210777,authRequired,1,authRequired,int authRequired (client*),networking.c,"int authRequired(client *c) {
    /* Check if the user is authenticated. This check is skipped in case
     * the default user is flagged as ""nopass"" and is active. */
    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||
                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&
                        !c->authenticated;
    return auth_required;
}",110.0,117.0,1.0,48.0,8.0,12,7,5,3,1,1,1,1,0,0,,0,1,2,1,1,int
3413,210812,createClient,1,createClient,client createClient (connection*),redis-benchmark.c,"static client createClient(char *cmd, size_t len, client from, int thread_id) {
    int j;
    int is_cluster_client = (config.cluster_mode && thread_id >= 0);
    client c = zmalloc(sizeof(struct _client));

    const char *ip = NULL;
    int port = 0;
    c->cluster_node = NULL;
    if (config.hostsocket == NULL || is_cluster_client) {
        if (!is_cluster_client) {
            ip = config.conn_info.hostip;
            port = config.conn_info.hostport;
        } else {
            int node_idx = 0;
            if (config.num_threads < config.cluster_node_count)
                node_idx = config.liveclients % config.cluster_node_count;
            else
                node_idx = thread_id % config.cluster_node_count;
            clusterNode *node = config.cluster_nodes[node_idx];
            assert(node != NULL);
            ip = (const char *) node->ip;
            port = node->port;
            c->cluster_node = node;
        }
        c->context = redisConnectNonBlock(ip,port...",663.0,850.0,1.0,26.0,188.0,170,7,131,9,7,97,4,5,0,18,,0,87,8,4,4,client
3414,211285,installClientWriteHandler,1,installClientWriteHandler,void installClientWriteHandler (client*),networking.c,"void installClientWriteHandler(client *c) {
    int ae_barrier = 0;
    /* For the fsync=always policy, we want that a given FD is never
     * served for reading and writing in the same event loop iteration,
     * so that in the middle of receiving the query, and serving it
     * to the client, we'll call beforeSleep() that will do the
     * actual fsync of AOF to disk. the write barrier ensures that. */
    if (server.aof_state == AOF_ON &&
        server.aof_fsync == AOF_FSYNC_ALWAYS)
    {
        ae_barrier = 1;
    }
    if (connSetWriteHandlerWithBarrier(c->conn, sendReplyToClient, ae_barrier) == C_ERR) {
        freeClientAsync(c);
    }
}",220.0,235.0,1.0,28.0,16.0,10,6,8,4,2,3,3,3,2,2,,0,2,2,1,1,void
3415,211329,putClientInPendingWriteQueue,1,putClientInPendingWriteQueue,void putClientInPendingWriteQueue (client*),networking.c,"void putClientInPendingWriteQueue(client *c) {
    /* Schedule the client to write the output buffers to the socket only
     * if not already done and, for slaves, if the slave can actually receive
     * writes at this stage. */
    if (!(c->flags & CLIENT_PENDING_WRITE) &&
        (c->replstate == REPL_STATE_NONE ||
         (c->replstate == SLAVE_STATE_ONLINE && !c->repl_start_cmd_stream_on_ack)))
    {
        /* Here instead of installing the write handler, we just flag the
         * client and put it into a list of clients that have something
         * to write to the socket. This way before re-entering the event
         * loop, we can try to directly write to the client sockets avoiding
         * a system call. We'll only really install the write handler if
         * we'll not be able to write the whole reply at once. */
        c->flags |= CLIENT_PENDING_WRITE;
        listLinkNodeHead(server.clients_pending_write, &c->clients_pending_write_node);
    }
}",244.0,261.0,1.0,21.0,18.0,18,9,8,3,3,7,2,2,4,1,,0,6,2,1,1,void
3416,211382,prepareClientToWrite,1,prepareClientToWrite,int prepareClientToWrite (client*),networking.c,"int prepareClientToWrite(client *c) {
    /* If it's the Lua client we always return ok without installing any
     * handler since there is no socket at all. */
    if (c->flags & (CLIENT_SCRIPT|CLIENT_MODULE)) return C_OK;

    /* If CLIENT_CLOSE_ASAP flag is set, we need not write anything. */
    if (c->flags & CLIENT_CLOSE_ASAP) return C_ERR;

    /* CLIENT REPLY OFF / SKIP handling: don't send replies.
     * CLIENT_PUSHING handling: disables the reply silencing flags. */
    if ((c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) &&
        !(c->flags & CLIENT_PUSHING)) return C_ERR;

    /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
     * is set. */
    if ((c->flags & CLIENT_MASTER) &&
        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;

    if (!c->conn) return C_ERR; /* Fake client for AOF loading. */

    /* Schedule the client to write the output buffers to the socket, unless
     * it should already be setup to do so (it has already ...",285.0,317.0,1.0,20.0,33.0,35,8,10,2,7,9,7,7,8,2,,0,8,2,1,1,int
3417,211512,_addReplyToBuffer,1,_addReplyToBuffer,"size_t _addReplyToBuffer (client*,char*,size_t)",networking.c,"size_t _addReplyToBuffer(client *c, const char *s, size_t len) {
    size_t available = c->buf_usable_size - c->bufpos;

    /* If there already are entries in the reply list, we cannot
     * add anything more to the static buffer. */
    if (listLength(c->reply) > 0) return 0;

    size_t reply_len = len > available ? available : len;
    memcpy(c->buf+c->bufpos,s,reply_len);
    c->bufpos+=reply_len;
    /* We update the buffer peak after appending the reply to the buffer */
    if(c->buf_peak < (size_t)c->bufpos)
        c->buf_peak = (size_t)c->bufpos;
    return reply_len;
}",330.0,344.0,1.0,8.0,15.0,24,9,21,5,1,11,3,3,4,0,,0,11,6,3,3,size_t
3418,211591,_addReplyProtoToList,1,_addReplyProtoToList,"void _addReplyProtoToList (client*,list*,char*,size_t)",networking.c,"void _addReplyProtoToList(client *c, list *reply_list, const char *s, size_t len) {
    listNode *ln = listLast(reply_list);
    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;

    /* Note that 'tail' may be NULL even if we have a tail node, because when
     * addReplyDeferredLen() is used, it sets a dummy node to NULL just
     * to fill it later, when the size of the bulk length is set. */

    /* Append to tail string when possible. */
    if (tail) {
        /* Copy the part we can fit into the tail, and leave the rest for a
         * new node */
        size_t avail = tail->size - tail->used;
        size_t copy = avail >= len? len: avail;
        memcpy(tail->buf + tail->used, s, copy);
        tail->used += copy;
        s += copy;
        len -= copy;
    }
    if (len) {
        /* Create a new node, make sure it is allocated to at
         * least PROTO_REPLY_CHUNK_BYTES */
        size_t usable_size;
        size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPL...",348.0,382.0,1.0,19.0,35.0,38,12,48,12,2,15,3,3,0,3,,0,13,8,4,4,void
3419,211725,cmdHasPushAsReply,1,cmdHasPushAsReply,int cmdHasPushAsReply (redisCommand*),networking.c,"int cmdHasPushAsReply(struct redisCommand *cmd) {
    if (!cmd) return 0;
    return cmd->proc == subscribeCommand  || cmd->proc == unsubscribeCommand ||
           cmd->proc == psubscribeCommand || cmd->proc == punsubscribeCommand ||
           cmd->proc == ssubscribeCommand || cmd->proc == sunsubscribeCommand;
}",387.0,392.0,1.0,1.0,6.0,18,4,13,7,1,6,2,2,0,0,,0,6,2,1,1,int
3420,211772,_addReplyToBufferOrList,1,_addReplyToBufferOrList,"void _addReplyToBufferOrList (client*,char*,size_t)",networking.c,"void _addReplyToBufferOrList(client *c, const char *s, size_t len) {
    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;

    /* Replicas should normally not cause any writes to the reply buffer. In case a rogue replica sent a command on the
     * replication link that caused a reply to be generated we'll simply disconnect it.
     * Note this is the simplest way to check a command added a response. Replication links are used to write data but
     * not for responses, so we should normally never get here on a replica client. */
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        sds cmdname = c->lastcmd ? c->lastcmd->fullname : NULL;
        logInvalidUseAndFreeClientAsync(c, ""Replica generated a reply to command '%s'"",
                                        cmdname ? cmdname : ""<unknown>"");
        return;
    }

    /* We call it here because this function may affect the reply
     * buffer offset (see function comment) */
    reqresSaveClientReplyOffset(c);

    /* If we...",394.0,426.0,1.0,19.0,33.0,28,12,31,7,3,12,5,5,4,7,,0,8,6,3,3,void
3421,211882,addReply,1,addReply,"void addReply (client*,robj*)",networking.c,"void addReply(client *c, robj *obj) {
    if (prepareClientToWrite(c) != C_OK) return;

    if (sdsEncodedObject(obj)) {
        _addReplyToBufferOrList(c,obj->ptr,sdslen(obj->ptr));
    } else if (obj->encoding == OBJ_ENCODING_INT) {
        /* For integer encoded strings we just convert it into a string
         * using our optimized function, and attach the resulting string
         * to the output buffer. */
        char buf[32];
        size_t len = ll2string(buf,sizeof(buf),(long)obj->ptr);
        _addReplyToBufferOrList(c,buf,len);
    } else {
        serverPanic(""Wrong obj->encoding in addReply()"");
    }
}",434.0,449.0,1.0,35.0,16.0,8,4,7,2,87,3,3,3,1,3,,0,2,4,2,2,void
3422,211960,addReplySds,1,addReplySds,"void addReplySds (client*,sds)",networking.c,"void addReplySds(client *c, sds s) {
    if (prepareClientToWrite(c) != C_OK) {
        /* The caller expects the sds to be free'd. */
        sdsfree(s);
        return;
    }
    _addReplyToBufferOrList(c,s,sdslen(s));
    sdsfree(s);
}",453.0,461.0,1.0,35.0,9.0,1,1,6,2,2,5,2,2,1,5,,0,2,4,2,2,void
3423,211984,addReplyProto,1,addReplyProto,"void addReplyProto (client*,char*,size_t)",networking.c,"void addReplyProto(client *c, const char *s, size_t len) {
    if (prepareClientToWrite(c) != C_OK) return;
    _addReplyToBufferOrList(c,s,len);
}",471.0,474.0,1.0,35.0,4.0,1,1,4,3,21,2,2,2,1,2,,0,1,6,3,3,void
3424,212004,addReplyErrorLength,1,addReplyErrorLength,"void addReplyErrorLength (client*,char*,size_t)",networking.c,"void addReplyErrorLength(client *c, const char *s, size_t len) {
    /* If the string already starts with ""-..."" then the error code
     * is provided by the caller. Otherwise we use ""-ERR"". */
    if (!len || s[0] != '-') addReplyProto(c,""-ERR "",5);
    addReplyProto(c,s,len);
    addReplyProto(c,""\r\n"",2);
}",485.0,491.0,1.0,1.0,7.0,4,4,7,3,3,3,2,2,0,3,,0,0,6,3,3,void
3425,212033,afterErrorReply,1,afterErrorReply,"void afterErrorReply (client*,char*,size_t,int)",networking.c,"void afterErrorReply(client *c, const char *s, size_t len, int flags) {
    /* Module clients fall into two categories:
     * Calls to RM_Call, in which case the error isn't being returned to a client, so should not be counted.
     * Module thread safe context calls to RM_ReplyWithError, which will be added to a real client by the main thread later. */
    if (c->flags & CLIENT_MODULE) {
        if (!c->deferred_reply_errors) {
            c->deferred_reply_errors = listCreate();
            listSetFreeMethod(c->deferred_reply_errors, (void (*)(void*))sdsfree);
        }
        listAddNodeTail(c->deferred_reply_errors, sdsnewlen(s, len));
        return;
    }

    if (!(flags & ERR_REPLY_FLAG_NO_STATS_UPDATE)) {
        /* Increment the global error counter */
        server.stat_total_error_replies++;
        /* Increment the error stats
         * If the string already starts with ""-..."" then the error prefix
         * is provided by the caller ( we limit the search to 32 cha...",496.0,587.0,1.0,19.0,92.0,71,17,57,16,6,19,10,16,4,8,,0,14,8,4,4,void
3426,212351,addReplyErrorObject,1,addReplyErrorObject,"void addReplyErrorObject (client*,robj*)",networking.c,"void addReplyErrorObject(client *c, robj *err) {
    addReply(c, err);
    afterErrorReply(c, err->ptr, sdslen(err->ptr)-2, 0); /* Ignore trailing \r\n */
}",591.0,594.0,1.0,1.0,4.0,3,2,5,2,26,3,1,1,0,3,,0,1,4,2,2,void
3427,212372,addReplyOrErrorObject,1,addReplyOrErrorObject,"void addReplyOrErrorObject (client*,robj*)",networking.c,"void addReplyOrErrorObject(client *c, robj *reply) {
    serverAssert(sdsEncodedObject(reply));
    sds rep = reply->ptr;
    if (sdslen(rep) > 1 && rep[0] == '-') {
        addReplyErrorObject(c, reply);
    } else {
        addReply(c, reply);
    }
}",601.0,609.0,1.0,4.0,9.0,15,11,8,3,3,3,2,2,1,3,,0,1,4,2,2,void
3428,212428,addReplyError,1,addReplyError,"void addReplyError (client*,char*)",networking.c,"void addReplyError(client *c, const char *err) {
    addReplyErrorLength(c,err,strlen(err));
    afterErrorReply(c,err,strlen(err),0);
}",612.0,615.0,1.0,1.0,4.0,0,0,6,2,129,2,1,1,0,2,,0,0,4,2,2,void
3429,212445,addReplyErrorSdsEx,1,addReplyErrorSdsEx,"void addReplyErrorSdsEx (client*,sds,int)",networking.c,"void addReplyErrorSdsEx(client *c, sds err, int flags) {
    addReplyErrorLength(c,err,sdslen(err));
    afterErrorReply(c,err,sdslen(err),flags);
    sdsfree(err);
}",620.0,624.0,1.0,1.0,5.0,0,0,8,3,2,5,1,1,0,5,,0,2,6,3,3,void
3430,212465,addReplyErrorSds,1,addReplyErrorSds,"void addReplyErrorSds (client*,sds)",networking.c,"void addReplyErrorSds(client *c, sds err) {
    addReplyErrorSdsEx(c, err, 0);
}",628.0,630.0,1.0,1.0,3.0,0,0,2,2,5,1,1,1,0,1,,0,0,4,2,2,void
3431,212475,addReplyErrorSdsSafe,1,addReplyErrorSdsSafe,"void addReplyErrorSdsSafe (client*,sds)",networking.c,"void addReplyErrorSdsSafe(client *c, sds err) {
    err = sdsmapchars(err, ""\r\n"", ""  "",  2);
    addReplyErrorSdsEx(c, err, 0);
}",634.0,637.0,1.0,1.0,4.0,1,1,4,2,0,2,1,1,0,2,,0,1,4,2,2,void
3432,212492,addReplyErrorFormatInternal,1,addReplyErrorFormatInternal,"void addReplyErrorFormatInternal (client*,int,char*,va_list)",networking.c,"void addReplyErrorFormatInternal(client *c, int flags, const char *fmt, va_list ap) {
    va_list cpy;
    va_copy(cpy,ap);
    sds s = sdscatvprintf(sdsempty(),fmt,cpy);
    va_end(cpy);
    /* Trim any newlines at the end (ones will be added by addReplyErrorLength) */
    s = sdstrim(s, ""\r\n"");
    /* Make sure there are no newlines in the middle of the string, otherwise
     * invalid protocol is emitted. */
    s = sdsmapchars(s, ""\r\n"", ""  "",  2);
    addReplyErrorLength(c,s,sdslen(s));
    afterErrorReply(c,s,sdslen(s),flags);
    sdsfree(s);
}",641.0,654.0,1.0,1.0,14.0,3,1,18,6,3,9,1,1,0,9,,0,6,8,4,4,void
3433,212538,addReplyErrorFormatEx,1,addReplyErrorFormatEx,"void addReplyErrorFormatEx (client*,int,char*...)",networking.c,"void addReplyErrorFormatEx(client *c, int flags, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    addReplyErrorFormatInternal(c, flags, fmt, ap);
    va_end(ap);
}",656.0,661.0,1.0,1.0,6.0,0,0,7,4,0,1,1,1,0,1,,0,0,6,3,3,void
3434,212556,addReplyErrorFormat,1,addReplyErrorFormat,"void addReplyErrorFormat (client*,char*...)",networking.c,"void addReplyErrorFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    addReplyErrorFormatInternal(c, 0, fmt, ap);
    va_end(ap);
}",665.0,670.0,1.0,1.0,6.0,0,0,6,3,29,1,1,1,0,1,,0,0,4,2,2,void
3435,212573,addReplyErrorArity,1,addReplyErrorArity,void addReplyErrorArity (client*),networking.c,"void addReplyErrorArity(client *c) {
    addReplyErrorFormat(c, ""wrong number of arguments for '%s' command"",
                        c->cmd->fullname);
}",672.0,675.0,1.0,1.0,4.0,2,1,2,1,5,2,1,1,0,1,,0,1,2,1,1,void
3436,212586,addReplyErrorExpireTime,1,addReplyErrorExpireTime,void addReplyErrorExpireTime (client*),networking.c,"void addReplyErrorExpireTime(client *c) {
    addReplyErrorFormat(c, ""invalid expire time in '%s' command"",
                        c->cmd->fullname);
}",677.0,680.0,1.0,1.0,4.0,2,1,2,1,2,2,1,1,0,1,,0,1,2,1,1,void
3437,212599,addReplyStatusLength,1,addReplyStatusLength,"void addReplyStatusLength (client*,char*,size_t)",networking.c,"void addReplyStatusLength(client *c, const char *s, size_t len) {
    addReplyProto(c,""+"",1);
    addReplyProto(c,s,len);
    addReplyProto(c,""\r\n"",2);
}",682.0,686.0,1.0,1.0,5.0,0,0,5,3,2,3,1,1,0,3,,0,0,6,3,3,void
3438,212618,addReplyStatus,1,addReplyStatus,"void addReplyStatus (client*,char*)",networking.c,"void addReplyStatus(client *c, const char *status) {
    addReplyStatusLength(c,status,strlen(status));
}",688.0,690.0,1.0,1.0,3.0,0,0,3,2,6,1,1,1,0,1,,0,0,4,2,2,void
3439,212629,addReplyStatusFormat,1,addReplyStatusFormat,"void addReplyStatusFormat (client*,char*...)",networking.c,"void addReplyStatusFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    sds s = sdscatvprintf(sdsempty(),fmt,ap);
    va_end(ap);
    addReplyStatusLength(c,s,sdslen(s));
    sdsfree(s);
}",692.0,699.0,1.0,1.0,8.0,1,1,10,4,2,5,1,1,0,5,,0,3,4,2,2,void
3440,212655,trimReplyUnusedTailSpace,1,trimReplyUnusedTailSpace,void trimReplyUnusedTailSpace (client*),networking.c,"void trimReplyUnusedTailSpace(client *c) {
    listNode *ln = listLast(c->reply);
    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;

    /* Note that 'tail' may be NULL even if we have a tail node, because when
     * addReplyDeferredLen() is used */
    if (!tail) return;

    /* We only try to trim the space is relatively high (more than a 1/4 of the
     * allocation), otherwise there's a high chance realloc will NOP.
     * Also, to avoid large memmove which happens as part of realloc, we only do
     * that if the used part is small.  */
    if (tail->size - tail->used > tail->size / 4 &&
        tail->used < PROTO_REPLY_CHUNK_BYTES)
    {
        size_t usable_size;
        size_t old_size = tail->size;
        tail = zrealloc_usable(tail, tail->used + sizeof(clientReplyBlock), &usable_size);
        /* take over the allocation's internal fragmentation (at least for
         * memory usage tracking) */
        tail->size = usable_size - sizeof(clientReplyBlock);
      ...",704.0,728.0,1.0,19.0,25.0,37,13,30,7,1,15,3,3,4,1,,0,15,2,1,1,void
3441,212763,addReplyDeferredLen,1,addReplyDeferredLen,void* addReplyDeferredLen (client*),networking.c,"void *addReplyDeferredLen(client *c) {
    /* Note that we install the write event here even if the object is not
     * ready to be sent, since we are sure that before returning to the
     * event loop setDeferredAggregateLen() will be called. */
    if (prepareClientToWrite(c) != C_OK) return NULL;

    /* Replicas should normally not cause any writes to the reply buffer. In case a rogue replica sent a command on the
     * replication link that caused a reply to be generated we'll simply disconnect it.
     * Note this is the simplest way to check a command added a response. Replication links are used to write data but
     * not for responses, so we should normally never get here on a replica client. */
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        sds cmdname = c->lastcmd ? c->lastcmd->fullname : NULL;
        logInvalidUseAndFreeClientAsync(c, ""Replica generated a reply to command '%s'"",
                                        cmdname ? cmdname : ""<unknown>"");
    ...",732.0,756.0,1.0,35.0,25.0,12,5,17,3,17,11,3,3,2,6,,0,7,2,1,1,void*
3442,212828,setDeferredReply,1,setDeferredReply,"void setDeferredReply (client*,void*,char*,size_t)",networking.c,"void setDeferredReply(client *c, void *node, const char *s, size_t length) {
    listNode *ln = (listNode*)node;
    clientReplyBlock *next, *prev;

    /* Abort when *node is NULL: when the client should not accept writes
     * we return NULL in addReplyDeferredLen() */
    if (node == NULL) return;
    serverAssert(!listNodeValue(ln));

    /* Normally we fill this dummy NULL node, added by addReplyDeferredLen(),
     * with a new buffer structure containing the protocol needed to specify
     * the length of the array following. However sometimes there might be room
     * in the previous/next node so we can instead remove this NULL node, and
     * suffix/prefix our data in the node immediately before/after it, in order
     * to save a write(2) syscall later. Conditions needed to do it:
     *
     * - The prev node is non-NULL and has space in it or
     * - The next node is non-NULL,
     * - It has enough room already allocated
     * - And not too large (avoid large memmov...",758.0,815.0,1.0,4.0,58.0,61,18,52,9,5,27,6,8,11,3,,0,24,8,4,4,void
3443,213067,setDeferredAggregateLen,1,setDeferredAggregateLen,"void setDeferredAggregateLen (client*,void*,long,char)",networking.c,"void setDeferredAggregateLen(client *c, void *node, long length, char prefix) {
    serverAssert(length >= 0);

    /* Abort when *node is NULL: when the client should not accept writes
     * we return NULL in addReplyDeferredLen() */
    if (node == NULL) return;

    /* Things like *2\r\n, %3\r\n or ~4\r\n are emitted very often by the protocol
     * so we have a few shared objects to use if the integer is small
     * like it is most of the times. */
    const size_t hdr_len = OBJ_SHARED_HDR_STRLEN(length);
    const int opt_hdr = length < OBJ_SHARED_BULKHDR_LEN;
    if (prefix == '*' && opt_hdr) {
        setDeferredReply(c, node, shared.mbulkhdr[length]->ptr, hdr_len);
        return;
    }
    if (prefix == '%' && opt_hdr) {
        setDeferredReply(c, node, shared.maphdr[length]->ptr, hdr_len);
        return;
    }
    if (prefix == '~' && opt_hdr) {
        setDeferredReply(c, node, shared.sethdr[length]->ptr, hdr_len);
        return;
    }

    char lenstr[128];
    siz...",818.0,846.0,1.0,4.0,29.0,28,13,38,10,5,5,5,5,0,5,,0,0,8,4,4,void
3444,213190,setDeferredArrayLen,1,setDeferredArrayLen,"void setDeferredArrayLen (client*,void*,long)",networking.c,"void setDeferredArrayLen(client *c, void *node, long length) {
    setDeferredAggregateLen(c,node,length,'*');
}",848.0,850.0,1.0,1.0,3.0,0,0,3,3,11,1,1,1,0,1,,0,0,6,3,3,void
3445,213202,setDeferredMapLen,1,setDeferredMapLen,"void setDeferredMapLen (client*,void*,long)",networking.c,"void setDeferredMapLen(client *c, void *node, long length) {
    int prefix = c->resp == 2 ? '*' : '%';
    if (c->resp == 2) length *= 2;
    setDeferredAggregateLen(c,node,length,prefix);
}",852.0,856.0,1.0,1.0,5.0,7,5,8,4,6,3,2,2,1,1,,0,2,6,3,3,void
3446,213235,setDeferredSetLen,1,setDeferredSetLen,"void setDeferredSetLen (client*,void*,long)",networking.c,"void setDeferredSetLen(client *c, void *node, long length) {
    int prefix = c->resp == 2 ? '*' : '~';
    setDeferredAggregateLen(c,node,length,prefix);
}",858.0,861.0,1.0,1.0,4.0,4,4,6,4,2,2,1,1,0,1,,0,1,6,3,3,void
3447,213258,setDeferredAttributeLen,1,setDeferredAttributeLen,"void setDeferredAttributeLen (client*,void*,long)",networking.c,"void setDeferredAttributeLen(client *c, void *node, long length) {
    serverAssert(c->resp >= 3);
    setDeferredAggregateLen(c,node,length,'|');
}",863.0,866.0,1.0,4.0,4.0,6,6,4,3,1,3,1,1,0,2,,0,1,6,3,3,void
3448,213288,setDeferredPushLen,1,setDeferredPushLen,"void setDeferredPushLen (client*,void*,long)",networking.c,"void setDeferredPushLen(client *c, void *node, long length) {
    serverAssert(c->resp >= 3);
    setDeferredAggregateLen(c,node,length,'>');
}",868.0,871.0,1.0,4.0,4.0,6,6,4,3,0,3,1,1,0,2,,0,1,6,3,3,void
3449,213318,addReplyDouble,1,addReplyDouble,"void addReplyDouble (client*,double)",networking.c,"void addReplyDouble(client *c, double d) {
    if (c->resp == 3) {
        char dbuf[MAX_D2STRING_CHARS+3];
        dbuf[0] = ',';
        const int dlen = d2string(dbuf+1,sizeof(dbuf)-1,d);
        dbuf[dlen+1] = '\r';
        dbuf[dlen+2] = '\n';
        dbuf[dlen+3] = '\0';
        addReplyProto(c,dbuf,dlen+3);
    } else {
        char dbuf[MAX_LONG_DOUBLE_CHARS+32];
        /* In order to prepend the string length before the formatted number,
         * but still avoid an extra memcpy of the whole number, we reserve space
         * for maximum header `$0000\r\n`, print double, add the resp header in
         * front of it, and then send the buffer with the right `start` offset. */
        const int dlen = d2string(dbuf+7,sizeof(dbuf)-7,d);
        int digits = digits10(dlen);
        int start = 4 - digits;
        serverAssert(start >= 0);
        dbuf[start] = '$';

        /* Convert `dlen` to string, putting it's digits after '$' and before the
            * formatted doub...",874.0,907.0,1.0,18.0,34.0,18,7,15,4,9,3,2,2,1,2,,0,2,4,2,2,void
3450,213497,addReplyBigNum,1,addReplyBigNum,"void addReplyBigNum (client*,char*,size_t)",networking.c,"void addReplyBigNum(client *c, const char* num, size_t len) {
    if (c->resp == 2) {
        addReplyBulkCBuffer(c, num, len);
    } else {
        addReplyProto(c,""("",1);
        addReplyProto(c,num,len);
        addReplyProto(c,""\r\n"",2);
    }
}",909.0,917.0,1.0,1.0,9.0,2,2,4,3,1,2,2,2,1,1,,0,1,6,3,3,void
3451,213529,addReplyHumanLongDouble,1,addReplyHumanLongDouble,"void addReplyHumanLongDouble (client*,long double)",networking.c,"void addReplyHumanLongDouble(client *c, long double d) {
    if (c->resp == 2) {
        robj *o = createStringObjectFromLongDouble(d,1);
        addReplyBulk(c,o);
        decrRefCount(o);
    } else {
        char buf[MAX_LONG_DOUBLE_CHARS];
        int len = ld2string(buf,sizeof(buf),d,LD_STR_HUMAN);
        addReplyProto(c,"","",1);
        addReplyProto(c,buf,len);
        addReplyProto(c,""\r\n"",2);
    }
}",922.0,934.0,1.0,17.0,13.0,3,3,6,3,3,4,2,2,1,3,,0,2,4,2,2,void
3452,213577,addReplyLongLongWithPrefix,1,addReplyLongLongWithPrefix,"void addReplyLongLongWithPrefix (client*,long long,char)",networking.c,"void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {
    char buf[128];
    int len;

    /* Things like $3\r\n or *2\r\n are emitted very often by the protocol
     * so we have a few shared objects to use if the integer is small
     * like it is most of the times. */
    const int opt_hdr = ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0;
    const size_t hdr_len = OBJ_SHARED_HDR_STRLEN(ll);
    if (prefix == '*' && opt_hdr) {
        addReplyProto(c,shared.mbulkhdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '$' && opt_hdr) {
        addReplyProto(c,shared.bulkhdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '%' && opt_hdr) {
        addReplyProto(c,shared.maphdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '~' && opt_hdr) {
        addReplyProto(c,shared.sethdr[ll]->ptr,hdr_len);
        return;
    }

    buf[0] = prefix;
    len = ll2string(buf+1,sizeof(buf)-1,ll);
    buf[len+1] = '\r';
    buf[len+2] = '\n';
    addRep...",938.0,966.0,1.0,29.0,29.0,25,12,25,8,4,3,2,2,0,3,,0,1,6,3,3,void
3453,213724,addReplyLongLong,1,addReplyLongLong,"void addReplyLongLong (client*,long long)",networking.c,"void addReplyLongLong(client *c, long long ll) {
    if (ll == 0)
        addReply(c,shared.czero);
    else if (ll == 1)
        addReply(c,shared.cone);
    else
        addReplyLongLongWithPrefix(c,ll,':');
}",968.0,975.0,1.0,1.0,8.0,2,2,3,3,74,1,2,2,0,1,,0,0,4,2,2,void
3454,213758,addReplyAggregateLen,1,addReplyAggregateLen,"void addReplyAggregateLen (client*,long,int)",networking.c,"void addReplyAggregateLen(client *c, long length, int prefix) {
    serverAssert(length >= 0);
    addReplyLongLongWithPrefix(c,length,prefix);
}",977.0,980.0,1.0,4.0,4.0,5,5,4,3,5,2,1,1,0,2,,0,0,6,3,3,void
3455,213785,addReplyArrayLen,1,addReplyArrayLen,"void addReplyArrayLen (client*,long)",networking.c,"void addReplyArrayLen(client *c, long length) {
    addReplyAggregateLen(c,length,'*');
}",982.0,984.0,1.0,1.0,3.0,0,0,2,2,60,1,1,1,0,1,,0,0,4,2,2,void
3456,213795,addReplyMapLen,1,addReplyMapLen,"void addReplyMapLen (client*,long)",networking.c,"void addReplyMapLen(client *c, long length) {
    int prefix = c->resp == 2 ? '*' : '%';
    if (c->resp == 2) length *= 2;
    addReplyAggregateLen(c,length,prefix);
}",986.0,990.0,1.0,1.0,5.0,7,5,7,3,32,3,2,2,1,1,,0,2,4,2,2,void
3457,213826,addReplySetLen,1,addReplySetLen,"void addReplySetLen (client*,long)",networking.c,"void addReplySetLen(client *c, long length) {
    int prefix = c->resp == 2 ? '*' : '~';
    addReplyAggregateLen(c,length,prefix);
}",992.0,995.0,1.0,1.0,4.0,4,4,5,3,7,2,1,1,0,1,,0,1,4,2,2,void
3458,213847,addReplyAttributeLen,1,addReplyAttributeLen,"void addReplyAttributeLen (client*,long)",networking.c,"void addReplyAttributeLen(client *c, long length) {
    serverAssert(c->resp >= 3);
    addReplyAggregateLen(c,length,'|');
}",997.0,1000.0,1.0,4.0,4.0,6,6,3,2,0,3,1,1,0,2,,0,1,4,2,2,void
3459,213875,addReplyPushLen,1,addReplyPushLen,"void addReplyPushLen (client*,long)",networking.c,"void addReplyPushLen(client *c, long length) {
    serverAssert(c->resp >= 3);
    serverAssertWithInfo(c, NULL, c->flags & CLIENT_PUSHING);
    addReplyAggregateLen(c,length,'>');
}",1002.0,1006.0,1.0,4.0,5.0,13,8,8,3,2,5,1,1,0,3,,0,2,4,2,2,void
3460,213927,addReplyNull,1,addReplyNull,void addReplyNull (client*),networking.c,"void addReplyNull(client *c) {
    if (c->resp == 2) {
        addReplyProto(c,""$-1\r\n"",5);
    } else {
        addReplyProto(c,""_\r\n"",3);
    }
}",1008.0,1014.0,1.0,1.0,7.0,2,2,2,1,15,2,2,2,1,1,,0,1,2,1,1,void
3461,213949,addReplyBool,1,addReplyBool,"void addReplyBool (client*,int)",networking.c,"void addReplyBool(client *c, int b) {
    if (c->resp == 2) {
        addReply(c, b ? shared.cone : shared.czero);
    } else {
        addReplyProto(c, b ? ""#t\r\n"" : ""#f\r\n"",4);
    }
}",1016.0,1022.0,1.0,1.0,7.0,5,4,5,3,1,2,2,2,1,1,,0,1,4,2,2,void
3462,213981,addReplyNullArray,1,addReplyNullArray,void addReplyNullArray (client*),networking.c,"void addReplyNullArray(client *c) {
    if (c->resp == 2) {
        addReplyProto(c,""*-1\r\n"",5);
    } else {
        addReplyProto(c,""_\r\n"",3);
    }
}",1028.0,1034.0,1.0,1.0,7.0,2,2,2,1,7,2,2,2,1,1,,0,1,2,1,1,void
3463,214003,addReplyBulkLen,1,addReplyBulkLen,"void addReplyBulkLen (client*,robj*)",networking.c,"void addReplyBulkLen(client *c, robj *obj) {
    size_t len = stringObjectLen(obj);

    addReplyLongLongWithPrefix(c,len,'$');
}",1037.0,1041.0,1.0,1.0,5.0,1,1,4,3,1,2,1,1,0,2,,0,1,4,2,2,void
3464,214018,addReplyBulk,1,addReplyBulk,"void addReplyBulk (client*,robj*)",networking.c,"void addReplyBulk(client *c, robj *obj) {
    addReplyBulkLen(c,obj);
    addReply(c,obj);
    addReplyProto(c,""\r\n"",2);
}",1044.0,1048.0,1.0,1.0,5.0,0,0,5,2,18,3,1,1,0,3,,0,0,4,2,2,void
3465,214034,addReplyBulkCBuffer,1,addReplyBulkCBuffer,"void addReplyBulkCBuffer (client*,void*,size_t)",networking.c,"void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
    addReplyLongLongWithPrefix(c,len,'$');
    addReplyProto(c,p,len);
    addReplyProto(c,""\r\n"",2);
}",1051.0,1055.0,1.0,1.0,5.0,0,0,6,3,49,3,1,1,0,3,,0,0,6,3,3,void
3466,214053,addReplyBulkSds,1,addReplyBulkSds,"void addReplyBulkSds (client*,sds)",networking.c,"void addReplyBulkSds(client *c, sds s)  {
    addReplyLongLongWithPrefix(c,sdslen(s),'$');
    addReplySds(c,s);
    addReplyProto(c,""\r\n"",2);
}",1058.0,1062.0,1.0,1.0,5.0,0,0,5,2,12,4,1,1,0,4,,0,1,4,2,2,void
3467,214071,setDeferredReplyBulkSds,1,setDeferredReplyBulkSds,"void setDeferredReplyBulkSds (client*,void*,sds)",networking.c,"void setDeferredReplyBulkSds(client *c, void *node, sds s) {
    sds reply = sdscatprintf(sdsempty(), ""$%d\r\n%s\r\n"", (unsigned)sdslen(s), s);
    setDeferredReply(c, node, reply, sdslen(reply));
    sdsfree(reply);
    sdsfree(s);
}",1065.0,1070.0,1.0,1.0,6.0,2,2,9,4,1,7,1,1,0,7,,0,4,6,3,3,void
3468,214099,addReplyBulkCString,1,addReplyBulkCString,"void addReplyBulkCString (client*,char*)",networking.c,"void addReplyBulkCString(client *c, const char *s) {
    if (s == NULL) {
        addReplyNull(c);
    } else {
        addReplyBulkCBuffer(c,s,strlen(s));
    }
}",1073.0,1079.0,1.0,1.0,7.0,1,1,3,3,211,1,2,2,0,1,,0,0,4,2,2,void
3469,214119,addReplyBulkLongLong,1,addReplyBulkLongLong,"void addReplyBulkLongLong (client*,long long)",networking.c,"void addReplyBulkLongLong(client *c, long long ll) {
    char buf[64];
    int len;

    len = ll2string(buf,64,ll);
    addReplyBulkCBuffer(c,buf,len);
}",1082.0,1088.0,1.0,1.0,7.0,1,1,6,4,49,2,1,1,0,2,,0,1,4,2,2,void
3470,214137,addReplyVerbatim,1,addReplyVerbatim,"void addReplyVerbatim (client*,char*,size_t,char*)",networking.c,"void addReplyVerbatim(client *c, const char *s, size_t len, const char *ext) {
    if (c->resp == 2) {
        addReplyBulkCBuffer(c,s,len);
    } else {
        char buf[32];
        size_t preflen = snprintf(buf,sizeof(buf),""=%zu\r\nxxx:"",len+4);
        char *p = buf+preflen-4;
        for (int i = 0; i < 3; i++) {
            if (*ext == '\0') {
                p[i] = ' ';
            } else {
                p[i] = *ext++;
            }
        }
        addReplyProto(c,buf,preflen);
        addReplyProto(c,s,len);
        addReplyProto(c,""\r\n"",2);
    }
}",1099.0,1117.0,1.0,1.0,19.0,2,2,4,3,3,2,2,2,1,1,,0,1,8,4,4,void
3471,214222,addReplyHelp,1,addReplyHelp,"void addReplyHelp (client*,char**)",networking.c,"void addReplyHelp(client *c, const char **help) {
    sds cmd = sdsnew((char*) c->argv[0]->ptr);
    void *blenp = addReplyDeferredLen(c);
    int blen = 0;

    sdstoupper(cmd);
    addReplyStatusFormat(c,
        ""%s <subcommand> [<arg> [value] [opt] ...]. Subcommands are:"",cmd);
    sdsfree(cmd);

    while (help[blen]) addReplyStatus(c,help[blen++]);

    addReplyStatus(c,""HELP"");
    addReplyStatus(c,""    Print this help."");

    blen += 1;  /* Account for the header. */
    blen += 2;  /* Account for the footer. */
    setDeferredArrayLen(c,blenp,blen);
}",1123.0,1141.0,1.0,1.0,19.0,10,5,18,5,12,9,2,2,0,8,,0,3,4,2,2,void
3472,214284,addReplySubcommandSyntaxError,1,addReplySubcommandSyntaxError,void addReplySubcommandSyntaxError (client*),networking.c,"void addReplySubcommandSyntaxError(client *c) {
    sds cmd = sdsnew((char*) c->argv[0]->ptr);
    sdstoupper(cmd);
    addReplyErrorFormat(c,
        ""unknown subcommand or wrong number of arguments for '%.128s'. Try %s HELP."",
        (char*)c->argv[1]->ptr,cmd);
    sdsfree(cmd);
}",1146.0,1153.0,1.0,1.0,8.0,9,4,7,2,2,6,1,1,0,4,,0,3,2,1,1,void
3473,214319,AddReplyFromClient,1,AddReplyFromClient,"void AddReplyFromClient (client*,client*)",networking.c,"void AddReplyFromClient(client *dst, client *src) {
    /* If the source client contains a partial response due to client output
     * buffer limits, propagate that to the dest rather than copy a partial
     * reply. We don't wanna run the risk of copying partial response in case
     * for some reason the output limits don't reach the same decision (maybe
     * they changed) */
    if (src->flags & CLIENT_CLOSE_ASAP) {
        sds client = catClientInfoString(sdsempty(),dst);
        freeClientAsync(dst);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
        return;
    }

    /* First add the static buffer (either into the static buffer or reply list) */
    addReplyProto(dst,src->buf, src->bufpos);

    /* We need to check with prepareClientToWrite again (after addReplyProto)
     * since addReplyProto may have changed something (like CLIENT_CLOSE_ASAP) */
    if (prepareClientToW...",1157.0,1198.0,1.0,21.0,42.0,30,8,27,5,1,27,6,6,6,11,,0,19,4,2,2,void
3474,214453,deferredAfterErrorReply,1,deferredAfterErrorReply,"void deferredAfterErrorReply (client*,list*)",networking.c,"void deferredAfterErrorReply(client *c, list *errors) {
    listIter li;
    listNode *ln;
    listRewind(errors,&li);
    while((ln = listNext(&li))) {
        sds err = ln->value;
        afterErrorReply(c, err, sdslen(err), 0);
    }
}",1202.0,1210.0,1.0,1.0,9.0,5,3,9,5,2,5,2,2,1,4,,0,3,4,2,2,void
3475,214484,copyReplicaOutputBuffer,1,copyReplicaOutputBuffer,"void copyReplicaOutputBuffer (client*,client*)",networking.c,"void copyReplicaOutputBuffer(client *dst, client *src) {
    serverAssert(src->bufpos == 0 && listLength(src->reply) == 0);

    if (src->ref_repl_buf_node == NULL) return;
    dst->ref_repl_buf_node = src->ref_repl_buf_node;
    dst->ref_block_pos = src->ref_block_pos;
    ((replBufBlock *)listNodeValue(dst->ref_repl_buf_node))->refcount++;
}",1214.0,1221.0,1.0,4.0,8.0,24,9,10,3,1,10,2,2,1,1,,0,9,4,2,2,void
3476,214553,clientHasPendingReplies,1,clientHasPendingReplies,int clientHasPendingReplies (client*),networking.c,"int clientHasPendingReplies(client *c) {
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        /* Replicas use global shared replication buffer instead of
         * private output buffer. */
        serverAssert(c->bufpos == 0 && listLength(c->reply) == 0);
        if (c->ref_repl_buf_node == NULL) return 0;

        /* If the last replication buffer block content is totally sent,
         * we have nothing to send. */
        listNode *ln = listLast(server.repl_buffer_blocks);
        replBufBlock *tail = listNodeValue(ln);
        if (ln == c->ref_repl_buf_node &&
            c->ref_block_pos == tail->used) return 0;

        return 1;
    } else {
        return c->bufpos || listLength(c->reply);
    }
}",1225.0,1243.0,1.0,28.0,19.0,25,9,15,5,11,9,4,6,5,2,,0,8,2,1,1,int
3477,214659,clientAcceptHandler,1,clientAcceptHandler,void clientAcceptHandler (connection*),networking.c,"void clientAcceptHandler(connection *conn) {
    client *c = connGetPrivateData(conn);

    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_WARNING,
                  ""Error accepting a client connection: %s (addr=%s laddr=%s)"",
                  connGetLastError(conn), getClientPeerId(c), getClientSockname(c));
        freeClientAsync(c);
        return;
    }

    /* If the server is running in protected mode (the default) and there
     * is no password set, nor a specific interface is bound, we don't accept
     * requests from non loopback interfaces. Instead we try to explain the
     * user what to do to fix it if needed. */
    if (server.protected_mode &&
        DefaultUser->flags & USER_FLAG_NOPASS)
    {
        if (connIsLocal(conn) != 1) {
            char *err =
                ""-DENIED Redis is running in protected mode because protected ""
                ""mode is enabled and no password is set for the default user. ""
                ""In this m...",1245.0,1297.0,1.0,8.0,53.0,19,11,20,6,0,12,5,8,4,11,,0,8,2,1,1,void
3478,214758,acceptCommonHandler,1,acceptCommonHandler,"void acceptCommonHandler (connection*,int,char*)",networking.c,"void acceptCommonHandler(connection *conn, int flags, char *ip) {
    client *c;
    UNUSED(ip);

    if (connGetState(conn) != CONN_STATE_ACCEPTING) {
        char addr[NET_ADDR_STR_LEN] = {0};
        char laddr[NET_ADDR_STR_LEN] = {0};
        connFormatAddr(conn, addr, sizeof(addr), 1);
        connFormatAddr(conn, laddr, sizeof(addr), 0);
        serverLog(LL_VERBOSE,
                  ""Accepted client connection in error state: %s (addr=%s laddr=%s)"",
                  connGetLastError(conn), addr, laddr);
        connClose(conn);
        return;
    }

    /* Limit the number of connections we take at the same time.
     *
     * Admission control will happen before a client is created and connAccept()
     * called, because we don't want to even start transport-level negotiation
     * if rejected. */
    if (listLength(server.clients) + getClusterConnectionsCount()
        >= server.maxclients)
    {
        char *err;
        if (server.cluster_enabled)
            err = ""...",1299.0,1373.0,1.0,4.0,75.0,41,14,53,11,2,24,8,11,6,23,,0,13,6,3,3,void
3479,214978,freeClientOriginalArgv,1,freeClientOriginalArgv,void freeClientOriginalArgv (client*),networking.c,"void freeClientOriginalArgv(client *c) {
    /* We didn't rewrite this client */
    if (!c->original_argv) return;

    for (int j = 0; j < c->original_argc; j++)
        decrRefCount(c->original_argv[j]);
    zfree(c->original_argv);
    c->original_argv = NULL;
    c->original_argc = 0;
}",1375.0,1384.0,1.0,1.0,10.0,10,4,8,3,2,6,3,3,2,1,,0,5,2,1,1,void
3480,215076,disconnectSlaves,1,disconnectSlaves,void disconnectSlaves (void),networking.c,"void disconnectSlaves(void) {
    listIter li;
    listNode *ln;
    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        freeClient((client*)ln->value);
    }
}",1401.0,1408.0,1.0,1.0,8.0,6,5,5,3,4,4,2,2,1,3,,0,2,2,1,1,void
3481,215102,anyOtherSlaveWaitRdb,1,anyOtherSlaveWaitRdb,int anyOtherSlaveWaitRdb (client*),networking.c,"int anyOtherSlaveWaitRdb(client *except_me) {
    listIter li;
    listNode *ln;

    listRewind(server.slaves, &li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (slave != except_me &&
            slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END)
        {
            return 1;
        }
    }
    return 0;
}",1413.0,1427.0,1.0,32.0,15.0,10,7,9,5,1,4,3,4,2,2,,0,3,2,1,1,int
3482,215145,unlinkClient,1,unlinkClient,void unlinkClient (client*),networking.c,"void unlinkClient(client *c) {
    listNode *ln;

    /* If this is marked as current client unset it. */
    if (server.current_client == c) server.current_client = NULL;

    /* Certain operations must be done only if the client has an active connection.
     * If the client was already unlinked or if it's a ""fake client"" the
     * conn is already set to NULL. */
    if (c->conn) {
        /* Remove from the list of active clients. */
        if (c->client_list_node) {
            uint64_t id = htonu64(c->id);
            raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);
            listDelNode(server.clients,c->client_list_node);
            c->client_list_node = NULL;
        }

        /* Check if this is a replica waiting for diskless replication (rdb pipe),
         * in which case it needs to be cleaned from that list */
        if (c->flags & CLIENT_SLAVE &&
            c->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&
            server.rdb_pipe_conns)
   ...",1432.0,1498.0,1.0,26.0,67.0,91,18,61,7,3,38,13,20,9,14,,0,26,2,1,1,void
3483,215442,clearClientConnectionState,1,clearClientConnectionState,void clearClientConnectionState (client*),networking.c,"void clearClientConnectionState(client *c) {
    listNode *ln;

    /* MONITOR clients are also marked with CLIENT_SLAVE, we need to
     * distinguish between the two.
     */
    if (c->flags & CLIENT_MONITOR) {
        ln = listSearchKey(server.monitors,c);
        serverAssert(ln != NULL);
        listDelNode(server.monitors,ln);

        c->flags &= ~(CLIENT_MONITOR|CLIENT_SLAVE);
    }

    serverAssert(!(c->flags &(CLIENT_SLAVE|CLIENT_MASTER)));

    if (c->flags & CLIENT_TRACKING) disableTracking(c);
    selectDb(c,0);
#ifdef LOG_REQ_RES
    c->resp = server.client_default_resp;
#else
    c->resp = 2;
#endif

    clientSetDefaultAuth(c);
    moduleNotifyUserChanged(c);
    discardTransaction(c);

    pubsubUnsubscribeAllChannels(c,0);
    pubsubUnsubscribeShardAllChannels(c, 0);
    pubsubUnsubscribeAllPatterns(c,0);

    if (c->name) {
        decrRefCount(c->name);
        c->name = NULL;
    }

    /* Note: lib_name and lib_ver are not reset since they still
     * repres...",1501.0,1544.0,1.0,19.0,44.0,50,13,25,4,2,22,4,4,3,13,,0,10,2,1,1,void
3484,215624,freeClient,1,freeClient,void freeClient (client*),redis-benchmark.c,"static void freeClient(client c) {
    aeEventLoop *el = CLIENT_GET_EVENTLOOP(c);
    listNode *ln;
    aeDeleteFileEvent(el,c->context->fd,AE_WRITABLE);
    aeDeleteFileEvent(el,c->context->fd,AE_READABLE);
    if (c->thread_id >= 0) {
        int requests_finished = 0;
        atomicGet(config.requests_finished, requests_finished);
        if (requests_finished >= config.requests) {
            aeStop(el);
        }
    }
    redisFree(c->context);
    sdsfree(c->obuf);
    zfree(c->randptr);
    zfree(c->stagptr);
    zfree(c);
    if (config.num_threads) pthread_mutex_lock(&(config.liveclients_mutex));
    config.liveclients--;
    ln = listSearchKey(config.clients,c);
    assert(ln != NULL);
    listDelNode(config.clients,ln);
    if (config.num_threads) pthread_mutex_unlock(&(config.liveclients_mutex));
}",371.0,394.0,1.0,22.0,24.0,130,19,95,5,22,95,21,30,21,49,,0,52,2,1,1,void
3485,216142,freeClientAsync,1,freeClientAsync,void freeClientAsync (client*),networking.c,"void freeClientAsync(client *c) {
    /* We need to handle concurrent access to the server.clients_to_close list
     * only in the freeClientAsync() function, since it's the only function that
     * may access the list while Redis uses I/O threads. All the other accesses
     * are in the context of the main thread while the other threads are
     * idle. */
    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_SCRIPT) return;
    c->flags |= CLIENT_CLOSE_ASAP;
    if (server.io_threads_num == 1) {
        /* no need to bother with locking if there's just one thread (the main thread) */
        listAddNodeTail(server.clients_to_close,c);
        return;
    }
    static pthread_mutex_t async_free_queue_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&async_free_queue_mutex);
    listAddNodeTail(server.clients_to_close,c);
    pthread_mutex_unlock(&async_free_queue_mutex);
}",1707.0,1724.0,1.0,19.0,18.0,16,8,12,4,15,5,3,3,2,2,,0,3,2,1,1,void
3486,216206,logInvalidUseAndFreeClientAsync,1,logInvalidUseAndFreeClientAsync,"void logInvalidUseAndFreeClientAsync (client*,char*...)",networking.c,"void logInvalidUseAndFreeClientAsync(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    sds info = sdscatvprintf(sdsempty(), fmt, ap);
    va_end(ap);

    sds client = catClientInfoString(sdsempty(), c);
    serverLog(LL_WARNING, ""%s, disconnecting it: %s"", info, client);

    sdsfree(info);
    sdsfree(client);
    freeClientAsync(c);
}",1728.0,1740.0,1.0,4.0,13.0,5,4,14,6,2,8,1,1,0,8,,0,4,4,2,2,void
3487,216257,beforeNextClient,1,beforeNextClient,int beforeNextClient (client*),networking.c,"int beforeNextClient(client *c) {
    /* Notice, this code is also called from 'processUnblockedClients'.
     * But in case of a module blocked client (see RM_Call 'K' flag) we do not reach this code path.
     * So whenever we change the code here we need to consider if we need this change on module
     * blocked client as well */

    /* Skip the client processing if we're in an IO thread, in that case we'll perform
       this operation later (this function is called again) in the fan-in stage of the threading mechanism */
    if (io_threads_op != IO_THREADS_OP_IDLE)
        return C_OK;
    /* Handle async frees */
    /* Note: this doesn't make the server.clients_to_close list redundant because of
     * cases where we want an async free of a client other than myself. For example
     * in ACL modifications we disconnect clients authenticated to non-existent
     * users (see ACL LOAD). */
    if (c && (c->flags & CLIENT_CLOSE_ASAP)) {
        freeClient(c);
        return C_...",1748.0,1768.0,1.0,25.0,21.0,6,6,4,2,3,2,3,3,1,1,,0,1,2,1,1,int
3488,216297,freeClientsInAsyncFreeQueue,1,freeClientsInAsyncFreeQueue,int freeClientsInAsyncFreeQueue (void),networking.c,"int freeClientsInAsyncFreeQueue(void) {
    int freed = 0;
    listIter li;
    listNode *ln;

    listRewind(server.clients_to_close,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);

        if (c->flags & CLIENT_PROTECTED) continue;

        c->flags &= ~CLIENT_CLOSE_ASAP;
        freeClient(c);
        listDelNode(server.clients_to_close,ln);
        freed++;
    }
    return freed;
}",1772.0,1789.0,1.0,20.0,18.0,16,9,16,6,2,7,4,4,2,4,,0,4,2,1,1,int
3489,216365,lookupClientByID,1,lookupClientByID,client lookupClientByID (uint64_t),networking.c,"client *lookupClientByID(uint64_t id) {
    id = htonu64(id);
    client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
    return (c == raxNotFound) ? NULL : c;
}",1794.0,1798.0,1.0,9.0,5.0,8,7,11,5,7,2,1,1,0,2,,0,2,2,1,1,client
3490,216397,_writevToClient,1,_writevToClient,"int _writevToClient (client*,ssize_t*)",networking.c,"static int _writevToClient(client *c, ssize_t *nwritten) {
    int iovcnt = 0;
    int iovmax = min(IOV_MAX, c->conn->iovcnt);
    struct iovec iov[iovmax];
    size_t iov_bytes_len = 0;
    /* If the static reply buffer is not empty, 
     * add it to the iov array for writev() as well. */
    if (c->bufpos > 0) {
        iov[iovcnt].iov_base = c->buf + c->sentlen;
        iov[iovcnt].iov_len = c->bufpos - c->sentlen;
        iov_bytes_len += iov[iovcnt++].iov_len;
    }
    /* The first node of reply list might be incomplete from the last call,
     * thus it needs to be calibrated to get the actual data address and length. */
    size_t offset = c->bufpos > 0 ? 0 : c->sentlen;
    listIter iter;
    listNode *next;
    clientReplyBlock *o;
    listRewind(c->reply, &iter);
    while ((next = listNext(&iter)) && iovcnt < iovmax && iov_bytes_len < NET_MAX_WRITES_PER_EVENT) {
        o = listNodeValue(next);
        if (o->used == 0) { /* empty node, just release it and skip. */
    ...",1805.0,1871.0,1.0,17.0,67.0,113,20,93,13,1,43,12,13,6,7,,0,39,4,2,2,int
3491,216730,_writeToClient,1,_writeToClient,"int _writeToClient (client*,ssize_t*)",networking.c,"int _writeToClient(client *c, ssize_t *nwritten) {
    *nwritten = 0;
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        serverAssert(c->bufpos == 0 && listLength(c->reply) == 0);

        replBufBlock *o = listNodeValue(c->ref_repl_buf_node);
        serverAssert(o->used >= c->ref_block_pos);
        /* Send current block if it is not fully sent. */
        if (o->used > c->ref_block_pos) {
            *nwritten = connWrite(c->conn, o->buf+c->ref_block_pos,
                                  o->used-c->ref_block_pos);
            if (*nwritten <= 0) return C_ERR;
            c->ref_block_pos += *nwritten;
        }

        /* If we fully sent the object on head, go to the next one. */
        listNode *next = listNextNode(c->ref_repl_buf_node);
        if (next && c->ref_block_pos == o->used) {
            o->refcount--;
            ((replBufBlock *)(listNodeValue(next)))->refcount++;
            c->ref_repl_buf_node = next;
            c->ref_block_pos = 0;
            incre...",1878.0,1929.0,1.0,28.0,52.0,76,19,42,5,1,34,8,14,9,7,,0,30,4,2,2,int
3492,217044,writeToClient,1,writeToClient,"int writeToClient (client*,int)",networking.c,"int writeToClient(client *c, int handler_installed) {
    /* Update total number of writes on server */
    atomicIncr(server.stat_total_writes_processed, 1);

    ssize_t nwritten = 0, totwritten = 0;

    while(clientHasPendingReplies(c)) {
        int ret = _writeToClient(c, &nwritten);
        if (ret == C_ERR) break;
        totwritten += nwritten;
        /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT
         * bytes, in a single threaded server it's a good idea to serve
         * other clients as well, even if a very large request comes from
         * super fast link that is always able to accept data (in real world
         * scenario think about 'KEYS *' against the loopback interface).
         *
         * However if we are over the maxmemory limit we ignore that and
         * just deliver as much data as it is possible to deliver.
         *
         * Moreover, we also send as much as possible if the client is
         * a slave or a monitor (other...",1939.0,2011.0,1.0,19.0,73.0,54,20,37,9,6,21,15,19,9,13,,0,15,4,2,2,int
3493,217271,sendReplyToClient,1,sendReplyToClient,void sendReplyToClient (connection*),networking.c,"void sendReplyToClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    writeToClient(c,1);
}",2014.0,2017.0,1.0,1.0,4.0,1,1,3,2,0,2,1,1,0,2,,0,1,2,1,1,void
3494,217284,handleClientsWithPendingWrites,1,handleClientsWithPendingWrites,int handleClientsWithPendingWrites (void),networking.c,"int handleClientsWithPendingWrites(void) {
    listIter li;
    listNode *ln;
    int processed = listLength(server.clients_pending_write);

    listRewind(server.clients_pending_write,&li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        c->flags &= ~CLIENT_PENDING_WRITE;
        listUnlinkNode(server.clients_pending_write,ln);

        /* If a client is protected, don't do anything,
         * that may trigger write error or recreate handler. */
        if (c->flags & CLIENT_PROTECTED) continue;

        /* Don't write to clients that are going to be closed anyway. */
        if (c->flags & CLIENT_CLOSE_ASAP) continue;

        /* Try to write buffers to the client socket. */
        if (writeToClient(c,0) == C_ERR) continue;

        /* If after the synchronous writes above we still have data to
         * output to the client, we need to install the writable handler. */
        if (clientHasPendingReplies(c)) {
            installClientWriteHandl...",2023.0,2051.0,1.0,20.0,29.0,22,9,19,5,2,10,9,10,5,6,,0,7,2,1,1,int
3495,217384,resetClient,1,resetClient,void resetClient (client*),redis-benchmark.c,"static void resetClient(client c) {
    aeEventLoop *el = CLIENT_GET_EVENTLOOP(c);
    aeDeleteFileEvent(el,c->context->fd,AE_WRITABLE);
    aeDeleteFileEvent(el,c->context->fd,AE_READABLE);
    aeCreateFileEvent(el,c->context->fd,AE_WRITABLE,writeHandler,c);
    c->written = 0;
    c->pending = config.pipeline;
}",406.0,413.0,1.0,22.0,8.0,59,14,28,4,7,23,5,5,4,3,,0,20,2,1,1,void
3496,217565,protectClient,1,protectClient,void protectClient (client*),networking.c,"void protectClient(client *c) {
    c->flags |= CLIENT_PROTECTED;
    if (c->conn) {
        connSetReadHandler(c->conn,NULL);
        connSetWriteHandler(c->conn,NULL);
    }
}",2109.0,2115.0,1.0,16.0,7.0,5,2,6,2,2,6,2,2,1,2,,0,4,2,1,1,void
3497,217594,unprotectClient,1,unprotectClient,void unprotectClient (client*),networking.c,"void unprotectClient(client *c) {
    if (c->flags & CLIENT_PROTECTED) {
        c->flags &= ~CLIENT_PROTECTED;
        if (c->conn) {
            connSetReadHandler(c->conn,readQueryFromClient);
            if (clientHasPendingReplies(c)) putClientInPendingWriteQueue(c);
        }
    }
}",2118.0,2126.0,1.0,19.0,9.0,8,4,7,2,3,7,4,7,3,3,,0,5,2,1,1,void
3498,217636,processInlineBuffer,1,processInlineBuffer,int processInlineBuffer (client*),networking.c,"int processInlineBuffer(client *c) {
    char *newline;
    int argc, j, linefeed_chars = 1;
    sds *argv, aux;
    size_t querylen;

    /* Search for end of line */
    newline = strchr(c->querybuf+c->qb_pos,'\n');

    /* Nothing to do without a \r\n */
    if (newline == NULL) {
        if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
            addReplyError(c,""Protocol error: too big inline request"");
            setProtocolError(""too big inline request"",c);
        }
        return C_ERR;
    }

    /* Handle the \r\n case. */
    if (newline != c->querybuf+c->qb_pos && *(newline-1) == '\r')
        newline--, linefeed_chars++;

    /* Split the input buffer up to the \r\n */
    querylen = newline-(c->querybuf+c->qb_pos);
    aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);
    argv = sdssplitargs(aux,&argc);
    sdsfree(aux);
    if (argv == NULL) {
        addReplyError(c,""Protocol error: unbalanced quotes in request"");
        setProtocolError(""unbalanced qu...",2135.0,2207.0,1.0,44.0,73.0,80,22,67,11,1,41,10,12,8,17,,0,30,2,1,1,int
3499,218104,processMultibulkBuffer,1,processMultibulkBuffer,int processMultibulkBuffer (client*),networking.c,"int processMultibulkBuffer(client *c) {
    char *newline = NULL;
    int ok;
    long long ll;

    if (c->multibulklen == 0) {
        /* The client should have been reset */
        serverAssertWithInfo(c,NULL,c->argc == 0);

        /* Multi bulk length cannot be read without a \r\n */
        newline = strchr(c->querybuf+c->qb_pos,'\r');
        if (newline == NULL) {
            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
                addReplyError(c,""Protocol error: too big mbulk count string"");
                setProtocolError(""too big mbulk count string"",c);
            }
            return C_ERR;
        }

        /* Buffer should also contain \n */
        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
            return C_ERR;

        /* We know for sure there is a whole line since newline != NULL,
         * so go ahead and find out the multi bulk length. */
        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_po...",2253.0,2413.0,1.0,8.0,161.0,185,25,122,8,0,92,23,49,33,26,,0,77,2,1,1,int
3500,218931,commandProcessed,1,commandProcessed,void commandProcessed (client*),networking.c,"void commandProcessed(client *c) {
    /* If client is blocked(including paused), just return avoid reset and replicate.
     *
     * 1. Don't reset the client structure for blocked clients, so that the reply
     *    callback will still be able to access the client argv and argc fields.
     *    The client will be reset in unblockClient().
     * 2. Don't update replication offset or propagate commands to replicas,
     *    since we have not applied the command. */
    if (c->flags & CLIENT_BLOCKED) return;

    reqresAppendResponse(c);
    resetClient(c);

    long long prev_offset = c->reploff;
    if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
        /* Update the applied replication offset of our master. */
        c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;
    }

    /* If the client is a master we need to compute the difference
     * between the applied offset before and after processing the buffer,
     * to understand how much of th...",2420.0,2452.0,1.0,19.0,33.0,31,9,21,3,1,17,5,6,4,4,,0,14,2,1,1,void
3501,219032,processCommandAndResetClient,1,processCommandAndResetClient,int processCommandAndResetClient (client*),networking.c,"int processCommandAndResetClient(client *c) {
    int deadclient = 0;
    client *old_client = server.current_client;
    server.current_client = c;
    if (processCommand(c) == C_OK) {
        commandProcessed(c);
        /* Update the client's memory to include output buffer growth following the
         * processed command. */
        updateClientMemUsageAndBucket(c);
    }

    if (server.current_client == NULL) deadclient = 1;
    /*
     * Restore the old client, this is needed because when a script
     * times out, we will get into this code from processEventsWhileBlocked.
     * Which will cause to set the server.current_client. If not restored
     * we will return 1 to our caller which will falsely indicate the client
     * is dead and will stop reading from its buffer.
     */
    server.current_client = old_client;
    /* performEvictions may flush slave output buffers. This may
     * result in a slave, that may be the active client, to be
     * freed. */
    return ...",2462.0,2486.0,1.0,29.0,25.0,13,5,14,5,1,3,3,3,1,3,,0,1,2,1,1,int
3502,219089,processPendingCommandAndInputBuffer,1,processPendingCommandAndInputBuffer,int processPendingCommandAndInputBuffer (client*),networking.c,"int processPendingCommandAndInputBuffer(client *c) {
    /* Notice, this code is also called from 'processUnblockedClients'.
     * But in case of a module blocked client (see RM_Call 'K' flag) we do not reach this code path.
     * So whenever we change the code here we need to consider if we need this change on module
     * blocked client as well */
    if (c->flags & CLIENT_PENDING_COMMAND) {
        c->flags &= ~CLIENT_PENDING_COMMAND;
        if (processCommandAndResetClient(c) == C_ERR) {
            return C_ERR;
        }
    }

    /* Now process client if it has more data in it's buffer.
     *
     * Note: when a master client steps into this function,
     * it can always satisfy this condition, because its querybuf
     * contains data not applied. */
    if (c->querybuf && sdslen(c->querybuf) > 0) {
        return processInputBuffer(c);
    }
    return C_OK;
}",2492.0,2513.0,1.0,19.0,22.0,13,8,6,1,2,7,4,5,5,3,,0,6,2,1,1,int
3503,219148,processInputBuffer,1,processInputBuffer,int processInputBuffer (client*),networking.c,"int processInputBuffer(client *c) {
    /* Keep processing while there is something in the input buffer */
    while(c->qb_pos < sdslen(c->querybuf)) {
        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;

        /* Don't process more buffers from clients that have already pending
         * commands to execute in c->argv. */
        if (c->flags & CLIENT_PENDING_COMMAND) break;

        /* Don't process input from the master while there is a busy script
         * condition on the slave. We want just to accumulate the replication
         * stream (instead of replying -BUSY like we do with other clients) and
         * later resume the processing. */
        if (isInsideYieldingLongCommand() && c->flags & CLIENT_MASTER) break;

        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
         * written to the client. Make sure to not let the reply grow after
         * this flag has been set (...",2520.0,2614.0,1.0,23.0,95.0,44,13,23,2,2,25,19,26,16,6,,0,22,2,1,1,int
3504,219429,readQueryFromClient,1,readQueryFromClient,void readQueryFromClient (connection*),networking.c,"void readQueryFromClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    int nread, big_arg = 0;
    size_t qblen, readlen;

    /* Check if we want to read from the client later when exiting from
     * the event loop. This is the case if threaded I/O is enabled. */
    if (postponeClientRead(c)) return;

    /* Update total number of reads on server */
    atomicIncr(server.stat_total_reads_processed, 1);

    readlen = PROTO_IOBUF_LEN;
    /* If this is a multi bulk request, and we are processing a bulk reply
     * that is large enough, try to maximize the probability that the query
     * buffer contains exactly the SDS string representing the object, even
     * at the risk of requiring more read(2) calls. This way the function
     * processMultiBulkBuffer() can avoid copying buffers to create the
     * Redis Object representing the argument. */
    if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
        && c->bulklen >= PROTO_M...",2616.0,2718.0,1.0,14.0,103.0,96,18,77,12,1,48,14,17,17,21,,0,42,2,1,1,void
3505,219858,genClientAddrString,1,genClientAddrString,"void genClientAddrString (client*,char*,size_t,int)",networking.c,"void genClientAddrString(client *client, char *addr,
                         size_t addr_len, int remote) {
    if (client->flags & CLIENT_UNIX_SOCKET) {
        /* Unix socket client. */
        snprintf(addr,addr_len,""%s:0"",server.unixsocket);
    } else {
        /* TCP client. */
        connFormatAddr(client->conn,addr,addr_len,remote);
    }
}",2731.0,2740.0,1.0,24.0,10.0,4,4,4,4,1,1,2,2,1,0,,0,1,8,4,4,void
3506,219893,getClientPeerId,1,getClientPeerId,char* getClientPeerId (client*),networking.c,"char *getClientPeerId(client *c) {
    char peerid[NET_ADDR_STR_LEN] = {0};

    if (c->peerid == NULL) {
        genClientAddrString(c,peerid,sizeof(peerid),1);
        c->peerid = sdsnew(peerid);
    }
    return c->peerid;
}",2746.0,2754.0,1.0,16.0,9.0,8,5,9,3,4,5,2,2,1,2,,0,4,2,1,1,char*
3507,219959,catClientInfoString,1,catClientInfoString,"sds catClientInfoString (sds,client*)",networking.c,"sds catClientInfoString(sds s, client *client) {
    char flags[17], events[3], conninfo[CONN_INFO_LEN], *p;

    p = flags;
    if (client->flags & CLIENT_SLAVE) {
        if (client->flags & CLIENT_MONITOR)
            *p++ = 'O';
        else
            *p++ = 'S';
    }
    if (client->flags & CLIENT_MASTER) *p++ = 'M';
    if (client->flags & CLIENT_PUBSUB) *p++ = 'P';
    if (client->flags & CLIENT_MULTI) *p++ = 'x';
    if (client->flags & CLIENT_BLOCKED) *p++ = 'b';
    if (client->flags & CLIENT_TRACKING) *p++ = 't';
    if (client->flags & CLIENT_TRACKING_BROKEN_REDIR) *p++ = 'R';
    if (client->flags & CLIENT_TRACKING_BCAST) *p++ = 'B';
    if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';
    if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';
    if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';
    if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';
    if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';
    if (client->flags & CLIENT_READONLY) *p++ = 'r';
    i...",2772.0,2851.0,1.0,40.0,80.0,238,16,112,13,10,72,23,26,23,9,,0,72,4,2,2,sds
3508,220615,getAllClientsInfoString,1,getAllClientsInfoString,sds getAllClientsInfoString (int),networking.c,"sds getAllClientsInfoString(int type) {
    listNode *ln;
    listIter li;
    client *client;
    sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));
    sdsclear(o);
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client = listNodeValue(ln);
        if (type != -1 && getClientType(client) != type) continue;
        o = catClientInfoString(o,client);
        o = sdscatlen(o,""\n"",1);
    }
    return o;
}",2853.0,2867.0,1.0,37.0,15.0,18,8,22,8,1,8,4,4,2,7,,0,6,2,1,1,sds
3509,220690,validateClientAttr,1,validateClientAttr,int validateClientAttr (char*),networking.c,"int validateClientAttr(const char *val) {
    /* Check if the charset is ok. We need to do this otherwise
     * CLIENT LIST format will break. You should always be able to
     * split by space to get the different fields. */
    while (*val) {
        if (*val < '!' || *val > '~') { /* ASCII is assumed. */
            return C_ERR;
        }
        val++;
    }
    return C_OK;
}",2870.0,2881.0,1.0,19.0,12.0,8,6,4,1,2,0,3,4,0,0,,0,0,2,1,1,int
3510,220721,validateClientName,1,validateClientName,"int validateClientName (robj*,char**)",networking.c,"int validateClientName(robj *name, const char **err) {
    const char *err_msg = ""Client names cannot contain spaces, newlines or special characters."";
    int len = (name != NULL) ? sdslen(name->ptr) : 0;
    /* We allow setting the client name to an empty string. */
    if (len == 0)
        return C_OK;
    if (validateClientAttr(name->ptr) == C_ERR) {
        if (err) *err = err_msg;
        return C_ERR;
    }
    return C_OK;
}",2884.0,2895.0,1.0,15.0,12.0,12,7,10,5,1,2,4,5,1,2,,0,2,4,2,2,int
3511,220779,clientSetName,1,clientSetName,"int clientSetName (client*,robj*,char**)",networking.c,"int clientSetName(client *c, robj *name, const char **err) {
    if (validateClientName(name, err) == C_ERR) {
        return C_ERR;
    }
    int len = (name != NULL) ? sdslen(name->ptr) : 0;
    /* Setting the client name to an empty string actually removes
     * the current name. */
    if (len == 0) {
        if (c->name) decrRefCount(c->name);
        c->name = NULL;
        return C_OK;
    }
    if (c->name) decrRefCount(c->name);
    c->name = name;
    incrRefCount(name);
    return C_OK;
}",2898.0,2914.0,1.0,41.0,17.0,16,6,16,5,3,11,5,6,3,5,,0,8,6,3,3,int
3512,220856,clientSetNameOrReply,1,clientSetNameOrReply,"int clientSetNameOrReply (client*,robj*)",networking.c,"int clientSetNameOrReply(client *c, robj *name) {
    const char *err = NULL;
    int result = clientSetName(c, name, &err);
    if (result == C_ERR) {
        addReplyError(c, err);
    }
    return result;
}",2925.0,2932.0,1.0,18.0,8.0,5,4,10,5,0,2,2,2,0,2,,0,1,4,2,2,int
3513,220887,clientSetinfoCommand,1,clientSetinfoCommand,void clientSetinfoCommand (client*),networking.c,"void clientSetinfoCommand(client *c) {
    sds attr = c->argv[2]->ptr;
    robj *valob = c->argv[3];
    sds val = valob->ptr;
    robj **destvar = NULL;
    if (!strcasecmp(attr,""lib-name"")) {
        destvar = &c->lib_name;
    } else if (!strcasecmp(attr,""lib-ver"")) {
        destvar = &c->lib_ver;
    } else {
        addReplyErrorFormat(c,""Unrecognized option '%s'"", attr);
        return;
    }

    if (validateClientAttr(val)==C_ERR) {
        addReplyErrorFormat(c,
            ""%s cannot contain spaces, newlines or special characters."", attr);
        return;
    }
    if (*destvar) decrRefCount(*destvar);
    if (sdslen(val)) {
        *destvar = valob;
        incrRefCount(valob);
    } else
        *destvar = NULL;
    addReply(c,shared.ok);
}",2935.0,2961.0,1.0,33.0,27.0,21,9,22,7,0,9,5,5,2,6,,0,5,2,1,1,void
3514,220995,resetCommand,1,resetCommand,void resetCommand (client*),networking.c,"void resetCommand(client *c) {
    /* MONITOR clients are also marked with CLIENT_SLAVE, we need to
     * distinguish between the two.
     */
    uint64_t flags = c->flags;
    if (flags & CLIENT_MONITOR) flags &= ~(CLIENT_MONITOR|CLIENT_SLAVE);

    if (flags & (CLIENT_SLAVE|CLIENT_MASTER|CLIENT_MODULE)) {
        addReplyError(c,""can only reset normal client connections"");
        return;
    }

    clearClientConnectionState(c);
    addReplyStatus(c,""RESET"");
}",2965.0,2979.0,1.0,16.0,15.0,14,6,8,2,0,4,3,3,0,3,,0,1,2,1,1,void
3515,221059,quitCommand,1,quitCommand,void quitCommand (client*),networking.c,"void quitCommand(client *c) {
    addReply(c,shared.ok);
    c->flags |= CLIENT_CLOSE_AFTER_REPLY;
}",2982.0,2985.0,1.0,16.0,4.0,3,3,3,2,0,2,1,1,0,1,,0,1,2,1,1,void
3516,221078,clientCommand,1,clientCommand,void clientCommand (client*),networking.c,"void clientCommand(client *c) {
    listNode *ln;
    listIter li;

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CACHING (YES|NO)"",
""    Enable/disable tracking of the keys for next command in OPTIN/OPTOUT modes."",
""GETREDIR"",
""    Return the client ID we are redirecting to when tracking is enabled."",
""GETNAME"",
""    Return the name of the current connection."",
""ID"",
""    Return the ID of the current connection."",
""INFO"",
""    Return information about the current client connection."",
""KILL <ip:port>"",
""    Kill connection made from <ip:port>."",
""KILL <option> <value> [<option> <value> [...]]"",
""    Kill connections. Options are:"",
""    * ADDR (<ip:port>|<unixsocket>:0)"",
""      Kill connections made from the specified address"",
""    * LADDR (<ip:port>|<unixsocket>:0)"",
""      Kill connections made to specified local address"",
""    * TYPE (NORMAL|MASTER|REPLICA|PUBSUB)"",
""      Kill connections by type."",
""    * USER <username>"",
""   ...",2987.0,3527.0,1.0,26.0,541.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
3517,223423,helloCommand,1,helloCommand,void helloCommand (client*),networking.c,"void helloCommand(client *c) {
    long long ver = 0;
    int next_arg = 1;

    if (c->argc >= 2) {
        if (getLongLongFromObjectOrReply(c, c->argv[next_arg++], &ver,
            ""Protocol version is not an integer or out of range"") != C_OK) {
            return;
        }

        if (ver < 2 || ver > 3) {
            addReplyError(c,""-NOPROTO unsupported protocol version"");
            return;
        }
    }

    robj *username = NULL;
    robj *password = NULL;
    robj *clientname = NULL;
    for (int j = next_arg; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        const char *opt = c->argv[j]->ptr;
        if (!strcasecmp(opt,""AUTH"") && moreargs >= 2) {
            redactClientCommandArgument(c, j+1);
            redactClientCommandArgument(c, j+2);
            username = c->argv[j+1];
            password = c->argv[j+2];
            j += 2;
        } else if (!strcasecmp(opt,""SETNAME"") && moreargs) {
            clientname = c->argv[j+1];
            con...",3530.0,3626.0,1.0,69.0,97.0,62,18,88,15,0,35,15,21,5,24,,0,13,2,1,1,void
3518,223760,securityWarningCommand,1,securityWarningCommand,void securityWarningCommand (client*),networking.c,"void securityWarningCommand(client *c) {
    static time_t logged_time = 0;
    time_t now = time(NULL);

    if (llabs(now-logged_time) > 60) {
        char ip[NET_IP_STR_LEN];
        int port;
        if (connAddrPeerName(c->conn, ip, sizeof(ip), &port) == -1) {
            serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted."");
        } else {
            serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection from %s:%d aborted."", ip, port);
        }
        logged_time = now;
    }
    freeClientAsync(c);
}",3637.0,3652.0,1.0,16.0,16.0,13,11,13,7,1,4,3,4,2,3,,0,2,2,1,1,void
3519,223843,retainOriginalCommandVector,1,retainOriginalCommandVector,void retainOriginalCommandVector (client*),networking.c,"static void retainOriginalCommandVector(client *c) {
    /* We already rewrote this command, so don't rewrite it again */
    if (c->original_argv) return;
    c->original_argc = c->argc;
    c->original_argv = zmalloc(sizeof(robj*)*(c->argc));
    for (int j = 0; j < c->argc; j++) {
        c->original_argv[j] = c->argv[j];
        incrRefCount(c->argv[j]);
    }
}",3656.0,3665.0,1.0,1.0,10.0,19,6,15,3,3,11,3,3,2,2,,0,10,2,1,1,void
3520,223903,redactClientCommandArgument,1,redactClientCommandArgument,"void redactClientCommandArgument (client*,int)",networking.c,"void redactClientCommandArgument(client *c, int argc) {
    retainOriginalCommandVector(c);
    if (c->original_argv[argc] == shared.redacted) {
        /* This argument has already been redacted */
        return;
    }
    decrRefCount(c->original_argv[argc]);
    c->original_argv[argc] = shared.redacted;
}",3670.0,3678.0,1.0,1.0,9.0,10,5,9,3,6,5,2,2,1,2,,0,3,4,2,2,void
3521,223938,rewriteClientCommandVector,1,rewriteClientCommandVector,"void rewriteClientCommandVector (client*,int...)",networking.c,"void rewriteClientCommandVector(client *c, int argc, ...) {
    va_list ap;
    int j;
    robj **argv; /* The new argument vector */

    argv = zmalloc(sizeof(robj*)*argc);
    va_start(ap,argc);
    for (j = 0; j < argc; j++) {
        robj *a;

        a = va_arg(ap, robj*);
        argv[j] = a;
        incrRefCount(a);
    }
    replaceClientCommandVector(c, argc, argv);
    va_end(ap);
}",3683.0,3699.0,1.0,1.0,17.0,7,5,16,7,8,3,2,2,0,3,,0,1,4,2,2,void
3522,223983,replaceClientCommandVector,1,replaceClientCommandVector,"void replaceClientCommandVector (client*,int,robj**)",networking.c,"void replaceClientCommandVector(client *c, int argc, robj **argv) {
    int j;
    retainOriginalCommandVector(c);
    freeClientArgv(c);
    c->argv = argv;
    c->argc = argc;
    c->argv_len_sum = 0;
    for (j = 0; j < c->argc; j++)
        if (c->argv[j])
            c->argv_len_sum += getStringObjectLen(c->argv[j]);
    c->cmd = lookupCommandOrOriginal(c->argv,c->argc);
    serverAssertWithInfo(c,NULL,c->cmd != NULL);
}",3702.0,3714.0,1.0,4.0,13.0,19,8,19,5,4,12,2,2,1,4,,0,9,6,3,3,void
3523,224072,rewriteClientCommandArgument,1,rewriteClientCommandArgument,"void rewriteClientCommandArgument (client*,int,robj*)",networking.c,"void rewriteClientCommandArgument(client *c, int i, robj *newval) {
    robj *oldval;
    retainOriginalCommandVector(c);

    /* We need to handle both extending beyond argc (just update it and
     * initialize the new element) or beyond argv_len (realloc is needed).
     */
    if (i >= c->argc) {
        if (i >= c->argv_len) {
            c->argv = zrealloc(c->argv,sizeof(robj*)*(i+1));
            c->argv_len = i+1;
        }
        c->argc = i+1;
        c->argv[i] = NULL;
    }
    oldval = c->argv[i];
    if (oldval) c->argv_len_sum -= getStringObjectLen(oldval);
    if (newval) c->argv_len_sum += getStringObjectLen(newval);
    c->argv[i] = newval;
    incrRefCount(newval);
    if (oldval) decrRefCount(oldval);

    /* If this is the command name make sure to fix c->cmd. */
    if (i == 0) {
        c->cmd = lookupCommandOrOriginal(c->argv,c->argc);
        serverAssertWithInfo(c,NULL,c->cmd != NULL);
    }
}",3727.0,3754.0,1.0,8.0,28.0,40,15,41,6,4,23,7,8,2,8,,0,17,6,3,3,void
3524,224208,getClientOutputBufferMemoryUsage,1,getClientOutputBufferMemoryUsage,size_t getClientOutputBufferMemoryUsage (client*),networking.c,"size_t getClientOutputBufferMemoryUsage(client *c) {
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        size_t repl_buf_size = 0;
        size_t repl_node_num = 0;
        size_t repl_node_size = sizeof(listNode) + sizeof(replBufBlock);
        if (c->ref_repl_buf_node) {
            replBufBlock *last = listNodeValue(listLast(server.repl_buffer_blocks));
            replBufBlock *cur = listNodeValue(c->ref_repl_buf_node);
            repl_buf_size = last->repl_offset + last->size - cur->repl_offset;
            repl_node_num = last->id - cur->id + 1;
        }
        return repl_buf_size + (repl_node_size*repl_node_num);
    } else { 
        size_t list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
        return c->reply_bytes + (list_item_size*listLength(c->reply));
    }
}",3762.0,3778.0,1.0,28.0,17.0,29,8,22,9,3,9,3,4,2,1,,0,9,2,1,1,size_t
3525,224324,getClientMemoryUsage,1,getClientMemoryUsage,"size_t getClientMemoryUsage (client*,size_t*)",networking.c,"size_t getClientMemoryUsage(client *c, size_t *output_buffer_mem_usage) {
    size_t mem = getClientOutputBufferMemoryUsage(c);
    if (output_buffer_mem_usage != NULL)
        *output_buffer_mem_usage = mem;
    mem += sdsZmallocSize(c->querybuf);
    mem += zmalloc_size(c);
    mem += c->buf_usable_size;
    /* For efficiency (less work keeping track of the argv memory), it doesn't include the used memory
     * i.e. unused sds space and internal fragmentation, just the string length. but this is enough to
     * spot problematic clients. */
    mem += c->argv_len_sum + sizeof(robj*)*c->argc;
    mem += multiStateMemOverhead(c);

    /* Add memory overhead of pubsub channels and patterns. Note: this is just the overhead of the robj pointers
     * to the strings themselves because they aren't stored per client. */
    mem += pubsubMemOverhead(c);

    /* Add memory overhead of the tracking prefixes, this is an underestimation so we don't need to traverse the entire rax */
    if (...",3783.0,3805.0,1.0,1.0,23.0,25,8,26,6,2,11,3,3,1,5,,0,7,4,2,2,size_t
3526,224399,getClientType,1,getClientType,int getClientType (client*),networking.c,"int getClientType(client *c) {
    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
    /* Even though MONITOR clients are marked as replicas, we
     * want the expose them as normal clients. */
    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
        return CLIENT_TYPE_SLAVE;
    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
    return CLIENT_TYPE_NORMAL;
}",3816.0,3824.0,1.0,19.0,9.0,14,5,4,1,17,4,4,4,4,0,,0,4,2,1,1,int
3527,224464,getClientTypeByName,1,getClientTypeByName,int getClientTypeByName (char*),networking.c,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""replica"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}",3826.0,3833.0,1.0,43.0,8.0,1,1,1,1,1,0,2,2,0,0,,0,0,2,1,1,int
3528,224532,getClientTypeName,1,getClientTypeName,char* getClientTypeName (int),networking.c,"char *getClientTypeName(int class) {
    switch(class) {
    case CLIENT_TYPE_NORMAL: return ""normal"";
    case CLIENT_TYPE_SLAVE:  return ""slave"";
    case CLIENT_TYPE_PUBSUB: return ""pubsub"";
    case CLIENT_TYPE_MASTER: return ""master"";
    default:                       return NULL;
    }
}",3835.0,3843.0,1.0,9.0,9.0,0,0,2,2,2,0,2,2,0,0,,0,0,2,1,1,char*
3529,224567,checkClientOutputBufferLimits,1,checkClientOutputBufferLimits,int checkClientOutputBufferLimits (client*),networking.c,"int checkClientOutputBufferLimits(client *c) {
    int soft = 0, hard = 0, class;
    unsigned long used_mem = getClientOutputBufferMemoryUsage(c);

    class = getClientType(c);
    /* For the purpose of output buffer limiting, masters are handled
     * like normal clients. */
    if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;

    /* Note that it doesn't make sense to set the replica clients output buffer
     * limit lower than the repl-backlog-size config (partial sync will succeed
     * and then replica will get disconnected).
     * Such a configuration is ignored (the size of repl-backlog-size will be used).
     * This doesn't have memory consumption implications since the replica client
     * will share the backlog buffers memory. */
    size_t hard_limit_bytes = server.client_obuf_limits[class].hard_limit_bytes;
    if (class == CLIENT_TYPE_SLAVE && hard_limit_bytes &&
        (long long)hard_limit_bytes < server.repl_backlog_size)
        hard_limit_bytes...",3851.0,3897.0,1.0,17.0,47.0,40,10,35,7,1,4,7,8,1,2,,0,4,2,1,1,int
3530,224729,closeClientOnOutputBufferLimitReached,1,closeClientOnOutputBufferLimitReached,"int closeClientOnOutputBufferLimitReached (client*,int)",networking.c,"int closeClientOnOutputBufferLimitReached(client *c, int async) {
    if (!c->conn) return 0; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    /* Note that c->reply_bytes is irrelevant for replica clients
     * (they use the global repl buffers). */
    if ((c->reply_bytes == 0 && getClientType(c) != CLIENT_TYPE_SLAVE) ||
        c->flags & CLIENT_CLOSE_ASAP) return 0;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        if (async) {
            freeClientAsync(c);
            serverLog(LL_WARNING,
                      ""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."",
                      client);
        } else {
            freeClient(c);
            serverLog(LL_WARNING,
                      ""Client %s closed for overcoming of output buffer limits."",
                      client);
        }
        sdsfree(client);
        return  1;
    }
...",3910.0,3935.0,1.0,4.0,26.0,22,17,14,5,4,12,5,6,5,8,,0,8,4,2,2,int
3531,224854,flushSlavesOutputBuffers,1,flushSlavesOutputBuffers,void flushSlavesOutputBuffers (void),networking.c,"void flushSlavesOutputBuffers(void) {
    listIter li;
    listNode *ln;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = listNodeValue(ln);
        int can_receive_writes = connHasWriteHandler(slave->conn) ||
                                 (slave->flags & CLIENT_PENDING_WRITE);

        /* We don't want to send the pending data to the replica in a few
         * cases:
         *
         * 1. For some reason there is neither the write handler installed
         *    nor the client is flagged as to have pending writes: for some
         *    reason this replica may not be set to receive data. This is
         *    just for the sake of defensive programming.
         *
         * 2. The put_online_on_ack flag is true. To know why we don't want
         *    to send data to the replica in this case, please grep for the
         *    flag for this flag.
         *
         * 3. Obviously if the slave is not ONLINE.
         */
        if ...",3941.0,3974.0,1.0,24.0,34.0,24,10,16,5,1,11,3,4,5,5,,0,9,2,1,1,void
3532,224933,updatePausedActions,1,updatePausedActions,void updatePausedActions (void),networking.c,"void updatePausedActions(void) {
    uint32_t prev_paused_actions = server.paused_actions;
    server.paused_actions = 0;

    for (int i = 0; i < NUM_PAUSE_PURPOSES; i++) {
        pause_event *p = &(server.client_pause_per_purpose[i]);
        if (p->end > server.mstime)
            server.paused_actions |= p->paused_actions;
        else {
            p->paused_actions = 0;
            p->end = 0;
        }
    }

    /* If the pause type is less restrictive than before, we unblock all clients
     * so they are reprocessed (may get re-paused). */
    uint32_t mask_cli = (PAUSE_ACTION_CLIENT_WRITE|PAUSE_ACTION_CLIENT_ALL);
    if ((server.paused_actions & mask_cli) < (prev_paused_actions & mask_cli)) {
        unblockPostponedClients();
    }
}",3978.0,3998.0,1.0,25.0,21.0,23,10,18,6,4,3,4,5,1,1,,0,2,2,1,1,void
3533,225024,unblockPostponedClients,1,unblockPostponedClients,void unblockPostponedClients (void),networking.c,"void unblockPostponedClients(void) {
    listNode *ln;
    listIter li;
    listRewind(server.postponed_clients, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        unblockClient(c, 1);
    }
}",4002.0,4010.0,1.0,20.0,9.0,7,5,9,5,2,4,2,2,1,3,,0,2,2,1,1,void
3534,225151,pauseActions,1,pauseActions,"void pauseActions (pause_purpose,mstime_t,uint32_t)",networking.c,"void pauseActions(pause_purpose purpose, mstime_t end, uint32_t actions) {
    /* Manage pause type and end time per pause purpose. */
    server.client_pause_per_purpose[purpose].paused_actions = actions;

    /* If currently configured end time bigger than new one, then keep it */
    if (server.client_pause_per_purpose[purpose].end < end)
        server.client_pause_per_purpose[purpose].end = end;

    updatePausedActions();

    /* We allow write commands that were queued
     * up before and after to execute. We need
     * to track this state so that we don't assert
     * in propagateNow(). */
    if (server.in_exec) {
        server.client_pause_in_transaction = 1;
    }
}",4044.0,4061.0,1.0,1.0,18.0,15,4,11,4,2,1,3,3,0,1,,0,0,6,3,3,void
3535,225198,unpauseActions,1,unpauseActions,void unpauseActions (pause_purpose),networking.c,"void unpauseActions(pause_purpose purpose) {
    server.client_pause_per_purpose[purpose].end = 0;
    server.client_pause_per_purpose[purpose].paused_actions = 0;
    updatePausedActions();
}",4064.0,4068.0,1.0,1.0,5.0,8,3,4,2,2,1,1,1,0,1,,0,0,2,1,1,void
3536,225222,isPausedActions,1,isPausedActions,uint32_t isPausedActions (uint32_t),networking.c,"uint32_t isPausedActions(uint32_t actions_bitmask) {
    return (server.paused_actions & actions_bitmask);
}",4071.0,4073.0,1.0,1.0,3.0,2,2,2,2,4,0,1,1,0,0,,0,0,2,1,1,uint32_t
3537,225233,isPausedActionsWithUpdate,1,isPausedActionsWithUpdate,uint32_t isPausedActionsWithUpdate (uint32_t),networking.c,"uint32_t isPausedActionsWithUpdate(uint32_t actions_bitmask) {
    if (!(server.paused_actions & actions_bitmask)) return 0;
    updatePausedActions();
    return (server.paused_actions & actions_bitmask);
}",4076.0,4080.0,1.0,1.0,5.0,5,3,4,2,5,1,2,2,0,1,,0,0,2,1,1,uint32_t
3538,225255,processEventsWhileBlocked,1,processEventsWhileBlocked,void processEventsWhileBlocked (void),networking.c,"void processEventsWhileBlocked(void) {
    int iterations = 4; /* See the function top-comment. */

    /* Update our cached time since it is used to create and update the last
     * interaction time with clients and for other important things. */
    updateCachedTime(0);

    /* For the few commands that are allowed during busy scripts, we rather
     * provide a fresher time than the one from when the script started (they
     * still won't get it from the call due to execution_nesting. For commands
     * during loading this doesn't matter. */
    mstime_t prev_cmd_time_snapshot = server.cmd_time_snapshot;
    server.cmd_time_snapshot = server.mstime;

    /* Note: when we are processing events while blocked (for instance during
     * busy Lua scripts), we set a global flag. When such flag is set, we
     * avoid handling the read part of clients using threaded I/O.
     * See https://github.com/redis/redis/issues/6988 for more info.
     * Note that there could be cases of nes...",4094.0,4134.0,1.0,12.0,41.0,33,14,21,7,5,7,4,4,0,4,,0,4,2,1,1,void
3539,225387,getIOPendingCount,1,getIOPendingCount,unsigned long getIOPendingCount (int),networking.c,"static inline unsigned long getIOPendingCount(int i) {
    unsigned long count = 0;
    atomicGetWithSync(io_threads_pending[i].value, count);
    return count;
}",4163.0,4167.0,1.0,1.0,5.0,3,3,5,3,3,1,1,1,0,0,,0,1,2,1,1,unsigned long
3540,225405,setIOPendingCount,1,setIOPendingCount,"void setIOPendingCount (int,long unsigned)",networking.c,"static inline void setIOPendingCount(int i, unsigned long count) {
    atomicSetWithSync(io_threads_pending[i].value, count);
}",4169.0,4171.0,1.0,1.0,3.0,2,2,3,3,4,1,1,1,0,0,,0,1,4,2,2,void
3541,225418,IOThreadMain,1,IOThreadMain,void* IOThreadMain (void*),networking.c,"void *IOThreadMain(void *myid) {
    /* The ID is the thread number (from 0 to server.io_threads_num-1), and is
     * used by the thread to just manipulate a single sub-array of clients. */
    long id = (unsigned long)myid;
    char thdname[16];

    snprintf(thdname, sizeof(thdname), ""io_thd_%ld"", id);
    redis_set_thread_title(thdname);
    redisSetCpuAffinity(server.server_cpulist);
    makeThreadKillable();

    while(1) {
        /* Wait for start */
        for (int j = 0; j < 1000000; j++) {
            if (getIOPendingCount(id) != 0) break;
        }

        /* Give the main thread a chance to stop this thread. */
        if (getIOPendingCount(id) == 0) {
            pthread_mutex_lock(&io_threads_mutex[id]);
            pthread_mutex_unlock(&io_threads_mutex[id]);
            continue;
        }

        serverAssert(getIOPendingCount(id) != 0);

        /* Process: note that the main thread will never touch our list
         * before we drop the pending count to 0. */
...",4173.0,4217.0,1.0,4.0,45.0,25,13,28,11,0,17,9,14,4,11,,0,9,2,1,1,void*
3542,225561,initThreadedIO,1,initThreadedIO,void initThreadedIO (void),networking.c,"void initThreadedIO(void) {
    server.io_threads_active = 0; /* We start with threads not active. */

    /* Indicate that io-threads are currently idle */
    io_threads_op = IO_THREADS_OP_IDLE;

    /* Don't spawn any thread if the user selected a single thread:
     * we'll handle I/O directly from the main thread. */
    if (server.io_threads_num == 1) return;

    if (server.io_threads_num > IO_THREADS_MAX_NUM) {
        serverLog(LL_WARNING,""Fatal: too many I/O threads configured. ""
                             ""The maximum number is %d."", IO_THREADS_MAX_NUM);
        exit(1);
    }

    /* Spawn and initialize the I/O threads. */
    for (int i = 0; i < server.io_threads_num; i++) {
        /* Things we do for all the threads including the main thread. */
        io_threads_list[i] = listCreate();
        if (i == 0) continue; /* Thread 0 is the main thread. */

        /* Things we do only for the additional threads. */
        pthread_t tid;
        pthread_mutex_init(&io_...",4220.0,4253.0,1.0,20.0,34.0,29,10,24,8,1,9,7,8,0,4,,0,6,2,1,1,void
3543,225693,killIOThreads,1,killIOThreads,void killIOThreads (void),networking.c,"void killIOThreads(void) {
    int err, j;
    for (j = 0; j < server.io_threads_num; j++) {
        if (io_threads[j] == pthread_self()) continue;
        if (io_threads[j] && pthread_cancel(io_threads[j]) == 0) {
            if ((err = pthread_join(io_threads[j],NULL)) != 0) {
                serverLog(LL_WARNING,
                    ""IO thread(tid:%lu) can not be joined: %s"",
                        (unsigned long)io_threads[j], strerror(err));
            } else {
                serverLog(LL_WARNING,
                    ""IO thread(tid:%lu) terminated"",(unsigned long)io_threads[j]);
            }
        }
    }
}",4255.0,4270.0,1.0,16.0,16.0,17,9,17,5,1,6,6,9,4,1,,0,5,2,1,1,void
3544,225794,startThreadedIO,1,startThreadedIO,void startThreadedIO (void),networking.c,"void startThreadedIO(void) {
    serverAssert(server.io_threads_active == 0);
    for (int j = 1; j < server.io_threads_num; j++)
        pthread_mutex_unlock(&io_threads_mutex[j]);
    server.io_threads_active = 1;
}",4272.0,4277.0,1.0,4.0,6.0,11,8,5,2,1,1,2,2,0,1,,0,0,2,1,1,void
3545,225840,stopThreadedIO,1,stopThreadedIO,void stopThreadedIO (void),networking.c,"void stopThreadedIO(void) {
    /* We may have still clients with pending reads when this function
     * is called: handle them before stopping the threads. */
    handleClientsWithPendingReadsUsingThreads();
    serverAssert(server.io_threads_active == 1);
    for (int j = 1; j < server.io_threads_num; j++)
        pthread_mutex_lock(&io_threads_mutex[j]);
    server.io_threads_active = 0;
}",4279.0,4287.0,1.0,4.0,9.0,11,8,5,2,1,2,2,2,0,2,,0,0,2,1,1,void
3546,225887,stopThreadedIOIfNeeded,1,stopThreadedIOIfNeeded,int stopThreadedIOIfNeeded (void),networking.c,"int stopThreadedIOIfNeeded(void) {
    int pending = listLength(server.clients_pending_write);

    /* Return ASAP if IO threads are disabled (single threaded mode). */
    if (server.io_threads_num == 1) return 1;

    if (pending < (server.io_threads_num*2)) {
        if (server.io_threads_active) stopThreadedIO();
        return 1;
    } else {
        return 0;
    }
}",4298.0,4310.0,1.0,18.0,13.0,10,6,7,2,2,1,4,5,0,1,,0,0,2,1,1,int
3547,225935,handleClientsWithPendingWritesUsingThreads,1,handleClientsWithPendingWritesUsingThreads,int handleClientsWithPendingWritesUsingThreads (void),networking.c,"int handleClientsWithPendingWritesUsingThreads(void) {
    int processed = listLength(server.clients_pending_write);
    if (processed == 0) return 0; /* Return ASAP if there are no clients. */

    /* If I/O threads are disabled or we have few clients to serve, don't
     * use I/O threads, but the boring synchronous code. */
    if (server.io_threads_num == 1 || stopThreadedIOIfNeeded()) {
        return handleClientsWithPendingWrites();
    }

    /* Start threads if needed. */
    if (!server.io_threads_active) startThreadedIO();

    /* Distribute the clients across N different lists. */
    listIter li;
    listNode *ln;
    listRewind(server.clients_pending_write,&li);
    int item_id = 0;
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        c->flags &= ~CLIENT_PENDING_WRITE;

        /* Remove clients from the list of pending writes since
         * they are going to be closed ASAP. */
        if (c->flags & CLIENT_CLOSE_ASAP) {
            listUn...",4318.0,4410.0,1.0,20.0,93.0,67,16,71,12,1,33,18,20,7,20,,0,19,2,1,1,int
3548,226292,handleClientsWithPendingReadsUsingThreads,1,handleClientsWithPendingReadsUsingThreads,int handleClientsWithPendingReadsUsingThreads (void),networking.c,"int handleClientsWithPendingReadsUsingThreads(void) {
    if (!server.io_threads_active || !server.io_threads_do_reads) return 0;
    int processed = listLength(server.clients_pending_read);
    if (processed == 0) return 0;

    /* Distribute the clients across N different lists. */
    listIter li;
    listNode *ln;
    listRewind(server.clients_pending_read,&li);
    int item_id = 0;
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        int target_id = item_id % server.io_threads_num;
        listAddNodeTail(io_threads_list[target_id],c);
        item_id++;
    }

    /* Give the start condition to the waiting threads, by setting the
     * start condition atomic var. */
    io_threads_op = IO_THREADS_OP_READ;
    for (int j = 1; j < server.io_threads_num; j++) {
        int count = listLength(io_threads_list[j]);
        setIOPendingCount(j, count);
    }

    /* Also use the main thread to process a slice of clients. */
    listRewind(io_threads_list[...",4443.0,4523.0,1.0,20.0,81.0,75,20,69,13,3,29,16,18,6,15,,0,19,2,1,1,int
3549,226583,getClientEvictionLimit,1,getClientEvictionLimit,size_t getClientEvictionLimit (void),networking.c,"size_t getClientEvictionLimit(void) {
    size_t maxmemory_clients_actual = SIZE_MAX;

    /* Handle percentage of maxmemory*/
    if (server.maxmemory_clients < 0 && server.maxmemory > 0) {
        unsigned long long maxmemory_clients_bytes = (unsigned long long)((double)server.maxmemory * -(double) server.maxmemory_clients / 100);
        if (maxmemory_clients_bytes <= SIZE_MAX)
            maxmemory_clients_actual = maxmemory_clients_bytes;
    }
    else if (server.maxmemory_clients > 0)
        maxmemory_clients_actual = server.maxmemory_clients;
    else
        return 0;

    /* Don't allow a too small maxmemory-clients to avoid cases where we can't communicate
     * at all with the server because of bad configuration */
    if (maxmemory_clients_actual < 1024*128)
        maxmemory_clients_actual = 1024*128;

    return maxmemory_clients_actual;
}",4527.0,4547.0,1.0,1.0,21.0,21,10,14,4,1,0,4,5,0,0,,0,0,2,1,1,size_t
3550,226664,evictClients,1,evictClients,void evictClients (void),networking.c,"void evictClients(void) {
    if (!server.client_mem_usage_buckets)
        return;
    /* Start eviction from topmost bucket (largest clients) */
    int curr_bucket = CLIENT_MEM_USAGE_BUCKETS-1;
    listIter bucket_iter;
    listRewind(server.client_mem_usage_buckets[curr_bucket].clients, &bucket_iter);
    size_t client_eviction_limit = getClientEvictionLimit();
    if (client_eviction_limit == 0)
        return;
    while (server.stat_clients_type_memory[CLIENT_TYPE_NORMAL] +
           server.stat_clients_type_memory[CLIENT_TYPE_PUBSUB] >= client_eviction_limit) {
        listNode *ln = listNext(&bucket_iter);
        if (ln) {
            client *c = ln->value;
            sds ci = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE, ""Evicting client: %s"", ci);
            freeClient(c);
            sdsfree(ci);
            server.stat_evictedclients++;
        } else {
            curr_bucket--;
            if (curr_bucket < 0) {
                serverLog(LL_WA...",4549.0,4578.0,1.0,22.0,30.0,28,13,22,7,2,9,5,6,0,8,,0,5,2,1,1,void
3551,226821,keyspaceEventsStringToFlags,1,keyspaceEventsStringToFlags,int keyspaceEventsStringToFlags (char*),notify.c,"int keyspaceEventsStringToFlags(char *classes) {
    char *p = classes;
    int c, flags = 0;

    while((c = *p++) != '\0') {
        switch(c) {
        case 'A': flags |= NOTIFY_ALL; break;
        case 'g': flags |= NOTIFY_GENERIC; break;
        case '$': flags |= NOTIFY_STRING; break;
        case 'l': flags |= NOTIFY_LIST; break;
        case 's': flags |= NOTIFY_SET; break;
        case 'h': flags |= NOTIFY_HASH; break;
        case 'z': flags |= NOTIFY_ZSET; break;
        case 'x': flags |= NOTIFY_EXPIRED; break;
        case 'e': flags |= NOTIFY_EVICTED; break;
        case 'K': flags |= NOTIFY_KEYSPACE; break;
        case 'E': flags |= NOTIFY_KEYEVENT; break;
        case 't': flags |= NOTIFY_STREAM; break;
        case 'm': flags |= NOTIFY_KEY_MISS; break;
        case 'd': flags |= NOTIFY_MODULE; break;
        case 'n': flags |= NOTIFY_NEW; break;
        default: return -1;
        }
    }
    return flags;
}",40.0,65.0,1.0,27.0,26.0,40,7,22,4,1,0,18,4,0,0,,0,0,2,1,1,int
3552,227039,keyspaceEventsFlagsToString,1,keyspaceEventsFlagsToString,sds keyspaceEventsFlagsToString (int),notify.c,"sds keyspaceEventsFlagsToString(int flags) {
    sds res;

    res = sdsempty();
    if ((flags & NOTIFY_ALL) == NOTIFY_ALL) {
        res = sdscatlen(res,""A"",1);
    } else {
        if (flags & NOTIFY_GENERIC) res = sdscatlen(res,""g"",1);
        if (flags & NOTIFY_STRING) res = sdscatlen(res,""$"",1);
        if (flags & NOTIFY_LIST) res = sdscatlen(res,""l"",1);
        if (flags & NOTIFY_SET) res = sdscatlen(res,""s"",1);
        if (flags & NOTIFY_HASH) res = sdscatlen(res,""h"",1);
        if (flags & NOTIFY_ZSET) res = sdscatlen(res,""z"",1);
        if (flags & NOTIFY_EXPIRED) res = sdscatlen(res,""x"",1);
        if (flags & NOTIFY_EVICTED) res = sdscatlen(res,""e"",1);
        if (flags & NOTIFY_STREAM) res = sdscatlen(res,""t"",1);
        if (flags & NOTIFY_MODULE) res = sdscatlen(res,""d"",1);
        if (flags & NOTIFY_NEW) res = sdscatlen(res,""n"",1);
    }
    if (flags & NOTIFY_KEYSPACE) res = sdscatlen(res,""K"",1);
    if (flags & NOTIFY_KEYEVENT) res = sdscatlen(res,""E"",1);
    if (f...",71.0,94.0,1.0,17.0,24.0,51,5,14,2,2,5,5,5,0,5,,0,5,2,1,1,sds
3553,227355,notifyKeyspaceEvent,1,notifyKeyspaceEvent,"void notifyKeyspaceEvent (int,char*,robj*,int)",notify.c,"void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
    sds chan;
    robj *chanobj, *eventobj;
    int len = -1;
    char buf[24];

    /* If any modules are interested in events, notify the module system now.
     * This bypasses the notifications configuration, but the module engine
     * will only call event subscribers if the event type matches the types
     * they are interested in. */
     moduleNotifyKeyspaceEvent(type, event, key, dbid);

    /* If notifications for this class of events are off, return ASAP. */
    if (!(server.notify_keyspace_events & type)) return;

    eventobj = createStringObject(event,strlen(event));

    /* __keyspace@<db>__:<key> <event> notifications. */
    if (server.notify_keyspace_events & NOTIFY_KEYSPACE) {
        chan = sdsnewlen(""__keyspace@"",11);
        len = ll2string(buf,sizeof(buf),dbid);
        chan = sdscatlen(chan, buf, len);
        chan = sdscatlen(chan, ""__:"", 3);
        chan = sdscatsds(chan, key->ptr);
  ...",104.0,145.0,1.0,40.0,42.0,30,9,52,10,34,19,5,6,0,19,,0,13,8,4,4,void
3554,227525,createObject,1,createObject,"robj createObject (int,void*)",object.c,"robj *createObject(int type, void *ptr) {
    robj *o = zmalloc(sizeof(*o));
    o->type = type;
    o->encoding = OBJ_ENCODING_RAW;
    o->ptr = ptr;
    o->refcount = 1;
    o->lru = 0;
    return o;
}",43.0,51.0,1.0,18.0,9.0,13,4,10,3,30,1,1,1,0,1,,0,1,4,2,2,robj
3555,227567,initObjectLRUOrLFU,1,initObjectLRUOrLFU,void initObjectLRUOrLFU (robj*),object.c,"void initObjectLRUOrLFU(robj *o) {
    if (o->refcount == OBJ_SHARED_REFCOUNT)
        return;
    /* Set the LRU to the current lruclock (minutes resolution), or
     * alternatively the LFU counter. */
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes() << 8) | LFU_INIT_VAL;
    } else {
        o->lru = LRU_CLOCK();
    }
    return;
}",53.0,64.0,1.0,23.0,12.0,9,7,4,3,2,1,3,3,0,1,,0,1,2,1,1,void
3556,227612,makeObjectShared,1,makeObjectShared,robj makeObjectShared (robj*),object.c,"robj *makeObjectShared(robj *o) {
    serverAssert(o->refcount == 1);
    o->refcount = OBJ_SHARED_REFCOUNT;
    return o;
}",77.0,81.0,1.0,4.0,5.0,8,7,4,2,0,1,1,1,0,1,,0,0,2,1,1,robj
3557,227644,createRawStringObject,1,createRawStringObject,"robj createRawStringObject (char*,size_t)",object.c,"robj *createRawStringObject(const char *ptr, size_t len) {
    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
}",85.0,87.0,1.0,24.0,3.0,0,0,2,2,8,2,1,1,0,2,,0,1,4,2,2,robj
3558,227658,createEmbeddedStringObject,1,createEmbeddedStringObject,"robj createEmbeddedStringObject (char*,size_t)",object.c,"robj *createEmbeddedStringObject(const char *ptr, size_t len) {
    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
    struct sdshdr8 *sh = (void*)(o+1);

    o->type = OBJ_STRING;
    o->encoding = OBJ_ENCODING_EMBSTR;
    o->ptr = sh+1;
    o->refcount = 1;
    o->lru = 0;

    sh->len = len;
    sh->alloc = len;
    sh->flags = SDS_TYPE_8;
    if (ptr == SDS_NOINIT)
        sh->buf[len] = '\0';
    else if (ptr) {
        memcpy(sh->buf,ptr,len);
        sh->buf[len] = '\0';
    } else {
        memset(sh->buf,0,len+1);
    }
    return o;
}",92.0,114.0,1.0,14.0,23.0,30,7,22,7,4,5,2,2,0,1,,0,5,4,2,2,robj
3559,227775,createStringObject,1,createStringObject,"robj createStringObject (char*,size_t)",object.c,"robj *createStringObject(const char *ptr, size_t len) {
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return createRawStringObject(ptr,len);
}",123.0,128.0,1.0,15.0,6.0,1,1,3,2,22,1,2,2,0,1,,0,0,4,2,2,robj
3560,227798,tryCreateRawStringObject,1,tryCreateRawStringObject,"robj tryCreateRawStringObject (char*,size_t)",object.c,"robj *tryCreateRawStringObject(const char *ptr, size_t len) {
    sds str = sdstrynewlen(ptr,len);
    if (!str) return NULL;
    return createObject(OBJ_STRING, str);
}",131.0,135.0,1.0,24.0,5.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,robj
3561,227822,tryCreateStringObject,1,tryCreateStringObject,"robj tryCreateStringObject (char*,size_t)",object.c,"robj *tryCreateStringObject(const char *ptr, size_t len) {
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return tryCreateRawStringObject(ptr,len);
}",138.0,143.0,1.0,15.0,6.0,1,1,3,2,0,1,2,2,0,1,,0,0,4,2,2,robj
3562,227845,createStringObjectFromLongLongWithOptions,1,createStringObjectFromLongLongWithOptions,"robj createStringObjectFromLongLongWithOptions (long long,int)",object.c,"robj *createStringObjectFromLongLongWithOptions(long long value, int flag) {
    robj *o;

    if (value >= 0 && value < OBJ_SHARED_INTEGERS && flag == LL2STROBJ_AUTO) {
        o = shared.integers[value];
    } else {
        if ((value >= LONG_MIN && value <= LONG_MAX) && flag != LL2STROBJ_NO_INT_ENC) {
            o = createObject(OBJ_STRING, NULL);
            o->encoding = OBJ_ENCODING_INT;
            o->ptr = (void*)((long)value);
        } else {
            char buf[LONG_STR_SIZE];
            int len = ll2string(buf, sizeof(buf), value);
            o = createStringObject(buf, len);
        }
    }
    return o;
}",149.0,166.0,1.0,30.0,18.0,8,7,7,4,3,0,2,2,0,0,,0,0,4,2,2,robj
3563,227934,createStringObjectFromLongLong,1,createStringObjectFromLongLong,robj createStringObjectFromLongLong (long long),object.c,"robj *createStringObjectFromLongLong(long long value) {
    return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_AUTO);
}",170.0,172.0,1.0,60.0,3.0,0,0,1,1,8,1,1,1,0,1,,0,0,2,1,1,robj
3564,227945,createStringObjectFromLongLongForValue,1,createStringObjectFromLongLongForValue,robj createStringObjectFromLongLongForValue (long long),object.c,"robj *createStringObjectFromLongLongForValue(long long value) {
    if (server.maxmemory == 0 || !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) {
        /* If the maxmemory policy permits, we can still return shared integers */
        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_AUTO);
    } else {
        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_NO_SHARED);
    }
}",179.0,186.0,1.0,61.0,8.0,9,7,3,2,0,1,2,2,0,1,,0,0,2,1,1,robj
3565,227986,createStringObjectFromLongLongWithSds,1,createStringObjectFromLongLongWithSds,robj createStringObjectFromLongLongWithSds (long long),object.c,"robj *createStringObjectFromLongLongWithSds(long long value) {
    return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_NO_INT_ENC);
}",190.0,192.0,1.0,60.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,robj
3566,227997,createStringObjectFromLongDouble,1,createStringObjectFromLongDouble,"robj createStringObjectFromLongDouble (long double,int)",object.c,"robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    int len = ld2string(buf,sizeof(buf),value,humanfriendly? LD_STR_HUMAN: LD_STR_AUTO);
    return createStringObject(buf,len);
}",200.0,204.0,1.0,13.0,5.0,3,3,9,6,1,2,1,1,0,2,,0,1,4,2,2,robj
3567,228020,dupStringObject,1,dupStringObject,robj dupStringObject (robj*),object.c,"robj *dupStringObject(const robj *o) {
    robj *d;

    serverAssert(o->type == OBJ_STRING);

    switch(o->encoding) {
    case OBJ_ENCODING_RAW:
        return createRawStringObject(o->ptr,sdslen(o->ptr));
    case OBJ_ENCODING_EMBSTR:
        return createEmbeddedStringObject(o->ptr,sdslen(o->ptr));
    case OBJ_ENCODING_INT:
        d = createObject(OBJ_STRING, NULL);
        d->encoding = OBJ_ENCODING_INT;
        d->ptr = o->ptr;
        return d;
    default:
        serverPanic(""Wrong encoding."");
        break;
    }
}",214.0,233.0,1.0,4.0,20.0,18,7,12,3,2,7,3,2,0,7,,0,3,2,1,1,robj
3568,228112,createQuicklistObject,1,createQuicklistObject,robj createQuicklistObject (void),object.c,"robj *createQuicklistObject(void) {
    quicklist *l = quicklistCreate();
    robj *o = createObject(OBJ_LIST,l);
    o->encoding = OBJ_ENCODING_QUICKLIST;
    return o;
}",235.0,240.0,1.0,27.0,6.0,4,2,5,2,0,2,1,1,0,2,,0,2,2,1,1,robj
3569,228138,createListListpackObject,1,createListListpackObject,robj createListListpackObject (void),object.c,"robj *createListListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_LIST,lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",242.0,247.0,1.0,27.0,6.0,4,2,5,2,3,2,1,1,0,2,,0,2,2,1,1,robj
3570,228165,createSetObject,1,createSetObject,robj createSetObject (void),object.c,"robj *createSetObject(void) {
    dict *d = dictCreate(&setDictType);
    robj *o = createObject(OBJ_SET,d);
    o->encoding = OBJ_ENCODING_HT;
    return o;
}",249.0,254.0,1.0,27.0,6.0,5,3,6,3,0,2,1,1,0,2,,0,2,2,1,1,robj
3571,228193,createIntsetObject,1,createIntsetObject,robj createIntsetObject (void),object.c,"robj *createIntsetObject(void) {
    intset *is = intsetNew();
    robj *o = createObject(OBJ_SET,is);
    o->encoding = OBJ_ENCODING_INTSET;
    return o;
}",256.0,261.0,1.0,27.0,6.0,4,2,5,2,1,2,1,1,0,2,,0,2,2,1,1,robj
3572,228219,createSetListpackObject,1,createSetListpackObject,robj createSetListpackObject (void),object.c,"robj *createSetListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_SET, lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",263.0,268.0,1.0,27.0,6.0,4,2,5,2,0,2,1,1,0,2,,0,2,2,1,1,robj
3573,228246,createHashObject,1,createHashObject,robj createHashObject (void),object.c,"robj *createHashObject(void) {
    unsigned char *zl = lpNew(0);
    robj *o = createObject(OBJ_HASH, zl);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",270.0,275.0,1.0,27.0,6.0,4,2,5,2,1,2,1,1,0,2,,0,2,2,1,1,robj
3574,228273,createZsetObject,1,createZsetObject,robj createZsetObject (void),object.c,"robj *createZsetObject(void) {
    zset *zs = zmalloc(sizeof(*zs));
    robj *o;

    zs->dict = dictCreate(&zsetDictType);
    zs->zsl = zslCreate();
    o = createObject(OBJ_ZSET,zs);
    o->encoding = OBJ_ENCODING_SKIPLIST;
    return o;
}",277.0,286.0,1.0,21.0,10.0,11,5,9,3,2,6,1,1,0,4,,0,6,2,1,1,robj
3575,228314,createZsetListpackObject,1,createZsetListpackObject,robj createZsetListpackObject (void),object.c,"robj *createZsetListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_ZSET,lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",288.0,293.0,1.0,27.0,6.0,4,2,5,2,2,2,1,1,0,2,,0,2,2,1,1,robj
3576,228341,createStreamObject,1,createStreamObject,robj createStreamObject (void),object.c,"robj *createStreamObject(void) {
    stream *s = streamNew();
    robj *o = createObject(OBJ_STREAM,s);
    o->encoding = OBJ_ENCODING_STREAM;
    return o;
}",295.0,300.0,1.0,27.0,6.0,4,2,5,2,2,2,1,1,0,2,,0,2,2,1,1,robj
3577,228367,createModuleObject,1,createModuleObject,"robj createModuleObject (moduleType*,void*)",object.c,"robj *createModuleObject(moduleType *mt, void *value) {
    moduleValue *mv = zmalloc(sizeof(*mv));
    mv->type = mt;
    mv->value = value;
    return createObject(OBJ_MODULE,mv);
}",302.0,307.0,1.0,24.0,6.0,7,4,7,3,2,4,1,1,0,2,,0,3,4,2,2,robj
3578,228396,freeStringObject,1,freeStringObject,void freeStringObject (robj*),object.c,"void freeStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        sdsfree(o->ptr);
    }
}",309.0,313.0,1.0,23.0,5.0,3,2,2,1,1,1,2,2,0,1,,0,0,2,1,1,void
3579,228414,freeListObject,1,freeListObject,void freeListObject (robj*),object.c,"void freeListObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistRelease(o->ptr);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        lpFree(o->ptr);
    } else {
        serverPanic(""Unknown list encoding type"");
    }
}",315.0,323.0,1.0,23.0,9.0,3,2,2,1,1,1,2,2,0,1,,0,0,2,1,1,void
3580,228457,freeSetObject,1,freeSetObject,void freeSetObject (robj*),object.c,"void freeSetObject(robj *o) {
    switch (o->encoding) {
    case OBJ_ENCODING_HT:
        dictRelease((dict*) o->ptr);
        break;
    case OBJ_ENCODING_INTSET:
    case OBJ_ENCODING_LISTPACK:
        zfree(o->ptr);
        break;
    default:
        serverPanic(""Unknown set encoding type"");
    }
}",325.0,337.0,1.0,9.0,13.0,5,3,3,1,2,3,4,2,0,3,,0,0,2,1,1,void
3581,228500,freeZsetObject,1,freeZsetObject,void freeZsetObject (robj*),object.c,"void freeZsetObject(robj *o) {
    zset *zs;
    switch (o->encoding) {
    case OBJ_ENCODING_SKIPLIST:
        zs = o->ptr;
        dictRelease(zs->dict);
        zslFree(zs->zsl);
        zfree(zs);
        break;
    case OBJ_ENCODING_LISTPACK:
        zfree(o->ptr);
        break;
    default:
        serverPanic(""Unknown sorted set encoding"");
    }
}",339.0,354.0,1.0,9.0,16.0,7,3,7,2,1,7,4,2,0,5,,0,2,2,1,1,void
3582,228549,freeHashObject,1,freeHashObject,void freeHashObject (robj*),object.c,"void freeHashObject(robj *o) {
    switch (o->encoding) {
    case OBJ_ENCODING_HT:
        dictRelease((dict*) o->ptr);
        break;
    case OBJ_ENCODING_LISTPACK:
        lpFree(o->ptr);
        break;
    default:
        serverPanic(""Unknown hash encoding type"");
        break;
    }
}",356.0,368.0,1.0,9.0,13.0,5,3,3,1,1,3,5,2,0,3,,0,0,2,1,1,void
3583,228589,freeModuleObject,1,freeModuleObject,void freeModuleObject (robj*),object.c,"void freeModuleObject(robj *o) {
    moduleValue *mv = o->ptr;
    mv->type->free(mv->value);
    zfree(mv);
}",370.0,374.0,1.0,1.0,5.0,5,2,5,2,1,3,1,1,0,1,,0,2,2,1,1,void
3584,228611,freeStreamObject,1,freeStreamObject,void freeStreamObject (robj*),object.c,"void freeStreamObject(robj *o) {
    freeStream(o->ptr);
}",376.0,378.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
3585,228620,incrRefCount,1,incrRefCount,void incrRefCount (robj*),object.c,"void incrRefCount(robj *o) {
    if (o->refcount < OBJ_FIRST_SPECIAL_REFCOUNT) {
        o->refcount++;
    } else {
        if (o->refcount == OBJ_SHARED_REFCOUNT) {
            /* Nothing to do: this refcount is immutable. */
        } else if (o->refcount == OBJ_STATIC_REFCOUNT) {
            serverPanic(""You tried to retain an object allocated in the stack"");
        }
    }
}",380.0,390.0,1.0,22.0,11.0,5,4,3,2,40,0,2,2,0,0,,0,0,2,1,1,void
3586,228672,decrRefCount,1,decrRefCount,void decrRefCount (robj*),object.c,"void decrRefCount(robj *o) {
    if (o->refcount == 1) {
        switch(o->type) {
        case OBJ_STRING: freeStringObject(o); break;
        case OBJ_LIST: freeListObject(o); break;
        case OBJ_SET: freeSetObject(o); break;
        case OBJ_ZSET: freeZsetObject(o); break;
        case OBJ_HASH: freeHashObject(o); break;
        case OBJ_MODULE: freeModuleObject(o); break;
        case OBJ_STREAM: freeStreamObject(o); break;
        default: serverPanic(""Unknown object type""); break;
        }
        zfree(o);
    } else {
        if (o->refcount <= 0) serverPanic(""decrRefCount against refcount <= 0"");
        if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
    }
}",392.0,409.0,1.0,13.0,18.0,4,3,10,1,109,9,11,4,0,9,,0,0,2,1,1,void
3587,228780,dismissSds,1,dismissSds,void dismissSds (sds),object.c,"void dismissSds(sds s) {
    dismissMemory(sdsAllocPtr(s), sdsAllocSize(s));
}",412.0,414.0,1.0,1.0,3.0,0,0,2,1,5,3,1,1,0,3,,0,2,2,1,1,void
3588,228790,dismissStringObject,1,dismissStringObject,void dismissStringObject (robj*),object.c,"void dismissStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        dismissSds(o->ptr);
    }
}",417.0,421.0,1.0,23.0,5.0,3,2,2,1,0,1,2,2,0,1,,0,0,2,1,1,void
3589,228808,dismissListObject,1,dismissListObject,"void dismissListObject (robj*,size_t)",object.c,"void dismissListObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        serverAssert(ql->len != 0);
        /* We iterate all nodes only when average node size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / ql->len >= server.page_size) {
            quicklistNode *node = ql->head;
            while (node) {
                if (quicklistNodeIsCompressed(node)) {
                    dismissMemory(node->entry, ((quicklistLZF*)node->entry)->sz);
                } else {
                    dismissMemory(node->entry, node->sz);
                }
                node = node->next;
            }
        }
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        dismissMemory(o->ptr, lpBytes((unsigned char*)o->ptr));
    } else {
        serverPanic(""Unknown list encoding type"");
    }
}",424.0,446.0,1.0,23.0,23.0,24,11,16,5,0,9,5,11,2,2,,0,7,4,2,2,void
3590,228933,dismissSetObject,1,dismissSetObject,"void dismissSetObject (robj*,size_t)",object.c,"void dismissSetObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *set = o->ptr;
        serverAssert(dictSize(set) != 0);
        /* We iterate all nodes only when average member size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / dictSize(set) >= server.page_size) {
            dictEntry *de;
            dictIterator *di = dictGetIterator(set);
            while ((de = dictNext(di)) != NULL) {
                dismissSds(dictGetKey(de));
            }
            dictReleaseIterator(di);
        }

        /* Dismiss hash table memory. */
        dismissMemory(set->ht_table[0], DICTHT_SIZE(set->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(set->ht_table[1], DICTHT_SIZE(set->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_INTSET) {
        dismissMemory(o->ptr, intsetBlobLen((intset*)o->ptr));
    } else if (o->encoding =...",449.0,474.0,1.0,23.0,26.0,55,17,27,8,0,20,4,7,3,8,,0,15,4,2,2,void
3591,229143,dismissZsetObject,1,dismissZsetObject,"void dismissZsetObject (robj*,size_t)",object.c,"void dismissZsetObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = o->ptr;
        zskiplist *zsl = zs->zsl;
        serverAssert(zsl->length != 0);
        /* We iterate all nodes only when average member size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / zsl->length >= server.page_size) {
            zskiplistNode *zn = zsl->tail;
            while (zn != NULL) {
                dismissSds(zn->ele);
                zn = zn->backward;
            }
        }

        /* Dismiss hash table memory. */
        dict *d = zs->dict;
        dismissMemory(d->ht_table[0], DICTHT_SIZE(d->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(d->ht_table[1], DICTHT_SIZE(d->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        dismissMemory(o->ptr, lpBytes((unsigned char*)o->ptr));
    } else {
        serverPanic...",477.0,501.0,1.0,23.0,25.0,54,16,28,9,0,19,4,7,1,4,,0,15,4,2,2,void
3592,229326,dismissHashObject,1,dismissHashObject,"void dismissHashObject (robj*,size_t)",object.c,"void dismissHashObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *d = o->ptr;
        serverAssert(dictSize(d) != 0);
        /* We iterate all fields only when average field/value size is bigger than
         * a page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / dictSize(d) >= server.page_size) {
            dictEntry *de;
            dictIterator *di = dictGetIterator(d);
            while ((de = dictNext(di)) != NULL) {
                /* Only dismiss values memory since the field size
                 * usually is small. */
                dismissSds(dictGetVal(de));
            }
            dictReleaseIterator(di);
        }

        /* Dismiss hash table memory. */
        dismissMemory(d->ht_table[0], DICTHT_SIZE(d->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(d->ht_table[1], DICTHT_SIZE(d->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_LIS...",504.0,529.0,1.0,23.0,26.0,55,17,27,8,0,20,4,7,3,8,,0,15,4,2,2,void
3593,229515,dismissStreamObject,1,dismissStreamObject,"void dismissStreamObject (robj*,size_t)",object.c,"void dismissStreamObject(robj *o, size_t size_hint) {
    stream *s = o->ptr;
    rax *rax = s->rax;
    if (raxSize(rax) == 0) return;

    /* Iterate only on stream entries, although size_hint may include serialized
     * consumer groups info, but usually, stream entries take up most of
     * the space. */
    if (size_hint / raxSize(rax) >= server.page_size) {
        raxIterator ri;
        raxStart(&ri,rax);
        raxSeek(&ri,""^"",NULL,0);
        while (raxNext(&ri)) {
            dismissMemory(ri.data, lpBytes(ri.data));
        }
        raxStop(&ri);
    }
}",532.0,549.0,1.0,1.0,18.0,14,7,16,7,0,11,4,5,3,8,,0,7,4,2,2,void
3594,229577,dismissObject,1,dismissObject,"void dismissObject (robj*,size_t)",object.c,"void dismissObject(robj *o, size_t size_hint) {
    /* madvise(MADV_DONTNEED) may not work if Transparent Huge Pages is enabled. */
    if (server.thp_enabled) return;

    /* Currently we use zmadvise_dontneed only when we use jemalloc with Linux.
     * so we avoid these pointless loops when they're not going to do anything. */
#if defined(USE_JEMALLOC) && defined(__linux__)
    if (o->refcount != 1) return;
    switch(o->type) {
        case OBJ_STRING: dismissStringObject(o); break;
        case OBJ_LIST: dismissListObject(o, size_hint); break;
        case OBJ_SET: dismissSetObject(o, size_hint); break;
        case OBJ_ZSET: dismissZsetObject(o, size_hint); break;
        case OBJ_HASH: dismissHashObject(o, size_hint); break;
        case OBJ_STREAM: dismissStreamObject(o, size_hint); break;
        default: break;
    }
#else
    UNUSED(o); UNUSED(size_hint);
#endif
}",564.0,584.0,1.0,4.0,21.0,3,2,5,3,3,0,2,2,0,0,,0,0,4,2,2,void
3595,229601,decrRefCountVoid,1,decrRefCountVoid,void decrRefCountVoid (void*),object.c,"void decrRefCountVoid(void *o) {
    decrRefCount(o);
}",589.0,591.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3596,229608,checkType,1,checkType,"int checkType (client*,robj*,int)",object.c,"int checkType(client *c, robj *o, int type) {
    /* A NULL is considered an empty key */
    if (o && o->type != type) {
        addReplyErrorObject(c,shared.wrongtypeerr);
        return 1;
    }
    return 0;
}",593.0,600.0,1.0,1.0,8.0,4,4,5,4,29,1,2,2,0,1,,0,0,6,3,3,int
3597,229633,isSdsRepresentableAsLongLong,1,isSdsRepresentableAsLongLong,"int isSdsRepresentableAsLongLong (sds,long long*)",object.c,"int isSdsRepresentableAsLongLong(sds s, long long *llval) {
    return string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;
}",602.0,604.0,1.0,42.0,3.0,2,2,3,2,0,2,1,1,0,2,,0,1,4,2,2,int
3598,229653,isObjectRepresentableAsLongLong,1,isObjectRepresentableAsLongLong,"int isObjectRepresentableAsLongLong (robj*,long long*)",object.c,"int isObjectRepresentableAsLongLong(robj *o, long long *llval) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    if (o->encoding == OBJ_ENCODING_INT) {
        if (llval) *llval = (long) o->ptr;
        return C_OK;
    } else {
        return isSdsRepresentableAsLongLong(o->ptr,llval);
    }
}",606.0,614.0,1.0,4.0,9.0,12,8,9,3,0,1,3,4,0,1,,0,0,4,2,2,int
3599,229713,trimStringObjectIfNeeded,1,trimStringObjectIfNeeded,"void trimStringObjectIfNeeded (robj*,int)",object.c,"void trimStringObjectIfNeeded(robj *o, int trim_small_values) {
    if (o->encoding != OBJ_ENCODING_RAW) return;
    /* A string may have free space in the following cases:
     * 1. When an arg len is greater than PROTO_MBULK_BIG_ARG the query buffer may be used directly as the SDS string.
     * 2. When utilizing the argument caching mechanism in Lua. 
     * 3. When calling from RM_TrimStringAllocation (trim_small_values is true). */
    size_t len = sdslen(o->ptr);
    if (len >= PROTO_MBULK_BIG_ARG ||
        trim_small_values||
        (server.executing_client && server.executing_client->flags & CLIENT_SCRIPT && len < LUA_CMD_OBJCACHE_MAX_LEN)) {
        if (sdsavail(o->ptr) > len/10) {
            o->ptr = sdsRemoveFreeSpace(o->ptr, 0);
        }
    }
}",618.0,632.0,1.0,23.0,15.0,22,13,12,4,3,3,4,5,1,3,,0,3,4,2,2,void
3600,229788,tryObjectEncodingEx,1,tryObjectEncodingEx,"robj tryObjectEncodingEx (robj*,int)",object.c,"robj *tryObjectEncodingEx(robj *o, int try_trim) {
    long value;
    sds s = o->ptr;
    size_t len;

    /* Make sure this is a string object, the only type we encode
     * in this function. Other types use encoded memory efficient
     * representations but are handled by the commands implementing
     * the type. */
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);

    /* We try some specialized encoding only for objects that are
     * RAW or EMBSTR encoded, in other words objects that are still
     * in represented by an actually array of chars. */
    if (!sdsEncodedObject(o)) return o;

    /* It's not safe to encode shared objects: shared objects can be shared
     * everywhere in the ""object space"" of Redis and may end in places where
     * they are not handled. We handle them only as values in the keyspace. */
     if (o->refcount > 1) return o;

    /* Check if we can represent this string as a long integer.
     * Note that we are sure that a string larger th...",635.0,705.0,1.0,4.0,71.0,39,20,37,9,2,8,8,10,1,8,,0,4,4,2,2,robj
3601,229991,tryObjectEncoding,1,tryObjectEncoding,robj tryObjectEncoding (robj*),object.c,"robj *tryObjectEncoding(robj *o) {
    return tryObjectEncodingEx(o, 1);
}",707.0,709.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,robj
3602,230000,getDecodedObject,1,getDecodedObject,robj getDecodedObject (robj*),object.c,"robj *getDecodedObject(robj *o) {
    robj *dec;

    if (sdsEncodedObject(o)) {
        incrRefCount(o);
        return o;
    }
    if (o->type == OBJ_STRING && o->encoding == OBJ_ENCODING_INT) {
        char buf[32];

        ll2string(buf,32,(long)o->ptr);
        dec = createStringObject(buf,strlen(buf));
        return dec;
    } else {
        serverPanic(""Unknown encoding type"");
    }
}",713.0,729.0,1.0,8.0,17.0,13,6,13,3,17,3,3,3,0,3,,0,1,2,1,1,robj
3603,230070,compareStringObjectsWithFlags,1,compareStringObjectsWithFlags,"int compareStringObjectsWithFlags (robj*,robj*,int)",object.c,"int compareStringObjectsWithFlags(const robj *a, const robj *b, int flags) {
    serverAssertWithInfo(NULL,a,a->type == OBJ_STRING && b->type == OBJ_STRING);
    char bufa[128], bufb[128], *astr, *bstr;
    size_t alen, blen, minlen;

    if (a == b) return 0;
    if (sdsEncodedObject(a)) {
        astr = a->ptr;
        alen = sdslen(astr);
    } else {
        alen = ll2string(bufa,sizeof(bufa),(long) a->ptr);
        astr = bufa;
    }
    if (sdsEncodedObject(b)) {
        bstr = b->ptr;
        blen = sdslen(bstr);
    } else {
        blen = ll2string(bufb,sizeof(bufb),(long) b->ptr);
        bstr = bufb;
    }
    if (flags & REDIS_COMPARE_COLL) {
        return strcoll(astr,bstr);
    } else {
        int cmp;

        minlen = (alen < blen) ? alen : blen;
        cmp = memcmp(astr,bstr,minlen);
        if (cmp == 0) return alen-blen;
        return cmp;
    }
}",742.0,772.0,1.0,4.0,31.0,28,11,25,8,2,3,5,5,0,3,,0,2,6,3,3,int
3604,230242,compareStringObjects,1,compareStringObjects,"int compareStringObjects (robj*,robj*)",object.c,"int compareStringObjects(const robj *a, const robj *b) {
    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_BINARY);
}",775.0,777.0,1.0,45.0,3.0,1,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
3605,230257,collateStringObjects,1,collateStringObjects,"int collateStringObjects (robj*,robj*)",object.c,"int collateStringObjects(const robj *a, const robj *b) {
    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_COLL);
}",780.0,782.0,1.0,45.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
3606,230272,equalStringObjects,1,equalStringObjects,"int equalStringObjects (robj*,robj*)",object.c,"int equalStringObjects(robj *a, robj *b) {
    if (a->encoding == OBJ_ENCODING_INT &&
        b->encoding == OBJ_ENCODING_INT){
        /* If both strings are integer encoded just check if the stored
         * long is the same. */
        return a->ptr == b->ptr;
    } else {
        return compareStringObjects(a,b) == 0;
    }
}",788.0,797.0,1.0,23.0,10.0,8,3,4,2,2,0,2,2,0,0,,0,0,4,2,2,int
3607,230311,stringObjectLen,1,stringObjectLen,size_t stringObjectLen (robj*),object.c,"size_t stringObjectLen(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    if (sdsEncodedObject(o)) {
        return sdslen(o->ptr);
    } else {
        return sdigits10((long)o->ptr);
    }
}",799.0,806.0,1.0,4.0,8.0,12,7,9,2,5,2,2,2,0,2,,0,0,2,1,1,size_t
3608,230368,getDoubleFromObject,1,getDoubleFromObject,"int getDoubleFromObject (robj*,double*)",object.c,"int getDoubleFromObject(const robj *o, double *target) {
    double value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (!string2d(o->ptr, sdslen(o->ptr), &value))
                return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    *target = value;
    return C_OK;
}",808.0,826.0,1.0,8.0,19.0,4,3,5,4,2,0,2,2,0,0,,0,0,4,2,2,int
3609,230477,getDoubleFromObjectOrReply,1,getDoubleFromObjectOrReply,"int getDoubleFromObjectOrReply (client*,robj*,double*,char*)",object.c,"int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {
    double value;
    if (getDoubleFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not a valid float"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",828.0,840.0,1.0,42.0,13.0,7,6,8,6,6,2,3,4,1,2,,0,1,8,4,4,int
3610,230524,getLongDoubleFromObject,1,getLongDoubleFromObject,"int getLongDoubleFromObject (robj*,long double*)",object.c,"int getLongDoubleFromObject(robj *o, long double *target) {
    long double value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (!string2ld(o->ptr, sdslen(o->ptr), &value))
                return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    *target = value;
    return C_OK;
}",842.0,860.0,1.0,8.0,19.0,4,3,5,4,1,0,2,2,0,0,,0,0,4,2,2,int
3611,230633,getLongDoubleFromObjectOrReply,1,getLongDoubleFromObjectOrReply,"int getLongDoubleFromObjectOrReply (client*,robj*,long double*,char*)",object.c,"int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {
    long double value;
    if (getLongDoubleFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not a valid float"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",862.0,874.0,1.0,46.0,13.0,7,6,8,6,0,2,3,4,1,2,,0,1,8,4,4,int
3612,230680,getLongLongFromObject,1,getLongLongFromObject,"int getLongLongFromObject (robj*,long long*)",object.c,"int getLongLongFromObject(robj *o, long long *target) {
    long long value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (string2ll(o->ptr,sdslen(o->ptr),&value) == 0) return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    if (target) *target = value;
    return C_OK;
}",876.0,893.0,1.0,8.0,18.0,4,3,6,4,4,0,3,3,0,0,,0,0,4,2,2,int
3613,230793,getLongLongFromObjectOrReply,1,getLongLongFromObjectOrReply,"int getLongLongFromObjectOrReply (client*,robj*,long long*,char*)",object.c,"int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {
    long long value;
    if (getLongLongFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not an integer or out of range"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",895.0,907.0,1.0,44.0,13.0,7,6,8,6,13,2,3,4,1,2,,0,1,8,4,4,int
3614,230840,getLongFromObjectOrReply,1,getLongFromObjectOrReply,"int getLongFromObjectOrReply (client*,robj*,long*,char*)",object.c,"int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
    long long value;

    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) return C_ERR;
    if (value < LONG_MIN || value > LONG_MAX) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is out of range"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",909.0,923.0,1.0,59.0,15.0,11,9,14,8,13,2,4,5,1,2,,0,1,8,4,4,int
3615,230903,getRangeLongFromObjectOrReply,1,getRangeLongFromObjectOrReply,"int getRangeLongFromObjectOrReply (client*,robj*,long,long,long*,char*)",object.c,"int getRangeLongFromObjectOrReply(client *c, robj *o, long min, long max, long *target, const char *msg) {
    if (getLongFromObjectOrReply(c, o, target, msg) != C_OK) return C_ERR;
    if (*target < min || *target > max) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyErrorFormat(c,""value is out of range, value must between %ld and %ld"", min, max);
        }
        return C_ERR;
    }
    return C_OK;
}",925.0,936.0,1.0,55.0,12.0,10,7,12,7,8,2,4,5,1,2,,0,1,12,6,6,int
3616,230966,getPositiveLongFromObjectOrReply,1,getPositiveLongFromObjectOrReply,"int getPositiveLongFromObjectOrReply (client*,robj*,long*,char*)",object.c,"int getPositiveLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
    if (msg) {
        return getRangeLongFromObjectOrReply(c, o, 0, LONG_MAX, target, msg);
    } else {
        return getRangeLongFromObjectOrReply(c, o, 0, LONG_MAX, target, ""value is out of range, must be positive"");
    }
}",938.0,944.0,1.0,1.0,7.0,0,0,6,5,3,1,2,2,0,1,,0,0,8,4,4,int
3617,230995,getIntFromObjectOrReply,1,getIntFromObjectOrReply,"int getIntFromObjectOrReply (client*,robj*,int*,char*)",object.c,"int getIntFromObjectOrReply(client *c, robj *o, int *target, const char *msg) {
    long value;

    if (getRangeLongFromObjectOrReply(c, o, INT_MIN, INT_MAX, &value, msg) != C_OK)
        return C_ERR;

    *target = value;
    return C_OK;
}",946.0,954.0,1.0,78.0,9.0,5,5,8,7,4,1,2,2,1,1,,0,1,8,4,4,int
3618,231096,streamRadixTreeMemoryUsage,1,streamRadixTreeMemoryUsage,size_t streamRadixTreeMemoryUsage (rax*),object.c,"size_t streamRadixTreeMemoryUsage(rax *rax) {
    size_t size = sizeof(*rax);
    size = rax->numele * sizeof(streamID);
    size += rax->numnodes * sizeof(raxNode);
    /* Add a fixed overhead due to the aux data pointer, children, ... */
    size += rax->numnodes * sizeof(long)*30;
    return size;
}",988.0,995.0,1.0,1.0,8.0,16,6,12,5,0,3,1,1,0,0,,0,3,2,1,1,size_t
3619,232146,freeMemoryOverheadData,1,freeMemoryOverheadData,void freeMemoryOverheadData (redisMemOverhead*),object.c,"void freeMemoryOverheadData(struct redisMemOverhead *mh) {
    zfree(mh->db);
    zfree(mh);
}",1164.0,1167.0,1.0,1.0,4.0,1,1,2,1,2,2,1,1,0,2,,0,0,2,1,1,void
3620,232157,getMemoryOverheadData,1,getMemoryOverheadData,struct redisMemOverhead getMemoryOverheadData (void),object.c,"struct redisMemOverhead *getMemoryOverheadData(void) {
    int j;
    size_t mem_total = 0;
    size_t mem = 0;
    size_t zmalloc_used = zmalloc_used_memory();
    struct redisMemOverhead *mh = zcalloc(sizeof(*mh));

    mh->total_allocated = zmalloc_used;
    mh->startup_allocated = server.initial_memory_usage;
    mh->peak_allocated = server.stat_peak_memory;
    mh->total_frag =
        (float)server.cron_malloc_stats.process_rss / server.cron_malloc_stats.zmalloc_used;
    mh->total_frag_bytes =
        server.cron_malloc_stats.process_rss - server.cron_malloc_stats.zmalloc_used;
    mh->allocator_frag =
        (float)server.cron_malloc_stats.allocator_active / server.cron_malloc_stats.allocator_allocated;
    mh->allocator_frag_bytes =
        server.cron_malloc_stats.allocator_active - server.cron_malloc_stats.allocator_allocated;
    mh->allocator_rss =
        (float)server.cron_malloc_stats.allocator_resident / server.cron_malloc_stats.allocator_active;
    mh->allocator_...",1172.0,1287.0,1.0,8.0,116.0,266,19,159,12,2,69,8,8,1,9,,0,67,2,1,1,struct redisMemOverhead
3621,232829,inputCatSds,1,inputCatSds,"void inputCatSds (void*,char*)",object.c,"void inputCatSds(void *result, const char *str) {
    /* result is actually a (sds *), so re-cast it here */
    sds *info = (sds *)result;
    *info = sdscat(*info, str);
}",1291.0,1295.0,1.0,1.0,5.0,5,3,5,3,0,1,1,1,0,1,,0,1,4,2,2,void
3622,232848,getMemoryDoctorReport,1,getMemoryDoctorReport,sds getMemoryDoctorReport (void),object.c,"sds getMemoryDoctorReport(void) {
    int empty = 0;          /* Instance is empty or almost empty. */
    int big_peak = 0;       /* Memory peak is much larger than used mem. */
    int high_frag = 0;      /* High fragmentation. */
    int high_alloc_frag = 0;/* High allocator fragmentation. */
    int high_proc_rss = 0;  /* High process rss overhead. */
    int high_alloc_rss = 0; /* High rss overhead. */
    int big_slave_buf = 0;  /* Slave buffers are too big. */
    int big_client_buf = 0; /* Client buffers are too big. */
    int many_scripts = 0;   /* Script cache has too many scripts. */
    int num_reports = 0;
    struct redisMemOverhead *mh = getMemoryOverheadData();

    if (mh->total_allocated < (1024*1024*5)) {
        empty = 1;
        num_reports++;
    } else {
        /* Peak is > 150% of current used memory? */
        if (((float)mh->peak_allocated / mh->total_allocated) > 1.5) {
            big_peak = 1;
            num_reports++;
        }

        /* Fragment...",1299.0,1409.0,1.0,25.0,111.0,19,6,18,12,0,4,3,3,1,3,,0,3,2,1,1,sds
3623,233203,objectSetLRUOrLFU,1,objectSetLRUOrLFU,"int objectSetLRUOrLFU (robj*,long long,long long,long long,int)",object.c,"int objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
                       long long lru_clock, int lru_multiplier) {
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        if (lfu_freq >= 0) {
            serverAssert(lfu_freq <= 255);
            val->lru = (LFUGetTimeInMinutes()<<8) | lfu_freq;
            return 1;
        }
    } else if (lru_idle >= 0) {
        /* Provided LRU idle time is in seconds. Scale
         * according to the LRU clock resolution this Redis
         * instance was compiled with (normally 1000 ms, so the
         * below statement will expand to lru_idle*1000/1000. */
        lru_idle = lru_idle*lru_multiplier/LRU_CLOCK_RESOLUTION;
        long lru_abs = lru_clock - lru_idle; /* Absolute access time. */
        /* If the LRU field underflows (since lru_clock is a wrapping clock),
         * we need to make it positive again. This be handled by the unwrapping
         * code in estimateObjectIdleTime. I.e. imagine a day wh...",1416.0,1442.0,1.0,34.0,27.0,13,12,5,3,3,2,3,4,0,2,,0,1,10,5,5,int
3624,233300,objectCommandLookup,1,objectCommandLookup,"robj objectCommandLookup (client*,robj*)",object.c,"robj *objectCommandLookup(client *c, robj *key) {
    return lookupKeyReadWithFlags(c->db,key,LOOKUP_NOTOUCH|LOOKUP_NONOTIFY);
}",1448.0,1450.0,1.0,44.0,3.0,4,3,2,2,1,2,1,1,0,1,,0,1,4,2,2,robj
3625,233323,objectCommandLookupOrReply,1,objectCommandLookupOrReply,"robj objectCommandLookupOrReply (client*,robj*,robj*)",object.c,"robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {
    robj *o = objectCommandLookup(c,key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",1452.0,1456.0,1.0,1.0,5.0,2,2,7,4,0,2,2,2,0,2,,0,1,6,3,3,robj
3626,233345,objectCommand,1,objectCommand,void objectCommand (client*),object.c,"void objectCommand(client *c) {
    robj *o;

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""ENCODING <key>"",
""    Return the kind of internal representation used in order to store the value"",
""    associated with a <key>."",
""FREQ <key>"",
""    Return the access frequency index of the <key>. The returned integer is"",
""    proportional to the logarithm of the recent access frequency of the key."",
""IDLETIME <key>"",
""    Return the idle time of the <key>, that is the approximated number of"",
""    seconds elapsed since the last access to the key."",
""REFCOUNT <key>"",
""    Return the number of references of the value associated with the specified"",
""    <key>."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""refcount"") && c->argc == 3) {
        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.null[c->resp]))
                == NULL) return;
        addReplyLongLong(c,o->refcount);
    } else...",1460.0,1511.0,1.0,38.0,52.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
3627,233609,memoryCommand,1,memoryCommand,void memoryCommand (client*),object.c,"void memoryCommand(client *c) {
    if (!strcasecmp(c->argv[1]->ptr,""help"") && c->argc == 2) {
        const char *help[] = {
""DOCTOR"",
""    Return memory problems reports."",
""MALLOC-STATS"",
""    Return internal statistics report from the memory allocator."",
""PURGE"",
""    Attempt to purge dirty pages for reclamation by the allocator."",
""STATS"",
""    Return information about the memory usage of the server."",
""USAGE <key> [SAMPLES <count>]"",
""    Return memory in bytes used by <key> and its value. Nested values are"",
""    sampled up to <count> times (default: 5, 0 means sample all)."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""usage"") && c->argc >= 3) {
        dictEntry *de;
        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;
        for (int j = 3; j < c->argc; j++) {
            if (!strcasecmp(c->argv[j]->ptr,""samples"") &&
                j+1 < c->argc)
            {
                if (getLongLongFromObjectOrReply(c,c->argv[j+...",1517.0,1688.0,1.0,28.0,172.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
3628,234272,med3,1,med3,"char* med3 (char*,char*,char*,int)",pqsort.c,"static inline char *
med3(char *a, char *b, char *c,
    int (*cmp) (const void *, const void *))
{

	return cmp(a, b) < 0 ?
	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
}",88.0,96.0,1.0,1.0,9.0,0,0,0,0,4,0,1,1,0,0,,0,0,8,4,4,char*
3629,234280,swapfunc,1,swapfunc,"void swapfunc (char*,char*,ANY,int)",pqsort.c,"static inline void
swapfunc(char *a, char *b, size_t n, int swaptype)
{

	if (swaptype <= 1)
		swapcode(long, a, b, n)
	else
		swapcode(char, a, b, n)
}",68.0,76.0,1.0,2.0,9.0,0,0,0,0,6,0,1,1,0,0,,0,0,8,4,4,void
3630,234438,_pqsort,1,_pqsort,"void _pqsort (void*,size_t,size_t,int,void*,void*)",pqsort.c,"static void
_pqsort(void *a, size_t n, size_t es,
    int (*cmp) (const void *, const void *), void *lrange, void *rrange)
{
	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
	size_t d, r;
	int swaptype, cmp_result;

loop:	SWAPINIT(a, es);
	if (n < 7) {
		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
			     pl -= es)
				swap(pl, pl - es);
		return;
	}
	pm = (char *) a + (n / 2) * es;
	if (n > 7) {
		pl = (char *) a;
		pn = (char *) a + (n - 1) * es;
		if (n > 40) {
			d = (n / 8) * es;
			pl = med3(pl, pl + d, pl + 2 * d, cmp);
			pm = med3(pm - d, pm, pm + d, cmp);
			pn = med3(pn - 2 * d, pn - d, pn, cmp);
		}
		pm = med3(pl, pm, pn, cmp);
	}
	swap(a, pm);
	pa = pb = (char *) a + es;

	pc = pd = (char *) a + (n - 1) * es;
	for (;;) {
		while (pb <= pc && (cmp_result = cmp(pb, a)) <= 0) {
			if (cmp_result == 0) {
				swap(pa, pb);
				pa += es;
			}
			pb += es;
		}
		while (pb <= pc && (cmp_result = cmp(pc, a)) >...",98.0,177.0,1.0,6.0,80.0,202,20,232,25,1,10,17,26,0,10,,0,4,12,6,6,void
3631,235138,pqsort,1,pqsort,"void pqsort (void*,size_t,size_t,int,size_t,size_t)",pqsort.c,"void
pqsort(void *a, size_t n, size_t es,
    int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
{
    _pqsort(a,n,es,cmp,((unsigned char*)a)+(lrange*es),
                       ((unsigned char*)a)+((rrange+1)*es)-1);
}",179.0,185.0,1.0,1.0,7.0,8,4,10,6,1,1,1,1,0,1,,0,0,12,6,6,void
3632,235197,clientPubSubChannels,1,pubsubtype.clientPubSubChannels,dict* pubsubtype.clientPubSubChannels (client*),pubsub.c,dict *(*clientPubSubChannels)(client*);,37.0,37.0,10.0,42.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,dict*
3633,235202,subscriptionCount,1,pubsubtype.subscriptionCount,int pubsubtype.subscriptionCount (client*),pubsub.c,int (*subscriptionCount)(client*);,38.0,38.0,9.0,37.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
3634,235212,clientSubscriptionsCount,1,clientSubscriptionsCount,int clientSubscriptionsCount (client*),pubsub.c,"int clientSubscriptionsCount(client *c) {
    return dictSize(c->pubsub_channels) + dictSize(c->pubsub_patterns);
}",221.0,223.0,1.0,11.0,3.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
3635,235217,clientShardSubscriptionsCount,1,clientShardSubscriptionsCount,int clientShardSubscriptionsCount (client*),pubsub.c,"int clientShardSubscriptionsCount(client *c) {
    return dictSize(c->pubsubshard_channels);
}",226.0,228.0,1.0,11.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3636,235327,addReplyPubsubMessage,1,addReplyPubsubMessage,"void addReplyPubsubMessage (client*,robj*,robj*,robj*)",pubsub.c,"void addReplyPubsubMessage(client *c, robj *channel, robj *msg, robj *message_bulk) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,message_bulk);
    addReplyBulk(c,channel);
    if (msg) addReplyBulk(c,msg);
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",107.0,118.0,1.0,16.0,12.0,14,9,15,6,1,8,4,4,1,4,,0,4,8,4,4,void
3637,235401,addReplyPubsubPatMessage,1,addReplyPubsubPatMessage,"void addReplyPubsubPatMessage (client*,robj*,robj*,robj*)",pubsub.c,"void addReplyPubsubPatMessage(client *c, robj *pat, robj *channel, robj *msg) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[4]);
    else
        addReplyPushLen(c,4);
    addReply(c,shared.pmessagebulk);
    addReplyBulk(c,pat);
    addReplyBulk(c,channel);
    addReplyBulk(c,msg);
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",123.0,135.0,1.0,16.0,13.0,15,9,16,6,1,9,3,3,1,5,,0,4,8,4,4,void
3638,235477,addReplyPubsubSubscribed,1,addReplyPubsubSubscribed,"void addReplyPubsubSubscribed (client*,robj*,pubsubtype)",pubsub.c,"void addReplyPubsubSubscribed(client *c, robj *channel, pubsubtype type) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,*type.subscribeMsg);
    addReplyBulk(c,channel);
    addReplyLongLong(c,type.subscriptionCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",138.0,149.0,1.0,16.0,12.0,17,10,15,5,1,10,3,3,1,5,,0,6,6,3,3,void
3639,235554,addReplyPubsubUnsubscribed,1,addReplyPubsubUnsubscribed,"void addReplyPubsubUnsubscribed (client*,robj*,pubsubtype)",pubsub.c,"void addReplyPubsubUnsubscribed(client *c, robj *channel, pubsubtype type) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c, *type.unsubscribeMsg);
    if (channel)
        addReplyBulk(c,channel);
    else
        addReplyNull(c);
    addReplyLongLong(c,type.subscriptionCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",155.0,169.0,1.0,16.0,15.0,17,10,16,5,3,10,4,4,1,5,,0,6,6,3,3,void
3640,235638,addReplyPubsubPatSubscribed,1,addReplyPubsubPatSubscribed,"void addReplyPubsubPatSubscribed (client*,robj*)",pubsub.c,"void addReplyPubsubPatSubscribed(client *c, robj *pattern) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,shared.psubscribebulk);
    addReplyBulk(c,pattern);
    addReplyLongLong(c,clientSubscriptionsCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",172.0,183.0,1.0,16.0,12.0,15,9,14,4,1,9,3,3,1,5,,0,5,4,2,2,void
3641,235710,addReplyPubsubPatUnsubscribed,1,addReplyPubsubPatUnsubscribed,"void addReplyPubsubPatUnsubscribed (client*,robj*)",pubsub.c,"void addReplyPubsubPatUnsubscribed(client *c, robj *pattern) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,shared.punsubscribebulk);
    if (pattern)
        addReplyBulk(c,pattern);
    else
        addReplyNull(c);
    addReplyLongLong(c,clientSubscriptionsCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",189.0,203.0,1.0,16.0,15.0,15,9,15,4,2,9,4,4,1,5,,0,5,4,2,2,void
3642,235953,clientTotalPubSubSubscriptionCount,1,clientTotalPubSubSubscriptionCount,int clientTotalPubSubSubscriptionCount (client*),pubsub.c,"int clientTotalPubSubSubscriptionCount(client *c) {
    return clientSubscriptionsCount(c) + clientShardSubscriptionsCount(c);
}",240.0,242.0,1.0,1.0,3.0,1,1,2,1,4,2,1,1,0,2,,0,0,2,1,1,int
3643,235964,pubsubSubscribeChannel,1,pubsubSubscribeChannel,"int pubsubSubscribeChannel (client*,robj*,pubsubtype)",pubsub.c,"int pubsubSubscribeChannel(client *c, robj *channel, pubsubtype type) {
    dictEntry *de;
    list *clients = NULL;
    int retval = 0;

    /* Add the channel to the client -> channels hash table */
    if (dictAdd(type.clientPubSubChannels(c),channel,NULL) == DICT_OK) {
        retval = 1;
        incrRefCount(channel);
        /* Add the client to the channel -> list of clients hash table */
        de = dictFind(*type.serverPubSubChannels, channel);
        if (de == NULL) {
            clients = listCreate();
            dictAdd(*type.serverPubSubChannels, channel, clients);
            incrRefCount(channel);
        } else {
            clients = dictGetVal(de);
        }
        listAddNodeTail(clients,c);
    }
    /* Notify the client */
    addReplyPubsubSubscribed(c,channel,type);
    return retval;
}",246.0,269.0,1.0,62.0,24.0,12,4,25,7,1,11,3,4,2,9,,0,6,6,3,3,int
3644,236039,pubsubUnsubscribeChannel,1,pubsubUnsubscribeChannel,"int pubsubUnsubscribeChannel (client*,robj*,int,pubsubtype)",pubsub.c,"int pubsubUnsubscribeChannel(client *c, robj *channel, int notify, pubsubtype type) {
    dictEntry *de;
    list *clients;
    listNode *ln;
    int retval = 0;

    /* Remove the channel from the client -> channels hash table */
    incrRefCount(channel); /* channel may be just a pointer to the same object
                            we have in the hash tables. Protect it... */
    if (dictDelete(type.clientPubSubChannels(c),channel) == DICT_OK) {
        retval = 1;
        /* Remove the client from the channel -> clients list hash table */
        de = dictFind(*type.serverPubSubChannels, channel);
        serverAssertWithInfo(c,NULL,de != NULL);
        clients = dictGetVal(de);
        ln = listSearchKey(clients,c);
        serverAssertWithInfo(c,NULL,ln != NULL);
        listDelNode(clients,ln);
        if (listLength(clients) == 0) {
            /* Free the list and associated hash entry at all if this was
             * the latest client, so that it will be possible to abus...",273.0,309.0,1.0,60.0,37.0,27,11,41,10,1,17,5,8,4,13,,0,9,8,4,4,int
3645,236172,pubsubShardUnsubscribeAllClients,1,pubsubShardUnsubscribeAllClients,void pubsubShardUnsubscribeAllClients (robj*),pubsub.c,"void pubsubShardUnsubscribeAllClients(robj *channel) {
    int retval;
    dictEntry *de = dictFind(server.pubsubshard_channels, channel);
    serverAssertWithInfo(NULL,channel,de != NULL);
    list *clients = dictGetVal(de);
    if (listLength(clients) > 0) {
        /* For each client subscribed to the channel, unsubscribe it. */
        listIter li;
        listNode *ln;
        listRewind(clients, &li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = listNodeValue(ln);
            retval = dictDelete(c->pubsubshard_channels, channel);
            serverAssertWithInfo(c,channel,retval == DICT_OK);
            addReplyPubsubUnsubscribed(c, channel, pubSubShardType);
            /* If the client has no other pubsub subscription,
             * move out of pubsub mode. */
            if (clientTotalPubSubSubscriptionCount(c) == 0) {
                c->flags &= ~CLIENT_PUBSUB;
            }
        }
    }
    /* Delete the channel from server pubsubshard chann...",311.0,339.0,1.0,4.0,29.0,35,13,44,10,1,18,4,7,3,13,,0,11,2,1,1,void
3646,236325,pubsubSubscribePattern,1,pubsubSubscribePattern,"int pubsubSubscribePattern (client*,robj*)",pubsub.c,"int pubsubSubscribePattern(client *c, robj *pattern) {
    dictEntry *de;
    list *clients;
    int retval = 0;

    if (dictAdd(c->pubsub_patterns, pattern, NULL) == DICT_OK) {
        retval = 1;
        incrRefCount(pattern);
        /* Add the client to the pattern -> list of clients hash table */
        de = dictFind(server.pubsub_patterns,pattern);
        if (de == NULL) {
            clients = listCreate();
            dictAdd(server.pubsub_patterns,pattern,clients);
            incrRefCount(pattern);
        } else {
            clients = dictGetVal(de);
        }
        listAddNodeTail(clients,c);
    }
    /* Notify the client */
    addReplyPubsubPatSubscribed(c,pattern);
    return retval;
}",343.0,365.0,1.0,54.0,23.0,9,4,21,7,0,9,3,4,2,8,,0,4,4,2,2,int
3647,236391,pubsubUnsubscribePattern,1,pubsubUnsubscribePattern,"int pubsubUnsubscribePattern (client*,robj*,int)",pubsub.c,"int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
    dictEntry *de;
    list *clients;
    listNode *ln;
    int retval = 0;

    incrRefCount(pattern); /* Protect the object. May be the same we remove */
    if (dictDelete(c->pubsub_patterns, pattern) == DICT_OK) {
        retval = 1;
        /* Remove the client from the pattern -> clients list hash table */
        de = dictFind(server.pubsub_patterns,pattern);
        serverAssertWithInfo(c,NULL,de != NULL);
        clients = dictGetVal(de);
        ln = listSearchKey(clients,c);
        serverAssertWithInfo(c,NULL,ln != NULL);
        listDelNode(clients,ln);
        if (listLength(clients) == 0) {
            /* Free the list and associated hash entry at all if this was
             * the latest client. */
            dictDelete(server.pubsub_patterns,pattern);
        }
    }
    /* Notify the client */
    if (notify) addReplyPubsubPatUnsubscribed(c,pattern);
    decrRefCount(pattern);
    return retval;
}",369.0,395.0,1.0,51.0,27.0,21,9,36,9,1,13,4,5,3,11,,0,6,6,3,3,int
3648,236505,pubsubUnsubscribeAllChannelsInternal,1,pubsubUnsubscribeAllChannelsInternal,"int pubsubUnsubscribeAllChannelsInternal (client*,int,pubsubtype)",pubsub.c,"int pubsubUnsubscribeAllChannelsInternal(client *c, int notify, pubsubtype type) {
    int count = 0;
    if (dictSize(type.clientPubSubChannels(c)) > 0) {
        dictIterator *di = dictGetSafeIterator(type.clientPubSubChannels(c));
        dictEntry *de;

        while((de = dictNext(di)) != NULL) {
            robj *channel = dictGetKey(de);

            count += pubsubUnsubscribeChannel(c,channel,notify,type);
        }
        dictReleaseIterator(di);
    }
    /* We were subscribed to nothing? Still reply to the client. */
    if (notify && count == 0) {
        addReplyPubsubUnsubscribed(c,NULL,type);
    }
    return count;
}",399.0,417.0,1.0,8.0,19.0,18,10,27,8,2,7,4,5,1,7,,0,4,6,3,3,int
3649,236591,pubsubUnsubscribeAllChannels,1,pubsubUnsubscribeAllChannels,"int pubsubUnsubscribeAllChannels (client*,int)",pubsub.c,"int pubsubUnsubscribeAllChannels(client *c, int notify) {
    int count = pubsubUnsubscribeAllChannelsInternal(c,notify,pubSubType);
    return count;
}",422.0,425.0,1.0,1.0,4.0,1,1,5,4,3,2,1,1,0,1,,0,2,4,2,2,int
3650,236606,pubsubUnsubscribeShardAllChannels,1,pubsubUnsubscribeShardAllChannels,"int pubsubUnsubscribeShardAllChannels (client*,int)",pubsub.c,"int pubsubUnsubscribeShardAllChannels(client *c, int notify) {
    int count = pubsubUnsubscribeAllChannelsInternal(c, notify, pubSubShardType);
    return count;
}",430.0,433.0,1.0,1.0,4.0,1,1,5,4,3,2,1,1,0,1,,0,2,4,2,2,int
3651,236621,pubsubUnsubscribeShardChannels,1,pubsubUnsubscribeShardChannels,"void pubsubUnsubscribeShardChannels (robj**,unsigned int)",pubsub.c,"void pubsubUnsubscribeShardChannels(robj **channels, unsigned int count) {
    for (unsigned int j = 0; j < count; j++) {
        /* Remove the channel from server and from the clients
         * subscribed to it as well as notify them. */
        pubsubShardUnsubscribeAllClients(channels[j]);
    }
}",438.0,444.0,1.0,1.0,7.0,3,3,5,3,0,1,2,2,0,1,,0,0,4,2,2,void
3652,236643,pubsubUnsubscribeAllPatterns,1,pubsubUnsubscribeAllPatterns,"int pubsubUnsubscribeAllPatterns (client*,int)",pubsub.c,"int pubsubUnsubscribeAllPatterns(client *c, int notify) {
    int count = 0;

    if (dictSize(c->pubsub_patterns) > 0) {
        dictIterator *di = dictGetSafeIterator(c->pubsub_patterns);
        dictEntry *de;

        while ((de = dictNext(di)) != NULL) {
            robj *pattern = dictGetKey(de);
            count += pubsubUnsubscribePattern(c, pattern, notify);
        }
        dictReleaseIterator(di);
    }

    /* We were subscribed to nothing? Still reply to the client. */
    if (notify && count == 0) addReplyPubsubPatUnsubscribed(c,NULL);
    return count;
}",448.0,465.0,1.0,8.0,18.0,18,9,21,7,3,10,4,5,4,6,,0,7,4,2,2,int
3653,236718,pubsubPublishMessageInternal,1,pubsubPublishMessageInternal,"int pubsubPublishMessageInternal (robj*,robj*,pubsubtype)",pubsub.c,"int pubsubPublishMessageInternal(robj *channel, robj *message, pubsubtype type) {
    int receivers = 0;
    dictEntry *de;
    dictIterator *di;
    listNode *ln;
    listIter li;

    /* Send to clients listening for that channel */
    de = dictFind(*type.serverPubSubChannels, channel);
    if (de) {
        list *list = dictGetVal(de);
        listNode *ln;
        listIter li;

        listRewind(list,&li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = ln->value;
            addReplyPubsubMessage(c,channel,message,*type.messageBulk);
            updateClientMemUsageAndBucket(c);
            receivers++;
        }
    }

    if (type.shard) {
        /* Shard pubsub ignores patterns. */
        return receivers;
    }

    /* Send to clients listening to matching channels */
    di = dictGetIterator(server.pubsub_patterns);
    if (di) {
        channel = getDecodedObject(channel);
        while((de = dictNext(di)) != NULL) {
            robj *pattern = ...",470.0,522.0,1.0,28.0,53.0,36,9,55,14,1,25,9,14,7,20,,0,17,6,3,3,int
3654,236881,pubsubPublishMessage,1,pubsubPublishMessage,"int pubsubPublishMessage (robj*,robj*,int)",pubsub.c,"int pubsubPublishMessage(robj *channel, robj *message, int sharded) {
    return pubsubPublishMessageInternal(channel, message, sharded? pubSubShardType : pubSubType);
}",525.0,527.0,1.0,1.0,3.0,1,1,5,5,3,3,1,1,0,1,,0,2,6,3,3,int
3655,236896,subscribeCommand,1,subscribeCommand,void subscribeCommand (client*),pubsub.c,"void subscribeCommand(client *c) {
    int j;
    if ((c->flags & CLIENT_DENY_BLOCKING) && !(c->flags & CLIENT_MULTI)) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe.
         *
         * Notice that we have a special treatment for multi because of
         * backward compatibility
         */
        addReplyError(c, ""SUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }
    for (j = 1; j < c->argc; j++)
        pubsubSubscribeChannel(c,c->argv[j],pubSubType);
    c->flags |= CLIENT_PUBSUB;
}",534.0,550.0,1.0,20.0,17.0,13,7,7,2,0,5,3,3,3,1,,0,4,2,1,1,void
3656,236957,unsubscribeCommand,1,unsubscribeCommand,void unsubscribeCommand (client*),pubsub.c,"void unsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeAllChannels(c,1);
    } else {
        int j;

        for (j = 1; j < c->argc; j++)
            pubsubUnsubscribeChannel(c,c->argv[j],1,pubSubType);
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",553.0,563.0,1.0,65.0,11.0,6,4,4,1,0,4,3,3,2,2,,0,3,2,1,1,void
3657,237012,psubscribeCommand,1,psubscribeCommand,void psubscribeCommand (client*),pubsub.c,"void psubscribeCommand(client *c) {
    int j;
    if ((c->flags & CLIENT_DENY_BLOCKING) && !(c->flags & CLIENT_MULTI)) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe.
         *
         * Notice that we have a special treatment for multi because of
         * backward compatibility
         */
        addReplyError(c, ""PSUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }

    for (j = 1; j < c->argc; j++)
        pubsubSubscribePattern(c,c->argv[j]);
    c->flags |= CLIENT_PUBSUB;
}",566.0,583.0,1.0,20.0,18.0,13,7,7,2,0,5,3,3,3,1,,0,4,2,1,1,void
3658,237072,punsubscribeCommand,1,punsubscribeCommand,void punsubscribeCommand (client*),pubsub.c,"void punsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeAllPatterns(c,1);
    } else {
        int j;

        for (j = 1; j < c->argc; j++)
            pubsubUnsubscribePattern(c,c->argv[j],1);
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",586.0,596.0,1.0,65.0,11.0,6,4,4,1,0,4,3,3,2,2,,0,3,2,1,1,void
3659,237126,pubsubPublishMessageAndPropagateToCluster,1,pubsubPublishMessageAndPropagateToCluster,"int pubsubPublishMessageAndPropagateToCluster (robj*,robj*,int)",pubsub.c,"int pubsubPublishMessageAndPropagateToCluster(robj *channel, robj *message, int sharded) {
    int receivers = pubsubPublishMessage(channel, message, sharded);
    if (server.cluster_enabled)
        clusterPropagatePublish(channel, message, sharded);
    return receivers;
}",600.0,605.0,1.0,1.0,6.0,2,2,9,5,4,2,2,2,0,2,,0,1,6,3,3,int
3660,237151,publishCommand,1,publishCommand,void publishCommand (client*),pubsub.c,"void publishCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelPublishCommand(c);
        return;
    }

    int receivers = pubsubPublishMessageAndPropagateToCluster(c->argv[1],c->argv[2],0);
    if (!server.cluster_enabled)
        forceCommandPropagation(c,PROPAGATE_REPL);
    addReplyLongLong(c,receivers);
}",608.0,618.0,1.0,34.0,11.0,8,5,9,3,0,6,3,3,0,4,,0,3,2,1,1,void
3661,237193,pubsubCommand,1,pubsubCommand,void pubsubCommand (client*),pubsub.c,"void pubsubCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CHANNELS [<pattern>]"",
""    Return the currently active channels matching a <pattern> (default: '*')."",
""NUMPAT"",
""    Return number of subscriptions to patterns."",
""NUMSUB [<channel> ...]"",
""    Return the number of subscribers for the specified channels, excluding"",
""    pattern subscriptions(default: no channels)."",
""SHARDCHANNELS [<pattern>]"",
""    Return the currently active shard level channels matching a <pattern> (default: '*')."",
""SHARDNUMSUB [<shardchannel> ...]"",
""    Return the number of subscribers for the specified shard level channel(s)"",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""channels"") &&
        (c->argc == 2 || c->argc == 3))
    {
        /* PUBSUB CHANNELS [<pattern>] */
        sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;
        channelList(c, pat, server.pubsub_channels);
    }...",621.0,678.0,1.0,35.0,58.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
3662,237590,spublishCommand,1,spublishCommand,void spublishCommand (client*),pubsub.c,"void spublishCommand(client *c) {
    int receivers = pubsubPublishMessageAndPropagateToCluster(c->argv[1],c->argv[2],1);
    if (!server.cluster_enabled)
        forceCommandPropagation(c,PROPAGATE_REPL);
    addReplyLongLong(c,receivers);
}",703.0,708.0,1.0,34.0,6.0,7,5,7,3,0,5,2,2,0,3,,0,3,2,1,1,void
3663,237624,ssubscribeCommand,1,ssubscribeCommand,void ssubscribeCommand (client*),pubsub.c,"void ssubscribeCommand(client *c) {
    if (c->flags & CLIENT_DENY_BLOCKING) {
        /* A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe. */
        addReplyError(c, ""SSUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }

    for (int j = 1; j < c->argc; j++) {
        /* A channel is only considered to be added, if a
         * subscriber exists for it. And if a subscriber
         * already exists the slotToChannel doesn't needs
         * to be incremented. */
        if (server.cluster_enabled &
            (dictFind(*pubSubShardType.serverPubSubChannels, c->argv[j]) == NULL)) {
            slotToChannelAdd(c->argv[j]->ptr);
        }
        pubsubSubscribeChannel(c, c->argv[j], pubSubShardType);
    }
    c->flags |= CLIENT_PUBSUB;
}",711.0,731.0,1.0,19.0,21.0,20,9,17,5,0,13,4,5,6,4,,0,10,2,1,1,void
3664,237701,sunsubscribeCommand,1,sunsubscribeCommand,void sunsubscribeCommand (client*),pubsub.c,"void sunsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeShardAllChannels(c, 1);
    } else {
        for (int j = 1; j < c->argc; j++) {
            pubsubUnsubscribeChannel(c, c->argv[j], 1, pubSubShardType);
        }
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",735.0,744.0,1.0,65.0,10.0,6,4,4,1,0,4,3,3,2,2,,0,3,2,1,1,void
3665,237757,pubsubMemOverhead,1,pubsubMemOverhead,size_t pubsubMemOverhead (client*),pubsub.c,"size_t pubsubMemOverhead(client *c) {
    /* PubSub patterns */
    size_t mem = dictMemUsage(c->pubsub_patterns);
    /* Global PubSub channels */
    mem += dictMemUsage(c->pubsub_channels);
    /* Sharded PubSub channels */
    mem += dictMemUsage(c->pubsubshard_channels);
    return mem;
}",746.0,754.0,1.0,1.0,9.0,6,3,7,2,1,6,1,1,0,3,,0,4,2,1,1,size_t
3666,237831,quicklistisSetPackedThreshold,1,quicklistisSetPackedThreshold,int quicklistisSetPackedThreshold (size_t),quicklist.c,"int quicklistisSetPackedThreshold(size_t sz) {
    /* Don't allow threshold to be set above or even slightly below 4GB */
    if (sz > (1ull<<32) - (1<<20)) {
        return 0;
    } else if (sz == 0) { /* 0 means restore threshold */
        sz = (1 << 30);
    }
    packed_threshold = sz;
    return 1;
}",57.0,66.0,1.0,1.0,10.0,5,4,3,2,0,1,2,2,0,0,,0,1,2,1,1,int
3667,237866,_quicklistBookmarkFindByName,1,_quicklistBookmarkFindByName,"quicklistBookmark* _quicklistBookmarkFindByName (quicklist*,char*)",quicklist.c,"quicklistBookmark *_quicklistBookmarkFindByName(quicklist *ql, const char *name) {
    unsigned i;
    for (i=0; i<ql->bookmark_count; i++) {
        if (!strcmp(ql->bookmarks[i].name, name)) {
            return &ql->bookmarks[i];
        }
    }
    return NULL;
}",1698.0,1706.0,1.0,1.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,quicklistBookmark
3668,237872,_quicklistBookmarkFindByNode,1,_quicklistBookmarkFindByNode,"quicklistBookmark* _quicklistBookmarkFindByNode (quicklist*,quicklistNode*)",quicklist.c,"quicklistBookmark *_quicklistBookmarkFindByNode(quicklist *ql, quicklistNode *node) {
    unsigned i;
    for (i=0; i<ql->bookmark_count; i++) {
        if (ql->bookmarks[i].node == node) {
            return &ql->bookmarks[i];
        }
    }
    return NULL;
}",1708.0,1716.0,1.0,1.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,quicklistBookmark
3669,237878,_quicklistBookmarkDelete,1,_quicklistBookmarkDelete,"void _quicklistBookmarkDelete (quicklist*,quicklistBookmark*)",quicklist.c,"void _quicklistBookmarkDelete(quicklist *ql, quicklistBookmark *bm) {
    int index = bm - ql->bookmarks;
    zfree(bm->name);
    ql->bookmark_count--;
    memmove(bm, bm+1, (ql->bookmark_count - index)* sizeof(*bm));
    /* NOTE: We do not shrink (realloc) the quicklist yet (to avoid resonance,
     * it may be re-used later (a call to realloc may NOP). */
}",1718.0,1725.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
3670,237884,quicklistCreate,1,quicklistCreate,quicklist quicklistCreate (void),quicklist.c,"quicklist *quicklistCreate(void) {
    struct quicklist *quicklist;

    quicklist = zmalloc(sizeof(*quicklist));
    quicklist->head = quicklist->tail = NULL;
    quicklist->len = 0;
    quicklist->count = 0;
    quicklist->compress = 0;
    quicklist->fill = -2;
    quicklist->bookmark_count = 0;
    return quicklist;
}",128.0,139.0,1.0,1.0,12.0,18,5,11,2,3,8,1,1,0,1,,0,8,2,1,1,quicklist
3671,237933,quicklistSetCompressDepth,1,quicklistSetCompressDepth,"void quicklistSetCompressDepth (quicklist*,int)",quicklist.c,"void quicklistSetCompressDepth(quicklist *quicklist, int compress) {
    if (compress > COMPRESS_MAX) {
        compress = COMPRESS_MAX;
    } else if (compress < 0) {
        compress = 0;
    }
    quicklist->compress = compress;
}",142.0,149.0,1.0,19.0,8.0,8,5,6,3,1,1,2,2,0,0,,0,1,4,2,2,void
3672,237974,quicklistSetFill,1,quicklistSetFill,"void quicklistSetFill (quicklist*,int)",quicklist.c,"void quicklistSetFill(quicklist *quicklist, int fill) {
    if (fill > FILL_MAX) {
        fill = FILL_MAX;
    } else if (fill < -5) {
        fill = -5;
    }
    quicklist->fill = fill;
}",152.0,159.0,1.0,15.0,8.0,10,5,6,3,1,1,2,2,0,0,,0,1,4,2,2,void
3673,238021,quicklistSetOptions,1,quicklistSetOptions,"void quicklistSetOptions (quicklist*,int,int)",quicklist.c,"void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
    quicklistSetFill(quicklist, fill);
    quicklistSetCompressDepth(quicklist, depth);
}",161.0,164.0,1.0,1.0,4.0,0,0,4,3,2,2,1,1,0,2,,0,0,6,3,3,void
3674,238034,quicklistNew,1,quicklistNew,"quicklist quicklistNew (int,int)",quicklist.c,"quicklist *quicklistNew(int fill, int compress) {
    quicklist *quicklist = quicklistCreate();
    quicklistSetOptions(quicklist, fill, compress);
    return quicklist;
}",167.0,171.0,1.0,1.0,5.0,1,1,5,3,1,2,1,1,0,2,,0,1,4,2,2,quicklist
3675,238050,quicklistCreateNode,1,quicklistCreateNode,quicklistNode quicklistCreateNode (void),quicklist.c,"REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
    quicklistNode *node;
    node = zmalloc(sizeof(*node));
    node->entry = NULL;
    node->count = 0;
    node->sz = 0;
    node->next = node->prev = NULL;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    node->container = QUICKLIST_NODE_CONTAINER_PACKED;
    node->recompress = 0;
    node->dont_compress = 0;
    return node;
}",173.0,185.0,1.0,12.0,13.0,21,4,14,2,6,10,1,1,0,1,,0,10,2,1,1,quicklistNode
3676,238112,quicklistCount,1,quicklistCount,unsigned long quicklistCount (quicklist*),quicklist.c,unsigned long quicklistCount(const quicklist *ql) { return ql->count; },188.0,188.0,1.0,71.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned long
3677,238121,quicklistRelease,1,quicklistRelease,void quicklistRelease (quicklist*),quicklist.c,"void quicklistRelease(quicklist *quicklist) {
    unsigned long len;
    quicklistNode *current, *next;

    current = quicklist->head;
    len = quicklist->len;
    while (len--) {
        next = current->next;

        zfree(current->entry);
        quicklist->count -= current->count;

        zfree(current);

        quicklist->len--;
        current = next;
    }
    quicklistBookmarksClear(quicklist);
    zfree(quicklist);
}",191.0,210.0,1.0,1.0,20.0,14,4,16,4,2,11,2,2,0,4,,0,7,2,1,1,void
3678,238172,__quicklistCompressNode,1,__quicklistCompressNode,int __quicklistCompressNode (quicklistNode*),quicklist.c,"REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
#ifdef REDIS_TEST
    node->attempted_compress = 1;
#endif
    if (node->dont_compress) return 0;

    /* validate that the node is neither
     * tail nor head (it has prev and next)*/
    assert(node->prev && node->next);

    node->recompress = 0;
    /* Don't bother compressing small values */
    if (node->sz < MIN_COMPRESS_BYTES)
        return 0;

    quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);

    /* Cancel if compression fails or doesn't compress small enough */
    if (((lzf->sz = lzf_compress(node->entry, node->sz, lzf->compressed,
                                 node->sz)) == 0) ||
        lzf->sz + MIN_COMPRESS_IMPROVE >= node->sz) {
        /* lzf_compress aborts/rejects compression if value not compressible. */
        zfree(lzf);
        return 0;
    }
    lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
    zfree(node->entry);
    node->entry = (unsigned char *)lzf;
    node->encoding = QUICKLI...",215.0,245.0,1.0,12.0,31.0,40,14,24,2,10,23,4,4,10,6,,0,20,2,1,1,int
3679,238299,__quicklistDecompressNode,1,__quicklistDecompressNode,int __quicklistDecompressNode (quicklistNode*),quicklist.c,"REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
#ifdef REDIS_TEST
    node->attempted_compress = 0;
#endif
    node->recompress = 0;

    void *decompressed = zmalloc(node->sz);
    quicklistLZF *lzf = (quicklistLZF *)node->entry;
    if (lzf_decompress(lzf->compressed, lzf->sz, decompressed, node->sz) == 0) {
        /* Someone requested decompress, but we can't decompress.  Not good. */
        zfree(decompressed);
        return 0;
    }
    zfree(lzf);
    node->entry = decompressed;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    return 1;
}",257.0,274.0,1.0,12.0,18.0,15,4,14,3,7,12,2,2,4,4,,0,10,2,1,1,int
3680,238359,quicklistGetLzf,1,quicklistGetLzf,"size_t quicklistGetLzf (quicklistNode*,void**)",quicklist.c,"size_t quicklistGetLzf(const quicklistNode *node, void **data) {
    quicklistLZF *lzf = (quicklistLZF *)node->entry;
    *data = lzf->compressed;
    return lzf->sz;
}",296.0,300.0,1.0,1.0,5.0,7,4,5,3,0,3,1,1,0,0,,0,3,4,2,2,size_t
3681,238383,__quicklistCompress,1,__quicklistCompress,"void __quicklistCompress (quicklist*,quicklistNode*)",quicklist.c,"REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,
                                      quicklistNode *node) {
    if (quicklist->len == 0) return;

    /* The head and tail should never be compressed (we should not attempt to recompress them) */
    assert(quicklist->head->recompress == 0 && quicklist->tail->recompress == 0);

    /* If length is less than our compress depth (from both sides),
     * we can't compress anything. */
    if (!quicklistAllowsCompression(quicklist) ||
        quicklist->len < (unsigned int)(quicklist->compress * 2))
        return;

#if 0
    /* Optimized cases for small depth counts */
    if (quicklist->compress == 1) {
        quicklistNode *h = quicklist->head, *t = quicklist->tail;
        quicklistDecompressNode(h);
        quicklistDecompressNode(t);
        if (h != node && t != node)
            quicklistCompressNode(node);
        return;
    } else if (quicklist->compress == 2) {
        quicklistNode *h = quicklist->head, *hn...",308.0,379.0,1.0,12.0,72.0,59,14,49,6,6,23,7,9,6,6,,0,17,4,2,2,void
3682,238600,__quicklistInsertNode,1,__quicklistInsertNode,"void __quicklistInsertNode (quicklist*,quicklistNode*,quicklistNode*,int)",quicklist.c,"REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
                                        quicklistNode *old_node,
                                        quicklistNode *new_node, int after) {
    if (after) {
        new_node->prev = old_node;
        if (old_node) {
            new_node->next = old_node->next;
            if (old_node->next)
                old_node->next->prev = new_node;
            old_node->next = new_node;
        }
        if (quicklist->tail == old_node)
            quicklist->tail = new_node;
    } else {
        new_node->next = old_node;
        if (old_node) {
            new_node->prev = old_node->prev;
            if (old_node->prev)
                old_node->prev->next = new_node;
            old_node->prev = new_node;
        }
        if (quicklist->head == old_node)
            quicklist->head = new_node;
    }
    /* If this insert creates the only element so far, initialize head/tail. */
    if (quicklist->len == 0) {
        quickli...",400.0,436.0,1.0,12.0,37.0,31,5,37,4,4,20,7,11,3,4,,0,16,8,4,4,void
3683,238786,_quicklistInsertNodeBefore,1,_quicklistInsertNodeBefore,"void _quicklistInsertNodeBefore (quicklist*,quicklistNode*,quicklistNode*)",quicklist.c,"REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
                                             quicklistNode *old_node,
                                             quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 0);
}",439.0,443.0,1.0,12.0,5.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
3684,238798,_quicklistInsertNodeAfter,1,_quicklistInsertNodeAfter,"void _quicklistInsertNodeAfter (quicklist*,quicklistNode*,quicklistNode*)",quicklist.c,"REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
                                            quicklistNode *old_node,
                                            quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 1);
}",445.0,449.0,1.0,12.0,5.0,0,0,3,3,3,1,1,1,0,1,,0,0,6,3,3,void
3685,238810,quicklistNodeLimit,1,quicklistNodeLimit,"void quicklistNodeLimit (int,size_t*,unsigned int*)",quicklist.c,"void quicklistNodeLimit(int fill, size_t *size, unsigned int *count) {
    *size = SIZE_MAX;
    *count = UINT_MAX;

    if (fill >= 0) {
        /* Ensure that one node have at least one entry */
        *count = (fill == 0) ? 1 : fill;
    } else {
        size_t offset = (-fill) - 1;
        size_t max_level = sizeof(optimization_level) / sizeof(*optimization_level);
        if (offset >= max_level) offset = max_level - 1;
        *size = optimization_level[offset];
    }
}",455.0,468.0,1.0,1.0,14.0,9,5,8,5,2,0,2,2,0,0,,0,0,6,3,3,void
3686,238873,quicklistNodeExceedsLimit,1,quicklistNodeExceedsLimit,"int quicklistNodeExceedsLimit (int,size_t,unsigned int)",quicklist.c,"int quicklistNodeExceedsLimit(int fill, size_t new_sz, unsigned int new_count) {
    size_t sz_limit;
    unsigned int count_limit;
    quicklistNodeLimit(fill, &sz_limit, &count_limit);

    if (likely(sz_limit != SIZE_MAX)) {
        return new_sz > sz_limit;
    } else if (count_limit != UINT_MAX) {
        /* when we reach here we know that the limit is a size limit (which is
         * safe, see comments next to optimization_level and SIZE_SAFETY_LIMIT) */
        if (!sizeMeetsSafetyLimit(new_sz)) return 1;
        return new_count > count_limit;
    }

    redis_unreachable();
}",474.0,489.0,1.0,8.0,16.0,4,3,7,5,3,1,2,2,0,1,,0,0,6,3,3,int
3687,238924,_quicklistNodeAllowInsert,1,_quicklistNodeAllowInsert,"int _quicklistNodeAllowInsert (quicklistNode*,int,size_t)",quicklist.c,"REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
                                           const int fill, const size_t sz) {
    if (unlikely(!node))
        return 0;

    if (unlikely(QL_NODE_IS_PLAIN(node) || isLargeElement(sz)))
        return 0;

    /* Estimate how many bytes will be added to the listpack by this one entry.
     * We prefer an overestimation, which would at worse lead to a few bytes
     * below the lowest limit of 4k (see optimization_level).
     * Note: No need to check for overflow below since both `node->sz` and
     * `sz` are to be less than 1GB after the plain/large element check above. */
    size_t new_sz = node->sz + sz + SIZE_ESTIMATE_OVERHEAD;
    if (unlikely(quicklistNodeExceedsLimit(fill, new_sz, node->count + 1)))
        return 0;
    return 1;
}",491.0,508.0,1.0,12.0,18.0,12,7,11,5,5,5,4,4,4,1,,0,5,6,3,3,int
3688,238984,_quicklistNodeAllowMerge,1,_quicklistNodeAllowMerge,"int _quicklistNodeAllowMerge (quicklistNode*,quicklistNode*,int)",quicklist.c,"REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,
                                          const quicklistNode *b,
                                          const int fill) {
    if (!a || !b)
        return 0;

    if (unlikely(QL_NODE_IS_PLAIN(a) || QL_NODE_IS_PLAIN(b)))
        return 0;

    /* approximate merged listpack size (- 7 to remove one listpack
     * header/trailer, see LP_HDR_SIZE and LP_EOF) */
    unsigned int merge_sz = a->sz + b->sz - 7;
    if (unlikely(quicklistNodeExceedsLimit(fill, merge_sz, a->count + b->count)))
        return 0;
    return 1;
}",510.0,525.0,1.0,12.0,16.0,16,7,11,4,4,7,4,4,5,1,,0,7,6,3,3,int
3689,239047,__quicklistCreatePlainNode,1,__quicklistCreatePlainNode,"quicklistNode __quicklistCreatePlainNode (void*,size_t)",quicklist.c,"static quicklistNode* __quicklistCreatePlainNode(void *value, size_t sz) {
    quicklistNode *new_node = quicklistCreateNode();
    new_node->entry = zmalloc(sz);
    new_node->container = QUICKLIST_NODE_CONTAINER_PLAIN;
    memcpy(new_node->entry, value, sz);
    new_node->sz = sz;
    new_node->count++;
    return new_node;
}",532.0,540.0,1.0,26.0,9.0,10,3,11,3,1,7,1,1,0,2,,0,7,4,2,2,quicklistNode
3690,239087,__quicklistInsertPlainNode,1,__quicklistInsertPlainNode,"void __quicklistInsertPlainNode (quicklist*,quicklistNode*,void*,size_t,int)",quicklist.c,"static void __quicklistInsertPlainNode(quicklist *quicklist, quicklistNode *old_node,
                                       void *value, size_t sz, int after) {
    __quicklistInsertNode(quicklist, old_node, __quicklistCreatePlainNode(value, sz), after);
    quicklist->count++;
}",542.0,546.0,1.0,1.0,5.0,2,2,6,5,4,3,1,1,0,2,,0,2,10,5,5,void
3691,239107,quicklistPushHead,1,quicklistPushHead,"int quicklistPushHead (quicklist*,void*,size_t)",quicklist.c,"int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_head = quicklist->head;

    if (unlikely(isLargeElement(sz))) {
        __quicklistInsertPlainNode(quicklist, quicklist->head, value, sz, 0);
        return 1;
    }

    if (likely(
            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {
        quicklist->head->entry = lpPrepend(quicklist->head->entry, value, sz);
        quicklistNodeUpdateSz(quicklist->head);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node->entry = lpPrepend(lpNew(0), value, sz);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);
    }
    quicklist->count++;
    quicklist->head->count++;
    return (orig_head != quicklist->head);
}",552.0,574.0,1.0,8.0,23.0,24,5,22,5,2,17,3,3,4,4,,0,16,6,3,3,int
3692,239234,quicklistPushTail,1,quicklistPushTail,"int quicklistPushTail (quicklist*,void*,size_t)",quicklist.c,"int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_tail = quicklist->tail;
    if (unlikely(isLargeElement(sz))) {
        __quicklistInsertPlainNode(quicklist, quicklist->tail, value, sz, 1);
        return 1;
    }

    if (likely(
            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {
        quicklist->tail->entry = lpAppend(quicklist->tail->entry, value, sz);
        quicklistNodeUpdateSz(quicklist->tail);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node->entry = lpAppend(lpNew(0), value, sz);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    }
    quicklist->count++;
    quicklist->tail->count++;
    return (orig_tail != quicklist->tail);
}",580.0,601.0,1.0,8.0,22.0,24,5,22,5,1,17,3,3,4,4,,0,16,6,3,3,int
3693,239361,quicklistAppendListpack,1,quicklistAppendListpack,"void quicklistAppendListpack (quicklist*,unsigned char*)",quicklist.c,"void quicklistAppendListpack(quicklist *quicklist, unsigned char *zl) {
    quicklistNode *node = quicklistCreateNode();

    node->entry = zl;
    node->count = lpLength(node->entry);
    node->sz = lpBytes(zl);

    _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    quicklist->count += node->count;
}",606.0,615.0,1.0,1.0,10.0,12,3,12,3,1,11,1,1,0,4,,0,10,4,2,2,void
3694,239403,quicklistAppendPlainNode,1,quicklistAppendPlainNode,"void quicklistAppendPlainNode (quicklist*,unsigned char*,size_t)",quicklist.c,"void quicklistAppendPlainNode(quicklist *quicklist, unsigned char *data, size_t sz) {
    quicklistNode *node = quicklistCreateNode();

    node->entry = data;
    node->count = 1;
    node->sz = sz;
    node->container = QUICKLIST_NODE_CONTAINER_PLAIN;

    _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    quicklist->count += node->count;
}",621.0,631.0,1.0,22.0,11.0,13,3,12,4,0,9,1,1,0,2,,0,8,6,3,3,void
3695,239449,__quicklistDelNode,1,__quicklistDelNode,"void __quicklistDelNode (quicklist*,quicklistNode*)",quicklist.c,"REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
                                     quicklistNode *node) {
    /* Update the bookmark if any */
    quicklistBookmark *bm = _quicklistBookmarkFindByNode(quicklist, node);
    if (bm) {
        bm->node = node->next;
        /* if the bookmark was to the last node, delete it. */
        if (!bm->node)
            _quicklistBookmarkDelete(quicklist, bm);
    }

    if (node->next)
        node->next->prev = node->prev;
    if (node->prev)
        node->prev->next = node->next;

    if (node == quicklist->tail) {
        quicklist->tail = node->prev;
    }

    if (node == quicklist->head) {
        quicklist->head = node->next;
    }

    /* Update len first, so in __quicklistCompress we know exactly len */
    quicklist->len--;
    quicklist->count -= node->count;

    /* If we deleted a node within our compress depth, we
     * now have compressed nodes needing to be decompressed. */
    __quicklistCompress(quicklist, NULL)...",641.0,675.0,1.0,12.0,35.0,32,6,30,4,4,24,7,8,5,5,,0,20,4,2,2,void
3696,239556,quicklistDelIndex,1,quicklistDelIndex,"int quicklistDelIndex (quicklist*,quicklistNode*,unsigned char**)",quicklist.c,"REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
                                   unsigned char **p) {
    int gone = 0;

    if (unlikely(QL_NODE_IS_PLAIN(node))) {
        __quicklistDelNode(quicklist, node);
        return 1;
    }
    node->entry = lpDelete(node->entry, *p, p);
    node->count--;
    if (node->count == 0) {
        gone = 1;
        __quicklistDelNode(quicklist, node);
    } else {
        quicklistNodeUpdateSz(node);
    }
    quicklist->count--;
    /* If we deleted the node, the original node is no longer valid */
    return gone ? 1 : 0;
}",685.0,704.0,1.0,12.0,20.0,15,6,15,4,4,9,3,3,2,3,,0,7,6,3,3,int
3697,239634,quicklistDelEntry,1,quicklistDelEntry,"void quicklistDelEntry (quicklistIter*,quicklistEntry*)",quicklist.c,"void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
    quicklistNode *prev = entry->node->prev;
    quicklistNode *next = entry->node->next;
    int deleted_node = quicklistDelIndex((quicklist *)entry->quicklist,
                                         entry->node, &entry->zi);

    /* after delete, the zi is now invalid for any future usage. */
    iter->zi = NULL;

    /* If current node is deleted, we must update iterator node and offset. */
    if (deleted_node) {
        if (iter->direction == AL_START_HEAD) {
            iter->current = next;
            iter->offset = 0;
        } else if (iter->direction == AL_START_TAIL) {
            iter->current = prev;
            iter->offset = -1;
        }
    }
    /* else if (!deleted_node), no changes needed.
     * we already reset iter->zi above, and the existing iter->offset
     * doesn't move again because:
     *   - [1, 2, 3] => delete offset 1 => [1, 3]: next element still offset 1
     *   - [1, 2, 3] =...",710.0,737.0,1.0,31.0,28.0,20,5,15,6,0,10,3,4,1,1,,0,10,4,2,2,void
3698,239721,quicklistReplaceEntry,1,quicklistReplaceEntry,"void quicklistReplaceEntry (quicklistIter*,quicklistEntry*,void*,size_t)",quicklist.c,"void quicklistReplaceEntry(quicklistIter *iter, quicklistEntry *entry,
                           void *data, size_t sz)
{
    quicklist* quicklist = iter->quicklist;

    if (likely(!QL_NODE_IS_PLAIN(entry->node) && !isLargeElement(sz))) {
        entry->node->entry = lpReplace(entry->node->entry, &entry->zi, data, sz);
        quicklistNodeUpdateSz(entry->node);
        /* quicklistNext() and quicklistGetIteratorEntryAtIdx() provide an uncompressed node */
        quicklistCompress(quicklist, entry->node);
    } else if (QL_NODE_IS_PLAIN(entry->node)) {
        if (isLargeElement(sz)) {
            zfree(entry->node->entry);
            entry->node->entry = zmalloc(sz);
            entry->node->sz = sz;
            memcpy(entry->node->entry, data, sz);
            quicklistCompress(quicklist, entry->node);
        } else {
            quicklistInsertAfter(iter, entry, data, sz);
            __quicklistDelNode(quicklist, entry->node);
        }
    } else {
        entry->node->don...",740.0,778.0,1.0,8.0,39.0,36,7,26,7,1,21,2,2,2,4,,0,19,8,4,4,void
3699,240110,quicklistReplaceAtIndex,1,quicklistReplaceAtIndex,"int quicklistReplaceAtIndex (quicklist*,long,void*,size_t)",quicklist.c,"int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,
                            size_t sz) {
    quicklistEntry entry;
    quicklistIter *iter = quicklistGetIteratorEntryAtIdx(quicklist, index, &entry);
    if (likely(iter)) {
        quicklistReplaceEntry(iter, &entry, data, sz);
        quicklistReleaseIterator(iter);
        return 1;
    } else {
        return 0;
    }
}",784.0,795.0,1.0,8.0,12.0,3,2,11,6,1,3,2,2,0,3,,0,1,8,4,4,int
3700,240147,_quicklistListpackMerge,1,_quicklistListpackMerge,"quicklistNode _quicklistListpackMerge (quicklist*,quicklistNode*,quicklistNode*)",quicklist.c,"REDIS_STATIC quicklistNode *_quicklistListpackMerge(quicklist *quicklist,
                                                    quicklistNode *a,
                                                    quicklistNode *b) {
    D(""Requested merge (a,b) (%u, %u)"", a->count, b->count);

    quicklistDecompressNode(a);
    quicklistDecompressNode(b);
    if ((lpMerge(&a->entry, &b->entry))) {
        /* We merged listpacks! Now remove the unused quicklistNode. */
        quicklistNode *keep = NULL, *nokeep = NULL;
        if (!a->entry) {
            nokeep = a;
            keep = b;
        } else if (!b->entry) {
            nokeep = b;
            keep = a;
        }
        keep->count = lpLength(keep->entry);
        quicklistNodeUpdateSz(keep);

        nokeep->count = 0;
        __quicklistDelNode(quicklist, nokeep);
        quicklistCompress(quicklist, keep);
        return keep;
    } else {
        /* else, the merge returned NULL and nothing changed. */
        return NULL;
    }
}",810.0,838.0,1.0,12.0,29.0,28,6,36,6,4,20,3,4,4,8,,0,15,6,3,3,quicklistNode
3701,240300,_quicklistMergeNodes,1,_quicklistMergeNodes,"void _quicklistMergeNodes (quicklist*,quicklistNode*)",quicklist.c,"REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,
                                       quicklistNode *center) {
    int fill = quicklist->fill;
    quicklistNode *prev, *prev_prev, *next, *next_next, *target;
    prev = prev_prev = next = next_next = target = NULL;

    if (center->prev) {
        prev = center->prev;
        if (center->prev->prev)
            prev_prev = center->prev->prev;
    }

    if (center->next) {
        next = center->next;
        if (center->next->next)
            next_next = center->next->next;
    }

    /* Try to merge prev_prev and prev */
    if (_quicklistNodeAllowMerge(prev, prev_prev, fill)) {
        _quicklistListpackMerge(quicklist, prev_prev, prev);
        prev_prev = prev = NULL; /* they could have moved, invalidate them. */
    }

    /* Try to merge next and next_next */
    if (_quicklistNodeAllowMerge(next, next_next, fill)) {
        _quicklistListpackMerge(quicklist, next, next_next);
        next = next_next = NULL; /*...",848.0,891.0,1.0,12.0,44.0,33,2,53,9,0,21,9,11,10,8,,0,18,4,2,2,void
3702,240444,_quicklistSplitNode,1,_quicklistSplitNode,"quicklistNode _quicklistSplitNode (quicklistNode*,int,int)",quicklist.c,"REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
                                                int after) {
    size_t zl_sz = node->sz;

    quicklistNode *new_node = quicklistCreateNode();
    new_node->entry = zmalloc(zl_sz);

    /* Copy original listpack so we can split it */
    memcpy(new_node->entry, node->entry, zl_sz);

    /* Need positive offset for calculating extent below. */
    if (offset < 0) offset = node->count + offset;

    /* Ranges to be trimmed: -1 here means ""continue deleting until the list ends"" */
    int orig_start = after ? offset + 1 : 0;
    int orig_extent = after ? -1 : offset;
    int new_start = after ? 0 : offset;
    int new_extent = after ? offset + 1 : -1;

    D(""After %d (%d); ranges: [%d, %d], [%d, %d]"", after, offset, orig_start,
      orig_extent, new_start, new_extent);

    node->entry = lpDeleteRange(node->entry, orig_start, orig_extent);
    node->count = lpLength(node->entry);
    quicklistNodeUpdate...",912.0,944.0,1.0,12.0,33.0,41,6,43,9,0,25,2,2,0,8,,0,25,6,3,3,quicklistNode
3703,240587,_quicklistInsert,1,_quicklistInsert,"void _quicklistInsert (quicklistIter*,quicklistEntry*,void*,size_t,int)",quicklist.c,"REDIS_STATIC void _quicklistInsert(quicklistIter *iter, quicklistEntry *entry,
                                   void *value, const size_t sz, int after)
{
    quicklist *quicklist = iter->quicklist;
    int full = 0, at_tail = 0, at_head = 0, avail_next = 0, avail_prev = 0;
    int fill = quicklist->fill;
    quicklistNode *node = entry->node;
    quicklistNode *new_node = NULL;

    if (!node) {
        /* we have no reference node, so let's create only node in the list */
        D(""No node given!"");
        if (unlikely(isLargeElement(sz))) {
            __quicklistInsertPlainNode(quicklist, quicklist->tail, value, sz, after);
            return;
        }
        new_node = quicklistCreateNode();
        new_node->entry = lpPrepend(lpNew(0), value, sz);
        __quicklistInsertNode(quicklist, NULL, new_node, after);
        new_node->count++;
        quicklist->count++;
        return;
    }

    /* Populate accounting flags for easier boolean checks later */
    if (!_quickl...",950.0,1081.0,1.0,12.0,132.0,82,10,94,16,2,44,11,15,14,13,,0,39,10,5,5,void
3704,241419,quicklistInsertBefore,1,quicklistInsertBefore,"void quicklistInsertBefore (quicklistIter*,quicklistEntry*,void*,size_t)",quicklist.c,"void quicklistInsertBefore(quicklistIter *iter, quicklistEntry *entry,
                           void *value, const size_t sz)
{
    _quicklistInsert(iter, entry, value, sz, 0);
}",1083.0,1087.0,1.0,1.0,5.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
3705,241433,quicklistInsertAfter,1,quicklistInsertAfter,"void quicklistInsertAfter (quicklistIter*,quicklistEntry*,void*,size_t)",quicklist.c,"void quicklistInsertAfter(quicklistIter *iter, quicklistEntry *entry,
                          void *value, const size_t sz)
{
    _quicklistInsert(iter, entry, value, sz, 1);
}",1089.0,1093.0,1.0,1.0,5.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
3706,241447,quicklistDelRange,1,quicklistDelRange,"int quicklistDelRange (quicklist*,long,long)",quicklist.c,"int quicklistDelRange(quicklist *quicklist, const long start,
                      const long count) {
    if (count <= 0)
        return 0;

    unsigned long extent = count; /* range is inclusive of start position */

    if (start >= 0 && extent > (quicklist->count - start)) {
        /* if requesting delete more elements than exist, limit to list size. */
        extent = quicklist->count - start;
    } else if (start < 0 && extent > (unsigned long)(-start)) {
        /* else, if at negative offset, limit max size to rest of list. */
        extent = -start; /* c.f. LREM -29 29; just delete until end. */
    }

    quicklistIter *iter = quicklistGetIteratorAtIdx(quicklist, AL_START_TAIL, start);
    if (!iter)
        return 0;

    D(""Quicklist delete request for start %ld, count %ld, extent: %ld"", start,
      count, extent);
    quicklistNode *node = iter->current;
    long offset = iter->offset;
    quicklistReleaseIterator(iter);

    /* iterate over next nodes until every...",1101.0,1184.0,1.0,63.0,84.0,32,11,39,10,0,11,7,9,3,3,,0,9,6,3,3,int
3707,241743,quicklistCompare,1,quicklistCompare,"int quicklistCompare (quicklistEntry*,unsigned char*,size_t)",quicklist.c,"int quicklistCompare(quicklistEntry* entry, unsigned char *p2, const size_t p2_len) {
    if (unlikely(QL_NODE_IS_PLAIN(entry->node))) {
        return ((entry->sz == p2_len) && (memcmp(entry->value, p2, p2_len) == 0));
    }
    return lpCompare(entry->zi, p2, p2_len);
}",1187.0,1192.0,1.0,8.0,6.0,9,3,9,3,0,5,2,2,1,1,,0,4,6,3,3,int
3708,241783,quicklistGetIterator,1,quicklistGetIterator,"quicklistIter quicklistGetIterator (quicklist*,int)",quicklist.c,"quicklistIter *quicklistGetIterator(quicklist *quicklist, int direction) {
    quicklistIter *iter;

    iter = zmalloc(sizeof(*iter));

    if (direction == AL_START_HEAD) {
        iter->current = quicklist->head;
        iter->offset = 0;
    } else if (direction == AL_START_TAIL) {
        iter->current = quicklist->tail;
        iter->offset = -1;
    }

    iter->direction = direction;
    iter->quicklist = quicklist;

    iter->zi = NULL;

    return iter;
}",1196.0,1215.0,1.0,21.0,20.0,15,5,13,4,1,7,2,2,0,1,,0,7,4,2,2,quicklistIter
3709,241854,quicklistGetIteratorAtIdx,1,quicklistGetIteratorAtIdx,"quicklistIter quicklistGetIteratorAtIdx (quicklist*,int,long long)",quicklist.c,"quicklistIter *quicklistGetIteratorAtIdx(quicklist *quicklist,
                                         const int direction,
                                         const long long idx)
{
    quicklistNode *n;
    unsigned long long accum = 0;
    unsigned long long index;
    int forward = idx < 0 ? 0 : 1; /* < 0 -> reverse, 0+ -> forward */

    index = forward ? idx : (-idx) - 1;
    if (index >= quicklist->count)
        return NULL;

    /* Seek in the other direction if that way is shorter. */
    int seek_forward = forward;
    unsigned long long seek_index = index;
    if (index > (quicklist->count - 1) / 2) {
        seek_forward = !forward;
        seek_index = quicklist->count - 1 - index;
    }

    n = seek_forward ? quicklist->head : quicklist->tail;
    while (likely(n)) {
        if ((accum + n->count) > seek_index) {
            break;
        } else {
            D(""Skipping over (%p) %u at accum %lld"", (void *)n, n->count,
              accum);
            accum ...",1219.0,1273.0,1.0,11.0,55.0,42,12,48,11,3,11,9,9,3,1,,0,11,6,3,3,quicklistIter
3710,242026,quicklistReleaseIterator,1,quicklistReleaseIterator,void quicklistReleaseIterator (quicklistIter*),quicklist.c,"void quicklistReleaseIterator(quicklistIter *iter) {
    if (!iter) return;
    if (iter->current)
        quicklistCompress(iter->quicklist, iter->current);

    zfree(iter);
}",1277.0,1283.0,1.0,8.0,7.0,14,4,11,1,3,12,3,3,1,3,,0,9,2,1,1,void
3711,242090,quicklistNext,1,quicklistNext,"int quicklistNext (quicklistIter*,quicklistEntry*)",quicklist.c,"int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {
    initEntry(entry);

    if (!iter) {
        D(""Returning because no iter!"");
        return 0;
    }

    entry->quicklist = iter->quicklist;
    entry->node = iter->current;

    if (!iter->current) {
        D(""Returning because current node is NULL"");
        return 0;
    }

    unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;
    int offset_update = 0;

    int plain = QL_NODE_IS_PLAIN(iter->current);
    if (!iter->zi) {
        /* If !zi, use current index. */
        quicklistDecompressNodeForUse(iter->current);
        if (unlikely(plain))
            iter->zi = iter->current->entry;
        else
            iter->zi = lpSeek(iter->current->entry, iter->offset);
    } else if (unlikely(plain)) {
        iter->zi = NULL;
    } else {
        /* else, use existing iterator offset and get prev/next as necessary. */
        if (iter->direction == AL_START_HEAD) {
            nextFn = lpNext;
 ...",1306.0,1380.0,1.0,4.0,75.0,70,7,49,6,2,37,7,9,3,2,,0,36,4,2,2,int
3712,242501,quicklistSetDirection,1,quicklistSetDirection,"void quicklistSetDirection (quicklistIter*,int)",quicklist.c,"void quicklistSetDirection(quicklistIter *iter, int direction) {
    iter->direction = direction;
}",1383.0,1385.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
3713,242512,quicklistDup,1,quicklistDup,quicklist quicklistDup (quicklist*),quicklist.c,"quicklist *quicklistDup(quicklist *orig) {
    quicklist *copy;

    copy = quicklistNew(orig->fill, orig->compress);

    for (quicklistNode *current = orig->head; current;
         current = current->next) {
        quicklistNode *node = quicklistCreateNode();

        if (current->encoding == QUICKLIST_NODE_ENCODING_LZF) {
            quicklistLZF *lzf = (quicklistLZF *)current->entry;
            size_t lzf_sz = sizeof(*lzf) + lzf->sz;
            node->entry = zmalloc(lzf_sz);
            memcpy(node->entry, current->entry, lzf_sz);
        } else if (current->encoding == QUICKLIST_NODE_ENCODING_RAW) {
            node->entry = zmalloc(current->sz);
            memcpy(node->entry, current->entry, current->sz);
        }

        node->count = current->count;
        copy->count += node->count;
        node->sz = current->sz;
        node->encoding = current->encoding;
        node->container = current->container;

        _quicklistInsertNodeAfter(copy, copy->tail, node);
    }...",1393.0,1423.0,1.0,33.0,31.0,36,8,32,6,0,17,3,4,0,4,,0,16,2,1,1,quicklist
3714,242659,quicklistGetIteratorEntryAtIdx,1,quicklistGetIteratorEntryAtIdx,"quicklistIter quicklistGetIteratorEntryAtIdx (quicklist*,long long,quicklistEntry*)",quicklist.c,"quicklistIter *quicklistGetIteratorEntryAtIdx(quicklist *quicklist, const long long idx,
                                              quicklistEntry *entry)
{
    quicklistIter *iter = quicklistGetIteratorAtIdx(quicklist, AL_START_TAIL, idx);
    if (!iter) return NULL;
    assert(quicklistNext(iter, entry));
    return iter;
}",1433.0,1440.0,1.0,63.0,8.0,6,6,8,5,1,3,2,2,0,3,,0,1,6,3,3,quicklistIter
3715,242699,quicklistRotatePlain,1,quicklistRotatePlain,void quicklistRotatePlain (quicklist*),quicklist.c,"static void quicklistRotatePlain(quicklist *quicklist) {
    quicklistNode *new_head = quicklist->tail;
    quicklistNode *new_tail = quicklist->tail->prev;
    quicklist->head->prev = new_head;
    new_tail->next = NULL;
    new_head->next = quicklist->head;
    new_head->prev = NULL;
    quicklist->head = new_head;
    quicklist->tail = new_tail;
}",1442.0,1451.0,1.0,1.0,10.0,19,2,16,4,1,9,1,1,0,0,,0,9,2,1,1,void
3716,242752,quicklistRotate,1,quicklistRotate,void quicklistRotate (quicklist*),quicklist.c,"void quicklistRotate(quicklist *quicklist) {
    if (quicklist->count <= 1)
        return;

    if (unlikely(QL_NODE_IS_PLAIN(quicklist->tail))) {
        quicklistRotatePlain(quicklist);
        return;
    }

    /* First, get the tail entry */
    unsigned char *p = lpSeek(quicklist->tail->entry, -1);
    unsigned char *value, *tmp;
    long long longval;
    unsigned int sz;
    char longstr[32] = {0};
    tmp = lpGetValue(p, &sz, &longval);

    /* If value found is NULL, then lpGet populated longval instead */
    if (!tmp) {
        /* Write the longval as a string so we can re-add it */
        sz = ll2string(longstr, sizeof(longstr), longval);
        value = (unsigned char *)longstr;
    } else if (quicklist->len == 1) {
        /* Copy buffer since there could be a memory overlap when move
         * entity from tail to head in the same listpack. */
        value = zmalloc(sz);
        memcpy(value, tmp, sz);
    } else {
        value = tmp;
    }

    /* Add tail entry...",1454.0,1499.0,1.0,8.0,46.0,31,12,31,7,0,14,6,6,3,8,,0,10,2,1,1,void
3717,242886,quicklistPopCustom,1,quicklistPopCustom,"int quicklistPopCustom (quicklist*,int,unsigned char**,size_t*,long long*,void*)",quicklist.c,"int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
                       size_t *sz, long long *sval,
                       void *(*saver)(unsigned char *data, size_t sz)) {
    unsigned char *p;
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    int pos = (where == QUICKLIST_HEAD) ? 0 : -1;

    if (quicklist->count == 0)
        return 0;

    if (data)
        *data = NULL;
    if (sz)
        *sz = 0;
    if (sval)
        *sval = -123456789;

    quicklistNode *node;
    if (where == QUICKLIST_HEAD && quicklist->head) {
        node = quicklist->head;
    } else if (where == QUICKLIST_TAIL && quicklist->tail) {
        node = quicklist->tail;
    } else {
        return 0;
    }

    /* The head and tail should never be compressed */
    assert(node->encoding != QUICKLIST_NODE_ENCODING_LZF);

    if (unlikely(QL_NODE_IS_PLAIN(node))) {
        if (data)
            *data = saver(node->entry, node->sz);
        if (sz)
         ...",1510.0,1565.0,1.0,24.0,56.0,43,12,44,12,1,14,12,16,3,5,,0,11,12,6,6,int
3718,243095,_quicklistSaver,1,_quicklistSaver,"void* _quicklistSaver (unsigned char*,size_t)",quicklist.c,"REDIS_STATIC void *_quicklistSaver(unsigned char *data, size_t sz) {
    unsigned char *vstr;
    if (data) {
        vstr = zmalloc(sz);
        memcpy(vstr, data, sz);
        return vstr;
    }
    return NULL;
}",1568.0,1576.0,1.0,12.0,9.0,1,1,8,4,0,1,2,2,0,1,,0,1,4,2,2,void*
3719,243117,quicklistPop,1,quicklistPop,"int quicklistPop (quicklist*,int,unsigned char**,size_t*,long long*)",quicklist.c,"int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
                 size_t *sz, long long *slong) {
    unsigned char *vstr = NULL;
    size_t vlen = 0;
    long long vlong = 0;
    if (quicklist->count == 0)
        return 0;
    int ret = quicklistPopCustom(quicklist, where, &vstr, &vlen, &vlong,
                                 _quicklistSaver);
    if (data)
        *data = vstr;
    if (slong)
        *slong = vlong;
    if (sz)
        *sz = vlen;
    return ret;
}",1581.0,1597.0,1.0,1.0,17.0,15,5,21,10,0,2,5,5,1,1,,0,2,10,5,5,int
3720,243183,quicklistPush,1,quicklistPush,"void quicklistPush (quicklist*,void*,size_t,int)",quicklist.c,"void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
                   int where) {
    /* The head and tail should never be compressed (we don't attempt to decompress them) */
    if (quicklist->head)
        assert(quicklist->head->encoding != QUICKLIST_NODE_ENCODING_LZF);
    if (quicklist->tail)
        assert(quicklist->tail->encoding != QUICKLIST_NODE_ENCODING_LZF);

    if (where == QUICKLIST_HEAD) {
        quicklistPushHead(quicklist, value, sz);
    } else if (where == QUICKLIST_TAIL) {
        quicklistPushTail(quicklist, value, sz);
    }
}",1600.0,1613.0,1.0,8.0,14.0,17,7,8,4,0,7,4,4,2,3,,0,4,8,4,4,void
3721,243266,quicklistRepr,1,quicklistRepr,"void quicklistRepr (unsigned char*,int)",quicklist.c,"void quicklistRepr(unsigned char *ql, int full) {
    int i = 0;
    quicklist *quicklist  = (struct quicklist*) ql;
    printf(""{count : %ld}\n"", quicklist->count);
    printf(""{len : %ld}\n"", quicklist->len);
    printf(""{fill : %d}\n"", quicklist->fill);
    printf(""{compress : %d}\n"", quicklist->compress);
    printf(""{bookmark_count : %d}\n"", quicklist->bookmark_count);
    quicklistNode* node = quicklist->head;

    while(node != NULL) {
        printf(""{quicklist node(%d)\n"", i++);
        printf(""{container : %s, encoding: %s, size: %zu, count: %d, recompress: %d, attempted_compress: %d}\n"",
               QL_NODE_IS_PLAIN(node) ? ""PLAIN"": ""PACKED"",
               (node->encoding == QUICKLIST_NODE_ENCODING_RAW) ? ""RAW"": ""LZF"",
               node->sz,
               node->count,
               node->recompress,
               node->attempted_compress);

        if (full) {
            quicklistDecompressNode(node);
            if (node->container == QUICKLIST_NODE_CONTAINER_P...",1616.0,1651.0,1.0,15.0,36.0,34,8,34,6,0,21,4,7,1,3,,0,18,4,2,2,void
3722,243443,quicklistBookmarkCreate,1,quicklistBookmarkCreate,"int quicklistBookmarkCreate (quicklist**,char*,quicklistNode*)",quicklist.c,"int quicklistBookmarkCreate(quicklist **ql_ref, const char *name, quicklistNode *node) {
    quicklist *ql = *ql_ref;
    if (ql->bookmark_count >= QL_MAX_BM)
        return 0;
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (bm) {
        bm->node = node;
        return 1;
    }
    ql = zrealloc(ql, sizeof(quicklist) + (ql->bookmark_count+1) * sizeof(quicklistBookmark));
    *ql_ref = ql;
    ql->bookmarks[ql->bookmark_count].node = node;
    ql->bookmarks[ql->bookmark_count].name = zstrdup(name);
    ql->bookmark_count++;
    return 1;
}",1661.0,1676.0,1.0,30.0,16.0,30,12,24,8,0,11,3,3,1,3,,0,11,6,3,3,int
3723,243534,quicklistBookmarkFind,1,quicklistBookmarkFind,"quicklistNode quicklistBookmarkFind (quicklist*,char*)",quicklist.c,"quicklistNode *quicklistBookmarkFind(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm) return NULL;
    return bm->node;
}",1681.0,1685.0,1.0,1.0,5.0,3,3,6,4,0,2,2,2,0,1,,0,2,4,2,2,quicklistNode
3724,243556,quicklistBookmarkDelete,1,quicklistBookmarkDelete,"int quicklistBookmarkDelete (quicklist*,char*)",quicklist.c,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}",1690.0,1696.0,1.0,1.0,7.0,2,2,6,3,0,2,2,2,0,2,,0,1,4,2,2,int
3725,243696,quicklistBookmarksClear,1,quicklistBookmarksClear,void quicklistBookmarksClear (quicklist*),quicklist.c,"void quicklistBookmarksClear(quicklist *ql) {
    while (ql->bookmark_count)
        zfree(ql->bookmarks[--ql->bookmark_count].name);
    /* NOTE: We do not shrink (realloc) the quick list. main use case for this
     * function is just before releasing the allocation. */
}",1727.0,1732.0,1.0,1.0,6.0,1,1,1,1,1,1,2,2,1,0,,0,1,2,1,1,void
3726,244069,next,1,next,void next (void),rand.c,"static void next(void) {
    uint32_t p[2], q[2], r[2], carry0, carry1;

    MUL(a[0], x[0], p);
    ADDEQU(p[0], c, carry0);
    ADDEQU(p[1], carry0, carry1);
    MUL(a[0], x[1], q);
    ADDEQU(p[1], q[0], carry0);
    MUL(a[1], x[0], r);
    x[2] = LOW(carry0 + carry1 + CARRY(p[1], r[0]) + q[1] + r[1] +
            a[0] * x[2] + a[1] * x[1] + a[2] * x[0]);
    x[1] = LOW(p[1] + r[0]);
    x[0] = LOW(p[0]);
}",80.0,93.0,1.0,4.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3727,244074,redisLrand48,1,redisLrand48,int32_t redisLrand48 (void),rand.c,"int32_t redisLrand48(void) {
    next();
    return (((int32_t)x[2] << (N - 1)) + (x[1] >> 1));
}",71.0,74.0,1.0,31.0,4.0,7,6,2,1,0,3,1,1,0,1,,0,2,2,1,1,int32_t
3728,244098,redisSrand48,1,redisSrand48,void redisSrand48 (int32_t),rand.c,"void redisSrand48(int32_t seedval) {
    SEED(X0, LOW(seedval), HIGH(seedval));
}",76.0,78.0,1.0,4.0,3.0,36,10,9,4,0,7,1,1,0,0,,0,7,2,1,1,void
3729,244763,raxSetDebugMsg,1,raxSetDebugMsg,void raxSetDebugMsg (int),rax.c,"void raxSetDebugMsg(int onoff) {
    raxDebugMsg = onoff;
}",81.0,83.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
3730,244771,raxStackInit,1,raxStackInit,void raxStackInit (raxStack*),rax.c,"static inline void raxStackInit(raxStack *ts) {
    ts->stack = ts->static_items;
    ts->items = 0;
    ts->maxitems = RAX_STACK_STATIC_ITEMS;
    ts->oom = 0;
}",94.0,99.0,1.0,19.0,6.0,9,2,5,1,2,5,1,1,0,0,,0,5,2,1,1,void
3731,244800,raxStackPush,1,raxStackPush,"int raxStackPush (raxStack*,void*)",rax.c,"static inline int raxStackPush(raxStack *ts, void *ptr) {
    if (ts->items == ts->maxitems) {
        if (ts->stack == ts->static_items) {
            ts->stack = rax_malloc(sizeof(void*)*ts->maxitems*2);
            if (ts->stack == NULL) {
                ts->stack = ts->static_items;
                ts->oom = 1;
                errno = ENOMEM;
                return 0;
            }
            memcpy(ts->stack,ts->static_items,sizeof(void*)*ts->maxitems);
        } else {
            void **newalloc = rax_realloc(ts->stack,sizeof(void*)*ts->maxitems*2);
            if (newalloc == NULL) {
                ts->oom = 1;
                errno = ENOMEM;
                return 0;
            }
            ts->stack = newalloc;
        }
        ts->maxitems *= 2;
    }
    ts->stack[ts->items] = ptr;
    ts->items++;
    return 1;
}",102.0,127.0,1.0,24.0,26.0,33,8,23,6,4,18,4,7,5,1,,0,18,4,2,2,int
3732,244935,raxStackPop,1,raxStackPop,void* raxStackPop (raxStack*),rax.c,"static inline void *raxStackPop(raxStack *ts) {
    if (ts->items == 0) return NULL;
    ts->items--;
    return ts->stack[ts->items];
}",131.0,135.0,1.0,1.0,5.0,7,4,5,2,4,4,2,2,1,0,,0,4,2,1,1,void*
3733,244961,raxStackPeek,1,raxStackPeek,void* raxStackPeek (raxStack*),rax.c,"static inline void *raxStackPeek(raxStack *ts) {
    if (ts->items == 0) return NULL;
    return ts->stack[ts->items-1];
}",139.0,142.0,1.0,1.0,4.0,6,4,4,2,1,3,2,2,1,0,,0,3,2,1,1,void*
3734,244985,raxStackFree,1,raxStackFree,void raxStackFree (raxStack*),rax.c,"static inline void raxStackFree(raxStack *ts) {
    if (ts->stack != ts->static_items) rax_free(ts->stack);
}",145.0,147.0,1.0,39.0,3.0,4,2,3,1,4,4,2,2,2,1,,0,3,2,1,1,void
3735,245005,raxNewNode,1,raxNewNode,"raxNode raxNewNode (size_t,int)",rax.c,"raxNode *raxNewNode(size_t children, int datafield) {
    size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+
                      sizeof(raxNode*)*children;
    if (datafield) nodesize += sizeof(void*);
    raxNode *node = rax_malloc(nodesize);
    if (node == NULL) return NULL;
    node->iskey = 0;
    node->isnull = 0;
    node->iscompr = 0;
    node->size = children;
    return node;
}",188.0,199.0,1.0,47.0,12.0,27,10,24,7,4,5,3,3,0,1,,0,5,4,2,2,raxNode
3736,245084,raxNew,1,raxNew,rax raxNew (void),rax.c,"rax *raxNew(void) {
    rax *rax = rax_malloc(sizeof(*rax));
    if (rax == NULL) return NULL;
    rax->numele = 0;
    rax->numnodes = 1;
    rax->head = raxNewNode(0,0);
    if (rax->head == NULL) {
        rax_free(rax);
        return NULL;
    } else {
        return rax;
    }
}",203.0,215.0,1.0,15.0,13.0,12,5,12,2,16,7,3,3,1,3,,0,6,2,1,1,rax
3737,245139,raxReallocForData,1,raxReallocForData,"raxNode raxReallocForData (raxNode*,void*)",rax.c,"raxNode *raxReallocForData(raxNode *n, void *data) {
    if (data == NULL) return n; /* No reallocation needed, setting isnull=1 */
    size_t curlen = raxNodeCurrentLength(n);
    return rax_realloc(n,curlen+sizeof(void*));
}",219.0,223.0,1.0,20.0,5.0,31,12,21,6,2,7,2,2,0,1,,0,6,4,2,2,raxNode
3738,245215,raxSetData,1,raxSetData,"void raxSetData (raxNode*,void*)",rax.c,"void raxSetData(raxNode *n, void *data) {
    n->iskey = 1;
    if (data != NULL) {
        n->isnull = 0;
        void **ndata = (void**)
            ((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
        memcpy(ndata,&data,sizeof(data));
    } else {
        n->isnull = 1;
    }
}",226.0,236.0,1.0,22.0,11.0,40,14,24,6,6,8,2,2,0,0,,0,8,4,2,2,void
3739,245312,raxGetData,1,raxGetData,void* raxGetData (raxNode*),rax.c,"void *raxGetData(raxNode *n) {
    if (n->isnull) return NULL;
    void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
    void *data;
    memcpy(&data,ndata,sizeof(data));
    return data;
}",239.0,245.0,1.0,36.0,7.0,36,13,23,6,14,7,2,2,1,0,,0,7,2,1,1,void*
3740,245396,raxAddChild,1,raxAddChild,"raxNode raxAddChild (raxNode*,unsigned char,raxNode**,raxNode***)",rax.c,"raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode ***parentlink) {
    assert(n->iscompr == 0);

    size_t curlen = raxNodeCurrentLength(n);
    n->size++;
    size_t newlen = raxNodeCurrentLength(n);
    n->size--; /* For now restore the original size. We'll update it only on
                  success at the end. */

    /* Alloc the new child we will link to 'n'. */
    raxNode *child = raxNewNode(0,0);
    if (child == NULL) return NULL;

    /* Make space in the original node. */
    raxNode *newn = rax_realloc(n,newlen);
    if (newn == NULL) {
        rax_free(child);
        return NULL;
    }
    n = newn;

    /* After the reallocation, we have up to 8/16 (depending on the system
     * pointer size, and the required node padding) bytes at the end, that is,
     * the additional char in the 'data' section, plus one pointer to the new
     * child, plus the padding needed in order to store addresses into aligned
     * locations.
     *
     * So...",256.0,387.0,1.0,20.0,132.0,174,20,131,16,0,37,8,8,4,3,,0,36,8,4,4,raxNode
3741,245816,raxCompressNode,1,raxCompressNode,"raxNode raxCompressNode (raxNode*,unsigned char*,size_t,raxNode**)",rax.c,"raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **child) {
    assert(n->size == 0 && n->iscompr == 0);
    void *data = NULL; /* Initialized only to avoid warnings. */
    size_t newsize;

    debugf(""Compress node: %.*s\n"", (int)len,s);

    /* Allocate the child to link to this node. */
    *child = raxNewNode(0,0);
    if (*child == NULL) return NULL;

    /* Make space in the parent node. */
    newsize = sizeof(raxNode)+len+raxPadding(len)+sizeof(raxNode*);
    if (n->iskey) {
        data = raxGetData(n); /* To restore it later. */
        if (!n->isnull) newsize += sizeof(void*);
    }
    raxNode *newn = rax_realloc(n,newsize);
    if (newn == NULL) {
        rax_free(*child);
        return NULL;
    }
    n = newn;

    n->iscompr = 1;
    n->size = len;
    memcpy(n->data,s,len);
    if (n->iskey) raxSetData(n,data);
    raxNode **childfield = raxNodeLastChildPtr(n);
    memcpy(childfield,child,sizeof(*child));
    return n;
}",397.0,428.0,1.0,4.0,32.0,82,15,65,11,1,21,6,7,3,5,,0,19,8,4,4,raxNode
3742,246032,raxLowWalk,1,raxLowWalk,"size_t raxLowWalk (rax*,unsigned char*,size_t,raxNode**,raxNode***,int*,raxStack*)",rax.c,"static inline size_t raxLowWalk(rax *rax, unsigned char *s, size_t len, raxNode **stopnode, raxNode ***plink, int *splitpos, raxStack *ts) {
    raxNode *h = rax->head;
    raxNode **parentlink = &rax->head;

    size_t i = 0; /* Position in the string. */
    size_t j = 0; /* Position in the node children (or bytes if compressed).*/
    while(h->size && i < len) {
        debugnode(""Lookup current node"",h);
        unsigned char *v = h->data;

        if (h->iscompr) {
            for (j = 0; j < h->size && i < len; j++, i++) {
                if (v[j] != s[i]) break;
            }
            if (j != h->size) break;
        } else {
            /* Even when h->size is large, linear scan provides good
             * performances compared to other approaches that are in theory
             * more sounding, like performing a binary search. */
            for (j = 0; j < h->size; j++) {
                if (v[j] == s[i]) break;
            }
            if (j == h->size) break;
      ...",459.0,500.0,1.0,8.0,42.0,54,14,55,14,4,13,13,21,6,1,,0,12,14,7,7,size_t
3743,246246,raxGenericInsert,1,raxGenericInsert,"int raxGenericInsert (rax*,unsigned char*,size_t,void*,void**,int)",rax.c,"int raxGenericInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old, int overwrite) {
    size_t i;
    int j = 0; /* Split position. If raxLowWalk() stops in a compressed
                  node, the index 'j' represents the char we stopped within the
                  compressed node, that is, the position where to split the
                  node for insertion. */
    raxNode *h, **parentlink;

    debugf(""### Insert %.*s with value %p\n"", (int)len, s, data);
    i = raxLowWalk(rax,s,len,&h,&parentlink,&j,NULL);

    /* If i == len we walked following the whole string. If we are not
     * in the middle of a compressed node, the string is either already
     * inserted or this middle node is currently not a key, but can represent
     * our key. We have just to reallocate the node and make space for the
     * data pointer. */
    if (i == len && (!h->iscompr || j == 0 /* not in the middle if j is 0 */)) {
        debugf(""### Insert: node representing key exists\n""...",509.0,900.0,1.0,4.0,392.0,326,23,266,30,2,80,26,48,12,18,,0,71,12,6,6,int
3744,247762,raxInsert,1,raxInsert,"int raxInsert (rax*,unsigned char*,size_t,void*,void**)",rax.c,"int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
    return raxGenericInsert(rax,s,len,data,old,1);
}",904.0,906.0,1.0,1.0,3.0,0,0,5,5,13,1,1,1,0,1,,0,0,10,5,5,int
3745,247779,raxTryInsert,1,raxTryInsert,"int raxTryInsert (rax*,unsigned char*,size_t,void*,void**)",rax.c,"int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
    return raxGenericInsert(rax,s,len,data,old,0);
}",911.0,913.0,1.0,1.0,3.0,0,0,5,5,3,1,1,1,0,1,,0,0,10,5,5,int
3746,247796,raxFind,1,raxFind,"void* raxFind (rax*,unsigned char*,size_t)",rax.c,"void *raxFind(rax *rax, unsigned char *s, size_t len) {
    raxNode *h;

    debugf(""### Lookup: %.*s\n"", (int)len, s);
    int splitpos = 0;
    size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);
    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey)
        return raxNotFound;
    return raxGetData(h);
}",918.0,927.0,1.0,4.0,10.0,12,7,16,8,15,5,2,2,2,2,,0,4,6,3,3,void*
3747,247844,raxFindParentLink,1,raxFindParentLink,"raxNode raxFindParentLink (raxNode*,raxNode*)",rax.c,"raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
    raxNode **cp = raxNodeFirstChildPtr(parent);
    raxNode *c;
    while(1) {
        memcpy(&c,cp,sizeof(c));
        if (c == child) break;
        cp++;
    }
    return cp;
}",934.0,943.0,1.0,19.0,10.0,19,11,15,5,1,3,4,4,0,0,,0,3,4,2,2,raxNode
3748,247902,raxRemoveChild,1,raxRemoveChild,"raxNode raxRemoveChild (raxNode*,raxNode*)",rax.c,"raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
    debugnode(""raxRemoveChild before"", parent);
    /* If parent is a compressed node (having a single child, as for definition
     * of the data structure), the removal of the child consists into turning
     * it into a normal node without children. */
    if (parent->iscompr) {
        void *data = NULL;
        if (parent->iskey) data = raxGetData(parent);
        parent->isnull = 0;
        parent->iscompr = 0;
        parent->size = 0;
        if (parent->iskey) raxSetData(parent,data);
        debugnode(""raxRemoveChild after"", parent);
        return parent;
    }

    /* Otherwise we need to scan for the child pointer and memmove()
     * accordingly.
     *
     * 1. To start we seek the first element in both the children
     *    pointers and edge bytes in the node. */
    raxNode **cp = raxNodeFirstChildPtr(parent);
    raxNode **c = cp;
    unsigned char *e = parent->data;

    /* 2. Search the child pointer to...",949.0,1018.0,1.0,4.0,70.0,100,16,81,14,1,26,9,11,3,3,,0,25,4,2,2,raxNode
3749,248168,raxRemove,1,raxRemove,"int raxRemove (rax*,unsigned char*,size_t,void**)",rax.c,"int raxRemove(rax *rax, unsigned char *s, size_t len, void **old) {
    raxNode *h;
    raxStack ts;

    debugf(""### Delete: %.*s\n"", (int)len, s);
    raxStackInit(&ts);
    int splitpos = 0;
    size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,&ts);
    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey) {
        raxStackFree(&ts);
        return 0;
    }
    if (old) *old = raxGetData(h);
    h->iskey = 0;
    rax->numele--;

    /* If this node has no children, the deletion needs to reclaim the
     * no longer used nodes. This is an iterative process that needs to
     * walk the three upward, deleting all the nodes with just one child
     * that are not keys, until the head of the rax is reached or the first
     * node with more than one child is found. */

    int trycompress = 0; /* Will be set to 1 if we should try to optimize the
                            tree resulting from the deletion. */

    if (h->size == 0) {
        debugf(""Key deleted in node withou...",1022.0,1219.0,1.0,4.0,198.0,270,23,197,22,11,76,27,51,22,14,,0,70,8,4,4,int
3750,248882,raxRecursiveFree,1,raxRecursiveFree,"void raxRecursiveFree (rax*,raxNode*,void)",rax.c,"void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {
    debugnode(""free traversing"",n);
    int numchildren = n->iscompr ? 1 : n->size;
    raxNode **cp = raxNodeLastChildPtr(n);
    while(numchildren--) {
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        raxRecursiveFree(rax,child,free_callback);
        cp--;
    }
    debugnode(""free depth-first"",n);
    if (free_callback && n->iskey && !n->isnull)
        free_callback(raxGetData(n));
    rax_free(n);
    rax->numnodes--;
}",1223.0,1238.0,1.0,4.0,16.0,55,14,37,8,1,15,3,3,2,2,,0,13,6,3,3,void
3751,249016,raxFreeWithCallback,1,raxFreeWithCallback,"void raxFreeWithCallback (rax*,void)",rax.c,"void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {
    raxRecursiveFree(rax,rax->head,free_callback);
    assert(rax->numnodes == 0);
    rax_free(rax);
}",1242.0,1246.0,1.0,4.0,5.0,3,2,5,2,3,4,1,1,0,2,,0,2,4,2,2,void
3752,249038,raxFree,1,raxFree,void raxFree (rax*),rax.c,"void raxFree(rax *rax) {
    raxFreeWithCallback(rax,NULL);
}",1249.0,1251.0,1.0,1.0,3.0,0,0,2,2,5,1,1,1,0,1,,0,0,2,1,1,void
3753,249046,raxStart,1,raxStart,"void raxStart (raxIterator*,rax*)",rax.c,"void raxStart(raxIterator *it, rax *rt) {
    it->flags = RAX_ITER_EOF; /* No crash if the iterator is not seeked. */
    it->rt = rt;
    it->key_len = 0;
    it->key = it->key_static_string;
    it->key_max = RAX_ITER_STATIC_LEN;
    it->data = NULL;
    it->node_cb = NULL;
    raxStackInit(&it->stack);
}",1258.0,1267.0,1.0,16.0,10.0,18,4,12,3,19,10,1,1,0,1,,0,9,4,2,2,void
3754,249100,raxIteratorAddChars,1,raxIteratorAddChars,"int raxIteratorAddChars (raxIterator*,unsigned char*,size_t)",rax.c,"int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
    if (len == 0) return 1;
    if (it->key_max < it->key_len+len) {
        unsigned char *old = (it->key == it->key_static_string) ? NULL :
                                                                  it->key;
        size_t new_max = (it->key_len+len)*2;
        it->key = rax_realloc(old,new_max);
        if (it->key == NULL) {
            it->key = (!old) ? it->key_static_string : old;
            errno = ENOMEM;
            return 0;
        }
        if (old == NULL) memcpy(it->key,it->key_static_string,it->key_len);
        it->key_max = new_max;
    }
    /* Use memmove since there could be an overlap between 's' and
     * it->key when we use the current key in order to re-seek. */
    memmove(it->key+it->key_len,s,len);
    it->key_len += len;
    return 1;
}",1272.0,1292.0,1.0,18.0,21.0,36,9,36,8,4,18,5,7,3,1,,0,18,6,3,3,int
3755,249219,raxIteratorDelChars,1,raxIteratorDelChars,"void raxIteratorDelChars (raxIterator*,size_t)",rax.c,"void raxIteratorDelChars(raxIterator *it, size_t count) {
    it->key_len -= count;
}",1296.0,1298.0,1.0,1.0,3.0,2,2,2,2,2,1,1,1,0,0,,0,1,4,2,2,void
3756,249230,raxIteratorNextStep,1,raxIteratorNextStep,"int raxIteratorNextStep (raxIterator*,int)",rax.c,"int raxIteratorNextStep(raxIterator *it, int noup) {
    if (it->flags & RAX_ITER_EOF) {
        return 1;
    } else if (it->flags & RAX_ITER_JUST_SEEKED) {
        it->flags &= ~RAX_ITER_JUST_SEEKED;
        return 1;
    }

    /* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */
    size_t orig_key_len = it->key_len;
    size_t orig_stack_items = it->stack.items;
    raxNode *orig_node = it->node;

    while(1) {
        int children = it->node->iscompr ? 1 : it->node->size;
        if (!noup && children) {
            debugf(""GO DEEPER\n"");
            /* Seek the lexicographically smaller key in this subtree, which
             * is the first one found always going towards the first child
             * of every successive node. */
            if (!raxStackPush(&it->stack,it->node)) return 0;
            raxNode **cp = raxNodeFirstChildPtr(it->node);
            if (!raxIteratorAddChars(it,...",1314.0,1410.0,1.0,20.0,97.0,67,14,38,8,1,28,8,17,12,3,,0,28,4,2,2,int
3757,249717,raxSeekGreatest,1,raxSeekGreatest,int raxSeekGreatest (raxIterator*),rax.c,"int raxSeekGreatest(raxIterator *it) {
    while(it->node->size) {
        if (it->node->iscompr) {
            if (!raxIteratorAddChars(it,it->node->data,
                it->node->size)) return 0;
        } else {
            if (!raxIteratorAddChars(it,it->node->data+it->node->size-1,1))
                return 0;
        }
        raxNode **cp = raxNodeLastChildPtr(it->node);
        if (!raxStackPush(&it->stack,it->node)) return 0;
        memcpy(&it->node,cp,sizeof(it->node));
    }
    return 1;
}",1415.0,1429.0,1.0,23.0,15.0,67,13,30,4,2,20,5,9,8,2,,0,20,2,1,1,int
3758,249897,raxIteratorPrevStep,1,raxIteratorPrevStep,"int raxIteratorPrevStep (raxIterator*,int)",rax.c,"int raxIteratorPrevStep(raxIterator *it, int noup) {
    if (it->flags & RAX_ITER_EOF) {
        return 1;
    } else if (it->flags & RAX_ITER_JUST_SEEKED) {
        it->flags &= ~RAX_ITER_JUST_SEEKED;
        return 1;
    }

    /* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */
    size_t orig_key_len = it->key_len;
    size_t orig_stack_items = it->stack.items;
    raxNode *orig_node = it->node;

    while(1) {
        int old_noup = noup;

        /* Already on head? Can't go up, iteration finished. */
        if (!noup && it->node == it->rt->head) {
            it->flags |= RAX_ITER_EOF;
            it->stack.items = orig_stack_items;
            it->key_len = orig_key_len;
            it->node = orig_node;
            return 1;
        }

        unsigned char prevchild = it->key[it->key_len-1];
        if (!noup) {
            it->node = raxStackPop(&it->stack);
        } else {
       ...",1434.0,1505.0,1.0,20.0,72.0,131,23,74,12,1,44,14,33,13,6,,0,43,4,2,2,int
3759,250272,raxSeek,1,raxSeek,"int raxSeek (raxIterator*,char*,unsigned char*,size_t)",rax.c,"int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {
    int eq = 0, lt = 0, gt = 0, first = 0, last = 0;

    it->stack.items = 0; /* Just resetting. Initialized by raxStart(). */
    it->flags |= RAX_ITER_JUST_SEEKED;
    it->flags &= ~RAX_ITER_EOF;
    it->key_len = 0;
    it->node = NULL;

    /* Set flags according to the operator used to perform the seek. */
    if (op[0] == '>') {
        gt = 1;
        if (op[1] == '=') eq = 1;
    } else if (op[0] == '<') {
        lt = 1;
        if (op[1] == '=') eq = 1;
    } else if (op[0] == '=') {
        eq = 1;
    } else if (op[0] == '^') {
        first = 1;
    } else if (op[0] == '$') {
        last = 1;
    } else {
        errno = 0;
        return 0; /* Error. */
    }

    /* If there are no elements, set the EOF condition immediately and
     * return. */
    if (it->rt->numele == 0) {
        it->flags |= RAX_ITER_EOF;
        return 1;
    }

    if (first) {
        /* Seeking the first key gre...",1511.0,1670.0,1.0,17.0,160.0,63,11,48,12,22,25,10,13,6,5,,0,25,8,4,4,int
3760,250858,raxNext,1,raxNext,int raxNext (raxIterator*),rax.c,"int raxNext(raxIterator *it) {
    if (!raxIteratorNextStep(it,0)) {
        errno = ENOMEM;
        return 0;
    }
    if (it->flags & RAX_ITER_EOF) {
        errno = 0;
        return 0;
    }
    return 1;
}",1675.0,1685.0,1.0,20.0,11.0,6,5,5,3,18,2,3,3,2,1,,0,2,2,1,1,int
3761,250892,raxPrev,1,raxPrev,int raxPrev (raxIterator*),rax.c,"int raxPrev(raxIterator *it) {
    if (!raxIteratorPrevStep(it,0)) {
        errno = ENOMEM;
        return 0;
    }
    if (it->flags & RAX_ITER_EOF) {
        errno = 0;
        return 0;
    }
    return 1;
}",1690.0,1700.0,1.0,20.0,11.0,6,5,5,3,2,2,3,3,2,1,,0,2,2,1,1,int
3762,250926,raxRandomWalk,1,raxRandomWalk,"int raxRandomWalk (raxIterator*,size_t)",rax.c,"int raxRandomWalk(raxIterator *it, size_t steps) {
    if (it->rt->numele == 0) {
        it->flags |= RAX_ITER_EOF;
        return 0;
    }

    if (steps == 0) {
        size_t fle = 1+floor(log(it->rt->numele));
        fle *= 2;
        steps = 1 + rand() % fle;
    }

    raxNode *n = it->node;
    while(steps > 0 || !n->iskey) {
        int numchildren = n->iscompr ? 1 : n->size;
        int r = rand() % (numchildren+(n != it->rt->head));

        if (r == numchildren) {
            /* Go up to parent. */
            n = raxStackPop(&it->stack);
            int todel = n->iscompr ? n->size : 1;
            raxIteratorDelChars(it,todel);
        } else {
            /* Select a random child. */
            if (n->iscompr) {
                if (!raxIteratorAddChars(it,n->data,n->size)) return 0;
            } else {
                if (!raxIteratorAddChars(it,n->data+r,1)) return 0;
            }
            raxNode **cp = raxNodeFirstChildPtr(n)+r;
            if (!raxStackPush...",1714.0,1752.0,1.0,21.0,39.0,45,14,34,7,0,18,6,8,3,3,,0,17,4,2,2,int
3763,251154,raxCompare,1,raxCompare,"int raxCompare (raxIterator*,char*,unsigned char*,size_t)",rax.c,"int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key_len) {
    int eq = 0, lt = 0, gt = 0;

    if (op[0] == '=' || op[1] == '=') eq = 1;
    if (op[0] == '>') gt = 1;
    else if (op[0] == '<') lt = 1;
    else if (op[1] != '=') return 0; /* Syntax error. */

    size_t minlen = key_len < iter->key_len ? key_len : iter->key_len;
    int cmp = memcmp(iter->key,key,minlen);

    /* Handle == */
    if (lt == 0 && gt == 0) return cmp == 0 && key_len == iter->key_len;

    /* Handle >, >=, <, <= */
    if (cmp == 0) {
        /* Same prefix: longer wins. */
        if (eq && key_len == iter->key_len) return 1;
        else if (lt) return iter->key_len < key_len;
        else if (gt) return iter->key_len > key_len;
        else return 0; /* Avoid warning, just 'eq' is handled before. */
    } else if (cmp > 0) {
        return gt ? 1 : 0;
    } else /* (cmp < 0) */ {
        return lt ? 1 : 0;
    }
}",1757.0,1783.0,1.0,1.0,27.0,30,8,26,9,2,5,6,7,1,0,,0,5,8,4,4,int
3764,251325,raxStop,1,raxStop,void raxStop (raxIterator*),rax.c,"void raxStop(raxIterator *it) {
    if (it->key != it->key_static_string) rax_free(it->key);
    raxStackFree(&it->stack);
}",1786.0,1789.0,1.0,42.0,4.0,6,3,4,1,32,6,2,2,2,2,,0,4,2,1,1,void
3765,251350,raxEOF,1,raxEOF,int raxEOF (raxIterator*),rax.c,"int raxEOF(raxIterator *it) {
    return it->flags & RAX_ITER_EOF;
}",1795.0,1797.0,1.0,23.0,3.0,3,3,1,1,3,1,1,1,0,0,,0,1,2,1,1,int
3766,251365,raxSize,1,raxSize,uint64_t raxSize (rax*),rax.c,"uint64_t raxSize(rax *rax) {
    return rax->numele;
}",1800.0,1802.0,1.0,1.0,3.0,1,1,1,1,16,1,1,1,0,0,,0,1,2,1,1,uint64_t
3767,251374,raxRecursiveShow,1,raxRecursiveShow,"void raxRecursiveShow (int,int,raxNode*)",rax.c,"void raxRecursiveShow(int level, int lpad, raxNode *n) {
    char s = n->iscompr ? '""' : '[';
    char e = n->iscompr ? '""' : ']';

    int numchars = printf(""%c%.*s%c"", s, n->size, n->data, e);
    if (n->iskey) {
        numchars += printf(""=%p"",raxGetData(n));
    }

    int numchildren = n->iscompr ? 1 : n->size;
    /* Note that 7 and 4 magic constants are the string length
     * of "" `-(x) "" and "" -> "" respectively. */
    if (level) {
        lpad += (numchildren > 1) ? 7 : 4;
        if (numchildren == 1) lpad += numchars;
    }
    raxNode **cp = raxNodeFirstChildPtr(n);
    for (int i = 0; i < numchildren; i++) {
        char *branch = "" `-(%c) "";
        if (numchildren > 1) {
            printf(""\n"");
            for (int j = 0; j < lpad; j++) putchar(' ');
            printf(branch,n->data[i]);
        } else {
            printf("" -> "");
        }
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        raxRecursiveShow(level+1,lpad,child);
        cp+...",1832.0,1863.0,1.0,19.0,32.0,47,16,47,13,1,12,7,11,1,1,,0,11,6,3,3,void
3768,251547,raxShow,1,raxShow,void raxShow (rax*),rax.c,"void raxShow(rax *rax) {
    raxRecursiveShow(0,0,rax->head);
    putchar('\n');
}",1866.0,1869.0,1.0,1.0,4.0,1,1,1,1,0,2,1,1,0,1,,0,1,2,1,1,void
3769,251707,raxTouch,1,raxTouch,unsigned long raxTouch (raxNode*),rax.c,"unsigned long raxTouch(raxNode *n) {
    debugf(""Touching %p\n"", (void*)n);
    unsigned long sum = 0;
    if (n->iskey) {
        sum += (unsigned long)raxGetData(n);
    }

    int numchildren = n->iscompr ? 1 : n->size;
    raxNode **cp = raxNodeFirstChildPtr(n);
    int count = 0;
    for (int i = 0; i < numchildren; i++) {
        if (numchildren > 1) {
            sum += (long)n->data[i];
        }
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        if (child == (void*)0x65d1760) count++;
        if (count > 1) exit(1);
        sum += raxTouch(child);
        cp++;
    }
    return sum;
}",1905.0,1927.0,1.0,4.0,23.0,39,16,33,8,0,8,6,9,1,1,,0,7,2,1,1,unsigned long
3770,252072,rdbCheckError,1,rdbCheckError,void rdbCheckError (char*...),redis-check-rdb.c,"void rdbCheckError(const char *fmt, ...) {
    char msg[1024];
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    printf(""--- RDB ERROR DETECTED ---\n"");
    printf(""[offset %llu] %s\n"",
        (unsigned long long) (rdbstate.rio ?
            rdbstate.rio->processed_bytes : 0), msg);
    printf(""[additional info] While doing: %s\n"",
        rdb_check_doing_string[rdbstate.doing]);
    if (rdbstate.key)
        printf(""[additional info] Reading key '%s'\n"",
            (char*)rdbstate.key->ptr);
    if (rdbstate.key_type != -1)
        printf(""[additional info] Reading type %d (%s)\n"",
            rdbstate.key_type,
            ((unsigned)rdbstate.key_type <
             sizeof(rdb_type_string)/sizeof(char*)) ?
                rdb_type_string[rdbstate.key_type] : ""unknown"");
    rdbShowGenericInfo();
}",113.0,137.0,1.0,1.0,25.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
3771,252082,rdbReportError,1,rdbReportError,"void rdbReportError (int,int,char*...)",rdb.c,"void rdbReportError(int corruption_error, int linenum, char *reason, ...) {
    va_list ap;
    char msg[1024];
    int len;

    len = snprintf(msg,sizeof(msg),
        ""Internal error in RDB reading offset %llu, function at rdb.c:%d -> "",
        (unsigned long long)server.loading_loaded_bytes, linenum);
    va_start(ap,reason);
    vsnprintf(msg+len,sizeof(msg)-len,reason,ap);
    va_end(ap);

    if (isRestoreContext()) {
        /* If we're in the context of a RESTORE command, just propagate the error. */
        /* log in VERBOSE, and return (don't exit). */
        serverLog(LL_VERBOSE, ""%s"", msg);
        return;
    } else if (rdbCheckMode) {
        /* If we're inside the rdb checker, let it handle the error. */
        rdbCheckError(""%s"",msg);
    } else if (rdbFileBeingLoaded) {
        /* If we're loading an rdb file form disk, run rdb check (and exit) */
        serverLog(LL_WARNING, ""%s"", msg);
        char *argv[2] = {"""",rdbFileBeingLoaded};
        if (anetIsFifo(ar...",67.0,108.0,1.0,8.0,42.0,20,12,21,8,4,2,2,2,0,2,,0,0,6,3,3,void
3772,252280,rdbWriteRaw,1,rdbWriteRaw,"ssize_t rdbWriteRaw (rio*,void*,size_t)",rdb.c,"ssize_t rdbWriteRaw(rio *rdb, void *p, size_t len) {
    if (rdb && rioWrite(rdb,p,len) == 0)
        return -1;
    return len;
}",110.0,114.0,1.0,1.0,5.0,3,3,5,3,15,1,2,2,1,1,,0,1,6,3,3,ssize_t
3773,252302,rdbSaveType,1,rdbSaveType,"int rdbSaveType (rio*,unsigned char)",rdb.c,"int rdbSaveType(rio *rdb, unsigned char type) {
    return rdbWriteRaw(rdb,&type,1);
}",116.0,118.0,1.0,1.0,3.0,1,1,2,2,16,1,1,1,0,1,,0,0,4,2,2,int
3774,252314,rdbLoadType,1,rdbLoadType,int rdbLoadType (rio*),rdb.c,"int rdbLoadType(rio *rdb) {
    unsigned char type;
    if (rioRead(rdb,&type,1) == 0) return -1;
    return type;
}",123.0,127.0,1.0,1.0,5.0,3,3,3,2,4,1,2,2,1,1,,0,1,2,1,1,int
3775,252334,rdbLoadTime,1,rdbLoadTime,time_t rdbLoadTime (rio*),rdb.c,"time_t rdbLoadTime(rio *rdb) {
    int32_t t32;
    if (rioRead(rdb,&t32,4) == 0) return -1;
    return (time_t)t32;
}",134.0,138.0,1.0,1.0,5.0,4,4,3,2,2,1,2,2,1,1,,0,1,2,1,1,time_t
3776,252356,rdbSaveMillisecondTime,1,rdbSaveMillisecondTime,"int rdbSaveMillisecondTime (rio*,long long)",rdb.c,"int rdbSaveMillisecondTime(rio *rdb, long long t) {
    int64_t t64 = (int64_t) t;
    memrev64ifbe(&t64); /* Store in little endian. */
    return rdbWriteRaw(rdb,&t64,8);
}",140.0,144.0,1.0,4.0,5.0,5,3,6,3,4,2,1,1,0,2,,0,0,4,2,2,int
3777,252381,rdbLoadMillisecondTime,1,rdbLoadMillisecondTime,"long long rdbLoadMillisecondTime (rio*,int)",rdb.c,"long long rdbLoadMillisecondTime(rio *rdb, int rdbver) {
    int64_t t64;
    if (rioRead(rdb,&t64,8) == 0) return LLONG_MAX;
    if (rdbver >= 9) /* Check the top comment of this function. */
        memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */
    return (long long)t64;
}",161.0,167.0,1.0,8.0,7.0,6,4,7,4,0,2,3,3,1,2,,0,1,4,2,2,long long
3778,252415,rdbSaveLen,1,rdbSaveLen,"int rdbSaveLen (rio*,uint64_t)",rdb.c,"int rdbSaveLen(rio *rdb, uint64_t len) {
    unsigned char buf[2];
    size_t nwritten;

    if (len < (1<<6)) {
        /* Save a 6 bit len */
        buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        nwritten = 1;
    } else if (len < (1<<14)) {
        /* Save a 14 bit len */
        buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
        buf[1] = len&0xFF;
        if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
        nwritten = 2;
    } else if (len <= UINT32_MAX) {
        /* Save a 32 bit len */
        buf[0] = RDB_32BITLEN;
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        uint32_t len32 = htonl(len);
        if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
        nwritten = 1+4;
    } else {
        /* Save a 64 bit len */
        buf[0] = RDB_64BITLEN;
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        len = htonu64(len);
        if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
        nwritten = 1+8;
    }
    ...",172.0,203.0,1.0,29.0,32.0,11,8,7,4,20,1,3,4,1,1,,0,1,4,2,2,int
3779,252601,rdbLoadLenByRef,1,rdbLoadLenByRef,"int rdbLoadLenByRef (rio*,int*,uint64_t*)",rdb.c,"int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
    unsigned char buf[2];
    int type;

    if (isencoded) *isencoded = 0;
    if (rioRead(rdb,buf,1) == 0) return -1;
    type = (buf[0]&0xC0)>>6;
    if (type == RDB_ENCVAL) {
        /* Read a 6 bit encoding type. */
        if (isencoded) *isencoded = 1;
        *lenptr = buf[0]&0x3F;
    } else if (type == RDB_6BITLEN) {
        /* Read a 6 bit len. */
        *lenptr = buf[0]&0x3F;
    } else if (type == RDB_14BITLEN) {
        /* Read a 14 bit len. */
        if (rioRead(rdb,buf+1,1) == 0) return -1;
        *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
    } else if (buf[0] == RDB_32BITLEN) {
        /* Read a 32 bit len. */
        uint32_t len;
        if (rioRead(rdb,&len,4) == 0) return -1;
        *lenptr = ntohl(len);
    } else if (buf[0] == RDB_64BITLEN) {
        /* Read a 64 bit len. */
        uint64_t len;
        if (rioRead(rdb,&len,8) == 0) return -1;
        *lenptr = ntohu64(len);
    } else {
       ...",215.0,249.0,1.0,16.0,35.0,15,7,11,5,3,1,5,6,1,1,,0,1,6,3,3,int
3780,252787,rdbLoadLen,1,rdbLoadLen,"uint64_t rdbLoadLen (rio*,int*)",rdb.c,"uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
    uint64_t len;

    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
    return len;
}",255.0,260.0,1.0,58.0,6.0,3,3,5,4,8,1,2,2,1,1,,0,1,4,2,2,uint64_t
3781,252810,rdbEncodeInteger,1,rdbEncodeInteger,"int rdbEncodeInteger (long long,unsigned char*)",rdb.c,"int rdbEncodeInteger(long long value, unsigned char *enc) {
    if (value >= -(1<<7) && value <= (1<<7)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;
        enc[1] = value&0xFF;
        return 2;
    } else if (value >= -(1<<15) && value <= (1<<15)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
        enc[1] = value&0xFF;
        enc[2] = (value>>8)&0xFF;
        return 3;
    } else if (value >= -((long long)1<<31) && value <= ((long long)1<<31)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;
        enc[1] = value&0xFF;
        enc[2] = (value>>8)&0xFF;
        enc[3] = (value>>16)&0xFF;
        enc[4] = (value>>24)&0xFF;
        return 5;
    } else {
        return 0;
    }
}",266.0,286.0,1.0,18.0,21.0,14,10,5,2,2,0,2,2,0,0,,0,0,4,2,2,int
3782,252978,rdbLoadIntegerObject,1,rdbLoadIntegerObject,"void* rdbLoadIntegerObject (rio*,int,int,size_t*)",rdb.c,"void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    int encode = flags & RDB_LOAD_ENC;
    unsigned char enc[4];
    long long val;

    if (enctype == RDB_ENC_INT8) {
        if (rioRead(rdb,enc,1) == 0) return NULL;
        val = (signed char)enc[0];
    } else if (enctype == RDB_ENC_INT16) {
        uint16_t v;
        if (rioRead(rdb,enc,2) == 0) return NULL;
        v = ((uint32_t)enc[0])|
            ((uint32_t)enc[1]<<8);
        val = (int16_t)v;
    } else if (enctype == RDB_ENC_INT32) {
        uint32_t v;
        if (rioRead(rdb,enc,4) == 0) return NULL;
        v = ((uint32_t)enc[0])|
            ((uint32_t)enc[1]<<8)|
            ((uint32_t)enc[2]<<16)|
            ((uint32_t)enc[3]<<24);
        val = (int32_t)v;
    } else {
        rdbReportCorruptRDB(""Unknown RDB integer encoding type %d"",enctype);
        return NULL; /* Never reached. */
    }
    if (plain |...",291.0,331.0,1.0,24.0,41.0,21,10,30,14,1,4,5,7,1,4,,0,4,8,4,4,void*
3783,253199,rdbTryIntegerEncoding,1,rdbTryIntegerEncoding,"int rdbTryIntegerEncoding (char*,size_t,unsigned char*)",rdb.c,"int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
    long long value;
    if (string2ll(s, len, &value)) {
        return rdbEncodeInteger(value, enc);
    } else {
        return 0;
    }
}",336.0,343.0,1.0,1.0,8.0,1,1,5,4,1,2,2,2,1,2,,0,1,6,3,3,int
3784,253222,rdbSaveLzfBlob,1,rdbSaveLzfBlob,"ssize_t rdbSaveLzfBlob (rio*,void*,size_t,size_t)",rdb.c,"ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
                       size_t original_len) {
    unsigned char byte;
    ssize_t n, nwritten = 0;

    /* Data compressed! Let's save it on disk */
    byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;
    if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
    nwritten += n;

    return nwritten;

writeerr:
    return -1;
}",345.0,368.0,1.0,12.0,24.0,22,7,24,7,1,4,9,5,4,4,,0,4,8,4,4,ssize_t
3785,253312,rdbSaveLzfStringObject,1,rdbSaveLzfStringObject,"ssize_t rdbSaveLzfStringObject (rio*,unsigned char*,size_t)",rdb.c,"ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
    size_t comprlen, outlen;
    void *out;

    /* We require at least four bytes compression for this to be worth it */
    if (len <= 4) return 0;
    outlen = len-4;
    if ((out = zmalloc(outlen+1)) == NULL) return 0;
    comprlen = lzf_compress(s, len, out, outlen);
    if (comprlen == 0) {
        zfree(out);
        return 0;
    }
    ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
    zfree(out);
    return nwritten;
}",370.0,386.0,1.0,1.0,17.0,9,5,20,8,1,5,4,4,1,5,,0,3,6,3,3,ssize_t
3786,253374,rdbLoadLzfStringObject,1,rdbLoadLzfStringObject,"void* rdbLoadLzfStringObject (rio*,int,size_t*)",rdb.c,"void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    uint64_t len, clen;
    unsigned char *c = NULL;
    char *val = NULL;

    if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
    if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
    if ((c = ztrymalloc(clen)) == NULL) {
        serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbLoadLzfStringObject failed allocating %llu bytes"", (unsigned long long)clen);
        goto err;
    }

    /* Allocate our target according to the uncompressed size. */
    if (plain) {
        val = ztrymalloc(len);
    } else {
        val = sdstrynewlen(SDS_NOINIT,len);
    }
    if (!val) {
        serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbLoadLzfStringObject failed allocating %llu bytes"", (unsigned long long)len);
        goto err;
    }

    if (lenptr) *lenptr = len;

    /* Load the compressed representation ...",391.0,438.0,1.0,24.0,48.0,61,13,64,12,1,12,15,11,5,12,,0,6,6,3,3,void*
3787,253642,rdbSaveRawString,1,rdbSaveRawString,"ssize_t rdbSaveRawString (rio*,unsigned char*,size_t)",rdb.c,"ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
    int enclen;
    ssize_t n, nwritten = 0;

    /* Try integer encoding */
    if (len <= 11) {
        unsigned char buf[5];
        if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
            return enclen;
        }
    }

    /* Try LZF compression - under 20 bytes it's unable to compress even
     * aaaaaaaaaaaaaaaaaa so skip it */
    if (server.rdb_compression && len > 20) {
        n = rdbSaveLzfStringObject(rdb,s,len);
        if (n == -1) return -1;
        if (n > 0) return n;
        /* Return value of 0 means data can't be compressed, save the old way */
    }

    /* Store verbatim */
    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
    nwritten += n;
    if (len > 0) {
        if (rdbWriteRaw(rdb,s,len) == -1) return -1;
        nwritten += len;
    }
    return nwritten;
}",442.0,472.0,1.0,1.0,31.0,26,9,31,8,5,5,10,16,4,5,,0,5,6,3,3,ssize_t
3788,253756,rdbSaveLongLongAsStringObject,1,rdbSaveLongLongAsStringObject,"ssize_t rdbSaveLongLongAsStringObject (rio*,long long)",rdb.c,"ssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {
    unsigned char buf[32];
    ssize_t n, nwritten = 0;
    int enclen = rdbEncodeInteger(value,buf);
    if (enclen > 0) {
        return rdbWriteRaw(rdb,buf,enclen);
    } else {
        /* Encode as string */
        enclen = ll2string((char*)buf,32,value);
        serverAssert(enclen < 32);
        if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
        nwritten += n;
        if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
        nwritten += n;
    }
    return nwritten;
}",475.0,491.0,1.0,8.0,17.0,3,2,9,5,1,2,2,2,0,2,,0,1,4,2,2,ssize_t
3789,253845,rdbSaveStringObject,1,rdbSaveStringObject,"ssize_t rdbSaveStringObject (rio*,robj*)",rdb.c,"ssize_t rdbSaveStringObject(rio *rdb, robj *obj) {
    /* Avoid to decode the object, then encode it again, if the
     * object is already integer encoded. */
    if (obj->encoding == OBJ_ENCODING_INT) {
        return rdbSaveLongLongAsStringObject(rdb,(long)obj->ptr);
    } else {
        serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
        return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
    }
}",494.0,503.0,1.0,25.0,10.0,4,3,3,2,3,1,2,2,0,1,,0,0,4,2,2,ssize_t
3790,253908,rdbGenericLoadStringObject,1,rdbGenericLoadStringObject,"void* rdbGenericLoadStringObject (rio*,int,size_t*)",rdb.c,"void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    int isencoded;
    unsigned long long len;

    len = rdbLoadLen(rdb,&isencoded);
    if (len == RDB_LENERR) return NULL;

    if (isencoded) {
        switch(len) {
        case RDB_ENC_INT8:
        case RDB_ENC_INT16:
        case RDB_ENC_INT32:
            return rdbLoadIntegerObject(rdb,len,flags,lenptr);
        case RDB_ENC_LZF:
            return rdbLoadLzfStringObject(rdb,flags,lenptr);
        default:
            rdbReportCorruptRDB(""Unknown RDB string encoding type %llu"",len);
            return NULL;
        }
    }

    if (plain || sds) {
        void *buf = plain ? ztrymalloc(len) : sdstrynewlen(SDS_NOINIT,len);
        if (!buf) {
            serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbGenericLoadStringObject failed allocating %llu bytes"", len);
            return NULL;
        }
        if (lenptr) *le...",518.0,568.0,1.0,24.0,51.0,36,13,51,12,5,9,9,15,1,9,,0,4,6,3,3,void*
3791,254188,rdbLoadStringObject,1,rdbLoadStringObject,robj rdbLoadStringObject (rio*),rdb.c,"robj *rdbLoadStringObject(rio *rdb) {
    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
}",570.0,572.0,1.0,42.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,robj
3792,254200,rdbLoadEncodedStringObject,1,rdbLoadEncodedStringObject,robj rdbLoadEncodedStringObject (rio*),rdb.c,"robj *rdbLoadEncodedStringObject(rio *rdb) {
    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
}",574.0,576.0,1.0,42.0,3.0,1,1,2,2,1,1,1,1,0,1,,0,0,2,1,1,robj
3793,254214,rdbSaveDoubleValue,1,rdbSaveDoubleValue,"int rdbSaveDoubleValue (rio*,double)",rdb.c,"int rdbSaveDoubleValue(rio *rdb, double val) {
    unsigned char buf[128];
    int len;

    if (isnan(val)) {
        buf[0] = 253;
        len = 1;
    } else if (!isfinite(val)) {
        len = 1;
        buf[0] = (val < 0) ? 255 : 254;
    } else {
        long long lvalue;
        /* Integer printing function is much faster, check if we can safely use it. */
        if (double2ll(val, &lvalue))
            ll2string((char*)buf+1,sizeof(buf)-1,lvalue);
        else {
            const int dlen = fpconv_dtoa(val, (char*)buf+1);
            buf[dlen+1] = '\0';
        }
        buf[0] = strlen((char*)buf+1);
        len = buf[0]+1;
    }
    return rdbWriteRaw(rdb,buf,len);
}",586.0,609.0,1.0,1.0,24.0,3,2,6,4,0,1,2,2,0,1,,0,0,4,2,2,int
3794,254315,rdbLoadDoubleValue,1,rdbLoadDoubleValue,"int rdbLoadDoubleValue (rio*,double*)",rdb.c,"int rdbLoadDoubleValue(rio *rdb, double *val) {
    char buf[256];
    unsigned char len;

    if (rioRead(rdb,&len,1) == 0) return -1;
    switch(len) {
    case 255: *val = R_NegInf; return 0;
    case 254: *val = R_PosInf; return 0;
    case 253: *val = R_Nan; return 0;
    default:
        if (rioRead(rdb,buf,len) == 0) return -1;
        buf[len] = '\0';
        if (sscanf(buf, ""%lg"", val)!=1) return -1;
        return 0;
    }
}",612.0,627.0,1.0,1.0,16.0,15,7,16,7,0,2,5,7,2,2,,0,2,4,2,2,int
3795,254392,rdbSaveBinaryDoubleValue,1,rdbSaveBinaryDoubleValue,"int rdbSaveBinaryDoubleValue (rio*,double)",rdb.c,"int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
    memrev64ifbe(&val);
    return rdbWriteRaw(rdb,&val,sizeof(val));
}",634.0,637.0,1.0,4.0,4.0,4,2,5,2,1,2,1,1,0,2,,0,0,4,2,2,int
3796,254412,rdbLoadBinaryDoubleValue,1,rdbLoadBinaryDoubleValue,"int rdbLoadBinaryDoubleValue (rio*,double*)",rdb.c,"int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
    memrev64ifbe(val);
    return 0;
}",641.0,645.0,1.0,4.0,5.0,4,4,5,2,1,2,2,2,1,2,,0,1,4,2,2,int
3797,254438,rdbSaveBinaryFloatValue,1,rdbSaveBinaryFloatValue,"int rdbSaveBinaryFloatValue (rio*,float)",rdb.c,"int rdbSaveBinaryFloatValue(rio *rdb, float val) {
    memrev32ifbe(&val);
    return rdbWriteRaw(rdb,&val,sizeof(val));
}",648.0,651.0,1.0,4.0,4.0,4,2,5,2,1,2,1,1,0,2,,0,0,4,2,2,int
3798,254458,rdbLoadBinaryFloatValue,1,rdbLoadBinaryFloatValue,"int rdbLoadBinaryFloatValue (rio*,float*)",rdb.c,"int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
    memrev32ifbe(val);
    return 0;
}",654.0,658.0,1.0,4.0,5.0,4,4,5,2,1,2,2,2,1,2,,0,1,4,2,2,int
3799,254484,rdbSaveObjectType,1,rdbSaveObjectType,"int rdbSaveObjectType (rio*,robj*)",rdb.c,"int rdbSaveObjectType(rio *rdb, robj *o) {
    switch (o->type) {
    case OBJ_STRING:
        return rdbSaveType(rdb,RDB_TYPE_STRING);
    case OBJ_LIST:
        if (o->encoding == OBJ_ENCODING_QUICKLIST || o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb, RDB_TYPE_LIST_QUICKLIST_2);
        else
            serverPanic(""Unknown list encoding"");
    case OBJ_SET:
        if (o->encoding == OBJ_ENCODING_INTSET)
            return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);
        else if (o->encoding == OBJ_ENCODING_HT)
            return rdbSaveType(rdb,RDB_TYPE_SET);
        else if (o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb,RDB_TYPE_SET_LISTPACK);
        else
            serverPanic(""Unknown set encoding"");
    case OBJ_ZSET:
        if (o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb,RDB_TYPE_ZSET_LISTPACK);
        else if (o->encoding == OBJ_ENCODING_SKIPLIST)
            return rdbSaveType(rdb,RDB_TYP...",661.0,701.0,1.0,9.0,41.0,14,5,13,2,2,8,6,10,0,8,,0,0,4,2,2,int
3800,254729,rdbLoadObjectType,1,rdbLoadObjectType,int rdbLoadObjectType (rio*),rdb.c,"int rdbLoadObjectType(rio *rdb) {
    int type;
    if ((type = rdbLoadType(rdb)) == -1) return -1;
    if (!rdbIsObjectType(type)) return -1;
    return type;
}",705.0,710.0,1.0,9.0,6.0,13,8,8,2,1,1,3,3,1,1,,0,1,2,1,1,int
3801,254773,rdbSaveStreamPEL,1,rdbSaveStreamPEL,"ssize_t rdbSaveStreamPEL (rio*,rax*,int)",rdb.c,"ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
    ssize_t n, nwritten = 0;

    /* Number of entries in the PEL. */
    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
    nwritten += n;

    /* Save each entry. */
    raxIterator ri;
    raxStart(&ri,pel);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        /* We store IDs in raw form as 128 big big endian numbers, like
         * they are inside the radix tree key. */
        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        if (nacks) {
            streamNACK *nack = ri.data;
            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1) {
                raxStop(&ri);
                return -1;
            }
            nwritten += n;
            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) {
                raxStop(&ri);
                return -1;
            }
            n...",719.0,758.0,1.0,1.0,40.0,34,8,35,9,1,16,7,13,9,12,,0,10,6,3,3,ssize_t
3802,254897,rdbSaveStreamConsumers,1,rdbSaveStreamConsumers,"size_t rdbSaveStreamConsumers (rio*,streamCG*)",rdb.c,"size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
    ssize_t n, nwritten = 0;

    /* Number of consumers in this consumer group. */
    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
    nwritten += n;

    /* Save each consumer. */
    raxIterator ri;
    raxStart(&ri,cg->consumers);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        streamConsumer *consumer = ri.data;

        /* Consumer name. */
        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Seen time. */
        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Active time. */
        if ((n = rdbSaveMillisecondTime(rdb,consumer->active_time)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Consumer PEL, without t...",763.0,810.0,1.0,1.0,48.0,43,7,40,7,0,22,7,11,13,14,,0,15,4,2,2,size_t
3803,255044,rdbSaveObject,1,rdbSaveObject,"ssize_t rdbSaveObject (rio*,robj*,robj*,int)",rdb.c,"ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key, int dbid) {
    ssize_t n = 0, nwritten = 0;

    if (o->type == OBJ_STRING) {
        /* Save a string value */
        if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
        nwritten += n;
    } else if (o->type == OBJ_LIST) {
        /* Save a list value */
        if (o->encoding == OBJ_ENCODING_QUICKLIST) {
            quicklist *ql = o->ptr;
            quicklistNode *node = ql->head;

            if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
            nwritten += n;

            while(node) {
                if ((n = rdbSaveLen(rdb,node->container)) == -1) return -1;
                nwritten += n;

                if (quicklistNodeIsCompressed(node)) {
                    void *data;
                    size_t compress_len = quicklistGetLzf(node, &data);
                    if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
                    nwritten += n;
                } else {
  ...",814.0,1110.0,1.0,19.0,297.0,9,5,9,4,3,1,3,4,1,1,,0,1,8,4,4,ssize_t
3804,256451,rdbSavedObjectLen,1,rdbSavedObjectLen,"size_t rdbSavedObjectLen (robj*,robj*,int)",rdb.c,"size_t rdbSavedObjectLen(robj *o, robj *key, int dbid) {
    ssize_t len = rdbSaveObject(NULL,o,key,dbid);
    serverAssertWithInfo(NULL,o,len != -1);
    return len;
}",1116.0,1120.0,1.0,4.0,5.0,7,7,11,5,0,2,1,1,0,2,,0,1,6,3,3,size_t
3805,256489,rdbSaveKeyValuePair,1,rdbSaveKeyValuePair,"int rdbSaveKeyValuePair (rio*,robj*,robj*,long long,int)",rdb.c,"int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, int dbid) {
    int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;
    int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;

    /* Save the expire time */
    if (expiretime != -1) {
        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
    }

    /* Save the LRU info. */
    if (savelru) {
        uint64_t idletime = estimateObjectIdleTime(val);
        idletime /= 1000; /* Using seconds is enough and requires less space.*/
        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
        if (rdbSaveLen(rdb,idletime) == -1) return -1;
    }

    /* Save the LFU info. */
    if (savelfu) {
        uint8_t buf[1];
        buf[0] = LFUDecrAndReturn(val);
        /* We can encode this in exactly two bytes: the opcode and an 8
         * bit counter, since the frequency is logarithmic with a 0-255 range...",1125.0,1165.0,1.0,44.0,41.0,43,9,31,10,1,12,14,20,9,12,,0,11,10,5,5,int
3806,256668,rdbSaveAuxField,1,rdbSaveAuxField,"ssize_t rdbSaveAuxField (rio*,void*,size_t,void*,size_t)",rdb.c,"ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
    ssize_t ret, len = 0;
    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
    len += ret;
    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
    len += ret;
    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
    len += ret;
    return len;
}",1168.0,1177.0,1.0,31.0,10.0,16,4,18,7,2,3,4,4,3,3,,0,3,10,5,5,ssize_t
3807,256736,rdbSaveAuxFieldStrStr,1,rdbSaveAuxFieldStrStr,"ssize_t rdbSaveAuxFieldStrStr (rio*,char*,char*)",rdb.c,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}",1181.0,1183.0,1.0,1.0,3.0,0,0,5,3,2,1,1,1,0,1,,0,0,6,3,3,ssize_t
3808,256752,rdbSaveAuxFieldStrInt,1,rdbSaveAuxFieldStrInt,"ssize_t rdbSaveAuxFieldStrInt (rio*,char*,long long)",rdb.c,"ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {
    char buf[LONG_STR_SIZE];
    int vlen = ll2string(buf,sizeof(buf),val);
    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
}",1186.0,1190.0,1.0,13.0,5.0,2,2,9,5,6,2,1,1,0,2,,0,1,6,3,3,ssize_t
3809,256776,rdbSaveInfoAuxFields,1,rdbSaveInfoAuxFields,"int rdbSaveInfoAuxFields (rio*,int,rdbSaveInfo*)",rdb.c,"int rdbSaveInfoAuxFields(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
    int aof_base = (rdbflags & RDBFLAGS_AOF_PREAMBLE) != 0;

    /* Add a few fields about the state when the RDB was created. */
    if (rdbSaveAuxFieldStrStr(rdb,""redis-ver"",REDIS_VERSION) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""redis-bits"",redis_bits) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""ctime"",time(NULL)) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""used-mem"",zmalloc_used_memory()) == -1) return -1;

    /* Handle saving options that generate aux fields. */
    if (rsi) {
        if (rdbSaveAuxFieldStrInt(rdb,""repl-stream-db"",rsi->repl_stream_db)
            == -1) return -1;
        if (rdbSaveAuxFieldStrStr(rdb,""repl-id"",server.replid)
            == -1) return -1;
        if (rdbSaveAuxFieldStrInt(rdb,""repl-offset"",server.master_repl_offset)
            == -1) return -1;
    }
    if (rdbSaveAuxFieldStrInt(rdb, ""aof-bas...",1193.0,1214.0,1.0,31.0,22.0,35,10,19,8,1,10,10,13,10,9,,0,10,6,3,3,int
3810,256915,rdbSaveSingleModuleAux,1,rdbSaveSingleModuleAux,"ssize_t rdbSaveSingleModuleAux (rio*,int,moduleType*)",rdb.c,"ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
    /* Save a module-specific aux value. */
    RedisModuleIO io;
    int retval = 0;
    moduleInitIOContext(io,mt,rdb,NULL,-1);

    /* We save the AUX field header in a temporary buffer so we can support aux_save2 API.
     * If aux_save2 is used the buffer will be flushed at the first time the module will perform
     * a write operation to the RDB and will be ignored is case there was no writes. */
    rio aux_save_headers_rio;
    rioInitWithBuffer(&aux_save_headers_rio, sdsempty());

    if (rdbSaveType(&aux_save_headers_rio, RDB_OPCODE_MODULE_AUX) == -1) goto error;

    /* Write the ""module"" identifier as prefix, so that we'll be able
     * to call the right module during loading. */
    if (rdbSaveLen(&aux_save_headers_rio,mt->id) == -1) goto error;

    /* write the 'when' so that we can provide it on loading. add a UINT opcode
     * for backwards compatibility, everything after the MT needs to be pref...",1216.0,1277.0,1.0,4.0,62.0,68,11,47,7,1,32,14,11,7,12,,0,26,6,3,3,ssize_t
3811,257200,rdbSaveFunctions,1,rdbSaveFunctions,ssize_t rdbSaveFunctions (rio*),rdb.c,"ssize_t rdbSaveFunctions(rio *rdb) {
    dict *functions = functionsLibGet();
    dictIterator *iter = dictGetIterator(functions);
    dictEntry *entry = NULL;
    ssize_t written = 0;
    ssize_t ret;
    while ((entry = dictNext(iter))) {
        if ((ret = rdbSaveType(rdb, RDB_OPCODE_FUNCTION2)) < 0) goto werr;
        written += ret;
        functionLibInfo *li = dictGetVal(entry);
        if ((ret = rdbSaveRawString(rdb, (unsigned char *) li->code, sdslen(li->code))) < 0) goto werr;
        written += ret;
    }
    dictReleaseIterator(iter);
    return written;

werr:
    dictReleaseIterator(iter);
    return -1;
}",1279.0,1298.0,1.0,36.0,20.0,16,6,23,8,2,11,6,6,6,9,,0,9,2,1,1,ssize_t
3812,257280,rdbSaveDb,1,rdbSaveDb,"ssize_t rdbSaveDb (rio*,int,int,long*)",rdb.c,"ssize_t rdbSaveDb(rio *rdb, int dbid, int rdbflags, long *key_counter) {
    dictIterator *di;
    dictEntry *de;
    ssize_t written = 0;
    ssize_t res;
    static long long info_updated_time = 0;
    char *pname = (rdbflags & RDBFLAGS_AOF_PREAMBLE) ? ""AOF rewrite"" :  ""RDB"";

    redisDb *db = server.db + dbid;
    dict *d = db->dict;
    if (dictSize(d) == 0) return 0;
    di = dictGetSafeIterator(d);

    /* Write the SELECT DB opcode */
    if ((res = rdbSaveType(rdb,RDB_OPCODE_SELECTDB)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb, dbid)) < 0) goto werr;
    written += res;

    /* Write the RESIZE DB opcode. */
    uint64_t db_size, expires_size;
    db_size = dictSize(db->dict);
    expires_size = dictSize(db->expires);
    if ((res = rdbSaveType(rdb,RDB_OPCODE_RESIZEDB)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb,db_size)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb,expires_size)) < 0) goto werr;
    writte...",1300.0,1366.0,1.0,30.0,67.0,86,18,91,25,1,25,18,17,9,16,,0,21,8,4,4,ssize_t
3813,257597,rdbSaveRio,1,rdbSaveRio,"int rdbSaveRio (int,rio*,int*,int,rdbSaveInfo*)",rdb.c,"int rdbSaveRio(int req, rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) {
    char magic[10];
    uint64_t cksum;
    long key_counter = 0;
    int j;

    if (server.rdb_checksum)
        rdb->update_cksum = rioGenericUpdateChecksum;
    snprintf(magic,sizeof(magic),""REDIS%04d"",RDB_VERSION);
    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
    if (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == -1) goto werr;
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA) && rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;

    /* save functions */
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_FUNCTIONS) && rdbSaveFunctions(rdb) == -1) goto werr;

    /* save all databases, skip this if we're in functions-only mode */
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA)) {
        for (j = 0; j < server.dbnum; j++) {
            if (rdbSaveDb(rdb, j, rdbflags, &key_counter) == -1) goto werr;
        }
    }

    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA) && rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFT...",1376.0,1414.0,1.0,45.0,39.0,49,13,35,12,2,9,21,16,8,9,,0,8,10,5,5,int
3814,257797,rdbSaveRioWithEOFMark,1,rdbSaveRioWithEOFMark,"int rdbSaveRioWithEOFMark (int,rio*,int*,rdbSaveInfo*)",rdb.c,"int rdbSaveRioWithEOFMark(int req, rio *rdb, int *error, rdbSaveInfo *rsi) {
    char eofmark[RDB_EOF_MARK_SIZE];

    startSaving(RDBFLAGS_REPLICATION);
    getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
    if (error) *error = 0;
    if (rioWrite(rdb,""$EOF:"",5) == 0) goto werr;
    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
    if (rioWrite(rdb,""\r\n"",2) == 0) goto werr;
    if (rdbSaveRio(req,rdb,error,RDBFLAGS_NONE,rsi) == C_ERR) goto werr;
    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
    stopSaving(1);
    return C_OK;

werr: /* Write error. */
    /* Set 'error' only if not already set by rdbSaveRio() call. */
    if (error && *error == 0) *error = errno;
    stopSaving(0);
    return C_ERR;
}",1424.0,1443.0,1.0,17.0,20.0,15,6,17,6,1,9,13,8,5,9,,0,5,8,4,4,int
3815,257906,rdbSaveInternal,1,rdbSaveInternal,"int rdbSaveInternal (int,char*,rdbSaveInfo*,int)",rdb.c,"static int rdbSaveInternal(int req, const char *filename, rdbSaveInfo *rsi, int rdbflags) {
    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
    rio rdb;
    int error = 0;
    int saved_errno;
    char *err_op;    /* For a detailed log */

    FILE *fp = fopen(filename,""w"");
    if (!fp) {
        saved_errno = errno;
        char *str_err = strerror(errno);
        char *cwdp = getcwd(cwd,MAXPATHLEN);
        serverLog(LL_WARNING,
            ""Failed opening the temp RDB file %s (in server root dir %s) ""
            ""for saving: %s"",
            filename,
            cwdp ? cwdp : ""unknown"",
            str_err);
        errno = saved_errno;
        return C_ERR;
    }

    rioInitWithFile(&rdb,fp);

    if (server.rdb_save_incremental_fsync) {
        rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);
        if (!(rdbflags & RDBFLAGS_KEEP_CACHE)) rioSetReclaimCache(&rdb,1);
    }

    if (rdbSaveRio(req,&rdb,&error,rdbflags,rsi) == C_ERR) {
        errno = er...",1445.0,1497.0,1.0,8.0,53.0,46,12,54,16,2,8,14,11,2,8,,0,2,8,4,4,int
3816,258144,rdbSaveToFile,1,rdbSaveToFile,int rdbSaveToFile (char*),rdb.c,"int rdbSaveToFile(const char *filename) {
    startSaving(RDBFLAGS_NONE);

    if (rdbSaveInternal(SLAVE_REQ_NONE,filename,NULL,RDBFLAGS_NONE) != C_OK) {
        int saved_errno = errno;
        stopSaving(0);
        errno = saved_errno;
        return C_ERR;
    }

    stopSaving(1);
    return C_OK;
}",1501.0,1513.0,1.0,16.0,13.0,4,3,6,4,1,4,2,2,1,4,,0,1,2,1,1,int
3817,258188,rdbSave,1,rdbSave,"int rdbSave (int,char*,rdbSaveInfo*,int)",rdb.c,"int rdbSave(int req, char *filename, rdbSaveInfo *rsi, int rdbflags) {
    char tmpfile[256];
    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */

    startSaving(RDBFLAGS_NONE);
    snprintf(tmpfile,256,""temp-%d.rdb"", (int) getpid());

    if (rdbSaveInternal(req,tmpfile,rsi,rdbflags) != C_OK) {
        stopSaving(0);
        return C_ERR;
    }
    
    /* Use RENAME to make sure the DB file is changed atomically only
     * if the generate DB file is ok. */
    if (rename(tmpfile,filename) == -1) {
        char *str_err = strerror(errno);
        char *cwdp = getcwd(cwd,MAXPATHLEN);
        serverLog(LL_WARNING,
            ""Error moving temp DB file %s on the final ""
            ""destination %s (in server root dir %s): %s"",
            tmpfile,
            filename,
            cwdp ? cwdp : ""unknown"",
            str_err);
        unlink(tmpfile);
        stopSaving(0);
        return C_ERR;
    }
    if (fsyncFileDir(filename) != 0) {
        serverLog...",1516.0,1557.0,1.0,16.0,42.0,26,9,27,12,3,10,4,4,2,10,,0,2,8,4,4,int
3818,258355,rdbSaveBackground,1,rdbSaveBackground,"int rdbSaveBackground (int,char*,rdbSaveInfo*,int)",rdb.c,"int rdbSaveBackground(int req, char *filename, rdbSaveInfo *rsi, int rdbflags) {
    pid_t childpid;

    if (hasActiveChildProcess()) return C_ERR;
    server.stat_rdb_saves++;

    server.dirty_before_bgsave = server.dirty;
    server.lastbgsave_try = time(NULL);

    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {
        int retval;

        /* Child */
        redisSetProcTitle(""redis-rdb-bgsave"");
        redisSetCpuAffinity(server.bgsave_cpulist);
        retval = rdbSave(req, filename,rsi,rdbflags);
        if (retval == C_OK) {
            sendChildCowInfo(CHILD_INFO_TYPE_RDB_COW_SIZE, ""RDB"");
        }
        exitFromChild((retval == C_OK) ? 0 : 1);
    } else {
        /* Parent */
        if (childpid == -1) {
            server.lastbgsave_status = C_ERR;
            serverLog(LL_WARNING,""Can't save in background: fork: %s"",
                strerror(errno));
            return C_ERR;
        }
        serverLog(LL_NOTICE,""Background saving started by pid %ld"",(long) ...",1559.0,1593.0,1.0,40.0,35.0,15,6,15,9,1,7,4,5,2,7,,0,3,8,4,4,int
3819,258515,rdbRemoveTempFile,1,rdbRemoveTempFile,"void rdbRemoveTempFile (pid_t,int)",rdb.c,"void rdbRemoveTempFile(pid_t childpid, int from_signal) {
    char tmpfile[256];
    char pid[32];

    /* Generate temp rdb file name using async-signal safe functions. */
    ll2string(pid, sizeof(pid), childpid);
    redis_strlcpy(tmpfile, ""temp-"", sizeof(tmpfile));
    redis_strlcat(tmpfile, pid, sizeof(tmpfile));
    redis_strlcat(tmpfile, "".rdb"", sizeof(tmpfile));

    if (from_signal) {
        /* bg_unlink is not async-signal-safe, but in this case we don't really
         * need to close the fd, it'll be released when the process exists. */
        int fd = open(tmpfile, O_RDONLY|O_NONBLOCK);
        UNUSED(fd);
        unlink(tmpfile);
    } else {
        bg_unlink(tmpfile);
    }
}",1599.0,1618.0,1.0,8.0,20.0,7,4,18,7,1,4,2,2,0,4,,0,0,4,2,2,void
3820,258566,rdbLoadCheckModuleValue,1,rdbLoadCheckModuleValue,"robj rdbLoadCheckModuleValue (rio*,char*)",rdb.c,"robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
    uint64_t opcode;
    while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
        if (opcode == RDB_MODULE_OPCODE_SINT ||
            opcode == RDB_MODULE_OPCODE_UINT)
        {
            uint64_t len;
            if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
                rdbReportCorruptRDB(
                    ""Error reading integer from module %s value"", modulename);
            }
        } else if (opcode == RDB_MODULE_OPCODE_STRING) {
            robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
            if (o == NULL) {
                rdbReportCorruptRDB(
                    ""Error reading string from module %s value"", modulename);
            }
            decrRefCount(o);
        } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
            float val;
            if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
                rdbReportCorruptRDB(
                    ""Error reading fl...",1624.0,1657.0,1.0,45.0,34.0,8,6,9,5,0,4,4,7,2,4,,0,2,4,2,2,robj
3821,258703,_ziplistPairsEntryConvertAndValidate,1,_ziplistPairsEntryConvertAndValidate,"int _ziplistPairsEntryConvertAndValidate (unsigned char*,unsigned int,void*)",rdb.c,"static int _ziplistPairsEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    unsigned char *str;
    unsigned int slen;
    long long vll;

    struct {
        long count;
        dict *fields;
        unsigned char **lp;
    } *data = userdata;

    if (data->fields == NULL) {
        data->fields = dictCreate(&hashDictType);
        dictExpand(data->fields, head_count/2);
    }

    if (!ziplistGet(p, &str, &slen, &vll))
        return 0;

    /* Even records are field names, add to dict and check that's not a dup */
    if (((data->count) & 1) == 0) {
        sds field = str? sdsnewlen(str, slen): sdsfromlonglong(vll);
        if (dictAdd(data->fields, field, NULL) != DICT_OK) {
            /* Duplicate, return an error */
            sdsfree(field);
            return 0;
        }
    }

    if (str) {
        *(data->lp) = lpAppend(*(data->lp), (unsigned char*)str, slen);
    } else {
        *(data->lp) = lpAppendInteger(*(data->lp), vll);
...",1662.0,1699.0,1.0,50.0,38.0,27,12,28,10,0,8,6,7,2,8,,0,6,6,3,3,int
3822,258822,ziplistPairsConvertAndValidateIntegrity,1,ziplistPairsConvertAndValidateIntegrity,"int ziplistPairsConvertAndValidateIntegrity (unsigned char*,size_t,unsigned char**)",rdb.c,"int ziplistPairsConvertAndValidateIntegrity(unsigned char *zl, size_t size, unsigned char **lp) {
    /* Keep track of the field names to locate duplicate ones */
    struct {
        long count;
        dict *fields; /* Initialisation at the first callback. */
        unsigned char **lp;
    } data = {0, NULL, lp};

    int ret = ziplistValidateIntegrity(zl, size, 1, _ziplistPairsEntryConvertAndValidate, &data);

    /* make sure we have an even number of records. */
    if (data.count & 1)
        ret = 0;

    if (data.fields) dictRelease(data.fields);
    return ret;
}",1705.0,1721.0,1.0,1.0,17.0,9,5,12,6,0,2,3,3,0,2,,0,1,6,3,3,int
3823,258867,_ziplistEntryConvertAndValidate,1,_ziplistEntryConvertAndValidate,"int _ziplistEntryConvertAndValidate (unsigned char*,unsigned int,void*)",rdb.c,"static int _ziplistEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    UNUSED(head_count);
    unsigned char *str;
    unsigned int slen;
    long long vll;
    unsigned char **lp = (unsigned char**)userdata;

    if (!ziplistGet(p, &str, &slen, &vll)) return 0;

    if (str)
        *lp = lpAppend(*lp, (unsigned char*)str, slen);
    else
        *lp = lpAppendInteger(*lp, vll);

    return 1;
}",1725.0,1740.0,1.0,4.0,16.0,11,5,13,7,0,2,3,3,1,2,,0,2,6,3,3,int
3824,258926,_listZiplistEntryConvertAndValidate,1,_listZiplistEntryConvertAndValidate,"int _listZiplistEntryConvertAndValidate (unsigned char*,unsigned int,void*)",rdb.c,"static int _listZiplistEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    UNUSED(head_count);
    unsigned char *str;
    unsigned int slen;
    long long vll;
    char longstr[32] = {0};
    quicklist *ql = (quicklist*)userdata;

    if (!ziplistGet(p, &str, &slen, &vll)) return 0;
    if (!str) {
        /* Write the longval as a string so we can re-add it */
        slen = ll2string(longstr, sizeof(longstr), vll);
        str = (unsigned char *)longstr;
    }
    quicklistPushTail(ql, str, slen);
    return 1;
}",1744.0,1760.0,1.0,4.0,17.0,14,6,19,8,0,3,3,3,1,3,,0,2,6,3,3,int
3825,258988,_lpEntryValidation,1,_lpEntryValidation,"int _lpEntryValidation (unsigned char*,unsigned int,void*)",rdb.c,"static int _lpEntryValidation(unsigned char *p, unsigned int head_count, void *userdata) {
    struct {
        int pairs;
        long count;
        dict *fields;
    } *data = userdata;

    if (data->fields == NULL) {
        data->fields = dictCreate(&hashDictType);
        dictExpand(data->fields, data->pairs ? head_count/2 : head_count);
    }

    /* If we're checking pairs, then even records are field names. Otherwise
     * we're checking all elements. Add to dict and check that's not a dup */
    if (!data->pairs || ((data->count) & 1) == 0) {
        unsigned char *str;
        int64_t slen;
        unsigned char buf[LP_INTBUF_SIZE];

        str = lpGet(p, &slen, buf);
        sds field = sdsnewlen(str, slen);
        if (dictAdd(data->fields, field, NULL) != DICT_OK) {
            /* Duplicate, return an error */
            sdsfree(field);
            return 0;
        }
    }

    (data->count)++;
    return 1;
}",1763.0,1793.0,1.0,26.0,31.0,23,11,24,10,0,6,4,5,1,6,,0,4,6,3,3,int
3826,259077,lpValidateIntegrityAndDups,1,lpValidateIntegrityAndDups,"int lpValidateIntegrityAndDups (unsigned char*,size_t,int,int)",rdb.c,"int lpValidateIntegrityAndDups(unsigned char *lp, size_t size, int deep, int pairs) {
    if (!deep)
        return lpValidateIntegrity(lp, size, 0, NULL, NULL);

    /* Keep track of the field names to locate duplicate ones */
    struct {
        int pairs;
        long count;
        dict *fields; /* Initialisation at the first callback. */
    } data = {pairs, 0, NULL};

    int ret = lpValidateIntegrity(lp, size, 1, _lpEntryValidation, &data);

    /* make sure we have an even number of records. */
    if (pairs && data.count & 1)
        ret = 0;

    if (data.fields) dictRelease(data.fields);
    return ret;
}",1800.0,1819.0,1.0,1.0,20.0,11,7,18,7,0,3,4,4,0,3,,0,1,8,4,4,int
3827,259136,rdbLoadObject,1,rdbLoadObject,"robj rdbLoadObject (int,rio*,sds,int,int*)",rdb.c,"robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error) {
    robj *o = NULL, *ele, *dec;
    uint64_t len;
    unsigned int i;

    /* Set default error of load object, it will be set to 0 on success. */
    if (error) *error = RDB_LOAD_ERR_OTHER;

    int deep_integrity_validation = server.sanitize_dump_payload == SANITIZE_DUMP_YES;
    if (server.sanitize_dump_payload == SANITIZE_DUMP_CLIENTS) {
        /* Skip sanitization when loading (an RDB), or getting a RESTORE command
         * from either the master or a client using an ACL user with the skip-sanitize-payload flag. */
        int skip = server.loading ||
            (server.current_client && (server.current_client->flags & CLIENT_MASTER));
        if (!skip && server.current_client && server.current_client->user)
            skip = !!(server.current_client->user->flags & USER_FLAG_SANITIZE_PAYLOAD_SKIP);
        deep_integrity_validation = !skip;
    }

    if (rdbtype == RDB_TYPE_STRING) {
        /* R...",1825.0,2854.0,1.0,24.0,1030.0,41,10,31,8,3,2,8,10,1,2,,0,2,10,5,5,robj
3828,262680,startLoading,1,startLoading,"void startLoading (size_t,int,int)",rdb.c,"void startLoading(size_t size, int rdbflags, int async) {
    /* Load the DB */
    server.loading = 1;
    if (async == 1) server.async_loading = 1;
    server.loading_start_time = time(NULL);
    server.loading_loaded_bytes = 0;
    server.loading_total_bytes = size;
    server.loading_rdb_used_mem = 0;
    server.rdb_last_load_keys_expired = 0;
    server.rdb_last_load_keys_loaded = 0;
    blockingOperationStarts();

    /* Fire the loading modules start event. */
    int subevent;
    if (rdbflags & RDBFLAGS_AOF_PREAMBLE)
        subevent = REDISMODULE_SUBEVENT_LOADING_AOF_START;
    else if(rdbflags & RDBFLAGS_REPLICATION)
        subevent = REDISMODULE_SUBEVENT_LOADING_REPL_START;
    else
        subevent = REDISMODULE_SUBEVENT_LOADING_RDB_START;
    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,subevent,NULL);
}",2858.0,2879.0,1.0,19.0,22.0,20,5,15,6,3,2,3,3,0,2,,0,0,6,3,3,void
3829,262778,startLoadingFile,1,startLoadingFile,"void startLoadingFile (size_t,char*,int)",rdb.c,"void startLoadingFile(size_t size, char* filename, int rdbflags) {
    rdbFileBeingLoaded = filename;
    startLoading(size, rdbflags, 0);
}",2884.0,2887.0,1.0,1.0,4.0,1,1,4,4,2,2,1,1,0,1,,0,1,6,3,3,void
3830,262792,loadingAbsProgress,1,loadingAbsProgress,void loadingAbsProgress (off_t),rdb.c,"void loadingAbsProgress(off_t pos) {
    server.loading_loaded_bytes = pos;
    if (server.stat_peak_memory < zmalloc_used_memory())
        server.stat_peak_memory = zmalloc_used_memory();
}",2890.0,2894.0,1.0,1.0,5.0,6,3,4,2,1,2,2,2,1,2,,0,2,2,1,1,void
3831,262814,loadingIncrProgress,1,loadingIncrProgress,void loadingIncrProgress (off_t),rdb.c,"void loadingIncrProgress(off_t size) {
    server.loading_loaded_bytes += size;
    if (server.stat_peak_memory < zmalloc_used_memory())
        server.stat_peak_memory = zmalloc_used_memory();
}",2897.0,2901.0,1.0,1.0,5.0,6,4,4,2,2,2,2,2,1,2,,0,2,2,1,1,void
3832,262836,updateLoadingFileName,1,updateLoadingFileName,void updateLoadingFileName (char*),rdb.c,"void updateLoadingFileName(char* filename) {
    rdbFileBeingLoaded = filename;
}",2904.0,2906.0,1.0,1.0,3.0,1,1,2,2,2,1,1,1,0,0,,0,1,2,1,1,void
3833,262844,stopLoading,1,stopLoading,void stopLoading (int),rdb.c,"void stopLoading(int success) {
    server.loading = 0;
    server.async_loading = 0;
    blockingOperationEnds();
    rdbFileBeingLoaded = NULL;

    /* Fire the loading modules end event. */
    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,
                          success?
                            REDISMODULE_SUBEVENT_LOADING_ENDED:
                            REDISMODULE_SUBEVENT_LOADING_FAILED,
                           NULL);
}",2909.0,2921.0,1.0,26.0,13.0,6,3,6,4,6,3,1,1,0,2,,0,1,2,1,1,void
3834,262876,startSaving,1,startSaving,void startSaving (int),rdb.c,"void startSaving(int rdbflags) {
    /* Fire the persistence modules start event. */
    int subevent;
    if (rdbflags & RDBFLAGS_AOF_PREAMBLE && getpid() != server.pid)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START;
    else if (rdbflags & RDBFLAGS_AOF_PREAMBLE)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_AOF_START;
    else if (getpid()!=server.pid)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START;
    else
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START;
    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,subevent,NULL);
}",2923.0,2935.0,1.0,19.0,13.0,6,6,5,4,3,1,2,2,0,1,,0,0,2,1,1,void
3835,262945,stopSaving,1,stopSaving,void stopSaving (int),rdb.c,"void stopSaving(int success) {
    /* Fire the persistence modules end event. */
    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,
                          success?
                            REDISMODULE_SUBEVENT_PERSISTENCE_ENDED:
                            REDISMODULE_SUBEVENT_PERSISTENCE_FAILED,
                          NULL);
}",2937.0,2944.0,1.0,26.0,8.0,1,1,2,2,8,1,1,1,0,1,,0,0,2,1,1,void
3836,262963,rdbLoadProgressCallback,1,rdbLoadProgressCallback,"void rdbLoadProgressCallback (rio*,void*,size_t)",rdb.c,"void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
    if (server.rdb_checksum)
        rioGenericUpdateChecksum(r, buf, len);
    if (server.loading_process_events_interval_bytes &&
        (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)
    {
        if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)
            replicationSendNewlineToMaster();
        loadingAbsProgress(r->processed_bytes);
        processEventsWhileBlocked();
        processModuleLoadingProgressEvent(0);
    }
    if (server.repl_state == REPL_STATE_TRANSFER && rioCheckType(r) == RIO_TYPE_CONN) {
        atomicIncr(server.stat_net_repl_input_bytes, len);
    }
}",2948.0,2963.0,1.0,71.0,16.0,22,8,19,5,0,6,5,6,1,6,,0,1,6,3,3,void
3837,263042,rdbFunctionLoad,1,rdbFunctionLoad,"int rdbFunctionLoad (rio*,int,functionsLibCtx*,int,sds*)",rdb.c,"int rdbFunctionLoad(rio *rdb, int ver, functionsLibCtx* lib_ctx, int rdbflags, sds *err) {
    UNUSED(ver);
    sds error = NULL;
    sds final_payload = NULL;
    int res = C_ERR;
    if (!(final_payload = rdbGenericLoadStringObject(rdb, RDB_LOAD_SDS, NULL))) {
        error = sdsnew(""Failed loading library payload"");
        goto done;
    }

    if (lib_ctx) {
        sds library_name = NULL;
        if (!(library_name = functionsCreateWithLibraryCtx(final_payload, rdbflags & RDBFLAGS_ALLOW_DUP, &error, lib_ctx))) {
            if (!error) {
                error = sdsnew(""Failed creating the library"");
            }
            goto done;
        }
        sdsfree(library_name);
    }

    res = C_OK;

done:
    if (final_payload) sdsfree(final_payload);
    if (error) {
        if (err) {
            *err = error;
        } else {
            serverLog(LL_WARNING, ""Failed creating function, %s"", error);
            sdsfree(error);
        }
    }
    return res;
}",2972.0,3006.0,1.0,4.0,35.0,20,8,30,10,1,6,10,12,2,6,,0,4,10,5,5,int
3838,263171,rdbLoadRio,1,rdbLoadRio,"int rdbLoadRio (rio*,int,rdbSaveInfo*)",rdb.c,"int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
    functionsLibCtx* functions_lib_ctx = functionsLibCtxGetCurrent();
    rdbLoadingCtx loading_ctx = { .dbarray = server.db, .functions_lib_ctx = functions_lib_ctx };
    int retval = rdbLoadRioWithLoadingCtx(rdb,rdbflags,rsi,&loading_ctx);
    return retval;
}",3010.0,3015.0,1.0,1.0,6.0,8,4,12,8,1,2,1,1,0,2,,0,2,6,3,3,int
3839,263207,rdbLoadRioWithLoadingCtx,1,rdbLoadRioWithLoadingCtx,"int rdbLoadRioWithLoadingCtx (rio*,int,rdbSaveInfo*,rdbLoadingCtx*)",rdb.c,"int rdbLoadRioWithLoadingCtx(rio *rdb, int rdbflags, rdbSaveInfo *rsi, rdbLoadingCtx *rdb_loading_ctx) {
    uint64_t dbid = 0;
    int type, rdbver;
    redisDb *db = rdb_loading_ctx->dbarray+0;
    char buf[1024];
    int error;
    long long empty_keys_skipped = 0;

    rdb->update_cksum = rdbLoadProgressCallback;
    rdb->max_processing_chunk = server.loading_process_events_interval_bytes;
    if (rioRead(rdb,buf,9) == 0) goto eoferr;
    buf[9] = '\0';
    if (memcmp(buf,""REDIS"",5) != 0) {
        serverLog(LL_WARNING,""Wrong signature trying to load DB from file"");
        return C_ERR;
    }
    rdbver = atoi(buf+5);
    if (rdbver < 1 || rdbver > RDB_VERSION) {
        serverLog(LL_WARNING,""Can't handle RDB format version %d"",rdbver);
        return C_ERR;
    }

    /* Key-specific attributes, set by opcodes before the key type. */
    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();
    long long lru_clock = LRU_CLOCK();

    while(1) {
        sds k...",3023.0,3367.0,1.0,8.0,345.0,86,19,69,20,2,21,24,34,5,19,,0,11,8,4,4,int
3840,264874,rdbLoad,1,rdbLoad,"int rdbLoad (char*,rdbSaveInfo*,int)",rdb.c,"int rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags) {
    FILE *fp;
    rio rdb;
    int retval;
    struct stat sb;
    int rdb_fd;

    fp = fopen(filename, ""r"");
    if (fp == NULL) {
        if (errno == ENOENT) return RDB_NOT_EXIST;

        serverLog(LL_WARNING,""Fatal error: can't open the RDB file %s for reading: %s"", filename, strerror(errno));
        return RDB_FAILED;
    }

    if (fstat(fileno(fp), &sb) == -1)
        sb.st_size = 0;

    startLoadingFile(sb.st_size, filename, rdbflags);
    rioInitWithFile(&rdb,fp);

    retval = rdbLoadRio(&rdb,rdbflags,rsi);

    fclose(fp);
    stopLoading(retval==C_OK);
    /* Reclaim the cache backed by rdb */
    if (retval == C_OK && !(rdbflags & RDBFLAGS_KEEP_CACHE)) {
        /* TODO: maybe we could combine the fopen and open into one in the future */
        rdb_fd = open(filename, O_RDONLY);
        if (rdb_fd > 0) bioCreateCloseJob(rdb_fd, 0, 1);
    }
    return (retval==C_OK) ? RDB_OK : RDB_FAILED;
}",3376.0,3408.0,1.0,36.0,33.0,25,12,31,13,1,6,6,8,0,6,,0,1,6,3,3,int
3841,265013,backgroundSaveDoneHandlerDisk,1,backgroundSaveDoneHandlerDisk,"void backgroundSaveDoneHandlerDisk (int,int)",rdb.c,"static void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        serverLog(LL_NOTICE,
            ""Background saving terminated with success"");
        server.dirty = server.dirty - server.dirty_before_bgsave;
        server.lastsave = time(NULL);
        server.lastbgsave_status = C_OK;
    } else if (!bysignal && exitcode != 0) {
        serverLog(LL_WARNING, ""Background saving error"");
        server.lastbgsave_status = C_ERR;
    } else {
        mstime_t latency;

        serverLog(LL_WARNING,
            ""Background saving terminated by signal %d"", bysignal);
        latencyStartMonitor(latency);
        rdbRemoveTempFile(server.child_pid, 0);
        latencyEndMonitor(latency);
        latencyAddSampleIfNeeded(""rdb-unlink-temp-file"",latency);
        /* SIGUSR1 is whitelisted, so we have a way to kill a child without
         * triggering an error condition. */
        if (bysignal != SIGUSR1)
            server.lastbgsave_...",3412.0,3436.0,1.0,8.0,25.0,15,8,9,4,1,1,2,2,0,1,,0,0,4,2,2,void
3842,265192,backgroundSaveDoneHandlerSocket,1,backgroundSaveDoneHandlerSocket,"void backgroundSaveDoneHandlerSocket (int,int)",rdb.c,"static void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        serverLog(LL_NOTICE,
            ""Background RDB transfer terminated with success"");
    } else if (!bysignal && exitcode != 0) {
        serverLog(LL_WARNING, ""Background transfer error"");
    } else {
        serverLog(LL_WARNING,
            ""Background transfer terminated by signal %d"", bysignal);
    }
    if (server.rdb_child_exit_pipe!=-1)
        close(server.rdb_child_exit_pipe);
    aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);
    close(server.rdb_pipe_read);
    server.rdb_child_exit_pipe = -1;
    server.rdb_pipe_read = -1;
    zfree(server.rdb_pipe_conns);
    server.rdb_pipe_conns = NULL;
    server.rdb_pipe_numconns = 0;
    server.rdb_pipe_numconns_writing = 0;
    zfree(server.rdb_pipe_buff);
    server.rdb_pipe_buff = NULL;
    server.rdb_pipe_bufflen = 0;
}",3441.0,3464.0,1.0,8.0,24.0,31,9,19,4,1,4,3,3,0,4,,0,0,4,2,2,void
3843,265344,backgroundSaveDoneHandler,1,backgroundSaveDoneHandler,"void backgroundSaveDoneHandler (int,int)",rdb.c,"void backgroundSaveDoneHandler(int exitcode, int bysignal) {
    int type = server.rdb_child_type;
    switch(server.rdb_child_type) {
    case RDB_CHILD_TYPE_DISK:
        backgroundSaveDoneHandlerDisk(exitcode,bysignal);
        break;
    case RDB_CHILD_TYPE_SOCKET:
        backgroundSaveDoneHandlerSocket(exitcode,bysignal);
        break;
    default:
        serverPanic(""Unknown RDB child type."");
        break;
    }

    server.rdb_child_type = RDB_CHILD_TYPE_NONE;
    server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
    server.rdb_save_time_start = -1;
    /* Possibly there are slaves waiting for a BGSAVE in order to be served
     * (the first stage of SYNC is a bulk transfer of dump.rdb) */
    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, type);
}",3467.0,3487.0,1.0,9.0,21.0,18,9,15,5,0,4,5,2,0,4,,0,0,4,2,2,void
3844,265426,killRDBChild,1,killRDBChild,void killRDBChild (void),rdb.c,"void killRDBChild(void) {
    kill(server.child_pid, SIGUSR1);
    /* Because we are not using here waitpid (like we have in killAppendOnlyChild
     * and TerminateModuleForkChild), all the cleanup operations is done by
     * checkChildrenDone, that later will find that the process killed.
     * This includes:
     * - resetChildState
     * - rdbRemoveTempFile */
}",3492.0,3500.0,1.0,1.0,9.0,1,1,2,2,6,0,1,1,0,0,,0,0,2,1,1,void
3845,265436,rdbSaveToSlavesSockets,1,rdbSaveToSlavesSockets,"int rdbSaveToSlavesSockets (int,rdbSaveInfo*)",rdb.c,"int rdbSaveToSlavesSockets(int req, rdbSaveInfo *rsi) {
    listNode *ln;
    listIter li;
    pid_t childpid;
    int pipefds[2], rdb_pipe_write, safe_to_exit_pipe;

    if (hasActiveChildProcess()) return C_ERR;

    /* Even if the previous fork child exited, don't start a new one until we
     * drained the pipe. */
    if (server.rdb_pipe_conns) return C_ERR;

    /* Before to fork, create a pipe that is used to transfer the rdb bytes to
     * the parent, we can't let it write directly to the sockets, since in case
     * of TLS we must let the parent handle a continuous TLS state when the
     * child terminates and parent takes over. */
    if (anetPipe(pipefds, O_NONBLOCK, 0) == -1) return C_ERR;
    server.rdb_pipe_read = pipefds[0]; /* read end */
    rdb_pipe_write = pipefds[1]; /* write end */

    /* create another pipe that is used by the parent to signal to the child
     * that it can exit. */
    if (anetPipe(pipefds, 0, 0) == -1) {
        close(rdb_pipe_write);
  ...",3504.0,3619.0,1.0,40.0,116.0,67,14,57,17,1,21,12,16,8,17,,0,13,4,2,2,int
3846,265869,saveCommand,1,saveCommand,void saveCommand (client*),rdb.c,"void saveCommand(client *c) {
    if (server.child_type == CHILD_TYPE_RDB) {
        addReplyError(c,""Background save already in progress"");
        return;
    }

    server.stat_rdb_saves++;

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);
    if (rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr,RDBFLAGS_NONE) == C_OK) {
        addReply(c,shared.ok);
    } else {
        addReplyErrorObject(c,shared.err);
    }
}",3621.0,3636.0,1.0,29.0,16.0,9,5,9,5,0,4,3,3,1,4,,0,2,2,1,1,void
3847,265927,bgsaveCommand,1,bgsaveCommand,void bgsaveCommand (client*),rdb.c,"void bgsaveCommand(client *c) {
    int schedule = 0;

    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite
     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */
    if (c->argc > 1) {
        if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""schedule"")) {
            schedule = 1;
        } else {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        }
    }

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);

    if (server.child_type == CHILD_TYPE_RDB) {
        addReplyError(c,""Background save already in progress"");
    } else if (hasActiveChildProcess() || server.in_exec) {
        if (schedule || server.in_exec) {
            server.rdb_bgsave_scheduled = 1;
            addReplyStatus(c,""Background saving scheduled"");
        } else {
            addReplyError(c,
            ""Another child process is active (AOF?): can't BGSAVE right now. ""
            ""Use BGSAVE SCHEDULE in order...",3639.0,3673.0,1.0,29.0,35.0,15,9,9,5,0,5,4,5,3,2,,0,4,2,1,1,void
3848,266049,rdbPopulateSaveInfo,1,rdbPopulateSaveInfo,rdbSaveInfo rdbPopulateSaveInfo (rdbSaveInfo*),rdb.c,"rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
    rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;
    *rsi = rsi_init;

    /* If the instance is a master, we can populate the replication info
     * only when repl_backlog is not NULL. If the repl_backlog is NULL,
     * it means that the instance isn't in any replication chains. In this
     * scenario the replication info is useless, because when a slave
     * connects to us, the NULL repl_backlog will trigger a full
     * synchronization, at the same time we will use a new replid and clear
     * replid2. */
    if (!server.masterhost && server.repl_backlog) {
        /* Note that when server.slaveseldb is -1, it means that this master
         * didn't apply any write commands after a full synchronization.
         * So we can let repl_stream_db be 0, this allows a restarted slave
         * to reload replication ID/offset, it's safe because the next write
         * command must generate a SELECT statement. */
        rsi->...",3684.0,3722.0,1.0,27.0,39.0,29,10,18,4,5,3,4,4,0,0,,0,3,2,1,1,rdbSaveInfo
3849,266559,redisGitSHA1,1,redisGitSHA1,char* redisGitSHA1 (void),release.c,"char *redisGitSHA1(void) {
    return REDIS_GIT_SHA1;
}",40.0,42.0,1.0,1.0,3.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,char*
3850,266564,redisGitDirty,1,redisGitDirty,char* redisGitDirty (void),release.c,"char *redisGitDirty(void) {
    return REDIS_GIT_DIRTY;
}",44.0,46.0,1.0,1.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,char*
3851,266577,createMissingClients,1,createMissingClients,void createMissingClients (client),redis-benchmark.c,"static void createMissingClients(client c) {
    int n = 0;
    while(config.liveclients < config.numclients) {
        int thread_id = -1;
        if (config.num_threads)
            thread_id = config.liveclients % config.num_threads;
        createClient(NULL,0,c,thread_id);

        /* Listen backlog is quite limited on most systems */
        if (++n > 64) {
            usleep(50000);
            n = 0;
        }
    }
}",852.0,866.0,1.0,1.0,15.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3852,266582,createBenchmarkThread,1,createBenchmarkThread,benchmarkThread* createBenchmarkThread (int),redis-benchmark.c,"static benchmarkThread *createBenchmarkThread(int index) {
    benchmarkThread *thread = zmalloc(sizeof(*thread));
    if (thread == NULL) return NULL;
    thread->index = index;
    thread->el = aeCreateEventLoop(1024*10);
    aeCreateTimeEvent(thread->el,1,showThroughput,(void *)thread,NULL);
    return thread;
}",1024.0,1031.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,benchmarkThread
3853,266592,freeBenchmarkThreads,1,freeBenchmarkThreads,void freeBenchmarkThreads (void),redis-benchmark.c,"static void freeBenchmarkThreads(void) {
    int i = 0;
    for (; i < config.num_threads; i++) {
        benchmarkThread *thread = config.threads[i];
        if (thread) freeBenchmarkThread(thread);
    }
    zfree(config.threads);
    config.threads = NULL;
}",1038.0,1046.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3854,266608,getRedisConfig,1,getRedisConfig,"redisConfig* getRedisConfig (char*,int,char*)",redis-benchmark.c,"static redisConfig *getRedisConfig(const char *ip, int port,
                                   const char *hostsocket)
{
    redisConfig *cfg = zcalloc(sizeof(*cfg));
    if (!cfg) return NULL;
    redisContext *c = NULL;
    redisReply *reply = NULL, *sub_reply = NULL;
    c = getRedisContext(ip, port, hostsocket);
    if (c == NULL) {
        freeRedisConfig(cfg);
        exit(1);
    }
    redisAppendCommand(c, ""CONFIG GET %s"", ""save"");
    redisAppendCommand(c, ""CONFIG GET %s"", ""appendonly"");
    int abort_test = 0;
    int i = 0;
    void *r = NULL;
    for (; i < 2; i++) {
        int res = redisGetReply(c, &r);
        if (reply) freeReplyObject(reply);
        reply = res == REDIS_OK ? ((redisReply *) r) : NULL;
        if (res != REDIS_OK || !r) goto fail;
        if (reply->type == REDIS_REPLY_ERROR) {
            goto fail;
        }
        if (reply->type != REDIS_REPLY_ARRAY || reply->elements < 2) goto fail;
        sub_reply = reply->element[1];
        char *value ...",313.0,364.0,1.0,1.0,52.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,redisConfig
3855,266615,getRedisContext,1,getRedisContext,"redisContext* getRedisContext (char*,int,char*)",redis-benchmark.c,"static redisContext *getRedisContext(const char *ip, int port,
                                     const char *hostsocket)
{
    redisContext *ctx = NULL;
    redisReply *reply =  NULL;
    if (hostsocket == NULL)
        ctx = redisConnect(ip, port);
    else
        ctx = redisConnectUnix(hostsocket);
    if (ctx == NULL || ctx->err) {
        fprintf(stderr,""Could not connect to Redis at "");
        char *err = (ctx != NULL ? ctx->errstr : """");
        if (hostsocket == NULL)
            fprintf(stderr,""%s:%d: %s\n"",ip,port,err);
        else
            fprintf(stderr,""%s: %s\n"",hostsocket,err);
        goto cleanup;
    }
    if (config.tls==1) {
        const char *err = NULL;
        if (cliSecureConnection(ctx, config.sslconfig, &err) == REDIS_ERR && err) {
            fprintf(stderr, ""Could not negotiate a TLS connection: %s\n"", err);
            goto cleanup;
        }
    }
    if (config.conn_info.auth == NULL)
        return ctx;
    if (config.conn_info.user == NULL)
...",256.0,309.0,1.0,1.0,54.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,redisContext
3856,266622,freeRedisConfig,1,freeRedisConfig,void freeRedisConfig (redisConfig*),redis-benchmark.c,"static void freeRedisConfig(redisConfig *cfg) {
    if (cfg->save) sdsfree(cfg->save);
    if (cfg->appendonly) sdsfree(cfg->appendonly);
    zfree(cfg);
}",365.0,369.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3857,266632,updateClusterSlotsConfiguration,1,updateClusterSlotsConfiguration,void updateClusterSlotsConfiguration (void),redis-benchmark.c,"static void updateClusterSlotsConfiguration(void) {
    pthread_mutex_lock(&config.is_updating_slots_mutex);
    atomicSet(config.is_updating_slots, 1);
    int i;
    for (i = 0; i < config.cluster_node_count; i++) {
        clusterNode *node = config.cluster_nodes[i];
        if (node->updated_slots != NULL) {
            int *oldslots = node->slots;
            node->slots = node->updated_slots;
            node->slots_count = node->updated_slots_count;
            node->current_slot_index = 0;
            node->updated_slots = NULL;
            node->updated_slots_count = 0;
            zfree(oldslots);
        }
    }
    atomicSet(config.is_updating_slots, 0);
    atomicIncr(config.slots_last_update, 1);
    pthread_mutex_unlock(&config.is_updating_slots_mutex);
}",1380.0,1399.0,1.0,1.0,20.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3858,266644,benchmarkVersion,1,benchmarkVersion,sds benchmarkVersion (void),redis-benchmark.c,"static sds benchmarkVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",208.0,220.0,1.0,45.0,13.0,4,1,10,2,0,8,3,4,2,8,,0,8,2,1,1,sds
3859,266693,dictSdsKeyCompare,1,dictSdsKeyCompare,"int dictSdsKeyCompare (dict*,void*,void*)",server.c,"int dictSdsKeyCompare(dict *d, const void *key1,
        const void *key2)
{
    int l1,l2;
    UNUSED(d);

    l1 = sdslen((sds)key1);
    l2 = sdslen((sds)key2);
    if (l1 != l2) return 0;
    return memcmp(key1, key2, l1) == 0;
}",259.0,269.0,1.0,4.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
3860,266700,ustime,1,ustime,long long ustime (void),server.c,"long long ustime(void) {
    struct timeval tv;
    long long ust;

    gettimeofday(&tv, NULL);
    ust = ((long long)tv.tv_sec)*1000000;
    ust += tv.tv_usec;
    return ust;
}",192.0,200.0,1.0,1.0,9.0,7,6,7,3,30,0,1,1,0,0,,0,0,2,1,1,long long
3861,266727,mstime,1,mstime,long long mstime (void),server.c,"mstime_t mstime(void) {
    return ustime()/1000;
}",203.0,205.0,1.0,1.0,3.0,1,1,0,0,125,1,1,1,0,1,,0,0,2,1,1,mstime_t
3862,267399,freeAllClients,1,freeAllClients,void freeAllClients (void),redis-benchmark.c,"static void freeAllClients(void) {
    listNode *ln = config.clients->head, *next;

    while(ln) {
        next = ln->next;
        freeClient(ln->value);
        ln = next;
    }
}",396.0,404.0,1.0,1.0,9.0,7,3,8,3,1,5,2,2,0,1,,0,4,2,1,1,void
3863,267501,randomizeClientKey,1,randomizeClientKey,void randomizeClientKey (client),redis-benchmark.c,"static void randomizeClientKey(client c) {
    size_t i;

    for (i = 0; i < c->randlen; i++) {
        char *p = c->randptr[i]+11;
        size_t r = 0;
        if (config.randomkeys_keyspacelen != 0)
            r = random() % config.randomkeys_keyspacelen;
        size_t j;

        for (j = 0; j < 12; j++) {
            *p = '0'+r%10;
            r/=10;
            p--;
        }
    }
}",415.0,431.0,1.0,1.0,17.0,21,11,16,6,0,4,4,6,2,0,,0,4,2,1,1,void
3864,267573,setClusterKeyHashTag,1,setClusterKeyHashTag,void setClusterKeyHashTag (client),redis-benchmark.c,"static void setClusterKeyHashTag(client c) {
    assert(c->thread_id >= 0);
    clusterNode *node = c->cluster_node;
    assert(node);
    assert(node->current_slot_index < node->slots_count);
    int is_updating_slots = 0;
    atomicGet(config.is_updating_slots, is_updating_slots);
    /* If updateClusterSlotsConfiguration is updating the slots array,
     * call updateClusterSlotsConfiguration is order to block the thread
     * since the mutex is locked. When the slots will be updated by the
     * thread that's actually performing the update, the execution of
     * updateClusterSlotsConfiguration won't actually do anything, since
     * the updated_slots_count array will be already NULL. */
    if (is_updating_slots) updateClusterSlotsConfiguration();
    int slot = node->slots[node->current_slot_index];
    const char *tag = crc16_slot_table[slot];
    int taglen = strlen(tag);
    size_t i;
    for (i = 0; i < c->staglen; i++) {
        char *p = c->stagptr[i] + 1;
        p[...",433.0,457.0,1.0,1.0,25.0,36,9,32,10,0,7,3,3,0,1,,0,6,2,1,1,void
3865,267689,clientDone,1,clientDone,void clientDone (client),redis-benchmark.c,"static void clientDone(client c) {
    int requests_finished = 0;
    atomicGet(config.requests_finished, requests_finished);
    if (requests_finished >= config.requests) {
        freeClient(c);
        if (!config.num_threads && config.el) aeStop(config.el);
        return;
    }
    if (config.keepalive) {
        resetClient(c);
    } else {
        if (config.num_threads) pthread_mutex_lock(&(config.liveclients_mutex));
        config.liveclients--;
        createMissingClients(c);
        config.liveclients++;
        if (config.num_threads)
            pthread_mutex_unlock(&(config.liveclients_mutex));
        freeClient(c);
    }
}",459.0,478.0,1.0,1.0,20.0,10,5,11,3,0,15,4,5,8,3,,0,12,2,1,1,void
3866,267768,readHandler,1,readHandler,"void readHandler (aeEventLoop*,int,void*,int)",redis-benchmark.c,"static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    client c = privdata;
    void *reply = NULL;
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);

    /* Calculate latency only for the first read event. This means that the
     * server already sent the reply and we need to parse it. Parsing overhead
     * is not part of the latency, so calculate it only once, here. */
    if (c->latency < 0) c->latency = ustime()-(c->start);

    if (redisBufferRead(c->context) != REDIS_OK) {
        fprintf(stderr,""Error: %s\n"",c->context->errstr);
        exit(1);
    } else {
        while(c->pending) {
            if (redisGetReply(c->context,&reply) != REDIS_OK) {
                fprintf(stderr,""Error: %s\n"",c->context->errstr);
                exit(1);
            }
            if (reply != NULL) {
                if (reply == (void*)REDIS_REPLY_ERROR) {
                    fprintf(stderr,""Unexpected error reply, exiting...\n"");
                    exit(1);
    ...",480.0,591.0,1.0,4.0,112.0,15,6,17,9,0,1,3,3,0,1,,0,1,8,4,4,void
3867,269390,showLatencyReport,1,showLatencyReport,void showLatencyReport (void),redis-benchmark.c,"static void showLatencyReport(void) {

    const float reqpersec = (float)config.requests_finished/((float)config.totlatency/1000.0f);
    const float p0 = ((float) hdr_min(config.latency_histogram))/1000.0f;
    const float p50 = hdr_value_at_percentile(config.latency_histogram, 50.0 )/1000.0f;
    const float p95 = hdr_value_at_percentile(config.latency_histogram, 95.0 )/1000.0f;
    const float p99 = hdr_value_at_percentile(config.latency_histogram, 99.0 )/1000.0f;
    const float p100 = ((float) hdr_max(config.latency_histogram))/1000.0f;
    const float avg = hdr_mean(config.latency_histogram)/1000.0f;

    if (!config.quiet && !config.csv) {
        printf(""%*s\r"", config.last_printed_bytes, "" ""); // ensure there is a clean line
        printf(""====== %s ======\n"", config.title);
        printf(""  %d requests completed in %.2f seconds\n"", config.requests_finished,
            (float)config.totlatency/1000);
        printf(""  %d parallel clients\n"", config.numclients);
        ...",868.0,959.0,1.0,1.0,92.0,105,17,95,19,1,59,12,26,10,1,,0,58,2,1,1,void
3868,269832,initBenchmarkThreads,1,initBenchmarkThreads,void initBenchmarkThreads (void),redis-benchmark.c,"static void initBenchmarkThreads(void) {
    int i;
    if (config.threads) freeBenchmarkThreads();
    config.threads = zmalloc(config.num_threads * sizeof(benchmarkThread*));
    for (i = 0; i < config.num_threads; i++) {
        benchmarkThread *thread = createBenchmarkThread(i);
        config.threads[i] = thread;
    }
}",961.0,969.0,1.0,1.0,9.0,13,6,12,4,2,13,3,3,4,3,,0,12,2,1,1,void
3869,269880,startBenchmarkThreads,1,startBenchmarkThreads,void startBenchmarkThreads (void),redis-benchmark.c,"static void startBenchmarkThreads(void) {
    int i;
    for (i = 0; i < config.num_threads; i++) {
        benchmarkThread *t = config.threads[i];
        if (pthread_create(&(t->thread), NULL, execBenchmarkThread, t)){
            fprintf(stderr, ""FATAL: Failed to start thread %d.\n"", i);
            exit(1);
        }
    }
    for (i = 0; i < config.num_threads; i++)
        pthread_join(config.threads[i]->thread, NULL);
}",971.0,982.0,1.0,1.0,12.0,11,6,15,6,1,7,4,5,5,0,,0,7,2,1,1,void
3870,269944,benchmark,1,benchmark,"void benchmark (char*,char*,int)",redis-benchmark.c,"static void benchmark(const char *title, char *cmd, int len) {
    client c;

    config.title = title;
    config.requests_issued = 0;
    config.requests_finished = 0;
    config.previous_requests_finished = 0;
    config.last_printed_bytes = 0;
    hdr_init(
        CONFIG_LATENCY_HISTOGRAM_MIN_VALUE,  // Minimum value
        CONFIG_LATENCY_HISTOGRAM_MAX_VALUE,  // Maximum value
        config.precision,  // Number of significant figures
        &config.latency_histogram);  // Pointer to initialise
    hdr_init(
        CONFIG_LATENCY_HISTOGRAM_MIN_VALUE,  // Minimum value
        CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE,  // Maximum value
        config.precision,  // Number of significant figures
        &config.current_sec_latency_histogram);  // Pointer to initialise

    if (config.num_threads) initBenchmarkThreads();

    int thread_id = config.num_threads > 0 ? 0 : -1;
    c = createClient(cmd,len,NULL,thread_id);
    createMissingClients(c);

    config.start = mstime(...",984.0,1020.0,1.0,8.0,37.0,37,8,29,7,22,51,6,6,10,9,,0,45,6,3,3,void
3871,270430,freeClusterNodes,1,freeClusterNodes,void freeClusterNodes (void),redis-benchmark.c,"static void freeClusterNodes(void) {
    int i = 0;
    for (; i < config.cluster_node_count; i++) {
        clusterNode *n = config.cluster_nodes[i];
        if (n) freeClusterNode(n);
    }
    zfree(config.cluster_nodes);
    config.cluster_nodes = NULL;
}",1099.0,1107.0,1.0,1.0,9.0,9,4,11,4,1,10,3,4,2,2,,0,8,2,1,1,void
3872,270471,addClusterNode,1,addClusterNode,clusterNode addClusterNode (clusterNode*),redis-benchmark.c,"static clusterNode **addClusterNode(clusterNode *node) {
    int count = config.cluster_node_count + 1;
    config.cluster_nodes = zrealloc(config.cluster_nodes,
                                    count * sizeof(*node));
    if (!config.cluster_nodes) return NULL;
    config.cluster_nodes[config.cluster_node_count++] = node;
    return config.cluster_nodes;
}",1109.0,1116.0,1.0,1.0,8.0,17,9,12,4,1,15,2,2,2,1,,0,15,2,1,1,clusterNode
3873,270519,fetchClusterConfiguration,1,fetchClusterConfiguration,int fetchClusterConfiguration (void),redis-benchmark.c,"static int fetchClusterConfiguration(void) {
    int success = 1;
    redisContext *ctx = NULL;
    redisReply *reply =  NULL;
    ctx = getRedisContext(config.conn_info.hostip, config.conn_info.hostport, config.hostsocket);
    if (ctx == NULL) {
        exit(1);
    }
    clusterNode *firstNode = createClusterNode((char *) config.conn_info.hostip,
                                               config.conn_info.hostport);
    if (!firstNode) {success = 0; goto cleanup;}
    reply = redisCommand(ctx, ""CLUSTER NODES"");
    success = (reply != NULL);
    if (!success) goto cleanup;
    success = (reply->type != REDIS_REPLY_ERROR);
    if (!success) {
        if (config.hostsocket == NULL) {
            fprintf(stderr, ""Cluster node %s:%d replied with error:\n%s\n"",
                    config.conn_info.hostip, config.conn_info.hostport, reply->str);
        } else {
            fprintf(stderr, ""Cluster node %s replied with error:\n%s\n"",
                    config.hostsocket, reply->st...",1121.0,1285.0,1.0,1.0,165.0,156,20,185,30,1,42,46,73,7,9,,0,41,2,1,1,int
3874,271756,genBenchmarkRandomData,1,genBenchmarkRandomData,"void genBenchmarkRandomData (char*,int)",redis-benchmark.c,"static void genBenchmarkRandomData(char *data, int count) {
    static uint32_t state = 1234;
    int i = 0;

    while (count--) {
        state = (state*1103515245+12345);
        data[i++] = '0'+((state>>16)&63);
    }
}",1402.0,1410.0,1.0,1.0,9.0,12,8,8,4,1,0,2,2,0,0,,0,0,4,2,2,void
3875,271793,parseOptions,1,parseOptions,"int parseOptions (int,char**)",redis-cli.c,"static int parseOptions(int argc, char **argv) {
    int i;

    for (i = 1; i < argc; i++) {
        int lastarg = i==argc-1;

        if (!strcmp(argv[i],""-h"") && !lastarg) {
            sdsfree(config.conn_info.hostip);
            config.conn_info.hostip = sdsnew(argv[++i]);
        } else if (!strcmp(argv[i],""-h"") && lastarg) {
            usage(0);
        } else if (!strcmp(argv[i],""--help"")) {
            usage(0);
        } else if (!strcmp(argv[i],""-x"")) {
            config.stdin_lastarg = 1;
        } else if (!strcmp(argv[i], ""-X"") && !lastarg) {
            config.stdin_tag_arg = 1;
            config.stdin_tag_name = argv[++i];
        } else if (!strcmp(argv[i],""-p"") && !lastarg) {
            config.conn_info.hostport = atoi(argv[++i]);
            if (config.conn_info.hostport < 0 || config.conn_info.hostport > 65535) {
                fprintf(stderr, ""Invalid server port.\n"");
                exit(1);
            }
        } else if (!strcmp(argv[i],""-s"") && !last...",2638.0,2969.0,1.0,28.0,332.0,14,8,19,7,1,2,5,7,0,0,,0,2,4,2,2,int
3876,272914,test_is_selected,1,test_is_selected,int test_is_selected (char*),redis-benchmark.c,"int test_is_selected(const char *name) {
    char buf[256];
    int l = strlen(name);

    if (config.tests == NULL) return 1;
    buf[0] = ',';
    memcpy(buf+1,name,l);
    buf[l+1] = ',';
    buf[l+2] = '\0';
    return strstr(config.tests,buf) != NULL;
}",1721.0,1731.0,1.0,1.0,11.0,14,6,15,5,31,4,2,2,2,0,,0,4,2,1,1,int
3877,272967,main,1,main,"int main (int,char**)",server.c,"int main(int argc, char **argv) {
    struct timeval tv;
    int j;
    char config_from_stdin = 0;

#ifdef REDIS_TEST
    if (argc >= 3 && !strcasecmp(argv[1], ""test"")) {
        int flags = 0;
        for (j = 3; j < argc; j++) {
            char *arg = argv[j];
            if (!strcasecmp(arg, ""--accurate"")) flags |= REDIS_TEST_ACCURATE;
            else if (!strcasecmp(arg, ""--large-memory"")) flags |= REDIS_TEST_LARGE_MEMORY;
            else if (!strcasecmp(arg, ""--valgrind"")) flags |= REDIS_TEST_VALGRIND;
        }

        if (!strcasecmp(argv[2], ""all"")) {
            int numtests = sizeof(redisTests)/sizeof(struct redisTest);
            for (j = 0; j < numtests; j++) {
                redisTests[j].failed = (redisTests[j].proc(argc,argv,flags) != 0);
            }

            /* Report tests result */
            int failed_num = 0;
            for (j = 0; j < numtests; j++) {
                if (redisTests[j].failed) {
                    failed_num++;
                  ...",7036.0,7365.0,1.0,4.0,330.0,249,22,318,23,0,237,49,94,70,83,,0,202,4,2,2,int
3878,274155,consumeNewline,1,consumeNewline,int consumeNewline (char*),redis-check-aof.c,"int consumeNewline(char *buf) {
    if (strncmp(buf,""\r\n"",2) != 0) {
        ERROR(""Expected \\r\\n, got: %02x%02x"",buf[0],buf[1]);
        return 0;
    }
    line += 1;
    return 1;
}",63.0,70.0,1.0,8.0,8.0,7,5,10,5,2,4,2,2,0,0,,0,4,2,1,1,int
3879,274199,readLong,1,readLong,"int readLong (FILE*,char,long*)",redis-check-aof.c,"int readLong(FILE *fp, char prefix, long *target) {
    char buf[128], *eptr;
    epos = ftello(fp);
    if (fgets(buf,sizeof(buf),fp) == NULL) {
        return 0;
    }
    if (buf[0] != prefix) {
        ERROR(""Expected prefix '%c', got: '%c'"",prefix,buf[0]);
        return 0;
    }
    *target = strtol(buf+1,&eptr,10);
    return consumeNewline(eptr);
}",72.0,84.0,1.0,8.0,13.0,13,9,20,9,2,5,3,3,0,1,,0,4,6,3,3,int
3880,274267,readBytes,1,readBytes,"int readBytes (FILE*,char*,long)",redis-check-aof.c,"int readBytes(FILE *fp, char *target, long length) {
    long real;
    epos = ftello(fp);
    real = fread(target,1,length,fp);
    if (real != length) {
        ERROR(""Expected to read %ld bytes, got %ld bytes"",length,real);
        return 0;
    }
    return 1;
}",86.0,95.0,1.0,8.0,10.0,6,4,16,7,1,4,2,2,0,0,,0,4,6,3,3,int
3881,274315,readString,1,readString,"int readString (FILE*,char**)",redis-check-aof.c,"int readString(FILE *fp, char** target) {
    long len;
    *target = NULL;
    if (!readLong(fp,'$',&len)) {
        return 0;
    }

    if (len < 0 || len > LONG_MAX - 2) {
        ERROR(""Expected to read string of %ld bytes, which is not in the suitable range"",len);
        return 0;
    }

    /* Increase length to also consume \r\n */
    len += 2;
    *target = (char*)zmalloc(len);
    if (!readBytes(fp,*target,len)) {
        zfree(*target);
        *target = NULL;
        return 0;
    }
    if (!consumeNewline(*target+len-2)) {
        zfree(*target);
        *target = NULL;
        return 0;
    }
    (*target)[len-2] = '\0';
    return 1;
}",97.0,124.0,1.0,8.0,28.0,31,13,30,8,1,9,5,5,3,6,,0,7,4,2,2,int
3882,274424,readArgc,1,readArgc,"int readArgc (FILE*,long*)",redis-check-aof.c,"int readArgc(FILE *fp, long *target) {
    return readLong(fp,'*',target);
}",126.0,128.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
3883,274435,processRESP,1,processRESP,"int processRESP (FILE*,char*,int*)",redis-check-aof.c,"int processRESP(FILE *fp, char *filename, int *out_multi) {
    long argc;
    char *str;

    if (!readArgc(fp, &argc)) return 0;

    for (int i = 0; i < argc; i++) {
        if (!readString(fp, &str)) return 0;
        if (i == 0) {
            if (strcasecmp(str, ""multi"") == 0) {
                if ((*out_multi)++) {
                    ERROR(""Unexpected MULTI in AOF %s"", filename);
                    zfree(str);
                    return 0;
                }
            } else if (strcasecmp(str, ""exec"") == 0) {
                if (--(*out_multi)) {
                    ERROR(""Unexpected EXEC in AOF %s"", filename);
                    zfree(str);
                    return 0;
                }
            }
        }
        zfree(str);
    }

    return 1;
}",137.0,164.0,1.0,20.0,28.0,13,9,19,9,0,7,7,14,2,4,,0,5,6,3,3,int
3884,274555,processAnnotations,1,processAnnotations,"int processAnnotations (FILE*,char*,int)",redis-check-aof.c,"int processAnnotations(FILE *fp, char *filename, int last_file) {
    char buf[AOF_ANNOTATION_LINE_MAX_LEN];

    epos = ftello(fp);
    if (fgets(buf, sizeof(buf), fp) == NULL) {
        printf(""Failed to read annotations from AOF %s, aborting...\n"", filename);
        exit(1);
    }

    if (to_timestamp && strncmp(buf, ""#TS:"", 4) == 0) {
        char *endptr;
        errno = 0;
        time_t ts = strtol(buf+4, &endptr, 10);
        if (errno != 0 || *endptr != '\r') {
            printf(""Invalid timestamp annotation\n"");
            exit(1);
        }
        if (ts <= to_timestamp) return 1;
        if (epos == 0) {
            printf(""AOF %s has nothing before timestamp %ld, ""
                    ""aborting...\n"", filename, to_timestamp);
            exit(1);
        }
        if (!last_file) {
            printf(""Failed to truncate AOF %s to timestamp %ld to offset %ld because it is not the last file.\n"",
                filename, to_timestamp, (long int)epos);
            pri...",175.0,215.0,1.0,13.0,41.0,19,13,28,10,1,9,8,13,4,0,,0,9,6,3,3,int
3885,274673,checkSingleAof,1,checkSingleAof,"int checkSingleAof (char*,char*,int,int,int)",redis-check-aof.c,"int checkSingleAof(char *aof_filename, char *aof_filepath, int last_file, int fix, int preamble) {
    off_t pos = 0, diff;
    int multi = 0;
    char buf[2];

    FILE *fp = fopen(aof_filepath, ""r+"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s, aborting...\n"", aof_filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp),&sb) == -1) {
        printf(""Cannot stat file: %s, aborting...\n"", aof_filename);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        return AOF_CHECK_EMPTY;
    }

    if (preamble) {
        char *argv[2] = {NULL, aof_filepath};
        if (redis_check_rdb_main(2, argv, fp) == C_ERR) {
            printf(""RDB preamble of AOF file is not sane, aborting.\n"");
            exit(1);
        } else {
            printf(""RDB preamble is OK, proceeding with AOF tail...\n"");
        }
    }

    while(1) {
        if (!multi) pos = ftello(fp);
        if (fgets(buf, sizeo...",222.0,330.0,1.0,11.0,109.0,49,15,79,22,3,11,22,37,5,2,,0,11,10,5,5,int
3886,275022,fileIsRDB,1,fileIsRDB,int fileIsRDB (char*),redis-check-aof.c,"int fileIsRDB(char *filepath) {
    FILE *fp = fopen(filepath, ""r"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s\n"", filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        printf(""Cannot stat file: %s\n"", filepath);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        fclose(fp);
        return 0;
    }

    if (size >= 8) {    /* There must be at least room for the RDB header. */
        char sig[5];
        int rdb_file = fread(sig, sizeof(sig), 1, fp) == 1 &&
                            memcmp(sig, ""REDIS"", sizeof(sig)) == 0;
        if (rdb_file) {
            fclose(fp);
            return 1;
        } 
    }

    fclose(fp);
    return 0;
}",336.0,367.0,1.0,11.0,32.0,15,8,23,8,1,0,6,7,0,0,,0,0,2,1,1,int
3887,275114,fileIsManifest,1,fileIsManifest,int fileIsManifest (char*),redis-check-aof.c,"int fileIsManifest(char *filepath) {
    int is_manifest = 0;
    FILE *fp = fopen(filepath, ""r"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s\n"", filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        printf(""Cannot stat file: %s\n"", filepath);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        fclose(fp);
        return 0;
    }

    char buf[MANIFEST_MAX_LINE+1];
    while (1) {
        if (fgets(buf, MANIFEST_MAX_LINE+1, fp) == NULL) {
            if (feof(fp)) {
                break;
            } else {
                printf(""Cannot read file: %s\n"", filepath);
                exit(1);
            }
        }

        /* Skip comments lines */
        if (buf[0] == '#') {
            continue;
        } else if (!memcmp(buf, ""file"", strlen(""file""))) {
            is_manifest = 1;
        }
    }

    fclose(fp);
    return is_manifest;
}",371.0,412.0,1.0,11.0,42.0,13,7,21,8,1,0,10,12,0,0,,0,0,2,1,1,int
3888,275227,getInputFileType,1,getInputFileType,input_file_type getInputFileType (char*),redis-check-aof.c,"input_file_type getInputFileType(char *filepath) {
    if (fileIsManifest(filepath)) {
        return AOF_MULTI_PART;
    } else if (fileIsRDB(filepath)) {
        return AOF_RDB_PREAMBLE;
    } else {
        return AOF_RESP;
    }
}",422.0,430.0,1.0,1.0,9.0,0,0,2,2,1,1,2,2,1,1,,0,1,2,1,1,input_file_type
3889,275250,printAofStyle,1,printAofStyle,"void printAofStyle (int,char*,char*)",redis-check-aof.c,"void printAofStyle(int ret, char *aofFileName, char *aofType) {
    if (ret == AOF_CHECK_OK) {
        printf(""%s %s is valid\n"", aofType, aofFileName);
    } else if (ret == AOF_CHECK_EMPTY) {
        printf(""%s %s is empty\n"", aofType, aofFileName);
    } else if (ret == AOF_CHECK_TIMESTAMP_TRUNCATED) {
        printf(""Successfully truncated AOF %s to timestamp %ld\n"",
            aofFileName, to_timestamp);
    } else if (ret == AOF_CHECK_TRUNCATED) {
        printf(""Successfully truncated AOF %s\n"", aofFileName);
    }
}",432.0,443.0,1.0,15.0,12.0,1,1,3,3,3,0,2,2,0,0,,0,0,6,3,3,void
3890,275306,checkMultiPartAof,1,checkMultiPartAof,"void checkMultiPartAof (char*,char*,int)",redis-check-aof.c,"void checkMultiPartAof(char *dirpath, char *manifest_filepath, int fix) {
    int total_num = 0, aof_num = 0, last_file;
    int ret;

    printf(""Start checking Multi Part AOF\n"");
    aofManifest *am = aofLoadManifestFromFile(manifest_filepath);

    if (am->base_aof_info) total_num++;
    if (am->incr_aof_list) total_num += listLength(am->incr_aof_list);

    if (am->base_aof_info) {
        sds aof_filename = am->base_aof_info->file_name;
        sds aof_filepath = makePath(dirpath, aof_filename);
        last_file = ++aof_num == total_num;
        int aof_preable = fileIsRDB(aof_filepath);

        printf(""Start to check BASE AOF (%s format).\n"", aof_preable ? ""RDB"":""RESP"");
        ret = checkSingleAof(aof_filename, aof_filepath, last_file, fix, aof_preable);
        printAofStyle(ret, aof_filename, (char *)""BASE AOF"");
        sdsfree(aof_filepath);
    }

    if (listLength(am->incr_aof_list)) {
        listNode *ln;
        listIter li;

        printf(""Start to check INCR ...",456.0,497.0,1.0,40.0,42.0,42,10,57,15,1,24,6,7,6,13,,0,18,6,3,3,void
3891,275485,checkOldStyleAof,1,checkOldStyleAof,"void checkOldStyleAof (char*,int,int)",redis-check-aof.c,"void checkOldStyleAof(char *filepath, int fix, int preamble) {
    printf(""Start checking Old-Style AOF\n"");
    int ret = checkSingleAof(filepath, filepath, 1, fix, preamble);
    printAofStyle(ret, filepath, (char *)""AOF"");
}",502.0,506.0,1.0,1.0,5.0,2,2,7,4,2,2,1,1,0,2,,0,1,6,3,3,void
3892,275509,redis_check_aof_main,1,redis_check_aof_main,"int redis_check_aof_main (int,char**)",redis-check-aof.c,"int redis_check_aof_main(int argc, char **argv) {
    char *filepath;
    char temp_filepath[PATH_MAX + 1];
    char *dirpath;
    int fix = 0;

    if (argc < 2) {
        goto invalid_args;
    } else if (argc == 2) {
        filepath = argv[1];
    } else if (argc == 3) {
        if (!strcmp(argv[1], ""--fix"")) {
            filepath = argv[2];
            fix = 1;
        } else {
            goto invalid_args;
        }
    } else if (argc == 4) {
        if (!strcmp(argv[1], ""--truncate-to-timestamp"")) {
            char *endptr;
            errno = 0;
            to_timestamp = strtol(argv[2], &endptr, 10);
            if (errno != 0 || *endptr != '\0') {
                printf(""Invalid timestamp, aborting...\n"");
                exit(1);
            }
            filepath = argv[3];
        } else {
            goto invalid_args;
        }
    } else {
        goto invalid_args;
    }

    /* In the glibc implementation dirname may modify their argument. */
    memcpy(temp_fi...",508.0,566.0,1.0,1.0,59.0,6,4,21,10,0,4,7,3,0,4,,0,1,4,2,2,int
3893,275688,createSharedObjects,1,createSharedObjects,void createSharedObjects (void),server.c,"void createSharedObjects(void) {
    int j;

    /* Shared command responses */
    shared.ok = createObject(OBJ_STRING,sdsnew(""+OK\r\n""));
    shared.emptybulk = createObject(OBJ_STRING,sdsnew(""$0\r\n\r\n""));
    shared.czero = createObject(OBJ_STRING,sdsnew("":0\r\n""));
    shared.cone = createObject(OBJ_STRING,sdsnew("":1\r\n""));
    shared.emptyarray = createObject(OBJ_STRING,sdsnew(""*0\r\n""));
    shared.pong = createObject(OBJ_STRING,sdsnew(""+PONG\r\n""));
    shared.queued = createObject(OBJ_STRING,sdsnew(""+QUEUED\r\n""));
    shared.emptyscan = createObject(OBJ_STRING,sdsnew(""*2\r\n$1\r\n0\r\n*0\r\n""));
    shared.space = createObject(OBJ_STRING,sdsnew("" ""));
    shared.plus = createObject(OBJ_STRING,sdsnew(""+""));

    /* Shared command error responses */
    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(
        ""-WRONGTYPE Operation against a key holding the wrong kind of value\r\n""));
    shared.err = createObject(OBJ_STRING,sdsnew(""-ERR\r\n""));
    shared.nokeyerr = c...",1824.0,1988.0,1.0,29.0,165.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3894,275759,rdbShowGenericInfo,1,rdbShowGenericInfo,void rdbShowGenericInfo (void),redis-check-rdb.c,"void rdbShowGenericInfo(void) {
    printf(""[info] %lu keys read\n"", rdbstate.keys);
    printf(""[info] %lu expires\n"", rdbstate.expires);
    printf(""[info] %lu already expired\n"", rdbstate.already_expired);
}",105.0,109.0,1.0,1.0,5.0,3,1,3,1,1,3,1,1,0,0,,0,3,2,1,1,void
3895,275867,rdbCheckInfo,1,rdbCheckInfo,void rdbCheckInfo (char*...),redis-check-rdb.c,"void rdbCheckInfo(const char *fmt, ...) {
    char msg[1024];
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    printf(""[offset %llu] %s\n"",
        (unsigned long long) (rdbstate.rio ?
            rdbstate.rio->processed_bytes : 0), msg);
}",140.0,151.0,1.0,1.0,12.0,6,5,10,4,3,2,1,1,0,0,,0,2,2,1,1,void
3896,275926,rdbCheckHandleCrash,1,rdbCheckHandleCrash,"void rdbCheckHandleCrash (int,siginfo_t*,void*)",redis-check-rdb.c,"void rdbCheckHandleCrash(int sig, siginfo_t *info, void *secret) {
    UNUSED(sig);
    UNUSED(info);
    UNUSED(secret);

    rdbCheckError(""Server crash checking the specified RDB file!"");
    exit(1);
}",167.0,174.0,1.0,4.0,8.0,3,1,6,3,0,1,1,1,0,1,,0,0,6,3,3,void
3897,275955,rdbCheckSetupSignals,1,rdbCheckSetupSignals,void rdbCheckSetupSignals (void),redis-check-rdb.c,"void rdbCheckSetupSignals(void) {
    struct sigaction act;

    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = rdbCheckHandleCrash;
    sigaction(SIGSEGV, &act, NULL);
    sigaction(SIGBUS, &act, NULL);
    sigaction(SIGFPE, &act, NULL);
    sigaction(SIGILL, &act, NULL);
    sigaction(SIGABRT, &act, NULL);
}",176.0,187.0,1.0,1.0,12.0,13,4,21,10,1,0,1,1,0,0,,0,0,2,1,1,void
3898,276005,redis_check_rdb,1,redis_check_rdb,"int redis_check_rdb (char*,FILE*)",redis-check-rdb.c,"int redis_check_rdb(char *rdbfilename, FILE *fp) {
    uint64_t dbid;
    int selected_dbid = -1;
    int type, rdbver;
    char buf[1024];
    long long expiretime, now = mstime();
    static rio rdb; /* Pointed by global struct riostate. */
    struct stat sb;

    int closefile = (fp == NULL);
    if (fp == NULL && (fp = fopen(rdbfilename,""r"")) == NULL) return 1;

    if (fstat(fileno(fp), &sb) == -1)
        sb.st_size = 0;

    startLoadingFile(sb.st_size, rdbfilename, RDBFLAGS_NONE);
    rioInitWithFile(&rdb,fp);
    rdbstate.rio = &rdb;
    rdb.update_cksum = rdbLoadProgressCallback;
    if (rioRead(&rdb,buf,9) == 0) goto eoferr;
    buf[9] = '\0';
    if (memcmp(buf,""REDIS"",5) != 0) {
        rdbCheckError(""Wrong signature trying to load DB from file"");
        goto err;
    }
    rdbver = atoi(buf+5);
    if (rdbver < 1 || rdbver > RDB_VERSION) {
        rdbCheckError(""Can't handle RDB format version %d"",rdbver);
        goto err;
    }

    expiretime = -1;
    while(1) {
...",193.0,386.0,1.0,46.0,194.0,93,16,83,19,1,33,29,30,7,19,,0,22,4,2,2,int
3899,276769,checkRdbVersion,1,checkRdbVersion,sds checkRdbVersion (void),redis-check-rdb.c,"static sds checkRdbVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",388.0,400.0,1.0,45.0,13.0,4,1,10,2,0,8,3,4,2,8,,0,8,2,1,1,sds
3900,276813,redis_check_rdb_main,1,redis_check_rdb_main,"int redis_check_rdb_main (int,char**,FILE*)",redis-check-rdb.c,"int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
    struct timeval tv;

    if (argc != 2 && fp == NULL) {
        fprintf(stderr, ""Usage: %s <rdb-file-name>\n"", argv[0]);
        exit(1);
    } else if (!strcmp(argv[1],""-v"") || !strcmp(argv[1], ""--version"")) {
        sds version = checkRdbVersion();
        printf(""redis-check-rdb %s\n"", version);
        sdsfree(version);
        exit(0);
    }

    gettimeofday(&tv, NULL);
    init_genrand64(((long long) tv.tv_sec * 1000000 + tv.tv_usec) ^ getpid());

    /* In order to call the loading functions we need to create the shared
     * integer objects, however since this function may be called from
     * an already initialized Redis instance, check if we really need to. */
    if (shared.integers[0] == NULL)
        createSharedObjects();
    server.loading_process_events_interval_bytes = 0;
    server.sanitize_dump_payload = SANITIZE_DUMP_YES;
    rdbCheckMode = 1;
    rdbCheckInfo(""Checking RDB file %s"", argv[1]);
   ...",414.0,447.0,1.0,35.0,34.0,26,13,22,10,1,8,5,5,0,7,,0,2,6,3,3,int
3901,277213,slaveMode,1,slaveMode,void slaveMode (int),redis-cli.c,"static void slaveMode(int send_sync) {
    static char eofmark[RDB_EOF_MARK_SIZE];
    static char lastbytes[RDB_EOF_MARK_SIZE];
    static int usemark = 0;
    static int out_full_mode;
    unsigned long long payload = sendSync(context, send_sync, eofmark, &out_full_mode);
    char buf[1024];
    int original_output = config.output;
    char *info = out_full_mode ? ""Full resync"" : ""Partial resync"";

    if (out_full_mode == 1 && payload == 0) {
        /* SYNC with EOF marker or PSYNC +FULLRESYNC with EOF marker. */
        payload = ULLONG_MAX;
        memset(lastbytes,0,RDB_EOF_MARK_SIZE);
        usemark = 1;
        fprintf(stderr, ""%s with master, discarding ""
                        ""bytes of bulk transfer until EOF marker...\n"", info);
    } else if (out_full_mode == 1 && payload != 0) {
        /* SYNC without EOF marker or PSYNC +FULLRESYNC. */
        fprintf(stderr, ""%s with master, discarding %llu ""
                        ""bytes of bulk transfer...\n"", info, payload);
...",8501.0,8565.0,1.0,24.0,65.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3902,277228,cliConnect,1,cliConnect,int cliConnect (int),redis-cli.c,"static int cliConnect(int flags) {
    if (context == NULL || flags & CC_FORCE) {
        if (context != NULL) {
            redisFree(context);
            config.dbnum = 0;
            config.in_multi = 0;
            cliRefreshPrompt();
        }

        /* Do not use hostsocket when we got redirected in cluster mode */
        if (config.hostsocket == NULL ||
            (config.cluster_mode && config.cluster_reissue_command)) {
            context = redisConnect(config.conn_info.hostip,config.conn_info.hostport);
        } else {
            context = redisConnectUnix(config.hostsocket);
        }

        if (!context->err && config.tls) {
            const char *err = NULL;
            if (cliSecureConnection(context, config.sslconfig, &err) == REDIS_ERR && err) {
                fprintf(stderr, ""Could not negotiate a TLS connection: %s\n"", err);
                redisFree(context);
                context = NULL;
                return REDIS_ERR;
            }
        }

   ...",1654.0,1724.0,1.0,35.0,71.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,int
3903,277239,getLongInfoField,1,getLongInfoField,"long getLongInfoField (char*,char*)",redis-cli.c,"static long getLongInfoField(char *info, char *field) {
    char *value = getInfoField(info,field);
    long l;

    if (!value) return LONG_MIN;
    l = strtol(value,NULL,10);
    zfree(value);
    return l;
}",9331.0,9339.0,1.0,1.0,9.0,0,0,0,0,9,0,1,1,0,0,,0,0,4,2,2,long
3904,277245,redis_strlcpy,1,redis_strlcpy,"size_t redis_strlcpy (char*,char*,size_t)",strl.c,"size_t
redis_strlcpy(char *dst, const char *src, size_t dsize)
{
    const char *osrc = src;
    size_t nleft = dsize;

    /* Copy as many bytes as will fit. */
    if (nleft != 0) {
        while (--nleft != 0) {
            if ((*dst++ = *src++) == '\0')
                break;
        }
    }

    /* Not enough room in dst, add NUL and traverse rest of src. */
    if (nleft == 0) {
        if (dsize != 0)
            *dst = '\0';        /* NUL-terminate dst */
        while (*src++)
            ;
    }

    return(src - osrc - 1); /* count does not include NUL */
}",23.0,46.0,1.0,1.0,24.0,0,0,0,0,12,0,1,1,0,0,,0,0,6,3,3,size_t
3905,277300,cliRefreshPrompt,1,cliRefreshPrompt,void cliRefreshPrompt (void),redis-cli.c,"static void cliRefreshPrompt(void) {
    if (config.eval_ldb) return;

    sds prompt = sdsempty();
    if (config.hostsocket != NULL) {
        prompt = sdscatfmt(prompt,""redis %s"",config.hostsocket);
    } else {
        char addr[256];
        formatAddr(addr, sizeof(addr), config.conn_info.hostip, config.conn_info.hostport);
        prompt = sdscatlen(prompt,addr,strlen(addr));
    }

    /* Add [dbnum] if needed */
    if (config.dbnum != 0)
        prompt = sdscatfmt(prompt,""[%i]"",config.dbnum);

    /* Add TX if in transaction state*/
    if (config.in_multi)  
        prompt = sdscatlen(prompt,""(TX)"",4);

    if (config.pubsub_mode)
        prompt = sdscatfmt(prompt,""(subscribed mode)"");

    /* Copy the prompt in the static buffer. */
    prompt = sdscatlen(prompt,""> "",2);
    snprintf(config.prompt,sizeof(config.prompt),""%s"",prompt);
    sdsfree(prompt);
}",320.0,347.0,1.0,1.0,28.0,18,4,23,3,5,25,6,6,10,7,,0,24,2,1,1,void
3906,277408,getDotfilePath,1,getDotfilePath,"sds getDotfilePath (char*,char*)",redis-cli.c,"static sds getDotfilePath(char *envoverride, char *dotfilename) {
    char *path = NULL;
    sds dotPath = NULL;

    /* Check the env for a dotfile override. */
    path = getenv(envoverride);
    if (path != NULL && *path != '\0') {
        if (!strcmp(""/dev/null"", path)) {
            return NULL;
        }

        /* If the env is set, return it. */
        dotPath = sdsnew(path);
    } else {
        char *home = getenv(""HOME"");
        if (home != NULL && *home != '\0') {
            /* If no override is set use $HOME/<dotfilename>. */
            dotPath = sdscatprintf(sdsempty(), ""%s/%s"", home, dotfilename);
        }
    }
    return dotPath;
}",357.0,378.0,1.0,1.0,22.0,9,5,14,4,2,1,3,4,0,1,,0,1,4,2,2,sds
3907,277575,cliVersion,1,cliVersion,sds cliVersion (void),redis-cli.c,"static sds cliVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",427.0,439.0,1.0,45.0,13.0,4,1,10,2,1,8,3,4,2,8,,0,8,2,1,1,sds
3908,277619,cliLegacyIntegrateHelp,1,cliLegacyIntegrateHelp,void cliLegacyIntegrateHelp (void),redis-cli.c,"static void cliLegacyIntegrateHelp(void) {
    if (cliConnect(CC_QUIET) == REDIS_ERR) return;

    redisReply *reply = redisCommand(context, ""COMMAND"");
    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;

    /* Scan the array reported by COMMAND and fill only the entries that
     * don't already match what we have. */
    for (size_t j = 0; j < reply->elements; j++) {
        redisReply *entry = reply->element[j];
        if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
            entry->element[0]->type != REDIS_REPLY_STRING ||
            entry->element[1]->type != REDIS_REPLY_INTEGER ||
            entry->element[3]->type != REDIS_REPLY_INTEGER) return;
        char *cmdname = entry->element[0]->str;
        int i;

        for (i = 0; i < helpEntriesLen; i++) {
            helpEntry *he = helpEntries+i;
            if (!strcasecmp(he->argv[0],cmdname))
                break;
        }
        if (i != helpEntriesLen) continue;

        helpEntries...",447.0,500.0,1.0,19.0,54.0,117,17,72,18,1,38,13,19,4,8,,0,37,2,1,1,void
3909,277960,sdscat_orempty,1,sdscat_orempty,"sds sdscat_orempty (sds,char*)",redis-cli.c,"static sds sdscat_orempty(sds params, const char *value) {
    if (value[0] == '\0') {
        return sdscat(params, ""\""\"""");
    }
    return sdscat(params, value);
}",503.0,508.0,1.0,1.0,6.0,2,2,4,2,2,2,2,2,0,2,,0,0,4,2,2,sds
3910,277981,makeHint,1,makeHint,"sds makeHint (char**,int,int,commandDocs)",redis-cli.c,"static sds makeHint(char **inputargv, int inputargc, int cmdlen, struct commandDocs docs) {
    sds hint;

    if (docs.args) {
        /* Remove arguments from the returned hint to show only the
         * ones the user did not yet type. */
        clearMatchedArgs(docs.args, docs.numargs);
        hint = sdsempty();
        int matchedWords = 0;
        if (inputargv && inputargc)
            matchedWords = matchArgs(inputargv + cmdlen, inputargc - cmdlen, docs.args, docs.numargs);
        if (matchedWords == inputargc - cmdlen) {
            hint = addHintForArguments(hint, docs.args, docs.numargs, "" "");
        }
        return hint;
    }

    /* If arg specs are not available, show the hint string until the user types something. */
    if (inputargc <= cmdlen) {
        hint = sdsnew(docs.params);
    } else {
        hint = sdsempty();
    }
    return hint;
}",1441.0,1465.0,1.0,1.0,25.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,sds
3911,277989,cliAddCommandDocArg,1,cliAddCommandDocArg,"void cliAddCommandDocArg (cliCommandArg*,redisReply*)",redis-cli.c,"static void cliAddCommandDocArg(cliCommandArg *cmdArg, redisReply *argMap) {
    if (argMap->type != REDIS_REPLY_MAP && argMap->type != REDIS_REPLY_ARRAY) {
        return;
    }

    for (size_t i = 0; i < argMap->elements; i += 2) {
        assert(argMap->element[i]->type == REDIS_REPLY_STRING);
        char *key = argMap->element[i]->str;
        if (!strcmp(key, ""name"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->name = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""display_text"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->display_text = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""token"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->token = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""type"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY...",520.0,580.0,1.0,37.0,61.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3912,277995,cliMakeCommandDocArgs,1,cliMakeCommandDocArgs,"void cliMakeCommandDocArgs (redisReply*,cliCommandArg*)",redis-cli.c,"static void cliMakeCommandDocArgs(redisReply *arguments, cliCommandArg *result) {
    for (size_t j = 0; j < arguments->elements; j++) {
        cliAddCommandDocArg(&result[j], arguments->element[j]);
    }
}",514.0,518.0,1.0,1.0,5.0,7,5,7,3,0,1,2,2,0,1,,0,0,4,2,2,void
3913,278481,cliFillInCommandHelpEntry,1,cliFillInCommandHelpEntry,"void cliFillInCommandHelpEntry (helpEntry*,char*,char*)",redis-cli.c,"static void cliFillInCommandHelpEntry(helpEntry *help, char *cmdname, char *subcommandname) {
    help->argc = subcommandname ? 2 : 1;
    help->argv = zmalloc(sizeof(sds) * help->argc);
    help->argv[0] = sdsnew(cmdname);
    sdstoupper(help->argv[0]);
    if (subcommandname) {
        /* Subcommand name may be two words separated by a pipe character. */
        char *pipe = strchr(subcommandname, '|');
        if (pipe != NULL) {
            help->argv[1] = sdsnew(pipe + 1);
        } else {
            help->argv[1] = sdsnew(subcommandname);
        }
        sdstoupper(help->argv[1]);
    }
    sds fullname = sdsnew(help->argv[0]);
    if (subcommandname) {
        fullname = sdscat(fullname, "" "");
        fullname = sdscat(fullname, help->argv[1]);
    }
    help->full = fullname;
    help->type = CLI_HELP_COMMAND;

    help->docs.name = help->full;
    help->docs.params = NULL;
    help->docs.args = NULL;
    help->docs.numargs = 0;
    help->docs.since = NULL;
}",583.0,611.0,1.0,17.0,29.0,48,9,36,7,2,25,4,5,0,8,,0,23,6,3,3,void
3914,278636,cliInitCommandHelpEntry,1,cliInitCommandHelpEntry,"helpEntry cliInitCommandHelpEntry (char*,char*,helpEntry*,redisReply*,dict*)",redis-cli.c,"static helpEntry *cliInitCommandHelpEntry(char *cmdname, char *subcommandname,
                                          helpEntry *next, redisReply *specs,
                                          dict *groups) {
    helpEntry *help = next++;
    cliFillInCommandHelpEntry(help, cmdname, subcommandname);

    assert(specs->type == REDIS_REPLY_MAP || specs->type == REDIS_REPLY_ARRAY);
    for (size_t j = 0; j < specs->elements; j += 2) {
        assert(specs->element[j]->type == REDIS_REPLY_STRING);
        char *key = specs->element[j]->str;
        if (!strcmp(key, ""summary"")) {
            redisReply *reply = specs->element[j + 1];
            assert(reply->type == REDIS_REPLY_STRING);
            help->docs.summary = sdsnew(reply->str);
        } else if (!strcmp(key, ""since"")) {
            redisReply *reply = specs->element[j + 1];
            assert(reply->type == REDIS_REPLY_STRING);
            help->docs.since = sdsnew(reply->str);
        } else if (!strcmp(key, ""group""))...",619.0,665.0,1.0,48.0,47.0,29,10,27,11,1,3,3,4,0,2,,0,2,10,5,5,helpEntry
3915,278985,cliCountCommands,1,cliCountCommands,size_t cliCountCommands (redisReply*),redis-cli.c,"static size_t cliCountCommands(redisReply* commandTable) {
    size_t numCommands = commandTable->elements / 2;

    /* The command docs table maps command names to a map of their specs. */    
    for (size_t i = 0; i < commandTable->elements; i += 2) {
        assert(commandTable->element[i]->type == REDIS_REPLY_STRING);  /* Command name. */
        assert(commandTable->element[i + 1]->type == REDIS_REPLY_MAP ||
               commandTable->element[i + 1]->type == REDIS_REPLY_ARRAY);
        redisReply *map = commandTable->element[i + 1];
        for (size_t j = 0; j < map->elements; j += 2) {
            assert(map->element[j]->type == REDIS_REPLY_STRING);
            char *key = map->element[j]->str;
            if (!strcmp(key, ""subcommands"")) {
                redisReply *subcommands = map->element[j + 1];
                assert(subcommands->type == REDIS_REPLY_MAP || subcommands->type == REDIS_REPLY_ARRAY);
                numCommands += subcommands->elements / 2;
           ...",668.0,688.0,1.0,1.0,21.0,49,10,37,10,1,0,4,7,0,0,,0,0,2,1,1,size_t
3916,279129,helpEntryCompare,1,helpEntryCompare,"int helpEntryCompare (void*,void*)",redis-cli.c,"int helpEntryCompare(const void *entry1, const void *entry2) {
    helpEntry *i1 = (helpEntry *)entry1;
    helpEntry *i2 = (helpEntry *)entry2;
    return strcmp(i1->full, i2->full);
}",691.0,695.0,1.0,1.0,5.0,6,3,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
3917,279155,cliInitGroupHelpEntries,1,cliInitGroupHelpEntries,void cliInitGroupHelpEntries (dict*),redis-cli.c,"void cliInitGroupHelpEntries(dict *groups) {
    dictIterator *iter = dictGetIterator(groups);
    dictEntry *entry;
    helpEntry tmp;

    int numGroups = dictSize(groups);
    int pos = helpEntriesLen;
    helpEntriesLen += numGroups;
    helpEntries = zrealloc(helpEntries, sizeof(helpEntry)*helpEntriesLen);

    for (entry = dictNext(iter); entry != NULL; entry = dictNext(iter)) {
        tmp.argc = 1;
        tmp.argv = zmalloc(sizeof(sds));
        tmp.argv[0] = sdscatprintf(sdsempty(),""@%s"",(char *)dictGetKey(entry));
        tmp.full = tmp.argv[0];
        tmp.type = CLI_HELP_GROUP;
        tmp.docs.name = NULL;
        tmp.docs.params = NULL;
        tmp.docs.args = NULL;
        tmp.docs.numargs = 0;
        tmp.docs.summary = NULL;
        tmp.docs.since = NULL;
        tmp.docs.group = NULL;
        helpEntries[pos++] = tmp;
    }
    dictReleaseIterator(iter);
}",701.0,727.0,1.0,20.0,27.0,53,11,43,11,2,30,2,2,0,8,,0,29,2,1,1,void
3918,279311,cliInitCommandHelpEntries,1,cliInitCommandHelpEntries,"void cliInitCommandHelpEntries (redisReply*,dict*)",redis-cli.c,"void cliInitCommandHelpEntries(redisReply *commandTable, dict *groups) {
    helpEntry *next = helpEntries;
    for (size_t i = 0; i < commandTable->elements; i += 2) {
        assert(commandTable->element[i]->type == REDIS_REPLY_STRING);
        char *cmdname = commandTable->element[i]->str;

        assert(commandTable->element[i + 1]->type == REDIS_REPLY_MAP ||
               commandTable->element[i + 1]->type == REDIS_REPLY_ARRAY);
        redisReply *cmdspecs = commandTable->element[i + 1];
        next = cliInitCommandHelpEntry(cmdname, NULL, next, cmdspecs, groups);
    }
}",730.0,741.0,1.0,1.0,12.0,28,7,26,11,1,2,2,2,0,1,,0,2,4,2,2,void
3919,279398,versionIsSupported,1,versionIsSupported,"int versionIsSupported (sds,sds)",redis-cli.c,"static int versionIsSupported(sds version, sds since) {
    int i;
    char *versionPos = version;
    char *sincePos = since;
    if (!since) {
        return 1;
    }

    for (i = 0; i != 3; i++) {
        int versionPart = atoi(versionPos);
        int sincePart = atoi(sincePos);
        if (versionPart > sincePart) {
            return 1;
        } else if (sincePart > versionPart) {
            return 0;
        }
        versionPos = strchr(versionPos, '.');
        sincePos = strchr(sincePos, '.');
        if (!versionPos || !sincePos)
            return 0;
        versionPos++;
        sincePos++;
    }
    return 0;
}",745.0,769.0,1.0,1.0,25.0,15,6,21,7,4,0,5,7,0,0,,0,0,4,2,2,int
3920,279481,removeUnsupportedArgs,1,removeUnsupportedArgs,"void removeUnsupportedArgs (cliCommandArg*,int*,sds)",redis-cli.c,"static void removeUnsupportedArgs(struct cliCommandArg *args, int *numargs, sds version) {
    int i = 0, j;
    while (i != *numargs) {
        if (versionIsSupported(version, args[i].since)) {
            if (args[i].subargs) {
                removeUnsupportedArgs(args[i].subargs, &args[i].numsubargs, version);
            }
            i++;
            continue;
        }
        for (j = i; j != *numargs; j++) {
            args[j] = args[j + 1];
        }
        (*numargs)--;
    }
}",771.0,786.0,1.0,1.0,16.0,22,9,23,5,1,1,6,9,1,1,,0,1,6,3,3,void
3921,279555,cliLegacyInitCommandHelpEntry,1,cliLegacyInitCommandHelpEntry,"helpEntry cliLegacyInitCommandHelpEntry (char*,char*,helpEntry*,commandDocs*,dict*,sds)",redis-cli.c,"static helpEntry *cliLegacyInitCommandHelpEntry(char *cmdname, char *subcommandname,
                                                helpEntry *next, struct commandDocs *command,
                                                dict *groups, sds version) {
    helpEntry *help = next++;
    cliFillInCommandHelpEntry(help, cmdname, subcommandname);
    
    help->docs.summary = sdsnew(command->summary);
    help->docs.since = sdsnew(command->since);
    help->docs.group = sdsnew(command->group);
    sds group = sdsdup(help->docs.group);
    if (dictAdd(groups, group, NULL) != DICT_OK) {
        sdsfree(group);
    }

    if (command->args != NULL) {
        help->docs.args = command->args;
        help->docs.numargs = command->numargs;
        if (version)
            removeUnsupportedArgs(help->docs.args, &help->docs.numargs, version);
        help->docs.params = makeHint(NULL, 0, 0, help->docs);
    }

    if (command->subcommands != NULL) {
        for (size_t i = 0; command->subcom...",788.0,820.0,1.0,40.0,33.0,57,9,52,10,1,31,7,11,6,10,,0,28,12,6,6,helpEntry
3922,279744,cliLegacyInitCommandHelpEntries,1,cliLegacyInitCommandHelpEntries,"int cliLegacyInitCommandHelpEntries (commandDocs*,dict*,sds)",redis-cli.c,"int cliLegacyInitCommandHelpEntries(struct commandDocs *commands, dict *groups, sds version) {
    helpEntry *next = helpEntries;
    for (size_t i = 0; commands[i].name != NULL; i++) {
        if (!version || versionIsSupported(version, commands[i].since)) {
            next = cliLegacyInitCommandHelpEntry(commands[i].name, NULL, next, &commands[i], groups, version);
        }
    }
    return next - helpEntries;
}",822.0,830.0,1.0,1.0,9.0,15,8,21,7,1,4,3,4,1,2,,0,4,6,3,3,int
3923,279803,cliLegacyCountCommands,1,cliLegacyCountCommands,"size_t cliLegacyCountCommands (commandDocs*,sds)",redis-cli.c,"static size_t cliLegacyCountCommands(struct commandDocs *commands, sds version) {
    int numCommands = 0;
    for (size_t i = 0; commands[i].name != NULL; i++) {
        if (version && !versionIsSupported(version, commands[i].since)) {
            continue;
        }
        numCommands++;
        if (commands[i].subcommands != NULL) {
            numCommands += cliLegacyCountCommands(commands[i].subcommands, version);
        }
    }
    return numCommands;
}",835.0,847.0,1.0,1.0,13.0,16,8,18,5,1,1,5,6,1,1,,0,1,4,2,2,size_t
3924,279864,cliGetServerVersion,1,cliGetServerVersion,sds cliGetServerVersion (void),redis-cli.c,"static sds cliGetServerVersion(void) {
    static const char *key = ""\nredis_version:"";
    redisReply *serverInfo = NULL;
    char *pos;

    if (config.server_version != NULL) {
        return config.server_version;
    }

    if (!context) return NULL;
    serverInfo = redisCommand(context, ""INFO SERVER"");
    if (serverInfo == NULL || serverInfo->type == REDIS_REPLY_ERROR) {
        freeReplyObject(serverInfo);
        return sdsempty();
    }

    assert(serverInfo->type == REDIS_REPLY_STRING || serverInfo->type == REDIS_REPLY_VERB);
    sds info = serverInfo->str;

    /* Finds the first appearance of ""redis_version"" in the INFO SERVER reply. */
    pos = strstr(info, key);
    if (pos) {
        pos += strlen(key);
        char *end = strchr(pos, '\r');
        if (end) {
            sds version = sdsnewlen(pos, end - pos);
            freeReplyObject(serverInfo);
            config.server_version = version;
            return version;
        }
    }
    freeReplyObject(serv...",852.0,885.0,1.0,1.0,34.0,25,9,40,12,1,8,6,7,2,2,,0,7,2,1,1,sds
3925,279975,cliLegacyInitHelp,1,cliLegacyInitHelp,void cliLegacyInitHelp (dict*),redis-cli.c,"static void cliLegacyInitHelp(dict *groups) {
    sds serverVersion = cliGetServerVersion();
    
    /* Scan the commandDocs array and fill in the entries */
    helpEntriesLen = cliLegacyCountCommands(redisCommandTable, serverVersion);
    helpEntries = zmalloc(sizeof(helpEntry)*helpEntriesLen);

    helpEntriesLen = cliLegacyInitCommandHelpEntries(redisCommandTable, groups, serverVersion);
    cliInitGroupHelpEntries(groups);

    qsort(helpEntries, helpEntriesLen, sizeof(helpEntry), helpEntryCompare);
    dictRelease(groups);
}",887.0,899.0,1.0,1.0,13.0,7,3,16,6,2,14,1,1,0,6,,0,12,2,1,1,void
3926,280012,cliInitHelp,1,cliInitHelp,void cliInitHelp (void),redis-cli.c,"static void cliInitHelp(void) {
    /* Dict type for a set of strings, used to collect names of command groups. */
    dictType groupsdt = {
        dictSdsHash,                /* hash function */
        NULL,                       /* key dup */
        NULL,                       /* val dup */
        dictSdsKeyCompare,          /* key compare */
        dictSdsDestructor,          /* key destructor */
        NULL,                       /* val destructor */
        NULL                        /* allow to expand */
    };
    redisReply *commandTable;
    dict *groups;

    if (cliConnect(CC_QUIET) == REDIS_ERR) {
        /* Can not connect to the server, but we still want to provide
         * help, generate it only from the static cli_commands.c data instead. */
        groups = dictCreate(&groupsdt);
        cliLegacyInitHelp(groups);
        return;
    }
    commandTable = redisCommand(context, ""COMMAND DOCS"");
    if (commandTable == NULL || commandTable->type == REDIS_REPLY...",904.0,949.0,1.0,19.0,46.0,25,11,38,12,4,19,4,4,1,12,,0,13,2,1,1,void
3927,280120,cliOutputCommandHelp,1,cliOutputCommandHelp,"void cliOutputCommandHelp (commandDocs*,int)",redis-cli.c,"static void cliOutputCommandHelp(struct commandDocs *help, int group) {
    printf(""\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n"", help->name, help->params);
    printf(""  \x1b[33msummary:\x1b[0m %s\r\n"", help->summary);
    if (help->since != NULL) {
        printf(""  \x1b[33msince:\x1b[0m %s\r\n"", help->since);
    }
    if (group) {
        printf(""  \x1b[33mgroup:\x1b[0m %s\r\n"", help->group);
    }
}",952.0,961.0,1.0,1.0,10.0,7,2,8,3,1,6,3,3,1,0,,0,6,4,2,2,void
3928,280159,cliOutputGenericHelp,1,cliOutputGenericHelp,void cliOutputGenericHelp (void),redis-cli.c,"static void cliOutputGenericHelp(void) {
    sds version = cliVersion();
    printf(
        ""redis-cli %s\n""
        ""To get help about Redis commands type:\n""
        ""      \""help @<group>\"" to get a list of commands in <group>\n""
        ""      \""help <command>\"" for help on <command>\n""
        ""      \""help <tab>\"" to get a list of possible help topics\n""
        ""      \""quit\"" to exit\n""
        ""\n""
        ""To set redis-cli preferences:\n""
        ""      \"":set hints\"" enable online hints\n""
        ""      \"":set nohints\"" disable online hints\n""
        ""Set your preferences in ~/.redisclirc\n"",
        version
    );
    sdsfree(version);
}",964.0,981.0,1.0,1.0,18.0,1,1,3,1,1,2,1,1,0,2,,0,1,2,1,1,void
3929,280173,cliOutputHelp,1,cliOutputHelp,"void cliOutputHelp (int,char**)",redis-cli.c,"static void cliOutputHelp(int argc, char **argv) {
    int i, j;
    char *group = NULL;
    helpEntry *entry;
    struct commandDocs *help;

    if (argc == 0) {
        cliOutputGenericHelp();
        return;
    } else if (argc > 0 && argv[0][0] == '@') {
        group = argv[0]+1;
    }

    if (helpEntries == NULL) {
        /* Initialize the help using the results of the COMMAND command.
         * In case we are using redis-cli help XXX, we need to init it. */
        cliInitHelp();
    }

    assert(argc > 0);
    for (i = 0; i < helpEntriesLen; i++) {
        entry = &helpEntries[i];
        if (entry->type != CLI_HELP_COMMAND) continue;

        help = &entry->docs;
        if (group == NULL) {
            /* Compare all arguments */
            if (argc <= entry->argc) {
                for (j = 0; j < argc; j++) {
                    if (strcasecmp(argv[j],entry->argv[j]) != 0) break;
                }
                if (j == argc) {
                    cliOutputCommand...",984.0,1024.0,1.0,27.0,41.0,24,9,29,10,1,10,12,24,5,3,,0,7,4,2,2,void
3930,280320,completionCallback,1,completionCallback,"void completionCallback (char*,linenoiseCompletions*)",redis-cli.c,"static void completionCallback(const char *buf, linenoiseCompletions *lc) {
    size_t startpos = 0;
    int mask;
    int i;
    size_t matchlen;
    sds tmp;

    if (strncasecmp(buf,""help "",5) == 0) {
        startpos = 5;
        while (isspace(buf[startpos])) startpos++;
        mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;
    } else {
        mask = CLI_HELP_COMMAND;
    }

    for (i = 0; i < helpEntriesLen; i++) {
        if (!(helpEntries[i].type & mask)) continue;

        matchlen = strlen(buf+startpos);
        if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {
            tmp = sdsnewlen(buf,startpos);
            tmp = sdscat(tmp,helpEntries[i].full);
            linenoiseAddCompletion(lc,tmp);
            sdsfree(tmp);
        }
    }
}",1027.0,1053.0,1.0,15.0,27.0,22,9,30,9,0,7,7,9,3,3,,0,6,4,2,2,void
3931,280429,addHintForArgument,1,addHintForArgument,"sds addHintForArgument (sds,cliCommandArg*)",redis-cli.c,"static sds addHintForArgument(sds hint, cliCommandArg *arg) {
    if (arg->matched_all) {
        return hint;
    }

    /* Surround an optional arg with brackets, unless it's partially matched. */
    if ((arg->flags & CMD_ARG_OPTIONAL) && !arg->matched) {
        hint = sdscat(hint, ""["");
    }

    /* Start with the token, if present and not matched. */
    if (arg->token != NULL && !arg->matched_token) {
        hint = sdscat_orempty(hint, arg->token);
        if (arg->type != ARG_TYPE_PURE_TOKEN) {
            hint = sdscat(hint, "" "");
        }
    }

    /* Add the body of the syntax string. */
    switch (arg->type) {
     case ARG_TYPE_ONEOF:
        if (arg->matched == 0) {
            hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, ""|"");
        } else {
            int i;
            for (i = 0; i < arg->numsubargs; i++) {
                if (arg->subargs[i].matched != 0) {
                    hint = addHintForArgument(hint, &arg->subargs[i]);
          ...",1176.0,1230.0,1.0,22.0,55.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,sds
3932,280435,addSeparator,1,addSeparator,"sds addSeparator (sds,size_t*,char*,int)",redis-cli.c,"static sds addSeparator(sds str, size_t *len, char *separator, int is_last) {
    if (sdslen(str) > *len && !is_last) {
        str = sdscat(str, separator);
        *len = sdslen(str);
    }
    return str;
}",1061.0,1067.0,1.0,1.0,7.0,7,5,9,4,3,3,2,2,1,3,,0,3,8,4,4,sds
3933,280465,clearMatchedArgs,1,clearMatchedArgs,"void clearMatchedArgs (cliCommandArg*,int)",redis-cli.c,"static void clearMatchedArgs(cliCommandArg *args, int numargs) {
    for (int i = 0; i != numargs; ++i) {
        args[i].matched = 0;
        args[i].matched_token = 0;
        args[i].matched_name = 0;
        args[i].matched_all = 0;
        if (args[i].subargs) {
            clearMatchedArgs(args[i].subargs, args[i].numsubargs);
        }
    }
}",1070.0,1080.0,1.0,1.0,11.0,20,4,17,3,1,0,3,4,0,0,,0,0,4,2,2,void
3934,280529,addHintForArguments,1,addHintForArguments,"sds addHintForArguments (sds,cliCommandArg*,int,char*)",redis-cli.c,"static sds addHintForArguments(sds hint, cliCommandArg *args, int numargs, char *separator) {
    int i, j, incomplete;
    size_t len=sdslen(hint);
    for (i = 0; i < numargs; i++) {
        if (!(args[i].flags & CMD_ARG_OPTIONAL)) {
            hint = addHintForArgument(hint, &args[i]);
            hint = addSeparator(hint, &len, separator, i == numargs-1);
            continue;
        }

        /* The rule is that successive ""optional"" arguments can appear in any order.
         * But if they are followed by a required argument, no more of those optional arguments
         * can appear after that.
         * 
         * This code handles all successive optional args together. This lets us show the
         * completion of the currently-incomplete optional arg first, if there is one.
         */
        for (j = i, incomplete = -1; j < numargs; j++) {
            if (!(args[j].flags & CMD_ARG_OPTIONAL)) break;
            if (args[j].matched != 0 && args[j].matched_all == 0) {
...",1085.0,1127.0,1.0,30.0,43.0,56,15,61,8,2,7,11,21,0,7,,0,7,8,4,4,sds
3935,280715,addHintForRepeatedArgument,1,addHintForRepeatedArgument,"sds addHintForRepeatedArgument (sds,cliCommandArg*)",redis-cli.c,"static sds addHintForRepeatedArgument(sds hint, cliCommandArg *arg) {
    if (!(arg->flags & CMD_ARG_MULTIPLE)) {
        return hint;
    }

    /* The repeating part is always shown at the end of the argument's hint,
     * so we can safely clear its matched flags before printing it.
     */
    clearMatchedArgs(arg, 1);
        
    if (hint[0] != '\0') {
        hint = sdscat(hint, "" "");
    }
    hint = sdscat(hint, ""["");

    if (arg->flags & CMD_ARG_MULTIPLE_TOKEN) {
        hint = sdscat_orempty(hint, arg->token);
        if (arg->type != ARG_TYPE_PURE_TOKEN) {
            hint = sdscat(hint, "" "");
        }
    }

    switch (arg->type) {
     case ARG_TYPE_ONEOF:
        hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, ""|"");
        break;

    case ARG_TYPE_BLOCK:
        hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, "" "");
        break;

    case ARG_TYPE_PURE_TOKEN:
        break;

    default:
        hint = sdscat_orempty(hint, arg->di...",1132.0,1173.0,1.0,23.0,42.0,29,8,36,5,0,21,10,7,4,9,,0,20,4,2,2,sds
3936,281039,matchArg,1,matchArg,"int matchArg (char**,int,cliCommandArg*)",redis-cli.c,"static int matchArg(char **nextword, int numwords, cliCommandArg *arg) {
    int matchedWords = 0;
    int matchedOnce = matchArgOnce(nextword, numwords, arg);
    if (!(arg->flags & CMD_ARG_MULTIPLE)) {
        return matchedOnce;
    }

    /* Found one match; now match a ""multiple"" argument as many times as possible. */
    matchedWords += matchedOnce;
    while (arg->matched_all && matchedWords < numwords) {
        clearMatchedArgs(arg, 1);
        if (arg->token != NULL && !(arg->flags & CMD_ARG_MULTIPLE_TOKEN)) {
            /* The token only appears the first time; the rest of the times,
             * pretend we saw it so we don't hint it.
             */
            matchedOnce = matchNoTokenArg(nextword + matchedWords, numwords - matchedWords, arg);
            if (arg->matched) {
                arg->matched_token = 1;
            }
        } else {
            matchedOnce = matchArgOnce(nextword + matchedWords, numwords - matchedWords, arg);
        }
        matchedWor...",1341.0,1367.0,1.0,23.0,27.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
3937,281046,matchArgs,1,matchArgs,"int matchArgs (char**,int,cliCommandArg*,int)",redis-cli.c,"static int matchArgs(char **words, int numwords, cliCommandArg *args, int numargs) {
    int nextword, nextarg, matchedWords;
    for (nextword = 0, nextarg = 0; nextword != numwords && nextarg != numargs; ++nextarg) {
        /* Optional args can occur in any order. Collect a range of consecutive optional args
         * and try to match them as a group against the next input words.
         */
        if (args[nextarg].flags & CMD_ARG_OPTIONAL) {
            int lastoptional;
            for (lastoptional = nextarg; lastoptional < numargs; lastoptional++) {
                if (!(args[lastoptional].flags & CMD_ARG_OPTIONAL)) break;
            }
            matchedWords = matchOptionalArgs(&words[nextword], numwords - nextword, &args[nextarg], lastoptional - nextarg);
            nextarg = lastoptional - 1;
        } else {
            matchedWords = matchArg(&words[nextword], numwords - nextword, &args[nextarg]);
            if (matchedWords == 0) {
                /* Couldn't mat...",1410.0,1434.0,1.0,34.0,25.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
3938,281054,matchNoTokenArg,1,matchNoTokenArg,"int matchNoTokenArg (char**,int,cliCommandArg*)",redis-cli.c,"static int matchNoTokenArg(char **nextword, int numwords, cliCommandArg *arg) {
    int i;
    switch (arg->type) {
    case ARG_TYPE_BLOCK: {
        arg->matched += matchArgs(nextword, numwords, arg->subargs, arg->numsubargs);

        /* All the subargs must be matched for the block to match. */
        arg->matched_all = 1;
        for (i = 0; i < arg->numsubargs; i++) {
            if (arg->subargs[i].matched_all == 0) {
                arg->matched_all = 0;
            }
        }
        break;
    }
    case ARG_TYPE_ONEOF: {
        for (i = 0; i < arg->numsubargs; i++) {
            if (matchArg(nextword, numwords, &arg->subargs[i])) {
                arg->matched += arg->subargs[i].matched;
                arg->matched_all = arg->subargs[i].matched_all;
                break;
            }
        }
        break;
    }

    case ARG_TYPE_INTEGER:
    case ARG_TYPE_UNIX_TIME: {
        long long value;
        if (sscanf(*nextword, ""%lld"", &value)) {
            arg->matc...",1236.0,1298.0,1.0,1.0,63.0,55,9,45,10,1,26,14,16,6,2,,0,25,6,3,3,int
3939,281272,matchToken,1,matchToken,"int matchToken (char**,cliCommandArg*)",redis-cli.c,"static int matchToken(char **nextword, cliCommandArg *arg) {
    if (strcasecmp(arg->token, nextword[0]) != 0) {
        return 0;
    }
    arg->matched_token = 1;
    arg->matched = 1;
    return 1;
}",1301.0,1308.0,1.0,1.0,8.0,7,4,4,2,1,3,2,2,1,0,,0,3,4,2,2,int
3940,281303,matchArgOnce,1,matchArgOnce,"int matchArgOnce (char**,int,cliCommandArg*)",redis-cli.c,"static int matchArgOnce(char **nextword, int numwords, cliCommandArg *arg) {
    /* First match the token, if present. */
    if (arg->token != NULL) {
        if (!matchToken(nextword, arg)) {
            return 0;
        }
        if (arg->type == ARG_TYPE_PURE_TOKEN) {
            arg->matched_all = 1;
            return 1;
        }
        if (numwords == 1) {
            return 1;
        }
        nextword++;
        numwords--;
    }

    /* Then match the rest of the argument. */
    if (!matchNoTokenArg(nextword, numwords, arg)) {
        return 0;
    }
    return arg->matched;
}",1314.0,1336.0,1.0,1.0,23.0,12,7,14,5,0,6,6,9,4,2,,0,6,6,3,3,int
3941,281470,matchOneOptionalArg,1,matchOneOptionalArg,"int matchOneOptionalArg (char**,int,cliCommandArg*,int,int*)",redis-cli.c,"static int matchOneOptionalArg(char **words, int numwords, cliCommandArg *args, int numargs, int *matchedarg) {
    for (int nextword = 0, nextarg = 0; nextword != numwords && nextarg != numargs; ++nextarg) {
        if (args[nextarg].matched) {
            /* Already matched this arg. */
            continue;
        }

        int matchedWords = matchArg(&words[nextword], numwords - nextword, &args[nextarg]);
        if (matchedWords != 0) {
            *matchedarg = nextarg;
            return matchedWords;
        }
    }
    return 0;
}",1372.0,1386.0,1.0,1.0,15.0,16,8,19,8,1,1,5,6,0,1,,0,1,10,5,5,int
3942,281535,matchOptionalArgs,1,matchOptionalArgs,"int matchOptionalArgs (char**,int,cliCommandArg*,int)",redis-cli.c,"static int matchOptionalArgs(char **words, int numwords, cliCommandArg *args, int numargs) {
    int nextword = 0;
    int matchedarg = -1, lastmatchedarg = -1;
    while (nextword != numwords) {
        int matchedWords = matchOneOptionalArg(&words[nextword], numwords - nextword, args, numargs, &matchedarg);
        if (matchedWords == 0) {
            break;
        }
        /* Successfully matched an optional arg; mark any previous match as completed
         * so it won't be partially hinted.
         */
        if (lastmatchedarg != -1) {
            args[lastmatchedarg].matched_all = 1;
        }
        lastmatchedarg = matchedarg;
        nextword += matchedWords;
    }
    return nextword;
}",1389.0,1407.0,1.0,1.0,19.0,19,9,22,8,0,1,5,6,0,1,,0,1,8,4,4,int
3943,281810,findHelpEntry,1,findHelpEntry,"helpEntry findHelpEntry (int,char**)",redis-cli.c,"static helpEntry* findHelpEntry(int argc, char **argv) {
    helpEntry *entry = NULL;
    int i, rawargc, matchlen = 0;
    sds *rawargv;

    for (i = 0; i < helpEntriesLen; i++) {
        if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;

        rawargv = helpEntries[i].argv;
        rawargc = helpEntries[i].argc;
        if (rawargc <= argc) {
            int j;
            for (j = 0; j < rawargc; j++) {
                if (strcasecmp(rawargv[j],argv[j])) {
                    break;
                }
            }
            if (j == rawargc && rawargc > matchlen) {
                matchlen = rawargc;
                entry = &helpEntries[i];
            }
        }
    }
    return entry;
}",1468.0,1492.0,1.0,36.0,25.0,26,11,33,11,1,5,9,16,2,0,,0,5,4,2,2,helpEntry
3944,281912,getHintForInput,1,getHintForInput,sds getHintForInput (char*),redis-cli.c,"static sds getHintForInput(const char *charinput) {
    sds hint = NULL;
    int inputargc, inputlen = strlen(charinput);
    sds *inputargv = sdssplitargs(charinput, &inputargc);
    int endspace = inputlen && isspace(charinput[inputlen-1]);

    /* Don't match the last word until the user has typed a space after it. */
    int matchargc = endspace ? inputargc : inputargc - 1;

    helpEntry *entry = findHelpEntry(matchargc, inputargv);
    if (entry) {
       hint = makeHint(inputargv, matchargc, entry->argc, entry->docs);
    }
    sdsfreesplitres(inputargv, inputargc);
    return hint;
}",1495.0,1510.0,1.0,1.0,16.0,15,7,27,9,3,6,2,2,0,4,,0,5,2,1,1,sds
3945,281979,hintsCallback,1,hintsCallback,"char* hintsCallback (char*,int*,int*)",redis-cli.c,"static char *hintsCallback(const char *buf, int *color, int *bold) {
    if (!pref.hints) return NULL;

    sds hint = getHintForInput(buf);
    if (hint == NULL) {
        return NULL;
    }

    *color = 90;
    *bold = 0;

    /* Add an initial space if needed. */
    int len = strlen(buf);
    int endspace = len && isspace(buf[len-1]);
    if (!endspace) {
        sds newhint = sdsnewlen("" "",1);
        newhint = sdscatsds(newhint,hint);
        sdsfree(hint);
        hint = newhint;
    }

    return hint;
}",1513.0,1535.0,1.0,1.0,23.0,17,8,24,9,0,6,4,4,2,4,,0,5,6,3,3,char*
3946,282052,freeHintsCallback,1,freeHintsCallback,void freeHintsCallback (void*),redis-cli.c,"static void freeHintsCallback(void *ptr) {
    sdsfree(ptr);
}",1537.0,1539.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3947,282059,cliRestoreTTY,1,cliRestoreTTY,void cliRestoreTTY (void),redis-cli.c,"void cliRestoreTTY(void) {
    if (orig_termios_saved)
        tcsetattr(STDIN_FILENO, TCSANOW, &orig_termios);
}",1546.0,1549.0,1.0,1.0,4.0,1,1,4,4,1,2,2,2,1,0,,0,2,2,1,1,void
3948,282072,cliPressAnyKeyTTY,1,cliPressAnyKeyTTY,void cliPressAnyKeyTTY (void),redis-cli.c,"static void cliPressAnyKeyTTY(void) {
    if (!isatty(STDIN_FILENO)) return;
    if (!orig_termios_saved) {
        if (tcgetattr(STDIN_FILENO, &orig_termios) == -1) return;
        atexit(cliRestoreTTY);
        orig_termios_saved = 1;
    }
    struct termios mode = orig_termios;
    mode.c_lflag &= ~(ECHO | ICANON); /* echoing off, canonical off */
    tcsetattr(STDIN_FILENO, TCSANOW, &mode);
}",1552.0,1562.0,1.0,1.0,11.0,11,8,13,7,1,4,4,5,2,0,,0,4,2,1,1,void
3949,282188,cliSelect,1,cliSelect,int cliSelect (void),redis-cli.c,"static int cliSelect(void) {
    redisReply *reply;
    if (config.conn_info.input_dbnum == config.dbnum) return REDIS_OK;

    reply = redisCommand(context,""SELECT %d"",config.conn_info.input_dbnum);
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr,""SELECT %d failed: %s\n"",config.conn_info.input_dbnum,reply->str);
    } else {
        config.dbnum = config.conn_info.input_dbnum;
        cliRefreshPrompt();
    }
    freeReplyObject(reply);
    return result;
}",1593.0,1613.0,1.0,1.0,21.0,15,4,21,9,0,8,4,4,4,0,,0,8,2,1,1,int
3950,282268,cliSwitchProto,1,cliSwitchProto,int cliSwitchProto (void),redis-cli.c,"static int cliSwitchProto(void) {
    redisReply *reply;
    if (!config.resp3 || config.resp2) return REDIS_OK;

    reply = redisCommand(context,""HELLO 3"");
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr,""HELLO 3 failed: %s\n"",reply->str);
        if (config.resp3 == 1) {
            result = REDIS_ERR;
        } else if (config.resp3 == 2) {
            result = REDIS_OK;
        }
    }

    /* Retrieve server version string for later use. */
    for (size_t i = 0; i < reply->elements; i += 2) {
        assert(reply->element[i]->type == REDIS_REPLY_STRING);
        char *key = reply->element[i]->str;
        if (!strcmp(key, ""version"")) {
            assert(reply->element[i + 1]->type == REDIS_REPLY_STRING);
            config.server_version = sdsnew(reply->element[i + 1]->str);
        }
    }
    freeReplyObject(reply);
    config.c...",1616.0,1648.0,1.0,1.0,33.0,38,9,37,12,0,11,7,9,6,1,,0,11,2,1,1,int
3951,282648,cliSendAsking,1,cliSendAsking,int cliSendAsking (void),redis-cli.c,"static int cliSendAsking(void) {
    redisReply *reply;

    config.cluster_send_asking = 0;
    if (context == NULL) {
        return REDIS_ERR;
    }
    reply = redisCommand(context,""ASKING"");
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }
    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr,""ASKING failed: %s\n"",reply->str);
    }
    freeReplyObject(reply);
    return result;
}",1728.0,1747.0,1.0,1.0,20.0,10,4,20,9,1,2,4,4,0,0,,0,2,2,1,1,int
3952,282705,cliPrintContextError,1,cliPrintContextError,void cliPrintContextError (void),redis-cli.c,"static void cliPrintContextError(void) {
    if (context == NULL) return;
    fprintf(stderr,""Error: %s\n"",context->errstr);
}",1749.0,1752.0,1.0,1.0,4.0,2,2,4,3,8,0,2,2,0,0,,0,0,2,1,1,void
3953,282771,cliFormatInvalidateTTY,1,cliFormatInvalidateTTY,sds cliFormatInvalidateTTY (redisReply*),redis-cli.c,"static sds cliFormatInvalidateTTY(redisReply *r) {
    sds out = sdsnew(""-> invalidate: "");

    for (size_t i = 0; i < r->element[1]->elements; i++) {
        redisReply *key = r->element[1]->element[i];
        assert(key->type == REDIS_REPLY_STRING);

        out = sdscatfmt(out, ""'%s'"", key->str, key->len);
        if (i < r->element[1]->elements - 1)
            out = sdscatlen(out, "", "", 2);
    }

    return sdscatlen(out, ""\n"", 1);
}",1764.0,1777.0,1.0,1.0,14.0,22,6,18,5,0,4,3,4,0,4,,0,3,2,1,1,sds
3954,282923,cliFormatReplyTTY,1,cliFormatReplyTTY,"sds cliFormatReplyTTY (redisReply*,char*)",redis-cli.c,"static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
    sds out = sdsempty();
    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscatprintf(out,""(error) %s\n"", r->str);
    break;
    case REDIS_REPLY_STATUS:
        out = sdscat(out,r->str);
        out = sdscat(out,""\n"");
    break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""(integer) %lld\n"",r->integer);
    break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""(double) %s\n"",r->str);
    break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        /* If you are producing output for the standard output we want
        * a more interesting output with quoted characters and so forth,
        * unless it's a verbatim string type. */
        if (r->type == REDIS_REPLY_STRING) {
            out = sdscatrepr(out,r->str,r->len);
            out = sdscat(out,""\n"");
        } else {
            out = sdscatlen(out,r->str,r->len);
            out = sdscat(out,""\n"");
       ...",1797.0,1913.0,1.0,1.0,117.0,27,4,49,15,0,11,13,9,0,11,,0,11,4,2,2,sds
3955,283342,isPubsubPush,1,isPubsubPush,int isPubsubPush (redisReply*),redis-cli.c,"int isPubsubPush(redisReply *r) {
    if (r == NULL ||
        r->type != (config.current_resp3 ? REDIS_REPLY_PUSH : REDIS_REPLY_ARRAY) ||
        r->elements < 3 ||
        r->element[0]->type != REDIS_REPLY_STRING)
    {
        return 0;
    }
    char *str = r->element[0]->str;
    size_t len = r->element[0]->len;
    /* Check if it is [p|s][un]subscribe or [p|s]message, but even simpler, we
     * just check that it ends with ""message"" or ""subscribe"". */
    return ((len >= strlen(""message"") &&
             !strcmp(str + len - strlen(""message""), ""message"")) ||
            (len >= strlen(""subscribe"") &&
             !strcmp(str + len - strlen(""subscribe""), ""subscribe"")));
}",1916.0,1932.0,1.0,1.0,17.0,33,14,19,8,1,2,2,2,2,0,,0,2,2,1,1,int
3956,283431,isColorTerm,1,isColorTerm,int isColorTerm (void),redis-cli.c,"int isColorTerm(void) {
    char *t = getenv(""TERM"");
    return t != NULL && strstr(t,""xterm"") != NULL;
}",1934.0,1937.0,1.0,1.0,4.0,4,3,5,2,2,0,1,1,0,0,,0,0,2,1,1,int
3957,283451,sdscatcolor,1,sdscatcolor,"sds sdscatcolor (sds,char*,size_t,char*)",redis-cli.c,"sds sdscatcolor(sds o, char *s, size_t len, char *color) {
    if (!isColorTerm()) return sdscatlen(o,s,len);

    int bold = strstr(color,""bold"") != NULL;
    int ccode = 37; /* Defaults to white. */
    if (strstr(color,""red"")) ccode = 31;
    else if (strstr(color,""green"")) ccode = 32;
    else if (strstr(color,""yellow"")) ccode = 33;
    else if (strstr(color,""blue"")) ccode = 34;
    else if (strstr(color,""magenta"")) ccode = 35;
    else if (strstr(color,""cyan"")) ccode = 36;
    else if (strstr(color,""white"")) ccode = 37;

    o = sdscatfmt(o,""\033[%i;%i;49m"",bold,ccode);
    o = sdscatlen(o,s,len);
    o = sdscat(o,""\033[0m"");
    return o;
}",1941.0,1958.0,1.0,1.0,18.0,8,3,20,7,1,5,3,3,1,5,,0,4,8,4,4,sds
3958,283568,sdsCatColorizedLdbReply,1,sdsCatColorizedLdbReply,"sds sdsCatColorizedLdbReply (sds,char*,size_t)",redis-cli.c,"sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
    char *color = ""white"";

    if (strstr(s,""<debug>"")) color = ""bold"";
    if (strstr(s,""<redis>"")) color = ""green"";
    if (strstr(s,""<reply>"")) color = ""cyan"";
    if (strstr(s,""<error>"")) color = ""red"";
    if (strstr(s,""<hint>"")) color = ""bold"";
    if (strstr(s,""<value>"") || strstr(s,""<retval>"")) color = ""magenta"";
    if (len > 4 && isdigit(s[3])) {
        if (s[1] == '>') color = ""yellow""; /* Current line. */
        else if (s[2] == '#') color = ""bold""; /* Break point. */
    }
    return sdscatcolor(o,s,len,color);
}",1962.0,1976.0,1.0,1.0,15.0,14,6,22,4,0,1,9,10,0,1,,0,0,6,3,3,sds
3959,283669,cliFormatReplyRaw,1,cliFormatReplyRaw,sds cliFormatReplyRaw (redisReply*),redis-cli.c,"static sds cliFormatReplyRaw(redisReply *r) {
    sds out = sdsempty(), tmp;
    size_t i;

    switch (r->type) {
    case REDIS_REPLY_NIL:
        /* Nothing... */
        break;
    case REDIS_REPLY_ERROR:
        out = sdscatlen(out,r->str,r->len);
        out = sdscatlen(out,""\n"",1);
        break;
    case REDIS_REPLY_STATUS:
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {
            /* The Lua debugger replies with arrays of simple (status)
             * strings. We colorize the output for more fun if this
             * is a debugging session. */

            /* Detect the end of a debugging session. */
            if (strstr(r->str,""<endsession>"") == r->str) {
                config.enable_ldb_on_eval = 0;
                config.eval_ldb = 0;
                config.eval_ldb_end = 1; /* Signal the caller session ended. */
                config.output = OUTPUT_STANDARD;
                cliRefreshPrompt...",1978.0,2049.0,1.0,32.0,72.0,55,10,81,18,1,33,16,17,2,19,,0,29,2,1,1,sds
3960,283949,cliFormatReplyCSV,1,cliFormatReplyCSV,sds cliFormatReplyCSV (redisReply*),redis-cli.c,"static sds cliFormatReplyCSV(redisReply *r) {
    unsigned int i;

    sds out = sdsempty();
    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscat(out,""ERROR,"");
        out = sdscatrepr(out,r->str,strlen(r->str));
    break;
    case REDIS_REPLY_STATUS:
        out = sdscatrepr(out,r->str,r->len);
    break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""%lld"",r->integer);
    break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""%s"",r->str);
        break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        out = sdscatrepr(out,r->str,r->len);
    break;
    case REDIS_REPLY_NIL:
        out = sdscat(out,""NULL"");
    break;
    case REDIS_REPLY_BOOL:
        out = sdscat(out,r->integer ? ""true"" : ""false"");
    break;
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
    case REDIS_REPLY_MAP: /* CSV has no map type, just output flat list. */
        for (i = 0; i < r->elements; i++) {
        ...",2051.0,2095.0,1.0,1.0,45.0,32,7,57,17,0,13,12,7,0,13,,0,12,2,1,1,sds
3961,284119,jsonStringOutput,1,jsonStringOutput,"sds jsonStringOutput (sds,char*,int,int)",redis-cli.c,"static sds jsonStringOutput(sds out, const char *p, int len, int mode) {
    if (mode == OUTPUT_JSON) {
        return escapeJsonString(out, p, len);
    } else if (mode == OUTPUT_QUOTED_JSON) {
        /* Need to double-quote backslashes */
        sds tmp = sdscatrepr(sdsempty(), p, len);
        int tmplen = sdslen(tmp);
        char *n = tmp;
        while (tmplen--) {
            if (*n == '\\') out = sdscatlen(out, ""\\\\"", 2);
            else out = sdscatlen(out, n, 1);
            n++;
        }

        sdsfree(tmp);
        return out;
    } else {
        assert(0);
    }
}",2099.0,2118.0,1.0,16.0,20.0,1,1,4,4,3,1,2,2,0,1,,0,0,8,4,4,sds
3962,284198,cliFormatReplyJson,1,cliFormatReplyJson,"sds cliFormatReplyJson (sds,redisReply*,int)",redis-cli.c,"static sds cliFormatReplyJson(sds out, redisReply *r, int mode) {
    unsigned int i;

    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscat(out,""error:"");
        out = jsonStringOutput(out,r->str,strlen(r->str),mode);
        break;
    case REDIS_REPLY_STATUS:
        out = jsonStringOutput(out,r->str,r->len,mode);
        break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""%lld"",r->integer);
        break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""%s"",r->str);
        break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        out = jsonStringOutput(out,r->str,r->len,mode);
        break;
    case REDIS_REPLY_NIL:
        out = sdscat(out,""null"");
        break;
    case REDIS_REPLY_BOOL:
        out = sdscat(out,r->integer ? ""true"" : ""false"");
        break;
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
        out = sdscat(out,""["");
        for (i = 0; i < r->elements; i++ ) {
 ...",2120.0,2189.0,1.0,1.0,70.0,61,10,93,18,0,15,16,15,0,15,,0,15,6,3,3,sds
3963,284497,cliFormatReply,1,cliFormatReply,"sds cliFormatReply (redisReply*,int,int)",redis-cli.c,"static sds cliFormatReply(redisReply *reply, int mode, int verbatim) {
    sds out;

    if (verbatim) {
        out = cliFormatReplyRaw(reply);
    }  else if (mode == OUTPUT_STANDARD) {
        out = cliFormatReplyTTY(reply, """");
    } else if (mode == OUTPUT_RAW) {
        out = cliFormatReplyRaw(reply);
        out = sdscatsds(out, config.cmd_delim);
    } else if (mode == OUTPUT_CSV) {
        out = cliFormatReplyCSV(reply);
        out = sdscatlen(out, ""\n"", 1);
    } else if (mode == OUTPUT_JSON || mode == OUTPUT_QUOTED_JSON) {
        out = cliFormatReplyJson(sdsempty(), reply, mode);
        out = sdscatlen(out, ""\n"", 1);
    } else {
        fprintf(stderr, ""Error:  Unknown output encoding %d\n"", mode);
        exit(1);
    }

    return out;
}",2192.0,2214.0,1.0,24.0,23.0,1,1,4,3,2,1,2,2,0,1,,0,1,6,3,3,sds
3964,284651,cliReadReply,1,cliReadReply,int cliReadReply (int),redis-cli.c,"static int cliReadReply(int output_raw_strings) {
    void *_reply;
    redisReply *reply;
    sds out = NULL;
    int output = 1;

    if (config.last_reply) {
        freeReplyObject(config.last_reply);
        config.last_reply = NULL;
    }

    if (redisGetReply(context,&_reply) != REDIS_OK) {
        if (config.blocking_state_aborted) {
            config.blocking_state_aborted = 0;
            config.monitor_mode = 0;
            config.pubsub_mode = 0;
            return cliConnect(CC_FORCE);
        }

        if (config.shutdown) {
            redisFree(context);
            context = NULL;
            return REDIS_OK;
        }
        if (config.interactive) {
            /* Filter cases where we should reconnect */
            if (context->err == REDIS_ERR_IO &&
                (errno == ECONNRESET || errno == EPIPE))
                return REDIS_ERR;
            if (context->err == REDIS_ERR_EOF)
                return REDIS_ERR;
        }
        cliPrintContextError(...",2233.0,2320.0,1.0,30.0,88.0,81,13,77,20,4,50,12,21,12,8,,0,44,2,1,1,int
3965,284965,cliWaitForMessagesOrStdin,1,cliWaitForMessagesOrStdin,void cliWaitForMessagesOrStdin (void),redis-cli.c,"static void cliWaitForMessagesOrStdin(void) {
    int show_info = config.output != OUTPUT_RAW && (isatty(STDOUT_FILENO) ||
                                                    getenv(""FAKETTY""));
    int use_color = show_info && isColorTerm();
    cliPressAnyKeyTTY();
    while (config.pubsub_mode) {
        /* First check if there are any buffered replies. */
        redisReply *reply;
        do {
            if (redisGetReplyFromReader(context, (void **)&reply) != REDIS_OK) {
                cliPrintContextError();
                exit(1);
            }
            if (reply) {
                sds out = cliFormatReply(reply, config.output, 0);
                fwrite(out,sdslen(out),1,stdout);
                fflush(stdout);
                sdsfree(out);
            }
        } while(reply);

        /* Wait for input, either on the Redis socket or on stdin. */
        struct timeval tv;
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(context->fd, &readfds);
     ...",2323.0,2385.0,1.0,37.0,63.0,32,10,41,13,1,21,12,25,5,9,,0,15,2,1,1,void
3966,285158,cliSendCommand,1,cliSendCommand,"int cliSendCommand (int,char**,long)",redis-cli.c,"static int cliSendCommand(int argc, char **argv, long repeat) {
    char *command = argv[0];
    size_t *argvlen;
    int j, output_raw;

    if (context == NULL) return REDIS_ERR;

    output_raw = 0;
    if (!strcasecmp(command,""info"") ||
        !strcasecmp(command,""lolwut"") ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""htstats"")) ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""htstats-key"")) ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""client-eviction"")) ||
        (argc >= 2 && !strcasecmp(command,""memory"") &&
                      (!strcasecmp(argv[1],""malloc-stats"") ||
                       !strcasecmp(argv[1],""doctor""))) ||
        (argc == 2 && !strcasecmp(command,""cluster"") &&
                      (!strcasecmp(argv[1],""nodes"") ||
                       !strcasecmp(argv[1],""info""))) ||
        (argc >= 2 && !st...",2387.0,2591.0,1.0,24.0,205.0,184,19,126,18,1,60,30,65,27,12,,0,52,6,3,3,int
3967,286004,reconnectingRedisCommand,1,reconnectingRedisCommand,"redisReply reconnectingRedisCommand (redisContext*,char*...)",redis-cli.c,"static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
    redisReply *reply = NULL;
    int tries = 0;
    va_list ap;

    assert(!c->err);
    while(reply == NULL) {
        while (c->err & (REDIS_ERR_IO | REDIS_ERR_EOF)) {
            printf(""\r\x1b[0K""); /* Cursor to left edge + clear line. */
            printf(""Reconnecting... %d\r"", ++tries);
            fflush(stdout);

            redisFree(c);
            c = redisConnect(config.conn_info.hostip,config.conn_info.hostport);
            if (!c->err && config.tls) {
                const char *err = NULL;
                if (cliSecureConnection(c, config.sslconfig, &err) == REDIS_ERR && err) {
                    fprintf(stderr, ""TLS Error: %s\n"", err);
                    exit(1);
                }
            }
            usleep(1000000);
        }

        va_start(ap,fmt);
        reply = redisvCommand(c,fmt,ap);
        va_end(ap);

        if (c->err && !(c->err & (REDIS_ERR_IO | REDIS_ER...",2594.0,2632.0,1.0,1.0,39.0,32,10,42,14,3,9,6,13,5,1,,0,9,4,2,2,redisReply
3968,288272,parseEnv,1,parseEnv,void parseEnv (void),redis-cli.c,"static void parseEnv(void) {
    /* Set auth from env, but do not overwrite CLI arguments if passed */
    char *auth = getenv(REDIS_CLI_AUTH_ENV);
    if (auth != NULL && config.conn_info.auth == NULL) {
        config.conn_info.auth = auth;
    }

    char *cluster_yes = getenv(REDIS_CLI_CLUSTER_YES_ENV);
    if (cluster_yes != NULL && !strcmp(cluster_yes, ""1"")) {
        config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
    }
}",2971.0,2982.0,1.0,24.0,12.0,16,7,12,4,0,6,3,3,2,0,,0,6,2,1,1,void
3969,288373,confirmWithYes,1,confirmWithYes,"int confirmWithYes (char*,int)",redis-cli.c,"static int confirmWithYes(char *msg, int ignore_force) {
    /* if --cluster-yes option is set and ignore_force is false,
     * do not prompt for an answer */
    if (!ignore_force &&
        (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_YES)) {
        return 1;
    }

    printf(""%s (type 'yes' to accept): "", msg);
    fflush(stdout);
    char buf[4];
    int nread = read(fileno(stdin),buf,4);
    buf[3] = '\0';
    return (nread != 0 && !strcmp(""yes"", buf));
}",3130.0,3144.0,1.0,48.0,15.0,12,8,10,7,3,2,2,2,2,0,,0,2,4,2,2,int
3970,288425,issueCommandRepeat,1,issueCommandRepeat,"int issueCommandRepeat (int,char**,long)",redis-cli.c,"static int issueCommandRepeat(int argc, char **argv, long repeat) {
    /* In Lua debugging mode, we want to pass the ""help"" to Redis to get
     * it's own HELP message, rather than handle it by the CLI, see ldbRepl.
     *
     * For the normal Redis HELP, we can process it without a connection. */
    if (!config.eval_ldb &&
        (!strcasecmp(argv[0],""help"") || !strcasecmp(argv[0],""?"")))
    {
        cliOutputHelp(--argc, ++argv);
        return REDIS_OK;
    }

    while (1) {
        if (config.cluster_reissue_command || context == NULL ||
            context->err == REDIS_ERR_IO || context->err == REDIS_ERR_EOF)
        {
            if (cliConnect(CC_FORCE) != REDIS_OK) {
                cliPrintContextError();
                config.cluster_reissue_command = 0;
                return REDIS_ERR;
            }
        }
        config.cluster_reissue_command = 0;
        if (config.cluster_send_asking) {
            if (cliSendAsking() != REDIS_OK) {
                cliPri...",3146.0,3189.0,1.0,27.0,44.0,32,12,31,10,1,21,11,17,13,7,,0,17,6,3,3,int
3971,288548,issueCommand,1,issueCommand,"int issueCommand (int,char**)",redis-cli.c,"static int issueCommand(int argc, char **argv) {
    return issueCommandRepeat(argc, argv, config.repeat);
}",3191.0,3193.0,1.0,1.0,3.0,1,1,3,3,2,3,1,1,0,1,,0,2,4,2,2,int
3972,288561,cliSplitArgs,1,cliSplitArgs,"sds cliSplitArgs (char*,int*)",redis-cli.c,"static sds *cliSplitArgs(char *line, int *argc) {
    if (config.eval_ldb && (strstr(line,""eval "") == line ||
                            strstr(line,""e "") == line))
    {
        sds *argv = sds_malloc(sizeof(sds)*2);
        *argc = 2;
        int len = strlen(line);
        int elen = line[1] == ' ' ? 2 : 5; /* ""e "" or ""eval ""? */
        argv[0] = sdsnewlen(line,elen-1);
        argv[1] = sdsnewlen(line+elen,len-elen);
        return argv;
    } else {
        return sdssplitargs(line,argc);
    }
}",3201.0,3215.0,1.0,1.0,15.0,22,12,21,7,0,5,2,2,2,3,,0,5,4,2,2,sds
3973,288640,cliSetPreferences,1,cliSetPreferences,"void cliSetPreferences (char**,int,int)",redis-cli.c,"void cliSetPreferences(char **argv, int argc, int interactive) {
    if (!strcasecmp(argv[0],"":set"") && argc >= 2) {
        if (!strcasecmp(argv[1],""hints"")) pref.hints = 1;
        else if (!strcasecmp(argv[1],""nohints"")) pref.hints = 0;
        else {
            printf(""%sunknown redis-cli preference '%s'\n"",
                interactive ? """" : "".redisclirc: "",
                argv[1]);
        }
    } else {
        printf(""%sunknown redis-cli internal command '%s'\n"",
            interactive ? """" : "".redisclirc: "",
            argv[0]);
    }
}",3220.0,3234.0,1.0,1.0,15.0,8,6,4,3,1,2,3,4,0,0,,0,2,6,3,3,void
3974,288709,cliLoadPreferences,1,cliLoadPreferences,void cliLoadPreferences (void),redis-cli.c,"void cliLoadPreferences(void) {
    sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
    if (rcfile == NULL) return;
    FILE *fp = fopen(rcfile,""r"");
    char buf[1024];

    if (fp) {
        while(fgets(buf,sizeof(buf),fp) != NULL) {
            sds *argv;
            int argc;

            argv = sdssplitargs(buf,&argc);
            if (argc > 0) cliSetPreferences(argv,argc,0);
            sdsfreesplitres(argv,argc);
        }
        fclose(fp);
    }
    sdsfree(rcfile);
}",3237.0,3255.0,1.0,32.0,19.0,8,6,20,6,1,5,5,8,0,5,,0,2,2,1,1,void
3975,289018,repl,1,repl,void repl (void),redis-cli.c,"static void repl(void) {
    sds historyfile = NULL;
    int history = 0;
    char *line;
    int argc;
    sds *argv;

    /* There is no need to initialize redis HELP when we are in lua debugger mode.
     * It has its own HELP and commands (COMMAND or COMMAND DOCS will fail and got nothing).
     * We will initialize the redis HELP after the Lua debugging session ended.*/
    if ((!config.eval_ldb) && isatty(fileno(stdin))) {
        /* Initialize the help using the results of the COMMAND command. */
        cliInitHelp();
    }

    config.interactive = 1;
    linenoiseSetMultiLine(1);
    linenoiseSetCompletionCallback(completionCallback);
    linenoiseSetHintsCallback(hintsCallback);
    linenoiseSetFreeHintsCallback(freeHintsCallback);

    /* Only use history and load the rc file when stdin is a tty. */
    if (isatty(fileno(stdin))) {
        historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
        //keep in-memory history always regardless i...",3312.0,3458.0,1.0,37.0,147.0,20,8,22,8,0,18,11,17,7,6,,0,14,2,1,1,void
3976,289473,noninteractive,1,noninteractive,"int noninteractive (int,char**)",redis-cli.c,"static int noninteractive(int argc, char **argv) {
    int retval = 0;
    sds *sds_args = getSdsArrayFromArgv(argc, argv, config.quoted_input);

    if (!sds_args) {
        printf(""Invalid quoted string\n"");
        return 1;
    }

    if (config.stdin_lastarg) {
        sds_args = sds_realloc(sds_args, (argc + 1) * sizeof(sds));
        sds_args[argc] = readArgFromStdin();
        argc++;
    } else if (config.stdin_tag_arg) {
        int i = 0, tag_match = 0;

        for (; i < argc; i++) {
            if (strcmp(config.stdin_tag_name, sds_args[i]) != 0) continue;

            tag_match = 1;
            sdsfree(sds_args[i]);
            sds_args[i] = readArgFromStdin();
            break;
        }

        if (!tag_match) {
            sdsfreesplitres(sds_args, argc);
            fprintf(stderr, ""Using -X option but stdin tag not match.\n"");
            return 1;
        }
    }

    retval = issueCommand(argc, sds_args);
    sdsfreesplitres(sds_args, argc);
    while (config...",3460.0,3502.0,1.0,1.0,43.0,17,11,24,8,0,13,5,6,5,7,,0,11,4,2,2,int
3977,289613,evalMode,1,evalMode,"int evalMode (int,char**)",redis-cli.c,"static int evalMode(int argc, char **argv) {
    sds script = NULL;
    FILE *fp;
    char buf[1024];
    size_t nread;
    char **argv2;
    int j, got_comma, keys;
    int retval = REDIS_OK;

    while(1) {
        if (config.eval_ldb) {
            printf(
            ""Lua debugging session started, please use:\n""
            ""quit    -- End the session.\n""
            ""restart -- Restart the script in debug mode again.\n""
            ""help    -- Show Lua script debugging commands.\n\n""
            );
        }

        sdsfree(script);
        script = sdsempty();
        got_comma = 0;
        keys = 0;

        /* Load the script from the file, as an sds string. */
        fp = fopen(config.eval,""r"");
        if (!fp) {
            fprintf(stderr,
                ""Can't open file '%s': %s\n"", config.eval, strerror(errno));
            exit(1);
        }
        while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
            script = sdscatlen(script,buf,nread);
        }
     ...",3508.0,3589.0,1.0,27.0,82.0,56,14,64,20,0,24,14,26,6,10,,0,22,4,2,2,int
3978,289956,clusterManagerNodeByName,1,clusterManagerNodeByName,clusterManagerNode* clusterManagerNodeByName (char*),redis-cli.c,"static clusterManagerNode *clusterManagerNodeByName(const char *name) {
    if (cluster_manager.nodes == NULL) return NULL;
    clusterManagerNode *found = NULL;
    sds lcname = sdsempty();
    lcname = sdscpy(lcname, name);
    sdstolower(lcname);
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->name && !sdscmp(n->name, lcname)) {
            found = n;
            break;
        }
    }
    sdsfree(lcname);
    return found;
}",4097.0,4115.0,1.0,1.0,19.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,clusterManagerNode
3979,290047,clusterManagerLog,1,clusterManagerLog,"void clusterManagerLog (int,char*...)",redis-cli.c,"static void clusterManagerLog(int level, const char* fmt, ...) {
    int use_colors =
        (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COLOR);
    if (use_colors) {
        printf(""\033["");
        switch (level) {
        case CLUSTER_MANAGER_LOG_LVL_INFO: printf(LOG_COLOR_BOLD); break;
        case CLUSTER_MANAGER_LOG_LVL_WARN: printf(LOG_COLOR_YELLOW); break;
        case CLUSTER_MANAGER_LOG_LVL_ERR: printf(LOG_COLOR_RED); break;
        case CLUSTER_MANAGER_LOG_LVL_SUCCESS: printf(LOG_COLOR_GREEN); break;
        default: printf(LOG_COLOR_RESET); break;
        }
    }
    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    va_end(ap);
    if (use_colors) printf(""\033["" LOG_COLOR_RESET);
}",6742.0,6760.0,1.0,48.0,19.0,0,0,0,0,31,0,1,1,0,0,,0,0,4,2,2,void
3980,290443,validateClusterManagerCommand,1,validateClusterManagerCommand,clusterManagerCommandProc validateClusterManagerCommand (void),redis-cli.c,"static clusterManagerCommandProc *validateClusterManagerCommand(void) {
    int i, commands_count = sizeof(clusterManagerCommands) /
                            sizeof(clusterManagerCommandDef);
    clusterManagerCommandProc *proc = NULL;
    char *cmdname = config.cluster_manager_command.name;
    int argc = config.cluster_manager_command.argc;
    for (i = 0; i < commands_count; i++) {
        clusterManagerCommandDef cmddef = clusterManagerCommands[i];
        if (!strcmp(cmddef.name, cmdname)) {
            if ((cmddef.arity > 0 && argc != cmddef.arity) ||
                (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
                fprintf(stderr, ""[ERR] Wrong number of arguments for ""
                                ""specified --cluster sub command\n"");
                return NULL;
            }
            proc = cmddef.proc;
        }
    }
    if (!proc) fprintf(stderr, ""Unknown --cluster subcommand\n"");
    return proc;
}",3813.0,3833.0,1.0,1.0,21.0,33,13,30,11,0,12,5,8,5,0,,0,12,2,1,1,clusterManagerCommandProc
3981,290549,parseClusterNodeAddress,1,parseClusterNodeAddress,"int parseClusterNodeAddress (char*,char**,int*,int*)",redis-cli.c,"static int parseClusterNodeAddress(char *addr, char **ip_ptr, int *port_ptr,
                                   int *bus_port_ptr)
{
    /* ip:port[@bus_port] */
    char *c = strrchr(addr, '@');
    if (c != NULL) {
        *c = '\0';
        if (bus_port_ptr != NULL)
            *bus_port_ptr = atoi(c + 1);
    }
    c = strrchr(addr, ':');
    if (c != NULL) {
        *c = '\0';
        *ip_ptr = addr;
        *port_ptr = atoi(++c);
    } else return 0;
    return 1;
}",3835.0,3852.0,1.0,1.0,18.0,17,5,18,6,1,0,4,5,0,0,,0,0,8,4,4,int
3982,290614,getClusterHostFromCmdArgs,1,getClusterHostFromCmdArgs,"int getClusterHostFromCmdArgs (int,char**,char**,int*)",redis-cli.c,"static int getClusterHostFromCmdArgs(int argc, char **argv,
                                     char **ip_ptr, int *port_ptr) {
    int port = 0;
    char *ip = NULL;
    if (argc == 1) {
        char *addr = argv[0];
        if (!parseClusterNodeAddress(addr, &ip, &port, NULL)) return 0;
    } else {
        ip = argv[0];
        port = atoi(argv[1]);
    }
    if (!ip || !port) return 0;
    else {
        *ip_ptr = ip;
        *port_ptr = port;
    }
    return 1;
}",3860.0,3877.0,1.0,1.0,18.0,11,6,12,6,0,1,4,5,1,1,,0,1,8,4,4,int
3983,290687,freeClusterManagerNodeFlags,1,freeClusterManagerNodeFlags,void freeClusterManagerNodeFlags (list*),redis-cli.c,"static void freeClusterManagerNodeFlags(list *flags) {
    listIter li;
    listNode *ln;
    listRewind(flags, &li);
    while ((ln = listNext(&li)) != NULL) {
        sds flag = ln->value;
        sdsfree(flag);
    }
    listRelease(flags);
}",3879.0,3888.0,1.0,1.0,10.0,6,4,9,5,1,5,2,2,1,4,,0,2,2,1,1,void
3984,290717,freeClusterManagerNode,1,freeClusterManagerNode,void freeClusterManagerNode (clusterManagerNode*),redis-cli.c,"static void freeClusterManagerNode(clusterManagerNode *node) {
    if (node->context != NULL) redisFree(node->context);
    if (node->friends != NULL) {
        listIter li;
        listNode *ln;
        listRewind(node->friends,&li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerNode *fn = ln->value;
            freeClusterManagerNode(fn);
        }
        listRelease(node->friends);
        node->friends = NULL;
    }
    if (node->name != NULL) sdsfree(node->name);
    if (node->replicate != NULL) sdsfree(node->replicate);
    if ((node->flags & CLUSTER_MANAGER_FLAG_FRIEND) && node->ip)
        sdsfree(node->ip);
    int i;
    if (node->migrating != NULL) {
        for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
        zfree(node->migrating);
    }
    if (node->importing != NULL) {
        for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
        zfree(node->importing);
    }
    if (node->flags_str !=...",3890.0,3921.0,1.0,23.0,32.0,44,8,43,6,1,33,12,15,12,10,,0,24,2,1,1,void
3985,290892,freeClusterManager,1,freeClusterManager,void freeClusterManager (void),redis-cli.c,"static void freeClusterManager(void) {
    listIter li;
    listNode *ln;
    if (cluster_manager.nodes != NULL) {
        listRewind(cluster_manager.nodes,&li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerNode *n = ln->value;
            freeClusterManagerNode(n);
        }
        listRelease(cluster_manager.nodes);
        cluster_manager.nodes = NULL;
    }
    if (cluster_manager.errors != NULL) {
        listRewind(cluster_manager.errors,&li);
        while ((ln = listNext(&li)) != NULL) {
            sds err = ln->value;
            sdsfree(err);
        }
        listRelease(cluster_manager.errors);
        cluster_manager.errors = NULL;
    }
    if (clusterManagerUncoveredSlots != NULL)
        dictRelease(clusterManagerUncoveredSlots);
}",3923.0,3946.0,1.0,1.0,24.0,25,5,29,7,1,29,6,8,7,9,,0,22,2,1,1,void
3986,291109,clusterManagerGetNodeRDBFilename,1,clusterManagerGetNodeRDBFilename,sds clusterManagerGetNodeRDBFilename (clusterManagerNode*),redis-cli.c,"static sds clusterManagerGetNodeRDBFilename(clusterManagerNode *node) {
    assert(config.cluster_manager_command.backup_dir);
    sds filename = sdsnew(config.cluster_manager_command.backup_dir);
    if (filename[sdslen(filename) - 1] != '/')
        filename = sdscat(filename, ""/"");
    filename = sdscatprintf(filename, ""redis-node-%s-%d-%s.rdb"", node->ip,
                            node->port, node->name);
    return filename;
}",3976.0,3984.0,1.0,1.0,9.0,13,6,13,3,0,11,2,2,1,4,,0,11,2,1,1,sds
3987,291160,clusterManagerCheckRedisReply,1,clusterManagerCheckRedisReply,"int clusterManagerCheckRedisReply (clusterManagerNode*,redisReply*,char**)",redis-cli.c,"static int clusterManagerCheckRedisReply(clusterManagerNode *n,
                                         redisReply *r, char **err)
{
    int is_err = 0;
    if (!r || (is_err = (r->type == REDIS_REPLY_ERROR))) {
        if (is_err) {
            if (err != NULL) {
                *err = zmalloc((r->len + 1) * sizeof(char));
                redis_strlcpy(*err, r->str,(r->len + 1));
            } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r->str);
        }
        return 0;
    }
    return 1;
}",3990.0,4004.0,1.0,19.0,15.0,17,10,14,6,15,2,4,7,0,2,,0,1,6,3,3,int
3988,291238,clusterManagerStartTransaction,1,clusterManagerStartTransaction,int clusterManagerStartTransaction (clusterManagerNode*),redis-cli.c,"static int clusterManagerStartTransaction(clusterManagerNode *node) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""MULTI"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4007.0,4012.0,1.0,24.0,6.0,3,2,10,4,1,2,2,2,0,1,,0,2,2,1,1,int
3989,291269,clusterManagerExecTransaction,1,clusterManagerExecTransaction,"int clusterManagerExecTransaction (clusterManagerNode*,clusterManagerOnReplyError)",redis-cli.c,"static int clusterManagerExecTransaction(clusterManagerNode *node,
                                         clusterManagerOnReplyError onerror)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""EXEC"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (success) {
        if (reply->type != REDIS_REPLY_ARRAY) {
            success = 0;
            goto cleanup;
        }
        size_t i;
        for (i = 0; i < reply->elements; i++) {
            redisReply *r = reply->element[i];
            char *err = NULL;
            success = clusterManagerCheckRedisReply(node, r, &err);
            if (!success && onerror) success = onerror(r, node, i);
            if (err) {
                if (!success)
                    CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
                zfree(err);
            }
            if (!success) break;
        }
    }
cleanup:
    if (reply) freeReplyObject(reply);
    return success;
}",4015.0,4042.0,1.0,24.0,28.0,22,8,41,9,1,7,11,20,0,4,,0,5,4,2,2,int
3990,291389,clusterManagerNodeConnect,1,clusterManagerNodeConnect,int clusterManagerNodeConnect (clusterManagerNode*),redis-cli.c,"static int clusterManagerNodeConnect(clusterManagerNode *node) {
    if (node->context) redisFree(node->context);
    node->context = redisConnect(node->ip, node->port);
    if (!node->context->err && config.tls) {
        const char *err = NULL;
        if (cliSecureConnection(node->context, config.sslconfig, &err) == REDIS_ERR && err) {
            fprintf(stderr,""TLS Error: %s\n"", err);
            redisFree(node->context);
            node->context = NULL;
            return 0;
        }
    }
    if (node->context->err) {
        fprintf(stderr,""Could not connect to Redis at "");
        fprintf(stderr,""%s:%d: %s\n"", node->ip, node->port,
                node->context->errstr);
        redisFree(node->context);
        node->context = NULL;
        return 0;
    }
    /* Set aggressive KEEP_ALIVE socket option in the Redis context socket
     * in order to prevent timeouts caused by the execution of long
     * commands. At the same time this improves the detection of real
     ...",4044.0,4081.0,1.0,43.0,38.0,43,8,44,8,0,30,9,13,13,3,,0,29,2,1,1,int
3991,291575,clusterManagerRemoveNodeFromList,1,clusterManagerRemoveNodeFromList,"void clusterManagerRemoveNodeFromList (list*,clusterManagerNode*)",redis-cli.c,"static void clusterManagerRemoveNodeFromList(list *nodelist,
                                             clusterManagerNode *node) {
    listIter li;
    listNode *ln;
    listRewind(nodelist, &li);
    while ((ln = listNext(&li)) != NULL) {
        if (node == ln->value) {
            listDelNode(nodelist, ln);
            break;
        }
    }
}",4083.0,4094.0,1.0,1.0,12.0,6,5,9,5,4,4,4,4,2,3,,0,2,4,2,2,void
3992,291773,clusterManagerGetNodeRedisInfo,1,clusterManagerGetNodeRedisInfo,"redisReply clusterManagerGetNodeRedisInfo (clusterManagerNode*,char**)",redis-cli.c,"static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
                                                  char **err)
{
    redisReply *info = CLUSTER_MANAGER_COMMAND(node, ""INFO"");
    if (err != NULL) *err = NULL;
    if (info == NULL) return NULL;
    if (info->type == REDIS_REPLY_ERROR) {
        if (err != NULL) {
            *err = zmalloc((info->len + 1) * sizeof(char));
            redis_strlcpy(*err, info->str,(info->len + 1));
        }
        freeReplyObject(info);
        return  NULL;
    }
    return info;
}",4149.0,4164.0,1.0,23.0,16.0,19,8,23,6,0,3,5,6,0,2,,0,2,4,2,2,redisReply
3993,292561,clusterManagerNodeFlagString,1,clusterManagerNodeFlagString,sds clusterManagerNodeFlagString (clusterManagerNode*),redis-cli.c,"static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
    sds flags = sdsempty();
    if (!node->flags_str) return flags;
    int empty = 1;
    listIter li;
    listNode *ln;
    listRewind(node->flags_str, &li);
    while ((ln = listNext(&li)) != NULL) {
        sds flag = ln->value;
        if (strcmp(flag, ""myself"") == 0) continue;
        if (!empty) flags = sdscat(flags, "","");
        flags = sdscatfmt(flags, ""%S"", flag);
        empty = 0;
    }
    return flags;
}",4377.0,4392.0,1.0,1.0,16.0,16,6,20,7,1,8,6,7,2,5,,0,7,2,1,1,sds
3994,292633,clusterManagerNodeSlotsString,1,clusterManagerNodeSlotsString,sds clusterManagerNodeSlotsString (clusterManagerNode*),redis-cli.c,"static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
    sds slots = sdsempty();
    int first_range_idx = -1, last_slot_idx = -1, i;
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        int has_slot = node->slots[i];
        if (has_slot) {
            if (first_range_idx == -1) {
                if (sdslen(slots)) slots = sdscat(slots, "","");
                first_range_idx = i;
                slots = sdscatfmt(slots, ""[%u"", i);
            }
            last_slot_idx = i;
        } else {
            if (last_slot_idx >= 0) {
                if (first_range_idx == last_slot_idx)
                    slots = sdscat(slots, ""]"");
                else slots = sdscatfmt(slots, ""-%u]"", last_slot_idx);
            }
            last_slot_idx = -1;
            first_range_idx = -1;
        }
    }
    if (last_slot_idx >= 0) {
        if (first_range_idx == last_slot_idx) slots = sdscat(slots, ""]"");
        else slots = sdscatfmt(slots, ""-%u]"", last_slot_idx);
    }
 ...",4395.0,4422.0,1.0,20.0,28.0,19,7,26,6,2,6,7,14,1,5,,0,6,2,1,1,sds
3995,292762,clusterManagerNodeGetJSON,1,clusterManagerNodeGetJSON,"sds clusterManagerNodeGetJSON (clusterManagerNode*,long unsigned)",redis-cli.c,"static sds clusterManagerNodeGetJSON(clusterManagerNode *node,
                                     unsigned long error_count)
{
    sds json = sdsempty();
    sds replicate = sdsempty();
    if (node->replicate)
        replicate = sdscatprintf(replicate, ""\""%s\"""", node->replicate);
    else
        replicate = sdscat(replicate, ""null"");
    sds slots = clusterManagerNodeSlotsString(node);
    sds flags = clusterManagerNodeFlagString(node);
    char *p = slots;
    while ((p = strchr(p, '-')) != NULL)
        *(p++) = ',';
    json = sdscatprintf(json,
        ""  {\n""
        ""    \""name\"": \""%s\"",\n""
        ""    \""host\"": \""%s\"",\n""
        ""    \""port\"": %d,\n""
        ""    \""replicate\"": %s,\n""
        ""    \""slots\"": [%s],\n""
        ""    \""slots_count\"": %d,\n""
        ""    \""flags\"": \""%s\"",\n""
        ""    \""current_epoch\"": %llu"",
        node->name,
        node->ip,
        node->port,
        replicate,
        slots,
        node->slots_count,
        flags,
        (u...",4424.0,4496.0,1.0,1.0,73.0,64,9,89,14,0,42,14,28,11,25,,0,37,4,2,2,sds
3996,293046,clusterManagerKeyHashSlot,1,clusterManagerKeyHashSlot,"unsigned int clusterManagerKeyHashSlot (char*,int)",redis-cli.c,"static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */

    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    /* No '{' ? Hash the whole key. This is the base case. */
    if (s == keylen) return crc16(key,keylen) & 0x3FFF;

    /* '{' found? Check if we have the corresponding '}'. */
    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    /* No '}' or nothing between {} ? Hash the whole key. */
    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;

    /* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */
    return crc16(key+s+1,e-s-1) & 0x3FFF;
}",4509.0,4528.0,1.0,1.0,20.0,17,7,21,4,0,3,5,5,0,3,,0,0,4,2,2,unsigned int
3997,293587,clusterManagerAddSlots,1,clusterManagerAddSlots,"int clusterManagerAddSlots (clusterManagerNode*,char**)",redis-cli.c,"static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
{
    redisReply *reply = NULL;
    void *_reply = NULL;
    int success = 1;
    /* First two args are used for the command itself. */
    int argc = node->slots_count + 2;
    sds *argv = zmalloc(argc * sizeof(*argv));
    size_t *argvlen = zmalloc(argc * sizeof(*argvlen));
    argv[0] = ""CLUSTER"";
    argv[1] = ""ADDSLOTS"";
    argvlen[0] = 7;
    argvlen[1] = 8;
    *err = NULL;
    int i, argv_idx = 2;
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        if (argv_idx >= argc) break;
        if (node->slots[i]) {
            argv[argv_idx] = sdsfromlonglong((long long) i);
            argvlen[argv_idx] = sdslen(argv[argv_idx]);
            argv_idx++;
        }
    }
    if (argv_idx == 2) {
        success = 0;
        goto cleanup;
    }
    redisAppendCommandArgv(node->context,argc,(const char**)argv,argvlen);
    if (redisGetReply(node->context, &_reply) != REDIS_OK) {
        success = 0;
        got...",4624.0,4666.0,1.0,20.0,43.0,52,14,61,12,0,11,12,12,2,7,,0,9,4,2,2,int
3998,293780,clusterManagerGetSlotOwner,1,clusterManagerGetSlotOwner,"clusterManagerNode clusterManagerGetSlotOwner (clusterManagerNode*,int,char**)",redis-cli.c,"static clusterManagerNode *clusterManagerGetSlotOwner(clusterManagerNode *n,
                                                      int slot, char **err)
{
    assert(slot >= 0 && slot < CLUSTER_MANAGER_SLOTS);
    clusterManagerNode *owner = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(n, ""CLUSTER SLOTS"");
    if (clusterManagerCheckRedisReply(n, reply, err)) {
        assert(reply->type == REDIS_REPLY_ARRAY);
        size_t i;
        for (i = 0; i < reply->elements; i++) {
            redisReply *r = reply->element[i];
            assert(r->type == REDIS_REPLY_ARRAY && r->elements >= 3);
            int from, to;
            from = r->element[0]->integer;
            to = r->element[1]->integer;
            if (slot < from || slot > to) continue;
            redisReply *nr =  r->element[2];
            assert(nr->type == REDIS_REPLY_ARRAY && nr->elements >= 2);
            char *name = NULL;
            if (nr->elements >= 3)
                name =  nr->element[2]->str;
 ...",4672.0,4715.0,1.0,31.0,44.0,47,10,47,13,2,3,10,17,1,2,,0,3,6,3,3,clusterManagerNode
3999,294018,clusterManagerSetSlot,1,clusterManagerSetSlot,"int clusterManagerSetSlot (clusterManagerNode*,clusterManagerNode*,int,char*,char**)",redis-cli.c,"static int clusterManagerSetSlot(clusterManagerNode *node1,
                                 clusterManagerNode *node2,
                                 int slot, const char *status, char **err) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, ""CLUSTER ""
                                                ""SETSLOT %d %s %s"",
                                                slot, status,
                                                (char *) node2->name);
    if (err != NULL) *err = NULL;
    if (!reply) {
        if (err) *err = zstrdup(""CLUSTER SETSLOT failed to run"");
        return 0;
    }
    int success = 1;
    if (reply->type == REDIS_REPLY_ERROR) {
        success = 0;
        if (err != NULL) {
            *err = zmalloc((reply->len + 1) * sizeof(char));
            redis_strlcpy(*err, reply->str,(reply->len + 1));
        } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply->str);
        goto cleanup;
    }
cleanup:
    freeReplyObject(reply);
    return success;
}",4718.0,4742.0,1.0,24.0,25.0,25,10,27,10,11,5,7,8,0,3,,0,4,10,5,5,int
4000,294136,clusterManagerClearSlotStatus,1,clusterManagerClearSlotStatus,"int clusterManagerClearSlotStatus (clusterManagerNode*,int)",redis-cli.c,"static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER SETSLOT %d %s"", slot, ""STABLE"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4744.0,4750.0,1.0,24.0,7.0,3,2,11,5,3,2,2,2,0,1,,0,2,4,2,2,int
4001,294169,clusterManagerDelSlot,1,clusterManagerDelSlot,"int clusterManagerDelSlot (clusterManagerNode*,int,int)",redis-cli.c,"static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
                                 int ignore_unassigned_err)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER DELSLOTS %d"", slot);
    char *err = NULL;
    int success = clusterManagerCheckRedisReply(node, reply, &err);
    if (!success && reply && reply->type == REDIS_REPLY_ERROR &&
        ignore_unassigned_err)
    {
        char *get_owner_err = NULL;
        clusterManagerNode *assigned_to =
            clusterManagerGetSlotOwner(node, slot, &get_owner_err);
        if (!assigned_to) {
            if (get_owner_err == NULL) success = 1;
            else {
                CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, get_owner_err);
                zfree(get_owner_err);
            }
        }
    }
    if (!success && err != NULL) {
        CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
        zfree(err);
    }
    if (reply) freeReplyObject(reply);
    return success;
}",4752.0,4779.0,1.0,24.0,28.0,22,7,37,10,3,7,6,9,0,4,,0,5,6,3,3,int
4002,294287,clusterManagerAddSlot,1,clusterManagerAddSlot,"int clusterManagerAddSlot (clusterManagerNode*,int)",redis-cli.c,"static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER ADDSLOTS %d"", slot);
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4781.0,4787.0,1.0,24.0,7.0,3,2,11,5,1,2,2,2,0,1,,0,2,4,2,2,int
4003,294319,clusterManagerCountKeysInSlot,1,clusterManagerCountKeysInSlot,"signed int clusterManagerCountKeysInSlot (clusterManagerNode*,int)",redis-cli.c,"static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
                                                int slot)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER COUNTKEYSINSLOT %d"", slot);
    int count = -1;
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (success && reply->type == REDIS_REPLY_INTEGER) count = reply->integer;
    if (reply) freeReplyObject(reply);
    return count;
}",4789.0,4799.0,1.0,24.0,11.0,10,5,17,7,1,2,3,3,0,1,,0,2,4,2,2,signed int
4004,294370,clusterManagerBumpEpoch,1,clusterManagerBumpEpoch,int clusterManagerBumpEpoch (clusterManagerNode*),redis-cli.c,"static int clusterManagerBumpEpoch(clusterManagerNode *node) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER BUMPEPOCH"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4801.0,4806.0,1.0,24.0,6.0,3,2,10,4,1,2,2,2,0,1,,0,2,2,1,1,int
4005,294423,clusterManagerSetSlotOwner,1,clusterManagerSetSlotOwner,"int clusterManagerSetSlotOwner (clusterManagerNode*,int,int)",redis-cli.c,"static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
                                      int slot,
                                      int do_clear)
{
    int success = clusterManagerStartTransaction(owner);
    if (!success) return 0;
    /* Ensure the slot is not already assigned. */
    clusterManagerDelSlot(owner, slot, 1);
    /* Add the slot and bump epoch. */
    clusterManagerAddSlot(owner, slot);
    if (do_clear) clusterManagerClearSlotStatus(owner, slot);
    clusterManagerBumpEpoch(owner);
    success = clusterManagerExecTransaction(owner, clusterManagerOnSetOwnerErr);
    return success;
}",4820.0,4834.0,1.0,1.0,15.0,3,2,14,4,5,6,3,3,0,6,,0,2,6,3,3,int
4006,294463,clusterManagerCompareKeysValues,1,clusterManagerCompareKeysValues,"int clusterManagerCompareKeysValues (clusterManagerNode*,clusterManagerNode*,redisReply*,list*)",redis-cli.c,"static int clusterManagerCompareKeysValues(clusterManagerNode *n1,
                                          clusterManagerNode *n2,
                                          redisReply *keys_reply,
                                          list *diffs)
{
    size_t i, argc = keys_reply->elements + 2;
    static const char *hash_zero = ""0000000000000000000000000000000000000000"";
    char **argv = zcalloc(argc * sizeof(char *));
    size_t  *argv_len = zcalloc(argc * sizeof(size_t));
    argv[0] = ""DEBUG"";
    argv_len[0] = 5;
    argv[1] = ""DIGEST-VALUE"";
    argv_len[1] = 12;
    for (i = 0; i < keys_reply->elements; i++) {
        redisReply *entry = keys_reply->element[i];
        int idx = i + 2;
        argv[idx] = entry->str;
        argv_len[idx] = entry->len;
    }
    int success = 0;
    void *_reply1 = NULL, *_reply2 = NULL;
    redisReply *r1 = NULL, *r2 = NULL;
    redisAppendCommandArgv(n1->context,argc, (const char**)argv,argv_len);
    success = (redisGetReply(n1->co...",4841.0,4898.0,1.0,8.0,58.0,102,14,111,24,1,15,16,14,0,7,,0,10,8,4,4,int
4007,294813,clusterManagerMigrateKeysInReply,1,clusterManagerMigrateKeysInReply,"redisReply clusterManagerMigrateKeysInReply (clusterManagerNode*,clusterManagerNode*,redisReply*,int,int,char*)",redis-cli.c,"static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
                                                    clusterManagerNode *target,
                                                    redisReply *reply,
                                                    int replace, int timeout,
                                                    char *dots)
{
    redisReply *migrate_reply = NULL;
    char **argv = NULL;
    size_t *argv_len = NULL;
    int c = (replace ? 8 : 7);
    if (config.conn_info.auth) c += 2;
    if (config.conn_info.user) c += 1;
    size_t argc = c + reply->elements;
    size_t i, offset = 6; // Keys Offset
    argv = zcalloc(argc * sizeof(char *));
    argv_len = zcalloc(argc * sizeof(size_t));
    char portstr[255];
    char timeoutstr[255];
    snprintf(portstr, 10, ""%d"", target->port);
    snprintf(timeoutstr, 10, ""%d"", timeout);
    argv[0] = ""MIGRATE"";
    argv_len[0] = 7;
    argv[1] = target->ip;
    argv_len[1] = strlen(target->ip);
 ...",4903.0,4983.0,1.0,1.0,81.0,121,15,119,25,2,26,12,13,8,5,,0,24,12,6,6,redisReply
4008,295230,clusterManagerMigrateKeysInSlot,1,clusterManagerMigrateKeysInSlot,"int clusterManagerMigrateKeysInSlot (clusterManagerNode*,clusterManagerNode*,int,int,int,int,char**)",redis-cli.c,"static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
                                           clusterManagerNode *target,
                                           int slot, int timeout,
                                           int pipeline, int verbose,
                                           char **err)
{
    int success = 1;
    int do_fix = config.cluster_manager_command.flags &
                 CLUSTER_MANAGER_CMD_FLAG_FIX;
    int do_replace = config.cluster_manager_command.flags &
                     CLUSTER_MANAGER_CMD_FLAG_REPLACE;
    while (1) {
        char *dots = NULL;
        redisReply *reply = NULL, *migrate_reply = NULL;
        reply = CLUSTER_MANAGER_COMMAND(source, ""CLUSTER ""
                                        ""GETKEYSINSLOT %d %d"", slot,
                                        pipeline);
        success = (reply != NULL);
        if (!success) return 0;
        if (reply->type == REDIS_REPLY_ERROR) {
            success = 0;
    ...",4986.0,5141.0,1.0,17.0,156.0,108,16,150,28,1,45,34,86,2,27,,0,27,14,7,7,int
4009,295740,clusterManagerMoveSlot,1,clusterManagerMoveSlot,"int clusterManagerMoveSlot (clusterManagerNode*,clusterManagerNode*,int,int,char**)",redis-cli.c,"static int clusterManagerMoveSlot(clusterManagerNode *source,
                                  clusterManagerNode *target,
                                  int slot, int opts,  char**err)
{
    if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) {
        printf(""Moving slot %d from %s:%d to %s:%d: "", slot, source->ip,
               source->port, target->ip, target->port);
        fflush(stdout);
    }
    if (err != NULL) *err = NULL;
    int pipeline = config.cluster_manager_command.pipeline,
        timeout = config.cluster_manager_command.timeout,
        print_dots = (opts & CLUSTER_MANAGER_OPT_VERBOSE),
        option_cold = (opts & CLUSTER_MANAGER_OPT_COLD),
        success = 1;
    if (!option_cold) {
        success = clusterManagerSetSlot(target, source, slot,
                                        ""importing"", err);
        if (!success) return 0;
        success = clusterManagerSetSlot(source, target, slot,
                                        ""migrating"", err);
        if (...",5152.0,5223.0,1.0,17.0,72.0,69,13,87,18,3,23,18,27,2,9,,0,21,10,5,5,int
4010,297585,clusterManagerSlotCountCompareDesc,1,clusterManagerSlotCountCompareDesc,"int clusterManagerSlotCountCompareDesc (void*,void*)",redis-cli.c,"int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
    clusterManagerNode *node2 = *((clusterManagerNode **) n2);
    return node2->slots_count - node1->slots_count;
}",5579.0,5583.0,1.0,1.0,5.0,9,5,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
4011,297613,clusterManagerCompareNodeBalance,1,clusterManagerCompareNodeBalance,"int clusterManagerCompareNodeBalance (void*,void*)",redis-cli.c,"int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
    clusterManagerNode *node2 = *((clusterManagerNode **) n2);
    return node1->balance - node2->balance;
}",5585.0,5589.0,1.0,1.0,5.0,9,5,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
4012,297641,clusterManagerGetConfigSignature,1,clusterManagerGetConfigSignature,sds clusterManagerGetConfigSignature (clusterManagerNode*),redis-cli.c,"static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
    sds signature = NULL;
    int node_count = 0, i = 0, name_len = 0;
    char **node_configs = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    if (reply == NULL || reply->type == REDIS_REPLY_ERROR)
        goto cleanup;
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        i = 0;
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *nodename = NULL;
        int tot_size = 0;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            if (i == 0) {
                nodename = token;
                tot_size = (p - token);
                name_len = tot_size++; // Make room for ':' in tot_size
            }
            if (++i == 8) break;
        }
        if (i != 8) continue;
        if (nodename == NULL) continue;
        int re...",5591.0,5682.0,1.0,24.0,92.0,118,18,153,24,0,9,29,52,0,8,,0,7,2,1,1,sds
4013,298182,clusterManagerGetDisconnectedLinks,1,clusterManagerGetDisconnectedLinks,list clusterManagerGetDisconnectedLinks (clusterManagerNode*),redis-cli.c,"static list *clusterManagerGetDisconnectedLinks(clusterManagerNode *node) {
    list *links = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    if (!clusterManagerCheckRedisReply(node, reply, NULL)) goto cleanup;
    links = listCreate();
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        int i = 0;
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *nodename = NULL, *addr = NULL, *flags = NULL, *link_status = NULL;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            if (i == 0) nodename = token;
            else if (i == 1) addr = token;
            else if (i == 2) flags = token;
            else if (i == 7) link_status = token;
            else if (i == 8) break;
            i++;
        }
        if (i == 7) link_status = line;
        if (nodename == NULL || addr == NULL || flags == NUL...",5711.0,5753.0,1.0,24.0,43.0,57,10,77,16,0,11,13,17,1,6,,0,10,2,1,1,list
4014,298598,clusterManagerGetCoveredSlots,1,clusterManagerGetCoveredSlots,int clusterManagerGetCoveredSlots (char*),redis-cli.c,"static int clusterManagerGetCoveredSlots(char *all_slots) {
    if (cluster_manager.nodes == NULL) return 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    int totslots = 0, i;
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
            if (node->slots[i] && !all_slots[i]) {
                all_slots[i] = 1;
                totslots++;
            }
        }
    }
    return totslots;
}",5804.0,5820.0,1.0,24.0,17.0,20,11,20,8,0,8,5,8,4,2,,0,7,2,1,1,int
4015,298674,clusterManagerPrintSlotsList,1,clusterManagerPrintSlotsList,void clusterManagerPrintSlotsList (list*),redis-cli.c,"static void clusterManagerPrintSlotsList(list *slots) {
    clusterManagerNode n = {0};
    listIter li;
    listNode *ln;
    listRewind(slots, &li);
    while ((ln = listNext(&li)) != NULL) {
        int slot = atoi(ln->value);
        if (slot >= 0 && slot < CLUSTER_MANAGER_SLOTS)
            n.slots[slot] = 1;
    }
    sds nodeslist = clusterManagerNodeSlotsString(&n);
    printf(""%s\n"", nodeslist);
    sdsfree(nodeslist);
}",5822.0,5835.0,1.0,32.0,14.0,16,10,16,7,3,6,3,4,1,4,,0,4,2,1,1,void
4016,298735,clusterManagerGetNodeWithMostKeysInSlot,1,clusterManagerGetNodeWithMostKeysInSlot,"clusterManagerNode clusterManagerGetNodeWithMostKeysInSlot (list*,int,char**)",redis-cli.c,"static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
                                                                    int slot,
                                                                    char **err)
{
    clusterManagerNode *node = NULL;
    int numkeys = 0;
    listIter li;
    listNode *ln;
    listRewind(nodes, &li);
    if (err) *err = NULL;
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
            continue;
        redisReply *r =
            CLUSTER_MANAGER_COMMAND(n, ""CLUSTER COUNTKEYSINSLOT %d"", slot);
        int success = clusterManagerCheckRedisReply(n, r, err);
        if (success) {
            if (r->integer > numkeys || node == NULL) {
                numkeys = r->integer;
                node = n;
            }
        }
        if (r != NULL) freeReplyObject(r);
        /* If the reply contains errors */
        if (!succ...",5839.0,5872.0,1.0,23.0,34.0,34,12,48,11,3,10,11,17,3,4,,0,8,6,3,3,clusterManagerNode
4017,298876,clusterManagerNodeWithLeastReplicas,1,clusterManagerNodeWithLeastReplicas,clusterManagerNode clusterManagerNodeWithLeastReplicas (void),redis-cli.c,"static clusterManagerNode *clusterManagerNodeWithLeastReplicas(void) {
    clusterManagerNode *node = NULL;
    int lowest_count = 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        if (node == NULL || n->replicas_count < lowest_count) {
            node = n;
            lowest_count = n->replicas_count;
        }
    }
    return node;
}",5878.0,5893.0,1.0,23.0,16.0,19,10,20,7,0,8,5,6,3,2,,0,7,2,1,1,clusterManagerNode
4018,298945,clusterManagerNodeMasterRandom,1,clusterManagerNodeMasterRandom,clusterManagerNode clusterManagerNodeMasterRandom (void),redis-cli.c,"static clusterManagerNode *clusterManagerNodeMasterRandom(void) {
    int master_count = 0;
    int idx;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        master_count++;
    }

    assert(master_count > 0);
    srand(time(NULL));
    idx = rand() % master_count;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        if (!idx--) {
            return n;
        }
    }
    /* Can not be reached */
    assert(0);
}",5897.0,5922.0,1.0,23.0,26.0,27,12,24,7,1,12,8,9,4,4,,0,10,2,1,1,clusterManagerNode
4019,299046,clusterManagerFixSlotsCoverage,1,clusterManagerFixSlotsCoverage,int clusterManagerFixSlotsCoverage (char*),redis-cli.c,"static int clusterManagerFixSlotsCoverage(char *all_slots) {
    int force_fix = config.cluster_manager_command.flags &
                    CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS;

    if (cluster_manager.unreachable_masters > 0 && !force_fix) {
        clusterManagerLogWarn(""*** Fixing slots coverage with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\n"", cluster_manager.unreachable_masters);
        exit(1);
    }

    int i, fixed = 0;
    list *none = NULL, *single = NULL, *multi = NULL;
    clusterManagerLogInfo("">>> Fixing slots coverage...\n"");
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        int covered = all_slots[i];
        if (!covered) {
            sds slot = sdsfromlonglong...",5924.0,6121.0,1.0,20.0,198.0,160,18,215,31,0,95,51,114,26,57,,0,72,2,1,1,int
4020,299769,clusterManagerFixOpenSlot,1,clusterManagerFixOpenSlot,int clusterManagerFixOpenSlot (int),redis-cli.c,"static int clusterManagerFixOpenSlot(int slot) {
    int force_fix = config.cluster_manager_command.flags &
                    CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS;

    if (cluster_manager.unreachable_masters > 0 && !force_fix) {
        clusterManagerLogWarn(""*** Fixing open slots with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\n"", cluster_manager.unreachable_masters);
        exit(1);
    }

    clusterManagerLogInfo("">>> Fixing open slot %d\n"", slot);
    /* Try to obtain the current slot owner, according to the current
     * nodes configuration. */
    int success = 1;
    list *owners = listCreate();    /* List of nodes claiming some ownership.
                                       ...",6126.0,6456.0,1.0,20.0,331.0,155,14,207,25,0,96,43,65,18,45,,0,72,2,1,1,int
4021,301077,clusterManagerFixMultipleSlotOwners,1,clusterManagerFixMultipleSlotOwners,"int clusterManagerFixMultipleSlotOwners (int,list*)",redis-cli.c,"static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
    clusterManagerLogInfo("">>> Fixing multiple owners for slot %d...\n"", slot);
    int success = 0;
    assert(listLength(owners) > 1);
    clusterManagerNode *owner = clusterManagerGetNodeWithMostKeysInSlot(owners,
                                                                        slot,
                                                                        NULL);
    if (!owner) owner = listFirst(owners)->value;
    clusterManagerLogInfo("">>> Setting slot %d owner: %s:%d\n"",
                          slot, owner->ip, owner->port);
    /* Set the slot owner. */
    if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    /* Update configuration in all the other master nodes by assigning the slot
     * itself to the new owner, and by eventually migrating keys if the node
     * has keys for the slot. */
    while ((ln = ...",6458.0,6493.0,1.0,4.0,36.0,34,12,49,11,0,18,14,17,4,10,,0,14,4,2,2,int
4022,301931,clusterNodeForResharding,1,clusterNodeForResharding,"clusterManagerNode clusterNodeForResharding (char*,clusterManagerNode*,int*)",redis-cli.c,"static clusterManagerNode *clusterNodeForResharding(char *id,
                                                    clusterManagerNode *target,
                                                    int *raise_err)
{
    clusterManagerNode *node = NULL;
    const char *invalid_node_msg = ""*** The specified node (%s) is not known ""
                                   ""or not a master, please retry.\n"";
    node = clusterManagerNodeByName(id);
    *raise_err = 0;
    if (!node || node->flags & CLUSTER_MANAGER_FLAG_SLAVE) {
        clusterManagerLogErr(invalid_node_msg, id);
        *raise_err = 1;
        return NULL;
    } else if (target != NULL) {
        if (!strcmp(node->name, target->name)) {
            clusterManagerLogErr( ""*** It is not possible to use ""
                                  ""the target node as ""
                                  ""source node.\n"");
            return NULL;
        }
    }
    return node;
}",6659.0,6681.0,1.0,31.0,23.0,12,7,13,5,0,3,2,2,1,2,,0,2,6,3,3,clusterManagerNode
4023,302006,clusterManagerComputeReshardTable,1,clusterManagerComputeReshardTable,"list clusterManagerComputeReshardTable (list*,int)",redis-cli.c,"static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
    list *moved = listCreate();
    int src_count = listLength(sources), i = 0, tot_slots = 0, j;
    clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
    listIter li;
    listNode *ln;
    listRewind(sources, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        tot_slots += node->slots_count;
        sorted[i++] = node;
    }
    qsort(sorted, src_count, sizeof(clusterManagerNode *),
          clusterManagerSlotCountCompareDesc);
    for (i = 0; i < src_count; i++) {
        clusterManagerNode *node = sorted[i];
        float n = ((float) numslots / tot_slots * node->slots_count);
        if (i == 0) n = ceil(n);
        else n = floor(n);
        int max = (int) n, count = 0;
        for (j = 0; j < CLUSTER_MANAGER_SLOTS; j++) {
            int slot = node->slots[j];
            if (!slot) continue;
            if (count >= max || (int)...",6683.0,6716.0,1.0,20.0,34.0,54,17,62,18,0,15,9,13,2,7,,0,12,4,2,2,list
4024,302204,clusterManagerShowReshardTable,1,clusterManagerShowReshardTable,void clusterManagerShowReshardTable (list*),redis-cli.c,"static void clusterManagerShowReshardTable(list *table) {
    listIter li;
    listNode *ln;
    listRewind(table, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerReshardTableItem *item = ln->value;
        clusterManagerNode *n = item->source;
        printf(""    Moving slot %d from %s\n"", item->slot, (char *) n->name);
    }
}",6718.0,6727.0,1.0,1.0,10.0,11,5,11,6,0,6,2,2,1,2,,0,5,2,1,1,void
4025,302246,clusterManagerReleaseReshardTable,1,clusterManagerReleaseReshardTable,void clusterManagerReleaseReshardTable (list*),redis-cli.c,"static void clusterManagerReleaseReshardTable(list *table) {
    if (table != NULL) {
        listIter li;
        listNode *ln;
        listRewind(table, &li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerReshardTableItem *item = ln->value;
            zfree(item);
        }
        listRelease(table);
    }
}",6729.0,6740.0,1.0,1.0,12.0,7,4,11,5,0,5,3,4,1,4,,0,2,2,1,1,void
4026,302534,clusterManagerPrintNotEmptyNodeError,1,clusterManagerPrintNotEmptyNodeError,"void clusterManagerPrintNotEmptyNodeError (clusterManagerNode*,char*)",redis-cli.c,"static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
                                                 char *err)
{
    char *msg;
    if (err) msg = err;
    else {
        msg = ""is not empty. Either the node already knows other ""
              ""nodes (check with CLUSTER NODES) or contains some ""
              ""key in database 0."";
    }
    clusterManagerLogErr(""[ERR] Node %s:%d %s\n"", node->ip, node->port, msg);
}",6808.0,6819.0,1.0,4.0,12.0,3,2,6,3,0,3,2,2,0,1,,0,2,4,2,2,void
4027,302589,clusterManagerMode,1,clusterManagerMode,void clusterManagerMode (clusterManagerCommandProc*),redis-cli.c,"static void clusterManagerMode(clusterManagerCommandProc *proc) {
    int argc = config.cluster_manager_command.argc;
    char **argv = config.cluster_manager_command.argv;
    cluster_manager.nodes = NULL;
    int success = proc(argc, argv);

    /* Initialized in createClusterManagerCommand. */
    if (config.stdin_lastarg) {
        zfree(config.cluster_manager_command.argv);
        sdsfree(config.cluster_manager_command.stdin_arg);
    } else if (config.stdin_tag_arg) {
        sdsfree(config.cluster_manager_command.stdin_arg);
    }
    freeClusterManager();

    exit(success ? 0 : 1);
}",6829.0,6845.0,1.0,1.0,17.0,15,3,13,6,0,15,2,2,2,3,,0,12,2,1,1,void
4028,308177,latencyModePrint,1,latencyModePrint,"void latencyModePrint (long long,long long,double,long long)",redis-cli.c,"static void latencyModePrint(long long min, long long max, double avg, long long count) {
    if (config.output == OUTPUT_STANDARD) {
        printf(""min: %lld, max: %lld, avg: %.2f (%lld samples)"",
                min, max, avg, count);
        fflush(stdout);
    } else if (config.output == OUTPUT_CSV) {
        printf(""%lld,%lld,%.2f,%lld\n"", min, max, avg, count);
    } else if (config.output == OUTPUT_RAW) {
        printf(""%lld %lld %.2f %lld\n"", min, max, avg, count);
    } else if (config.output == OUTPUT_JSON) {
        printf(""{\""min\"": %lld, \""max\"": %lld, \""avg\"": %.2f, \""count\"": %lld}\n"", min, max, avg, count);
    }
}",8157.0,8169.0,1.0,25.0,13.0,2,2,6,6,1,2,2,2,2,0,,0,2,8,4,4,void
4029,308253,latencyMode,1,latencyMode,void latencyMode (void),redis-cli.c,"static void latencyMode(void) {
    redisReply *reply;
    long long start, latency, min = 0, max = 0, tot = 0, count = 0;
    long long history_interval =
        config.interval ? config.interval/1000 :
                          LATENCY_HISTORY_DEFAULT_INTERVAL;
    double avg;
    long long history_start = mstime();

    /* Set a default for the interval in case of --latency option
     * with --raw, --csv or when it is redirected to non tty. */
    if (config.interval == 0) {
        config.interval = 1000;
    } else {
        config.interval /= 1000; /* We need to convert to milliseconds. */
    }

    if (!context) exit(1);
    while(1) {
        start = mstime();
        reply = reconnectingRedisCommand(context,""PING"");
        if (reply == NULL) {
            fprintf(stderr,""\nI/O error\n"");
            exit(1);
        }
        latency = mstime()-start;
        freeReplyObject(reply);
        count++;
        if (count == 1) {
            min = max = tot = latency;
      ...",8173.0,8231.0,1.0,26.0,59.0,42,12,42,14,0,20,8,12,7,8,,0,18,2,1,1,void
4030,308485,showLatencyDistSamples,1,showLatencyDistSamples,"void showLatencyDistSamples (distsamples*,long long)",redis-cli.c,"void showLatencyDistSamples(struct distsamples *samples, long long tot) {
    int j;

     /* We convert samples into an index inside the palette
     * proportional to the percentage a given bucket represents.
     * This way intensity of the different parts of the spectrum
     * don't change relative to the number of requests, which avoids to
     * pollute the visualization with non-latency related info. */
    printf(""\033[38;5;0m""); /* Set foreground color to black. */
    for (j = 0; ; j++) {
        int coloridx =
            ceil((double) samples[j].count / tot * (spectrum_palette_size-1));
        int color = spectrum_palette[coloridx];
        printf(""\033[48;5;%dm%c"", (int)color, samples[j].character);
        samples[j].count = 0;
        if (samples[j].max == 0) break; /* Last sample. */
    }
    printf(""\033[0m\n"");
    fflush(stdout);
}",8257.0,8276.0,1.0,1.0,20.0,20,9,18,8,1,2,4,4,0,0,,0,2,4,2,2,void
4031,308556,showLatencyDistLegend,1,showLatencyDistLegend,void showLatencyDistLegend (void),redis-cli.c,"void showLatencyDistLegend(void) {
    int j;

    printf(""---------------------------------------------\n"");
    printf("". - * #          .01 .125 .25 .5 milliseconds\n"");
    printf(""1,2,3,...,9      from 1 to 9     milliseconds\n"");
    printf(""A,B,C,D,E        10,20,30,40,50  milliseconds\n"");
    printf(""F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n"");
    printf(""K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\n"");
    printf(""From 0 to 100%%: "");
    for (j = 0; j < spectrum_palette_size; j++) {
        printf(""\033[48;5;%dm "", spectrum_palette[j]);
    }
    printf(""\033[0m\n"");
    printf(""---------------------------------------------\n"");
}",8280.0,8295.0,1.0,1.0,16.0,3,3,5,3,1,2,2,2,1,0,,0,2,2,1,1,void
4032,308596,latencyDistMode,1,latencyDistMode,void latencyDistMode (void),redis-cli.c,"static void latencyDistMode(void) {
    redisReply *reply;
    long long start, latency, count = 0;
    long long history_interval =
        config.interval ? config.interval/1000 :
                          LATENCY_DIST_DEFAULT_INTERVAL;
    long long history_start = ustime();
    int j, outputs = 0;

    struct distsamples samples[] = {
        /* We use a mostly logarithmic scale, with certain linear intervals
         * which are more interesting than others, like 1-10 milliseconds
         * range. */
        {10,0,'.'},         /* 0.01 ms */
        {125,0,'-'},        /* 0.125 ms */
        {250,0,'*'},        /* 0.25 ms */
        {500,0,'#'},        /* 0.5 ms */
        {1000,0,'1'},       /* 1 ms */
        {2000,0,'2'},       /* 2 ms */
        {3000,0,'3'},       /* 3 ms */
        {4000,0,'4'},       /* 4 ms */
        {5000,0,'5'},       /* 5 ms */
        {6000,0,'6'},       /* 6 ms */
        {7000,0,'7'},       /* 7 ms */
        {8000,0,'8'},       /* 8 ms */
     ...",8297.0,8373.0,1.0,26.0,77.0,70,16,35,13,0,12,9,15,1,8,,0,10,2,1,1,void
4033,308863,sendReplconf,1,sendReplconf,"int sendReplconf (char*,char*)",redis-cli.c,"int sendReplconf(const char* arg1, const char* arg2) {
    int res = 1;
    fprintf(stderr, ""sending REPLCONF %s %s\n"", arg1, arg2);
    redisReply *reply = redisCommand(context, ""REPLCONF %s %s"", arg1, arg2);

    /* Handle any error conditions */
    if(reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if(reply->type == REDIS_REPLY_ERROR) {
        /* non fatal, old versions may not support it */
        fprintf(stderr, ""REPLCONF %s error: %s\n"", arg1, reply->str);
        res = 0;
    }
    freeReplyObject(reply);
    return res;
}",8381.0,8397.0,1.0,1.0,17.0,3,2,13,7,2,0,2,2,0,0,,0,0,4,2,2,int
4034,308919,sendCapa,1,sendCapa,void sendCapa (void),redis-cli.c,"void sendCapa(void) {
    sendReplconf(""capa"", ""eof"");
}",8399.0,8401.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,void
4035,308927,sendRdbOnly,1,sendRdbOnly,void sendRdbOnly (void),redis-cli.c,"void sendRdbOnly(void) {
    sendReplconf(""rdb-only"", ""1"");
}",8403.0,8405.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,void
4036,308935,readConn,1,readConn,"ssize_t readConn (redisContext*,char*,size_t)",redis-cli.c,"static ssize_t readConn(redisContext *c, char *buf, size_t len)
{
    return c->funcs->read(c, buf, len);
}",8410.0,8413.0,1.0,1.0,4.0,2,1,4,3,2,0,1,1,0,0,,0,0,6,3,3,ssize_t
4037,308952,sendSync,1,sendSync,"unsigned long long sendSync (redisContext*,int,char*,int*)",redis-cli.c,"unsigned long long sendSync(redisContext *c, int send_sync, char *out_eof, int *out_full_mode) {
    /* To start we need to send the SYNC command and return the payload.
     * The hiredis client lib does not understand this part of the protocol
     * and we don't want to mess with its buffers, so everything is performed
     * using direct low-level I/O. */
    char buf[4096], *p;
    ssize_t nread;

    if (out_full_mode) *out_full_mode = 1;

    if (send_sync) {
        /* Send the SYNC command. */
        if (cliWriteConn(c, ""SYNC\r\n"", 6) != 6) {
            fprintf(stderr,""Error writing to master\n"");
            exit(1);
        }
    } else {
        /* We have written the command into c->obuf before. */
        if (cliWriteConn(c, """", 0) != 0) {
            fprintf(stderr,""Error writing to master\n"");
            exit(1);
        }
    }

    /* Read $<payload>\r\n, making sure to read just up to ""\n"" */
    p = buf;
    while(1) {
        nread = readConn(c,p,1);
        ...",8425.0,8499.0,1.0,57.0,75.0,51,14,55,10,0,3,23,36,1,3,,0,3,8,4,4,unsigned long long
4038,309719,pipeMode,1,pipeMode,void pipeMode (void),redis-cli.c,"static void pipeMode(void) {
    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
    char obuf[1024*16]; /* Output buffer */
    char aneterr[ANET_ERR_LEN];
    redisReply *reply;
    int eof = 0; /* True once we consumed all the standard input. */
    int done = 0;
    char magic[20]; /* Special reply we recognize. */
    time_t last_read_time = time(NULL);

    srand(time(NULL));

    /* Use non blocking I/O. */
    if (anetNonBlock(aneterr,context->fd) == ANET_ERR) {
        fprintf(stderr, ""Can't set the socket in non blocking mode: %s\n"",
            aneterr);
        exit(1);
    }

    context->flags &= ~REDIS_BLOCK;

    /* Transfer raw protocol and read replies from the server at the same
     * time. */
    while(!done) {
        int mask = AE_READABLE;

        if (!eof || obuf_len != 0) mask |= AE_WRITABLE;
        mask = aeWait(context->fd,mask,1000);

        /* Handle the readable state: we can read replies from the server. */
        if (mask & AE_READ...",8672.0,8824.0,1.0,17.0,153.0,82,22,105,29,0,9,27,81,5,3,,0,9,2,1,1,void
4039,310156,sendScan,1,sendScan,redisReply sendScan (long long unsigned*),redis-cli.c,"static redisReply *sendScan(unsigned long long *it) {
    redisReply *reply;

    if (config.pattern)
        reply = redisCommand(context, ""SCAN %llu MATCH %b COUNT %d"",
            *it, config.pattern, sdslen(config.pattern), config.count);
    else
        reply = redisCommand(context,""SCAN %llu"",*it);

    /* Handle any error conditions */
    if(reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if(reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr, ""SCAN error: %s\n"", reply->str);
        exit(1);
    } else if(reply->type != REDIS_REPLY_ARRAY) {
        fprintf(stderr, ""Non ARRAY response from SCAN!\n"");
        exit(1);
    } else if(reply->elements != 2) {
        fprintf(stderr, ""Invalid element count from SCAN!\n"");
        exit(1);
    }

    /* Validate our types are correct */
    assert(reply->element[0]->type == REDIS_REPLY_STRING);
    assert(reply->element[1]->type == REDIS_REPLY_ARRAY);

    /* Update iterator */
    *it...",8830.0,8862.0,1.0,1.0,33.0,20,6,18,8,3,9,3,3,2,1,,0,9,2,1,1,redisReply
4040,310283,getDbSize,1,getDbSize,int getDbSize (void),redis-cli.c,"static int getDbSize(void) {
    redisReply *reply;
    int size;

    reply = redisCommand(context, ""DBSIZE"");

    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if (reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr, ""Couldn't determine DBSIZE: %s\n"", reply->str);
        exit(1);
    } else if (reply->type != REDIS_REPLY_INTEGER) {
        fprintf(stderr, ""Non INTEGER response from DBSIZE!\n"");
        exit(1);
    }

    /* Grab the number of keys and free our reply */
    size = reply->integer;
    freeReplyObject(reply);

    return size;
}",8864.0,8886.0,1.0,1.0,23.0,4,3,9,5,2,0,2,2,0,0,,0,0,2,1,1,int
4041,310403,typeinfo_add,1,typeinfo_add,"typeinfo typeinfo_add (dict*,char*,typeinfo*)",redis-cli.c,"static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
    typeinfo *info = zmalloc(sizeof(typeinfo));
    *info = *type_template;
    info->name = sdsnew(name);
    dictAdd(types, info->name, info);
    return info;
}",8906.0,8912.0,1.0,1.0,7.0,8,4,10,5,6,6,1,1,0,3,,0,5,6,3,3,typeinfo
4042,310435,type_free,1,type_free,"void type_free (dict*,void*)",redis-cli.c,"void type_free(dict *d, void* val) {
    typeinfo *info = val;
    UNUSED(d);
    if (info->biggest_key)
        sdsfree(info->biggest_key);
    sdsfree(info->name);
    zfree(info);
}",8914.0,8921.0,1.0,4.0,8.0,5,3,8,3,0,6,2,2,1,3,,0,3,4,2,2,void
4043,310477,getKeyTypes,1,getKeyTypes,"void getKeyTypes (dict*,redisReply*,typeinfo**)",redis-cli.c,"static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
    redisReply *reply;
    unsigned int i;

    /* Pipeline TYPE commands */
    for(i=0;i<keys->elements;i++) {
        const char* argv[] = {""TYPE"", keys->element[i]->str};
        size_t lens[] = {4, keys->element[i]->len};
        redisAppendCommandArgv(context, 2, argv, lens);
    }

    /* Retrieve types */
    for(i=0;i<keys->elements;i++) {
        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
            fprintf(stderr, ""Error getting type for key '%s' (%d: %s)\n"",
                keys->element[i]->str, context->err, context->errstr);
            exit(1);
        } else if(reply->type != REDIS_REPLY_STATUS) {
            if(reply->type == REDIS_REPLY_ERROR) {
                fprintf(stderr, ""TYPE returned an error: %s\n"", reply->str);
            } else {
                fprintf(stderr,
                    ""Invalid reply type (%d) for TYPE on key '%s'!\n"",
                    reply->typ...",8933.0,8972.0,1.0,1.0,40.0,31,8,38,14,1,4,5,7,0,4,,0,3,6,3,3,void
4044,310659,getKeySizes,1,getKeySizes,"void getKeySizes (redisReply*,typeinfo**,long long unsigned*,int,unsigned)",redis-cli.c,"static void getKeySizes(redisReply *keys, typeinfo **types,
                        unsigned long long *sizes, int memkeys,
                        unsigned memkeys_samples)
{
    redisReply *reply;
    unsigned int i;

    /* Pipeline size commands */
    for(i=0;i<keys->elements;i++) {
        /* Skip keys that disappeared between SCAN and TYPE (or unknown types when not in memkeys mode) */
        if(!types[i] || (!types[i]->sizecmd && !memkeys))
            continue;

        if (!memkeys) {
            const char* argv[] = {types[i]->sizecmd, keys->element[i]->str};
            size_t lens[] = {strlen(types[i]->sizecmd), keys->element[i]->len};
            redisAppendCommandArgv(context, 2, argv, lens);
        } else if (memkeys_samples==0) {
            const char* argv[] = {""MEMORY"", ""USAGE"", keys->element[i]->str};
            size_t lens[] = {6, 5, keys->element[i]->len};
            redisAppendCommandArgv(context, 3, argv, lens);
        } else {
            sds samplesst...",8974.0,9031.0,1.0,1.0,58.0,47,11,41,11,1,0,9,11,0,0,,0,0,10,5,5,void
4045,310932,longStatLoopModeStop,1,longStatLoopModeStop,void longStatLoopModeStop (int),redis-cli.c,"static void longStatLoopModeStop(int s) {
    UNUSED(s);
    force_cancel_loop = 1;
}",9033.0,9036.0,1.0,4.0,4.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
4046,310946,findBigKeys,1,findBigKeys,"void findBigKeys (int,unsigned)",redis-cli.c,"static void findBigKeys(int memkeys, unsigned memkeys_samples) {
    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0, scan_loops = 0;
    redisReply *reply, *keys;
    unsigned int arrsize=0, i;
    dictIterator *di;
    dictEntry *de;
    typeinfo **types = NULL;
    double pct;

    dict *types_dict = dictCreate(&typeinfoDictType);
    typeinfo_add(types_dict, ""string"", &type_string);
    typeinfo_add(types_dict, ""list"", &type_list);
    typeinfo_add(types_dict, ""set"", &type_set);
    typeinfo_add(types_dict, ""hash"", &type_hash);
    typeinfo_add(types_dict, ""zset"", &type_zset);
    typeinfo_add(types_dict, ""stream"", &type_stream);

    signal(SIGINT, longStatLoopModeStop);
    /* Total keys pre scanning */
    total_keys = getDbSize();

    /* Status message */
    printf(""\n# Scanning the entire keyspace to find biggest keys as well as\n"");
    printf(""# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"");
    printf(""# per 100 SCAN comma...",9038.0,9173.0,1.0,1.0,136.0,124,20,145,32,0,65,18,35,10,27,,0,51,4,2,2,void
4047,311409,getKeyFreqs,1,getKeyFreqs,"void getKeyFreqs (redisReply*,long long unsigned*)",redis-cli.c,"static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
    redisReply *reply;
    unsigned int i;

    /* Pipeline OBJECT freq commands */
    for(i=0;i<keys->elements;i++) {
        const char* argv[] = {""OBJECT"", ""FREQ"", keys->element[i]->str};
        size_t lens[] = {6, 4, keys->element[i]->len};
        redisAppendCommandArgv(context, 3, argv, lens);
    }

    /* Retrieve freqs */
    for(i=0;i<keys->elements;i++) {
        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
            sds keyname = sdscatrepr(sdsempty(), keys->element[i]->str, keys->element[i]->len);
            fprintf(stderr, ""Error getting freq for key '%s' (%d: %s)\n"",
                keyname, context->err, context->errstr);
            sdsfree(keyname);
            exit(1);
        } else if(reply->type != REDIS_REPLY_INTEGER) {
            if(reply->type == REDIS_REPLY_ERROR) {
                fprintf(stderr, ""Error: %s\n"", reply->str);
                exit(1);
            } else {
 ...",9175.0,9209.0,1.0,1.0,35.0,28,8,29,9,1,3,4,5,0,3,,0,2,4,2,2,void
4048,311584,findHotKeys,1,findHotKeys,void findHotKeys (void),redis-cli.c,"static void findHotKeys(void) {
    redisReply *keys, *reply;
    unsigned long long counters[HOTKEYS_SAMPLE] = {0};
    sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
    unsigned long long sampled = 0, total_keys, *freqs = NULL, it = 0, scan_loops = 0;
    unsigned int arrsize = 0, i, k;
    double pct;

    signal(SIGINT, longStatLoopModeStop);
    /* Total keys pre scanning */
    total_keys = getDbSize();

    /* Status message */
    printf(""\n# Scanning the entire keyspace to find hot keys as well as\n"");
    printf(""# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"");
    printf(""# per 100 SCAN commands (not usually needed).\n\n"");

    /* SCAN loop */
    do {
        /* Calculate approximate percentage completion */
        pct = 100 * (double)sampled/total_keys;

        /* Grab some keys and point to the keys array */
        reply = sendScan(&it);
        scan_loops++;
        keys  = reply->element[1];

        /* Reallocate our freqs array if we need to */
 ...",9212.0,9304.0,1.0,32.0,93.0,78,22,89,19,0,15,15,28,4,9,,0,11,2,1,1,void
4049,312011,bytesToHuman,1,bytesToHuman,"void bytesToHuman (char*,size_t,long long)",server.c,"void bytesToHuman(char *s, size_t size, unsigned long long n) {
    double d;

    if (n < 1024) {
        /* Bytes */
        snprintf(s,size,""%lluB"",n);
    } else if (n < (1024*1024)) {
        d = (double)n/(1024);
        snprintf(s,size,""%.2fK"",d);
    } else if (n < (1024LL*1024*1024)) {
        d = (double)n/(1024*1024);
        snprintf(s,size,""%.2fM"",d);
    } else if (n < (1024LL*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024);
        snprintf(s,size,""%.2fG"",d);
    } else if (n < (1024LL*1024*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024*1024);
        snprintf(s,size,""%.2fT"",d);
    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024*1024*1024);
        snprintf(s,size,""%.2fP"",d);
    } else {
        /* Let's hope we never need this */
        snprintf(s,size,""%lluB"",n);
    }
}",5255.0,5280.0,1.0,1.0,26.0,7,5,9,3,9,0,3,3,0,0,,0,0,6,3,3,void
4050,312120,statMode,1,statMode,void statMode (void),redis-cli.c,"static void statMode(void) {
    redisReply *reply;
    long aux, requests = 0;
    int i = 0;

    while(1) {
        char buf[64];
        int j;

        reply = reconnectingRedisCommand(context,""INFO"");
        if (reply == NULL) {
            fprintf(stderr, ""\nI/O error\n"");
            exit(1);
        } else if (reply->type == REDIS_REPLY_ERROR) {
            fprintf(stderr, ""ERROR: %s\n"", reply->str);
            exit(1);
        }

        if ((i++ % 20) == 0) {
            printf(
""------- data ------ --------------------- load -------------------- - child -\n""
""keys       mem      clients blocked requests            connections          \n"");
        }

        /* Keys */
        aux = 0;
        for (j = 0; j < 20; j++) {
            long k;

            snprintf(buf,sizeof(buf),""db%d:keys"",j);
            k = getLongInfoField(reply->str,buf);
            if (k == LONG_MIN) continue;
            aux += k;
        }
        snprintf(buf,sizeof(buf),""%ld"",aux);
        pr...",9367.0,9454.0,1.0,1.0,88.0,42,12,69,12,0,13,13,13,0,11,,0,10,2,1,1,void
4051,312377,scanMode,1,scanMode,void scanMode (void),redis-cli.c,"static void scanMode(void) {
    redisReply *reply;
    unsigned long long cur = 0;
    signal(SIGINT, longStatLoopModeStop);
    do {
        reply = sendScan(&cur);
        for (unsigned int j = 0; j < reply->element[1]->elements; j++) {
            if (config.output == OUTPUT_STANDARD) {
                sds out = sdscatrepr(sdsempty(), reply->element[1]->element[j]->str,
                                     reply->element[1]->element[j]->len);
                printf(""%s\n"", out);
                sdsfree(out);
            } else {
                printf(""%s\n"", reply->element[1]->element[j]->str);
            }
        }
        freeReplyObject(reply);
        if (config.interval) usleep(config.interval);
    } while(force_cancel_loop == 0 && cur != 0);

    exit(0);
}",9460.0,9481.0,1.0,33.0,22.0,26,9,20,7,0,11,5,9,5,4,,0,10,2,1,1,void
4052,312491,powerLawRand,1,powerLawRand,"long long powerLawRand (long long,long long,double)",redis-cli.c,"long long powerLawRand(long long min, long long max, double alpha) {
    double pl, r;

    max += 1;
    r = ((double)rand()) / RAND_MAX;
    pl = pow(
        ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),
        (1.0/(alpha+1)));
    return (max-1-(long long)pl)+min;
}",9493.0,9502.0,1.0,1.0,10.0,17,7,15,6,1,0,1,1,0,0,,0,0,6,3,3,long long
4053,312547,LRUTestGenKey,1,LRUTestGenKey,"void LRUTestGenKey (char*,size_t)",redis-cli.c,"void LRUTestGenKey(char *buf, size_t buflen) {
    snprintf(buf, buflen, ""lru:%lld"",
        powerLawRand(1, config.lru_test_sample_size, 6.2));
}",9506.0,9509.0,1.0,1.0,4.0,1,1,3,3,2,3,1,1,0,1,,0,2,4,2,2,void
4054,312563,LRUTestMode,1,LRUTestMode,void LRUTestMode (void),redis-cli.c,"static void LRUTestMode(void) {
    redisReply *reply;
    char key[128];
    long long start_cycle;
    int j;

    srand(time(NULL)^getpid());
    while(1) {
        /* Perform cycles of 1 second with 50% writes and 50% reads.
         * We use pipelining batching writes / reads N times per cycle in order
         * to fill the target instance easily. */
        start_cycle = mstime();
        long long hits = 0, misses = 0;
        while(mstime() - start_cycle < LRU_CYCLE_PERIOD) {
            /* Write cycle. */
            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
                char val[6];
                val[5] = '\0';
                for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');
                LRUTestGenKey(key,sizeof(key));
                redisAppendCommand(context, ""SET %s %s"",key,val);
            }
            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)
                redisGetReply(context, (void**)&reply);

            /* Read cycle. */
        ...",9513.0,9572.0,1.0,39.0,60.0,37,14,47,14,0,4,14,32,1,4,,0,2,2,1,1,void
4055,312772,compute_something_fast,1,compute_something_fast,unsigned long compute_something_fast (void),redis-cli.c,"unsigned long compute_something_fast(void) {
    unsigned char s[256], i, j, t;
    int count = 1000, k;
    unsigned long output = 0;

    for (k = 0; k < 256; k++) s[k] = k;

    i = 0;
    j = 0;
    while(count--) {
        i++;
        j = j + s[i];
        t = s[i];
        s[i] = s[j];
        s[j] = t;
        output += s[(s[i]+s[j])&255];
    }
    return output;
}",9585.0,9603.0,1.0,1.0,19.0,24,8,29,7,1,0,3,3,0,0,,0,0,2,1,1,unsigned long
4056,312856,sigIntHandler,1,sigIntHandler,void sigIntHandler (int),redis-cli.c,"static void sigIntHandler(int s) {
    UNUSED(s);

    if (config.monitor_mode || config.pubsub_mode) {
        close(context->fd);
        context->fd = REDIS_INVALID_FD;
        config.blocking_state_aborted = 1;
    } else {
        exit(1);
    }
}",9605.0,9615.0,1.0,4.0,11.0,9,5,8,4,0,6,2,2,4,0,,0,6,2,1,1,void
4057,312894,intrinsicLatencyMode,1,intrinsicLatencyMode,void intrinsicLatencyMode (void),redis-cli.c,"static void intrinsicLatencyMode(void) {
    long long test_end, run_time, max_latency = 0, runs = 0;

    run_time = (long long)config.intrinsic_latency_duration * 1000000;
    test_end = ustime() + run_time;
    signal(SIGINT, longStatLoopModeStop);

    while(1) {
        long long start, end, latency;

        start = ustime();
        compute_something_fast();
        end = ustime();
        latency = end-start;
        runs++;
        if (latency <= 0) continue;

        /* Reporting */
        if (latency > max_latency) {
            max_latency = latency;
            printf(""Max latency so far: %lld microseconds.\n"", max_latency);
        }

        double avg_us = (double)run_time/runs;
        double avg_ns = avg_us * 1e3;
        if (force_cancel_loop || end > test_end) {
            printf(""\n%lld total runs ""
                ""(avg latency: ""
                ""%.4f microseconds / %.2f nanoseconds per run).\n"",
                runs, avg_us, avg_ns);
            printf(""Wor...",9617.0,9652.0,1.0,1.0,36.0,24,11,32,12,0,7,6,8,1,4,,0,6,2,1,1,void
4058,313010,testHint,1,testHint,void testHint (char*),redis-cli.c,"void testHint(const char *input) {
    cliInitHelp();

    sds hint = getHintForInput(input);
    printf(""%s\n"", hint);
    exit(0);
}",9662.0,9668.0,1.0,1.0,7.0,1,1,3,2,0,2,1,1,0,2,,0,1,2,1,1,void
4059,313026,readHintSuiteLine,1,readHintSuiteLine,"sds readHintSuiteLine (char[],size_t,FILE*)",redis-cli.c,"sds readHintSuiteLine(char buf[], size_t size, FILE *fp) {
    while (fgets(buf, size, fp) != NULL) {
        if (buf[0] != '#') {
            sds input = sdsnew(buf);

            /* Strip newline. */
            input = sdstrim(input, ""\n"");
            return input;
        }
    }
    return NULL;
}",9670.0,9681.0,1.0,1.0,12.0,5,3,11,5,1,2,3,4,0,2,,0,2,6,3,3,sds
4060,313062,testHintSuite,1,testHintSuite,void testHintSuite (char*),redis-cli.c,"void testHintSuite(char *filename) {
    FILE *fp;
    char buf[256];
    sds line, input, expected, hint;
    int pass=0, fail=0;
    int argc;
    char **argv;

    fp = fopen(filename, ""r"");
    if (!fp) {
        fprintf(stderr,
            ""Can't open file '%s': %s\n"", filename, strerror(errno));
        exit(-1);
    }

    cliInitHelp();

    while (1) {
        line = readHintSuiteLine(buf, sizeof(buf), fp);
        if (line == NULL) break;
        argv = sdssplitargs(line, &argc);
        sdsfree(line);
        if (argc == 0) {
            sdsfreesplitres(argv, argc);
            continue;
        }

        if (argc == 1) {
            fprintf(stderr,
                ""Missing expected hint for input '%s'\n"", argv[0]);
            exit(-1);
        }
        input = argv[0];
        expected = argv[1];
        hint = getHintForInput(input);
        if (config.verbose) {
            printf(""Input: '%s', Expected: '%s', Hint: '%s'\n"", input, expected, hint);
        }

      ...",9684.0,9743.0,1.0,1.0,60.0,37,16,61,15,0,15,11,15,4,13,,0,8,2,1,1,void
4061,314852,RedisModule_Alloc,1,RedisModule_Alloc,void* RedisModule_Alloc (size_t),redismodule.h,void * (*RedisModule_Alloc)(size_t bytes) REDISMODULE_ATTR;,959.0,959.0,22.0,57.0,1.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,void*
4062,314868,RedisModule_Free,1,RedisModule_Free,void RedisModule_Free (void*),redismodule.h,void (*RedisModule_Free)(void *ptr) REDISMODULE_ATTR;,962.0,962.0,22.0,51.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
4063,314890,RedisModule_CreateCommand,1,RedisModule_CreateCommand,"int RedisModule_CreateCommand (RedisModuleCtx*,char*,RedisModuleCmdFunc,char*,int,int,int)",redismodule.h,"int (*RedisModule_CreateCommand)(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) REDISMODULE_ATTR;",966.0,966.0,21.0,177.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,14,7,7,int
4064,314943,RedisModule_WrongArity,1,RedisModule_WrongArity,int RedisModule_WrongArity (RedisModuleCtx*),redismodule.h,int (*RedisModule_WrongArity)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,973.0,973.0,21.0,66.0,1.0,0,0,0,0,24,0,1,1,0,0,,0,0,2,1,1,int
4065,314948,RedisModule_ReplyWithLongLong,1,RedisModule_ReplyWithLongLong,"int RedisModule_ReplyWithLongLong (RedisModuleCtx*,long long)",redismodule.h,"int (*RedisModule_ReplyWithLongLong)(RedisModuleCtx *ctx, long long ll) REDISMODULE_ATTR;",974.0,974.0,21.0,87.0,1.0,0,0,0,0,14,0,1,1,0,0,,0,0,4,2,2,int
4066,314954,RedisModule_GetSelectedDb,1,RedisModule_GetSelectedDb,int RedisModule_GetSelectedDb (RedisModuleCtx*),redismodule.h,int (*RedisModule_GetSelectedDb)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,975.0,975.0,21.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4067,314971,RedisModule_OpenKey,1,RedisModule_OpenKey,"RedisModuleKey* RedisModule_OpenKey (RedisModuleCtx*,RedisModuleString*,int)",redismodule.h,"RedisModuleKey * (*RedisModule_OpenKey)(RedisModuleCtx *ctx, RedisModuleString *keyname, int mode) REDISMODULE_ATTR;",978.0,978.0,32.0,114.0,1.0,0,0,0,0,15,0,1,1,0,0,,0,0,6,3,3,RedisModuleKey*
4068,314983,RedisModule_CloseKey,1,RedisModule_CloseKey,void RedisModule_CloseKey (RedisModuleKey*),redismodule.h,void (*RedisModule_CloseKey)(RedisModuleKey *kp) REDISMODULE_ATTR;,980.0,980.0,22.0,64.0,1.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,void
4069,314988,RedisModule_KeyType,1,RedisModule_KeyType,int RedisModule_KeyType (RedisModuleKey*),redismodule.h,int (*RedisModule_KeyType)(RedisModuleKey *kp) REDISMODULE_ATTR;,981.0,981.0,21.0,62.0,1.0,0,0,0,0,17,0,1,1,0,0,,0,0,2,1,1,int
4070,314993,RedisModule_ValueLength,1,RedisModule_ValueLength,size_t RedisModule_ValueLength (RedisModuleKey*),redismodule.h,size_t (*RedisModule_ValueLength)(RedisModuleKey *kp) REDISMODULE_ATTR;,982.0,982.0,24.0,69.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,size_t
4071,314998,RedisModule_ListPush,1,RedisModule_ListPush,"int RedisModule_ListPush (RedisModuleKey*,int,RedisModuleString*)",redismodule.h,"int (*RedisModule_ListPush)(RedisModuleKey *kp, int where, RedisModuleString *ele) REDISMODULE_ATTR;",983.0,983.0,21.0,98.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,int
4072,315005,RedisModule_ListPop,1,RedisModule_ListPop,"RedisModuleString* RedisModule_ListPop (RedisModuleKey*,int)",redismodule.h,"RedisModuleString * (*RedisModule_ListPop)(RedisModuleKey *key, int where) REDISMODULE_ATTR;",984.0,984.0,35.0,90.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
4073,315037,RedisModule_Call,1,RedisModule_Call,"RedisModuleCallReply* RedisModule_Call (RedisModuleCtx*,char*,char*...)",redismodule.h,"RedisModuleCallReply * (*RedisModule_Call)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",989.0,989.0,38.0,122.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,6,3,3,RedisModuleCallReply*
4074,315050,RedisModule_FreeCallReply,1,RedisModule_FreeCallReply,void RedisModule_FreeCallReply (RedisModuleCallReply*),redismodule.h,void (*RedisModule_FreeCallReply)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,991.0,991.0,22.0,78.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
4075,315060,RedisModule_CallReplyInteger,1,RedisModule_CallReplyInteger,long long RedisModule_CallReplyInteger (RedisModuleCallReply*),redismodule.h,long long (*RedisModule_CallReplyInteger)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,993.0,993.0,27.0,86.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,long long
4076,315128,RedisModule_CallReplyLength,1,RedisModule_CallReplyLength,size_t RedisModule_CallReplyLength (RedisModuleCallReply*),redismodule.h,size_t (*RedisModule_CallReplyLength)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,1004.0,1004.0,24.0,82.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,size_t
4077,315133,RedisModule_CallReplyArrayElement,1,RedisModule_CallReplyArrayElement,"RedisModuleCallReply* RedisModule_CallReplyArrayElement (RedisModuleCallReply*,size_t)",redismodule.h,"RedisModuleCallReply * (*RedisModule_CallReplyArrayElement)(RedisModuleCallReply *reply, size_t idx) REDISMODULE_ATTR;",1005.0,1005.0,38.0,116.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,RedisModuleCallReply*
4078,315146,RedisModule_CreateStringFromLongLong,1,RedisModule_CreateStringFromLongLong,"RedisModuleString* RedisModule_CreateStringFromLongLong (RedisModuleCtx*,long long)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromLongLong)(RedisModuleCtx *ctx, long long ll) REDISMODULE_ATTR;",1007.0,1007.0,35.0,110.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
4079,315171,RedisModule_CreateStringFromString,1,RedisModule_CreateStringFromString,"RedisModuleString* RedisModule_CreateStringFromString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromString)(RedisModuleCtx *ctx, const RedisModuleString *str) REDISMODULE_ATTR;",1011.0,1011.0,35.0,124.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
4080,315189,RedisModule_FreeString,1,RedisModule_FreeString,"void RedisModule_FreeString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"void (*RedisModule_FreeString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1014.0,1014.0,22.0,91.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,void
4081,315195,RedisModule_StringPtrLen,1,RedisModule_StringPtrLen,"char* RedisModule_StringPtrLen (RedisModuleString*,size_t*)",redismodule.h,"const char * (*RedisModule_StringPtrLen)(const RedisModuleString *str, size_t *len) REDISMODULE_ATTR;",1015.0,1015.0,28.0,99.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,char*
4082,315201,RedisModule_ReplyWithError,1,RedisModule_ReplyWithError,"int RedisModule_ReplyWithError (RedisModuleCtx*,char*)",redismodule.h,"int (*RedisModule_ReplyWithError)(RedisModuleCtx *ctx, const char *err) REDISMODULE_ATTR;",1016.0,1016.0,21.0,87.0,1.0,0,0,0,0,31,0,1,1,0,0,,0,0,4,2,2,int
4083,315213,RedisModule_ReplyWithSimpleString,1,RedisModule_ReplyWithSimpleString,"int RedisModule_ReplyWithSimpleString (RedisModuleCtx*,char*)",redismodule.h,"int (*RedisModule_ReplyWithSimpleString)(RedisModuleCtx *ctx, const char *msg) REDISMODULE_ATTR;",1018.0,1018.0,21.0,94.0,1.0,0,0,0,0,11,0,1,1,0,0,,0,0,4,2,2,int
4084,315219,RedisModule_ReplyWithArray,1,RedisModule_ReplyWithArray,"int RedisModule_ReplyWithArray (RedisModuleCtx*,long)",redismodule.h,"int (*RedisModule_ReplyWithArray)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1019.0,1019.0,21.0,80.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,4,2,2,int
4085,315253,RedisModule_ReplySetArrayLength,1,RedisModule_ReplySetArrayLength,"void RedisModule_ReplySetArrayLength (RedisModuleCtx*,long)",redismodule.h,"void (*RedisModule_ReplySetArrayLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1025.0,1025.0,22.0,86.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,void
4086,315283,RedisModule_ReplyWithStringBuffer,1,RedisModule_ReplyWithStringBuffer,"int RedisModule_ReplyWithStringBuffer (RedisModuleCtx*,char*,size_t)",redismodule.h,"int (*RedisModule_ReplyWithStringBuffer)(RedisModuleCtx *ctx, const char *buf, size_t len) REDISMODULE_ATTR;",1030.0,1030.0,21.0,106.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,int
4087,315296,RedisModule_ReplyWithString,1,RedisModule_ReplyWithString,"int RedisModule_ReplyWithString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"int (*RedisModule_ReplyWithString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1032.0,1032.0,21.0,95.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4088,315322,RedisModule_ReplyWithNull,1,RedisModule_ReplyWithNull,int RedisModule_ReplyWithNull (RedisModuleCtx*),redismodule.h,int (*RedisModule_ReplyWithNull)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1036.0,1036.0,21.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4089,315339,RedisModule_ReplyWithDouble,1,RedisModule_ReplyWithDouble,"int RedisModule_ReplyWithDouble (RedisModuleCtx*,double)",redismodule.h,"int (*RedisModule_ReplyWithDouble)(RedisModuleCtx *ctx, double d) REDISMODULE_ATTR;",1039.0,1039.0,21.0,81.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4090,315352,RedisModule_ReplyWithCallReply,1,RedisModule_ReplyWithCallReply,"int RedisModule_ReplyWithCallReply (RedisModuleCtx*,RedisModuleCallReply*)",redismodule.h,"int (*RedisModule_ReplyWithCallReply)(RedisModuleCtx *ctx, RedisModuleCallReply *reply) REDISMODULE_ATTR;",1041.0,1041.0,21.0,103.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4091,315358,RedisModule_StringToLongLong,1,RedisModule_StringToLongLong,"int RedisModule_StringToLongLong (RedisModuleString*,long long*)",redismodule.h,"int (*RedisModule_StringToLongLong)(const RedisModuleString *str, long long *ll) REDISMODULE_ATTR;",1042.0,1042.0,21.0,96.0,1.0,0,0,0,0,14,0,1,1,0,0,,0,0,4,2,2,int
4092,315370,RedisModule_StringToDouble,1,RedisModule_StringToDouble,"int RedisModule_StringToDouble (RedisModuleString*,double*)",redismodule.h,"int (*RedisModule_StringToDouble)(const RedisModuleString *str, double *d) REDISMODULE_ATTR;",1044.0,1044.0,21.0,90.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4093,315388,RedisModule_AutoMemory,1,RedisModule_AutoMemory,void RedisModule_AutoMemory (RedisModuleCtx*),redismodule.h,void (*RedisModule_AutoMemory)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1047.0,1047.0,22.0,67.0,1.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,void
4094,315393,RedisModule_Replicate,1,RedisModule_Replicate,"int RedisModule_Replicate (RedisModuleCtx*,char*,char*...)",redismodule.h,"int (*RedisModule_Replicate)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",1048.0,1048.0,21.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
4095,315400,RedisModule_ReplicateVerbatim,1,RedisModule_ReplicateVerbatim,int RedisModule_ReplicateVerbatim (RedisModuleCtx*),redismodule.h,int (*RedisModule_ReplicateVerbatim)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1049.0,1049.0,21.0,73.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
4096,315411,RedisModule_CreateStringFromCallReply,1,RedisModule_CreateStringFromCallReply,RedisModuleString* RedisModule_CreateStringFromCallReply (RedisModuleCallReply*),redismodule.h,RedisModuleString * (*RedisModule_CreateStringFromCallReply)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,1051.0,1051.0,35.0,105.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
4097,315432,RedisModule_StringDMA,1,RedisModule_StringDMA,"char* RedisModule_StringDMA (RedisModuleKey*,size_t*,int)",redismodule.h,"char * (*RedisModule_StringDMA)(RedisModuleKey *key, size_t *len, int mode) REDISMODULE_ATTR;",1055.0,1055.0,22.0,91.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,char*
4098,315445,RedisModule_GetExpire,1,RedisModule_GetExpire,mstime_t RedisModule_GetExpire (RedisModuleKey*),redismodule.h,mstime_t (*RedisModule_GetExpire)(RedisModuleKey *key) REDISMODULE_ATTR;,1057.0,1057.0,26.0,70.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,mstime_t
4099,315450,RedisModule_SetExpire,1,RedisModule_SetExpire,"int RedisModule_SetExpire (RedisModuleKey*,mstime_t)",redismodule.h,"int (*RedisModule_SetExpire)(RedisModuleKey *key, mstime_t expire) REDISMODULE_ATTR;",1058.0,1058.0,21.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4100,315514,RedisModule_ZsetRangeStop,1,RedisModule_ZsetRangeStop,void RedisModule_ZsetRangeStop (RedisModuleKey*),redismodule.h,void (*RedisModule_ZsetRangeStop)(RedisModuleKey *key) REDISMODULE_ATTR;,1068.0,1068.0,22.0,70.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
4101,315519,RedisModule_ZsetFirstInScoreRange,1,RedisModule_ZsetFirstInScoreRange,"int RedisModule_ZsetFirstInScoreRange (RedisModuleKey*,double,double,int,int)",redismodule.h,"int (*RedisModule_ZsetFirstInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex) REDISMODULE_ATTR;",1069.0,1069.0,21.0,123.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
4102,315528,RedisModule_ZsetLastInScoreRange,1,RedisModule_ZsetLastInScoreRange,"int RedisModule_ZsetLastInScoreRange (RedisModuleKey*,double,double,int,int)",redismodule.h,"int (*RedisModule_ZsetLastInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex) REDISMODULE_ATTR;",1070.0,1070.0,21.0,122.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
4103,315537,RedisModule_ZsetFirstInLexRange,1,RedisModule_ZsetFirstInLexRange,"int RedisModule_ZsetFirstInLexRange (RedisModuleKey*,RedisModuleString*,RedisModuleString*)",redismodule.h,"int (*RedisModule_ZsetFirstInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) REDISMODULE_ATTR;",1071.0,1071.0,21.0,123.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
4104,315551,RedisModule_ZsetRangeCurrentElement,1,RedisModule_ZsetRangeCurrentElement,"RedisModuleString* RedisModule_ZsetRangeCurrentElement (RedisModuleKey*,double*)",redismodule.h,"RedisModuleString * (*RedisModule_ZsetRangeCurrentElement)(RedisModuleKey *key, double *score) REDISMODULE_ATTR;",1073.0,1073.0,35.0,110.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
4105,315557,RedisModule_ZsetRangeNext,1,RedisModule_ZsetRangeNext,int RedisModule_ZsetRangeNext (RedisModuleKey*),redismodule.h,int (*RedisModule_ZsetRangeNext)(RedisModuleKey *key) REDISMODULE_ATTR;,1074.0,1074.0,21.0,69.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
4106,315562,RedisModule_ZsetRangePrev,1,RedisModule_ZsetRangePrev,int RedisModule_ZsetRangePrev (RedisModuleKey*),redismodule.h,int (*RedisModule_ZsetRangePrev)(RedisModuleKey *key) REDISMODULE_ATTR;,1075.0,1075.0,21.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4107,315567,RedisModule_ZsetRangeEndReached,1,RedisModule_ZsetRangeEndReached,int RedisModule_ZsetRangeEndReached (RedisModuleKey*),redismodule.h,int (*RedisModule_ZsetRangeEndReached)(RedisModuleKey *key) REDISMODULE_ATTR;,1076.0,1076.0,21.0,75.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
4108,315572,RedisModule_HashSet,1,RedisModule_HashSet,"int RedisModule_HashSet (RedisModuleKey*,int...)",redismodule.h,"int (*RedisModule_HashSet)(RedisModuleKey *key, int flags, ...) REDISMODULE_ATTR;",1077.0,1077.0,21.0,79.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4109,315578,RedisModule_HashGet,1,RedisModule_HashGet,"int RedisModule_HashGet (RedisModuleKey*,int...)",redismodule.h,"int (*RedisModule_HashGet)(RedisModuleKey *key, int flags, ...) REDISMODULE_ATTR;",1078.0,1078.0,21.0,79.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4110,315728,RedisModule_PoolAlloc,1,RedisModule_PoolAlloc,"void* RedisModule_PoolAlloc (RedisModuleCtx*,size_t)",redismodule.h,"void * (*RedisModule_PoolAlloc)(RedisModuleCtx *ctx, size_t bytes) REDISMODULE_ATTR;",1102.0,1102.0,22.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void*
4111,315742,RedisModule_ModuleTypeSetValue,1,RedisModule_ModuleTypeSetValue,"int RedisModule_ModuleTypeSetValue (RedisModuleKey*,RedisModuleType*,void*)",redismodule.h,"int (*RedisModule_ModuleTypeSetValue)(RedisModuleKey *key, RedisModuleType *mt, void *value) REDISMODULE_ATTR;",1104.0,1104.0,21.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
4112,315757,RedisModule_ModuleTypeGetType,1,RedisModule_ModuleTypeGetType,RedisModuleType* RedisModule_ModuleTypeGetType (RedisModuleKey*),redismodule.h,RedisModuleType * (*RedisModule_ModuleTypeGetType)(RedisModuleKey *key) REDISMODULE_ATTR;,1106.0,1106.0,33.0,87.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,RedisModuleType*
4113,315762,RedisModule_ModuleTypeGetValue,1,RedisModule_ModuleTypeGetValue,void* RedisModule_ModuleTypeGetValue (RedisModuleKey*),redismodule.h,void * (*RedisModule_ModuleTypeGetValue)(RedisModuleKey *key) REDISMODULE_ATTR;,1107.0,1107.0,22.0,77.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void*
4114,315784,RedisModule_SaveUnsigned,1,RedisModule_SaveUnsigned,"void RedisModule_SaveUnsigned (RedisModuleIO*,uint64_t)",redismodule.h,"void (*RedisModule_SaveUnsigned)(RedisModuleIO *io, uint64_t value) REDISMODULE_ATTR;",1111.0,1111.0,22.0,83.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4115,315790,RedisModule_LoadUnsigned,1,RedisModule_LoadUnsigned,uint64_t RedisModule_LoadUnsigned (RedisModuleIO*),redismodule.h,uint64_t (*RedisModule_LoadUnsigned)(RedisModuleIO *io) REDISMODULE_ATTR;,1112.0,1112.0,26.0,71.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
4116,315795,RedisModule_SaveSigned,1,RedisModule_SaveSigned,"void RedisModule_SaveSigned (RedisModuleIO*,int64_t)",redismodule.h,"void (*RedisModule_SaveSigned)(RedisModuleIO *io, int64_t value) REDISMODULE_ATTR;",1113.0,1113.0,22.0,80.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4117,315801,RedisModule_LoadSigned,1,RedisModule_LoadSigned,int64_t RedisModule_LoadSigned (RedisModuleIO*),redismodule.h,int64_t (*RedisModule_LoadSigned)(RedisModuleIO *io) REDISMODULE_ATTR;,1114.0,1114.0,25.0,68.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int64_t
4118,315806,RedisModule_EmitAOF,1,RedisModule_EmitAOF,"void RedisModule_EmitAOF (RedisModuleIO*,char*,char*...)",redismodule.h,"void (*RedisModule_EmitAOF)(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",1115.0,1115.0,22.0,105.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4119,315890,RedisModule_Log,1,RedisModule_Log,"void RedisModule_Log (RedisModuleCtx*,char*,char*...)",redismodule.h,"void (*RedisModule_Log)(RedisModuleCtx *ctx, const char *level, const char *fmt, ...) REDISMODULE_ATTR REDISMODULE_ATTR_PRINTF(3,4);",1129.0,1129.0,22.0,101.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
4120,315930,RedisModule_RetainString,1,RedisModule_RetainString,"void RedisModule_RetainString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"void (*RedisModule_RetainString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1135.0,1135.0,22.0,93.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4121,316020,RedisModule_DigestAddLongLong,1,RedisModule_DigestAddLongLong,"void RedisModule_DigestAddLongLong (RedisModuleDigest*,long long)",redismodule.h,"void (*RedisModule_DigestAddLongLong)(RedisModuleDigest *md, long long ele) REDISMODULE_ATTR;",1152.0,1152.0,22.0,91.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4122,316026,RedisModule_DigestEndSequence,1,RedisModule_DigestEndSequence,void RedisModule_DigestEndSequence (RedisModuleDigest*),redismodule.h,void (*RedisModule_DigestEndSequence)(RedisModuleDigest *md) REDISMODULE_ATTR;,1153.0,1153.0,22.0,76.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4123,316073,RedisModule_DictSet,1,RedisModule_DictSet,"int RedisModule_DictSet (RedisModuleDict*,RedisModuleString*,void*)",redismodule.h,"int (*RedisModule_DictSet)(RedisModuleDict *d, RedisModuleString *key, void *ptr) REDISMODULE_ATTR;",1161.0,1161.0,21.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
4124,316095,RedisModule_DictGet,1,RedisModule_DictGet,"void* RedisModule_DictGet (RedisModuleDict*,RedisModuleString*,int*)",redismodule.h,"void * (*RedisModule_DictGet)(RedisModuleDict *d, RedisModuleString *key, int *nokey) REDISMODULE_ATTR;",1164.0,1164.0,22.0,101.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void*
4125,316125,RedisModule_DictIteratorStart,1,RedisModule_DictIteratorStart,"RedisModuleDictIter* RedisModule_DictIteratorStart (RedisModuleDict*,char*,RedisModuleString*)",redismodule.h,"RedisModuleDictIter * (*RedisModule_DictIteratorStart)(RedisModuleDict *d, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",1168.0,1168.0,37.0,130.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,RedisModuleDictIter*
4126,316132,RedisModule_DictIteratorStop,1,RedisModule_DictIteratorStop,void RedisModule_DictIteratorStop (RedisModuleDictIter*),redismodule.h,void (*RedisModule_DictIteratorStop)(RedisModuleDictIter *di) REDISMODULE_ATTR;,1169.0,1169.0,22.0,77.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4127,316152,RedisModule_DictNextC,1,RedisModule_DictNextC,"void* RedisModule_DictNextC (RedisModuleDictIter*,size_t*,void**)",redismodule.h,"void * (*RedisModule_DictNextC)(RedisModuleDictIter *di, size_t *keylen, void **dataptr) REDISMODULE_ATTR;",1172.0,1172.0,22.0,104.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void*
4128,316188,RedisModule_DictCompare,1,RedisModule_DictCompare,"int RedisModule_DictCompare (RedisModuleDictIter*,char*,RedisModuleString*)",redismodule.h,"int (*RedisModule_DictCompare)(RedisModuleDictIter *di, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",1177.0,1177.0,21.0,111.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
4129,316336,RedisModule_BlockClientOnKeys,1,RedisModule_BlockClientOnKeys,"RedisModuleBlockedClient* RedisModule_BlockClientOnKeys (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,RedisModuleString**,int,void*)",redismodule.h,"RedisModuleBlockedClient * (*RedisModule_BlockClientOnKeys)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) REDISMODULE_ATTR;",1200.0,1200.0,42.0,291.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,16,8,8,RedisModuleBlockedClient*
4130,316361,RedisModule_SignalKeyAsReady,1,RedisModule_SignalKeyAsReady,"void RedisModule_SignalKeyAsReady (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"void (*RedisModule_SignalKeyAsReady)(RedisModuleCtx *ctx, RedisModuleString *key) REDISMODULE_ATTR;",1202.0,1202.0,22.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4131,316441,RedisModule_BlockClient,1,RedisModule_BlockClient,"RedisModuleBlockedClient* RedisModule_BlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long)",redismodule.h,"RedisModuleBlockedClient * (*RedisModule_BlockClient)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms) REDISMODULE_ATTR;",1216.0,1216.0,42.0,230.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,RedisModuleBlockedClient*
4132,316468,RedisModule_UnblockClient,1,RedisModule_UnblockClient,"int RedisModule_UnblockClient (RedisModuleBlockedClient*,void*)",redismodule.h,"int (*RedisModule_UnblockClient)(RedisModuleBlockedClient *bc, void *privdata) REDISMODULE_ATTR;",1220.0,1220.0,21.0,94.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,int
4133,316484,RedisModule_GetBlockedClientPrivateData,1,RedisModule_GetBlockedClientPrivateData,void* RedisModule_GetBlockedClientPrivateData (RedisModuleCtx*),redismodule.h,void * (*RedisModule_GetBlockedClientPrivateData)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1223.0,1223.0,22.0,86.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void*
4134,316494,RedisModule_AbortBlock,1,RedisModule_AbortBlock,int RedisModule_AbortBlock (RedisModuleBlockedClient*),redismodule.h,int (*RedisModule_AbortBlock)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,1225.0,1225.0,21.0,75.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
4135,316509,RedisModule_GetThreadSafeContext,1,RedisModule_GetThreadSafeContext,RedisModuleCtx* RedisModule_GetThreadSafeContext (RedisModuleBlockedClient*),redismodule.h,RedisModuleCtx * (*RedisModule_GetThreadSafeContext)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,1228.0,1228.0,32.0,98.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,RedisModuleCtx*
4136,316519,RedisModule_FreeThreadSafeContext,1,RedisModule_FreeThreadSafeContext,void RedisModule_FreeThreadSafeContext (RedisModuleCtx*),redismodule.h,void (*RedisModule_FreeThreadSafeContext)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1230.0,1230.0,22.0,78.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4137,316524,RedisModule_ThreadSafeContextLock,1,RedisModule_ThreadSafeContextLock,void RedisModule_ThreadSafeContextLock (RedisModuleCtx*),redismodule.h,void (*RedisModule_ThreadSafeContextLock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1231.0,1231.0,22.0,78.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4138,316534,RedisModule_ThreadSafeContextUnlock,1,RedisModule_ThreadSafeContextUnlock,void RedisModule_ThreadSafeContextUnlock (RedisModuleCtx*),redismodule.h,void (*RedisModule_ThreadSafeContextUnlock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1233.0,1233.0,22.0,80.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4139,316579,RedisModule_SendClusterMessage,1,RedisModule_SendClusterMessage,"int RedisModule_SendClusterMessage (RedisModuleCtx*,char*,uint8_t,char*,uint32_t)",redismodule.h,"int (*RedisModule_SendClusterMessage)(RedisModuleCtx *ctx, const char *target_id, uint8_t type, const char *msg, uint32_t len) REDISMODULE_ATTR;",1240.0,1240.0,21.0,142.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,int
4140,316588,RedisModule_GetClusterNodeInfo,1,RedisModule_GetClusterNodeInfo,"int RedisModule_GetClusterNodeInfo (RedisModuleCtx*,char*,char*,char*,int*,int*)",redismodule.h,"int (*RedisModule_GetClusterNodeInfo)(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) REDISMODULE_ATTR;",1241.0,1241.0,21.0,140.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
4141,316598,RedisModule_GetClusterNodesList,1,RedisModule_GetClusterNodesList,"char** RedisModule_GetClusterNodesList (RedisModuleCtx*,size_t*)",redismodule.h,"char ** (*RedisModule_GetClusterNodesList)(RedisModuleCtx *ctx, size_t *numnodes) REDISMODULE_ATTR;",1242.0,1242.0,22.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char**
4142,316604,RedisModule_FreeClusterNodesList,1,RedisModule_FreeClusterNodesList,void RedisModule_FreeClusterNodesList (char**),redismodule.h,void (*RedisModule_FreeClusterNodesList)(char **ids) REDISMODULE_ATTR;,1243.0,1243.0,22.0,68.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4143,316609,RedisModule_CreateTimer,1,RedisModule_CreateTimer,"RedisModuleTimerID RedisModule_CreateTimer (RedisModuleCtx*,mstime_t,RedisModuleTimerProc,void*)",redismodule.h,"RedisModuleTimerID (*RedisModule_CreateTimer)(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) REDISMODULE_ATTR;",1244.0,1244.0,36.0,142.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,RedisModuleTimerID
4144,316654,RedisModule_SetDisconnectCallback,1,RedisModule_SetDisconnectCallback,"void RedisModule_SetDisconnectCallback (RedisModuleBlockedClient*,RedisModuleDisconnectFunc)",redismodule.h,"void (*RedisModule_SetDisconnectCallback)(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) REDISMODULE_ATTR;",1251.0,1251.0,22.0,123.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4145,316774,RedisModule_CreateModuleUser,1,RedisModule_CreateModuleUser,RedisModuleUser* RedisModule_CreateModuleUser (char*),redismodule.h,RedisModuleUser * (*RedisModule_CreateModuleUser)(const char *name) REDISMODULE_ATTR;,1272.0,1272.0,33.0,83.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,RedisModuleUser*
4146,316779,RedisModule_FreeModuleUser,1,RedisModule_FreeModuleUser,void RedisModule_FreeModuleUser (RedisModuleUser*),redismodule.h,void (*RedisModule_FreeModuleUser)(RedisModuleUser *user) REDISMODULE_ATTR;,1273.0,1273.0,22.0,73.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4147,316790,RedisModule_SetModuleUserACL,1,RedisModule_SetModuleUserACL,"int RedisModule_SetModuleUserACL (RedisModuleUser*,char*)",redismodule.h,"int (*RedisModule_SetModuleUserACL)(RedisModuleUser *user, const char* acl) REDISMODULE_ATTR;",1275.0,1275.0,21.0,91.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,int
4148,316856,RedisModule_AuthenticateClientWithACLUser,1,RedisModule_AuthenticateClientWithACLUser,"int RedisModule_AuthenticateClientWithACLUser (RedisModuleCtx*,char*,size_t,RedisModuleUserChangedFunc,void*,uint64_t*)",redismodule.h,"int (*RedisModule_AuthenticateClientWithACLUser)(RedisModuleCtx *ctx, const char *name, size_t len, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) REDISMODULE_ATTR;",1285.0,1285.0,21.0,189.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
4149,316866,RedisModule_AuthenticateClientWithUser,1,RedisModule_AuthenticateClientWithUser,"int RedisModule_AuthenticateClientWithUser (RedisModuleCtx*,RedisModuleUser*,RedisModuleUserChangedFunc,void*,uint64_t*)",redismodule.h,"int (*RedisModule_AuthenticateClientWithUser)(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) REDISMODULE_ATTR;",1286.0,1286.0,21.0,179.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
4150,316875,RedisModule_DeauthenticateAndCloseClient,1,RedisModule_DeauthenticateAndCloseClient,"int RedisModule_DeauthenticateAndCloseClient (RedisModuleCtx*,uint64_t)",redismodule.h,"int (*RedisModule_DeauthenticateAndCloseClient)(RedisModuleCtx *ctx, uint64_t client_id) REDISMODULE_ATTR;",1287.0,1287.0,21.0,104.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4151,317062,RedisModule_Init,1,RedisModule_Init,"int RedisModule_Init (RedisModuleCtx*,char*,int,int)",redismodule.h,"static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
    void *getapifuncptr = ((void**)ctx)[0];
    RedisModule_GetApi = (int (*)(const char *, void *)) (unsigned long)getapifuncptr;
    REDISMODULE_GET_API(Alloc);
    REDISMODULE_GET_API(TryAlloc);
    REDISMODULE_GET_API(Calloc);
    REDISMODULE_GET_API(Free);
    REDISMODULE_GET_API(Realloc);
    REDISMODULE_GET_API(Strdup);
    REDISMODULE_GET_API(CreateCommand);
    REDISMODULE_GET_API(GetCommand);
    REDISMODULE_GET_API(CreateSubcommand);
    REDISMODULE_GET_API(SetCommandInfo);
    REDISMODULE_GET_API(SetCommandACLCategories);
    REDISMODULE_GET_API(SetModuleAttribs);
    REDISMODULE_GET_API(IsModuleNameBusy);
    REDISMODULE_GET_API(WrongArity);
    REDISMODULE_GET_API(ReplyWithLongLong);
    REDISMODULE_GET_API(ReplyWithError);
    REDISMODULE_GET_API(ReplyWithErrorFormat);
    REDISMODULE_GET_API(ReplyWithSimpleString);
    REDISMODULE_GET_API(ReplyWithArray);
    REDISMODULE_GET_API...",1318.0,1678.0,1.0,4.0,361.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
4152,319970,redisBuildId,1,redisBuildId,uint64_t redisBuildId (void),release.c,"uint64_t redisBuildId(void) {
    char *buildid = REDIS_BUILD_ID_RAW;

    return crc64(0,(unsigned char*)buildid,strlen(buildid));
}",52.0,56.0,1.0,1.0,5.0,2,2,4,2,2,1,1,1,0,1,,0,0,2,1,1,uint64_t
4153,319987,redisBuildIdString,1,redisBuildIdString,char* redisBuildIdString (void),release.c,"char *redisBuildIdString(void) {
    static char buf[32];
    static int cached = 0;
    if (!cached) {
        snprintf(buf,sizeof(buf),""%llx"",(unsigned long long) redisBuildId());
        cached = 1;
    }
    return buf;
}",61.0,69.0,1.0,1.0,9.0,5,4,6,2,1,1,2,2,0,1,,0,0,2,1,1,char*
4154,320043,replicationDiscardCachedMaster,1,replicationDiscardCachedMaster,void replicationDiscardCachedMaster (void),replication.c,"void replicationDiscardCachedMaster(void) {
    if (server.cached_master == NULL) return;

    serverLog(LL_NOTICE,""Discarding previously cached master state."");
    server.cached_master->flags &= ~CLIENT_MASTER;
    freeClient(server.cached_master);
    server.cached_master = NULL;
}",3377.0,3384.0,1.0,4.0,8.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
4155,320048,replicationResurrectCachedMaster,1,replicationResurrectCachedMaster,void replicationResurrectCachedMaster (connection*),replication.c,"void replicationResurrectCachedMaster(connection *conn) {
    server.master = server.cached_master;
    server.cached_master = NULL;
    server.master->conn = conn;
    connSetPrivateData(server.master->conn, server.master);
    server.master->flags &= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
    server.master->authenticated = 1;
    server.master->lastinteraction = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTED;
    server.repl_down_since = 0;

    /* Fire the master link modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                          REDISMODULE_SUBEVENT_MASTER_LINK_UP,
                          NULL);

    /* Re-add to the list of clients. */
    linkClient(server.master);
    if (connSetReadHandler(server.master->conn, readQueryFromClient)) {
        serverLog(LL_WARNING,""Error resurrecting the cached master, impossible to add the readable handler: %s"", strerror(errno));
        freeClientAsync(server.master); /* C...",3392.0,3423.0,1.0,30.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4156,320053,replicationSendAck,1,replicationSendAck,void replicationSendAck (void),replication.c,"void replicationSendAck(void) {
    client *c = server.master;

    if (c != NULL) {
        int send_fack = server.fsynced_reploff != -1;
        c->flags |= CLIENT_MASTER_FORCE_REPLY;
        addReplyArrayLen(c,send_fack ? 5 : 3);
        addReplyBulkCString(c,""REPLCONF"");
        addReplyBulkCString(c,""ACK"");
        addReplyBulkLongLong(c,c->reploff);
        if (send_fack) {
            addReplyBulkCString(c,""FACK"");
            addReplyBulkLongLong(c,server.fsynced_reploff);
        }
        c->flags &= ~CLIENT_MASTER_FORCE_REPLY;
    }
}",3260.0,3276.0,1.0,20.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
4157,320058,replicaPutOnline,1,replicaPutOnline,int replicaPutOnline (client*),replication.c,"int replicaPutOnline(client *slave) {
    if (slave->flags & CLIENT_REPL_RDBONLY) {
        slave->replstate = SLAVE_STATE_RDB_TRANSMITTED;
        /* The client asked for RDB only so we should close it ASAP */
        serverLog(LL_NOTICE,
                  ""RDB transfer completed, rdb only replica (%s) should be disconnected asap"",
                  replicationGetSlaveName(slave));
        return 0;
    }
    slave->replstate = SLAVE_STATE_ONLINE;
    slave->repl_ack_time = server.unixtime; /* Prevent false timeout. */

    refreshGoodSlavesCount();
    /* Fire the replica change modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,
                          REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,
                          NULL);
    serverLog(LL_NOTICE,""Synchronization with replica %s succeeded"",
        replicationGetSlaveName(slave));
    return 1;
}",1292.0,1312.0,1.0,23.0,21.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
4158,320063,replicaStartCommandStream,1,replicaStartCommandStream,void replicaStartCommandStream (client*),replication.c,"void replicaStartCommandStream(client *slave) {
    serverAssert(!(slave->flags & CLIENT_REPL_RDBONLY));
    slave->repl_start_cmd_stream_on_ack = 0;

    putClientInPendingWriteQueue(slave);
}",1325.0,1330.0,1.0,4.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4159,320068,cancelReplicationHandshake,1,cancelReplicationHandshake,int cancelReplicationHandshake (int),replication.c,"int cancelReplicationHandshake(int reconnect) {
    if (server.repl_state == REPL_STATE_TRANSFER) {
        replicationAbortSyncTransfer();
        server.repl_state = REPL_STATE_CONNECT;
    } else if (server.repl_state == REPL_STATE_CONNECTING ||
               slaveIsInHandshakeState())
    {
        undoConnectWithMaster();
        server.repl_state = REPL_STATE_CONNECT;
    } else {
        return 0;
    }

    if (!reconnect)
        return 1;

    /* try to re-connect without waiting for replicationCron, this is needed
     * for the ""diskless loading short read"" test. */
    serverLog(LL_NOTICE,""Reconnecting to MASTER %s:%d after failure"",
        server.masterhost, server.masterport);
    connectWithMaster();

    return 1;
}",2977.0,3000.0,1.0,4.0,24.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,int
4160,320077,connTypeOfReplication,1,connTypeOfReplication,ConnectionType connTypeOfReplication (void),replication.c,"static ConnectionType *connTypeOfReplication(void) {
    if (server.tls_replication) {
        return connectionTypeTls();
    }

    return connectionTypeTcp();
}",58.0,64.0,1.0,1.0,7.0,1,1,1,1,1,2,2,2,0,2,,0,0,2,1,1,ConnectionType
4161,320091,replicationGetSlaveName,1,replicationGetSlaveName,char* replicationGetSlaveName (client*),replication.c,"char *replicationGetSlaveName(client *c) {
    static char buf[NET_HOST_PORT_STR_LEN];
    char ip[NET_IP_STR_LEN];

    ip[0] = '\0';
    buf[0] = '\0';
    if (c->slave_addr ||
        connAddrPeerName(c->conn,ip,sizeof(ip),NULL) != -1)
    {
        char *addr = c->slave_addr ? c->slave_addr : ip;
        if (c->slave_listening_port)
            formatAddr(buf,sizeof(buf),addr,c->slave_listening_port);
        else
            snprintf(buf,sizeof(buf),""%s:<unknown-replica-port>"",addr);
    } else {
        snprintf(buf,sizeof(buf),""client id #%llu"",
            (unsigned long long) c->id);
    }
    return buf;
}",70.0,89.0,1.0,20.0,20.0,17,8,17,5,9,8,3,4,4,2,,0,7,2,1,1,char*
4162,320171,bg_unlink,1,bg_unlink,int bg_unlink (char*),replication.c,"int bg_unlink(const char *filename) {
    int fd = open(filename,O_RDONLY|O_NONBLOCK);
    if (fd == -1) {
        /* Can't open the file? Fall back to unlinking in the main thread. */
        return unlink(filename);
    } else {
        /* The following unlink() removes the name but doesn't free the
         * file contents because a process still has it open. */
        int retval = unlink(filename);
        if (retval == -1) {
            /* If we got an unlink error, we just return it, closing the
             * new reference we have to the file. */
            int old_errno = errno;
            close(fd);  /* This would overwrite our errno. So we saved it. */
            errno = old_errno;
            return -1;
        }
        bioCreateCloseJob(fd, 0, 0);
        return 0; /* Success. */
    }
}",97.0,117.0,1.0,1.0,21.0,4,4,6,4,9,0,2,2,0,0,,0,0,2,1,1,int
4163,320224,createReplicationBacklog,1,createReplicationBacklog,void createReplicationBacklog (void),replication.c,"void createReplicationBacklog(void) {
    serverAssert(server.repl_backlog == NULL);
    server.repl_backlog = zmalloc(sizeof(replBacklog));
    server.repl_backlog->ref_repl_buf_node = NULL;
    server.repl_backlog->unindexed_count = 0;
    server.repl_backlog->blocks_index = raxNew();
    server.repl_backlog->histlen = 0;
    /* We don't have any data inside our buffer, but virtually the first
     * byte we have is the next byte that will be generated for the
     * replication stream. */
    server.repl_backlog->offset = server.master_repl_offset+1;
}",121.0,132.0,1.0,4.0,12.0,26,10,11,3,3,3,1,1,0,3,,0,2,2,1,1,void
4164,320293,resizeReplicationBacklog,1,resizeReplicationBacklog,void resizeReplicationBacklog (void),replication.c,"void resizeReplicationBacklog(void) {
    if (server.repl_backlog_size < CONFIG_REPL_BACKLOG_MIN_SIZE)
        server.repl_backlog_size = CONFIG_REPL_BACKLOG_MIN_SIZE;
    if (server.repl_backlog)
        incrementalTrimReplicationBacklog(REPL_BACKLOG_TRIM_BLOCKS_PER_CALL);
}",139.0,144.0,1.0,35.0,6.0,7,4,3,1,1,1,3,3,0,1,,0,0,2,1,1,void
4165,320327,freeReplicationBacklog,1,freeReplicationBacklog,void freeReplicationBacklog (void),replication.c,"void freeReplicationBacklog(void) {
    serverAssert(listLength(server.slaves) == 0);
    if (server.repl_backlog == NULL) return;

    /* Decrease the start buffer node reference count. */
    if (server.repl_backlog->ref_repl_buf_node) {
        replBufBlock *o = listNodeValue(
            server.repl_backlog->ref_repl_buf_node);
        serverAssert(o->refcount == 1); /* Last reference. */
        o->refcount--;
    }

    /* Replication buffer blocks are completely released when we free the
     * backlog, since the backlog is released only when there are no replicas
     * and the backlog keeps the last reference of all blocks. */
    freeReplicationBacklogRefMemAsync(server.repl_buffer_blocks,
                            server.repl_backlog->blocks_index);
    resetReplicationBuffer();
    zfree(server.repl_backlog);
    server.repl_backlog = NULL;
}",146.0,166.0,1.0,4.0,21.0,31,9,14,3,3,7,3,3,0,5,,0,2,2,1,1,void
4166,320425,createReplicationBacklogIndex,1,createReplicationBacklogIndex,void createReplicationBacklogIndex (listNode*),replication.c,"void createReplicationBacklogIndex(listNode *ln) {
    server.repl_backlog->unindexed_count++;
    if (server.repl_backlog->unindexed_count >= REPL_BACKLOG_INDEX_PER_BLOCKS) {
        replBufBlock *o = listNodeValue(ln);
        uint64_t encoded_offset = htonu64(o->repl_offset);
        raxInsert(server.repl_backlog->blocks_index,
                  (unsigned char*)&encoded_offset, sizeof(uint64_t),
                  ln, NULL);
        server.repl_backlog->unindexed_count = 0;
    }
}",171.0,181.0,1.0,48.0,11.0,19,8,14,6,2,5,2,2,0,2,,0,4,2,1,1,void
4167,320489,rebaseReplicationBuffer,1,rebaseReplicationBuffer,void rebaseReplicationBuffer (long long),replication.c,"void rebaseReplicationBuffer(long long base_repl_offset) {
    raxFree(server.repl_backlog->blocks_index);
    server.repl_backlog->blocks_index = raxNew();
    server.repl_backlog->unindexed_count = 0;

    listIter li;
    listNode *ln;
    listRewind(server.repl_buffer_blocks, &li);
    while ((ln = listNext(&li))) {
        replBufBlock *o = listNodeValue(ln);
        o->repl_offset += base_repl_offset;
        createReplicationBacklogIndex(ln);
    }
}",185.0,198.0,1.0,26.0,14.0,16,5,13,5,0,7,2,2,1,5,,0,4,2,1,1,void
4168,320545,resetReplicationBuffer,1,resetReplicationBuffer,void resetReplicationBuffer (void),replication.c,"void resetReplicationBuffer(void) {
    server.repl_buffer_mem = 0;
    server.repl_buffer_blocks = listCreate();
    listSetFreeMethod(server.repl_buffer_blocks, (void (*)(void*))zfree);
}",200.0,204.0,1.0,4.0,5.0,9,4,5,2,2,1,1,1,0,1,,0,1,2,1,1,void
4169,320574,canFeedReplicaReplBuffer,1,canFeedReplicaReplBuffer,int canFeedReplicaReplBuffer (client*),replication.c,"int canFeedReplicaReplBuffer(client *replica) {
    /* Don't feed replicas that only want the RDB. */
    if (replica->flags & CLIENT_REPL_RDBONLY) return 0;

    /* Don't feed replicas that are still waiting for BGSAVE to start. */
    if (replica->replstate == SLAVE_STATE_WAIT_BGSAVE_START) return 0;

    return 1;
}",206.0,214.0,1.0,25.0,9.0,5,4,2,1,2,2,3,3,2,0,,0,2,2,1,1,int
4170,320605,prepareReplicasToWrite,1,prepareReplicasToWrite,int prepareReplicasToWrite (void),replication.c,"int prepareReplicasToWrite(void) {
    listIter li;
    listNode *ln;
    int prepared = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (!canFeedReplicaReplBuffer(slave)) continue;
        if (prepareClientToWrite(slave) == C_ERR) continue;
        prepared++;
    }

    return prepared;
}",220.0,234.0,1.0,43.0,15.0,11,8,11,5,2,5,6,6,3,4,,0,4,2,1,1,int
4171,320655,feedReplicationBufferWithObject,1,feedReplicationBufferWithObject,void feedReplicationBufferWithObject (robj*),replication.c,"void feedReplicationBufferWithObject(robj *o) {
    char llstr[LONG_STR_SIZE];
    void *p;
    size_t len;

    if (o->encoding == OBJ_ENCODING_INT) {
        len = ll2string(llstr,sizeof(llstr),(long)o->ptr);
        p = llstr;
    } else {
        len = sdslen(o->ptr);
        p = o->ptr;
    }
    feedReplicationBuffer(p,len);
}",238.0,251.0,1.0,15.0,14.0,7,5,9,4,2,2,2,2,0,2,,0,1,2,1,1,void
4172,320702,incrementalTrimReplicationBacklog,1,incrementalTrimReplicationBacklog,void incrementalTrimReplicationBacklog (size_t),replication.c,"void incrementalTrimReplicationBacklog(size_t max_blocks) {
    serverAssert(server.repl_backlog != NULL);

    size_t trimmed_blocks = 0;
    while (server.repl_backlog->histlen > server.repl_backlog_size &&
           trimmed_blocks < max_blocks)
    {
        /* We never trim backlog to less than one block. */
        if (listLength(server.repl_buffer_blocks) <= 1) break;

        /* Replicas increment the refcount of the first replication buffer block
         * they refer to, in that case, we don't trim the backlog even if
         * backlog_histlen exceeds backlog_size. This implicitly makes backlog
         * bigger than our setting, but makes the master accept partial resync as
         * much as possible. So that backlog must be the last reference of
         * replication buffer blocks. */
        listNode *first = listFirst(server.repl_buffer_blocks);
        serverAssert(first == server.repl_backlog->ref_repl_buf_node);
        replBufBlock *fo = listNodeValue(first);
  ...",258.0,311.0,1.0,4.0,54.0,96,20,53,11,5,20,8,8,2,7,,0,14,2,1,1,void
4173,320975,freeReplicaReferencedReplBuffer,1,freeReplicaReferencedReplBuffer,void freeReplicaReferencedReplBuffer (client*),replication.c,"void freeReplicaReferencedReplBuffer(client *replica) {
    if (replica->ref_repl_buf_node != NULL) {
        /* Decrease the start buffer node reference count. */
        replBufBlock *o = listNodeValue(replica->ref_repl_buf_node);
        serverAssert(o->refcount > 0);
        o->refcount--;
        incrementalTrimReplicationBacklog(REPL_BACKLOG_TRIM_BLOCKS_PER_CALL);
    }
    replica->ref_repl_buf_node = NULL;
    replica->ref_block_pos = 0;
}",314.0,324.0,1.0,26.0,11.0,18,9,10,3,1,9,2,2,1,2,,0,7,2,1,1,void
4174,321036,feedReplicationBuffer,1,feedReplicationBuffer,"void feedReplicationBuffer (char*,size_t)",replication.c,"void feedReplicationBuffer(char *s, size_t len) {
    static long long repl_block_id = 0;

    if (server.repl_backlog == NULL) return;

    while(len > 0) {
        size_t start_pos = 0; /* The position of referenced block to start sending. */
        listNode *start_node = NULL; /* Replica/backlog starts referenced node. */
        int add_new_block = 0; /* Create new block if current block is total used. */
        listNode *ln = listLast(server.repl_buffer_blocks);
        replBufBlock *tail = ln ? listNodeValue(ln) : NULL;

        /* Append to tail string when possible. */
        if (tail && tail->size > tail->used) {
            start_node = listLast(server.repl_buffer_blocks);
            start_pos = tail->used;
            /* Copy the part we can fit into the tail, and leave the rest for a
             * new node */
            size_t avail = tail->size - tail->used;
            size_t copy = (avail >= len) ? len : avail;
            memcpy(tail->buf + tail->used, s, copy)...",331.0,429.0,1.0,23.0,99.0,146,22,128,19,5,32,13,25,5,9,,0,26,4,2,2,void
4175,321483,replicationFeedSlaves,1,replicationFeedSlaves,"void replicationFeedSlaves (list*,int,robj**,int)",replication.c,"void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
    int j, len;
    char llstr[LONG_STR_SIZE];

    /* In case we propagate a command that doesn't touch keys (PING, REPLCONF) we
     * pass dbid=-1 that indicate there is no need to replicate `select` command. */
    serverAssert(dictid == -1 || (dictid >= 0 && dictid < server.dbnum));

    /* If the instance is not a top level master, return ASAP: we'll just proxy
     * the stream of data we receive from our master instead, in order to
     * propagate *identical* replication stream. In this way this slave can
     * advertise the same replication ID as the master (since it shares the
     * master replication history and has the same backlog and offsets). */
    if (server.masterhost != NULL) return;

    /* If there aren't slaves, and there is no backlog buffer to populate,
     * we can return ASAP. */
    if (server.repl_backlog == NULL && listLength(slaves) == 0) {
        /* We increment the repl...",437.0,518.0,1.0,15.0,82.0,79,20,60,12,3,14,7,9,1,12,,0,5,8,4,4,void
4176,321749,showLatestBacklog,1,showLatestBacklog,void showLatestBacklog (void),replication.c,"void showLatestBacklog(void) {
    if (server.repl_backlog == NULL) return;
    if (listLength(server.repl_buffer_blocks) == 0) return;

    size_t dumplen = 256;
    if (server.repl_backlog->histlen < (long long)dumplen)
        dumplen = server.repl_backlog->histlen;

    sds dump = sdsempty();
    listNode *node = listLast(server.repl_buffer_blocks);
    while(dumplen) {
        if (node == NULL) break;
        replBufBlock *o = listNodeValue(node);
        size_t thislen = o->used >= dumplen ? dumplen : o->used;
        sds head = sdscatrepr(sdsempty(), o->buf+o->used-thislen, thislen);
        sds tmp = sdscatsds(head, dump);
        sdsfree(dump);
        dump = tmp;
        dumplen -= thislen;
        node = listPrevNode(node);
    }

    /* Finally log such bytes: this is vital debugging info to
     * understand what happened. */
    serverLog(LL_NOTICE,""Latest backlog is: '%s'"", dump);
    sdsfree(dump);
}",524.0,550.0,1.0,8.0,27.0,40,12,43,9,1,13,7,7,0,7,,0,10,2,1,1,void
4177,321905,replicationFeedStreamFromMasterStream,1,replicationFeedStreamFromMasterStream,"void replicationFeedStreamFromMasterStream (char*,size_t)",replication.c,"void replicationFeedStreamFromMasterStream(char *buf, size_t buflen) {
    /* Debugging: this is handy to see the stream sent from master
     * to slaves. Disabled with if(0). */
    if (0) {
        printf(""%zu:"",buflen);
        for (size_t j = 0; j < buflen; j++) {
            printf(""%c"", isprint(buf[j]) ? buf[j] : '.');
        }
        printf(""\n"");
    }

    /* There must be replication backlog if having attached slaves. */
    if (listLength(server.slaves)) serverAssert(server.repl_backlog != NULL);
    if (server.repl_backlog) {
        /* Must install write handler for all replicas first before feeding
         * replication stream. */
        prepareReplicasToWrite();
        feedReplicationBuffer(buf,buflen);
    }
}",555.0,574.0,1.0,8.0,20.0,15,10,15,5,1,3,5,6,0,3,,0,0,4,2,2,void
4178,321981,replicationFeedMonitors,1,replicationFeedMonitors,"void replicationFeedMonitors (client*,list*,int,robj**,int)",replication.c,"void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
    /* Fast path to return if the monitors list is empty or the server is in loading. */
    if (monitors == NULL || listLength(monitors) == 0 || server.loading) return;
    listNode *ln;
    listIter li;
    int j;
    sds cmdrepr = sdsnew(""+"");
    robj *cmdobj;
    struct timeval tv;

    gettimeofday(&tv,NULL);
    cmdrepr = sdscatprintf(cmdrepr,""%ld.%06ld "",(long)tv.tv_sec,(long)tv.tv_usec);
    if (c->flags & CLIENT_SCRIPT) {
        cmdrepr = sdscatprintf(cmdrepr,""[%d lua] "",dictid);
    } else if (c->flags & CLIENT_UNIX_SOCKET) {
        cmdrepr = sdscatprintf(cmdrepr,""[%d unix:%s] "",dictid,server.unixsocket);
    } else {
        cmdrepr = sdscatprintf(cmdrepr,""[%d %s] "",dictid,getClientPeerId(c));
    }

    for (j = 0; j < argc; j++) {
        if (argv[j]->encoding == OBJ_ENCODING_INT) {
            cmdrepr = sdscatprintf(cmdrepr, ""\""%ld\"""", (long)argv[j]->ptr);
        } else {
 ...",576.0,615.0,1.0,28.0,40.0,36,13,42,14,4,14,7,9,3,11,,0,11,10,5,5,void
4179,322188,addReplyReplicationBacklog,1,addReplyReplicationBacklog,"long long addReplyReplicationBacklog (client*,long long)",replication.c,"long long addReplyReplicationBacklog(client *c, long long offset) {
    long long skip;

    serverLog(LL_DEBUG, ""[PSYNC] Replica request offset: %lld"", offset);

    if (server.repl_backlog->histlen == 0) {
        serverLog(LL_DEBUG, ""[PSYNC] Backlog history len is zero"");
        return 0;
    }

    serverLog(LL_DEBUG, ""[PSYNC] Backlog size: %lld"",
             server.repl_backlog_size);
    serverLog(LL_DEBUG, ""[PSYNC] First byte: %lld"",
             server.repl_backlog->offset);
    serverLog(LL_DEBUG, ""[PSYNC] History len: %lld"",
             server.repl_backlog->histlen);

    /* Compute the amount of bytes we need to discard. */
    skip = offset - server.repl_backlog->offset;
    serverLog(LL_DEBUG, ""[PSYNC] Skipping: %lld"", skip);

    /* Iterate recorded blocks, quickly search the approximate node. */
    listNode *node = NULL;
    if (raxSize(server.repl_backlog->blocks_index) > 0) {
        uint64_t encoded_offset = htonu64(offset);
        raxIterator ri;
        raxS...",619.0,684.0,1.0,4.0,66.0,77,18,58,10,1,26,7,8,4,16,,0,13,4,2,2,long long
4180,322527,getPsyncInitialOffset,1,getPsyncInitialOffset,long long getPsyncInitialOffset (void),replication.c,"long long getPsyncInitialOffset(void) {
    return server.master_repl_offset;
}",690.0,692.0,1.0,1.0,3.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,long long
4181,322536,replicationSetupSlaveForFullResync,1,replicationSetupSlaveForFullResync,"int replicationSetupSlaveForFullResync (client*,long long)",replication.c,"int replicationSetupSlaveForFullResync(client *slave, long long offset) {
    char buf[128];
    int buflen;

    slave->psync_initial_offset = offset;
    slave->replstate = SLAVE_STATE_WAIT_BGSAVE_END;
    /* We are going to accumulate the incremental changes for this
     * slave as well. Set slaveseldb to -1 in order to force to re-emit
     * a SELECT statement in the replication stream. */
    server.slaveseldb = -1;

    /* Don't send this reply to slaves that approached us with
     * the old SYNC command. */
    if (!(slave->flags & CLIENT_PRE_PSYNC)) {
        buflen = snprintf(buf,sizeof(buf),""+FULLRESYNC %s %lld\r\n"",
                          server.replid,offset);
        if (connWrite(slave->conn,buf,buflen) != buflen) {
            freeClientAsync(slave);
            return C_ERR;
        }
    }
    return C_OK;
}",710.0,732.0,1.0,23.0,23.0,17,9,15,5,3,6,3,4,3,2,,0,5,4,2,2,int
4182,322606,masterTryPartialResynchronization,1,masterTryPartialResynchronization,"int masterTryPartialResynchronization (client*,long long)",replication.c,"int masterTryPartialResynchronization(client *c, long long psync_offset) {
    long long psync_len;
    char *master_replid = c->argv[1]->ptr;
    char buf[128];
    int buflen;

    /* Is the replication ID of this master the same advertised by the wannabe
     * slave via PSYNC? If the replication ID changed this master has a
     * different replication history, and there is no way to continue.
     *
     * Note that there are two potentially valid replication IDs: the ID1
     * and the ID2. The ID2 however is only valid up to a specific offset. */
    if (strcasecmp(master_replid, server.replid) &&
        (strcasecmp(master_replid, server.replid2) ||
         psync_offset > server.second_replid_offset))
    {
        /* Replid ""?"" is used by slaves that want to force a full resync. */
        if (master_replid[0] != '?') {
            if (strcasecmp(master_replid, server.replid) &&
                strcasecmp(master_replid, server.replid2))
            {
                server...",739.0,835.0,1.0,16.0,97.0,64,15,55,8,1,20,10,12,3,13,,0,12,4,2,2,int
4183,322938,startBgsaveForReplication,1,startBgsaveForReplication,"int startBgsaveForReplication (int,int)",replication.c,"int startBgsaveForReplication(int mincapa, int req) {
    int retval;
    int socket_target = 0;
    listIter li;
    listNode *ln;

    /* We use a socket target if slave can handle the EOF marker and we're configured to do diskless syncs.
     * Note that in case we're creating a ""filtered"" RDB (functions-only, for example) we also force socket replication
     * to avoid overwriting the snapshot RDB file with filtered data. */
    socket_target = (server.repl_diskless_sync || req & SLAVE_REQ_RDB_MASK) && (mincapa & SLAVE_CAPA_EOF);
    /* `SYNC` should have failed with error if we don't support socket and require a filter, assert this here */
    serverAssert(socket_target || !(req & SLAVE_REQ_RDB_MASK));

    serverLog(LL_NOTICE,""Starting BGSAVE for SYNC with target: %s"",
        socket_target ? ""replicas sockets"" : ""disk"");

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);
    /* Only do rdbSave* when rsiptr is not NULL,
     * otherwise slave will miss rep...",855.0,933.0,1.0,56.0,79.0,66,19,49,12,1,22,12,21,5,13,,0,14,4,2,2,int
4184,323232,syncCommand,1,syncCommand,void syncCommand (client*),replication.c,"void syncCommand(client *c) {
    /* ignore SYNC if already slave or in monitor mode */
    if (c->flags & CLIENT_SLAVE) return;

    /* Check if this is a failover request to a replica with the same replid and
     * become a master if so. */
    if (c->argc > 3 && !strcasecmp(c->argv[0]->ptr,""psync"") && 
        !strcasecmp(c->argv[3]->ptr,""failover""))
    {
        serverLog(LL_NOTICE, ""Failover request received for replid %s."",
            (unsigned char *)c->argv[1]->ptr);
        if (!server.masterhost) {
            addReplyError(c, ""PSYNC FAILOVER can't be sent to a master."");
            return;
        }

        if (!strcasecmp(c->argv[1]->ptr,server.replid)) {
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,
                ""MASTER MODE enabled (failover request from '%s')"",client);
            sdsfree(client);
        } else {
            addReplyError(c, ""PSYNC FAILOVER replid must match ...",936.0,1128.0,1.0,19.0,193.0,130,18,77,10,0,54,20,29,22,29,,0,33,2,1,1,void
4185,323892,replconfCommand,1,replconfCommand,void replconfCommand (client*),replication.c,"void replconfCommand(client *c) {
    int j;

    if ((c->argc % 2) == 0) {
        /* Number of arguments must be odd to make sure that every
         * option has a corresponding value. */
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Process every option-value pair. */
    for (j = 1; j < c->argc; j+=2) {
        if (!strcasecmp(c->argv[j]->ptr,""listening-port"")) {
            long port;

            if ((getLongFromObjectOrReply(c,c->argv[j+1],
                    &port,NULL) != C_OK))
                return;
            c->slave_listening_port = port;
        } else if (!strcasecmp(c->argv[j]->ptr,""ip-address"")) {
            sds addr = c->argv[j+1]->ptr;
            if (sdslen(addr) < NET_HOST_STR_LEN) {
                if (c->slave_addr) sdsfree(c->slave_addr);
                c->slave_addr = sdsdup(addr);
            } else {
                addReplyErrorFormat(c,""REPLCONF ip-address provided by ""
                    ""replica instance is too ...",1165.0,1280.0,1.0,35.0,116.0,19,11,17,5,0,8,5,8,5,3,,0,6,2,1,1,void
4186,324567,removeRDBUsedToSyncReplicas,1,removeRDBUsedToSyncReplicas,void removeRDBUsedToSyncReplicas (void),replication.c,"void removeRDBUsedToSyncReplicas(void) {
    /* If the feature is disabled, return ASAP but also clear the
     * RDBGeneratedByReplication flag in case it was set. Otherwise if the
     * feature was enabled, but gets disabled later with CONFIG SET, the
     * flag may remain set to one: then next time the feature is re-enabled
     * via CONFIG SET we have it set even if no RDB was generated
     * because of replication recently. */
    if (!server.rdb_del_sync_files) {
        RDBGeneratedByReplication = 0;
        return;
    }

    if (allPersistenceDisabled() && RDBGeneratedByReplication) {
        client *slave;
        listNode *ln;
        listIter li;

        int delrdb = 1;
        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
                slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END ||
                slave->replstate == SLAVE_STATE_SEND_BULK...",1337.0,1377.0,1.0,36.0,41.0,29,12,20,7,1,12,8,13,6,5,,0,9,2,1,1,void
4187,324681,closeRepldbfd,1,closeRepldbfd,void closeRepldbfd (client*),replication.c,"void closeRepldbfd(client *myself) {
    listNode *ln;
    listIter li;
    int reclaim = 1;
    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (slave != myself && slave->replstate == SLAVE_STATE_SEND_BULK) {
            reclaim = 0;
            break;
        }
    }

    if (reclaim) {
        bioCreateCloseJob(myself->repldbfd, 0, 1);
    } else {
        close(myself->repldbfd);
    }
    myself->repldbfd = -1;
}",1381.0,1400.0,1.0,51.0,20.0,16,8,14,6,1,7,5,5,2,3,,0,5,2,1,1,void
4188,324749,sendBulkToSlave,1,sendBulkToSlave,void sendBulkToSlave (connection*),replication.c,"void sendBulkToSlave(connection *conn) {
    client *slave = connGetPrivateData(conn);
    char buf[PROTO_IOBUF_LEN];
    ssize_t nwritten, buflen;

    /* Before sending the RDB file, we send the preamble as configured by the
     * replication process. Currently the preamble is just the bulk count of
     * the file in the form ""$<length>\r\n"". */
    if (slave->replpreamble) {
        nwritten = connWrite(conn,slave->replpreamble,sdslen(slave->replpreamble));
        if (nwritten == -1) {
            serverLog(LL_WARNING,
                ""Write error sending RDB preamble to replica: %s"",
                connGetLastError(conn));
            freeClient(slave);
            return;
        }
        atomicIncr(server.stat_net_repl_output_bytes, nwritten);
        sdsrange(slave->replpreamble,nwritten,-1);
        if (sdslen(slave->replpreamble) == 0) {
            sdsfree(slave->replpreamble);
            slave->replpreamble = NULL;
            /* fall through sending data. */
      ...",1402.0,1458.0,1.0,13.0,57.0,44,13,51,10,0,35,9,13,8,21,,0,23,2,1,1,void
4189,324968,rdbPipeWriteHandlerConnRemoved,1,rdbPipeWriteHandlerConnRemoved,void rdbPipeWriteHandlerConnRemoved (connection*),replication.c,"void rdbPipeWriteHandlerConnRemoved(struct connection *conn) {
    if (!connHasWriteHandler(conn))
        return;
    connSetWriteHandler(conn, NULL);
    client *slave = connGetPrivateData(conn);
    slave->repl_last_partial_write = 0;
    server.rdb_pipe_numconns_writing--;
    /* if there are no more writes for now for this conn, or write error: */
    if (server.rdb_pipe_numconns_writing == 0) {
        if (aeCreateFileEvent(server.el, server.rdb_pipe_read, AE_READABLE, rdbPipeReadHandler,NULL) == AE_ERR) {
            serverPanic(""Unrecoverable error creating server.rdb_pipe_read file event."");
        }
    }
}",1462.0,1475.0,1.0,63.0,14.0,13,8,12,5,2,6,4,5,2,5,,0,4,2,1,1,void
4190,325030,rdbPipeWriteHandler,1,rdbPipeWriteHandler,void rdbPipeWriteHandler (connection*),replication.c,"void rdbPipeWriteHandler(struct connection *conn) {
    serverAssert(server.rdb_pipe_bufflen>0);
    client *slave = connGetPrivateData(conn);
    ssize_t nwritten;
    if ((nwritten = connWrite(conn, server.rdb_pipe_buff + slave->repldboff,
                              server.rdb_pipe_bufflen - slave->repldboff)) == -1)
    {
        if (connGetState(conn) == CONN_STATE_CONNECTED)
            return; /* equivalent to EAGAIN */
        serverLog(LL_WARNING,""Write error sending DB to replica: %s"",
            connGetLastError(conn));
        freeClient(slave);
        return;
    } else {
        slave->repldboff += nwritten;
        atomicIncr(server.stat_net_repl_output_bytes, nwritten);
        if (slave->repldboff < server.rdb_pipe_bufflen) {
            slave->repl_last_partial_write = server.unixtime;
            return; /* more data to write.. */
        }
    }
    rdbPipeWriteHandlerConnRemoved(conn);
}",1479.0,1501.0,1.0,4.0,23.0,20,14,15,5,0,10,3,4,4,8,,0,6,2,1,1,void
4191,325143,rdbPipeReadHandler,1,rdbPipeReadHandler,"void rdbPipeReadHandler (aeEventLoop*,int,void*,int)",replication.c,"void rdbPipeReadHandler(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask) {
    UNUSED(mask);
    UNUSED(clientData);
    UNUSED(eventLoop);
    int i;
    if (!server.rdb_pipe_buff)
        server.rdb_pipe_buff = zmalloc(PROTO_IOBUF_LEN);
    serverAssert(server.rdb_pipe_numconns_writing==0);

    while (1) {
        server.rdb_pipe_bufflen = read(fd, server.rdb_pipe_buff, PROTO_IOBUF_LEN);
        if (server.rdb_pipe_bufflen < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
                return;
            serverLog(LL_WARNING,""Diskless rdb transfer, read error sending DB to replicas: %s"", strerror(errno));
            for (i=0; i < server.rdb_pipe_numconns; i++) {
                connection *conn = server.rdb_pipe_conns[i];
                if (!conn)
                    continue;
                client *slave = connGetPrivateData(conn);
                freeClient(slave);
                server.rdb_pipe_conns[i] = NULL;
            }
            k...",1504.0,1596.0,1.0,4.0,93.0,97,17,84,16,0,20,22,43,2,18,,0,8,8,4,4,void
4192,325550,updateSlavesWaitingBgsave,1,updateSlavesWaitingBgsave,"void updateSlavesWaitingBgsave (int,int)",replication.c,"void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
    listNode *ln;
    listIter li;

    /* Note: there's a chance we got here from within the REPLCONF ACK command
     * so we must avoid using freeClient, otherwise we'll crash on our way up. */

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
            struct redis_stat buf;

            if (bgsaveerr != C_OK) {
                freeClientAsync(slave);
                serverLog(LL_WARNING,""SYNC failed. BGSAVE child returned an error"");
                continue;
            }

            /* If this was an RDB on disk save, we have to prepare to send
             * the RDB from disk to the slave socket. Otherwise if this was
             * already an RDB -> Slaves socket transfer, used in the case of
             * diskless replication, our work is trivial, we can just put
             * the slave online....",1604.0,1684.0,1.0,32.0,81.0,19,9,16,6,1,11,8,14,3,8,,0,6,4,2,2,void
4193,325757,changeReplicationId,1,changeReplicationId,void changeReplicationId (void),replication.c,"void changeReplicationId(void) {
    getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
    server.replid[CONFIG_RUN_ID_SIZE] = '\0';
}",1690.0,1693.0,1.0,36.0,4.0,4,3,2,1,4,1,1,1,0,1,,0,0,2,1,1,void
4194,325778,clearReplicationId2,1,clearReplicationId2,void clearReplicationId2 (void),replication.c,"void clearReplicationId2(void) {
    memset(server.replid2,'0',sizeof(server.replid));
    server.replid2[CONFIG_RUN_ID_SIZE] = '\0';
    server.second_replid_offset = -1;
}",1698.0,1702.0,1.0,19.0,5.0,9,5,4,1,4,0,1,1,0,0,,0,0,2,1,1,void
4195,325807,shiftReplicationId,1,shiftReplicationId,void shiftReplicationId (void),replication.c,"void shiftReplicationId(void) {
    memcpy(server.replid2,server.replid,sizeof(server.replid));
    /* We set the second replid offset to the master offset + 1, since
     * the slave will ask for the first byte it has not yet received, so
     * we need to add one to the offset: for example if, as a slave, we are
     * sure we have the same history as the master for 50 bytes, after we
     * are turned into a master, we can accept a PSYNC request with offset
     * 51, since the slave asking has the same history up to the 50th
     * byte, and is asking for the new bytes starting at offset 51. */
    server.second_replid_offset = server.master_repl_offset+1;
    changeReplicationId();
    serverLog(LL_NOTICE,""Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s"", server.replid2, server.second_replid_offset, server.replid);
}",1709.0,1721.0,1.0,4.0,13.0,14,6,9,1,1,2,1,1,0,2,,0,0,2,1,1,void
4196,325860,slaveIsInHandshakeState,1,slaveIsInHandshakeState,int slaveIsInHandshakeState (void),replication.c,"int slaveIsInHandshakeState(void) {
    return server.repl_state >= REPL_STATE_RECEIVE_PING_REPLY &&
           server.repl_state <= REPL_STATE_RECEIVE_PSYNC_REPLY;
}",1727.0,1730.0,1.0,1.0,4.0,5,4,4,3,1,0,1,1,0,0,,0,0,2,1,1,int
4197,325877,replicationSendNewlineToMaster,1,replicationSendNewlineToMaster,void replicationSendNewlineToMaster (void),replication.c,"void replicationSendNewlineToMaster(void) {
    static time_t newline_sent;
    if (time(NULL) != newline_sent) {
        newline_sent = time(NULL);
        /* Pinging back in this stage is best-effort. */
        if (server.repl_transfer_s) connWrite(server.repl_transfer_s, ""\n"", 1);
    }
}",1740.0,1747.0,1.0,1.0,8.0,4,3,6,3,2,1,3,4,0,1,,0,0,2,1,1,void
4198,325904,replicationEmptyDbCallback,1,replicationEmptyDbCallback,void replicationEmptyDbCallback (dict*),replication.c,"void replicationEmptyDbCallback(dict *d) {
    UNUSED(d);
    if (server.repl_state == REPL_STATE_TRANSFER)
        replicationSendNewlineToMaster();
}",1752.0,1756.0,1.0,4.0,5.0,3,3,4,3,0,1,2,2,0,1,,0,0,2,1,1,void
4199,325923,replicationCreateMasterClient,1,replicationCreateMasterClient,"void replicationCreateMasterClient (connection*,int)",replication.c,"void replicationCreateMasterClient(connection *conn, int dbid) {
    server.master = createClient(conn);
    if (conn)
        connSetReadHandler(server.master->conn, readQueryFromClient);

    /**
     * Important note:
     * The CLIENT_DENY_BLOCKING flag is not, and should not, be set here.
     * For commands like BLPOP, it makes no sense to block the master
     * connection, and such blocking attempt will probably cause deadlock and
     * break the replication. We consider such a thing as a bug because
     * commands as BLPOP should never be sent on the replication link.
     * A possible use-case for blocking the replication link is if a module wants
     * to pass the execution to a background thread and unblock after the
     * execution is done. This is the reason why we allow blocking the replication
     * connection. */
    server.master->flags |= CLIENT_MASTER;

    server.master->authenticated = 1;
    server.master->reploff = server.master_initial_offset;
    serve...",1761.0,1790.0,1.0,28.0,30.0,37,8,21,5,2,3,4,4,0,3,,0,1,4,2,2,void
4200,326035,restartAOFAfterSYNC,1,restartAOFAfterSYNC,void restartAOFAfterSYNC (void),replication.c,"void restartAOFAfterSYNC(void) {
    unsigned int tries, max_tries = 10;
    for (tries = 0; tries < max_tries; ++tries) {
        if (startAppendOnly() == C_OK) break;
        serverLog(LL_WARNING,
            ""Failed enabling the AOF after successful master synchronization! ""
            ""Trying it again in one second."");
        sleep(1);
    }
    if (tries == max_tries) {
        serverLog(LL_WARNING,
            ""FATAL: this replica instance finished the synchronization with ""
            ""its master, but the AOF can't be turned on. Exiting now."");
        exit(1);
    }
}",1796.0,1811.0,1.0,33.0,16.0,11,5,8,3,3,3,5,5,1,3,,0,1,2,1,1,void
4201,326109,useDisklessLoad,1,useDisklessLoad,int useDisklessLoad (void),replication.c,"static int useDisklessLoad(void) {
    /* compute boolean decision to use diskless load */
    int enabled = server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB ||
           (server.repl_diskless_load == REPL_DISKLESS_LOAD_WHEN_DB_EMPTY && dbTotalServerKeyCount()==0);

    if (enabled) {
        /* Check all modules handle read errors, otherwise it's not safe to use diskless load. */
        if (!moduleAllDatatypesHandleErrors()) {
            serverLog(LL_NOTICE,
                ""Skipping diskless-load because there are modules that don't handle read errors."");
            enabled = 0;
        }
        /* Check all modules handle async replication, otherwise it's not safe to use diskless load. */
        else if (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB && !moduleAllModulesHandleReplAsyncLoad()) {
            serverLog(LL_NOTICE,
                ""Skipping diskless-load because there are modules that are not aware of async replication."");
            enabled = 0;
...",1813.0,1833.0,1.0,47.0,21.0,13,8,7,2,2,3,3,4,1,3,,0,2,2,1,1,int
4202,326201,disklessLoadInitTempDb,1,disklessLoadInitTempDb,redisDb disklessLoadInitTempDb (void),replication.c,"redisDb *disklessLoadInitTempDb(void) {
    return initTempDb();
}",1838.0,1840.0,1.0,1.0,3.0,0,0,0,0,1,1,1,1,0,1,,0,0,2,1,1,redisDb
4203,326208,disklessLoadDiscardTempDb,1,disklessLoadDiscardTempDb,void disklessLoadDiscardTempDb (redisDb*),replication.c,"void disklessLoadDiscardTempDb(redisDb *tempDb) {
    discardTempDb(tempDb, replicationEmptyDbCallback);
}",1844.0,1846.0,1.0,1.0,3.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void
4204,326216,replicationAttachToNewMaster,1,replicationAttachToNewMaster,void replicationAttachToNewMaster (void),replication.c,"void replicationAttachToNewMaster(void) { 
    /* Replica starts to apply data from new master, we must discard the cached
     * master structure. */
    serverAssert(server.master == NULL);
    replicationDiscardCachedMaster();

    disconnectSlaves(); /* Force our replicas to resync with us as well. */
    freeReplicationBacklog(); /* Don't allow our chained replicas to PSYNC. */
}",1852.0,1860.0,1.0,4.0,9.0,6,6,2,2,1,4,1,1,0,4,,0,0,2,1,1,void
4205,326242,readSyncBulkPayload,1,readSyncBulkPayload,void readSyncBulkPayload (connection*),replication.c,"void readSyncBulkPayload(connection *conn) {
    char buf[PROTO_IOBUF_LEN];
    ssize_t nread, readlen, nwritten;
    int use_diskless_load = useDisklessLoad();
    redisDb *diskless_load_tempDb = NULL;
    functionsLibCtx* temp_functions_lib_ctx = NULL;
    int empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC :
                                                        EMPTYDB_NO_FLAGS;
    off_t left;

    /* Static vars used to hold the EOF mark, and the last bytes received
     * from the server: when they match, we reached the end of the transfer. */
    static char eofmark[CONFIG_RUN_ID_SIZE];
    static char lastbytes[CONFIG_RUN_ID_SIZE];
    static int usemark = 0;

    /* If repl_transfer_size == -1 we still have to read the bulk length
     * from the master reply. */
    if (server.repl_transfer_size == -1) {
        nread = connSyncReadLine(conn,buf,1024,server.repl_syncio_timeout*1000);
        if (nread == -1) {
            serverLog(LL_WARNING,
             ...",1864.0,2296.0,1.0,13.0,433.0,191,24,165,26,0,55,38,64,2,54,,0,10,2,1,1,void
4206,327613,receiveSynchronousResponse,1,receiveSynchronousResponse,char* receiveSynchronousResponse (connection*),replication.c,"char *receiveSynchronousResponse(connection *conn) {
    char buf[256];
    /* Read the reply from the server. */
    if (connSyncReadLine(conn,buf,sizeof(buf),server.repl_syncio_timeout*1000) == -1)
    {
        serverLog(LL_WARNING, ""Failed to read response from the server: %s"", connGetLastError(conn));
        return NULL;
    }
    server.repl_transfer_lastio = server.unixtime;
    return sdsnew(buf);
}",2298.0,2308.0,1.0,8.0,11.0,11,8,10,4,6,4,2,2,1,4,,0,2,2,1,1,char*
4207,327666,sendCommandRaw,1,sendCommandRaw,"char* sendCommandRaw (connection*,sds)",replication.c,"char* sendCommandRaw(connection *conn, sds cmd) {
    if (connSyncWrite(conn,cmd,sdslen(cmd),server.repl_syncio_timeout*1000) == -1) {
        return sdscatprintf(sdsempty(),""-Writing to master: %s"",
                connGetLastError(conn));
    }
    return NULL;
}",2311.0,2317.0,1.0,1.0,7.0,4,4,6,4,2,5,2,2,2,5,,0,4,4,2,2,char*
4208,327695,sendCommand,1,sendCommand,char* sendCommand (connection*...),replication.c,"char *sendCommand(connection *conn, ...) {
    va_list ap;
    sds cmd = sdsempty();
    sds cmdargs = sdsempty();
    size_t argslen = 0;
    char *arg;

    /* Create the command to send to the master, we use redis binary
     * protocol to make sure correct arguments are sent. This function
     * is not safe for all binary data. */
    va_start(ap,conn);
    while(1) {
        arg = va_arg(ap, char*);
        if (arg == NULL) break;
        cmdargs = sdscatprintf(cmdargs,""$%zu\r\n%s\r\n"",strlen(arg),arg);
        argslen++;
    }

    cmd = sdscatprintf(cmd,""*%zu\r\n"",argslen);
    cmd = sdscatsds(cmd,cmdargs);
    sdsfree(cmdargs);

    va_end(ap);
    char* err = sendCommandRaw(conn, cmd);
    sdsfree(cmd);
    if(err)
        return err;
    return NULL;
}",2328.0,2356.0,1.0,1.0,29.0,9,3,27,8,5,8,5,5,0,8,,0,6,2,1,1,char*
4209,327767,sendCommandArgv,1,sendCommandArgv,"char* sendCommandArgv (connection*,int,char**,size_t*)",replication.c,"char *sendCommandArgv(connection *conn, int argc, char **argv, size_t *argv_lens) {
    sds cmd = sdsempty();
    char *arg;
    int i;

    /* Create the command to send to the master. */
    cmd = sdscatfmt(cmd,""*%i\r\n"",argc);
    for (i=0; i<argc; i++) {
        int len;
        arg = argv[i];
        len = argv_lens ? argv_lens[i] : strlen(arg);
        cmd = sdscatfmt(cmd,""$%i\r\n"",len);
        cmd = sdscatlen(cmd,arg,len);
        cmd = sdscatlen(cmd,""\r\n"",2);
    }
    char* err = sendCommandRaw(conn, cmd);
    sdsfree(cmd);
    if (err)
        return err;
    return NULL;
}",2367.0,2387.0,1.0,1.0,21.0,13,4,31,10,1,7,3,3,0,7,,0,6,8,4,4,char*
4210,327846,slaveTryPartialResynchronization,1,slaveTryPartialResynchronization,"int slaveTryPartialResynchronization (connection*,int)",replication.c,"int slaveTryPartialResynchronization(connection *conn, int read_reply) {
    char *psync_replid;
    char psync_offset[32];
    sds reply;

    /* Writing half */
    if (!read_reply) {
        /* Initially set master_initial_offset to -1 to mark the current
         * master replid and offset as not valid. Later if we'll be able to do
         * a FULL resync using the PSYNC command we'll set the offset at the
         * right value, so that this information will be propagated to the
         * client structure representing the master into server.master. */
        server.master_initial_offset = -1;

        if (server.cached_master) {
            psync_replid = server.cached_master->replid;
            snprintf(psync_offset,sizeof(psync_offset),""%lld"", server.cached_master->reploff+1);
            serverLog(LL_NOTICE,""Trying a partial resynchronization (request %s:%s)."", psync_replid, psync_offset);
        } else {
            serverLog(LL_NOTICE,""Partial resynchronization not po...",2443.0,2610.0,1.0,12.0,168.0,99,16,98,13,2,23,18,30,1,23,,0,3,4,2,2,int
4211,328444,syncWithMaster,1,syncWithMaster,void syncWithMaster (connection*),replication.c,"void syncWithMaster(connection *conn) {
    char tmpfile[256], *err = NULL;
    int dfd = -1, maxtries = 5;
    int psync_result;

    /* If this event fired after the user turned the instance into a master
     * with SLAVEOF NO ONE we must just return ASAP. */
    if (server.repl_state == REPL_STATE_NONE) {
        connClose(conn);
        return;
    }

    /* Check for errors in the socket: after a non blocking connect() we
     * may find that the socket is in error state. */
    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_WARNING,""Error condition on socket for SYNC: %s"",
                connGetLastError(conn));
        goto error;
    }

    /* Send a PING to check the master is able to reply without errors. */
    if (server.repl_state == REPL_STATE_CONNECTING) {
        serverLog(LL_NOTICE,""Non blocking connect for SYNC fired the event."");
        /* Delete the writable event so that the readable event remains
         * registered and we can wait ...",2614.0,2925.0,1.0,8.0,312.0,228,18,230,32,0,55,71,80,5,55,,0,23,2,1,1,void
4212,329505,connectWithMaster,1,connectWithMaster,int connectWithMaster (void),replication.c,"int connectWithMaster(void) {
    server.repl_transfer_s = connCreate(connTypeOfReplication());
    if (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,
                server.bind_source_addr, syncWithMaster) == C_ERR) {
        serverLog(LL_WARNING,""Unable to connect to MASTER: %s"",
                connGetLastError(server.repl_transfer_s));
        connClose(server.repl_transfer_s);
        server.repl_transfer_s = NULL;
        return C_ERR;
    }


    server.repl_transfer_lastio = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTING;
    serverLog(LL_NOTICE,""MASTER <-> REPLICA sync started"");
    return C_OK;
}",2927.0,2943.0,1.0,60.0,17.0,24,6,15,3,3,7,2,2,1,7,,0,4,2,1,1,int
4213,329607,undoConnectWithMaster,1,undoConnectWithMaster,void undoConnectWithMaster (void),replication.c,"void undoConnectWithMaster(void) {
    connClose(server.repl_transfer_s);
    server.repl_transfer_s = NULL;
}",2949.0,2952.0,1.0,1.0,4.0,3,2,3,2,1,1,1,1,0,1,,0,0,2,1,1,void
4214,329621,replicationAbortSyncTransfer,1,replicationAbortSyncTransfer,void replicationAbortSyncTransfer (void),replication.c,"void replicationAbortSyncTransfer(void) {
    serverAssert(server.repl_state == REPL_STATE_TRANSFER);
    undoConnectWithMaster();
    if (server.repl_transfer_fd!=-1) {
        close(server.repl_transfer_fd);
        bg_unlink(server.repl_transfer_tmpfile);
        zfree(server.repl_transfer_tmpfile);
        server.repl_transfer_tmpfile = NULL;
        server.repl_transfer_fd = -1;
    }
}",2957.0,2967.0,1.0,4.0,11.0,17,9,9,3,0,4,2,2,0,4,,0,0,2,1,1,void
4215,329748,replicationSetMaster,1,replicationSetMaster,"void replicationSetMaster (char*,int)",replication.c,"void replicationSetMaster(char *ip, int port) {
    int was_master = server.masterhost == NULL;

    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (server.master) {
        freeClient(server.master);
    }
    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */

    /* Setting masterhost only after the call to freeClient since it calls
     * replicationHandleMasterDisconnection which can trigger a re-connect
     * directly from within that call. */
    server.masterhost = sdsnew(ip);
    server.masterport = port;

    /* Update oom_score_adj */
    setOOMScoreAdj(-1);

    /* Here we don't disconnect with replicas, since they may hopefully be able
     * to partially resync with us. We will disconnect with replicas and force
     * them to resync with us when changing replid on partially resync with new
     * master, or finishing transferring RDB and preparing loading DB on full
     * sync with new master. */

    cancelReplicationHandsh...",3003.0,3051.0,1.0,26.0,49.0,22,6,22,7,4,12,4,4,0,12,,0,1,4,2,2,void
4216,329855,replicationUnsetMaster,1,replicationUnsetMaster,void replicationUnsetMaster (void),replication.c,"void replicationUnsetMaster(void) {
    if (server.masterhost == NULL) return; /* Nothing to do. */

    /* Fire the master link modules event. */
    if (server.repl_state == REPL_STATE_CONNECTED)
        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,
                              NULL);

    /* Clear masterhost first, since the freeClient calls
     * replicationHandleMasterDisconnection which can attempt to re-connect. */
    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (server.master) freeClient(server.master);
    replicationDiscardCachedMaster();
    cancelReplicationHandshake(0);
    /* When a slave is turned into a master, the current replication ID
     * (that was inherited from the master at synchronization time) is
     * used as secondary ID up to the current offset, and a new replication
     * ID is created to continue with a new replication history. */
    shiftRepli...",3054.0,3108.0,1.0,30.0,55.0,24,5,19,4,5,10,5,5,0,10,,0,0,2,1,1,void
4217,329954,replicationHandleMasterDisconnection,1,replicationHandleMasterDisconnection,void replicationHandleMasterDisconnection (void),replication.c,"void replicationHandleMasterDisconnection(void) {
    /* Fire the master link modules event. */
    if (server.repl_state == REPL_STATE_CONNECTED)
        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,
                              NULL);

    server.master = NULL;
    server.repl_state = REPL_STATE_CONNECT;
    server.repl_down_since = server.unixtime;
    /* We lost connection with our master, don't disconnect slaves yet,
     * maybe we'll be able to PSYNC with our master later. We'll disconnect
     * the slaves only if we'll have to do a full resync with our master. */

    /* Try to re-connect immediately rather than wait for replicationCron
     * waiting 1 second may risk backlog being recycled. */
    if (server.masterhost) {
        serverLog(LL_NOTICE,""Reconnecting to MASTER %s:%d"",
            server.masterhost, server.masterport);
        connectWithMaster();
    }
}",3112.0,3133.0,1.0,30.0,22.0,15,5,13,4,2,3,3,3,0,3,,0,0,2,1,1,void
4218,330021,replicaofCommand,1,replicaofCommand,void replicaofCommand (client*),replication.c,"void replicaofCommand(client *c) {
    /* SLAVEOF is not allowed in cluster mode as replication is automatically
     * configured using the current address of the master node. */
    if (server.cluster_enabled) {
        addReplyError(c,""REPLICAOF not allowed in cluster mode."");
        return;
    }

    if (server.failover_state != NO_FAILOVER) {
        addReplyError(c,""REPLICAOF not allowed while failing over."");
        return;
    }

    /* The special host/port combination ""NO"" ""ONE"" turns the instance
     * into a master. Otherwise the new master address is set. */
    if (!strcasecmp(c->argv[1]->ptr,""no"") &&
        !strcasecmp(c->argv[2]->ptr,""one"")) {
        if (server.masterhost) {
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,""MASTER MODE enabled (user request from '%s')"",
                client);
            sdsfree(client);
        }
    } else {
        long port;

        if (c->f...",3135.0,3194.0,1.0,12.0,60.0,18,9,15,5,0,10,5,6,2,8,,0,4,2,1,1,void
4219,330233,roleCommand,1,roleCommand,void roleCommand (client*),replication.c,"void roleCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelRoleCommand(c);
        return;
    }

    if (server.masterhost == NULL) {
        listIter li;
        listNode *ln;
        void *mbcount;
        int slaves = 0;

        addReplyArrayLen(c,3);
        addReplyBulkCBuffer(c,""master"",6);
        addReplyLongLong(c,server.master_repl_offset);
        mbcount = addReplyDeferredLen(c);
        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;
            char ip[NET_IP_STR_LEN], *slaveaddr = slave->slave_addr;

            if (!slaveaddr) {
                if (connAddrPeerName(slave->conn,ip,sizeof(ip),NULL) == -1)
                    continue;
                slaveaddr = ip;
            }
            if (slave->replstate != SLAVE_STATE_ONLINE) continue;
            addReplyArrayLen(c,3);
            addReplyBulkCString(c,slaveaddr);
            addReplyBulkLongLong(c,slave->slave_listening_port);
 ...",3199.0,3255.0,1.0,20.0,57.0,25,10,38,10,0,19,9,15,4,13,,0,9,2,1,1,void
4220,330514,replicationCacheMaster,1,replicationCacheMaster,void replicationCacheMaster (client*),replication.c,"void replicationCacheMaster(client *c) {
    serverAssert(server.master != NULL && server.cached_master == NULL);
    serverLog(LL_NOTICE,""Caching the disconnected master state."");

    /* Unlink the client from the server structures. */
    unlinkClient(c);

    /* Reset the master client so that's ready to accept new commands:
     * we want to discard the non processed query buffers and non processed
     * offsets, including pending transactions, already populated arguments,
     * pending outputs to the master. */
    sdsclear(server.master->querybuf);
    server.master->qb_pos = 0;
    server.master->repl_applied = 0;
    server.master->read_reploff = server.master->reploff;
    if (c->flags & CLIENT_MULTI) discardTransaction(c);
    listEmpty(c->reply);
    c->sentlen = 0;
    c->reply_bytes = 0;
    c->bufpos = 0;
    resetClient(c);

    /* Save the master. Server.master will be set to null later by
     * replicationHandleMasterDisconnection(). */
    server.cached_master ...",3298.0,3339.0,1.0,4.0,42.0,46,13,28,3,1,21,4,4,3,10,,0,11,2,1,1,void
4221,330664,replicationCacheMasterUsingMyself,1,replicationCacheMasterUsingMyself,void replicationCacheMasterUsingMyself (void),replication.c,"void replicationCacheMasterUsingMyself(void) {
    serverLog(LL_NOTICE,
        ""Before turning into a replica, using my own master parameters ""
        ""to synthesize a cached master: I may be able to synchronize with ""
        ""the new master with just a partial transfer."");

    /* This will be used to populate the field server.master->reploff
     * by replicationCreateMasterClient(). We'll later set the created
     * master as server.cached_master, so the replica will use such
     * offset for PSYNC. */
    server.master_initial_offset = server.master_repl_offset;

    /* The master client we create can be set to any DBID, because
     * the new master will start its replication stream with SELECT. */
    replicationCreateMasterClient(NULL,-1);

    /* Use our own ID / offset. */
    memcpy(server.master->replid, server.replid, sizeof(server.replid));

    /* Set as cached master. */
    unlinkClient(server.master);
    server.cached_master = server.master;
    server.master ...",3350.0,3373.0,1.0,4.0,24.0,18,7,12,2,1,3,1,1,0,3,,0,0,2,1,1,void
4222,330940,refreshGoodSlavesCount,1,refreshGoodSlavesCount,void refreshGoodSlavesCount (void),replication.c,"void refreshGoodSlavesCount(void) {
    listIter li;
    listNode *ln;
    int good = 0;

    if (!server.repl_min_slaves_to_write ||
        !server.repl_min_slaves_max_lag) return;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        time_t lag = server.unixtime - slave->repl_ack_time;

        if (slave->replstate == SLAVE_STATE_ONLINE &&
            lag <= server.repl_min_slaves_max_lag) good++;
    }
    server.repl_good_slaves_count = good;
}",3430.0,3447.0,1.0,32.0,18.0,24,11,18,6,4,5,4,5,2,2,,0,4,2,1,1,void
4223,331014,checkGoodReplicasStatus,1,checkGoodReplicasStatus,int checkGoodReplicasStatus (void),replication.c,"int checkGoodReplicasStatus(void) {
    return server.masterhost || /* not a primary status should be OK */
           !server.repl_min_slaves_max_lag || /* Min slave max lag not configured */
           !server.repl_min_slaves_to_write || /* Min slave to write not configured */
           server.repl_good_slaves_count >= server.repl_min_slaves_to_write; /* check if we have enough slaves */
}",3450.0,3455.0,1.0,1.0,6.0,11,4,5,1,4,0,1,1,0,0,,0,0,2,1,1,int
4224,331041,replicationRequestAckFromSlaves,1,replicationRequestAckFromSlaves,void replicationRequestAckFromSlaves (void),replication.c,"void replicationRequestAckFromSlaves(void) {
    server.get_ack_from_slaves = 1;
}",3487.0,3489.0,1.0,1.0,3.0,2,2,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
4225,331051,replicationCountAcksByOffset,1,replicationCountAcksByOffset,int replicationCountAcksByOffset (long long),replication.c,"int replicationCountAcksByOffset(long long offset) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
        if (slave->repl_ack_off >= offset) count++;
    }
    return count;
}",3493.0,3506.0,1.0,32.0,14.0,12,7,12,6,1,5,5,6,3,2,,0,4,2,1,1,int
4226,331102,replicationCountAOFAcksByOffset,1,replicationCountAOFAcksByOffset,int replicationCountAOFAcksByOffset (long long),replication.c,"int replicationCountAOFAcksByOffset(long long offset) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
        if (slave->repl_aof_off >= offset) count++;
    }
    return count;
}",3510.0,3523.0,1.0,32.0,14.0,12,7,12,6,1,5,5,6,3,2,,0,4,2,1,1,int
4227,331153,waitCommand,1,waitCommand,void waitCommand (client*),replication.c,"void waitCommand(client *c) {
    mstime_t timeout;
    long numreplicas, ackreplicas;
    long long offset = c->woff;

    if (server.masterhost) {
        addReplyError(c,""WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated."");
        return;
    }

    /* Argument parsing. */
    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
        return;
    if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
        != C_OK) return;

    /* First try without blocking at all. */
    ackreplicas = replicationCountAcksByOffset(c->woff);
    if (ackreplicas >= numreplicas || c->flags & CLIENT_DENY_BLOCKING) {
        addReplyLongLong(c,ackreplicas);
        return;
    }

    /* Otherwise block the client and put it into our list of clients
     * waiting for ack from slaves. */
    blockForReplica...",3527.0,3557.0,1.0,68.0,31.0,18,10,22,7,0,12,5,5,5,7,,0,8,2,1,1,void
4228,331243,waitaofCommand,1,waitaofCommand,void waitaofCommand (client*),replication.c,"void waitaofCommand(client *c) {
    mstime_t timeout;
    long numreplicas, numlocal, ackreplicas, acklocal;

    /* Argument parsing. */
    if (getRangeLongFromObjectOrReply(c,c->argv[1],0,1,&numlocal,NULL) != C_OK)
        return;
    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&numreplicas,NULL) != C_OK)
        return;
    if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_MILLISECONDS) != C_OK)
        return;

    if (server.masterhost) {
        addReplyError(c,""WAITAOF cannot be used with replica instances. Please also note that writes to replicas are just local and are not propagated."");
        return;
    }
    if (numlocal && !server.aof_enabled) {
        addReplyError(c, ""WAITAOF cannot be used when numlocal is set but appendonly is disabled."");
        return;
    }

    /* First try without blocking at all. */
    ackreplicas = replicationCountAOFAcksByOffset(c->woff);
    acklocal = server.fsynced_reploff >= c->woff;
    if ((ackreplicas >= numreplic...",3561.0,3599.0,1.0,74.0,39.0,30,12,36,8,0,18,7,7,7,11,,0,11,2,1,1,void
4229,331382,unblockClientWaitingReplicas,1,unblockClientWaitingReplicas,void unblockClientWaitingReplicas (client*),replication.c,"void unblockClientWaitingReplicas(client *c) {
    listNode *ln = listSearchKey(server.clients_waiting_acks,c);
    serverAssert(ln != NULL);
    listDelNode(server.clients_waiting_acks,ln);
    updateStatsOnUnblock(c, 0, 0, 0);
}",3605.0,3610.0,1.0,4.0,6.0,8,7,8,4,0,4,1,1,0,4,,0,1,2,1,1,void
4230,331421,processClientsWaitingReplicas,1,processClientsWaitingReplicas,void processClientsWaitingReplicas (void),replication.c,"void processClientsWaitingReplicas(void) {
    long long last_offset = 0;
    long long last_aof_offset = 0;
    int last_numreplicas = 0;
    int last_aof_numreplicas = 0;

    listIter li;
    listNode *ln;

    listRewind(server.clients_waiting_acks,&li);
    while((ln = listNext(&li))) {
        int numlocal = 0;
        int numreplicas = 0;

        client *c = ln->value;
        int is_wait_aof = c->bstate.btype == BLOCKED_WAITAOF;

        if (is_wait_aof && c->bstate.numlocal && !server.aof_enabled) {
            addReplyError(c, ""WAITAOF cannot be used when numlocal is set but appendonly is disabled."");
            unblockClient(c, 1);
            continue;
        }

        /* Every time we find a client that is satisfied for a given
         * offset and number of replicas, we remember it so the next client
         * may be unblocked without calling replicationCountAcksByOffset()
         * or calling replicationCountAOFAcksByOffset()
         * if the requested offset ...",3614.0,3685.0,1.0,1.0,72.0,41,9,41,12,1,15,9,13,5,8,,0,8,2,1,1,void
4231,331650,replicationGetSlaveOffset,1,replicationGetSlaveOffset,long long replicationGetSlaveOffset (void),replication.c,"long long replicationGetSlaveOffset(void) {
    long long offset = 0;

    if (server.masterhost != NULL) {
        if (server.master) {
            offset = server.master->reploff;
        } else if (server.cached_master) {
            offset = server.cached_master->reploff;
        }
    }
    /* offset may be -1 when the master does not support it at all, however
     * this function is designed to return an offset that can express the
     * amount of data processed by the master, so we return a positive
     * integer. */
    if (offset < 0) offset = 0;
    return offset;
}",3689.0,3705.0,1.0,1.0,17.0,9,5,9,3,4,0,4,5,0,0,,0,0,2,1,1,long long
4232,331702,replicationCron,1,replicationCron,void replicationCron (void),replication.c,"void replicationCron(void) {
    static long long replication_cron_loops = 0;

    /* Check failover status first, to see if we need to start
     * handling the failover. */
    updateFailoverStatus();

    /* Non blocking connection timeout? */
    if (server.masterhost &&
        (server.repl_state == REPL_STATE_CONNECTING ||
         slaveIsInHandshakeState()) &&
         (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
    {
        serverLog(LL_WARNING,""Timeout connecting to the MASTER..."");
        cancelReplicationHandshake(1);
    }

    /* Bulk transfer I/O timeout? */
    if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER &&
        (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
    {
        serverLog(LL_WARNING,""Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."");
        cancelReplicationHandshake(1);
    }

    /* Timed out master wh...",3710.0,3905.0,1.0,8.0,196.0,176,24,102,16,1,45,23,37,9,32,,0,19,2,1,1,void
4233,332301,shouldStartChildReplication,1,shouldStartChildReplication,"int shouldStartChildReplication (int*,int*)",replication.c,"int shouldStartChildReplication(int *mincapa_out, int *req_out) {
    /* We should start a BGSAVE good for replication if we have slaves in
     * WAIT_BGSAVE_START state.
     *
     * In case of diskless replication, we make sure to wait the specified
     * number of seconds (according to configuration) so that other slaves
     * have the time to arrive before we start streaming. */
    if (!hasActiveChildProcess()) {
        time_t idle, max_idle = 0;
        int slaves_waiting = 0;
        int mincapa;
        int req;
        int first = 1;
        listNode *ln;
        listIter li;

        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
                if (first) {
                    /* Get first slave's requirements */
                    req = slave->slave_req;
                } else if (req != slave->slave_req) {
                    /* Skip sl...",3907.0,3957.0,1.0,36.0,51.0,43,15,40,12,1,9,9,23,3,3,,0,8,4,2,2,int
4234,332452,replicationStartPendingFork,1,replicationStartPendingFork,void replicationStartPendingFork (void),replication.c,"void replicationStartPendingFork(void) {
    int mincapa = -1;
    int req = -1;

    if (shouldStartChildReplication(&mincapa, &req)) {
        /* Start the BGSAVE. The called function may start a
         * BGSAVE with socket target or disk target depending on the
         * configuration and slaves capabilities and requirements. */
        startBgsaveForReplication(mincapa, req);
    }
}",3959.0,3969.0,1.0,1.0,11.0,6,3,6,2,2,2,2,2,1,2,,0,1,2,1,1,void
4235,332477,findReplica,1,findReplica,"client findReplica (char*,int)",replication.c,"static client *findReplica(char *host, int port) {
    listIter li;
    listNode *ln;
    client *replica;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        replica = ln->value;
        char ip[NET_IP_STR_LEN], *replicaip = replica->slave_addr;

        if (!replicaip) {
            if (connAddrPeerName(replica->conn, ip, sizeof(ip), NULL) == -1)
                continue;
            replicaip = ip;
        }

        if (!strcasecmp(host, replicaip) &&
                (port == replica->slave_listening_port))
            return replica;
    }

    return NULL;
}",3972.0,3994.0,1.0,16.0,23.0,18,9,21,9,2,7,6,9,4,3,,0,6,4,2,2,client
4236,332548,getFailoverStateString,1,getFailoverStateString,const char* getFailoverStateString (void),replication.c,"const char *getFailoverStateString(void) {
    switch(server.failover_state) {
        case NO_FAILOVER: return ""no-failover"";
        case FAILOVER_IN_PROGRESS: return ""failover-in-progress"";
        case FAILOVER_WAIT_FOR_SYNC: return ""waiting-for-sync"";
        default: return ""unknown"";
    }
}",3996.0,4003.0,1.0,1.0,8.0,1,1,4,4,1,0,2,2,0,0,,0,0,2,1,1,const char*
4237,332573,clearFailoverState,1,clearFailoverState,void clearFailoverState (void),replication.c,"void clearFailoverState(void) {
    server.failover_end_time = 0;
    server.force_failover = 0;
    zfree(server.target_replica_host);
    server.target_replica_host = NULL;
    server.target_replica_port = 0;
    server.failover_state = NO_FAILOVER;
    unpauseActions(PAUSE_DURING_FAILOVER);
}",4008.0,4016.0,1.0,1.0,9.0,11,2,9,4,2,2,1,1,0,2,,0,0,2,1,1,void
4238,332609,abortFailover,1,abortFailover,void abortFailover (char*),replication.c,"void abortFailover(const char *err) {
    if (server.failover_state == NO_FAILOVER) return;

    if (server.target_replica_host) {
        serverLog(LL_NOTICE,""FAILOVER to %s:%d aborted: %s"",
            server.target_replica_host,server.target_replica_port,err);  
    } else {
        serverLog(LL_NOTICE,""FAILOVER to any replica aborted: %s"",err);  
    }
    if (server.failover_state == FAILOVER_IN_PROGRESS) {
        replicationUnsetMaster();
    }
    clearFailoverState();
}",4019.0,4032.0,1.0,8.0,14.0,10,4,9,4,2,3,4,4,0,3,,0,0,2,1,1,void
4239,332682,failoverCommand,1,failoverCommand,void failoverCommand (client*),replication.c,"void failoverCommand(client *c) {
    if (server.cluster_enabled) {
        addReplyError(c,""FAILOVER not allowed in cluster mode. ""
                        ""Use CLUSTER FAILOVER command instead."");
        return;
    }
    
    /* Handle special case for abort */
    if ((c->argc == 2) && !strcasecmp(c->argv[1]->ptr,""abort"")) {
        if (server.failover_state == NO_FAILOVER) {
            addReplyError(c, ""No failover in progress."");
            return;
        }

        abortFailover(""Failover manually aborted"");
        addReply(c,shared.ok);
        return;
    }

    long timeout_in_ms = 0;
    int force_flag = 0;
    long port = 0;
    char *host = NULL;

    /* Parse the command for syntax and arguments. */
    for (int j = 1; j < c->argc; j++) {
        if (!strcasecmp(c->argv[j]->ptr,""timeout"") && (j + 1 < c->argc) &&
            timeout_in_ms == 0)
        {
            if (getLongFromObjectOrReply(c,c->argv[j + 1],
                        &timeout_in_ms,NULL) != C_OK)...",4061.0,4168.0,1.0,48.0,108.0,73,17,71,15,0,25,16,24,8,18,,0,11,2,1,1,void
4240,333085,updateFailoverStatus,1,updateFailoverStatus,void updateFailoverStatus (void),replication.c,"void updateFailoverStatus(void) {
    if (server.failover_state != FAILOVER_WAIT_FOR_SYNC) return;
    mstime_t now = server.mstime;

    /* Check if failover operation has timed out */
    if (server.failover_end_time && server.failover_end_time <= now) {
        if (server.force_failover) {
            serverLog(LL_NOTICE,
                ""FAILOVER to %s:%d time out exceeded, failing over."",
                server.target_replica_host, server.target_replica_port);
            server.failover_state = FAILOVER_IN_PROGRESS;
            /* If timeout has expired force a failover if requested. */
            replicationSetMaster(server.target_replica_host,
                server.target_replica_port);
            return;
        } else {
            /* Force was not requested, so timeout. */
            abortFailover(""Replica never caught up before timeout"");
            return;
        }
    }

    /* Check to see if the replica has caught up so failover can start */
    client *replica...",4177.0,4239.0,1.0,12.0,63.0,36,9,31,6,2,6,6,7,1,5,,0,2,2,1,1,void
4241,333309,parseBulk,1,parseBulk,"int parseBulk (ReplyParser*,void*)",resp_parser.c,"static int parseBulk(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long bulklen;
    parser->curr_location = p + 2; /* for \r\n */

    string2ll(proto+1,p-proto-1,&bulklen);
    if (bulklen == -1) {
        parser->callbacks.null_bulk_string_callback(p_ctx, proto, parser->curr_location - proto);
    } else {
        const char *str = parser->curr_location;
        parser->curr_location += bulklen;
        parser->curr_location += 2; /* for \r\n */
        parser->callbacks.bulk_string_callback(p_ctx, str, bulklen, proto, parser->curr_location - proto);
    }

    return C_OK;
}",61.0,78.0,1.0,11.0,18.0,17,8,16,5,1,6,2,2,0,2,,0,4,4,2,2,int
4242,333404,parseSimpleString,1,parseSimpleString,"int parseSimpleString (ReplyParser*,void*)",resp_parser.c,"static int parseSimpleString(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.simple_str_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",80.0,86.0,1.0,11.0,7.0,14,5,14,4,1,5,1,1,0,1,,0,4,4,2,2,int
4243,333456,parseError,1,parseError,"int parseError (ReplyParser*,void*)",resp_parser.c,"static int parseError(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; // for \r\n
    parser->callbacks.error_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",88.0,94.0,1.0,11.0,7.0,14,5,14,4,1,5,1,1,0,1,,0,4,4,2,2,int
4244,333508,parseLong,1,parseLong,"int parseLong (ReplyParser*,void*)",resp_parser.c,"static int parseLong(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    long long val;
    string2ll(proto+1,p-proto-1,&val);
    parser->callbacks.long_callback(p_ctx, val, proto, parser->curr_location - proto);
    return C_OK;
}",96.0,104.0,1.0,11.0,9.0,15,6,16,5,1,6,1,1,0,2,,0,4,4,2,2,int
4245,333565,parseAttributes,1,parseAttributes,"int parseAttributes (ReplyParser*,void*)",resp_parser.c,"static int parseAttributes(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.attribute_callback(parser, p_ctx, len, proto);
    return C_OK;
}",106.0,115.0,1.0,11.0,10.0,13,7,16,5,1,5,1,1,0,2,,0,3,4,2,2,int
4246,333619,parseVerbatimString,1,parseVerbatimString,"int parseVerbatimString (ReplyParser*,void*)",resp_parser.c,"static int parseVerbatimString(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long bulklen;
    parser->curr_location = p + 2; /* for \r\n */
    string2ll(proto+1,p-proto-1,&bulklen);
    const char *format = parser->curr_location;
    parser->curr_location += bulklen;
    parser->curr_location += 2; /* for \r\n */
    parser->callbacks.verbatim_string_callback(p_ctx, format, format + 4, bulklen - 4, proto, parser->curr_location - proto);
    return C_OK;
}",117.0,128.0,1.0,11.0,12.0,23,7,23,6,1,9,1,1,0,2,,0,7,4,2,2,int
4247,333698,parseBigNumber,1,parseBigNumber,"int parseBigNumber (ReplyParser*,void*)",resp_parser.c,"static int parseBigNumber(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.big_number_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",130.0,136.0,1.0,11.0,7.0,14,5,14,4,1,5,1,1,0,1,,0,4,4,2,2,int
4248,333750,parseNull,1,parseNull,"int parseNull (ReplyParser*,void*)",resp_parser.c,"static int parseNull(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.null_callback(p_ctx, proto, parser->curr_location - proto);
    return C_OK;
}",138.0,144.0,1.0,11.0,7.0,11,5,11,4,1,5,1,1,0,1,,0,4,4,2,2,int
4249,333794,parseDouble,1,parseDouble,"int parseDouble (ReplyParser*,void*)",resp_parser.c,"static int parseDouble(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    char buf[MAX_LONG_DOUBLE_CHARS+1];
    size_t len = p-proto-1;
    double d;
    if (len <= MAX_LONG_DOUBLE_CHARS) {
        memcpy(buf,proto+1,len);
        buf[len] = '\0';
        d = strtod(buf,NULL); /* We expect a valid representation. */
    } else {
        d = 0;
    }
    parser->callbacks.double_callback(p_ctx, d, proto, parser->curr_location - proto);
    return C_OK;
}",146.0,162.0,1.0,13.0,17.0,20,8,24,8,1,5,2,2,0,1,,0,4,4,2,2,int
4250,333879,parseBool,1,parseBool,"int parseBool (ReplyParser*,void*)",resp_parser.c,"static int parseBool(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.bool_callback(p_ctx, proto[1] == 't', proto, parser->curr_location - proto);
    return C_OK;
}",164.0,170.0,1.0,11.0,7.0,13,7,12,4,1,5,1,1,0,1,,0,4,4,2,2,int
4251,333928,parseArray,1,parseArray,"int parseArray (ReplyParser*,void*)",resp_parser.c,"static int parseArray(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    if (len == -1) {
        parser->callbacks.null_array_callback(p_ctx, proto, parser->curr_location - proto);
    } else {
        parser->callbacks.array_callback(parser, p_ctx, len, proto);
    }
    return C_OK;
}",172.0,185.0,1.0,11.0,14.0,17,9,17,5,1,6,2,2,0,2,,0,4,4,2,2,int
4252,334003,parseSet,1,parseSet,"int parseSet (ReplyParser*,void*)",resp_parser.c,"static int parseSet(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.set_callback(parser, p_ctx, len, proto);
    return C_OK;
}",187.0,196.0,1.0,11.0,10.0,13,7,16,5,1,5,1,1,0,2,,0,3,4,2,2,int
4253,334057,parseMap,1,parseMap,"int parseMap (ReplyParser*,void*)",resp_parser.c,"static int parseMap(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.map_callback(parser, p_ctx, len, proto);
    return C_OK;
}",198.0,207.0,1.0,11.0,10.0,13,7,16,5,1,5,1,1,0,2,,0,3,4,2,2,int
4254,334111,parseReply,1,parseReply,"int parseReply (ReplyParser*,void*)",resp_parser.c,"int parseReply(ReplyParser *parser, void *p_ctx) {
    switch (parser->curr_location[0]) {
        case '$': return parseBulk(parser, p_ctx);
        case '+': return parseSimpleString(parser, p_ctx);
        case '-': return parseError(parser, p_ctx);
        case ':': return parseLong(parser, p_ctx);
        case '*': return parseArray(parser, p_ctx);
        case '~': return parseSet(parser, p_ctx);
        case '%': return parseMap(parser, p_ctx);
        case '#': return parseBool(parser, p_ctx);
        case ',': return parseDouble(parser, p_ctx);
        case '_': return parseNull(parser, p_ctx);
        case '(': return parseBigNumber(parser, p_ctx);
        case '=': return parseVerbatimString(parser, p_ctx);
        case '|': return parseAttributes(parser, p_ctx);
        default: if (parser->callbacks.error) parser->callbacks.error(p_ctx);
    }
    return C_ERR;
}",210.0,228.0,1.0,11.0,19.0,7,4,30,2,4,17,3,4,2,14,,0,3,4,2,2,int
4255,334232,null_array_callback,1,ReplyParserCallbacks.null_array_callback,"void ReplyParserCallbacks.null_array_callback (void*,char*,size_t)",resp_parser.h,"void (*null_array_callback)(void *ctx, const char *proto, size_t proto_len);",39.0,39.0,10.0,79.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4256,334239,null_bulk_string_callback,1,ReplyParserCallbacks.null_bulk_string_callback,"void ReplyParserCallbacks.null_bulk_string_callback (void*,char*,size_t)",resp_parser.h,"void (*null_bulk_string_callback)(void *ctx, const char *proto, size_t proto_len);",42.0,42.0,10.0,85.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4257,334255,error_callback,1,ReplyParserCallbacks.error_callback,"void ReplyParserCallbacks.error_callback (void*,char*,size_t,char*,size_t)",resp_parser.h,"void (*error_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",48.0,48.0,10.0,103.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
4258,334264,simple_str_callback,1,ReplyParserCallbacks.simple_str_callback,"void ReplyParserCallbacks.simple_str_callback (void*,char*,size_t,char*,size_t)",resp_parser.h,"void (*simple_str_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",51.0,51.0,10.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
4259,334273,long_callback,1,ReplyParserCallbacks.long_callback,"void ReplyParserCallbacks.long_callback (void*,long long,char*,size_t)",resp_parser.h,"void (*long_callback)(void *ctx, long long val, const char *proto, size_t proto_len);",54.0,54.0,10.0,88.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
4260,334289,set_callback,1,ReplyParserCallbacks.set_callback,"void ReplyParserCallbacks.set_callback (ReplyParser*,void*,size_t,char*)",resp_parser.h,"void (*set_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",60.0,60.0,10.0,94.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
4261,334297,map_callback,1,ReplyParserCallbacks.map_callback,"void ReplyParserCallbacks.map_callback (ReplyParser*,void*,size_t,char*)",resp_parser.h,"void (*map_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",63.0,63.0,10.0,94.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
4262,334305,bool_callback,1,ReplyParserCallbacks.bool_callback,"void ReplyParserCallbacks.bool_callback (void*,int,char*,size_t)",resp_parser.h,"void (*bool_callback)(void *ctx, int val, const char *proto, size_t proto_len);",66.0,66.0,10.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
4263,334313,double_callback,1,ReplyParserCallbacks.double_callback,"void ReplyParserCallbacks.double_callback (void*,double,char*,size_t)",resp_parser.h,"void (*double_callback)(void *ctx, double val, const char *proto, size_t proto_len);",69.0,69.0,10.0,87.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
4264,334321,big_number_callback,1,ReplyParserCallbacks.big_number_callback,"void ReplyParserCallbacks.big_number_callback (void*,char*,size_t,char*,size_t)",resp_parser.h,"void (*big_number_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",72.0,72.0,10.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
4265,334330,verbatim_string_callback,1,ReplyParserCallbacks.verbatim_string_callback,"void ReplyParserCallbacks.verbatim_string_callback (void*,char*,char*,size_t,char*,size_t)",resp_parser.h,"void (*verbatim_string_callback)(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len);",75.0,75.0,10.0,133.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,void
4266,334340,attribute_callback,1,ReplyParserCallbacks.attribute_callback,"void ReplyParserCallbacks.attribute_callback (ReplyParser*,void*,size_t,char*)",resp_parser.h,"void (*attribute_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",78.0,78.0,10.0,100.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
4267,334348,null_callback,1,ReplyParserCallbacks.null_callback,"void ReplyParserCallbacks.null_callback (void*,char*,size_t)",resp_parser.h,"void (*null_callback)(void *ctx, const char *proto, size_t proto_len);",81.0,81.0,10.0,73.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4268,334355,error,1,ReplyParserCallbacks.error,void ReplyParserCallbacks.error (void*),resp_parser.h,void (*error)(void *ctx);,83.0,83.0,10.0,28.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4269,334395,rioBufferWrite,1,rioBufferWrite,"size_t rioBufferWrite (rio*,void*,size_t)",rio.c,"static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
    r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
    r->io.buffer.pos += len;
    return 1;
}",62.0,66.0,1.0,1.0,5.0,12,5,6,3,0,1,1,1,0,1,,0,1,6,3,3,size_t
4270,334433,rioBufferRead,1,rioBufferRead,"size_t rioBufferRead (rio*,void*,size_t)",rio.c,"static size_t rioBufferRead(rio *r, void *buf, size_t len) {
    if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len)
        return 0; /* not enough buffer to return len bytes. */
    memcpy(buf,r->io.buffer.ptr+r->io.buffer.pos,len);
    r->io.buffer.pos += len;
    return 1;
}",69.0,75.0,1.0,1.0,7.0,19,6,9,3,0,1,2,2,1,1,,0,1,6,3,3,size_t
4271,334534,rioInitWithBuffer,1,rioInitWithBuffer,"void rioInitWithBuffer (rio*,sds)",rio.c,"void rioInitWithBuffer(rio *r, sds s) {
    *r = rioBufferIO;
    r->io.buffer.ptr = s;
    r->io.buffer.pos = 0;
}",102.0,106.0,1.0,1.0,5.0,10,4,5,3,8,1,1,1,0,0,,0,1,4,2,2,void
4272,334562,rioFileWrite,1,rioFileWrite,"size_t rioFileWrite (rio*,void*,size_t)",rio.c,"static size_t rioFileWrite(rio *r, const void *buf, size_t len) {
    if (!r->io.file.autosync) return fwrite(buf,len,1,r->io.file.fp);

    size_t nwritten = 0;
    /* Incrementally write data to the file, avoid a single write larger than
     * the autosync threshold (so that the kernel's buffer cache never has too
     * many dirty pages at once). */
    while (len != nwritten) {
        serverAssert(r->io.file.autosync > r->io.file.buffered);
        size_t nalign = (size_t)(r->io.file.autosync - r->io.file.buffered);
        size_t towrite = nalign > len-nwritten ? len-nwritten : nalign;

        if (fwrite((char*)buf+nwritten,towrite,1,r->io.file.fp) == 0) return 0;
        nwritten += towrite;
        r->io.file.buffered += towrite;

        if (r->io.file.buffered >= r->io.file.autosync) {
            fflush(r->io.file.fp);

            size_t processed = r->processed_bytes + nwritten;
            serverAssert(processed % r->io.file.autosync == 0);
            serverAssert(r...",111.0,168.0,1.0,8.0,58.0,95,17,42,7,0,4,7,13,0,4,,0,0,6,3,3,size_t
4273,334904,rioInitWithFile,1,rioInitWithFile,"void rioInitWithFile (rio*,FILE*)",rio.c,"void rioInitWithFile(rio *r, FILE *fp) {
    *r = rioFileIO;
    r->io.file.fp = fp;
    r->io.file.buffered = 0;
    r->io.file.autosync = 0;
    r->io.file.reclaim_cache = 0;
}",199.0,205.0,1.0,1.0,7.0,18,4,7,3,3,1,1,1,0,0,,0,1,4,2,2,void
4274,334950,rioConnWrite,1,rioConnWrite,"size_t rioConnWrite (rio*,void*,size_t)",rio.c,"static size_t rioConnWrite(rio *r, const void *buf, size_t len) {
    UNUSED(r);
    UNUSED(buf);
    UNUSED(len);
    return 0; /* Error, this target does not yet support writing. */
}",213.0,218.0,1.0,4.0,6.0,3,1,6,3,1,0,1,1,0,0,,0,0,6,3,3,size_t
4275,334977,rioConnRead,1,rioConnRead,"size_t rioConnRead (rio*,void*,size_t)",rio.c,"static size_t rioConnRead(rio *r, void *buf, size_t len) {
    size_t avail = sdslen(r->io.conn.buf)-r->io.conn.pos;

    /* If the buffer is too small for the entire request: realloc. */
    if (sdslen(r->io.conn.buf) + sdsavail(r->io.conn.buf) < len)
        r->io.conn.buf = sdsMakeRoomFor(r->io.conn.buf, len - sdslen(r->io.conn.buf));

    /* If the remaining unused buffer is not large enough: memmove so that we
     * can read the rest. */
    if (len > avail && sdsavail(r->io.conn.buf) < len - avail) {
        sdsrange(r->io.conn.buf, r->io.conn.pos, -1);
        r->io.conn.pos = 0;
    }

    /* Make sure the caller didn't request to read past the limit.
     * If they didn't we'll buffer till the limit, if they did, we'll
     * return an error. */
    if (r->io.conn.read_limit != 0 && r->io.conn.read_limit < r->io.conn.read_so_far + len) {
        errno = EOVERFLOW;
        return 0;
    }

    /* If we don't already have all the data in the sds, read more */
    while (len ...",221.0,273.0,1.0,32.0,53.0,145,15,66,10,0,14,8,11,5,14,,0,12,6,3,3,size_t
4276,335389,rioConnFlush,1,rioConnFlush,int rioConnFlush (rio*),rio.c,"static int rioConnFlush(rio *r) {
    /* Our flush is implemented by the write method, that recognizes a
     * buffer set to NULL with a count of zero as a flush request. */
    return rioConnWrite(r,NULL,0);
}",282.0,286.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
4277,335416,rioInitWithConn,1,rioInitWithConn,"void rioInitWithConn (rio*,connection*,size_t)",rio.c,"void rioInitWithConn(rio *r, connection *conn, size_t read_limit) {
    *r = rioConnIO;
    r->io.conn.conn = conn;
    r->io.conn.pos = 0;
    r->io.conn.read_limit = read_limit;
    r->io.conn.read_so_far = 0;
    r->io.conn.buf = sdsnewlen(NULL, PROTO_IOBUF_LEN);
    sdsclear(r->io.conn.buf);
}",303.0,311.0,1.0,37.0,9.0,26,5,11,5,1,3,1,1,0,2,,0,2,6,3,3,void
4278,335486,rioFreeConn,1,rioFreeConn,"void rioFreeConn (rio*,sds*)",rio.c,"void rioFreeConn(rio *r, sds *remaining) {
    if (remaining && (size_t)r->io.conn.pos < sdslen(r->io.conn.buf)) {
        if (r->io.conn.pos > 0) sdsrange(r->io.conn.buf, r->io.conn.pos, -1);
        *remaining = r->io.conn.buf;
    } else {
        sdsfree(r->io.conn.buf);
        if (remaining) *remaining = NULL;
    }
    r->io.conn.buf = NULL;
}",315.0,324.0,1.0,1.0,10.0,29,9,10,3,2,2,3,4,1,2,,0,1,4,2,2,void
4279,335578,rioFdWrite,1,rioFdWrite,"size_t rioFdWrite (rio*,void*,size_t)",rio.c,"static size_t rioFdWrite(rio *r, const void *buf, size_t len) {
    ssize_t retval;
    unsigned char *p = (unsigned char*) buf;
    int doflush = (buf == NULL && len == 0);

    /* For small writes, we rather keep the data in user-space buffer, and flush
     * it only when it grows. however for larger writes, we prefer to flush
     * any pre-existing buffer, and write the new one directly without reallocs
     * and memory copying. */
    if (len > PROTO_IOBUF_LEN) {
        /* First, flush any pre-existing buffered data. */
        if (sdslen(r->io.fd.buf)) {
            if (rioFdWrite(r, NULL, 0) == 0)
                return 0;
        }
        /* Write the new data, keeping 'p' and 'len' from the input. */
    } else {
        if (len) {
            r->io.fd.buf = sdscatlen(r->io.fd.buf,buf,len);
            if (sdslen(r->io.fd.buf) > PROTO_IOBUF_LEN)
                doflush = 1;
            if (!doflush)
                return 1;
        }
        /* Flushing the buffered da...",337.0,384.0,1.0,14.0,48.0,38,14,33,12,1,2,9,16,1,2,,0,1,6,3,3,size_t
4280,335818,rioFdFlush,1,rioFdFlush,int rioFdFlush (rio*),rio.c,"static int rioFdFlush(rio *r) {
    /* Our flush is implemented by the write method, that recognizes a
     * buffer set to NULL with a count of zero as a flush request. */
    return rioFdWrite(r,NULL,0);
}",401.0,405.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
4281,335845,rioInitWithFd,1,rioInitWithFd,"void rioInitWithFd (rio*,int)",rio.c,"void rioInitWithFd(rio *r, int fd) {
    *r = rioFdIO;
    r->io.fd.fd = fd;
    r->io.fd.pos = 0;
    r->io.fd.buf = sdsempty();
}",420.0,425.0,1.0,1.0,6.0,14,4,6,3,1,2,1,1,0,1,,0,2,4,2,2,void
4282,335882,rioFreeFd,1,rioFreeFd,void rioFreeFd (rio*),rio.c,"void rioFreeFd(rio *r) {
    sdsfree(r->io.fd.buf);
}",428.0,430.0,1.0,1.0,3.0,3,2,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
4283,335895,rioGenericUpdateChecksum,1,rioGenericUpdateChecksum,"void rioGenericUpdateChecksum (rio*,void*,size_t)",rio.c,"void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
    r->cksum = crc64(r->cksum,buf,len);
}",436.0,438.0,1.0,1.0,3.0,3,2,4,3,1,1,1,1,0,1,,0,1,6,3,3,void
4284,335912,rioSetAutoSync,1,rioSetAutoSync,"void rioSetAutoSync (rio*,off_t)",rio.c,"void rioSetAutoSync(rio *r, off_t bytes) {
    if(r->write != rioFileIO.write) return;
    r->io.file.autosync = bytes;
}",448.0,451.0,1.0,1.0,4.0,7,4,4,3,1,1,2,2,1,0,,0,1,4,2,2,void
4285,335937,rioSetReclaimCache,1,rioSetReclaimCache,"void rioSetReclaimCache (rio*,int)",rio.c,"void rioSetReclaimCache(rio *r, int enabled) {
    r->io.file.reclaim_cache = enabled;
}",458.0,460.0,1.0,1.0,3.0,4,3,2,2,1,0,1,1,0,0,,0,0,4,2,2,void
4286,335952,rioCheckType,1,rioCheckType,uint8_t rioCheckType (rio*),rio.c,"uint8_t rioCheckType(rio *r) {
    if (r->read == rioFileRead) {
        return RIO_TYPE_FILE;
    } else if (r->read == rioBufferRead) {
        return RIO_TYPE_BUFFER;
    } else if (r->read == rioConnRead) {
        return RIO_TYPE_CONN;
    } else {
        /* r->read == rioFdRead */
        return RIO_TYPE_FD;
    }
}",463.0,474.0,1.0,15.0,12.0,3,3,1,1,1,0,2,2,0,0,,0,0,2,1,1,uint8_t
4287,336008,rioWriteBulkCount,1,rioWriteBulkCount,"size_t rioWriteBulkCount (rio*,char,long)",rio.c,"size_t rioWriteBulkCount(rio *r, char prefix, long count) {
    char cbuf[128];
    int clen;

    cbuf[0] = prefix;
    clen = 1+ll2string(cbuf+1,sizeof(cbuf)-1,count);
    cbuf[clen++] = '\r';
    cbuf[clen++] = '\n';
    if (rioWrite(r,cbuf,clen) == 0) return 0;
    return clen;
}",482.0,492.0,1.0,1.0,11.0,14,7,14,5,14,2,2,2,1,2,,0,2,6,3,3,size_t
4288,336059,rioWriteBulkString,1,rioWriteBulkString,"size_t rioWriteBulkString (rio*,char*,size_t)",rio.c,"size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {
    size_t nwritten;

    if ((nwritten = rioWriteBulkCount(r,'$',len)) == 0) return 0;
    if (len > 0 && rioWrite(r,buf,len) == 0) return 0;
    if (rioWrite(r,""\r\n"",2) == 0) return 0;
    return nwritten+len+2;
}",495.0,502.0,1.0,1.0,8.0,8,5,10,4,42,3,4,4,3,3,,0,3,6,3,3,size_t
4289,336109,rioWriteBulkLongLong,1,rioWriteBulkLongLong,"size_t rioWriteBulkLongLong (rio*,long long)",rio.c,"size_t rioWriteBulkLongLong(rio *r, long long l) {
    char lbuf[32];
    unsigned int llen;

    llen = ll2string(lbuf,sizeof(lbuf),l);
    return rioWriteBulkString(r,lbuf,llen);
}",505.0,511.0,1.0,1.0,7.0,2,2,7,4,10,2,1,1,0,2,,0,1,4,2,2,size_t
4290,336129,rioWriteBulkDouble,1,rioWriteBulkDouble,"size_t rioWriteBulkDouble (rio*,double)",rio.c,"size_t rioWriteBulkDouble(rio *r, double d) {
    char dbuf[128];
    unsigned int dlen;
    dlen = fpconv_dtoa(d, dbuf);
    dbuf[dlen] = '\0';
    return rioWriteBulkString(r,dbuf,dlen);
}",514.0,520.0,1.0,1.0,7.0,3,2,8,4,1,1,1,1,0,1,,0,0,4,2,2,size_t
4291,336166,read,1,_rio.read,"size_t _rio.read (_rio*,void*,size_t)",rio.h,"size_t (*read)(struct _rio *, void *buf, size_t len);",52.0,52.0,12.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,size_t
4292,336173,write,1,_rio.write,"size_t _rio.write (_rio*,void*,size_t)",rio.h,"size_t (*write)(struct _rio *, const void *buf, size_t len);",53.0,53.0,12.0,63.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,size_t
4293,336180,tell,1,_rio.tell,off_t _rio.tell (_rio*),rio.h,off_t (*tell)(struct _rio *);,54.0,54.0,11.0,32.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,off_t
4294,336185,flush,1,_rio.flush,int _rio.flush (_rio*),rio.h,int (*flush)(struct _rio *);,55.0,55.0,9.0,31.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4295,336190,update_cksum,1,_rio.update_cksum,"void _rio.update_cksum (_rio*,void*,size_t)",rio.h,"void (*update_cksum)(struct _rio *, const void *buf, size_t len);",61.0,61.0,10.0,68.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
4296,336227,rioWrite,1,rioWrite,"size_t rioWrite (rio*,void*,size_t)",rio.h,"static inline size_t rioWrite(rio *r, const void *buf, size_t len) {
    if (r->flags & RIO_FLAG_WRITE_ERROR) return 0;
    while (len) {
        size_t bytes_to_write = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_write);
        if (r->write(r,buf,bytes_to_write) == 0) {
            r->flags |= RIO_FLAG_WRITE_ERROR;
            return 0;
        }
        buf = (char*)buf + bytes_to_write;
        len -= bytes_to_write;
        r->processed_bytes += bytes_to_write;
    }
    return 1;
}",109.0,123.0,1.0,19.0,15.0,22,12,25,4,15,2,5,7,1,2,,0,1,6,3,3,size_t
4297,336318,rioRead,1,rioRead,"size_t rioRead (rio*,void*,size_t)",rio.h,"static inline size_t rioRead(rio *r, void *buf, size_t len) {
    if (r->flags & RIO_FLAG_READ_ERROR) return 0;
    while (len) {
        size_t bytes_to_read = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
        if (r->read(r,buf,bytes_to_read) == 0) {
            r->flags |= RIO_FLAG_READ_ERROR;
            return 0;
        }
        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_read);
        buf = (char*)buf + bytes_to_read;
        len -= bytes_to_read;
        r->processed_bytes += bytes_to_read;
    }
    return 1;
}",125.0,139.0,1.0,19.0,15.0,22,12,25,4,15,2,5,7,1,2,,0,1,6,3,3,size_t
4298,336409,rioTell,1,rioTell,off_t rioTell (rio*),rio.h,"static inline off_t rioTell(rio *r) {
    return r->tell(r);
}",141.0,143.0,1.0,1.0,3.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,off_t
4299,336420,rioFlush,1,rioFlush,int rioFlush (rio*),rio.h,"static inline int rioFlush(rio *r) {
    return r->flush(r);
}",145.0,147.0,1.0,1.0,3.0,1,1,2,1,1,1,1,1,0,1,,0,0,2,1,1,int
4300,336431,rioGetReadError,1,rioGetReadError,int rioGetReadError (rio*),rio.h,"static inline int rioGetReadError(rio *r) {
    return (r->flags & RIO_FLAG_READ_ERROR) != 0;
}",152.0,154.0,1.0,23.0,3.0,4,4,1,1,2,0,1,1,0,0,,0,0,2,1,1,int
4301,336672,exitScriptTimedoutMode,1,exitScriptTimedoutMode,void exitScriptTimedoutMode (scriptRunCtx*),script.c,"static void exitScriptTimedoutMode(scriptRunCtx *run_ctx) {
    serverAssert(run_ctx == curr_run_ctx);
    serverAssert(scriptIsTimedout());
    run_ctx->flags &= ~SCRIPT_TIMEDOUT;
    blockingOperationEnds();
    /* if we are a replica and we have an active master, set it for continue processing */
    if (server.masterhost && server.master) queueClientForReprocessing(server.master);
}",46.0,53.0,1.0,4.0,8.0,16,10,6,3,1,8,2,2,0,6,,0,2,2,1,1,void
4302,336732,enterScriptTimedoutMode,1,enterScriptTimedoutMode,void enterScriptTimedoutMode (scriptRunCtx*),script.c,"static void enterScriptTimedoutMode(scriptRunCtx *run_ctx) {
    serverAssert(run_ctx == curr_run_ctx);
    serverAssert(!scriptIsTimedout());
    /* Mark script as timedout */
    run_ctx->flags |= SCRIPT_TIMEDOUT;
    blockingOperationStarts();
}",55.0,61.0,1.0,4.0,7.0,13,8,3,2,1,7,1,1,0,5,,0,2,2,1,1,void
4303,336780,scriptIsTimedout,1,scriptIsTimedout,int scriptIsTimedout (void),script.c,"int scriptIsTimedout(void) {
    return scriptIsRunning() && (curr_run_ctx->flags & SCRIPT_TIMEDOUT);
}",63.0,65.0,1.0,55.0,3.0,4,4,1,1,7,3,1,1,0,1,,0,2,2,1,1,int
4304,336797,scriptGetClient,1,scriptGetClient,client scriptGetClient (void),script.c,"client* scriptGetClient(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->c;
}",67.0,70.0,1.0,4.0,4.0,5,5,1,1,0,5,1,1,0,3,,0,2,2,1,1,client
4305,336821,scriptGetCaller,1,scriptGetCaller,client scriptGetCaller (void),script.c,"client* scriptGetCaller(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->original_client;
}",72.0,75.0,1.0,4.0,4.0,5,5,1,1,0,5,1,1,0,3,,0,2,2,1,1,client
4306,336845,scriptInterrupt,1,scriptInterrupt,int scriptInterrupt (scriptRunCtx*),script.c,"int scriptInterrupt(scriptRunCtx *run_ctx) {
    if (run_ctx->flags & SCRIPT_TIMEDOUT) {
        /* script already timedout
           we just need to precess some events and return */
        processEventsWhileBlocked();
        return (run_ctx->flags & SCRIPT_KILLED) ? SCRIPT_KILL : SCRIPT_CONTINUE;
    }

    long long elapsed = elapsedMs(run_ctx->start_time);
    if (elapsed < server.busy_reply_threshold) {
        return SCRIPT_CONTINUE;
    }

    serverLog(LL_WARNING,
            ""Slow script detected: still in execution after %lld milliseconds. ""
                    ""You can try killing the script using the %s command. Script name is: %s."",
            elapsed, (run_ctx->flags & SCRIPT_EVAL_MODE) ? ""SCRIPT KILL"" : ""FUNCTION KILL"", run_ctx->funcname);

    enterScriptTimedoutMode(run_ctx);
    /* Once the script timeouts we reenter the event loop to permit others
     * some commands execution. For this reason
     * we need to mask the client executing the script from the ev...",80.0,109.0,1.0,25.0,30.0,24,7,13,3,1,13,3,3,1,6,,0,8,2,1,1,int
4307,336953,scriptFlagsToCmdFlags,1,scriptFlagsToCmdFlags,"uint64_t scriptFlagsToCmdFlags (uint64_t,uint64_t)",script.c,"uint64_t scriptFlagsToCmdFlags(uint64_t cmd_flags, uint64_t script_flags) {
    /* If the script declared flags, clear the ones from the command and use the ones it declared.*/
    cmd_flags &= ~(CMD_STALE | CMD_DENYOOM | CMD_WRITE);

    /* NO_WRITES implies ALLOW_OOM */
    if (!(script_flags & (SCRIPT_FLAG_ALLOW_OOM | SCRIPT_FLAG_NO_WRITES)))
        cmd_flags |= CMD_DENYOOM;
    if (!(script_flags & SCRIPT_FLAG_NO_WRITES))
        cmd_flags |= CMD_WRITE;
    if (script_flags & SCRIPT_FLAG_ALLOW_STALE)
        cmd_flags |= CMD_STALE;

    /* In addition the MAY_REPLICATE flag is set for these commands, but
     * if we have flags we know if it's gonna do any writes or not. */
    cmd_flags &= ~CMD_MAY_REPLICATE;

    return cmd_flags;
}",111.0,128.0,1.0,19.0,18.0,21,5,9,2,2,0,4,4,0,0,,0,0,4,2,2,uint64_t
4308,337045,scriptPrepareForRun,1,scriptPrepareForRun,"int scriptPrepareForRun (scriptRunCtx*,client*,client*,char*,uint64_t,int)",script.c,"int scriptPrepareForRun(scriptRunCtx *run_ctx, client *engine_client, client *caller, const char *funcname, uint64_t script_flags, int ro) {
    serverAssert(!curr_run_ctx);
    int client_allow_oom = !!(caller->flags & CLIENT_ALLOW_OOM);

    int running_stale = server.masterhost &&
            server.repl_state != REPL_STATE_CONNECTED &&
            server.repl_serve_stale_data == 0;
    int obey_client = mustObeyClient(caller);

    if (!(script_flags & SCRIPT_FLAG_EVAL_COMPAT_MODE)) {
        if ((script_flags & SCRIPT_FLAG_NO_CLUSTER) && server.cluster_enabled) {
            addReplyError(caller, ""Can not run script on cluster, 'no-cluster' flag is set."");
            return C_ERR;
        }

        if (running_stale && !(script_flags & SCRIPT_FLAG_ALLOW_STALE)) {
            addReplyError(caller, ""-MASTERDOWN Link with MASTER is down, ""
                             ""replica-serve-stale-data is set to 'no' ""
                             ""and 'allow-stale' flag is not set on th...",131.0,249.0,1.0,4.0,119.0,117,16,68,16,2,32,15,30,2,13,,0,23,12,6,6,int
4309,337474,scriptResetRun,1,scriptResetRun,void scriptResetRun (scriptRunCtx*),script.c,"void scriptResetRun(scriptRunCtx *run_ctx) {
    serverAssert(curr_run_ctx);

    /* After the script done, remove the MULTI state. */
    run_ctx->c->flags &= ~CLIENT_MULTI;

    if (scriptIsTimedout()) {
        exitScriptTimedoutMode(run_ctx);
        /* Restore the client that was protected when the script timeout
         * was detected. */
        unprotectClient(run_ctx->original_client);
    }

    preventCommandPropagation(run_ctx->original_client);

    /*  unset curr_run_ctx so we will know there is no running script */
    curr_run_ctx = NULL;
}",252.0,269.0,1.0,4.0,18.0,11,8,8,3,2,11,2,2,1,5,,0,7,2,1,1,void
4310,337522,scriptIsRunning,1,scriptIsRunning,int scriptIsRunning (void),script.c,"int scriptIsRunning(void) {
    return curr_run_ctx != NULL;
}",272.0,274.0,1.0,1.0,3.0,1,1,2,2,17,1,1,1,0,0,,0,1,2,1,1,int
4311,337531,scriptCurrFunction,1,scriptCurrFunction,const char* scriptCurrFunction (void),script.c,"const char* scriptCurrFunction(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->funcname;
}",276.0,279.0,1.0,4.0,4.0,5,5,1,1,0,5,1,1,0,3,,0,2,2,1,1,const char*
4312,337555,scriptIsEval,1,scriptIsEval,int scriptIsEval (void),script.c,"int scriptIsEval(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->flags & SCRIPT_EVAL_MODE;
}",281.0,284.0,1.0,4.0,4.0,7,7,1,1,1,5,1,1,0,3,,0,2,2,1,1,int
4313,337585,scriptKill,1,scriptKill,"void scriptKill (client*,int)",script.c,"void scriptKill(client *c, int is_eval) {
    if (!curr_run_ctx) {
        addReplyError(c, ""-NOTBUSY No scripts in execution right now."");
        return;
    }
    if (mustObeyClient(curr_run_ctx->original_client)) {
        addReplyError(c,
                ""-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed."");
        return;
    }
    if (curr_run_ctx->flags & SCRIPT_WRITE_DIRTY) {
        addReplyError(c,
                ""-UNKILLABLE Sorry the script already executed write ""
                        ""commands against the dataset. You can either wait the ""
                        ""script termination or kill the server in a hard way ""
                        ""using the SHUTDOWN NOSAVE command."");
        return;
    }
    if (is_eval && !(curr_run_ctx->flags & SCRIPT_EVAL_MODE)) {
        /* Kill a function with 'SCRIPT KILL' is not allow */
        addReplyErrorObject(c, shared.slowscripterr);
        return;
    }
    if...",287.0,317.0,1.0,30.0,31.0,20,6,17,4,1,18,6,6,10,7,,0,12,4,2,2,void
4314,337678,scriptVerifyCommandArity,1,scriptVerifyCommandArity,"int scriptVerifyCommandArity (redisCommand*,int,sds*)",script.c,"static int scriptVerifyCommandArity(struct redisCommand *cmd, int argc, sds *err) {
    if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity))) {
        if (cmd)
            *err = sdsnew(""Wrong number of args calling Redis command from script"");
        else
            *err = sdsnew(""Unknown Redis command called from script"");
        return C_ERR;
    }
    return C_OK;
}",319.0,328.0,1.0,15.0,10.0,14,10,8,3,1,4,3,4,3,1,,0,4,6,3,3,int
4315,337732,scriptVerifyACL,1,scriptVerifyACL,"int scriptVerifyACL (client*,sds*)",script.c,"static int scriptVerifyACL(client *c, sds *err) {
    /* Check the ACLs. */
    int acl_errpos;
    int acl_retval = ACLCheckAllPerm(c, &acl_errpos);
    if (acl_retval != ACL_OK) {
        addACLLogEntry(c,acl_retval,ACL_LOG_CTX_LUA,acl_errpos,NULL,NULL);
        sds msg = getAclErrorMessage(acl_retval, c->user, c->cmd, c->argv[acl_errpos]->ptr, 0);
        *err = sdscatsds(sdsnew(""ACL failure in script: ""), msg);
        sdsfree(msg);
        return C_ERR;
    }
    return C_OK;
}",330.0,342.0,1.0,22.0,13.0,12,7,18,6,1,9,2,2,0,6,,0,7,4,2,2,int
4316,337799,scriptVerifyWriteCommandAllow,1,scriptVerifyWriteCommandAllow,"int scriptVerifyWriteCommandAllow (scriptRunCtx*,char**)",script.c,"static int scriptVerifyWriteCommandAllow(scriptRunCtx *run_ctx, char **err) {

    /* A write command, on an RO command or an RO script is rejected ASAP.
     * Note: For scripts, we consider may-replicate commands as write commands.
     * This also makes it possible to allow read-only scripts to be run during
     * CLIENT PAUSE WRITE. */
    if (run_ctx->flags & SCRIPT_READ_ONLY &&
        (run_ctx->c->cmd->flags & (CMD_WRITE|CMD_MAY_REPLICATE)))
    {
        *err = sdsnew(""Write commands are not allowed from read-only scripts."");
        return C_ERR;
    }

    /* The other checks below are on the server state and are only relevant for
     *  write commands, return if this is not a write command. */
    if (!(run_ctx->c->cmd->flags & CMD_WRITE))
        return C_OK;

    /* If the script already made a modification to the dataset, we can't
     * fail it on unpredictable error state. */
    if ((run_ctx->flags & SCRIPT_WRITE_DIRTY))
        return C_OK;

    /* Write commands...",344.0,394.0,1.0,25.0,51.0,45,11,16,5,1,12,7,7,7,7,,0,12,4,2,2,int
4317,337953,scriptVerifyOOM,1,scriptVerifyOOM,"int scriptVerifyOOM (scriptRunCtx*,char**)",script.c,"static int scriptVerifyOOM(scriptRunCtx *run_ctx, char **err) {
    if (run_ctx->flags & SCRIPT_ALLOW_OOM) {
        /* Allow running any command even if OOM reached */
        return C_OK;
    }

    /* If we reached the memory limit configured via maxmemory, commands that
     * could enlarge the memory usage are not allowed, but only if this is the
     * first write in the context of this script, otherwise we can't stop
     * in the middle. */

    if (server.maxmemory &&                            /* Maxmemory is actually enabled. */
        !mustObeyClient(run_ctx->original_client) &&   /* Don't care about mem for replicas or AOF. */
        !(run_ctx->flags & SCRIPT_WRITE_DIRTY) &&      /* Script had no side effects so far. */
        server.pre_command_oom_state &&                /* Detected OOM when script start. */
        (run_ctx->c->cmd->flags & CMD_DENYOOM))
    {
        *err = sdsdup(shared.oomerr->ptr);
        return C_ERR;
    }

    return C_OK;
}",396.0,418.0,1.0,25.0,23.0,25,9,8,4,1,6,3,3,5,2,,0,6,4,2,2,int
4318,338032,scriptVerifyClusterState,1,scriptVerifyClusterState,"int scriptVerifyClusterState (scriptRunCtx*,client*,client*,sds*)",script.c,"static int scriptVerifyClusterState(scriptRunCtx *run_ctx, client *c, client *original_c, sds *err) {
    if (!server.cluster_enabled || mustObeyClient(original_c)) {
        return C_OK;
    }
    /* If this is a Redis Cluster node, we need to make sure the script is not
     * trying to access non-local keys, with the exception of commands
     * received from our master or when loading the AOF back in memory. */
    int error_code;
    /* Duplicate relevant flags in the script client. */
    c->flags &= ~(CLIENT_READONLY | CLIENT_ASKING);
    c->flags |= original_c->flags & (CLIENT_READONLY | CLIENT_ASKING);
    int hashslot = -1;
    if (getNodeByQuery(c, c->cmd, c->argv, c->argc, &hashslot, &error_code) != server.cluster->myself) {
        if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) {
            *err = sdsnew(
                    ""Script attempted to execute a write command while the ""
                            ""cluster is down and readonly"");
        } else if (error_cod...",420.0,460.0,1.0,15.0,41.0,40,15,20,7,1,12,6,8,7,3,,0,12,8,4,4,int
4319,338208,scriptSetResp,1,scriptSetResp,"int scriptSetResp (scriptRunCtx*,int)",script.c,"int scriptSetResp(scriptRunCtx *run_ctx, int resp) {
    if (resp != 2 && resp != 3) {
        return C_ERR;
    }

    run_ctx->c->resp = resp;
    return C_OK;
}",463.0,470.0,1.0,15.0,8.0,7,5,4,2,1,1,2,2,0,0,,0,1,4,2,2,int
4320,338239,scriptSetRepl,1,scriptSetRepl,"int scriptSetRepl (scriptRunCtx*,int)",script.c,"int scriptSetRepl(scriptRunCtx *run_ctx, int repl) {
    if ((repl & ~(PROPAGATE_AOF | PROPAGATE_REPL)) != 0) {
        return C_ERR;
    }
    run_ctx->repl_flags = repl;
    return C_OK;
}",474.0,480.0,1.0,18.0,7.0,7,7,3,2,1,1,2,2,0,0,,0,1,4,2,2,int
4321,338273,scriptVerifyAllowStale,1,scriptVerifyAllowStale,"int scriptVerifyAllowStale (client*,sds*)",script.c,"static int scriptVerifyAllowStale(client *c, sds *err) {
    if (!server.masterhost) {
        /* Not a replica, stale is irrelevant */
        return C_OK;
    }

    if (server.repl_state == REPL_STATE_CONNECTED) {
        /* Connected to replica, stale is irrelevant */
        return C_OK;
    }

    if (server.repl_serve_stale_data == 1) {
        /* Disconnected from replica but allow to serve data */
        return C_OK;
    }

    if (c->cmd->flags & CMD_STALE) {
        /* Command is allow while stale */
        return C_OK;
    }

    /* On stale replica, can not run the command */
    *err = sdsnew(""Can not execute the command on a stale replica"");
    return C_ERR;
}",482.0,506.0,1.0,15.0,25.0,13,9,6,4,1,2,5,5,1,1,,0,2,4,2,2,int
4322,338338,scriptCall,1,scriptCall,"void scriptCall (scriptRunCtx*,sds*)",script.c,"void scriptCall(scriptRunCtx *run_ctx, sds *err) {
    client *c = run_ctx->c;

    /* Setup our fake client for command execution */
    c->user = run_ctx->original_client->user;

    /* Process module hooks */
    moduleCallCommandFilters(c);

    struct redisCommand *cmd = lookupCommand(c->argv, c->argc);
    c->cmd = c->lastcmd = c->realcmd = cmd;
    if (scriptVerifyCommandArity(cmd, c->argc, err) != C_OK) {
        goto error;
    }

    /* There are commands that are not allowed inside scripts. */
    if (!server.script_disable_deny_script && (cmd->flags & CMD_NOSCRIPT)) {
        *err = sdsnew(""This Redis command is not allowed from script"");
        goto error;
    }

    if (scriptVerifyAllowStale(c, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyACL(c, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyWriteCommandAllow(run_ctx, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyOOM(run_ctx, err) != C_OK) {
        goto error;
    }...",513.0,573.0,1.0,55.0,61.0,54,14,44,6,1,29,18,11,12,13,,0,25,4,2,2,void
4323,338573,scriptRunDuration,1,scriptRunDuration,long long scriptRunDuration (void),script.c,"long long scriptRunDuration(void) {
    serverAssert(scriptIsRunning());
    return elapsedMs(curr_run_ctx->start_time);
}",575.0,578.0,1.0,4.0,4.0,5,5,1,1,0,6,1,1,0,4,,0,2,2,1,1,long long
4324,338954,luaSaveOnRegistry,1,luaSaveOnRegistry,"void luaSaveOnRegistry (lua_State*,char*,void*)",script_lua.c,"void luaSaveOnRegistry(lua_State* lua, const char* name, void* ptr) {
    lua_pushstring(lua, name);
    if (ptr) {
        lua_pushlightuserdata(lua, ptr);
    } else {
        lua_pushnil(lua);
    }
    lua_settable(lua, LUA_REGISTRYINDEX);
}",159.0,167.0,1.0,1.0,9.0,0,0,7,4,5,0,2,2,0,0,,0,0,6,3,3,void
4325,338977,luaGetFromRegistry,1,luaGetFromRegistry,"void* luaGetFromRegistry (lua_State*,char*)",script_lua.c,"void* luaGetFromRegistry(lua_State* lua, const char* name) {
    lua_pushstring(lua, name);
    lua_gettable(lua, LUA_REGISTRYINDEX);

    if (lua_isnil(lua, -1)) {
        lua_pop(lua, 1); /* pops the value */
        return NULL;
    }
    /* must be light user data */
    serverAssert(lua_islightuserdata(lua, -1));

    void* ptr = (void*) lua_topointer(lua, -1);
    serverAssert(ptr);

    /* pops the value */
    lua_pop(lua, 1);

    return ptr;
}",172.0,190.0,1.0,4.0,19.0,13,6,14,5,8,2,2,2,0,2,,0,0,4,2,2,void*
4326,339114,redisProtocolToLuaType,1,redisProtocolToLuaType,"void redisProtocolToLuaType (lua_State*,char*)",script_lua.c,"static void redisProtocolToLuaType(lua_State *lua, char* reply) {
    ReplyParser parser = {.curr_location = reply, .callbacks = DefaultLuaTypeParserCallbacks};

    parseReply(&parser, lua);
}",232.0,236.0,1.0,1.0,5.0,5,3,7,6,1,2,1,1,0,1,,0,1,4,2,2,void
4327,339988,luaPushErrorBuff,1,luaPushErrorBuff,"void luaPushErrorBuff (lua_State*,sds)",script_lua.c,"void luaPushErrorBuff(lua_State *lua, sds err_buffer) {
    sds msg;
    sds error_code;

    /* If debugging is active and in step mode, log errors resulting from
     * Redis commands. */
    if (ldbIsEnabled()) {
        ldbLog(sdscatprintf(sdsempty(),""<error> %s"",err_buffer));
    }

    /* There are two possible formats for the received `error` string:
     * 1) ""-CODE msg"": in this case we remove the leading '-' since we don't store it as part of the lua error format.
     * 2) ""msg"": in this case we prepend a generic 'ERR' code since all error statuses need some error code.
     * We support format (1) so this function can reuse the error messages used in other places in redis.
     * We support format (2) so it'll be easy to pass descriptive errors to this function without worrying about format.
     */
    if (err_buffer[0] == '-') {
        /* derive error code from the message */
        char *err_msg = strstr(err_buffer, "" "");
        if (!err_msg) {
            msg = sd...",532.0,576.0,1.0,1.0,45.0,10,6,21,6,2,11,4,5,1,11,,0,7,4,2,2,void
4328,340088,luaPushError,1,luaPushError,"void luaPushError (lua_State*,char*)",script_lua.c,"void luaPushError(lua_State *lua, const char *error) {
    luaPushErrorBuff(lua, sdsnew(error));
}",578.0,580.0,1.0,1.0,3.0,0,0,2,2,24,2,1,1,0,2,,0,1,4,2,2,void
4329,340098,luaError,1,luaError,int luaError (lua_State*),script_lua.c,"int luaError(lua_State *lua) {
    return lua_error(lua);
}",586.0,588.0,1.0,1.0,3.0,0,0,1,1,19,0,1,1,0,0,,0,0,2,1,1,int
4330,340648,freeLuaRedisArgv,1,freeLuaRedisArgv,"void freeLuaRedisArgv (robj**,int,int)",script_lua.c,"void freeLuaRedisArgv(robj **argv, int argc, int argv_len) {
    int j;
    for (j = 0; j < argc; j++) {
        robj *o = argv[j];

        /* Try to cache the object in the lua_args_cached_objects array.
         * The object must be small, SDS-encoded, and with refcount = 1
         * (we must be the only owner) for us to cache it. */
        if (j < LUA_CMD_OBJCACHE_SIZE &&
            o->refcount == 1 &&
            (o->encoding == OBJ_ENCODING_RAW ||
             o->encoding == OBJ_ENCODING_EMBSTR) &&
            sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)
        {
            sds s = o->ptr;
            if (lua_args_cached_objects[j]) decrRefCount(lua_args_cached_objects[j]);
            lua_args_cached_objects[j] = o;
            lua_args_cached_objects_len[j] = sdsalloc(s);
        } else {
            decrRefCount(o);
        }
    }
    if (argv != lua_argv || argv_len != lua_argv_size) {
        /* The command changed argv, scrap the cache and start over. */
        zfr...",858.0,886.0,1.0,16.0,29.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
4331,340673,luaArgsToRedisArgv,1,luaArgsToRedisArgv,"robj luaArgsToRedisArgv (lua_State*,int*,int*)",script_lua.c,"static robj **luaArgsToRedisArgv(lua_State *lua, int *argc, int *argv_len) {
    int j;
    /* Require at least one argument */
    *argc = lua_gettop(lua);
    if (*argc == 0) {
        luaPushError(lua, ""Please specify at least one argument for this redis lib call"");
        return NULL;
    }

    /* Build the arguments vector (reuse a cached argv from last call) */
    if (lua_argv_size < *argc) {
        lua_argv = zrealloc(lua_argv,sizeof(robj*)* *argc);
        lua_argv_size = *argc;
    }
    *argv_len = lua_argv_size;

    for (j = 0; j < *argc; j++) {
        char *obj_s;
        size_t obj_len;
        char dbuf[64];

        if (lua_type(lua,j+1) == LUA_TNUMBER) {
            /* We can't use lua_tolstring() for number -> string conversion
             * since Lua uses a format specifier that loses precision. */
            lua_Number num = lua_tonumber(lua,j+1);
            obj_len = fpconv_dtoa((double)num, dbuf);
            dbuf[obj_len] = '\0';
            obj_s = db...",796.0,856.0,1.0,16.0,61.0,44,13,62,16,2,19,7,9,3,5,,0,15,6,3,3,robj
4332,340972,luaRedisGenericCommand,1,luaRedisGenericCommand,"int luaRedisGenericCommand (lua_State*,int)",script_lua.c,"static int luaRedisGenericCommand(lua_State *lua, int raise_error) {
    int j;
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    sds err = NULL;
    client* c = rctx->c;
    sds reply;

    c->argv = luaArgsToRedisArgv(lua, &c->argc, &c->argv_len);
    if (c->argv == NULL) {
        return raise_error ? luaError(lua) : 1;
    }

    static int inuse = 0;   /* Recursive calls detection. */

    /* By using Lua debug hooks it is possible to trigger a recursive call
     * to luaRedisGenericCommand(), which normally should never happen.
     * To make this function reentrant is futile and makes it slower, but
     * we should at least detect such a misuse, and abort. */
    if (inuse) {
        char *recursion_warning =
                ""luaRedisGenericCommand() recursive call detected. ""
                ""Are you doing funny stuff with Lua debug hooks?"";
        serverLog(LL_WARNING,""%s"",re...",888.0,992.0,1.0,49.0,105.0,71,18,75,12,2,44,14,15,9,20,,0,30,4,2,2,int
4333,341401,luaRedisCallCommand,1,luaRedisCallCommand,int luaRedisCallCommand (lua_State*),script_lua.c,"static int luaRedisCallCommand(lua_State *lua) {
    return luaRedisGenericCommand(lua,1);
}",1024.0,1026.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
4334,341410,luaRedisPCallCommand,1,luaRedisPCallCommand,int luaRedisPCallCommand (lua_State*),script_lua.c,"static int luaRedisPCallCommand(lua_State *lua) {
    return luaRedisGenericCommand(lua,0);
}",1029.0,1031.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
4335,341419,luaRedisSha1hexCommand,1,luaRedisSha1hexCommand,int luaRedisSha1hexCommand (lua_State*),script_lua.c,"static int luaRedisSha1hexCommand(lua_State *lua) {
    int argc = lua_gettop(lua);
    char digest[41];
    size_t len;
    char *s;

    if (argc != 1) {
        luaPushError(lua, ""wrong number of arguments"");
        return luaError(lua);
    }

    s = (char*)lua_tolstring(lua,1,&len);
    sha1hex(digest,s,len);
    lua_pushstring(lua,digest);
    return 1;
}",1035.0,1050.0,1.0,1.0,16.0,5,4,13,5,0,3,2,2,0,3,,0,0,2,1,1,int
4336,341461,luaRedisReturnSingleFieldTable,1,luaRedisReturnSingleFieldTable,"int luaRedisReturnSingleFieldTable (lua_State*,char*)",script_lua.c,"static int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
        luaPushError(lua, ""wrong number or type of arguments"");
        return 1;
    }

    lua_newtable(lua);
    lua_pushstring(lua, field);
    lua_pushvalue(lua, -3);
    lua_settable(lua, -3);
    return 1;
}",1059.0,1070.0,1.0,1.0,12.0,6,3,9,3,1,1,2,2,0,1,,0,0,4,2,2,int
4337,341500,luaRedisErrorReplyCommand,1,luaRedisErrorReplyCommand,int luaRedisErrorReplyCommand (lua_State*),script_lua.c,"static int luaRedisErrorReplyCommand(lua_State *lua) {
    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
        luaPushError(lua, ""wrong number or type of arguments"");
        return 1;
    }

    /* add '-' if not exists */
    const char *err = lua_tostring(lua, -1);
    sds err_buff = NULL;
    if (err[0] != '-') {
        err_buff = sdscatfmt(sdsempty(), ""-%s"", err);
    } else {
        err_buff = sdsnew(err);
    }
    luaPushErrorBuff(lua, err_buff);
    return 1;
}",1073.0,1089.0,1.0,1.0,17.0,10,5,13,5,0,4,3,3,0,4,,0,2,2,1,1,int
4338,341558,luaRedisStatusReplyCommand,1,luaRedisStatusReplyCommand,int luaRedisStatusReplyCommand (lua_State*),script_lua.c,"static int luaRedisStatusReplyCommand(lua_State *lua) {
    return luaRedisReturnSingleFieldTable(lua,""ok"");
}",1092.0,1094.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
4339,341567,luaRedisSetReplCommand,1,luaRedisSetReplCommand,int luaRedisSetReplCommand (lua_State*),script_lua.c,"static int luaRedisSetReplCommand(lua_State *lua) {
    int flags, argc = lua_gettop(lua);

    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */

    if (argc != 1) {
        luaPushError(lua, ""redis.set_repl() requires one argument."");
         return luaError(lua);
    }

    flags = lua_tonumber(lua,-1);
    if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {
        luaPushError(lua, ""Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE."");
        return luaError(lua);
    }

    scriptSetRepl(rctx, flags);
    return 0;
}",1100.0,1119.0,1.0,49.0,20.0,13,10,16,4,0,7,3,3,0,7,,0,1,2,1,1,int
4340,341643,luaRedisAclCheckCmdPermissionsCommand,1,luaRedisAclCheckCmdPermissionsCommand,int luaRedisAclCheckCmdPermissionsCommand (lua_State*),script_lua.c,"static int luaRedisAclCheckCmdPermissionsCommand(lua_State *lua) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    int raise_error = 0;

    int argc, argv_len;
    robj **argv = luaArgsToRedisArgv(lua, &argc, &argv_len);

    /* Require at least one argument */
    if (argv == NULL) return luaError(lua);

    /* Find command */
    struct redisCommand *cmd;
    if ((cmd = lookupCommand(argv, argc)) == NULL) {
        luaPushError(lua, ""Invalid command passed to redis.acl_check_cmd()"");
        raise_error = 1;
    } else {
        int keyidxptr;
        if (ACLCheckAllUserCommandPerm(rctx->original_client->user, cmd, argv, argc, &keyidxptr) != ACL_OK) {
            lua_pushboolean(lua, 0);
        } else {
            lua_pushboolean(lua, 1);
        }
    }

    freeLuaRedisArgv(argv, argc, argv_len);
    if (raise_error)
        return luaError(lua);
    else
        return 1;
}",1124.0,1154.0,1.0,49.0,31.0,13,7,23,8,0,8,4,4,1,8,,0,3,2,1,1,int
4341,341752,luaLogCommand,1,luaLogCommand,int luaLogCommand (lua_State*),script_lua.c,"static int luaLogCommand(lua_State *lua) {
    int j, argc = lua_gettop(lua);
    int level;
    sds log;

    if (argc < 2) {
        luaPushError(lua, ""redis.log() requires two arguments or more."");
        return luaError(lua);
    } else if (!lua_isnumber(lua,-argc)) {
        luaPushError(lua, ""First argument must be a number (log level)."");
        return luaError(lua);
    }
    level = lua_tonumber(lua,-argc);
    if (level < LL_DEBUG || level > LL_WARNING) {
        luaPushError(lua, ""Invalid debug level."");
        return luaError(lua);
    }
    if (level < server.verbosity) return 0;

    /* Glue together all the arguments */
    log = sdsempty();
    for (j = 1; j < argc; j++) {
        size_t len;
        char *s;

        s = (char*)lua_tolstring(lua,(-argc)+j,&len);
        if (s) {
            if (j != 1) log = sdscatlen(log,"" "",1);
            log = sdscatlen(log,s,len);
        }
    }
    serverLogRaw(level,log);
    sdsfree(log);
    return 0;
}",1158.0,1192.0,1.0,16.0,35.0,20,10,34,8,0,9,7,10,0,9,,0,3,2,1,1,int
4342,341880,luaSetResp,1,luaSetResp,int luaSetResp (lua_State*),script_lua.c,"static int luaSetResp(lua_State *lua) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    int argc = lua_gettop(lua);

    if (argc != 1) {
        luaPushError(lua, ""redis.setresp() requires one argument."");
        return luaError(lua);
    }

    int resp = lua_tonumber(lua,-argc);
    if (resp != 2 && resp != 3) {
        luaPushError(lua, ""RESP version must be 2 or 3."");
        return luaError(lua);
    }
    scriptSetResp(rctx, resp);
    return 0;
}",1195.0,1212.0,1.0,49.0,18.0,12,8,18,4,0,7,3,3,0,7,,0,1,2,1,1,int
4343,341951,luaLoadLib,1,luaLoadLib,"void luaLoadLib (lua_State*,char*,lua_CFunction)",script_lua.c,"static void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
  lua_pushcfunction(lua, luafunc);
  lua_pushstring(lua, libname);
  lua_call(lua, 1, 0);
}",1218.0,1222.0,1.0,1.0,5.0,0,0,5,3,9,0,1,1,0,0,,0,0,6,3,3,void
4344,341992,luaLoadLibraries,1,luaLoadLibraries,void luaLoadLibraries (lua_State*),script_lua.c,"static void luaLoadLibraries(lua_State *lua) {
    luaLoadLib(lua, """", luaopen_base);
    luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);
    luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);
    luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);
    luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);
    luaLoadLib(lua, ""cjson"", luaopen_cjson);
    luaLoadLib(lua, ""struct"", luaopen_struct);
    luaLoadLib(lua, ""cmsgpack"", luaopen_cmsgpack);
    luaLoadLib(lua, ""bit"", luaopen_bit);

#if 0 /* Stuff that we don't load currently, for sandboxing concerns. */
    luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
    luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
#endif
}",1229.0,1244.0,1.0,1.0,16.0,0,0,22,14,1,9,1,1,0,9,,0,0,2,1,1,void
4345,342033,luaGetStringSds,1,luaGetStringSds,"sds luaGetStringSds (lua_State*,int)",script_lua.c,"sds luaGetStringSds(lua_State *lua, int index) {
    if (!lua_isstring(lua, index)) {
        return NULL;
    }

    size_t len;
    const char *str = lua_tolstring(lua, index, &len);
    sds str_sds = sdsnewlen(str, len);
    return str_sds;
}",1248.0,1257.0,1.0,1.0,10.0,4,3,11,6,2,1,2,2,0,1,,0,1,4,2,2,sds
4346,342064,luaProtectedTableError,1,luaProtectedTableError,int luaProtectedTableError (lua_State*),script_lua.c,"static int luaProtectedTableError(lua_State *lua) {
    int argc = lua_gettop(lua);
    if (argc != 2) {
        serverLog(LL_WARNING, ""malicious code trying to call luaProtectedTableError with wrong arguments"");
        luaL_error(lua, ""Wrong number of arguments to luaProtectedTableError"");
    }
    if (!lua_isstring(lua, -1) && !lua_isnumber(lua, -1)) {
        luaL_error(lua, ""Second argument to luaProtectedTableError must be a string or number"");
    }
    const char *variable_name = lua_tostring(lua, -1);
    luaL_error(lua, ""Script attempted to access nonexistent global variable '%s'"", variable_name);
    return 0;
}",1259.0,1271.0,1.0,8.0,13.0,12,8,12,4,0,1,3,3,0,1,,0,0,2,1,1,int
4347,342129,luaSetErrorMetatable,1,luaSetErrorMetatable,void luaSetErrorMetatable (lua_State*),script_lua.c,"void luaSetErrorMetatable(lua_State *lua) {
    lua_newtable(lua); /* push metatable */
    lua_pushcfunction(lua, luaProtectedTableError); /* push get error handler */
    lua_setfield(lua, -2, ""__index"");
    lua_setmetatable(lua, -2);
}",1280.0,1285.0,1.0,1.0,6.0,2,1,4,1,4,0,1,1,0,0,,0,0,2,1,1,void
4348,342148,luaNewIndexAllowList,1,luaNewIndexAllowList,int luaNewIndexAllowList (lua_State*),script_lua.c,"static int luaNewIndexAllowList(lua_State *lua) {
    int argc = lua_gettop(lua);
    if (argc != 3) {
        serverLog(LL_WARNING, ""malicious code trying to call luaNewIndexAllowList with wrong arguments"");
        luaL_error(lua, ""Wrong number of arguments to luaNewIndexAllowList"");
    }
    if (!lua_istable(lua, -3)) {
        luaL_error(lua, ""first argument to luaNewIndexAllowList must be a table"");
    }
    if (!lua_isstring(lua, -2) && !lua_isnumber(lua, -2)) {
        luaL_error(lua, ""Second argument to luaNewIndexAllowList must be a string or number"");
    }
    const char *variable_name = lua_tostring(lua, -2);
    /* check if the key is in our allow list */

    char ***allow_l = allow_lists;
    for (; *allow_l ; ++allow_l){
        char **c = *allow_l;
        for (; *c ; ++c) {
            if (strcmp(*c, variable_name) == 0) {
                break;
            }
        }
        if (*c) {
            break;
        }
    }
    if (!*allow_l) {
        /* Search the...",1287.0,1330.0,1.0,8.0,44.0,33,10,30,8,0,4,15,20,0,2,,0,2,2,1,1,int
4349,342311,luaSetAllowListProtection,1,luaSetAllowListProtection,void luaSetAllowListProtection (lua_State*),script_lua.c,"void luaSetAllowListProtection(lua_State *lua) {
    lua_newtable(lua); /* push metatable */
    lua_pushcfunction(lua, luaNewIndexAllowList); /* push get error handler */
    lua_setfield(lua, -2, ""__newindex"");
    lua_setmetatable(lua, -2);
}",1338.0,1343.0,1.0,1.0,6.0,2,1,4,1,1,0,1,1,0,0,,0,0,2,1,1,void
4350,342330,luaSetTableProtectionRecursively,1,luaSetTableProtectionRecursively,void luaSetTableProtectionRecursively (lua_State*),script_lua.c,"void luaSetTableProtectionRecursively(lua_State *lua) {
    /* This protect us from a loop in case we already visited the table
     * For example, globals has '_G' key which is pointing back to globals. */
    if (lua_isreadonlytable(lua, -1)) {
        return;
    }

    /* protect the current table */
    lua_enablereadonlytable(lua, -1, 1);

    lua_checkstack(lua, 2);
    lua_pushnil(lua); /* Use nil to start iteration. */
    while (lua_next(lua,-2)) {
        /* Stack now: table, key, value */
        if (lua_istable(lua, -1)) {
            luaSetTableProtectionRecursively(lua);
        }
        lua_pop(lua, 1);
    }

    /* protect the metatable if exists */
    if (lua_getmetatable(lua, -1)) {
        luaSetTableProtectionRecursively(lua);
        lua_pop(lua, 1); /* pop the metatable */
    }
}",1348.0,1373.0,1.0,1.0,26.0,5,1,11,1,3,0,5,6,0,0,,0,0,2,1,1,void
4351,342380,luaRegisterVersion,1,luaRegisterVersion,void luaRegisterVersion (lua_State*),script_lua.c,"void luaRegisterVersion(lua_State* lua) {
    lua_pushstring(lua,""REDIS_VERSION_NUM"");
    lua_pushnumber(lua,REDIS_VERSION_NUM);
    lua_settable(lua,-3);

    lua_pushstring(lua,""REDIS_VERSION"");
    lua_pushstring(lua,REDIS_VERSION);
    lua_settable(lua,-3);
}",1375.0,1383.0,1.0,23.0,9.0,2,1,6,1,2,0,1,1,0,0,,0,0,2,1,1,void
4352,342409,luaRegisterLogFunction,1,luaRegisterLogFunction,void luaRegisterLogFunction (lua_State*),script_lua.c,"void luaRegisterLogFunction(lua_State* lua) {
    /* redis.log and log levels. */
    lua_pushstring(lua,""log"");
    lua_pushcfunction(lua,luaLogCommand);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_DEBUG"");
    lua_pushnumber(lua,LL_DEBUG);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_VERBOSE"");
    lua_pushnumber(lua,LL_VERBOSE);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_NOTICE"");
    lua_pushnumber(lua,LL_NOTICE);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_WARNING"");
    lua_pushnumber(lua,LL_WARNING);
    lua_settable(lua,-3);
}",1385.0,1406.0,1.0,23.0,22.0,5,1,15,1,2,0,1,1,0,0,,0,0,2,1,1,void
4353,342472,luaRegisterRedisAPI,1,luaRegisterRedisAPI,void luaRegisterRedisAPI (lua_State*),script_lua.c,"void luaRegisterRedisAPI(lua_State* lua) {
    lua_pushvalue(lua, LUA_GLOBALSINDEX);
    luaSetAllowListProtection(lua);
    lua_pop(lua, 1);

    luaLoadLibraries(lua);

    lua_pushcfunction(lua,luaRedisPcall);
    lua_setglobal(lua, ""pcall"");

    /* Register the redis commands table and fields */
    lua_newtable(lua);

    /* redis.call */
    lua_pushstring(lua,""call"");
    lua_pushcfunction(lua,luaRedisCallCommand);
    lua_settable(lua,-3);

    /* redis.pcall */
    lua_pushstring(lua,""pcall"");
    lua_pushcfunction(lua,luaRedisPCallCommand);
    lua_settable(lua,-3);

    luaRegisterLogFunction(lua);

    luaRegisterVersion(lua);

    /* redis.setresp */
    lua_pushstring(lua,""setresp"");
    lua_pushcfunction(lua,luaSetResp);
    lua_settable(lua,-3);

    /* redis.sha1hex */
    lua_pushstring(lua, ""sha1hex"");
    lua_pushcfunction(lua, luaRedisSha1hexCommand);
    lua_settable(lua, -3);

    /* redis.error_reply and redis.status_reply */
    lua_pushstring(lua, ""error_r...",1408.0,1498.0,1.0,23.0,91.0,16,2,60,4,2,4,1,1,0,4,,0,0,2,1,1,void
4354,342674,luaCreateArray,1,luaCreateArray,"void luaCreateArray (lua_State*,robj**,int)",script_lua.c,"static void luaCreateArray(lua_State *lua, robj **elev, int elec) {
    int j;

    lua_newtable(lua);
    for (j = 0; j < elec; j++) {
        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));
        lua_rawseti(lua,-2,j+1);
    }
}",1502.0,1510.0,1.0,1.0,9.0,9,7,11,4,2,1,2,2,0,1,,0,0,6,3,3,void
4355,342826,luaMaskCountHook,1,luaMaskCountHook,"void luaMaskCountHook (lua_State*,lua_Debug*)",script_lua.c,"static void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
    UNUSED(ar);
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    if (scriptInterrupt(rctx) == SCRIPT_KILL) {
        serverLog(LL_NOTICE,""Lua script killed by user with SCRIPT KILL."");

        /*
         * Set the hook to invoke all the time so the user
         * will not be able to catch the error with pcall and invoke
         * pcall again which will prevent the script from ever been killed
         */
        lua_sethook(lua, luaMaskCountHook, LUA_MASKLINE, 0);

        luaPushError(lua,""Script killed by user with SCRIPT KILL..."");
        luaError(lua);
    }
}",1556.0,1573.0,1.0,4.0,18.0,10,9,12,5,0,6,2,2,1,6,,0,2,4,2,2,void
4356,342897,luaErrorInformationDiscard,1,luaErrorInformationDiscard,void luaErrorInformationDiscard (errorInfo*),script_lua.c,"void luaErrorInformationDiscard(errorInfo *err_info) {
    if (err_info->msg) sdsfree(err_info->msg);
    if (err_info->source) sdsfree(err_info->source);
    if (err_info->line) sdsfree(err_info->line);
}",1575.0,1579.0,1.0,1.0,5.0,6,1,6,1,1,9,4,4,3,3,,0,6,2,1,1,void
4357,342929,luaExtractErrorInformation,1,luaExtractErrorInformation,"void luaExtractErrorInformation (lua_State*,errorInfo*)",script_lua.c,"void luaExtractErrorInformation(lua_State *lua, errorInfo *err_info) {
    if (lua_isstring(lua, -1)) {
        err_info->msg = sdscatfmt(sdsempty(), ""ERR %s"", lua_tostring(lua, -1));
        err_info->line = NULL;
        err_info->source = NULL;
        err_info->ignore_err_stats_update = 0;
        return;
    }

    lua_getfield(lua, -1, ""err"");
    if (lua_isstring(lua, -1)) {
        err_info->msg = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""source"");
    if (lua_isstring(lua, -1)) {
        err_info->source = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""line"");
    if (lua_isstring(lua, -1)) {
        err_info->line = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""ignore_error_stats_update"");
    if (lua_isboolean(lua, -1)) {
        err_info->ignore_err_stats_update = lua_toboolean(lua, -1);
    }
    lua_pop(lua, 1);
}",1581.0,1613.0,1.0,1.0,33.0,30,3,28,3,1,13,6,6,0,5,,0,13,4,2,2,void
4358,343059,luaCallFunction,1,luaCallFunction,"void luaCallFunction (scriptRunCtx*,lua_State*,robj**,size_t,robj**,size_t,int)",script_lua.c,"void luaCallFunction(scriptRunCtx* run_ctx, lua_State *lua, robj** keys, size_t nkeys, robj** args, size_t nargs, int debug_enabled) {
    client* c = run_ctx->original_client;
    int delhook = 0;

    /* We must set it before we set the Lua hook, theoretically the
     * Lua hook might be called wheneven we run any Lua instruction
     * such as 'luaSetGlobalArray' and we want the run_ctx to be available
     * each time the Lua hook is invoked. */
    luaSaveOnRegistry(lua, REGISTRY_RUN_CTX_NAME, run_ctx);

    if (server.busy_reply_threshold > 0 && !debug_enabled) {
        lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
        delhook = 1;
    } else if (debug_enabled) {
        lua_sethook(lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);
        delhook = 1;
    }

    /* Populate the argv and keys table accordingly to the arguments that
     * EVAL received. */
    luaCreateArray(lua,keys,nkeys);
    /* On eval, keys and arguments are globals. */
    if (run_ct...",1615.0,1718.0,1.0,27.0,104.0,30,11,52,17,2,10,10,13,3,5,,0,5,14,7,7,void
4359,343344,luaMemory,1,luaMemory,unsigned long luaMemory (lua_State*),script_lua.c,"unsigned long luaMemory(lua_State *lua) {
    return lua_gc(lua, LUA_GCCOUNT, 0) * 1024LL;
}",1720.0,1722.0,1.0,1.0,3.0,1,1,2,2,2,0,1,1,0,0,,0,0,2,1,1,unsigned long
4360,343508,sdsHdrSize,1,sdsHdrSize,int sdsHdrSize (char),sds.c,"static inline int sdsHdrSize(char type) {
    switch(type&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return sizeof(struct sdshdr5);
        case SDS_TYPE_8:
            return sizeof(struct sdshdr8);
        case SDS_TYPE_16:
            return sizeof(struct sdshdr16);
        case SDS_TYPE_32:
            return sizeof(struct sdshdr32);
        case SDS_TYPE_64:
            return sizeof(struct sdshdr64);
    }
    return 0;
}",45.0,59.0,1.0,16.0,15.0,6,2,6,6,8,0,2,2,0,0,,0,0,2,1,1,int
4361,343557,sdsReqType,1,sdsReqType,char sdsReqType (size_t),sds.c,"static inline char sdsReqType(size_t string_size) {
    if (string_size < 1<<5)
        return SDS_TYPE_5;
    if (string_size < 1<<8)
        return SDS_TYPE_8;
    if (string_size < 1<<16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size < 1ll<<32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}",61.0,75.0,1.0,15.0,15.0,8,2,4,1,3,0,5,5,0,0,,0,0,2,1,1,char
4362,343610,sdsTypeMaxSize,1,sdsTypeMaxSize,size_t sdsTypeMaxSize (char),sds.c,"static inline size_t sdsTypeMaxSize(char type) {
    if (type == SDS_TYPE_5)
        return (1<<5) - 1;
    if (type == SDS_TYPE_8)
        return (1<<8) - 1;
    if (type == SDS_TYPE_16)
        return (1<<16) - 1;
#if (LONG_MAX == LLONG_MAX)
    if (type == SDS_TYPE_32)
        return (1ll<<32) - 1;
#endif
    return -1; /* this is equivalent to the max SDS_TYPE_64 or SDS_TYPE_32 */
}",77.0,89.0,1.0,16.0,13.0,13,4,4,1,4,0,5,5,0,0,,0,0,2,1,1,size_t
4363,343670,_sdsnewlen,1,_sdsnewlen,"sds _sdsnewlen (void*,size_t,int)",sds.c,"sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) {
    void *sh;
    sds s;
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
    int hdrlen = sdsHdrSize(type);
    unsigned char *fp; /* flags pointer. */
    size_t usable;

    assert(initlen + hdrlen + 1 > initlen); /* Catch size_t overflow */
    sh = trymalloc?
        s_trymalloc_usable(hdrlen+initlen+1, &usable) :
        s_malloc_usable(hdrlen+initlen+1, &usable);
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        memset(sh, 0, hdrlen+initlen+1);
    s = (char*)sh+hdrlen;
    fp = ((unsigned char*)s)-1;
    usable = usable-hdrlen-1;
    if (usable > sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    switch(type) {
        case SDS_TYPE_5: {
            *fp = type | (initlen << S...",104.0,167.0,1.0,16.0,64.0,78,15,89,19,2,15,12,7,2,6,,0,15,6,3,3,sds
4364,343962,sdsnewlen,1,sdsnewlen,"sds sdsnewlen (void*,size_t)",sds.c,"sds sdsnewlen(const void *init, size_t initlen) {
    return _sdsnewlen(init, initlen, 0);
}",169.0,171.0,1.0,1.0,3.0,0,0,2,2,61,1,1,1,0,1,,0,0,4,2,2,sds
4365,343973,sdstrynewlen,1,sdstrynewlen,"sds sdstrynewlen (void*,size_t)",sds.c,"sds sdstrynewlen(const void *init, size_t initlen) {
    return _sdsnewlen(init, initlen, 1);
}",173.0,175.0,1.0,1.0,3.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,sds
4366,343984,sdsempty,1,sdsempty,sds sdsempty (void),sds.c,"sds sdsempty(void) {
    return sdsnewlen("""",0);
}",179.0,181.0,1.0,1.0,3.0,0,0,0,0,165,1,1,1,0,1,,0,0,2,1,1,sds
4367,343993,sdsnew,1,sdsnew,sds sdsnew (char*),sds.c,"sds sdsnew(const char *init) {
    size_t initlen = (init == NULL) ? 0 : strlen(init);
    return sdsnewlen(init, initlen);
}",184.0,187.0,1.0,1.0,4.0,3,3,6,3,177,1,1,1,0,1,,0,0,2,1,1,sds
4368,344012,sdsdup,1,sdsdup,sds sdsdup (sds),sds.c,"sds sdsdup(const sds s) {
    return sdsnewlen(s, sdslen(s));
}",190.0,192.0,1.0,1.0,3.0,0,0,2,1,49,2,1,1,0,2,,0,1,2,1,1,sds
4369,344022,sdsfree,1,sdsfree,void sdsfree (sds),sds.c,"void sdsfree(sds s) {
    if (s == NULL) return;
    s_free((char*)s-sdsHdrSize(s[-1]));
}",195.0,198.0,1.0,4.0,4.0,5,5,4,2,343,2,2,2,0,2,,0,1,2,1,1,void
4370,344045,sdsupdatelen,1,sdsupdatelen,void sdsupdatelen (sds),sds.c,"void sdsupdatelen(sds s) {
    size_t reallen = strlen(s);
    sdssetlen(s, reallen);
}",214.0,217.0,1.0,1.0,4.0,1,1,4,2,1,1,1,1,0,1,,0,0,2,1,1,void
4371,344058,sdsclear,1,sdsclear,void sdsclear (sds),sds.c,"void sdsclear(sds s) {
    sdssetlen(s, 0);
    s[0] = '\0';
}",223.0,226.0,1.0,1.0,4.0,2,2,2,1,7,1,1,1,0,1,,0,0,2,1,1,void
4372,344071,_sdsMakeRoomFor,1,_sdsMakeRoomFor,"sds _sdsMakeRoomFor (sds,size_t,int)",sds.c,"sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {
    void *sh, *newsh;
    size_t avail = sdsavail(s);
    size_t len, newlen, reqlen;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen;
    size_t usable;

    /* Return ASAP if there is enough space left. */
    if (avail >= addlen) return s;

    len = sdslen(s);
    sh = (char*)s-sdsHdrSize(oldtype);
    reqlen = newlen = (len+addlen);
    assert(newlen > len);   /* Catch size_t overflow */
    if (greedy == 1) {
        if (newlen < SDS_MAX_PREALLOC)
            newlen *= 2;
        else
            newlen += SDS_MAX_PREALLOC;
    }

    type = sdsReqType(newlen);

    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;

    hdrlen = sdsHdrSize(type);
    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */
    if (ol...",240.0,291.0,1.0,33.0,52.0,39,14,53,14,2,9,8,10,1,9,,0,8,6,3,3,sds
4373,344291,sdsMakeRoomFor,1,sdsMakeRoomFor,"sds sdsMakeRoomFor (sds,size_t)",sds.c,"sds sdsMakeRoomFor(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 1);
}",295.0,297.0,1.0,1.0,3.0,0,0,2,2,11,1,1,1,0,1,,0,0,4,2,2,sds
4374,344302,sdsMakeRoomForNonGreedy,1,sdsMakeRoomForNonGreedy,"sds sdsMakeRoomForNonGreedy (sds,size_t)",sds.c,"sds sdsMakeRoomForNonGreedy(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 0);
}",300.0,302.0,1.0,1.0,3.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,sds
4375,344313,sdsRemoveFreeSpace,1,sdsRemoveFreeSpace,"sds sdsRemoveFreeSpace (sds,int)",sds.c,"sds sdsRemoveFreeSpace(sds s, int would_regrow) {
    return sdsResize(s, sdslen(s), would_regrow);
}",310.0,312.0,1.0,1.0,3.0,0,0,3,2,2,2,1,1,0,2,,0,1,4,2,2,sds
4376,344325,sdsResize,1,sdsResize,"sds sdsResize (sds,size_t,int)",sds.c,"sds sdsResize(sds s, size_t size, int would_regrow) {
    void *sh, *newsh;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);
    size_t len = sdslen(s);
    sh = (char*)s-oldhdrlen;

    /* Return ASAP if the size is already good. */
    if (sdsalloc(s) == size) return s;

    /* Truncate len if needed. */
    if (size < len) len = size;

    /* Check what would be the minimum SDS header that is just good enough to
     * fit this string. */
    type = sdsReqType(size);
    if (would_regrow) {
        /* Don't use type 5, it is not good for strings that are expected to grow back. */
        if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    }
    hdrlen = sdsHdrSize(type);

    /* If the type is the same, or can hold the size in it with low overhead
     * (larger than SDS_TYPE_8), we just realloc(), letting the allocator
     * to do the copy only if really needed. Otherwise if the change is
     * huge, we manually reallocate the string ...",323.0,377.0,1.0,33.0,55.0,38,14,54,14,2,8,7,9,1,8,,0,6,6,3,3,sds
4377,344522,sdsAllocSize,1,sdsAllocSize,size_t sdsAllocSize (sds),sds.c,"size_t sdsAllocSize(sds s) {
    size_t alloc = sdsalloc(s);
    return sdsHdrSize(s[-1])+alloc+1;
}",386.0,389.0,1.0,1.0,4.0,5,4,4,2,2,2,1,1,0,2,,0,1,2,1,1,size_t
4378,344542,sdsAllocPtr,1,sdsAllocPtr,void* sdsAllocPtr (sds),sds.c,"void *sdsAllocPtr(sds s) {
    return (void*) (s-sdsHdrSize(s[-1]));
}",393.0,395.0,1.0,1.0,3.0,4,4,2,1,2,1,1,1,0,1,,0,0,2,1,1,void*
4379,344557,sdsIncrLen,1,sdsIncrLen,"void sdsIncrLen (sds,ssize_t)",sds.c,"void sdsIncrLen(sds s, ssize_t incr) {
    unsigned char flags = s[-1];
    size_t len;
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5: {
            unsigned char *fp = ((unsigned char*)s)-1;
            unsigned char oldlen = SDS_TYPE_5_LEN(flags);
            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));
            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);
            len = oldlen+incr;
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
            len = (sh->len += incr);
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
            len = (sh->len += incr);
            break;
        }
        case SDS_TYPE_32: {
         ...",420.0,459.0,1.0,17.0,40.0,110,19,79,15,4,16,7,2,0,0,,0,16,4,2,2,void
4380,344861,sdsgrowzero,1,sdsgrowzero,"sds sdsgrowzero (sds,size_t)",sds.c,"sds sdsgrowzero(sds s, size_t len) {
    size_t curlen = sdslen(s);

    if (len <= curlen) return s;
    s = sdsMakeRoomFor(s,len-curlen);
    if (s == NULL) return NULL;

    /* Make sure added region doesn't contain garbage */
    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
    sdssetlen(s, len);
    return s;
}",466.0,477.0,1.0,1.0,12.0,8,5,19,4,0,3,3,3,0,3,,0,2,4,2,2,sds
4381,344908,sdscatlen,1,sdscatlen,"sds sdscatlen (sds,void*,size_t)",sds.c,"sds sdscatlen(sds s, const void *t, size_t len) {
    size_t curlen = sdslen(s);

    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    memcpy(s+curlen, t, len);
    sdssetlen(s, curlen+len);
    s[curlen+len] = '\0';
    return s;
}",484.0,493.0,1.0,1.0,10.0,8,4,19,5,131,3,2,2,0,3,,0,2,6,3,3,sds
4382,344952,sdscat,1,sdscat,"sds sdscat (sds,char*)",sds.c,"sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}",499.0,501.0,1.0,1.0,3.0,0,0,3,2,108,1,1,1,0,1,,0,0,4,2,2,sds
4383,344964,sdscatsds,1,sdscatsds,"sds sdscatsds (sds,sds)",sds.c,"sds sdscatsds(sds s, const sds t) {
    return sdscatlen(s, t, sdslen(t));
}",507.0,509.0,1.0,1.0,3.0,0,0,3,2,28,2,1,1,0,2,,0,1,4,2,2,sds
4384,344976,sdscpylen,1,sdscpylen,"sds sdscpylen (sds,char*,size_t)",sds.c,"sds sdscpylen(sds s, const char *t, size_t len) {
    if (sdsalloc(s) < len) {
        s = sdsMakeRoomFor(s,len-sdslen(s));
        if (s == NULL) return NULL;
    }
    memcpy(s, t, len);
    s[len] = '\0';
    sdssetlen(s, len);
    return s;
}",513.0,522.0,1.0,1.0,10.0,6,5,17,4,1,4,3,4,1,4,,0,3,6,3,3,sds
4385,345018,sdscpy,1,sdscpy,"sds sdscpy (sds,char*)",sds.c,"sds sdscpy(sds s, const char *t) {
    return sdscpylen(s, t, strlen(t));
}",526.0,528.0,1.0,1.0,3.0,0,0,3,2,3,1,1,1,0,1,,0,0,4,2,2,sds
4386,345030,sdsfromlonglong,1,sdsfromlonglong,sds sdsfromlonglong (long long),sds.c,"sds sdsfromlonglong(long long value) {
    char buf[LONG_STR_SIZE];
    int len = ll2string(buf,sizeof(buf),value);

    return sdsnewlen(buf,len);
}",534.0,539.0,1.0,13.0,6.0,2,2,6,3,9,2,1,1,0,2,,0,1,2,1,1,sds
4387,345048,sdscatvprintf,1,sdscatvprintf,"sds sdscatvprintf (sds,char*,va_list)",sds.c,"sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
    va_list cpy;
    char staticbuf[1024], *buf = staticbuf, *t;
    size_t buflen = strlen(fmt)*2;
    int bufstrlen;

    /* We try to start using a static buffer for speed.
     * If not possible we revert to heap allocation. */
    if (buflen > sizeof(staticbuf)) {
        buf = s_malloc(buflen);
        if (buf == NULL) return NULL;
    } else {
        buflen = sizeof(staticbuf);
    }

    /* Alloc enough space for buffer and \0 after failing to
     * fit the string in the current buffer size. */
    while(1) {
        va_copy(cpy,ap);
        bufstrlen = vsnprintf(buf, buflen, fmt, cpy);
        va_end(cpy);
        if (bufstrlen < 0) {
            if (buf != staticbuf) s_free(buf);
            return NULL;
        }
        if (((size_t)bufstrlen) >= buflen) {
            if (buf != staticbuf) s_free(buf);
            buflen = ((size_t)bufstrlen) + 1;
            buf = s_malloc(buflen);
            if (buf == NULL) re...",542.0,581.0,1.0,14.0,40.0,20,10,44,10,6,6,12,19,0,6,,0,3,6,3,3,sds
4388,345181,sdscatprintf,1,sdscatprintf,"sds sdscatprintf (sds,char*...)",sds.c,"sds sdscatprintf(sds s, const char *fmt, ...) {
    va_list ap;
    char *t;
    va_start(ap, fmt);
    t = sdscatvprintf(s,fmt,ap);
    va_end(ap);
    return t;
}",599.0,606.0,1.0,1.0,8.0,1,1,8,4,125,1,1,1,0,1,,0,1,4,2,2,sds
4389,345202,sdscatfmt,1,sdscatfmt,"sds sdscatfmt (sds,char*...)",sds.c,"sds sdscatfmt(sds s, char const *fmt, ...) {
    size_t initlen = sdslen(s);
    const char *f = fmt;
    long i;
    va_list ap;

    /* To avoid continuous reallocations, let's start with a buffer that
     * can hold at least two times the format string itself. It's not the
     * best heuristic but seems to work in practice. */
    s = sdsMakeRoomFor(s, strlen(fmt)*2);
    va_start(ap,fmt);
    f = fmt;    /* Next format specifier byte to process. */
    i = initlen; /* Position of the next byte to write to dest str. */
    while(*f) {
        char next, *str;
        size_t l;
        long long num;
        unsigned long long unum;

        /* Make sure there is always space for at least 1 char. */
        if (sdsavail(s)==0) {
            s = sdsMakeRoomFor(s,1);
        }

        switch(*f) {
        case '%':
            next = *(f+1);
            if (next == '\0') break;
            f++;
            switch(next) {
            case 's':
            case 'S':
               ...",624.0,717.0,1.0,29.0,94.0,44,11,87,12,87,18,16,24,4,18,,0,13,4,2,2,sds
4390,345431,sdstrim,1,sdstrim,"sds sdstrim (sds,char*)",sds.c,"sds sdstrim(sds s, const char *cset) {
    char *end, *sp, *ep;
    size_t len;

    sp = s;
    ep = end = s+sdslen(s)-1;
    while(sp <= end && strchr(cset, *sp)) sp++;
    while(ep > sp && strchr(cset, *ep)) ep--;
    len = (ep-sp)+1;
    if (s != sp) memmove(s, sp, len);
    s[len] = '\0';
    sdssetlen(s,len);
    return s;
}",733.0,746.0,1.0,1.0,14.0,17,9,27,6,10,2,4,4,0,2,,0,1,4,2,2,sds
4391,345502,sdssubstr,1,sdssubstr,"void sdssubstr (sds,size_t,size_t)",sds.c,"void sdssubstr(sds s, size_t start, size_t len) {
    /* Clamp out of range input */
    size_t oldlen = sdslen(s);
    if (start >= oldlen) start = len = 0;
    if (len > oldlen-start) len = oldlen-start;

    /* Move the data */
    if (len) memmove(s, s+start, len);
    s[len] = 0;
    sdssetlen(s,len);
}",751.0,761.0,1.0,1.0,11.0,11,6,21,4,1,2,4,4,0,2,,0,1,6,3,3,void
4392,345553,sdsrange,1,sdsrange,"void sdsrange (sds,ssize_t,ssize_t)",sds.c,"void sdsrange(sds s, ssize_t start, ssize_t end) {
    size_t newlen, len = sdslen(s);
    if (len == 0) return;
    if (start < 0)
        start = len + start;
    if (end < 0)
        end = len + end;
    newlen = (start > end) ? 0 : (end-start)+1;
    sdssubstr(s, start, newlen);
}",784.0,793.0,1.0,1.0,10.0,13,7,19,5,18,2,4,4,0,2,,0,1,6,3,3,void
4393,345608,sdstolower,1,sdstolower,void sdstolower (sds),sds.c,"void sdstolower(sds s) {
    size_t len = sdslen(s), j;

    for (j = 0; j < len; j++) s[j] = tolower(s[j]);
}",796.0,800.0,1.0,1.0,5.0,3,2,5,3,4,1,2,2,0,1,,0,1,2,1,1,void
4394,345637,sdstoupper,1,sdstoupper,void sdstoupper (sds),sds.c,"void sdstoupper(sds s) {
    size_t len = sdslen(s), j;

    for (j = 0; j < len; j++) s[j] = toupper(s[j]);
}",803.0,807.0,1.0,1.0,5.0,3,2,5,3,6,1,2,2,0,1,,0,1,2,1,1,void
4395,345666,sdscmp,1,sdscmp,"int sdscmp (sds,sds)",sds.c,"int sdscmp(const sds s1, const sds s2) {
    size_t l1, l2, minlen;
    int cmp;

    l1 = sdslen(s1);
    l2 = sdslen(s2);
    minlen = (l1 < l2) ? l1 : l2;
    cmp = memcmp(s1,s2,minlen);
    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);
    return cmp;
}",820.0,830.0,1.0,1.0,11.0,12,6,19,6,11,2,2,2,0,2,,0,2,4,2,2,int
4396,345718,sdssplitlen,1,sdssplitlen,"sds sdssplitlen (char*,ssize_t,char*,int,int*)",sds.c,"sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {
    int elements = 0, slots = 5;
    long start = 0, j;
    sds *tokens;

    if (seplen < 1 || len <= 0) {
        *count = 0;
        return NULL;
    }
    tokens = s_malloc(sizeof(sds)*slots);
    if (tokens == NULL) return NULL;

    for (j = 0; j < (len-(seplen-1)); j++) {
        /* make sure there is room for the next element and the final one */
        if (slots < elements+2) {
            sds *newtokens;

            slots *= 2;
            newtokens = s_realloc(tokens,sizeof(sds)*slots);
            if (newtokens == NULL) goto cleanup;
            tokens = newtokens;
        }
        /* search the separator */
        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
            tokens[elements] = sdsnewlen(s+start,j-start);
            if (tokens[elements] == NULL) goto cleanup;
            elements++;
            start = j+seplen;
            j = j+seplen-1;...",848.0,894.0,1.0,13.0,47.0,58,14,71,14,16,5,13,16,0,5,,0,4,10,5,5,sds
4397,345927,sdsfreesplitres,1,sdsfreesplitres,"void sdsfreesplitres (sds*,int)",sds.c,"void sdsfreesplitres(sds *tokens, int count) {
    if (!tokens) return;
    while(count--)
        sdsfree(tokens[count]);
    s_free(tokens);
}",897.0,902.0,1.0,4.0,6.0,2,2,3,2,74,1,3,3,0,1,,0,0,4,2,2,void
4398,345949,sdscatrepr,1,sdscatrepr,"sds sdscatrepr (sds,char*,size_t)",sds.c,"sds sdscatrepr(sds s, const char *p, size_t len) {
    s = sdsMakeRoomFor(s, len + 2);
    s = sdscatlen(s,""\"""",1);
    while(len--) {
        switch(*p) {
        case '\\':
        case '""':
            s = sdscatprintf(s,""\\%c"",*p);
            break;
        case '\n': s = sdscatlen(s,""\\n"",2); break;
        case '\r': s = sdscatlen(s,""\\r"",2); break;
        case '\t': s = sdscatlen(s,""\\t"",2); break;
        case '\a': s = sdscatlen(s,""\\a"",2); break;
        case '\b': s = sdscatlen(s,""\\b"",2); break;
        default:
            if (isprint(*p))
                s = sdscatlen(s, p, 1);
            else
                s = sdscatprintf(s,""\\x%02x"",(unsigned char)*p);
            break;
        }
        p++;
    }
    return sdscatlen(s,""\"""",1);
}",910.0,934.0,1.0,1.0,25.0,15,5,26,3,16,10,11,7,0,10,,0,9,6,3,3,sds
4399,346065,sdsneedsrepr,1,sdsneedsrepr,int sdsneedsrepr (sds),sds.c,"int sdsneedsrepr(const sds s) {
    size_t len = sdslen(s);
    const char *p = s;

    while (len--) {
        if (*p == '\\' || *p == '""' || *p == '\n' || *p == '\r' ||
            *p == '\t' || *p == '\a' || *p == '\b' || !isprint(*p) || isspace(*p)) return 1;
        p++;
    }

    return 0;
}",943.0,954.0,1.0,1.0,12.0,29,7,15,3,1,1,3,4,0,1,,0,1,2,1,1,int
4400,346134,is_hex_digit,1,is_hex_digit,int is_hex_digit (char),sds.c,"int is_hex_digit(char c) {
    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
           (c >= 'A' && c <= 'F');
}",958.0,961.0,1.0,1.0,4.0,11,4,6,1,2,0,1,1,0,0,,0,0,2,1,1,int
4401,346163,hex_digit_to_int,1,hex_digit_to_int,int hex_digit_to_int (char),sds.c,"int hex_digit_to_int(char c) {
    switch(c) {
    case '0': return 0;
    case '1': return 1;
    case '2': return 2;
    case '3': return 3;
    case '4': return 4;
    case '5': return 5;
    case '6': return 6;
    case '7': return 7;
    case '8': return 8;
    case '9': return 9;
    case 'a': case 'A': return 10;
    case 'b': case 'B': return 11;
    case 'c': case 'C': return 12;
    case 'd': case 'D': return 13;
    case 'e': case 'E': return 14;
    case 'f': case 'F': return 15;
    default: return 0;
    }
}",965.0,985.0,1.0,1.0,21.0,0,0,1,1,2,0,2,2,0,0,,0,0,2,1,1,int
4402,346250,sdssplitargs,1,sdssplitargs,"sds sdssplitargs (char*,int*)",sds.c,"sds *sdssplitargs(const char *line, int *argc) {
    const char *p = line;
    char *current = NULL;
    char **vector = NULL;

    *argc = 0;
    while(1) {
        /* skip blanks */
        while(*p && isspace(*p)) p++;
        if (*p) {
            /* get a token */
            int inq=0;  /* set to 1 if we are in ""quotes"" */
            int insq=0; /* set to 1 if we are in 'single quotes' */
            int done=0;

            if (current == NULL) current = sdsempty();
            while(!done) {
                if (inq) {
                    if (*p == '\\' && *(p+1) == 'x' &&
                                             is_hex_digit(*(p+2)) &&
                                             is_hex_digit(*(p+3)))
                    {
                        unsigned char byte;

                        byte = (hex_digit_to_int(*(p+2))*16)+
                                hex_digit_to_int(*(p+3));
                        current = sdscatlen(current,(char*)&byte,1);
                 ...",1006.0,1114.0,1.0,21.0,109.0,55,14,47,11,16,9,11,27,2,9,,0,7,4,2,2,sds
4403,346651,sdsmapchars,1,sdsmapchars,"sds sdsmapchars (sds,char*,char*,size_t)",sds.c,"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
    size_t j, i, l = sdslen(s);

    for (j = 0; j < l; j++) {
        for (i = 0; i < setlen; i++) {
            if (s[j] == from[i]) {
                s[j] = to[i];
                break;
            }
        }
    }
    return s;
}",1125.0,1137.0,1.0,1.0,13.0,11,4,17,7,5,1,5,7,0,1,,0,1,8,4,4,sds
4404,346707,sdsjoin,1,sdsjoin,"sds sdsjoin (char**,int,char*)",sds.c,"sds sdsjoin(char **argv, int argc, char *sep) {
    sds join = sdsempty();
    int j;

    for (j = 0; j < argc; j++) {
        join = sdscat(join, argv[j]);
        if (j != argc-1) join = sdscat(join,sep);
    }
    return join;
}",1141.0,1150.0,1.0,1.0,10.0,8,5,14,5,2,3,3,4,0,3,,0,3,6,3,3,sds
4405,346751,sdsjoinsds,1,sdsjoinsds,"sds sdsjoinsds (sds*,int,char*,size_t)",sds.c,"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
    sds join = sdsempty();
    int j;

    for (j = 0; j < argc; j++) {
        join = sdscatsds(join, argv[j]);
        if (j != argc-1) join = sdscatlen(join,sep,seplen);
    }
    return join;
}",1153.0,1162.0,1.0,1.0,10.0,8,5,15,6,1,3,3,4,0,3,,0,3,8,4,4,sds
4406,346797,sds_malloc,1,sds_malloc,void* sds_malloc (size_t),sds.c,void *sds_malloc(size_t size) { return s_malloc(size); },1169.0,1169.0,1.0,39.0,1.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void*
4407,346807,sds_realloc,1,sds_realloc,"void* sds_realloc (void*,size_t)",sds.c,"void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }",1170.0,1170.0,1.0,51.0,1.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,void*
4408,346819,sds_free,1,sds_free,void sds_free (void*),sds.c,void sds_free(void *ptr) { s_free(ptr); },1171.0,1171.0,1.0,27.0,1.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
4409,346828,sdstemplate,1,sdstemplate,"sds sdstemplate (char*,sdstemplate_callback_t,void*)",sds.c,"sds sdstemplate(const char *template, sdstemplate_callback_t cb_func, void *cb_arg)
{
    sds res = sdsempty();
    const char *p = template;

    while (*p) {
        /* Find next variable, copy everything until there */
        const char *sv = strchr(p, '{');
        if (!sv) {
            /* Not found: copy till rest of template and stop */
            res = sdscat(res, p);
            break;
        } else if (sv > p) {
            /* Found: copy anything up to the beginning of the variable */
            res = sdscatlen(res, p, sv - p);
        }

        /* Skip into variable name, handle premature end or quoting */
        sv++;
        if (!*sv) goto error;       /* Premature end of template */
        if (*sv == '{') {
            /* Quoted '{' */
            p = sv + 1;
            res = sdscat(res, ""{"");
            continue;
        }

        /* Find end of variable name, handle premature end of template */
        const char *ev = strchr(sv, '}');
        if (!ev) got...",1179.0,1228.0,1.0,1.0,50.0,23,7,38,9,1,8,12,12,0,8,,0,5,6,3,3,sds
4410,347015,sdslen,1,sdslen,size_t sdslen (sds),sds.h,"static inline size_t sdslen(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->len;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->len;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->len;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->len;
    }
    return 0;
}",87.0,102.0,1.0,17.0,16.0,21,9,17,6,383,0,2,2,0,0,,0,0,2,1,1,size_t
4411,347111,sdsavail,1,sdsavail,size_t sdsavail (sds),sds.h,"static inline size_t sdsavail(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5: {
            return 0;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            return sh->alloc - sh->len;
        }
    }
    return 0;
}",104.0,128.0,1.0,17.0,25.0,32,8,27,11,14,8,2,2,0,0,,0,8,2,1,1,size_t
4412,347239,sdssetlen,1,sdssetlen,"void sdssetlen (sds,size_t)",sds.h,"static inline void sdssetlen(sds s, size_t newlen) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            {
                unsigned char *fp = ((unsigned char*)s)-1;
                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
            }
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->len = newlen;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->len = newlen;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->len = newlen;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->len = newlen;
            break;
    }
}",130.0,152.0,1.0,17.0,23.0,31,11,23,8,12,0,7,2,0,0,,0,0,4,2,2,void
4413,347357,sdsinclen,1,sdsinclen,"void sdsinclen (sds,size_t)",sds.h,"static inline void sdsinclen(sds s, size_t inc) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            {
                unsigned char *fp = ((unsigned char*)s)-1;
                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;
                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
            }
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->len += inc;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->len += inc;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->len += inc;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->len += inc;
            break;
    }
}",154.0,177.0,1.0,17.0,24.0,34,14,27,9,5,0,7,2,0,0,,0,0,4,2,2,void
4414,347486,sdsalloc,1,sdsalloc,size_t sdsalloc (sds),sds.h,"static inline size_t sdsalloc(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->alloc;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->alloc;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->alloc;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->alloc;
    }
    return 0;
}",180.0,195.0,1.0,17.0,16.0,21,9,17,6,7,0,2,2,0,0,,0,0,2,1,1,size_t
4415,347582,sdssetalloc,1,sdssetalloc,"void sdssetalloc (sds,size_t)",sds.h,"static inline void sdssetalloc(sds s, size_t newlen) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            /* Nothing to do, this type has no total allocation info. */
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->alloc = newlen;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->alloc = newlen;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->alloc = newlen;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->alloc = newlen;
            break;
    }
}",197.0,216.0,1.0,17.0,20.0,24,8,19,7,2,0,7,2,0,0,,0,0,4,2,2,void
4416,348152,redisAeReadEvent,1,redisAeReadEvent,"void redisAeReadEvent (aeEventLoop*,int,void*,int)",sentinel.c,"static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
    ((void)el); ((void)fd); ((void)mask);

    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAsyncHandleRead(e->context);
}",304.0,309.0,1.0,1.0,6.0,6,3,6,5,0,1,1,1,0,0,,0,1,8,4,4,void
4417,348179,redisAeWriteEvent,1,redisAeWriteEvent,"void redisAeWriteEvent (aeEventLoop*,int,void*,int)",sentinel.c,"static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
    ((void)el); ((void)fd); ((void)mask);

    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAsyncHandleWrite(e->context);
}",311.0,316.0,1.0,1.0,6.0,6,3,6,5,0,1,1,1,0,0,,0,1,8,4,4,void
4418,348206,redisAeAddRead,1,redisAeAddRead,void redisAeAddRead (void*),sentinel.c,"static void redisAeAddRead(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (!e->reading) {
        e->reading = 1;
        aeCreateFileEvent(loop,e->fd,AE_READABLE,redisAeReadEvent,e);
    }
}",318.0,325.0,1.0,37.0,8.0,9,4,9,3,0,5,2,2,1,1,,0,4,2,1,1,void
4419,348244,redisAeDelRead,1,redisAeDelRead,void redisAeDelRead (void*),sentinel.c,"static void redisAeDelRead(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (e->reading) {
        e->reading = 0;
        aeDeleteFileEvent(loop,e->fd,AE_READABLE);
    }
}",327.0,334.0,1.0,37.0,8.0,8,3,8,3,1,5,2,2,1,1,,0,4,2,1,1,void
4420,348279,redisAeAddWrite,1,redisAeAddWrite,void redisAeAddWrite (void*),sentinel.c,"static void redisAeAddWrite(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (!e->writing) {
        e->writing = 1;
        aeCreateFileEvent(loop,e->fd,AE_WRITABLE,redisAeWriteEvent,e);
    }
}",336.0,343.0,1.0,37.0,8.0,9,4,9,3,0,5,2,2,1,1,,0,4,2,1,1,void
4421,348317,redisAeDelWrite,1,redisAeDelWrite,void redisAeDelWrite (void*),sentinel.c,"static void redisAeDelWrite(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (e->writing) {
        e->writing = 0;
        aeDeleteFileEvent(loop,e->fd,AE_WRITABLE);
    }
}",345.0,352.0,1.0,37.0,8.0,8,3,8,3,1,5,2,2,1,1,,0,4,2,1,1,void
4422,348352,redisAeCleanup,1,redisAeCleanup,void redisAeCleanup (void*),sentinel.c,"static void redisAeCleanup(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAeDelRead(privdata);
    redisAeDelWrite(privdata);
    zfree(e);
}",354.0,359.0,1.0,1.0,6.0,2,2,5,2,0,3,1,1,0,3,,0,0,2,1,1,void
4423,348369,redisAeAttach,1,redisAeAttach,"int redisAeAttach (aeEventLoop*,redisAsyncContext*)",sentinel.c,"static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
    redisContext *c = &(ac->c);
    redisAeEvents *e;

    /* Nothing should be attached when something is already attached */
    if (ac->ev.data != NULL)
        return C_ERR;

    /* Create container for context and r/w events */
    e = (redisAeEvents*)zmalloc(sizeof(*e));
    e->context = ac;
    e->loop = loop;
    e->fd = c->fd;
    e->reading = e->writing = 0;

    /* Register functions to start/stop listening for events */
    ac->ev.addRead = redisAeAddRead;
    ac->ev.delRead = redisAeDelRead;
    ac->ev.addWrite = redisAeAddWrite;
    ac->ev.delWrite = redisAeDelWrite;
    ac->ev.cleanup = redisAeCleanup;
    ac->ev.data = e;

    return C_OK;
}",361.0,385.0,1.0,15.0,25.0,40,9,21,5,0,6,2,2,0,1,,0,6,4,2,2,int
4424,348496,sentinelGetMasterByName,1,sentinelGetMasterByName,sentinelRedisInstance* sentinelGetMasterByName (char*),sentinel.c,"sentinelRedisInstance *sentinelGetMasterByName(char *name) {
    sentinelRedisInstance *ri;
    sds sdsname = sdsnew(name);

    ri = dictFetchValue(sentinel.masters,sdsname);
    sdsfree(sdsname);
    return ri;
}",1512.0,1519.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sentinelRedisInstance
4425,348521,sentinelAbortFailover,1,sentinelAbortFailover,void sentinelAbortFailover (sentinelRedisInstance*),sentinel.c,"void sentinelAbortFailover(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_FAILOVER_IN_PROGRESS);
    serverAssert(ri->failover_state <= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);

    ri->flags &= ~(SRI_FAILOVER_IN_PROGRESS|SRI_FORCE_FAILOVER);
    ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
    ri->failover_state_change_time = mstime();
    if (ri->promoted_slave) {
        ri->promoted_slave->flags &= ~SRI_PROMOTED;
        ri->promoted_slave = NULL;
    }
}",5360.0,5371.0,1.0,4.0,12.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
4426,348526,sentinelEvent,1,sentinelEvent,"void sentinelEvent (int,char*,sentinelRedisInstance*,char*...)",sentinel.c,"void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
                   const char *fmt, ...) {
    va_list ap;
    char msg[LOG_MAX_LEN];
    robj *channel, *payload;

    /* Handle %@ */
    if (fmt[0] == '%' && fmt[1] == '@') {
        sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ?
                                         NULL : ri->master;

        if (master) {
            snprintf(msg, sizeof(msg), ""%s %s %s %d @ %s %s %d"",
                sentinelRedisInstanceTypeStr(ri),
                ri->name, announceSentinelAddr(ri->addr), ri->addr->port,
                master->name, announceSentinelAddr(master->addr), master->addr->port);
        } else {
            snprintf(msg, sizeof(msg), ""%s %s %s %d"",
                sentinelRedisInstanceTypeStr(ri),
                ri->name, announceSentinelAddr(ri->addr), ri->addr->port);
        }
        fmt += 2;
    } else {
        msg[0] = '\0';
    }

    /* Use vsprintf for the rest of the formatting if any...",669.0,724.0,1.0,13.0,56.0,0,0,0,0,37,0,1,1,0,0,,0,0,8,4,4,void
4427,348534,sentinelSelectSlave,1,sentinelSelectSlave,sentinelRedisInstance* sentinelSelectSlave (sentinelRedisInstance*),sentinel.c,"sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance **instance =
        zmalloc(sizeof(instance[0])*dictSize(master->slaves));
    sentinelRedisInstance *selected = NULL;
    int instances = 0;
    dictIterator *di;
    dictEntry *de;
    mstime_t max_master_down_time = 0;

    if (master->flags & SRI_S_DOWN)
        max_master_down_time += mstime() - master->s_down_since_time;
    max_master_down_time += master->down_after_period * 10;

    di = dictGetIterator(master->slaves);

    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);
        mstime_t info_validity_time;

        if (slave->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
        if (slave->link->disconnected) continue;
        if (mstime() - slave->link->last_avail_time > sentinel_ping_period*5) continue;
        if (slave->slave_priority == 0) continue;

        /* If the master is in SDOWN state we get INFO for slaves every secon...",5062.0,5105.0,1.0,36.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sentinelRedisInstance
4428,348539,sentinelScheduleScriptExecution,1,sentinelScheduleScriptExecution,void sentinelScheduleScriptExecution (char*...),sentinel.c,"void sentinelScheduleScriptExecution(char *path, ...) {
    va_list ap;
    char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];
    int argc = 1;
    sentinelScriptJob *sj;

    va_start(ap, path);
    while(argc < SENTINEL_SCRIPT_MAX_ARGS) {
        argv[argc] = va_arg(ap,char*);
        if (!argv[argc]) break;
        argv[argc] = sdsnew(argv[argc]); /* Copy the string. */
        argc++;
    }
    va_end(ap);
    argv[0] = sdsnew(path);

    sj = zmalloc(sizeof(*sj));
    sj->flags = SENTINEL_SCRIPT_NONE;
    sj->retry_num = 0;
    sj->argv = zmalloc(sizeof(char*)*(argc+1));
    sj->start_time = 0;
    sj->pid = 0;
    memcpy(sj->argv,argv,sizeof(char*)*(argc+1));

    listAddNodeTail(sentinel.scripts_queue,sj);

    /* Remove the oldest non running script if we already hit the limit. */
    if (listLength(sentinel.scripts_queue) > SENTINEL_SCRIPT_MAX_QUEUE) {
        listNode *ln;
        listIter li;

        listRewind(sentinel.scripts_queue,&li);
        while ((ln = listNext(&li)) != NU...",754.0,798.0,1.0,15.0,45.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4429,348544,sentinelStartFailover,1,sentinelStartFailover,void sentinelStartFailover (sentinelRedisInstance*),sentinel.c,"void sentinelStartFailover(sentinelRedisInstance *master) {
    serverAssert(master->flags & SRI_MASTER);

    master->failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
    master->flags |= SRI_FAILOVER_IN_PROGRESS;
    master->failover_epoch = ++sentinel.current_epoch;
    sentinelEvent(LL_WARNING,""+new-epoch"",master,""%llu"",
        (unsigned long long) sentinel.current_epoch);
    sentinelEvent(LL_WARNING,""+try-failover"",master,""%@"");
    master->failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
    master->failover_state_change_time = mstime();
}",4948.0,4959.0,1.0,4.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4430,348556,sentinelSendSlaveOf,1,sentinelSendSlaveOf,"int sentinelSendSlaveOf (sentinelRedisInstance*,sentinelAddr*)",sentinel.c,"int sentinelSendSlaveOf(sentinelRedisInstance *ri, const sentinelAddr *addr) {
    char portstr[32];
    const char *host;
    int retval;

    /* If host is NULL we send SLAVEOF NO ONE that will turn the instance
    * into a master. */
    if (!addr) {
        host = ""NO"";
        memcpy(portstr,""ONE"",4);
    } else {
        host = announceSentinelAddr(addr);
        ll2string(portstr,sizeof(portstr),addr->port);
    }

    /* In order to send SLAVEOF in a safe way, we send a transaction performing
     * the following tasks:
     * 1) Reconfigure the instance according to the specified host/port params.
     * 2) Rewrite the configuration.
     * 3) Disconnect all clients (but this one sending the command) in order
     *    to trigger the ask-master-on-reconnection protocol for connected
     *    clients.
     *
     * Note that we don't check the replies returned by commands, since we
     * will observe instead the effects in the next INFO output. */
    retval = redisAsyncC...",4880.0,4945.0,1.0,18.0,66.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
4431,348562,sentinelVoteLeader,1,sentinelVoteLeader,"char* sentinelVoteLeader (sentinelRedisInstance*,uint64_t,char*,uint64_t*)",sentinel.c,"char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
    if (req_epoch > sentinel.current_epoch) {
        sentinel.current_epoch = req_epoch;
        sentinelFlushConfig();
        sentinelEvent(LL_WARNING,""+new-epoch"",master,""%llu"",
            (unsigned long long) sentinel.current_epoch);
    }

    if (master->leader_epoch < req_epoch && sentinel.current_epoch <= req_epoch)
    {
        sdsfree(master->leader);
        master->leader = sdsnew(req_runid);
        master->leader_epoch = sentinel.current_epoch;
        sentinelFlushConfig();
        sentinelEvent(LL_WARNING,""+vote-for-leader"",master,""%s %llu"",
            master->leader, (unsigned long long) master->leader_epoch);
        /* If we did not voted for ourselves, set the master failover start
         * time to now, in order to force a delay before we can start a
         * failover for the same master. */
        if (strcasecmp(master->leader,sentinel....",4749.0,4774.0,1.0,22.0,26.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,char*
4432,348570,sentinelFlushConfig,1,sentinelFlushConfig,int sentinelFlushConfig (void),sentinel.c,"int sentinelFlushConfig(void) {
    int saved_hz = server.hz;
    int rewrite_status;

    server.hz = CONFIG_DEFAULT_HZ;
    rewrite_status = rewriteConfig(server.configfile, 0);
    server.hz = saved_hz;

    if (rewrite_status == -1) {
        serverLog(LL_WARNING,""WARNING: Sentinel was not able to save the new configuration on disk!!!: %s"", strerror(errno));
        return C_ERR;
    } else {
        serverLog(LL_NOTICE,""Sentinel new configuration saved on disk"");
        return C_OK;
    }
}",2282.0,2297.0,1.0,16.0,16.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,int
4433,348575,sentinelGenerateInitialMonitorEvents,1,sentinelGenerateInitialMonitorEvents,void sentinelGenerateInitialMonitorEvents (void),sentinel.c,"void sentinelGenerateInitialMonitorEvents(void) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        sentinelEvent(LL_WARNING,""+monitor"",ri,""%@ quorum %d"",ri->quorum);
    }
    dictReleaseIterator(di);
}",730.0,740.0,1.0,22.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4434,348580,sentinelSendPing,1,sentinelSendPing,int sentinelSendPing (sentinelRedisInstance*),sentinel.c,"int sentinelSendPing(sentinelRedisInstance *ri) {
    int retval = redisAsyncCommand(ri->link->cc,
        sentinelPingReplyCallback, ri, ""%s"",
        sentinelInstanceMapCommand(ri,""PING""));
    if (retval == C_OK) {
        ri->link->pending_commands++;
        ri->link->last_ping_time = mstime();
        /* We update the active ping time only if we received the pong for
         * the previous ping, otherwise we are technically waiting since the
         * first ping that did not receive a reply. */
        if (ri->link->act_ping_time == 0)
            ri->link->act_ping_time = ri->link->last_ping_time;
        return 1;
    } else {
        return 0;
    }
}",3096.0,3112.0,1.0,18.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4435,348585,sentinelForceHelloUpdateForMaster,1,sentinelForceHelloUpdateForMaster,int sentinelForceHelloUpdateForMaster (sentinelRedisInstance*),sentinel.c,"int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
    if (!(master->flags & SRI_MASTER)) return C_ERR;
    if (master->last_pub_time >= (sentinel_publish_period+1))
        master->last_pub_time -= (sentinel_publish_period+1);
    sentinelForceHelloUpdateDictOfRedisInstances(master->sentinels);
    sentinelForceHelloUpdateDictOfRedisInstances(master->slaves);
    return C_OK;
}",3082.0,3089.0,1.0,26.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4436,348590,getSentinelRedisInstanceByAddrAndRunID,1,getSentinelRedisInstanceByAddrAndRunID,"sentinelRedisInstance* getSentinelRedisInstanceByAddrAndRunID (dict*,char*,int,char*)",sentinel.c,"sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *addr, int port, char *runid) {
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *instance = NULL;
    sentinelAddr *ri_addr = NULL;

    serverAssert(addr || runid);   /* User must pass at least one search param. */
    if (addr != NULL) {
        /* Try to resolve addr. If hostnames are used, we're accepting an ri_addr
         * that contains an hostname only and can still be matched based on that.
         */
        ri_addr = createSentinelAddr(addr,port,1);
        if (!ri_addr) return NULL;
    }
    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (runid && !ri->runid) continue;
        if ((runid == NULL || strcmp(ri->runid, runid) == 0) &&
            (addr == NULL || sentinelAddrOrHostnameEqual(ri->addr, ri_addr)))
        {
            instance = ri;
            break;
        }
    ...",1478.0,1509.0,1.0,4.0,32.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,sentinelRedisInstance
4437,348598,sentinelSimFailureCrash,1,sentinelSimFailureCrash,void sentinelSimFailureCrash (void),sentinel.c,"void sentinelSimFailureCrash(void) {
    serverLog(LL_WARNING,
        ""Sentinel CRASH because of SENTINEL simulate-failure"");
    exit(99);
}",4738.0,4742.0,1.0,4.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
4438,348603,releaseSentinelRedisInstance,1,releaseSentinelRedisInstance,void releaseSentinelRedisInstance (sentinelRedisInstance*),sentinel.c,"void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
    /* Release all its slaves or sentinels if any. */
    dictRelease(ri->sentinels);
    dictRelease(ri->slaves);

    /* Disconnect the instance. */
    releaseInstanceLink(ri->link,ri);

    /* Free other resources. */
    sdsfree(ri->name);
    sdsfree(ri->runid);
    sdsfree(ri->notification_script);
    sdsfree(ri->client_reconfig_script);
    sdsfree(ri->slave_master_host);
    sdsfree(ri->leader);
    sdsfree(ri->auth_pass);
    sdsfree(ri->auth_user);
    sdsfree(ri->info);
    releaseSentinelAddr(ri->addr);
    dictRelease(ri->renamed_commands);

    /* Clear state into the master if needed. */
    if ((ri->flags & SRI_SLAVE) && (ri->flags & SRI_PROMOTED) && ri->master)
        ri->master->promoted_slave = NULL;

    zfree(ri);
}",1381.0,1407.0,1.0,21.0,27.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4439,348608,dictInstancesValDestructor,1,dictInstancesValDestructor,"void dictInstancesValDestructor (dict*,void*)",sentinel.c,"void dictInstancesValDestructor (dict *d, void *obj) {
    UNUSED(d);
    releaseSentinelRedisInstance(obj);
}",416.0,419.0,1.0,4.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void
4440,348705,initSentinel,1,initSentinel,void initSentinel (void),sentinel.c,"void initSentinel(void) {
    /* Initialize various data structures. */
    sentinel.current_epoch = 0;
    sentinel.masters = dictCreate(&instancesDictType);
    sentinel.tilt = 0;
    sentinel.tilt_start_time = 0;
    sentinel.previous_time = mstime();
    sentinel.running_scripts = 0;
    sentinel.scripts_queue = listCreate();
    sentinel.announce_ip = NULL;
    sentinel.announce_port = 0;
    sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
    sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;
    sentinel.sentinel_auth_pass = NULL;
    sentinel.sentinel_auth_user = NULL;
    sentinel.resolve_hostnames = SENTINEL_DEFAULT_RESOLVE_HOSTNAMES;
    sentinel.announce_hostnames = SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES;
    memset(sentinel.myid,0,sizeof(sentinel.myid));
    server.sentinel_config = NULL;
}",490.0,509.0,1.0,32.0,20.0,36,4,23,4,0,38,1,1,0,3,,0,38,2,1,1,void
4441,348809,sentinelCheckConfigFile,1,sentinelCheckConfigFile,void sentinelCheckConfigFile (void),sentinel.c,"void sentinelCheckConfigFile(void) {
    if (server.configfile == NULL) {
        serverLog(LL_WARNING,
            ""Sentinel needs config file on disk to save state. Exiting..."");
        exit(1);
    } else if (access(server.configfile,W_OK) == -1) {
        serverLog(LL_WARNING,
            ""Sentinel config file %s is not writable: %s. Exiting..."",
            server.configfile,strerror(errno));
        exit(1);
    }
}",513.0,524.0,1.0,8.0,12.0,5,4,3,2,0,1,2,2,0,1,,0,0,2,1,1,void
4442,348878,sentinelIsRunning,1,sentinelIsRunning,void sentinelIsRunning (void),sentinel.c,"void sentinelIsRunning(void) {
    int j;

    /* If this Sentinel has yet no ID set in the configuration file, we
     * pick a random one and persist the config on disk. From now on this
     * will be this Sentinel ID across restarts. */
    for (j = 0; j < CONFIG_RUN_ID_SIZE; j++)
        if (sentinel.myid[j] != 0) break;

    if (j == CONFIG_RUN_ID_SIZE) {
        /* Pick ID and persist the config. */
        getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);
        sentinelFlushConfig();
    }

    /* Log its ID to make debugging of issues simpler. */
    serverLog(LL_NOTICE,""Sentinel ID is %s"", sentinel.myid);

    /* We want to generate a +monitor event for every configured master
     * at startup. */
    sentinelGenerateInitialMonitorEvents();
}",528.0,549.0,1.0,20.0,22.0,8,5,6,3,0,8,3,3,0,4,,0,4,2,1,1,void
4443,348943,createSentinelAddr,1,createSentinelAddr,"sentinelAddr createSentinelAddr (char*,int,int)",sentinel.c,"sentinelAddr *createSentinelAddr(char *hostname, int port, int is_accept_unresolved) {
    char ip[NET_IP_STR_LEN];
    sentinelAddr *sa;

    if (port < 0 || port > 65535) {
        errno = EINVAL;
        return NULL;
    }
    if (anetResolve(NULL,hostname,ip,sizeof(ip),
                    sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) == ANET_ERR) {
        serverLog(LL_WARNING, ""Failed to resolve hostname '%s'"", hostname);
        if (sentinel.resolve_hostnames && is_accept_unresolved) {
            ip[0] = '\0';
        }
        else {
            errno = ENOENT;
            return NULL;
        }
    }
    sa = zmalloc(sizeof(*sa));
    sa->hostname = sdsnew(hostname);
    sa->ip = sdsnew(ip);
    sa->port = port;
    return sa;
}",558.0,582.0,1.0,12.0,25.0,26,15,24,10,4,12,4,5,5,5,,0,11,6,3,3,sentinelAddr
4444,349054,dupSentinelAddr,1,dupSentinelAddr,sentinelAddr dupSentinelAddr (sentinelAddr*),sentinel.c,"sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
    sentinelAddr *sa;

    sa = zmalloc(sizeof(*sa));
    sa->hostname = sdsnew(src->hostname);
    sa->ip = sdsnew(src->ip);
    sa->port = src->port;
    return sa;
}",585.0,593.0,1.0,1.0,9.0,12,4,9,2,4,9,1,1,0,3,,0,9,2,1,1,sentinelAddr
4445,349091,releaseSentinelAddr,1,releaseSentinelAddr,void releaseSentinelAddr (sentinelAddr*),sentinel.c,"void releaseSentinelAddr(sentinelAddr *sa) {
    sdsfree(sa->hostname);
    sdsfree(sa->ip);
    zfree(sa);
}",596.0,600.0,1.0,1.0,5.0,2,1,3,1,7,5,1,1,0,3,,0,2,2,1,1,void
4446,349106,sentinelAddrOrHostnameEqual,1,sentinelAddrOrHostnameEqual,"int sentinelAddrOrHostnameEqual (sentinelAddr*,sentinelAddr*)",sentinel.c,"int sentinelAddrOrHostnameEqual(sentinelAddr *a, sentinelAddr *b) {
    return a->port == b->port &&
            (!strcmp(a->ip, b->ip)  ||
            !strcasecmp(a->hostname, b->hostname));
}",605.0,609.0,1.0,1.0,5.0,11,5,6,2,2,6,1,1,0,0,,0,6,4,2,2,int
4447,349138,sentinelAddrEqualsHostname,1,sentinelAddrEqualsHostname,"int sentinelAddrEqualsHostname (sentinelAddr*,char*)",sentinel.c,"int sentinelAddrEqualsHostname(sentinelAddr *a, char *hostname) {
    char ip[NET_IP_STR_LEN];

    /* Try resolve the hostname and compare it to the address */
    if (anetResolve(NULL, hostname, ip, sizeof(ip),
                    sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) == ANET_ERR) {

        /* If failed resolve then compare based on hostnames. That is our best effort as
         * long as the server is unavailable for some reason. It is fine since Redis 
         * instance cannot have multiple hostnames for a given setup */
        return !strcasecmp(sentinel.resolve_hostnames ? a->hostname : a->ip, hostname);
    }
    /* Compare based on address */
    return !strcasecmp(a->ip, ip);
}",612.0,626.0,1.0,12.0,15.0,13,8,11,5,3,8,2,2,3,1,,0,8,4,2,2,int
4448,349191,announceSentinelAddr,1,announceSentinelAddr,const char* announceSentinelAddr (sentinelAddr*),sentinel.c,"const char *announceSentinelAddr(const sentinelAddr *a) {
    return sentinel.announce_hostnames ? a->hostname : a->ip;
}",628.0,630.0,1.0,1.0,3.0,4,3,3,2,10,4,1,1,0,0,,0,4,2,1,1,const char*
4449,349207,announceSentinelAddrAndPort,1,announceSentinelAddrAndPort,sds announceSentinelAddrAndPort (sentinelAddr*),sentinel.c,"sds announceSentinelAddrAndPort(const sentinelAddr *a) {
    const char *addr = announceSentinelAddr(a);
    if (strchr(addr, ':') != NULL)
        return sdscatprintf(sdsempty(), ""[%s]:%d"", addr, a->port);
    else
        return sdscatprintf(sdsempty(), ""%s:%d"", addr, a->port);
}",635.0,641.0,1.0,1.0,7.0,3,3,6,3,2,4,2,2,0,3,,0,3,2,1,1,sds
4450,349508,sentinelReleaseScriptJob,1,sentinelReleaseScriptJob,void sentinelReleaseScriptJob (sentinelScriptJob*),sentinel.c,"void sentinelReleaseScriptJob(sentinelScriptJob *sj) {
    int j = 0;

    while(sj->argv[j]) sdsfree(sj->argv[j++]);
    zfree(sj->argv);
    zfree(sj);
}",745.0,751.0,1.0,1.0,7.0,4,3,5,2,0,4,2,2,1,2,,0,2,2,1,1,void
4451,349715,sentinelGetScriptListNodeByPid,1,sentinelGetScriptListNodeByPid,listNode sentinelGetScriptListNodeByPid (pid_t),sentinel.c,"listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
    listNode *ln;
    listIter li;

    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;

        if ((sj->flags & SENTINEL_SCRIPT_RUNNING) && sj->pid == pid)
            return ln;
    }
    return NULL;
}",802.0,814.0,1.0,25.0,13.0,12,8,12,6,1,7,3,4,3,2,,0,6,2,1,1,listNode
4452,349762,sentinelRunPendingScripts,1,sentinelRunPendingScripts,void sentinelRunPendingScripts (void),sentinel.c,"void sentinelRunPendingScripts(void) {
    listNode *ln;
    listIter li;
    mstime_t now = mstime();

    /* Find jobs that are not running and run them, from the top to the
     * tail of the queue, so we run older jobs first. */
    listRewind(sentinel.scripts_queue,&li);
    while (sentinel.running_scripts < SENTINEL_SCRIPT_MAX_RUNNING &&
           (ln = listNext(&li)) != NULL)
    {
        sentinelScriptJob *sj = ln->value;
        pid_t pid;

        /* Skip if already running. */
        if (sj->flags & SENTINEL_SCRIPT_RUNNING) continue;

        /* Skip if it's a retry, but not enough time has elapsed. */
        if (sj->start_time && sj->start_time > now) continue;

        sj->flags |= SENTINEL_SCRIPT_RUNNING;
        sj->start_time = mstime();
        sj->retry_num++;
        pid = fork();

        if (pid == -1) {
            /* Parent (fork error).
             * We report fork errors as signal 99, in order to unify the
             * reporting with other kind of err...",818.0,863.0,1.0,38.0,46.0,31,14,22,7,1,19,7,8,6,5,,0,17,2,1,1,void
4453,349918,sentinelScriptRetryDelay,1,sentinelScriptRetryDelay,mstime_t sentinelScriptRetryDelay (int),sentinel.c,"mstime_t sentinelScriptRetryDelay(int retry_num) {
    mstime_t delay = sentinel_script_retry_delay;

    while (retry_num-- > 1) delay *= 2;
    return delay;
}",872.0,877.0,1.0,1.0,6.0,3,3,4,3,1,1,2,2,0,0,,0,1,2,1,1,mstime_t
4454,349937,sentinelCollectTerminatedScripts,1,sentinelCollectTerminatedScripts,void sentinelCollectTerminatedScripts (void),sentinel.c,"void sentinelCollectTerminatedScripts(void) {
    int statloc;
    pid_t pid;

    while ((pid = waitpid(-1, &statloc, WNOHANG)) > 0) {
        int exitcode = WEXITSTATUS(statloc);
        int bysignal = 0;
        listNode *ln;
        sentinelScriptJob *sj;

        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
        sentinelEvent(LL_DEBUG,""-script-child"",NULL,""%ld %d %d"",
            (long)pid, exitcode, bysignal);

        ln = sentinelGetScriptListNodeByPid(pid);
        if (ln == NULL) {
            serverLog(LL_WARNING,""waitpid() returned a pid (%ld) we can't find in our scripts execution queue!"", (long)pid);
            continue;
        }
        sj = ln->value;

        /* If the script was terminated by a signal or returns an
         * exit code of ""1"" (that means: please retry), we reschedule it
         * if the max number of retries is not already reached. */
        if ((bysignal || exitcode == 1) &&
            sj->retry_num != SENTINEL_SCRIPT_MAX_RETRY)...",883.0,926.0,1.0,22.0,44.0,31,16,29,10,1,13,6,8,1,5,,0,11,2,1,1,void
4455,350095,sentinelKillTimedoutScripts,1,sentinelKillTimedoutScripts,void sentinelKillTimedoutScripts (void),sentinel.c,"void sentinelKillTimedoutScripts(void) {
    listNode *ln;
    listIter li;
    mstime_t now = mstime();

    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;

        if (sj->flags & SENTINEL_SCRIPT_RUNNING &&
            (now - sj->start_time) > sentinel_script_max_runtime)
        {
            sentinelEvent(LL_WARNING,""-script-timeout"",NULL,""%s %ld"",
                sj->argv[0], (long)sj->pid);
            kill(sj->pid,SIGKILL);
        }
    }
}",930.0,947.0,1.0,24.0,18.0,19,11,17,8,1,13,3,4,4,4,,0,11,2,1,1,void
4456,350166,sentinelPendingScriptsCommand,1,sentinelPendingScriptsCommand,void sentinelPendingScriptsCommand (client*),sentinel.c,"void sentinelPendingScriptsCommand(client *c) {
    listNode *ln;
    listIter li;

    addReplyArrayLen(c,listLength(sentinel.scripts_queue));
    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;
        int j = 0;

        addReplyMapLen(c,5);

        addReplyBulkCString(c,""argv"");
        while (sj->argv[j]) j++;
        addReplyArrayLen(c,j);
        j = 0;
        while (sj->argv[j]) addReplyBulkCString(c,sj->argv[j++]);

        addReplyBulkCString(c,""flags"");
        addReplyBulkCString(c,
            (sj->flags & SENTINEL_SCRIPT_RUNNING) ? ""running"" : ""scheduled"");

        addReplyBulkCString(c,""pid"");
        addReplyBulkLongLong(c,sj->pid);

        if (sj->flags & SENTINEL_SCRIPT_RUNNING) {
            addReplyBulkCString(c,""run-time"");
            addReplyBulkLongLong(c,mstime() - sj->start_time);
        } else {
            mstime_t delay = sj->start_time ? (sj->start_time-mstime()) : 0;
   ...",950.0,988.0,1.0,23.0,39.0,25,9,33,7,0,29,5,8,4,15,,0,16,2,1,1,void
4457,350323,sentinelCallClientReconfScript,1,sentinelCallClientReconfScript,"void sentinelCallClientReconfScript (sentinelRedisInstance*,int,char*,sentinelAddr*,sentinelAddr*)",sentinel.c,"void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
    char fromport[32], toport[32];

    if (master->client_reconfig_script == NULL) return;
    ll2string(fromport,sizeof(fromport),from->port);
    ll2string(toport,sizeof(toport),to->port);
    sentinelScheduleScriptExecution(master->client_reconfig_script,
        master->name,
        (role == SENTINEL_LEADER) ? ""leader"" : ""observer"",
        state, announceSentinelAddr(from), fromport,
        announceSentinelAddr(to), toport, NULL);
}",1002.0,1013.0,1.0,17.0,12.0,11,5,17,8,2,10,2,2,1,5,,0,7,10,5,5,void
4458,350381,createInstanceLink,1,createInstanceLink,instanceLink createInstanceLink (void),sentinel.c,"instanceLink *createInstanceLink(void) {
    instanceLink *link = zmalloc(sizeof(*link));

    link->refcount = 1;
    link->disconnected = 1;
    link->pending_commands = 0;
    link->cc = NULL;
    link->pc = NULL;
    link->cc_conn_time = 0;
    link->pc_conn_time = 0;
    link->last_reconn_time = 0;
    link->pc_last_activity = 0;
    /* We set the act_ping_time to ""now"" even if we actually don't have yet
     * a connection with the node, nor we sent a ping.
     * This is useful to detect a timeout in case we'll not be able to connect
     * with the node at all. */
    link->act_ping_time = mstime();
    link->last_ping_time = 0;
    link->last_avail_time = mstime();
    link->last_pong_time = mstime();
    return link;
}",1018.0,1039.0,1.0,1.0,22.0,29,4,18,2,1,17,1,1,0,4,,0,17,2,1,1,instanceLink
4459,350460,instanceLinkCloseConnection,1,instanceLinkCloseConnection,"void instanceLinkCloseConnection (instanceLink*,redisAsyncContext*)",sentinel.c,"void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
    if (c == NULL) return;

    if (link->cc == c) {
        link->cc = NULL;
        link->pending_commands = 0;
    }
    if (link->pc == c) link->pc = NULL;
    c->data = NULL;
    link->disconnected = 1;
    redisAsyncFree(c);
}",1042.0,1053.0,1.0,1.0,12.0,15,3,15,3,14,6,4,4,2,0,,0,6,4,2,2,void
4460,350513,releaseInstanceLink,1,releaseInstanceLink,"instanceLink releaseInstanceLink (instanceLink*,sentinelRedisInstance*)",sentinel.c,"instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
{
    serverAssert(link->refcount > 0);
    link->refcount--;
    if (link->refcount != 0) {
        if (ri && ri->link->cc) {
            /* This instance may have pending callbacks in the hiredis async
             * context, having as 'privdata' the instance that we are going to
             * free. Let's rewrite the callback list, directly exploiting
             * hiredis internal data structures, in order to bind them with
             * a callback that will ignore the reply at all. */
            redisCallback *cb;
            redisCallbackList *callbacks = &link->cc->replies;

            cb = callbacks->head;
            while(cb) {
                if (cb->privdata == ri) {
                    cb->fn = sentinelDiscardReplyCallback;
                    cb->privdata = NULL; /* Not strictly needed. */
                }
                cb = cb->next;
            }
        }
        return link; /* ...",1063.0,1093.0,1.0,4.0,31.0,29,12,25,6,1,11,5,11,2,4,,0,7,4,2,2,instanceLink
4461,350613,sentinelTryConnectionSharing,1,sentinelTryConnectionSharing,int sentinelTryConnectionSharing (sentinelRedisInstance*),sentinel.c,"int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_SENTINEL);
    dictIterator *di;
    dictEntry *de;

    if (ri->runid == NULL) return C_ERR; /* No way to identify it. */
    if (ri->link->refcount > 1) return C_ERR; /* Already shared. */

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *master = dictGetVal(de), *match;
        /* We want to share with the same physical Sentinel referenced
         * in other masters, so skip our master. */
        if (master == ri->master) continue;
        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
                                                       NULL,0,ri->runid);
        if (match == NULL) continue; /* No match. */
        if (match == ri) continue; /* Should never happen but... safer. */

        /* We identified a matching Sentinel, great! Let's free our link
         * and use the one of the matching S...",1107.0,1136.0,1.0,4.0,30.0,34,14,28,7,1,20,10,10,4,8,,0,16,2,1,1,int
4462,350748,dropInstanceConnections,1,dropInstanceConnections,void dropInstanceConnections (sentinelRedisInstance*),sentinel.c,"void dropInstanceConnections(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_MASTER);

    /* Disconnect with the master. */
    instanceLinkCloseConnection(ri->link, ri->link->cc);
    instanceLinkCloseConnection(ri->link, ri->link->pc);
    
    /* Disconnect with all replicas. */
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *repl_ri;
    di = dictGetIterator(ri->slaves);
    while ((de = dictNext(di)) != NULL) {
        repl_ri = dictGetVal(de);
        instanceLinkCloseConnection(repl_ri->link, repl_ri->link->cc);
        instanceLinkCloseConnection(repl_ri->link, repl_ri->link->pc);
    }
    dictReleaseIterator(di);
}",1139.0,1157.0,1.0,4.0,19.0,24,9,17,5,0,19,2,2,1,9,,0,13,2,1,1,void
4463,350832,sentinelDropConnections,1,sentinelDropConnections,int sentinelDropConnections (void),sentinel.c,"int sentinelDropConnections(void) {
    dictIterator *di;
    dictEntry *de;
    int dropped = 0;

    di = dictGetIterator(sentinel.masters);
    while ((de = dictNext(di)) != NULL) {
        dictIterator *sdi;
        dictEntry *sde;

        sentinelRedisInstance *ri = dictGetVal(de);
        sdi = dictGetIterator(ri->sentinels);
        while ((sde = dictNext(sdi)) != NULL) {
            sentinelRedisInstance *si = dictGetVal(sde);
            if (!si->link->disconnected) {
                instanceLinkCloseConnection(si->link, si->link->pc);
                instanceLinkCloseConnection(si->link, si->link->cc);
                dropped++;
            }
        }
        dictReleaseIterator(sdi);
    }
    dictReleaseIterator(di);

    return dropped;
}",1161.0,1186.0,1.0,1.0,26.0,21,6,24,9,0,18,4,7,3,10,,0,14,2,1,1,int
4464,350917,sentinelUpdateSentinelAddressInAllMasters,1,sentinelUpdateSentinelAddressInAllMasters,int sentinelUpdateSentinelAddressInAllMasters (sentinelRedisInstance*),sentinel.c,"int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_SENTINEL);
    dictIterator *di;
    dictEntry *de;
    int reconfigured = 0;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *master = dictGetVal(de), *match;
        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
                                                       NULL,0,ri->runid);
        /* If there is no match, this master does not know about this
         * Sentinel, try with the next one. */
        if (match == NULL) continue;

        /* Disconnect the old links if connected. */
        if (match->link->cc != NULL)
            instanceLinkCloseConnection(match->link,match->link->cc);
        if (match->link->pc != NULL)
            instanceLinkCloseConnection(match->link,match->link->pc);

        if (match == ri) continue; /* Address already updated for it. */

        /* Updat...",1194.0,1228.0,1.0,4.0,35.0,35,12,34,8,1,25,9,11,3,11,,0,19,2,1,1,int
4465,351129,createSentinelRedisInstance,1,createSentinelRedisInstance,"sentinelRedisInstance createSentinelRedisInstance (char*,int,char*,int,int,sentinelRedisInstance*)",sentinel.c,"sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {
    sentinelRedisInstance *ri;
    sentinelAddr *addr;
    dict *table = NULL;
    sds sdsname;

    serverAssert(flags & (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
    serverAssert((flags & SRI_MASTER) || master != NULL);

    /* Check address validity. */
    addr = createSentinelAddr(hostname,port,1);
    if (addr == NULL) return NULL;

    /* For slaves use ip/host:port as name. */
    if (flags & SRI_SLAVE)
        sdsname = announceSentinelAddrAndPort(addr);
    else
        sdsname = sdsnew(name);

    /* Make sure the entry is not duplicated. This may happen when the same
     * name for a master is used multiple times inside the configuration or
     * if we try to add multiple times a slave or sentinel with same ip/port
     * to a master. */
    if (flags & SRI_MASTER) table = sentinel.masters;
    else if (flags & SRI_SLAVE) table = ...",1285.0,1375.0,1.0,4.0,91.0,133,16,98,17,4,73,5,5,1,18,,0,68,12,6,6,sentinelRedisInstance
4466,351654,sentinelRedisInstanceLookupSlave,1,sentinelRedisInstanceLookupSlave,"sentinelRedisInstance sentinelRedisInstanceLookupSlave (sentinelRedisInstance*,char*,int)",sentinel.c,"sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
                sentinelRedisInstance *ri, char *slave_addr, int port)
{
    sds key;
    sentinelRedisInstance *slave;
    sentinelAddr *addr;

    serverAssert(ri->flags & SRI_MASTER);

    /* We need to handle a slave_addr that is potentially a hostname.
     * If that is the case, depending on configuration we either resolve
     * it and use the IP address or fail.
     */
    addr = createSentinelAddr(slave_addr, port, 0);
    if (!addr) return NULL;
    key = announceSentinelAddrAndPort(addr);
    releaseSentinelAddr(addr);

    slave = dictFetchValue(ri->slaves,key);
    sdsfree(key);
    return slave;
}",1410.0,1431.0,1.0,4.0,22.0,12,9,14,7,1,8,2,2,0,6,,0,5,6,3,3,sentinelRedisInstance
4467,351765,removeMatchingSentinelFromMaster,1,removeMatchingSentinelFromMaster,"int removeMatchingSentinelFromMaster (sentinelRedisInstance*,char*)",sentinel.c,"int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {
    dictIterator *di;
    dictEntry *de;
    int removed = 0;

    if (runid == NULL) return 0;

    di = dictGetSafeIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->runid && strcmp(ri->runid,runid) == 0) {
            dictDelete(master->sentinels,ri->name);
            removed++;
        }
    }
    dictReleaseIterator(di);
    return removed;
}",1452.0,1470.0,1.0,1.0,19.0,14,6,18,7,1,10,4,5,3,5,,0,8,4,2,2,int
4468,351966,sentinelResetMaster,1,sentinelResetMaster,"void sentinelResetMaster (sentinelRedisInstance*,int)",sentinel.c,"void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
    serverAssert(ri->flags & SRI_MASTER);
    dictRelease(ri->slaves);
    ri->slaves = dictCreate(&instancesDictType);
    if (!(flags & SENTINEL_RESET_NO_SENTINELS)) {
        dictRelease(ri->sentinels);
        ri->sentinels = dictCreate(&instancesDictType);
    }
    instanceLinkCloseConnection(ri->link,ri->link->cc);
    instanceLinkCloseConnection(ri->link,ri->link->pc);
    ri->flags &= SRI_MASTER;
    if (ri->leader) {
        sdsfree(ri->leader);
        ri->leader = NULL;
    }
    ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
    ri->failover_state_change_time = 0;
    ri->failover_start_time = 0; /* We can failover again ASAP. */
    ri->promoted_slave = NULL;
    sdsfree(ri->runid);
    sdsfree(ri->slave_master_host);
    ri->runid = NULL;
    ri->slave_master_host = NULL;
    ri->link->act_ping_time = mstime();
    ri->link->last_ping_time = 0;
    ri->link->last_avail_time = mstime();
    ri->link->...",1533.0,1564.0,1.0,4.0,32.0,63,10,36,4,2,44,4,4,1,15,,0,35,4,2,2,void
4469,352163,sentinelResetMastersByPattern,1,sentinelResetMastersByPattern,"int sentinelResetMastersByPattern (char*,int)",sentinel.c,"int sentinelResetMastersByPattern(char *pattern, int flags) {
    dictIterator *di;
    dictEntry *de;
    int reset = 0;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->name) {
            if (stringmatch(pattern,ri->name,0)) {
                sentinelResetMaster(ri,flags);
                reset++;
            }
        }
    }
    dictReleaseIterator(di);
    return reset;
}",1568.0,1586.0,1.0,1.0,19.0,9,5,16,8,0,10,4,7,4,6,,0,8,4,2,2,int
4470,352216,sentinelResetMasterAndChangeAddress,1,sentinelResetMasterAndChangeAddress,"int sentinelResetMasterAndChangeAddress (sentinelRedisInstance*,char*,int)",sentinel.c,"int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *hostname, int port) {
    sentinelAddr *oldaddr, *newaddr;
    sentinelAddr **slaves = NULL;
    int numslaves = 0, j;
    dictIterator *di;
    dictEntry *de;

    newaddr = createSentinelAddr(hostname,port,0);
    if (newaddr == NULL) return C_ERR;

    /* There can be only 0 or 1 slave that has the newaddr.
     * and It can add old master 1 more slave. 
     * so It allocates dictSize(master->slaves) + 1          */
    slaves = zmalloc(sizeof(sentinelAddr*)*(dictSize(master->slaves) + 1));
    
    /* Don't include the one having the address we are switching to. */
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (sentinelAddrOrHostnameEqual(slave->addr,newaddr)) continue;
        slaves[numslaves++] = dupSentinelAddr(slave->addr);
    }
    dictReleaseIterator(di);

    /* If we are switching to a diff...",1595.0,1650.0,1.0,32.0,56.0,52,13,55,13,2,30,8,9,5,17,,0,23,6,3,3,int
4471,352420,sentinelRedisInstanceNoDownFor,1,sentinelRedisInstanceNoDownFor,"int sentinelRedisInstanceNoDownFor (sentinelRedisInstance*,mstime_t)",sentinel.c,"int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
    mstime_t most_recent;

    most_recent = ri->s_down_since_time;
    if (ri->o_down_since_time > most_recent)
        most_recent = ri->o_down_since_time;
    return most_recent == 0 || (mstime() - most_recent) > ms;
}",1654.0,1661.0,1.0,1.0,8.0,10,6,9,3,1,4,2,2,1,1,,0,3,4,2,2,int
4472,352454,sentinelGetCurrentMasterAddress,1,sentinelGetCurrentMasterAddress,sentinelAddr sentinelGetCurrentMasterAddress (sentinelRedisInstance*),sentinel.c,"sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {
    /* If we are failing over the master, and the state is already
     * SENTINEL_FAILOVER_STATE_RECONF_SLAVES or greater, it means that we
     * already have the new configuration epoch in the master, and the
     * slave acknowledged the configuration switch. Advertise the new
     * address. */
    if ((master->flags & SRI_FAILOVER_IN_PROGRESS) &&
        master->promoted_slave &&
        master->failover_state >= SENTINEL_FAILOVER_STATE_RECONF_SLAVES)
    {
        return master->promoted_slave->addr;
    } else {
        return master->addr;
    }
}",1665.0,1679.0,1.0,25.0,15.0,10,5,4,1,1,4,2,2,3,0,,0,4,2,1,1,sentinelAddr
4473,352494,sentinelPropagateDownAfterPeriod,1,sentinelPropagateDownAfterPeriod,void sentinelPropagateDownAfterPeriod (sentinelRedisInstance*),sentinel.c,"void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int j;
    dict *d[] = {master->slaves, master->sentinels, NULL};

    for (j = 0; d[j]; j++) {
        di = dictGetIterator(d[j]);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);
            ri->down_after_period = master->down_after_period;
        }
        dictReleaseIterator(di);
    }
}",1683.0,1697.0,1.0,1.0,15.0,14,5,18,7,0,8,3,4,1,4,,0,7,2,1,1,void
4474,352552,sentinelInstanceMapCommand,1,sentinelInstanceMapCommand,"char* sentinelInstanceMapCommand (sentinelRedisInstance*,char*)",sentinel.c,"char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {
    sds sc = sdsnew(command);
    if (ri->master) ri = ri->master;
    char *retval = dictFetchValue(ri->renamed_commands, sc);
    sdsfree(sc);
    return retval ? retval : command;
}",1706.0,1712.0,1.0,1.0,7.0,7,3,12,4,5,6,2,2,1,3,,0,5,4,2,2,char*
4475,352588,sentinelCheckCreateInstanceErrors,1,sentinelCheckCreateInstanceErrors,const char* sentinelCheckCreateInstanceErrors (int),sentinel.c,"const char *sentinelCheckCreateInstanceErrors(int role) {
    switch(errno) {
    case EBUSY:
        switch (role) {
        case SRI_MASTER:
            return ""Duplicate master name."";
        case SRI_SLAVE:
            return ""Duplicate hostname and port for replica."";
        case SRI_SENTINEL:
            return ""Duplicate runid for sentinel."";
        default:
            serverAssert(0);
            break;
        }
        break;
    case ENOENT:
        return ""Can't resolve instance hostname."";
    case EINVAL:
        return ""Invalid port number."";
    default:
        return ""Unknown Error for creating instances."";
    }
}",1718.0,1740.0,1.0,13.0,23.0,7,5,5,5,1,1,5,4,0,1,,0,0,2,1,1,const char*
4476,352654,initializeSentinelConfig,1,initializeSentinelConfig,void initializeSentinelConfig (void),sentinel.c,"void initializeSentinelConfig(void) {
    server.sentinel_config = zmalloc(sizeof(struct sentinelConfig));
    server.sentinel_config->monitor_cfg = listCreate();
    server.sentinel_config->pre_monitor_cfg = listCreate();
    server.sentinel_config->post_monitor_cfg = listCreate();
    listSetFreeMethod(server.sentinel_config->monitor_cfg,freeSentinelLoadQueueEntry);
    listSetFreeMethod(server.sentinel_config->pre_monitor_cfg,freeSentinelLoadQueueEntry);
    listSetFreeMethod(server.sentinel_config->post_monitor_cfg,freeSentinelLoadQueueEntry);
}",1743.0,1751.0,1.0,4.0,9.0,30,4,17,3,1,4,1,1,0,4,,0,4,2,1,1,void
4477,352738,freeSentinelConfig,1,freeSentinelConfig,void freeSentinelConfig (void),sentinel.c,"void freeSentinelConfig(void) {
    /* release these three config queues since we will not use it anymore */
    listRelease(server.sentinel_config->pre_monitor_cfg);
    listRelease(server.sentinel_config->monitor_cfg);
    listRelease(server.sentinel_config->post_monitor_cfg);
    zfree(server.sentinel_config);
    server.sentinel_config = NULL;
}",1754.0,1761.0,1.0,1.0,8.0,9,3,6,2,1,4,1,1,0,4,,0,0,2,1,1,void
4478,352770,searchPreMonitorCfgName,1,searchPreMonitorCfgName,int searchPreMonitorCfgName (char*),sentinel.c,"int searchPreMonitorCfgName(const char *name) {
    for (unsigned int i = 0; i < sizeof(preMonitorCfgName)/sizeof(preMonitorCfgName[0]); i++) {
        if (!strcasecmp(preMonitorCfgName[i],name)) return 1;
    }
    return 0;
}",1765.0,1770.0,1.0,1.0,6.0,8,6,7,3,0,3,3,4,3,0,,0,3,2,1,1,int
4479,352827,queueSentinelConfig,1,queueSentinelConfig,"void queueSentinelConfig (sds*,int,int,sds)",sentinel.c,"void queueSentinelConfig(sds *argv, int argc, int linenum, sds line) {
    int i;
    struct sentinelLoadQueueEntry *entry;

    /* initialize sentinel_config for the first call */
    if (server.sentinel_config == NULL) initializeSentinelConfig();

    entry = zmalloc(sizeof(struct sentinelLoadQueueEntry));
    entry->argv = zmalloc(sizeof(char*)*argc);
    entry->argc = argc;
    entry->linenum = linenum;
    entry->line = sdsdup(line);
    for (i = 0; i < argc; i++) {
        entry->argv[i] = sdsdup(argv[i]);
    }
    /*  Separate config lines with pre monitor config, monitor config and
     *  post monitor config, in order to parsing config dependencies
     *  correctly. */
    if (!strcasecmp(argv[0],""monitor"")) {
        listAddNodeTail(server.sentinel_config->monitor_cfg,entry);
    } else if (searchPreMonitorCfgName(argv[0])) {
        listAddNodeTail(server.sentinel_config->pre_monitor_cfg,entry);
    } else{
        listAddNodeTail(server.sentinel_config->post_monitor_cf...",1783.0,1808.0,1.0,1.0,26.0,24,9,23,10,0,11,4,4,0,6,,0,9,8,4,4,void
4480,352935,loadSentinelConfigFromQueue,1,loadSentinelConfigFromQueue,void loadSentinelConfigFromQueue (void),sentinel.c,"void loadSentinelConfigFromQueue(void) {
    const char *err = NULL;
    listIter li;
    listNode *ln;
    int linenum = 0;
    sds line = NULL;
    unsigned int j;

    /* if there is no sentinel_config entry, we can return immediately */
    if (server.sentinel_config == NULL) return;

    list *sentinel_configs[3] = {
        server.sentinel_config->pre_monitor_cfg,
        server.sentinel_config->monitor_cfg,
        server.sentinel_config->post_monitor_cfg
    };
    /* loading from pre monitor config queue first to avoid dependency issues
     * loading from monitor config queue
     * loading from the post monitor config queue */
    for (j = 0; j < sizeof(sentinel_configs) / sizeof(sentinel_configs[0]); j++) {
        listRewind(sentinel_configs[j],&li);
        while((ln = listNext(&li))) {
            struct sentinelLoadQueueEntry *entry = ln->value;
            err = sentinelHandleConfiguration(entry->argv,entry->argc);
            if (err) {
                linenum = en...",1812.0,1855.0,1.0,8.0,44.0,32,10,37,11,0,9,6,8,1,4,,0,7,2,1,1,void
4481,353064,sentinelHandleConfiguration,1,sentinelHandleConfiguration,"const char* sentinelHandleConfiguration (char**,int)",sentinel.c,"const char *sentinelHandleConfiguration(char **argv, int argc) {

    sentinelRedisInstance *ri;

    if (!strcasecmp(argv[0],""monitor"") && argc == 5) {
        /* monitor <name> <host> <port> <quorum> */
        int quorum = atoi(argv[4]);

        if (quorum <= 0) return ""Quorum must be 1 or greater."";
        if (createSentinelRedisInstance(argv[1],SRI_MASTER,argv[2],
                                        atoi(argv[3]),quorum,NULL) == NULL)
        {
            return sentinelCheckCreateInstanceErrors(SRI_MASTER);
        }
    } else if (!strcasecmp(argv[0],""down-after-milliseconds"") && argc == 3) {
        /* down-after-milliseconds <name> <milliseconds> */
        ri = sentinelGetMasterByName(argv[1]);
        if (!ri) return ""No such master with specified name."";
        ri->down_after_period = atoi(argv[2]);
        if (ri->down_after_period <= 0)
            return ""negative or zero time parameter."";
        sentinelPropagateDownAfterPeriod(ri);
    } else if (!strcasecm...",1857.0,2022.0,1.0,48.0,166.0,13,7,12,4,1,2,4,6,1,2,,0,1,4,2,2,const char*
4482,354771,sentinelFlushConfigAndReply,1,sentinelFlushConfigAndReply,void sentinelFlushConfigAndReply (client*),sentinel.c,"static void sentinelFlushConfigAndReply(client *c) {
    if (sentinelFlushConfig() == C_ERR)
        addReplyError(c, ""Failed to save config file. Check server logs."");
    else
        addReply(c, shared.ok);
}",2302.0,2307.0,1.0,33.0,6.0,2,2,1,1,0,2,2,2,1,2,,0,1,2,1,1,void
4483,354794,sentinelSendAuthIfNeeded,1,sentinelSendAuthIfNeeded,"void sentinelSendAuthIfNeeded (sentinelRedisInstance*,redisAsyncContext*)",sentinel.c,"void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
    char *auth_pass = NULL;
    char *auth_user = NULL;

    if (ri->flags & SRI_MASTER) {
        auth_pass = ri->auth_pass;
        auth_user = ri->auth_user;
    } else if (ri->flags & SRI_SLAVE) {
        auth_pass = ri->master->auth_pass;
        auth_user = ri->master->auth_user;
    } else if (ri->flags & SRI_SENTINEL) {
        /* If sentinel_auth_user is NULL, AUTH will use default user
           with sentinel_auth_pass to authenticate */
        if (sentinel.sentinel_auth_pass) {
            auth_pass = sentinel.sentinel_auth_pass;
            auth_user = sentinel.sentinel_auth_user;
        } else {
            /* Compatibility with old configs. requirepass is used
             * for both incoming and outgoing authentication. */
            auth_pass = server.requirepass;
            auth_user = NULL;
        }
    }

    if (auth_pass && auth_user == NULL) {
        if (redisAsyncCommand(c,...",2323.0,2358.0,1.0,20.0,36.0,15,7,18,6,0,5,4,5,2,1,,0,5,4,2,2,void
4484,354951,sentinelSetClientName,1,sentinelSetClientName,"void sentinelSetClientName (sentinelRedisInstance*,redisAsyncContext*,char*)",sentinel.c,"void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {
    char name[64];

    snprintf(name,sizeof(name),""sentinel-%.8s-%s"",sentinel.myid,type);
    if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri,
        ""%s SETNAME %s"",
        sentinelInstanceMapCommand(ri,""CLIENT""),
        name) == C_OK)
    {
        ri->link->pending_commands++;
    }
}",2366.0,2377.0,1.0,17.0,12.0,6,5,10,6,0,4,2,2,1,1,,0,4,6,3,3,void
4485,355004,sentinelReconnectInstance,1,sentinelReconnectInstance,void sentinelReconnectInstance (sentinelRedisInstance*),sentinel.c,"void sentinelReconnectInstance(sentinelRedisInstance *ri) {

    if (ri->link->disconnected == 0) return;
    if (ri->addr->port == 0) return; /* port == 0 means invalid address. */
    instanceLink *link = ri->link;
    mstime_t now = mstime();

    if (now - ri->link->last_reconn_time < sentinel_ping_period) return;
    ri->link->last_reconn_time = now;

    /* Commands connection. */
    if (link->cc == NULL) {

        /* It might be that the instance is disconnected because it wasn't available earlier when the instance
         * allocated, say during failover, and therefore we failed to resolve its ip.
         * Another scenario is that the instance restarted with new ip, and we should resolve its new ip based on
         * its hostname */
        if (sentinel.resolve_hostnames) {
            sentinelAddr *tryResolveAddr = createSentinelAddr(ri->addr->hostname, ri->addr->port, 0);
            if (tryResolveAddr != NULL) {
                releaseSentinelAddr(ri->addr);
       ...",2398.0,2493.0,1.0,26.0,96.0,79,13,46,8,1,40,13,20,18,7,,0,35,2,1,1,void
4486,355487,sentinelMasterLooksSane,1,sentinelMasterLooksSane,int sentinelMasterLooksSane (sentinelRedisInstance*),sentinel.c,"int sentinelMasterLooksSane(sentinelRedisInstance *master) {
    return
        master->flags & SRI_MASTER &&
        master->role_reported == SRI_MASTER &&
        (master->flags & (SRI_S_DOWN|SRI_O_DOWN)) == 0 &&
        (mstime() - master->info_refresh) < sentinel_info_period*2;
}",2502.0,2508.0,1.0,24.0,7.0,19,9,5,2,1,6,1,1,0,1,,0,5,2,1,1,int
4487,355540,sentinelRefreshInstanceInfo,1,sentinelRefreshInstanceInfo,"void sentinelRefreshInstanceInfo (sentinelRedisInstance*,char*)",sentinel.c,"void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
    sds *lines;
    int numlines, j;
    int role = 0;

    /* cache full INFO output for instance */
    sdsfree(ri->info);
    ri->info = sdsnew(info);

    /* The following fields must be reset to a given value in the case they
     * are not found at all in the INFO output. */
    ri->master_link_down_time = 0;

    /* Process line by line. */
    lines = sdssplitlen(info,strlen(info),""\r\n"",2,&numlines);
    for (j = 0; j < numlines; j++) {
        sentinelRedisInstance *slave;
        sds l = lines[j];

        /* run_id:<40 hex chars>*/
        if (sdslen(l) >= 47 && !memcmp(l,""run_id:"",7)) {
            if (ri->runid == NULL) {
                ri->runid = sdsnewlen(l+7,40);
            } else {
                if (strncmp(ri->runid,l+7,40) != 0) {
                    sentinelEvent(LL_NOTICE,""+reboot"",ri,""%@"");

                    if (ri->flags & SRI_MASTER && ri->master_reboot_down_after_period ...",2511.0,2766.0,1.0,34.0,256.0,255,23,165,16,1,110,38,85,50,43,,0,95,4,2,2,void
4488,356632,sentinelInfoReplyCallback,1,sentinelInfoReplyCallback,"void sentinelInfoReplyCallback (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* INFO reply type is verbatim in resp3. Normally, sentinel will not use
     * resp3 but this is required for testing (see logreqres.c). */
    if (r->type == REDIS_REPLY_STRING || r->type == REDIS_REPLY_VERB)
        sentinelRefreshInstanceInfo(ri,r->str);
}",2768.0,2781.0,1.0,1.0,14.0,15,6,15,8,0,2,3,3,0,1,,0,1,6,3,3,void
4489,356715,sentinelPingReplyCallback,1,sentinelPingReplyCallback,"void sentinelPingReplyCallback (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    if (r->type == REDIS_REPLY_STATUS ||
        r->type == REDIS_REPLY_ERROR) {
        /* Update the ""instance available"" field only if this is an
         * acceptable reply. */
        if (strncmp(r->str,""PONG"",4) == 0 ||
            strncmp(r->str,""LOADING"",7) == 0 ||
            strncmp(r->str,""MASTERDOWN"",10) == 0)
        {
            link->last_avail_time = mstime();
            link->act_ping_time = 0; /* Flag the pong as received. */

            if (ri->flags & SRI_MASTER_REBOOT && strncmp(r->str,""PONG"",4) == 0)
                ri->flags &= ~SRI_MASTER_REBOOT;

        } else {
            /* Send a SCRIPT KILL command if the instance appears to be
             * down because of a busy script. */
            if (str...",2793.0,2835.0,1.0,28.0,43.0,37,10,22,8,0,8,5,8,1,2,,0,8,6,3,3,void
4490,356900,sentinelPublishReplyCallback,1,sentinelPublishReplyCallback,"void sentinelPublishReplyCallback (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* Only update pub_time if we actually published our message. Otherwise
     * we'll retry again in 100 milliseconds. */
    if (r->type != REDIS_REPLY_ERROR)
        ri->last_pub_time = mstime();
}",2839.0,2852.0,1.0,1.0,14.0,13,6,12,7,0,3,3,3,0,1,,0,3,6,3,3,void
4491,356945,sentinelProcessHelloMessage,1,sentinelProcessHelloMessage,"void sentinelProcessHelloMessage (char*,int)",sentinel.c,"void sentinelProcessHelloMessage(char *hello, int hello_len) {
    /* Format is composed of 8 tokens:
     * 0=ip,1=port,2=runid,3=current_epoch,4=master_name,
     * 5=master_ip,6=master_port,7=master_config_epoch. */
    int numtokens, port, removed, master_port;
    uint64_t current_epoch, master_config_epoch;
    char **token = sdssplitlen(hello, hello_len, "","", 1, &numtokens);
    sentinelRedisInstance *si, *master;

    if (numtokens == 8) {
        /* Obtain a reference to the master this hello message is about */
        master = sentinelGetMasterByName(token[4]);
        if (!master) goto cleanup; /* Unknown master, skip the message. */

        /* First, try to see if we already have this sentinel. */
        port = atoi(token[1]);
        master_port = atoi(token[6]);
        si = getSentinelRedisInstanceByAddrAndRunID(
                        master->sentinels,token[0],port,token[2]);
        current_epoch = strtoull(token[3],NULL,10);
        master_config_epoch = strto...",2859.0,2971.0,1.0,30.0,113.0,62,14,81,14,1,42,13,29,6,23,,0,29,4,2,2,void
4492,357417,sentinelSendHello,1,sentinelSendHello,int sentinelSendHello (sentinelRedisInstance*),sentinel.c,"int sentinelSendHello(sentinelRedisInstance *ri) {
    char ip[NET_IP_STR_LEN];
    char payload[NET_IP_STR_LEN+1024];
    int retval;
    char *announce_ip;
    int announce_port;
    sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ? ri : ri->master;
    sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);

    if (ri->link->disconnected) return C_ERR;

    /* Use the specified announce address if specified, otherwise try to
     * obtain our own IP address. */
    if (sentinel.announce_ip) {
        announce_ip = sentinel.announce_ip;
    } else {
        if (anetFdToString(ri->link->cc->c.fd,ip,sizeof(ip),NULL,0) == -1)
            return C_ERR;
        announce_ip = ip;
    }
    if (sentinel.announce_port) announce_port = sentinel.announce_port;
    else if (server.tls_replication && server.tls_port) announce_port = server.tls_port;
    else announce_port = server.port;

    /* Format and send the Hello message. */
    snprintf(payload,sizeof(payload),
...",3017.0,3057.0,1.0,12.0,41.0,32,11,30,8,1,23,5,5,5,3,,0,22,2,1,1,int
4493,357602,sentinelForceHelloUpdateDictOfRedisInstances,1,sentinelForceHelloUpdateDictOfRedisInstances,void sentinelForceHelloUpdateDictOfRedisInstances (dict*),sentinel.c,"void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        if (ri->last_pub_time >= (sentinel_publish_period+1))
            ri->last_pub_time -= (sentinel_publish_period+1);
    }
    dictReleaseIterator(di);
}",3061.0,3072.0,1.0,1.0,12.0,10,6,12,6,0,8,3,4,3,4,,0,7,2,1,1,void
4494,357760,sentinelSendPeriodicCommands,1,sentinelSendPeriodicCommands,void sentinelSendPeriodicCommands (sentinelRedisInstance*),sentinel.c,"void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
    mstime_t now = mstime();
    mstime_t info_period, ping_period;
    int retval;

    /* Return ASAP if we have already a PING or INFO already pending, or
     * in the case the instance is not properly connected. */
    if (ri->link->disconnected) return;

    /* For INFO, PING, PUBLISH that are not critical commands to send we
     * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't
     * want to use a lot of memory just because a link is not working
     * properly (note that anyway there is a redundant protection about this,
     * that is, the link will be disconnected and reconnected if a long
     * timeout condition is detected. */
    if (ri->link->pending_commands >=
        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) return;

    /* If this is a slave of a master in O_DOWN condition we start sending
     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD
     * period. In ...",3116.0,3178.0,1.0,8.0,63.0,58,15,36,7,1,22,9,10,14,4,,0,20,2,1,1,void
4495,357944,populateDict,1,populateDict,"void populateDict (dict*,char**)",sentinel.c,"static void populateDict(dict *options_dict, char **options) {
    for (int i=0; options[i]; i++) {
        sds option = sdsnew(options[i]);
        if (dictAdd(options_dict, option, NULL)==DICT_ERR)
            sdsfree(option);
    }
}",3181.0,3187.0,1.0,49.0,7.0,5,3,10,5,0,3,3,4,1,3,,0,2,4,2,2,void
4496,358908,sentinelFailoverStateStr,1,sentinelFailoverStateStr,const char* sentinelFailoverStateStr (int),sentinel.c,"const char *sentinelFailoverStateStr(int state) {
    switch(state) {
    case SENTINEL_FAILOVER_STATE_NONE: return ""none"";
    case SENTINEL_FAILOVER_STATE_WAIT_START: return ""wait_start"";
    case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return ""select_slave"";
    case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return ""send_slaveof_noone"";
    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return ""wait_promotion"";
    case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return ""reconf_slaves"";
    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return ""update_config"";
    default: return ""unknown"";
    }
}",3386.0,3397.0,1.0,9.0,12.0,0,0,1,1,1,0,2,2,0,0,,0,0,2,1,1,const char*
4497,358961,addReplySentinelRedisInstance,1,addReplySentinelRedisInstance,"void addReplySentinelRedisInstance (client*,sentinelRedisInstance*)",sentinel.c,"void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
    char *flags = sdsempty();
    void *mbl;
    int fields = 0;

    mbl = addReplyDeferredLen(c);

    addReplyBulkCString(c,""name"");
    addReplyBulkCString(c,ri->name);
    fields++;

    addReplyBulkCString(c,""ip"");
    addReplyBulkCString(c,announceSentinelAddr(ri->addr));
    fields++;

    addReplyBulkCString(c,""port"");
    addReplyBulkLongLong(c,ri->addr->port);
    fields++;

    addReplyBulkCString(c,""runid"");
    addReplyBulkCString(c,ri->runid ? ri->runid : """");
    fields++;

    addReplyBulkCString(c,""flags"");
    if (ri->flags & SRI_S_DOWN) flags = sdscat(flags,""s_down,"");
    if (ri->flags & SRI_O_DOWN) flags = sdscat(flags,""o_down,"");
    if (ri->flags & SRI_MASTER) flags = sdscat(flags,""master,"");
    if (ri->flags & SRI_SLAVE) flags = sdscat(flags,""slave,"");
    if (ri->flags & SRI_SENTINEL) flags = sdscat(flags,""sentinel,"");
    if (ri->link->disconnected) flags = sdscat(flags,""disconnect...",3400.0,3595.0,1.0,20.0,196.0,203,14,213,5,1,168,26,28,25,101,,0,95,4,2,2,void
4498,359783,sentinelSetDebugConfigParameters,1,sentinelSetDebugConfigParameters,void sentinelSetDebugConfigParameters (client*),sentinel.c,"void sentinelSetDebugConfigParameters(client *c){
    int j;
    int badarg = 0; /* Bad argument position for error reporting. */
    char *option;

    /* Process option - value pairs. */
    for (j = 2; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        option = c->argv[j]->ptr;
        long long ll;

        if (!strcasecmp(option,""info-period"") && moreargs > 0) {
            /* info-period <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            sentinel_info_period = ll;

        } else if (!strcasecmp(option,""ping-period"") && moreargs > 0) {
            /* ping-period <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            sentinel_ping_period = ll;

        } else if ...",3597.0,3740.0,1.0,48.0,144.0,31,16,28,9,0,9,5,7,2,3,,0,7,2,1,1,void
4499,360412,addReplySentinelDebugInfo,1,addReplySentinelDebugInfo,void addReplySentinelDebugInfo (client*),sentinel.c,"void addReplySentinelDebugInfo(client *c) {
    void *mbl;
    int fields = 0;

    mbl = addReplyDeferredLen(c);

    addReplyBulkCString(c,""INFO-PERIOD"");
    addReplyBulkLongLong(c,sentinel_info_period);
    fields++;

    addReplyBulkCString(c,""PING-PERIOD"");
    addReplyBulkLongLong(c,sentinel_ping_period);
    fields++;

    addReplyBulkCString(c,""ASK-PERIOD"");
    addReplyBulkLongLong(c,sentinel_ask_period);
    fields++;

    addReplyBulkCString(c,""PUBLISH-PERIOD"");
    addReplyBulkLongLong(c,sentinel_publish_period);
    fields++;

    addReplyBulkCString(c,""DEFAULT-DOWN-AFTER"");
    addReplyBulkLongLong(c,sentinel_default_down_after);
    fields++;

    addReplyBulkCString(c,""DEFAULT-FAILOVER-TIMEOUT"");
    addReplyBulkLongLong(c,sentinel_default_failover_timeout);
    fields++;

    addReplyBulkCString(c,""TILT-TRIGGER"");
    addReplyBulkLongLong(c,sentinel_tilt_trigger);
    fields++;

    addReplyBulkCString(c,""TILT-PERIOD"");
    addReplyBulkLongLong(c,sentinel_tilt_peri...",3742.0,3801.0,1.0,1.0,60.0,15,2,58,16,0,41,1,1,0,28,,0,14,2,1,1,void
4500,360534,addReplyDictOfRedisInstances,1,addReplyDictOfRedisInstances,"void addReplyDictOfRedisInstances (client*,dict*)",sentinel.c,"void addReplyDictOfRedisInstances(client *c, dict *instances) {
    dictIterator *di;
    dictEntry *de;
    long slaves = 0;
    void *replylen = addReplyDeferredLen(c);

    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        /* don't announce unannounced replicas */
        if (ri->flags & SRI_SLAVE && !ri->replica_announced) continue;
        addReplySentinelRedisInstance(c,ri);
        slaves++;
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c, replylen, slaves);
}",3805.0,3822.0,1.0,24.0,18.0,13,8,19,8,0,9,4,4,3,7,,0,6,4,2,2,void
4501,360596,sentinelGetMasterByNameOrReplyError,1,sentinelGetMasterByNameOrReplyError,"sentinelRedisInstance sentinelGetMasterByNameOrReplyError (client*,robj*)",sentinel.c,"sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
                        robj *name)
{
    sentinelRedisInstance *ri;

    ri = dictFetchValue(sentinel.masters,name->ptr);
    if (!ri) {
        addReplyError(c,""No such master with that name"");
        return NULL;
    }
    return ri;
}",3827.0,3838.0,1.0,1.0,12.0,4,4,7,5,0,4,2,2,0,2,,0,3,4,2,2,sentinelRedisInstance
4502,360623,sentinelIsQuorumReachable,1,sentinelIsQuorumReachable,"int sentinelIsQuorumReachable (sentinelRedisInstance*,int*)",sentinel.c,"int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
    dictIterator *di;
    dictEntry *de;
    int usable = 1; /* Number of usable Sentinels. Init to 1 to count myself. */
    int result = SENTINEL_ISQR_OK;
    int voters = dictSize(master->sentinels)+1; /* Known Sentinels + myself. */

    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
        usable++;
    }
    dictReleaseIterator(di);

    if (usable < (int)master->quorum) result |= SENTINEL_ISQR_NOQUORUM;
    if (usable < voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
    if (usableptr) *usableptr = usable;
    return result;
}",3843.0,3863.0,1.0,17.0,21.0,33,13,26,9,0,10,7,7,3,4,,0,9,4,2,2,int
4503,360748,sentinelCommand,1,sentinelCommand,void sentinelCommand (client*),sentinel.c,"void sentinelCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CKQUORUM <master-name>"",
""    Check if the current Sentinel configuration is able to reach the quorum"",
""    needed to failover a master and the majority needed to authorize the"",
""    failover."",
""CONFIG SET param value [param value ...]"",
""    Set a global Sentinel configuration parameter."",
""CONFIG GET <param> [param param param ...]"",
""    Get global Sentinel configuration parameter."",
""DEBUG [<param> <value> ...]"",
""    Show a list of configurable time parameters and their values (milliseconds)."",
""    Or update current configurable parameters values (one or more)."",
""GET-MASTER-ADDR-BY-NAME <master-name>"",
""    Return the ip and port number of the master with that name."",
""FAILOVER <master-name>"",
""    Manually failover a master node without asking for agreement from other"",
""    Sentinels"",
""FLUSHCONFIG"",
""    Force Sentinel to rewrite its configura...",3865.0,4241.0,1.0,44.0,377.0,9,7,7,3,0,4,2,2,2,2,,0,2,2,1,1,void
4504,362296,addInfoSectionsToDict,1,addInfoSectionsToDict,"void addInfoSectionsToDict (dict*,char**)",server.c,"void addInfoSectionsToDict(dict *section_dict, char **sections) {
    while (*sections) {
        sds section = sdsnew(*sections);
        if (dictAdd(section_dict, section, NULL)==DICT_ERR)
            sdsfree(section);
        sections++;
    }
}",5395.0,5402.0,1.0,50.0,8.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
4505,362302,sentinelInfoCommand,1,sentinelInfoCommand,void sentinelInfoCommand (client*),sentinel.c,"void sentinelInfoCommand(client *c) {
    char *sentinel_sections[] = {""server"", ""clients"", ""cpu"", ""stats"", ""sentinel"", NULL};
    int sec_all = 0, sec_everything = 0;
    static dict *cached_all_info_sections = NULL;

    /* Get requested section list. */
    dict *sections_dict = genInfoSectionDict(c->argv+1, c->argc-1, sentinel_sections, &sec_all, &sec_everything);

    /* Purge unsupported sections from the requested ones. */
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(sections_dict);
    while((de = dictNext(di)) != NULL) {
        int i;
        sds sec = dictGetKey(de);
        for (i=0; sentinel_sections[i]; i++)
            if (!strcasecmp(sentinel_sections[i], sec))
                break;
        /* section not found? remove it */
        if (!sentinel_sections[i])
            dictDelete(sections_dict, sec);
    }
    dictReleaseIterator(di);

    /* Insert explicit all sections (don't pass these vars to genRedisInfoString) */
    if (sec_all || sec_every...",4246.0,4323.0,1.0,12.0,78.0,86,17,87,17,1,57,11,18,5,23,,0,50,2,1,1,void
4506,362638,sentinelRoleCommand,1,sentinelRoleCommand,void sentinelRoleCommand (client*),sentinel.c,"void sentinelRoleCommand(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c,2);
    addReplyBulkCBuffer(c,""sentinel"",8);
    addReplyArrayLen(c,dictSize(sentinel.masters));

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        addReplyBulkCString(c,ri->name);
    }
    dictReleaseIterator(di);
}",4327.0,4342.0,1.0,23.0,16.0,14,6,16,6,1,17,2,2,1,8,,0,12,2,1,1,void
4507,363437,sentinelPublishCommand,1,sentinelPublishCommand,void sentinelPublishCommand (client*),sentinel.c,"void sentinelPublishCommand(client *c) {
    if (strcmp(c->argv[1]->ptr,SENTINEL_HELLO_CHANNEL)) {
        addReplyError(c, ""Only HELLO messages are accepted by Sentinel instances."");
        return;
    }
    sentinelProcessHelloMessage(c->argv[2]->ptr,sdslen(c->argv[2]->ptr));
    addReplyLongLong(c,1);
}",4525.0,4532.0,1.0,31.0,8.0,9,2,5,1,1,7,2,2,1,4,,0,4,2,1,1,void
4508,363478,sentinelCheckSubjectivelyDown,1,sentinelCheckSubjectivelyDown,void sentinelCheckSubjectivelyDown (sentinelRedisInstance*),sentinel.c,"void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
    mstime_t elapsed = 0;

    if (ri->link->act_ping_time)
        elapsed = mstime() - ri->link->act_ping_time;
    else if (ri->link->disconnected)
        elapsed = mstime() - ri->link->last_avail_time;

    /* Check if we are in need for a reconnection of one of the
     * links, because we are detecting low activity.
     *
     * 1) Check if the command link seems connected, was connected not less
     *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have a
     *    pending ping for more than half the timeout. */
    if (ri->link->cc &&
        (mstime() - ri->link->cc_conn_time) >
        sentinel_min_link_reconnect_period &&
        ri->link->act_ping_time != 0 && /* There is a pending ping... */
        /* The pending ping is delayed, and we did not receive
         * error replies as well. */
        (mstime() - ri->link->act_ping_time) > (ri->down_after_period/2) &&
        (mstime() - ri->link->l...",4537.0,4603.0,1.0,21.0,67.0,85,13,35,5,1,43,6,7,31,12,,0,40,2,1,1,void
4509,363752,sentinelCheckObjectivelyDown,1,sentinelCheckObjectivelyDown,void sentinelCheckObjectivelyDown (sentinelRedisInstance*),sentinel.c,"void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    unsigned int quorum = 0, odown = 0;

    if (master->flags & SRI_S_DOWN) {
        /* Is down for enough sentinels? */
        quorum = 1; /* the current sentinel. */
        /* Count all the other sentinels. */
        di = dictGetIterator(master->sentinels);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);

            if (ri->flags & SRI_MASTER_DOWN) quorum++;
        }
        dictReleaseIterator(di);
        if (quorum >= master->quorum) odown = 1;
    }

    /* Set the flag accordingly to the outcome. */
    if (odown) {
        if ((master->flags & SRI_O_DOWN) == 0) {
            sentinelEvent(LL_WARNING,""+odown"",master,""%@ #quorum %d/%d"",
                quorum, master->quorum);
            master->flags |= SRI_O_DOWN;
            master->o_down_since_time = mstime();
        }
    } else {
        if (master->fla...",4611.0,4644.0,1.0,24.0,34.0,27,8,24,7,1,14,7,12,5,6,,0,12,2,1,1,void
4510,363896,sentinelReceiveIsMasterDownReply,1,sentinelReceiveIsMasterDownReply,"void sentinelReceiveIsMasterDownReply (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* Ignore every error or unexpected reply.
     * Note that if the command returns an error for any reason we'll
     * end clearing the SRI_MASTER_DOWN flag for timeout anyway. */
    if (r->type == REDIS_REPLY_ARRAY && r->elements == 3 &&
        r->element[0]->type == REDIS_REPLY_INTEGER &&
        r->element[1]->type == REDIS_REPLY_STRING &&
        r->element[2]->type == REDIS_REPLY_INTEGER)
    {
        ri->last_master_down_reply_time = mstime();
        if (r->element[0]->integer == 1) {
            ri->flags |= SRI_MASTER_DOWN;
        } else {
            ri->flags &= ~SRI_MASTER_DOWN;
        }
        if (strcmp(r->element[1]->str,""*"")) {
            /* If the runid in the reply is not ""*"" the Sentinel act...",4648.0,4684.0,1.0,25.0,37.0,68,14,33,10,0,12,6,10,1,4,,0,10,6,3,3,void
4511,364099,sentinelAskMasterStateToOtherSentinels,1,sentinelAskMasterStateToOtherSentinels,"void sentinelAskMasterStateToOtherSentinels (sentinelRedisInstance*,int)",sentinel.c,"void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        mstime_t elapsed = mstime() - ri->last_master_down_reply_time;
        char port[32];
        int retval;

        /* If the master state from other sentinel is too old, we clear it. */
        if (elapsed > sentinel_ask_period*5) {
            ri->flags &= ~SRI_MASTER_DOWN;
            sdsfree(ri->leader);
            ri->leader = NULL;
        }

        /* Only ask if master is down to other sentinels if:
         *
         * 1) We believe it is down, or there is a failover in progress.
         * 2) Sentinel is connected.
         * 3) We did not receive the info within SENTINEL_ASK_PERIOD ms. */
        if ((master->flags & SRI_S_DOWN) == 0) continue;
        if (ri->link->disconnected) continue;
        i...",4691.0,4733.0,1.0,26.0,43.0,45,17,35,11,2,29,10,12,7,10,,0,26,4,2,2,void
4512,364404,sentinelLeaderIncr,1,sentinelLeaderIncr,"int sentinelLeaderIncr (dict*,char*)",sentinel.c,"int sentinelLeaderIncr(dict *counters, char *runid) {
    dictEntry *existing, *de;
    uint64_t oldval;

    de = dictAddRaw(counters,runid,&existing);
    if (existing) {
        oldval = dictGetUnsignedIntegerVal(existing);
        dictSetUnsignedIntegerVal(existing,oldval+1);
        return oldval+1;
    } else {
        serverAssert(de != NULL);
        dictSetUnsignedIntegerVal(de,1);
        return 1;
    }
}",4783.0,4797.0,1.0,8.0,15.0,5,3,10,5,2,3,2,2,0,3,,0,2,4,2,2,int
4513,364459,sentinelGetLeader,1,sentinelGetLeader,"char* sentinelGetLeader (sentinelRedisInstance*,uint64_t)",sentinel.c,"char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
    dict *counters;
    dictIterator *di;
    dictEntry *de;
    unsigned int voters = 0, voters_quorum;
    char *myvote;
    char *winner = NULL;
    uint64_t leader_epoch;
    uint64_t max_votes = 0;

    serverAssert(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
    counters = dictCreate(&leaderVotesDictType);

    voters = dictSize(master->sentinels)+1; /* All the other sentinels and me.*/

    /* Count other sentinels votes */
    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        if (ri->leader != NULL && ri->leader_epoch == sentinel.current_epoch)
            sentinelLeaderIncr(counters,ri->leader);
    }
    dictReleaseIterator(di);

    /* Check what's the winner. For the winner to win, it needs two conditions:
     * 1) Absolute majority between voters (50% + 1).
     * 2) And anyway at least master->...",4805.0,4868.0,1.0,4.0,64.0,62,20,73,16,1,29,9,12,7,17,,0,23,4,2,2,char*
4514,364982,sentinelStartFailoverIfNeeded,1,sentinelStartFailoverIfNeeded,int sentinelStartFailoverIfNeeded (sentinelRedisInstance*),sentinel.c,"int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
    /* We can't failover if the master is not in O_DOWN state. */
    if (!(master->flags & SRI_O_DOWN)) return 0;

    /* Failover already in progress? */
    if (master->flags & SRI_FAILOVER_IN_PROGRESS) return 0;

    /* Last failover attempt started too little time ago? */
    if (mstime() - master->failover_start_time <
        master->failover_timeout*2)
    {
        if (master->failover_delay_logged != master->failover_start_time) {
            time_t clock = (master->failover_start_time +
                            master->failover_timeout*2) / 1000;
            char ctimebuf[26];

            ctime_r(&clock,ctimebuf);
            ctimebuf[24] = '\0'; /* Remove newline. */
            master->failover_delay_logged = master->failover_start_time;
            serverLog(LL_NOTICE,
                ""Next failover delay: I will not start a failover before %s"",
                ctimebuf);
        }
        return 0;...",4972.0,5000.0,1.0,26.0,29.0,30,14,17,4,1,13,5,6,7,3,,0,11,2,1,1,int
4515,365416,sentinelFailoverWaitStart,1,sentinelFailoverWaitStart,void sentinelFailoverWaitStart (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
    char *leader;
    int isleader;

    /* Check if we are the leader for the failover epoch. */
    leader = sentinelGetLeader(ri, ri->failover_epoch);
    isleader = leader && strcasecmp(leader,sentinel.myid) == 0;
    sdsfree(leader);

    /* If I'm not the leader, and it is not a forced failover via
     * SENTINEL FAILOVER, then I can't continue with the failover. */
    if (!isleader && !(ri->flags & SRI_FORCE_FAILOVER)) {
        mstime_t election_timeout = sentinel_election_timeout;

        /* The election timeout is the MIN between SENTINEL_ELECTION_TIMEOUT
         * and the configured failover timeout. */
        if (election_timeout > ri->failover_timeout)
            election_timeout = ri->failover_timeout;
        /* Abort the failover if I'm not the leader after some time. */
        if (mstime() - ri->failover_start_time > election_timeout) {
            sentinelEvent(LL_WARNING,""-failover-abort-not-electe...",5108.0,5139.0,1.0,35.0,32.0,27,10,25,6,1,21,5,7,6,9,,0,15,2,1,1,void
4516,365531,sentinelFailoverSelectSlave,1,sentinelFailoverSelectSlave,void sentinelFailoverSelectSlave (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
    sentinelRedisInstance *slave = sentinelSelectSlave(ri);

    /* We don't handle the timeout in this state as the function aborts
     * the failover or go forward in the next state. */
    if (slave == NULL) {
        sentinelEvent(LL_WARNING,""-failover-abort-no-good-slave"",ri,""%@"");
        sentinelAbortFailover(ri);
    } else {
        sentinelEvent(LL_WARNING,""+selected-slave"",slave,""%@"");
        slave->flags |= SRI_PROMOTED;
        ri->promoted_slave = slave;
        ri->failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;
        ri->failover_state_change_time = mstime();
        sentinelEvent(LL_NOTICE,""+failover-state-send-slaveof-noone"",
            slave, ""%@"");
    }
}",5141.0,5158.0,1.0,22.0,18.0,2,2,6,3,1,3,2,2,0,3,,0,1,2,1,1,void
4517,365597,sentinelFailoverSendSlaveOfNoOne,1,sentinelFailoverSendSlaveOfNoOne,void sentinelFailoverSendSlaveOfNoOne (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
    int retval;

    /* We can't send the command to the promoted slave if it is now
     * disconnected. Retry again and again with this state until the timeout
     * is reached, then abort the failover. */
    if (ri->promoted_slave->link->disconnected) {
        if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
            sentinelEvent(LL_WARNING,""-failover-abort-slave-timeout"",ri,""%@"");
            sentinelAbortFailover(ri);
        }
        return;
    }

    /* Send SLAVEOF NO ONE command to turn the slave into a master.
     * We actually register a generic callback for this command as we don't
     * really care about the reply. We check if it worked indirectly observing
     * if INFO returns a different role (master instead of slave). */
    retval = sentinelSendSlaveOf(ri->promoted_slave,NULL);
    if (retval != C_OK) return;
    sentinelEvent(LL_NOTICE, ""+failover-state-wait-promo...",5160.0,5184.0,1.0,26.0,25.0,15,5,12,3,1,13,4,5,4,6,,0,10,2,1,1,void
4518,365669,sentinelFailoverWaitPromotion,1,sentinelFailoverWaitPromotion,void sentinelFailoverWaitPromotion (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
    /* Just handle the timeout. Switching to the next state is handled
     * by the function parsing the INFO command of the promoted slave. */
    if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
        sentinelEvent(LL_WARNING,""-failover-abort-slave-timeout"",ri,""%@"");
        sentinelAbortFailover(ri);
    }
}",5188.0,5195.0,1.0,22.0,8.0,4,3,4,1,1,5,2,2,3,3,,0,3,2,1,1,void
4519,365694,sentinelFailoverDetectEnd,1,sentinelFailoverDetectEnd,void sentinelFailoverDetectEnd (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
    int not_reconfigured = 0, timeout = 0;
    dictIterator *di;
    dictEntry *de;
    mstime_t elapsed = mstime() - master->failover_state_change_time;

    /* We can't consider failover finished if the promoted slave is
     * not reachable. */
    if (master->promoted_slave == NULL ||
        master->promoted_slave->flags & SRI_S_DOWN) return;

    /* The failover terminates once all the reachable slaves are properly
     * configured. */
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (slave->flags & (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
        if (slave->flags & SRI_S_DOWN) continue;
        not_reconfigured++;
    }
    dictReleaseIterator(di);

    /* Force end of failover on timeout. */
    if (elapsed > master->failover_timeout) {
        not_reconfigured = 0;
        timeout = 1;
        sentinelEvent(LL...",5197.0,5256.0,1.0,40.0,60.0,55,11,44,9,1,28,16,21,9,14,,0,23,2,1,1,void
4520,365925,sentinelFailoverReconfNextSlave,1,sentinelFailoverReconfNextSlave,void sentinelFailoverReconfNextSlave (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int in_progress = 0;

    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (slave->flags & (SRI_RECONF_SENT|SRI_RECONF_INPROG))
            in_progress++;
    }
    dictReleaseIterator(di);

    di = dictGetIterator(master->slaves);
    while(in_progress < master->parallel_syncs &&
          (de = dictNext(di)) != NULL)
    {
        sentinelRedisInstance *slave = dictGetVal(de);
        int retval;

        /* Skip the promoted slave, and already configured slaves. */
        if (slave->flags & (SRI_PROMOTED|SRI_RECONF_DONE)) continue;

        /* If too much time elapsed without the slave moving forward to
         * the next state, consider it reconfigured even if it is not.
         * Sentinels will detect the slave as misconfigured and fix its
         * configuration l...",5260.0,5315.0,1.0,28.0,56.0,53,13,39,8,1,29,12,15,11,14,,0,24,2,1,1,void
4521,366134,sentinelFailoverSwitchToPromotedSlave,1,sentinelFailoverSwitchToPromotedSlave,void sentinelFailoverSwitchToPromotedSlave (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance *ref = master->promoted_slave ?
                                 master->promoted_slave : master;

    sentinelEvent(LL_WARNING,""+switch-master"",master,""%s %s %d %s %d"",
        master->name, announceSentinelAddr(master->addr), master->addr->port,
        announceSentinelAddr(ref->addr), ref->addr->port);

    sentinelResetMasterAndChangeAddress(master,ref->addr->hostname,ref->addr->port);
}",5320.0,5329.0,1.0,18.0,10.0,15,3,13,2,1,13,1,1,0,4,,0,11,2,1,1,void
4522,366190,sentinelFailoverStateMachine,1,sentinelFailoverStateMachine,void sentinelFailoverStateMachine (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_MASTER);

    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;

    switch(ri->failover_state) {
        case SENTINEL_FAILOVER_STATE_WAIT_START:
            sentinelFailoverWaitStart(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SELECT_SLAVE:
            sentinelFailoverSelectSlave(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:
            sentinelFailoverSendSlaveOfNoOne(ri);
            break;
        case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
            sentinelFailoverWaitPromotion(ri);
            break;
        case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
            sentinelFailoverReconfNextSlave(ri);
            break;
    }
}",5331.0,5353.0,1.0,4.0,23.0,12,8,8,1,1,9,8,3,2,6,,0,3,2,1,1,void
4523,366361,sentinelHandleRedisInstance,1,sentinelHandleRedisInstance,void sentinelHandleRedisInstance (sentinelRedisInstance*),sentinel.c,"void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
    /* ========== MONITORING HALF ============ */
    /* Every kind of instance */
    sentinelReconnectInstance(ri);
    sentinelSendPeriodicCommands(ri);

    /* ============== ACTING HALF ============= */
    /* We don't proceed with the acting half if we are in TILT mode.
     * TILT happens when we find something odd with the time, like a
     * sudden change in the clock. */
    if (sentinel.tilt) {
        if (mstime()-sentinel.tilt_start_time < sentinel_tilt_period) return;
        sentinel.tilt = 0;
        sentinelEvent(LL_WARNING,""-tilt"",NULL,""#tilt mode exited"");
    }

    /* Every kind of instance */
    sentinelCheckSubjectivelyDown(ri);

    /* Masters and slaves */
    if (ri->flags & (SRI_MASTER|SRI_SLAVE)) {
        /* Nothing so far. */
    }

    /* Only masters */
    if (ri->flags & SRI_MASTER) {
        sentinelCheckObjectivelyDown(ri);
        if (sentinelStartFailoverIfNeeded(ri))
            sen...",5379.0,5411.0,1.0,22.0,33.0,15,8,15,4,1,19,6,8,9,10,,0,11,2,1,1,void
4524,366447,sentinelHandleDictOfRedisInstances,1,sentinelHandleDictOfRedisInstances,void sentinelHandleDictOfRedisInstances (dict*),sentinel.c,"void sentinelHandleDictOfRedisInstances(dict *instances) {
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *switch_to_promoted = NULL;

    /* There are a number of things we need to perform against every master. */
    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        sentinelHandleRedisInstance(ri);
        if (ri->flags & SRI_MASTER) {
            sentinelHandleDictOfRedisInstances(ri->slaves);
            sentinelHandleDictOfRedisInstances(ri->sentinels);
            if (ri->failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) {
                switch_to_promoted = ri;
            }
        }
    }
    if (switch_to_promoted)
        sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);
    dictReleaseIterator(di);
}",5415.0,5437.0,1.0,24.0,23.0,13,6,19,6,1,10,5,8,3,6,,0,7,2,1,1,void
4525,366515,sentinelCheckTiltCondition,1,sentinelCheckTiltCondition,void sentinelCheckTiltCondition (void),sentinel.c,"void sentinelCheckTiltCondition(void) {
    mstime_t now = mstime();
    mstime_t delta = now - sentinel.previous_time;

    if (delta < 0 || delta > sentinel_tilt_trigger) {
        sentinel.tilt = 1;
        sentinel.tilt_start_time = mstime();
        sentinelEvent(LL_WARNING,""+tilt"",NULL,""#tilt mode entered"");
    }
    sentinel.previous_time = mstime();
}",5458.0,5468.0,1.0,22.0,11.0,13,6,11,5,1,13,2,2,1,4,,0,12,2,1,1,void
4526,366563,sentinelTimer,1,sentinelTimer,void sentinelTimer (void),sentinel.c,"void sentinelTimer(void) {
    sentinelCheckTiltCondition();
    sentinelHandleDictOfRedisInstances(sentinel.masters);
    sentinelRunPendingScripts();
    sentinelCollectTerminatedScripts();
    sentinelKillTimedoutScripts();

    /* We continuously change the frequency of the Redis ""timer interrupt""
     * in order to desynchronize every Sentinel from every other.
     * This non-determinism avoids that Sentinels started at the same time
     * exactly continue to stay synchronized asking to be voted at the
     * same time again and again (resulting in nobody likely winning the
     * election because of split brain voting). */
    server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
}",5470.0,5484.0,1.0,16.0,15.0,5,4,2,2,1,7,1,1,0,5,,0,2,2,1,1,void
4527,366678,isShutdownInitiated,1,isShutdownInitiated,int isShutdownInitiated (void),server.c,"static inline int isShutdownInitiated(void) {
    return server.shutdown_mstime != 0;
}",4265.0,4267.0,1.0,1.0,3.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,int
4528,366683,isReadyToShutdown,1,isReadyToShutdown,int isReadyToShutdown (void),server.c,"int isReadyToShutdown(void) {
    if (listLength(server.slaves) == 0) return 1;  /* No replicas. */

    listIter li;
    listNode *ln;
    listRewind(server.slaves, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *replica = listNodeValue(ln);
        if (replica->repl_ack_off != server.master_repl_offset) return 0;
    }
    return 1;
}",4272.0,4283.0,1.0,8.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4529,366688,finishShutdown,1,finishShutdown,int finishShutdown (void),server.c,"int finishShutdown(void) {

    int save = server.shutdown_flags & SHUTDOWN_SAVE;
    int nosave = server.shutdown_flags & SHUTDOWN_NOSAVE;
    int force = server.shutdown_flags & SHUTDOWN_FORCE;

    /* Log a warning for each replica that is lagging. */
    listIter replicas_iter;
    listNode *replicas_list_node;
    int num_replicas = 0, num_lagging_replicas = 0;
    listRewind(server.slaves, &replicas_iter);
    while ((replicas_list_node = listNext(&replicas_iter)) != NULL) {
        client *replica = listNodeValue(replicas_list_node);
        num_replicas++;
        if (replica->repl_ack_off != server.master_repl_offset) {
            num_lagging_replicas++;
            long lag = replica->replstate == SLAVE_STATE_ONLINE ?
                time(NULL) - replica->repl_ack_time : 0;
            serverLog(LL_NOTICE,
                      ""Lagging replica %s reported offset %lld behind master, lag=%ld, state=%s."",
                      replicationGetSlaveName(replica),
             ...",4313.0,4460.0,1.0,39.0,148.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4530,366693,replstateToString,1,replstateToString,char* replstateToString (int),server.c,"const char *replstateToString(int replstate) {
    switch (replstate) {
    case SLAVE_STATE_WAIT_BGSAVE_START:
    case SLAVE_STATE_WAIT_BGSAVE_END:
        return ""wait_bgsave"";
    case SLAVE_STATE_SEND_BULK:
        return ""send_bulk"";
    case SLAVE_STATE_ONLINE:
        return ""online"";
    default:
        return """";
    }
}",5298.0,5310.0,1.0,9.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,const char*
4531,366706,serverLogRaw,1,serverLogRaw,"void serverLogRaw (int,char*)",server.c,"void serverLogRaw(int level, const char *msg) {
    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
    const char *c = "".-*#"";
    FILE *fp;
    char buf[64];
    int rawmode = (level & LL_RAW);
    int log_to_stdout = server.logfile[0] == '\0';

    level &= 0xff; /* clear flags */
    if (level < server.verbosity) return;

    fp = log_to_stdout ? stdout : fopen(server.logfile,""a"");
    if (!fp) return;

    if (rawmode) {
        fprintf(fp,""%s"",msg);
    } else {
        int off;
        struct timeval tv;
        int role_char;
        pid_t pid = getpid();

        gettimeofday(&tv,NULL);
        struct tm tm;
        nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);
        off = strftime(buf,sizeof(buf),""%d %b %Y %H:%M:%S."",&tm);
        snprintf(buf+off,sizeof(buf)-off,""%03d"",(int)tv.tv_usec/1000);
        if (server.sentinel_mode) {
            role_char = 'X'; /* Sentinel. */
        } else if (pid != server.pid) {
  ...",106.0,147.0,1.0,27.0,42.0,19,10,28,13,20,8,6,6,4,0,,0,8,4,2,2,void
4532,366891,_serverLog,1,_serverLog,"void _serverLog (int,char*...)",server.c,"void _serverLog(int level, const char *fmt, ...) {
    va_list ap;
    char msg[LOG_MAX_LEN];

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    serverLogRaw(level,msg);
}",152.0,161.0,1.0,13.0,10.0,1,1,9,4,362,1,1,1,0,1,,0,0,4,2,2,void
4533,366913,serverLogFromHandler,1,serverLogFromHandler,"void serverLogFromHandler (int,char*)",server.c,"void serverLogFromHandler(int level, const char *msg) {
    int fd;
    int log_to_stdout = server.logfile[0] == '\0';
    char buf[64];

    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
        return;
    fd = log_to_stdout ? STDOUT_FILENO :
                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
    if (fd == -1) return;
    ll2string(buf,sizeof(buf),getpid());
    if (write(fd,buf,strlen(buf)) == -1) goto err;
    if (write(fd,"":signal-handler ("",17) == -1) goto err;
    ll2string(buf,sizeof(buf),time(NULL));
    if (write(fd,buf,strlen(buf)) == -1) goto err;
    if (write(fd,"") "",2) == -1) goto err;
    if (write(fd,msg,strlen(msg)) == -1) goto err;
    if (write(fd,""\n"",1) == -1) goto err;
err:
    if (!log_to_stdout) close(fd);
}",169.0,189.0,1.0,1.0,21.0,32,13,33,11,6,10,16,10,4,2,,0,8,4,2,2,void
4534,367086,commandTimeSnapshot,1,commandTimeSnapshot,mstime_t commandTimeSnapshot (void),server.c,"mstime_t commandTimeSnapshot(void) {
    /* When we are in the middle of a command execution, we want to use a
     * reference time that does not change: in that case we just use the
     * cached time, that we update before each call in the call() function.
     * This way we avoid that commands such as RPOPLPUSH or similar, that
     * may re-open the same key multiple times, can invalidate an already
     * open object in a next call, if the next call will see the key expired,
     * while the first did not.
     * This is specifically important in the context of scripts, where we
     * pretend that time freezes. This way a key can expire only the first time
     * it is accessed and not in the middle of the script execution, making
     * propagation to slaves / AOF consistent. See issue #1525 for more info.
     * Note that we cannot use the cached server.mstime because it can change
     * in processEventsWhileBlocked etc. */
    return server.cmd_time_snapshot;
}",212.0,227.0,1.0,1.0,16.0,1,1,1,1,13,2,1,1,0,0,,0,2,2,1,1,mstime_t
4535,367095,exitFromChild,1,exitFromChild,void exitFromChild (int),server.c,"void exitFromChild(int retcode) {
#ifdef COVERAGE_TEST
    exit(retcode);
#else
    _exit(retcode);
#endif
}",233.0,239.0,1.0,1.0,7.0,0,0,1,1,7,0,1,1,0,0,,0,0,2,1,1,void
4536,367192,dictObjectDestructor,1,dictObjectDestructor,"void dictObjectDestructor (dict*,void*)",server.c,"void dictObjectDestructor(dict *d, void *val)
{
    UNUSED(d);
    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
    decrRefCount(val);
}",280.0,285.0,1.0,4.0,6.0,2,2,5,3,0,1,2,2,0,1,,0,0,4,2,2,void
4537,367226,dictSdsDup,1,dictSdsDup,"void* dictSdsDup (dict*,void*)",server.c,"void *dictSdsDup(dict *d, const void *key) {
    UNUSED(d);
    return sdsdup((const sds) key);
}",293.0,296.0,1.0,4.0,4.0,2,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void*
4538,367243,dictObjKeyCompare,1,dictObjKeyCompare,"int dictObjKeyCompare (dict*,void*,void*)",server.c,"int dictObjKeyCompare(dict *d, const void *key1,
        const void *key2)
{
    const robj *o1 = key1, *o2 = key2;
    return dictSdsKeyCompare(d, o1->ptr,o2->ptr);
}",298.0,303.0,1.0,1.0,6.0,4,2,7,5,0,1,1,1,0,1,,0,0,6,3,3,int
4539,367267,dictObjHash,1,dictObjHash,uint64_t dictObjHash (void*),server.c,"uint64_t dictObjHash(const void *key) {
    const robj *o = key;
    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
}",305.0,308.0,1.0,1.0,4.0,4,3,4,2,0,2,1,1,0,2,,0,1,2,1,1,uint64_t
4540,367301,dictSdsCaseHash,1,dictSdsCaseHash,uint64_t dictSdsCaseHash (void*),server.c,"uint64_t dictSdsCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));
}",314.0,316.0,1.0,1.0,3.0,2,1,2,1,0,2,1,1,0,2,,0,1,2,1,1,uint64_t
4541,367315,dictCStrHash,1,dictCStrHash,uint64_t dictCStrHash (void*),server.c,"uint64_t dictCStrHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
}",319.0,321.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
4542,367329,dictCStrCaseHash,1,dictCStrCaseHash,uint64_t dictCStrCaseHash (void*),server.c,"uint64_t dictCStrCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, strlen((char*)key));
}",324.0,326.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
4543,367403,dictEncObjKeyCompare,1,dictEncObjKeyCompare,"int dictEncObjKeyCompare (dict*,void*,void*)",server.c,"int dictEncObjKeyCompare(dict *d, const void *key1, const void *key2)
{
    robj *o1 = (robj*) key1, *o2 = (robj*) key2;
    int cmp;

    if (o1->encoding == OBJ_ENCODING_INT &&
        o2->encoding == OBJ_ENCODING_INT)
            return o1->ptr == o2->ptr;

    /* Due to OBJ_STATIC_REFCOUNT, we avoid calling getDecodedObject() without
     * good reasons, because it would incrRefCount() the object, which
     * is invalid. So we check to make sure dictFind() works with static
     * objects as well. */
    if (o1->refcount != OBJ_STATIC_REFCOUNT) o1 = getDecodedObject(o1);
    if (o2->refcount != OBJ_STATIC_REFCOUNT) o2 = getDecodedObject(o2);
    cmp = dictSdsKeyCompare(d,o1->ptr,o2->ptr);
    if (o1->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o1);
    if (o2->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o2);
    return cmp;
}",345.0,364.0,1.0,24.0,20.0,29,7,27,7,0,5,6,6,0,5,,0,3,6,3,3,int
4544,367516,dictEncObjHash,1,dictEncObjHash,uint64_t dictEncObjHash (void*),server.c,"uint64_t dictEncObjHash(const void *key) {
    robj *o = (robj*) key;

    if (sdsEncodedObject(o)) {
        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
    } else if (o->encoding == OBJ_ENCODING_INT) {
        char buf[32];
        int len;

        len = ll2string(buf,32,(long)o->ptr);
        return dictGenHashFunction((unsigned char*)buf, len);
    } else {
        serverPanic(""Unknown string encoding"");
    }
}",366.0,380.0,1.0,8.0,15.0,10,5,7,2,0,2,2,2,0,2,,0,1,2,1,1,uint64_t
4545,367593,dictExpandAllowed,1,dictExpandAllowed,"int dictExpandAllowed (size_t,double)",server.c,"int dictExpandAllowed(size_t moreMem, double usedRatio) {
    if (usedRatio <= HASHTABLE_MAX_LOAD_FACTOR) {
        return !overMaxmemoryAfterAlloc(moreMem);
    } else {
        return 1;
    }
}",388.0,394.0,1.0,21.0,7.0,2,2,2,2,0,1,2,2,0,1,,0,0,4,2,2,int
4546,367614,dbDictEntryMetadataSize,1,dbDictEntryMetadataSize,size_t dbDictEntryMetadataSize (dict*),server.c,"size_t dbDictEntryMetadataSize(dict *d) {
    UNUSED(d);
    /* NOTICE: this also affects overhead_ht_slot_to_keys in getMemoryOverheadData.
     * If we ever add non-cluster related data here, that code must be modified too. */
    return server.cluster_enabled ? sizeof(clusterDictEntryMetadata) : 0;
}",399.0,404.0,1.0,4.0,6.0,4,4,4,3,0,2,1,1,0,0,,0,2,2,1,1,size_t
4547,367633,dbDictMetadataSize,1,dbDictMetadataSize,size_t dbDictMetadataSize (void),server.c,"size_t dbDictMetadataSize(void) {
    return server.cluster_enabled ? sizeof(clusterDictMetadata) : 0;
}",409.0,411.0,1.0,1.0,3.0,3,3,2,2,0,2,1,1,0,0,,0,2,2,1,1,size_t
4548,367646,dbDictAfterReplaceEntry,1,dbDictAfterReplaceEntry,"void dbDictAfterReplaceEntry (dict*,dictEntry*)",server.c,"void dbDictAfterReplaceEntry(dict *d, dictEntry *de) {
    if (server.cluster_enabled) slotToKeyReplaceEntry(d, de);
}",413.0,415.0,1.0,1.0,3.0,1,1,3,3,0,3,2,2,2,1,,0,2,4,2,2,void
4549,367843,htNeedsResize,1,htNeedsResize,int htNeedsResize (dict*),server.c,"int htNeedsResize(dict *dict) {
    long long size, used;

    size = dictSlots(dict);
    used = dictSize(dict);
    return (size > DICT_HT_INITIAL_SIZE &&
            (used*100/size < HASHTABLE_MIN_FILL));
}",593.0,600.0,1.0,11.0,8.0,32,14,13,3,3,6,1,1,0,0,,0,6,2,1,1,int
4550,367928,tryResizeHashTables,1,tryResizeHashTables,void tryResizeHashTables (int),server.c,"void tryResizeHashTables(int dbid) {
    if (htNeedsResize(server.db[dbid].dict))
        dictResize(server.db[dbid].dict);
    if (htNeedsResize(server.db[dbid].expires))
        dictResize(server.db[dbid].expires);
}",604.0,609.0,1.0,1.0,6.0,12,2,8,2,1,12,3,3,6,4,,0,10,2,1,1,void
4551,367969,incrementallyRehash,1,incrementallyRehash,int incrementallyRehash (int),server.c,"int incrementallyRehash(int dbid) {
    /* Keys dictionary */
    if (dictIsRehashing(server.db[dbid].dict)) {
        dictRehashMilliseconds(server.db[dbid].dict,1);
        return 1; /* already used our millisecond for this loop... */
    }
    /* Expires */
    if (dictIsRehashing(server.db[dbid].expires)) {
        dictRehashMilliseconds(server.db[dbid].expires,1);
        return 1; /* already used our millisecond for this loop... */
    }
    return 0;
}",618.0,630.0,1.0,8.0,13.0,24,5,12,2,1,14,3,3,8,2,,0,12,2,1,1,int
4552,368044,updateDictResizePolicy,1,updateDictResizePolicy,void updateDictResizePolicy (void),server.c,"void updateDictResizePolicy(void) {
    if (server.in_fork_child != CHILD_TYPE_NONE)
        dictSetResizeEnabled(DICT_RESIZE_FORBID);
    else if (hasActiveChildProcess())
        dictSetResizeEnabled(DICT_RESIZE_AVOID);
    else
        dictSetResizeEnabled(DICT_RESIZE_ENABLE);
}",638.0,645.0,1.0,32.0,8.0,2,2,2,2,3,3,2,2,2,1,,0,2,2,1,1,void
4553,368071,strChildType,1,strChildType,const char* strChildType (int),server.c,"const char *strChildType(int type) {
    switch(type) {
        case CHILD_TYPE_RDB: return ""RDB"";
        case CHILD_TYPE_AOF: return ""AOF"";
        case CHILD_TYPE_LDB: return ""LDB"";
        case CHILD_TYPE_MODULE: return ""MODULE"";
        default: return ""Unknown"";
    }
}",647.0,655.0,1.0,13.0,9.0,0,0,1,1,1,0,2,2,0,0,,0,0,2,1,1,const char*
4554,368106,hasActiveChildProcess,1,hasActiveChildProcess,int hasActiveChildProcess (void),server.c,"int hasActiveChildProcess(void) {
    return server.child_pid != -1;
}",659.0,661.0,1.0,1.0,3.0,3,3,1,1,13,2,1,1,0,0,,0,2,2,1,1,int
4555,368118,resetChildState,1,resetChildState,void resetChildState (void),server.c,"void resetChildState(void) {
    server.child_type = CHILD_TYPE_NONE;
    server.child_pid = -1;
    server.stat_current_cow_peak = 0;
    server.stat_current_cow_bytes = 0;
    server.stat_current_cow_updated = 0;
    server.stat_current_save_keys_processed = 0;
    server.stat_module_progress = 0;
    server.stat_current_save_keys_total = 0;
    updateDictResizePolicy();
    closeChildInfoPipe();
    moduleFireServerEvent(REDISMODULE_EVENT_FORK_CHILD,
                          REDISMODULE_SUBEVENT_FORK_CHILD_DIED,
                          NULL);
}",663.0,677.0,1.0,24.0,15.0,17,3,9,2,2,19,1,1,0,3,,0,16,2,1,1,void
4556,368176,isMutuallyExclusiveChildType,1,isMutuallyExclusiveChildType,int isMutuallyExclusiveChildType (int),server.c,"int isMutuallyExclusiveChildType(int type) {
    return type == CHILD_TYPE_RDB || type == CHILD_TYPE_AOF || type == CHILD_TYPE_MODULE;
}",680.0,682.0,1.0,19.0,3.0,5,2,3,1,1,0,1,1,0,0,,0,0,2,1,1,int
4557,368199,isInsideYieldingLongCommand,1,isInsideYieldingLongCommand,int isInsideYieldingLongCommand (void),server.c,"int isInsideYieldingLongCommand(void) {
    return scriptIsTimedout() || server.busy_module_yield_flags;
}",685.0,687.0,1.0,1.0,3.0,2,2,1,1,5,3,1,1,0,1,,0,2,2,1,1,int
4558,368210,allPersistenceDisabled,1,allPersistenceDisabled,int allPersistenceDisabled (void),server.c,"int allPersistenceDisabled(void) {
    return server.saveparamslen == 0 && server.aof_state == AOF_OFF;
}",691.0,693.0,1.0,60.0,3.0,5,3,2,1,1,4,1,1,0,0,,0,4,2,1,1,int
4559,368229,trackInstantaneousMetric,1,trackInstantaneousMetric,"void trackInstantaneousMetric (int,long long,long long,long long)",server.c,"void trackInstantaneousMetric(int metric, long long current_value, long long current_base, long long factor) {
    if (server.inst_metric[metric].last_sample_base > 0) {
        long long base = current_base - server.inst_metric[metric].last_sample_base;
        long long value = current_value - server.inst_metric[metric].last_sample_value;
        long long avg = base > 0 ? (value * factor / base) : 0;
        server.inst_metric[metric].samples[server.inst_metric[metric].idx] = avg;
        server.inst_metric[metric].idx++;
        server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;
    }
    server.inst_metric[metric].last_sample_base = current_base;
    server.inst_metric[metric].last_sample_value = current_value;
}",704.0,715.0,1.0,42.0,12.0,42,9,30,8,7,9,2,2,1,0,,0,9,8,4,4,void
4560,368339,getInstantaneousMetric,1,getInstantaneousMetric,long long getInstantaneousMetric (int),server.c,"long long getInstantaneousMetric(int metric) {
    int j;
    long long sum = 0;

    for (j = 0; j < STATS_METRIC_SAMPLES; j++)
        sum += server.inst_metric[metric].samples[j];
    return sum / STATS_METRIC_SAMPLES;
}",718.0,725.0,1.0,20.0,8.0,4,3,4,2,7,0,2,2,0,0,,0,0,2,1,1,long long
4561,368378,clientsCronResizeQueryBuffer,1,clientsCronResizeQueryBuffer,int clientsCronResizeQueryBuffer (client*),server.c,"int clientsCronResizeQueryBuffer(client *c) {
    size_t querybuf_size = sdsalloc(c->querybuf);
    time_t idletime = server.unixtime - c->lastinteraction;

    /* Only resize the query buffer if the buffer is actually wasting at least a
     * few kbytes */
    if (sdsavail(c->querybuf) > 1024*4) {
        /* There are two conditions to resize the query buffer: */
        if (idletime > 2) {
            /* 1) Query is idle for a long time. */
            c->querybuf = sdsRemoveFreeSpace(c->querybuf, 1);
        } else if (querybuf_size > PROTO_RESIZE_THRESHOLD && querybuf_size/2 > c->querybuf_peak) {
            /* 2) Query buffer is too big for latest peak and is larger than
             *    resize threshold. Trim excess space but only up to a limit,
             *    not below the recent peak and current c->querybuf (which will
             *    be soon get used). If we're in the middle of a bulk then make
             *    sure not to resize to less than the bulk length. */
   ...",731.0,762.0,1.0,35.0,32.0,29,11,16,4,1,18,4,5,5,4,,0,18,2,1,1,int
4562,368536,clientsCronResizeOutputBuffer,1,clientsCronResizeOutputBuffer,"int clientsCronResizeOutputBuffer (client*,mstime_t)",server.c,"int clientsCronResizeOutputBuffer(client *c, mstime_t now_ms) {

    size_t new_buffer_size = 0;
    char *oldbuf = NULL;
    const size_t buffer_target_shrink_size = c->buf_usable_size/2;
    const size_t buffer_target_expand_size = c->buf_usable_size*2;

    /* in case the resizing is disabled return immediately */
    if(!server.reply_buffer_resizing_enabled)
        return 0;

    if (buffer_target_shrink_size >= PROTO_REPLY_MIN_BYTES &&
        c->buf_peak < buffer_target_shrink_size )
    {
        new_buffer_size = max(PROTO_REPLY_MIN_BYTES,c->buf_peak+1);
        server.stat_reply_buffer_shrinks++;
    } else if (buffer_target_expand_size < PROTO_REPLY_CHUNK_BYTES*2 &&
        c->buf_peak == c->buf_usable_size)
    {
        new_buffer_size = min(PROTO_REPLY_CHUNK_BYTES,buffer_target_expand_size);
        server.stat_reply_buffer_expands++;
    }

    serverAssertWithInfo(c, NULL, (!new_buffer_size) || (new_buffer_size >= (size_t)c->bufpos));

    /* reset the peak value eac...",771.0,813.0,1.0,37.0,43.0,52,19,40,8,1,26,5,5,8,3,,0,24,4,2,2,int
4563,368745,clientsCronTrackExpansiveClients,1,clientsCronTrackExpansiveClients,"int clientsCronTrackExpansiveClients (client*,int)",server.c,"int clientsCronTrackExpansiveClients(client *c, int time_idx) {
    size_t in_usage = sdsZmallocSize(c->querybuf) + c->argv_len_sum +
	              (c->argv ? zmalloc_size(c->argv) : 0);
    size_t out_usage = getClientOutputBufferMemoryUsage(c);

    /* Track the biggest values observed so far in this slot. */
    if (in_usage > ClientsPeakMemInput[time_idx]) ClientsPeakMemInput[time_idx] = in_usage;
    if (out_usage > ClientsPeakMemOutput[time_idx]) ClientsPeakMemOutput[time_idx] = out_usage;

    return 0; /* This function never terminates the client. */
}",831.0,841.0,1.0,1.0,11.0,17,6,19,6,1,11,3,3,2,3,,0,11,4,2,2,int
4564,368803,getMemUsageBucket,1,getMemUsageBucket,clientMemUsageBucket getMemUsageBucket (size_t),server.c,"static inline clientMemUsageBucket *getMemUsageBucket(size_t mem) {
    int size_in_bits = 8*(int)sizeof(mem);
    int clz = mem > 0 ? __builtin_clzl(mem) : size_in_bits;
    int bucket_idx = size_in_bits - clz;
    if (bucket_idx > CLIENT_MEM_USAGE_BUCKET_MAX_LOG)
        bucket_idx = CLIENT_MEM_USAGE_BUCKET_MAX_LOG;
    else if (bucket_idx < CLIENT_MEM_USAGE_BUCKET_MIN_LOG)
        bucket_idx = CLIENT_MEM_USAGE_BUCKET_MIN_LOG;
    bucket_idx -= CLIENT_MEM_USAGE_BUCKET_MIN_LOG;
    return &server.client_mem_usage_buckets[bucket_idx];
}",850.0,860.0,1.0,21.0,11.0,15,11,14,5,1,2,2,2,0,0,,0,2,2,1,1,clientMemUsageBucket
4565,368871,updateClientMemoryUsage,1,updateClientMemoryUsage,void updateClientMemoryUsage (client*),server.c,"void updateClientMemoryUsage(client *c) {
    size_t mem = getClientMemoryUsage(c, NULL);
    int type = getClientType(c);
    /* Now that we have the memory used by the client, remove the old
     * value from the old category, and add it back. */
    server.stat_clients_type_memory[c->last_memory_type] -= c->last_memory_usage;
    server.stat_clients_type_memory[type] += mem;
    /* Remember what we added and where, to remove it next time. */
    c->last_memory_type = type;
    c->last_memory_usage = mem;
}",874.0,884.0,1.0,1.0,11.0,14,6,15,5,2,10,1,1,0,2,,0,10,2,1,1,void
4566,368915,clientEvictionAllowed,1,clientEvictionAllowed,int clientEvictionAllowed (client*),server.c,"int clientEvictionAllowed(client *c) {
    if (server.maxmemory_clients == 0 || c->flags & CLIENT_NO_EVICT) {
        return 0;
    }
    int type = getClientType(c);
    return (type == CLIENT_TYPE_NORMAL || type == CLIENT_TYPE_PUBSUB);
}",886.0,892.0,1.0,52.0,7.0,10,7,6,3,1,4,2,2,3,1,,0,4,2,1,1,int
4567,368956,removeClientFromMemUsageBucket,1,removeClientFromMemUsageBucket,"void removeClientFromMemUsageBucket (client*,int)",server.c,"void removeClientFromMemUsageBucket(client *c, int allow_eviction) {
    if (c->mem_usage_bucket) {
        c->mem_usage_bucket->mem_usage_sum -= c->last_memory_usage;
        /* If this client can't be evicted then remove it from the mem usage
         * buckets */
        if (!allow_eviction) {
            listDelNode(c->mem_usage_bucket->clients, c->mem_usage_bucket_node);
            c->mem_usage_bucket = NULL;
            c->mem_usage_bucket_node = NULL;
        }
    }
}",899.0,910.0,1.0,1.0,12.0,13,4,10,3,2,8,3,4,1,1,,0,7,4,2,2,void
4568,368999,updateClientMemUsageAndBucket,1,updateClientMemUsageAndBucket,int updateClientMemUsageAndBucket (client*),server.c,"int updateClientMemUsageAndBucket(client *c) {
    serverAssert(io_threads_op == IO_THREADS_OP_IDLE);
    int allow_eviction = clientEvictionAllowed(c);
    removeClientFromMemUsageBucket(c, allow_eviction);

    if (!allow_eviction) {
        return 0;
    }

    /* Update client memory usage. */
    updateClientMemoryUsage(c);

    /* Update the client in the mem usage buckets */
    clientMemUsageBucket *bucket = getMemUsageBucket(c->last_memory_usage);
    bucket->mem_usage_sum += c->last_memory_usage;
    if (bucket != c->mem_usage_bucket) {
        if (c->mem_usage_bucket)
            listDelNode(c->mem_usage_bucket->clients,
                        c->mem_usage_bucket_node);
        c->mem_usage_bucket = bucket;
        listAddNodeTail(bucket->clients, c);
        c->mem_usage_bucket_node = listLast(bucket->clients);
    }
    return 1;
}",928.0,952.0,1.0,4.0,25.0,26,10,23,4,9,19,4,5,2,7,,0,14,2,1,1,int
4569,369097,getExpansiveClientsInfo,1,getExpansiveClientsInfo,"void getExpansiveClientsInfo (size_t*,size_t*)",server.c,"void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
    size_t i = 0, o = 0;
    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {
        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];
        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];
    }
    *in_usage = i;
    *out_usage = o;
}",956.0,964.0,1.0,24.0,9.0,16,5,20,7,1,4,4,6,2,0,,0,4,4,2,2,void
4570,369157,clientsCron,1,clientsCron,void clientsCron (void),server.c,"void clientsCron(void) {
    /* Try to process at least numclients/server.hz of clients
     * per call. Since normally (if there are no big latency events) this
     * function is called server.hz times per second, in the average case we
     * process all the clients in 1 second. */
    int numclients = listLength(server.clients);
    int iterations = numclients/server.hz;
    mstime_t now = mstime();

    /* Process at least a few clients while we are at it, even if we need
     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract
     * of processing each client once per second. */
    if (iterations < CLIENTS_CRON_MIN_ITERATIONS)
        iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?
                     numclients : CLIENTS_CRON_MIN_ITERATIONS;


    int curr_peak_mem_usage_slot = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;
    /* Always zero the next sample, so that when we switch to that second, we'll
     * only register samples that are gr...",982.0,1045.0,1.0,21.0,64.0,35,12,39,10,1,30,14,15,10,9,,0,28,2,1,1,void
4571,369313,databasesCron,1,databasesCron,void databasesCron (void),server.c,"void databasesCron(void) {
    /* Expire keys by random sampling. Not required for slaves
     * as master will synthesize DELs for us. */
    if (server.active_expire_enabled) {
        if (iAmMaster()) {
            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
        } else {
            expireSlaveKeys();
        }
    }

    /* Defrag keys gradually. */
    activeDefragCycle();

    /* Perform hash tables rehashing if needed, but only if there are no
     * other processes saving the DB on disk. Otherwise rehashing is bad
     * as will cause a lot of copy-on-write of memory pages. */
    if (!hasActiveChildProcess()) {
        /* We use global counters so if we stop the computation at a given
         * DB we'll be able to start from the successive in the next
         * cron loop iteration. */
        static unsigned int resize_db = 0;
        static unsigned int rehash_db = 0;
        int dbs_per_call = CRON_DBS_PER_CALL;
        int j;

        /* Don't test more DBs than w...",1050.0,1101.0,1.0,30.0,52.0,18,7,21,6,1,16,10,18,8,6,,0,13,2,1,1,void
4572,369418,updateCachedTimeWithUs,1,updateCachedTimeWithUs,"void updateCachedTimeWithUs (int,long long)",server.c,"static inline void updateCachedTimeWithUs(int update_daylight_info, const long long ustime) {
    server.ustime = ustime;
    server.mstime = server.ustime / 1000;
    time_t unixtime = server.mstime / 1000;
    atomicSet(server.unixtime, unixtime);

    /* To get information about daylight saving time, we need to call
     * localtime_r and cache the result. However calling localtime_r in this
     * context is safe since we will never fork() while here, in the main
     * thread. The logging function will call a thread safe version of
     * localtime that has no locks. */
    if (update_daylight_info) {
        struct tm tm;
        time_t ut = server.unixtime;
        localtime_r(&ut,&tm);
        server.daylight_active = tm.tm_isdst;
    }
}",1103.0,1120.0,1.0,1.0,18.0,17,4,15,6,2,14,2,2,0,0,,0,14,4,2,2,void
4573,369473,updateCachedTime,1,updateCachedTime,void updateCachedTime (int),server.c,"void updateCachedTime(int update_daylight_info) {
    const long long us = ustime();
    updateCachedTimeWithUs(update_daylight_info, us);
}",1132.0,1135.0,1.0,1.0,4.0,1,1,3,2,4,2,1,1,0,2,,0,1,2,1,1,void
4574,369485,enterExecutionUnit,1,enterExecutionUnit,"void enterExecutionUnit (int,long long)",server.c,"void enterExecutionUnit(int update_cached_time, long long us) {
    if (server.execution_nesting++ == 0 && update_cached_time) {
        if (us == 0) {
            us = ustime();
        }
        updateCachedTimeWithUs(0, us);
        server.cmd_time_snapshot = server.mstime;
    }
}",1143.0,1151.0,1.0,1.0,9.0,9,5,7,3,3,8,3,4,2,2,,0,7,4,2,2,void
4575,369519,exitExecutionUnit,1,exitExecutionUnit,void exitExecutionUnit (void),server.c,"void exitExecutionUnit(void) {
    --server.execution_nesting;
}",1153.0,1155.0,1.0,1.0,3.0,2,2,1,1,4,2,1,1,0,0,,0,2,2,1,1,void
4576,369528,checkChildrenDone,1,checkChildrenDone,void checkChildrenDone (void),server.c,"void checkChildrenDone(void) {
    int statloc = 0;
    pid_t pid;

    if ((pid = waitpid(-1, &statloc, WNOHANG)) != 0) {
        int exitcode = WIFEXITED(statloc) ? WEXITSTATUS(statloc) : -1;
        int bysignal = 0;

        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);

        /* sigKillChildHandler catches the signal and calls exit(), but we
         * must make sure not to flag lastbgsave_status, etc incorrectly.
         * We could directly terminate the child process via SIGUSR1
         * without handling it */
        if (exitcode == SERVER_CHILD_NOERROR_RETVAL) {
            bysignal = SIGUSR1;
            exitcode = 1;
        }

        if (pid == -1) {
            serverLog(LL_WARNING,""waitpid() returned an error: %s. ""
                ""child_type: %s, child_pid = %d"",
                strerror(errno),
                strChildType(server.child_type),
                (int) server.child_pid);
        } else if (pid == server.child_pid) {
            if (server...",1157.0,1206.0,1.0,24.0,50.0,21,10,20,8,1,9,5,8,0,3,,0,7,2,1,1,void
4577,369726,cronUpdateMemoryStats,1,cronUpdateMemoryStats,void cronUpdateMemoryStats (void),server.c,"void cronUpdateMemoryStats(void) {
    /* Record the max memory used since the server was started. */
    if (zmalloc_used_memory() > server.stat_peak_memory)
        server.stat_peak_memory = zmalloc_used_memory();

    run_with_period(100) {
        /* Sample the RSS and other metrics here since this is a relatively slow call.
         * We must sample the zmalloc_used at the same time we take the rss, otherwise
         * the frag ratio calculate may be off (ratio of two samples at different times) */
        server.cron_malloc_stats.process_rss = zmalloc_get_rss();
        server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();
        /* Sampling the allocator info can be slow too.
         * The fragmentation ratio it'll show is potentially more accurate
         * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc
         * allocations, and allocator reserved pages that can be pursed (all not actual frag) */
        zmalloc_get_allocator_...",1209.0,1241.0,1.0,4.0,33.0,55,10,21,2,2,44,2,2,3,6,,0,43,2,1,1,void
4578,369865,serverCron,1,serverCron,"int serverCron (aeEventLoop*,long long,void*)",server.c,"int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    int j;
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    /* Software watchdog: deliver the SIGALRM that will reach the signal
     * handler if we don't return here fast enough. */
    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);

    server.hz = server.config_hz;
    /* Adapt the server.hz value to the number of configured clients. If we have
     * many clients, we want to call serverCron() with an higher frequency. */
    if (server.dynamic_hz) {
        while (listLength(server.clients) / server.hz >
               MAX_CLIENTS_PER_CLOCK_TICK)
        {
            server.hz *= 2;
            if (server.hz > CONFIG_MAX_HZ) {
                server.hz = CONFIG_MAX_HZ;
                break;
            }
        }
    }

    /* for debug purposes: skip actual cron work if pause_cron is on */
    if (server.pause_cron) return 1000/server.hz;

    mono...",1262.0,1529.0,1.0,4.0,268.0,287,25,160,22,0,229,27,40,88,43,,0,200,6,3,3,int
4579,371022,blockingOperationStarts,1,blockingOperationStarts,void blockingOperationStarts (void),server.c,"void blockingOperationStarts(void) {
    if(!server.blocking_op_nesting++){
        updateCachedTime(0);
        server.blocked_last_cron = server.mstime;
    }
}",1532.0,1537.0,1.0,1.0,6.0,6,4,3,1,2,7,2,2,2,1,,0,6,2,1,1,void
4580,371043,blockingOperationEnds,1,blockingOperationEnds,void blockingOperationEnds (void),server.c,"void blockingOperationEnds(void) {
    if(!(--server.blocking_op_nesting)){
        server.blocked_last_cron = 0;
    }
}",1539.0,1543.0,1.0,1.0,5.0,5,4,2,1,3,4,2,2,2,0,,0,4,2,1,1,void
4581,371060,whileBlockedCron,1,whileBlockedCron,void whileBlockedCron (void),server.c,"void whileBlockedCron(void) {
    /* Here we may want to perform some cron jobs (normally done server.hz times
     * per second). */

    /* Since this function depends on a call to blockingOperationStarts, let's
     * make sure it was done. */
    serverAssert(server.blocked_last_cron);

    /* In case we where called too soon, leave right away. This way one time
     * jobs after the loop below don't need an if. and we don't bother to start
     * latency monitor if this function is called too often. */
    if (server.blocked_last_cron >= server.mstime)
        return;

    mstime_t latency;
    latencyStartMonitor(latency);

    /* In some cases we may be called with big intervals, so we may need to do
     * extra work here. This is because some of the functions in serverCron rely
     * on the fact that it is performed every 10 ms or so. For instance, if
     * activeDefragCycle needs to utilize 25% cpu, it will utilize 2.5ms, so we
     * need to call it multiple times. */
 ...",1550.0,1601.0,1.0,4.0,52.0,41,15,30,3,1,46,6,7,15,8,,0,41,2,1,1,void
4582,371224,sendGetackToReplicas,1,sendGetackToReplicas,void sendGetackToReplicas (void),server.c,"static void sendGetackToReplicas(void) {
    robj *argv[3];
    argv[0] = shared.replconf;
    argv[1] = shared.getack;
    argv[2] = shared.special_asterick; /* Not used argument. */
    replicationFeedSlaves(server.slaves, -1, argv, 3);
}",1603.0,1609.0,1.0,1.0,7.0,11,4,8,3,2,9,1,1,0,1,,0,8,2,1,1,void
4583,371260,beforeSleep,1,beforeSleep,void beforeSleep (aeEventLoop*),server.c,"void beforeSleep(struct aeEventLoop *eventLoop) {
    UNUSED(eventLoop);

    size_t zmalloc_used = zmalloc_used_memory();
    if (zmalloc_used > server.stat_peak_memory)
        server.stat_peak_memory = zmalloc_used;

    /* Just call a subset of vital functions in case we are re-entering
     * the event loop from processEventsWhileBlocked(). Note that in this
     * case we keep track of the number of events we are processing, since
     * processEventsWhileBlocked() wants to stop ASAP if there are no longer
     * events to handle. */
    if (ProcessingEventsWhileBlocked) {
        uint64_t processed = 0;
        processed += handleClientsWithPendingReadsUsingThreads();
        processed += connTypeProcessPendingData();
        if (server.aof_state == AOF_ON || server.aof_state == AOF_WAIT_REWRITE)
            flushAppendOnlyFile(0);
        processed += handleClientsWithPendingWrites();
        processed += freeClientsInAsyncFreeQueue();
        server.events_processed_while_b...",1627.0,1782.0,1.0,4.0,156.0,88,19,64,17,0,99,15,17,35,38,,0,73,2,1,1,void
4584,371587,afterSleep,1,afterSleep,void afterSleep (aeEventLoop*),server.c,"void afterSleep(struct aeEventLoop *eventLoop) {
    UNUSED(eventLoop);
    /********************* WARNING ********************
     * Do NOT add anything above moduleAcquireGIL !!! *
     ***************************** ********************/
    if (!ProcessingEventsWhileBlocked) {
        /* Acquire the modules GIL so that their threads won't touch anything. */
        if (moduleCount()) {
            mstime_t latency;
            latencyStartMonitor(latency);

            moduleAcquireGIL();
            moduleFireServerEvent(REDISMODULE_EVENT_EVENTLOOP,
                                  REDISMODULE_SUBEVENT_EVENTLOOP_AFTER_SLEEP,
                                  NULL);
            latencyEndMonitor(latency);
            latencyAddSampleIfNeeded(""module-acquire-GIL"",latency);
        }
        /* Set the eventloop start time. */
        server.el_start = getMonotonicUs();
        /* Set the eventloop command count at start. */
        server.el_cmd_cnt_start = server.stat_numcomman...",1787.0,1820.0,1.0,4.0,34.0,21,7,23,5,0,28,4,5,3,8,,0,24,2,1,1,void
4585,372664,initServerClientMemUsageBuckets,1,initServerClientMemUsageBuckets,void initServerClientMemUsageBuckets (void),server.c,"void initServerClientMemUsageBuckets(void) {
    if (server.client_mem_usage_buckets)
        return;
    server.client_mem_usage_buckets = zmalloc(sizeof(clientMemUsageBucket)*CLIENT_MEM_USAGE_BUCKETS);
    for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++) {
        server.client_mem_usage_buckets[j].mem_usage_sum = 0;
        server.client_mem_usage_buckets[j].clients = listCreate();
    }
}",1990.0,1998.0,1.0,75.0,9.0,19,8,9,3,2,10,3,3,2,2,,0,10,2,1,1,void
4586,372726,freeServerClientMemUsageBuckets,1,freeServerClientMemUsageBuckets,void freeServerClientMemUsageBuckets (void),server.c,"void freeServerClientMemUsageBuckets(void) {
    if (!server.client_mem_usage_buckets)
        return;
    for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++)
        listRelease(server.client_mem_usage_buckets[j].clients);
    zfree(server.client_mem_usage_buckets);
    server.client_mem_usage_buckets = NULL;
}",2000.0,2007.0,1.0,24.0,8.0,9,6,6,3,1,7,3,3,2,1,,0,6,2,1,1,void
4587,372772,initServerConfig,1,initServerConfig,void initServerConfig (void),server.c,"void initServerConfig(void) {
    int j;
    char *default_bindaddr[CONFIG_DEFAULT_BINDADDR_COUNT] = CONFIG_DEFAULT_BINDADDR;

    initConfigValues();
    updateCachedTime(1);
    server.cmd_time_snapshot = server.mstime;
    getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);
    server.runid[CONFIG_RUN_ID_SIZE] = '\0';
    changeReplicationId();
    clearReplicationId2();
    server.hz = CONFIG_DEFAULT_HZ; /* Initialize it ASAP, even if it may get
                                      updated later after loading the config.
                                      This value may be used before the server
                                      is initialized. */
    server.timezone = getTimeZone(); /* Initialized by tzset(). */
    server.configfile = NULL;
    server.executable = NULL;
    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
    server.bindaddr_count = CONFIG_DEFAULT_BINDADDR_COUNT;
    for (j = 0; j < CONFIG_DEFAULT_BINDADDR_COUNT; j++)
        server.bindaddr[j] = zstr...",2009.0,2130.0,1.0,27.0,122.0,183,12,111,15,0,181,4,4,0,16,,0,171,2,1,1,void
4588,373314,restartServer,1,restartServer,"int restartServer (int,mstime_t)",server.c,"int restartServer(int flags, mstime_t delay) {
    int j;

    /* Check if we still have accesses to the executable that started this
     * server instance. */
    if (access(server.executable,X_OK) == -1) {
        serverLog(LL_WARNING,""Can't restart: this process has no ""
                             ""permissions to execute %s"", server.executable);
        return C_ERR;
    }

    /* Config rewriting. */
    if (flags & RESTART_SERVER_CONFIG_REWRITE &&
        server.configfile &&
        rewriteConfig(server.configfile, 0) == -1)
    {
        serverLog(LL_WARNING,""Can't restart: configuration rewrite process ""
                             ""failed: %s"", strerror(errno));
        return C_ERR;
    }

    /* Perform a proper shutdown. We don't wait for lagging replicas though. */
    if (flags & RESTART_SERVER_GRACEFULLY &&
        prepareForShutdown(SHUTDOWN_NOW) != C_OK)
    {
        serverLog(LL_WARNING,""Can't restart: error preparing for shutdown"");
        return C_ERR;
    ...",2149.0,2196.0,1.0,8.0,48.0,45,13,25,8,0,34,7,8,10,7,,0,30,4,2,2,int
4589,373510,setOOMScoreAdj,1,setOOMScoreAdj,int setOOMScoreAdj (int),server.c,"int setOOMScoreAdj(int process_class) {
    if (process_class == -1)
        process_class = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER);

    serverAssert(process_class >= 0 && process_class < CONFIG_OOM_COUNT);

#ifdef HAVE_PROC_OOM_SCORE_ADJ
    /* The following statics are used to indicate Redis has changed the process's oom score.
     * And to save the original score so we can restore it later if needed.
     * We need this so when we disabled oom-score-adj (also during configuration rollback
     * when another configuration parameter was invalid and causes a rollback after
     * applying a new oom-score) we can return to the oom-score value from before our
     * adjustments. */
    static int oom_score_adjusted_by_redis = 0;
    static int oom_score_adj_base = 0;

    int fd;
    int val;
    char buf[64];

    if (server.oom_score_adj != OOM_SCORE_ADJ_NO) {
        if (!oom_score_adjusted_by_redis) {
            oom_score_adjusted_by_redis = 1;
          ...",2205.0,2267.0,1.0,45.0,63.0,13,11,5,2,4,3,2,2,0,1,,0,2,2,1,1,int
4590,373558,adjustOpenFilesLimit,1,adjustOpenFilesLimit,void adjustOpenFilesLimit (void),server.c,"void adjustOpenFilesLimit(void) {
    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;
    struct rlimit limit;

    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {
        serverLog(LL_WARNING,""Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly."",
            strerror(errno));
        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;
    } else {
        rlim_t oldlimit = limit.rlim_cur;

        /* Set the max number of files if the current limit is not enough
         * for our needs. */
        if (oldlimit < maxfiles) {
            rlim_t bestlimit;
            int setrlimit_error = 0;

            /* Try to set the file limit to match 'maxfiles' or at least
             * to the higher value supported less than maxfiles. */
            bestlimit = maxfiles;
            while(bestlimit > oldlimit) {
                rlim_t decr_step = 16;

                limit.rlim_cur = bestlimit;
                limit.r...",2277.0,2353.0,1.0,40.0,77.0,12,9,7,5,2,7,2,2,0,1,,0,6,2,1,1,void
4591,373838,closeListener,1,closeListener,void closeListener (connListener*),server.c,"void closeListener(connListener *sfd) {
    int j;

    for (j = 0; j < sfd->count; j++) {
        if (sfd->fd[j] == -1) continue;

        aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);
        close(sfd->fd[j]);
    }

    sfd->count = 0;
}",2401.0,2412.0,1.0,49.0,12.0,14,7,11,3,4,8,4,4,2,1,,0,7,2,1,1,void
4592,373891,createSocketAcceptHandler,1,createSocketAcceptHandler,"int createSocketAcceptHandler (connListener*,aeFileProc*)",server.c,"int createSocketAcceptHandler(connListener *sfd, aeFileProc *accept_handler) {
    int j;

    for (j = 0; j < sfd->count; j++) {
        if (aeCreateFileEvent(server.el, sfd->fd[j], AE_READABLE, accept_handler,sfd) == AE_ERR) {
            /* Rollback */
            for (j = j-1; j >= 0; j--) aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);
            return C_ERR;
        }
    }
    return C_OK;
}",2416.0,2427.0,1.0,53.0,12.0,12,9,11,4,3,5,4,7,5,1,,0,5,4,2,2,int
4593,373965,listenToPort,1,listenToPort,int listenToPort (connListener*),server.c,"int listenToPort(connListener *sfd) {
    int j;
    int port = sfd->port;
    char **bindaddr = sfd->bindaddr;

    /* If we have no bind address, we don't listen on a TCP socket */
    if (sfd->bindaddr_count == 0) return C_OK;

    for (j = 0; j < sfd->bindaddr_count; j++) {
        char* addr = bindaddr[j];
        int optional = *addr == '-';
        if (optional) addr++;
        if (strchr(addr,':')) {
            /* Bind IPv6 address. */
            sfd->fd[sfd->count] = anetTcp6Server(server.neterr,port,addr,server.tcp_backlog);
        } else {
            /* Bind IPv4 address. */
            sfd->fd[sfd->count] = anetTcpServer(server.neterr,port,addr,server.tcp_backlog);
        }
        if (sfd->fd[sfd->count] == ANET_ERR) {
            int net_errno = errno;
            serverLog(LL_WARNING,
                ""Warning: Could not create server TCP listening socket %s:%d: %s"",
                addr, port, server.neterr);
            if (net_errno == EADDRNOTAVAIL && optional...",2448.0,2489.0,1.0,41.0,42.0,57,13,55,16,1,33,11,17,6,6,,0,28,2,1,1,int
4594,374188,resetServerStats,1,resetServerStats,void resetServerStats (void),server.c,"void resetServerStats(void) {
    int j;

    server.stat_numcommands = 0;
    server.stat_numconnections = 0;
    server.stat_expiredkeys = 0;
    server.stat_expired_stale_perc = 0;
    server.stat_expired_time_cap_reached_count = 0;
    server.stat_expire_cycle_time_used = 0;
    server.stat_evictedkeys = 0;
    server.stat_evictedclients = 0;
    server.stat_total_eviction_exceeded_time = 0;
    server.stat_last_eviction_exceeded_time = 0;
    server.stat_keyspace_misses = 0;
    server.stat_keyspace_hits = 0;
    server.stat_active_defrag_hits = 0;
    server.stat_active_defrag_misses = 0;
    server.stat_active_defrag_key_hits = 0;
    server.stat_active_defrag_key_misses = 0;
    server.stat_active_defrag_scanned = 0;
    server.stat_total_active_defrag_time = 0;
    server.stat_last_active_defrag_time = 0;
    server.stat_fork_time = 0;
    server.stat_fork_rate = 0;
    server.stat_total_forks = 0;
    server.stat_rejected_conn = 0;
    server.stat_sync_full = 0;
    server...",2494.0,2550.0,1.0,20.0,57.0,106,6,59,4,2,96,2,2,0,1,,0,95,2,1,1,void
4595,374481,makeThreadKillable,1,makeThreadKillable,void makeThreadKillable (void),server.c,"void makeThreadKillable(void) {
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
}",2555.0,2558.0,1.0,1.0,4.0,0,0,4,3,2,0,1,1,0,0,,0,0,2,1,1,void
4596,374492,initServer,1,initServer,void initServer (void),server.c,"void initServer(void) {
    int j;

    signal(SIGHUP, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);
    setupSignalHandlers();
    makeThreadKillable();

    if (server.syslog_enabled) {
        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,
            server.syslog_facility);
    }

    /* Initialization after setting defaults from the config system. */
    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;
    server.fsynced_reploff = server.aof_enabled ? 0 : -1;
    server.hz = server.config_hz;
    server.pid = getpid();
    server.in_fork_child = CHILD_TYPE_NONE;
    server.main_thread_id = pthread_self();
    server.current_client = NULL;
    server.errors = raxNew();
    server.execution_nesting = 0;
    server.clients = listCreate();
    server.clients_index = raxNew();
    server.clients_to_close = listCreate();
    server.slaves = listCreate();
    server.monitors = listCreate();
    server.clients_pending_write = listCreate();
    server.clients_pendin...",2560.0,2753.0,1.0,44.0,194.0,333,19,187,19,0,329,10,10,22,54,,0,307,2,1,1,void
4597,375458,initListeners,1,initListeners,void initListeners (void),server.c,"void initListeners(void) {
    /* Setup listeners from server config for TCP/TLS/Unix */
    int conn_index;
    connListener *listener;
    if (server.port != 0) {
        conn_index = connectionIndexByType(CONN_TYPE_SOCKET);
        if (conn_index < 0)
            serverPanic(""Failed finding connection listener of %s"", CONN_TYPE_SOCKET);
        listener = &server.listeners[conn_index];
        listener->bindaddr = server.bindaddr;
        listener->bindaddr_count = server.bindaddr_count;
        listener->port = server.port;
        listener->ct = connectionByType(CONN_TYPE_SOCKET);
    }

    if (server.tls_port || server.tls_replication || server.tls_cluster) {
        ConnectionType *ct_tls = connectionTypeTls();
        if (!ct_tls) {
            serverLog(LL_WARNING, ""Failed finding TLS support."");
            exit(1);
        }
        if (connTypeConfigure(ct_tls, &server.tls_ctx_config, 1) == C_ERR) {
            serverLog(LL_WARNING, ""Failed to configure TLS. Check logs ...",2755.0,2825.0,1.0,43.0,71.0,106,14,69,7,0,83,16,23,20,19,,0,75,2,1,1,void
4598,375862,InitServerLast,1,InitServerLast,void InitServerLast (void),server.c,"void InitServerLast(void) {
    bioInit();
    initThreadedIO();
    set_jemalloc_bg_thread(server.jemalloc_bg_thread);
    server.initial_memory_usage = zmalloc_used_memory();
}",2832.0,2837.0,1.0,1.0,6.0,3,2,2,1,0,8,1,1,0,4,,0,5,2,1,1,void
4599,375878,populateCommandLegacyRangeSpec,1,populateCommandLegacyRangeSpec,void populateCommandLegacyRangeSpec (redisCommand*),server.c,"void populateCommandLegacyRangeSpec(struct redisCommand *c) {
    memset(&c->legacy_range_key_spec, 0, sizeof(c->legacy_range_key_spec));

    /* Set the movablekeys flag if we have a GETKEYS flag for modules.
     * Note that for native redis commands, we always have keyspecs,
     * with enough information to rely on for movablekeys. */
    if (c->flags & CMD_MODULE_GETKEYS)
        c->flags |= CMD_MOVABLE_KEYS;

    /* no key-specs, no keys, exit. */
    if (c->key_specs_num == 0) {
        return;
    }

    if (c->key_specs_num == 1 &&
        c->key_specs[0].begin_search_type == KSPEC_BS_INDEX &&
        c->key_specs[0].find_keys_type == KSPEC_FK_RANGE)
    {
        /* Quick win, exactly one range spec. */
        c->legacy_range_key_spec = c->key_specs[0];
        /* If it has the incomplete flag, set the movablekeys flag on the command. */
        if (c->key_specs[0].flags & CMD_KEY_INCOMPLETE)
            c->flags |= CMD_MOVABLE_KEYS;
        return;
    }

    int firstke...",2869.0,2942.0,1.0,19.0,74.0,158,21,82,9,2,35,13,16,12,2,,0,33,2,1,1,void
4600,376319,catSubCommandFullname,1,catSubCommandFullname,"sds catSubCommandFullname (char*,char*)",server.c,"sds catSubCommandFullname(const char *parent_name, const char *sub_name) {
    return sdscatfmt(sdsempty(), ""%s|%s"", parent_name, sub_name);
}",2944.0,2946.0,1.0,1.0,3.0,0,0,2,2,2,2,1,1,0,2,,0,1,4,2,2,sds
4601,376331,commandAddSubcommand,1,commandAddSubcommand,"void commandAddSubcommand (redisCommand*,redisCommand*,char*)",server.c,"void commandAddSubcommand(struct redisCommand *parent, struct redisCommand *subcommand, const char *declared_name) {
    if (!parent->subcommands_dict)
        parent->subcommands_dict = dictCreate(&commandTableDictType);

    subcommand->parent = parent; /* Assign the parent command */
    subcommand->id = ACLGetCommandID(subcommand->fullname); /* Assign the ID used for ACL. */

    serverAssert(dictAdd(parent->subcommands_dict, sdsnew(declared_name), subcommand) == DICT_OK);
}",2948.0,2956.0,1.0,4.0,9.0,16,9,10,4,2,12,2,2,1,5,,0,10,6,3,3,void
4602,376386,setImplicitACLCategories,1,setImplicitACLCategories,void setImplicitACLCategories (redisCommand*),server.c,"void setImplicitACLCategories(struct redisCommand *c) {
    if (c->flags & CMD_WRITE)
        c->acl_categories |= ACL_CATEGORY_WRITE;
    /* Exclude scripting commands from the RO category. */
    if (c->flags & CMD_READONLY && !(c->acl_categories & ACL_CATEGORY_SCRIPTING))
        c->acl_categories |= ACL_CATEGORY_READ;
    if (c->flags & CMD_ADMIN)
        c->acl_categories |= ACL_CATEGORY_ADMIN|ACL_CATEGORY_DANGEROUS;
    if (c->flags & CMD_PUBSUB)
        c->acl_categories |= ACL_CATEGORY_PUBSUB;
    if (c->flags & CMD_FAST)
        c->acl_categories |= ACL_CATEGORY_FAST;
    if (c->flags & CMD_BLOCKING)
        c->acl_categories |= ACL_CATEGORY_BLOCKING;

    /* If it's not @fast is @slow in this binary world. */
    if (!(c->acl_categories & ACL_CATEGORY_FAST))
        c->acl_categories |= ACL_CATEGORY_SLOW;
}",2960.0,2978.0,1.0,19.0,19.0,43,6,15,1,1,15,8,8,8,0,,0,15,2,1,1,void
4603,376549,populateCommandStructure,1,populateCommandStructure,int populateCommandStructure (redisCommand*),server.c,"int populateCommandStructure(struct redisCommand *c) {
    /* If the command marks with CMD_SENTINEL, it exists in sentinel. */
    if (!(c->flags & CMD_SENTINEL) && server.sentinel_mode)
        return C_ERR;

    /* If the command marks with CMD_ONLY_SENTINEL, it only exists in sentinel. */
    if (c->flags & CMD_ONLY_SENTINEL && !server.sentinel_mode)
        return C_ERR;

    /* Translate the command string flags description into an actual
     * set of flags. */
    setImplicitACLCategories(c);

    /* We start with an unallocated histogram and only allocate memory when a command
     * has been issued for the first time */
    c->latency_histogram = NULL;

    /* Handle the legacy range spec and the ""movablekeys"" flag (must be done after populating all key specs). */
    populateCommandLegacyRangeSpec(c);

    /* Assign the ID used for ACL. */
    c->id = ACLGetCommandID(c->fullname);

    /* Handle subcommands */
    if (c->subcommands) {
        for (int j = 0; c->subcomman...",2984.0,3021.0,1.0,21.0,38.0,34,11,24,5,1,21,7,9,8,5,,0,18,2,1,1,int
4604,376676,populateCommandTable,1,populateCommandTable,void populateCommandTable (void),server.c,"void populateCommandTable(void) {
    int j;
    struct redisCommand *c;

    for (j = 0;; j++) {
        c = redisCommandTable + j;
        if (c->declared_name == NULL)
            break;

        int retval1, retval2;

        c->fullname = sdsnew(c->declared_name);
        if (populateCommandStructure(c) == C_ERR)
            continue;

        retval1 = dictAdd(server.commands, sdsdup(c->fullname), c);
        /* Populate an additional dictionary that will be unaffected
         * by rename-command statements in redis.conf. */
        retval2 = dictAdd(server.orig_commands, sdsdup(c->fullname), c);
        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
    }
}",3027.0,3048.0,1.0,43.0,22.0,24,12,20,7,1,17,6,6,2,7,,0,16,2,1,1,void
4605,376766,resetCommandTableStats,1,resetCommandTableStats,void resetCommandTableStats (dict*),server.c,"void resetCommandTableStats(dict* commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;

    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        c = (struct redisCommand *) dictGetVal(de);
        c->microseconds = 0;
        c->calls = 0;
        c->rejected_calls = 0;
        c->failed_calls = 0;
        if(c->latency_histogram) {
            hdr_close(c->latency_histogram);
            c->latency_histogram = NULL;
        }
        if (c->subcommands_dict)
            resetCommandTableStats(c->subcommands_dict);
    }
    dictReleaseIterator(di);
}",3050.0,3070.0,1.0,1.0,21.0,19,4,18,5,1,13,4,6,3,4,,0,12,2,1,1,void
4606,376837,resetErrorTableStats,1,resetErrorTableStats,void resetErrorTableStats (void),server.c,"void resetErrorTableStats(void) {
    raxFreeWithCallback(server.errors, zfree);
    server.errors = raxNew();
}",3072.0,3075.0,1.0,1.0,4.0,3,2,3,2,1,6,1,1,0,2,,0,5,2,1,1,void
4607,376852,redisOpArrayAppend,1,redisOpArrayAppend,"int redisOpArrayAppend (redisOpArray*,int,robj**,int,int)",server.c,"int redisOpArrayAppend(redisOpArray *oa, int dbid, robj **argv, int argc, int target) {
    redisOp *op;
    int prev_capacity = oa->capacity;

    if (oa->numops == 0) {
        oa->capacity = 16;
    } else if (oa->numops >= oa->capacity) {
        oa->capacity *= 2;
    }

    if (prev_capacity != oa->capacity)
        oa->ops = zrealloc(oa->ops,sizeof(redisOp)*oa->capacity);
    op = oa->ops+oa->numops;
    op->dbid = dbid;
    op->argv = argv;
    op->argc = argc;
    op->target = target;
    oa->numops++;
    return oa->numops;
}",3079.0,3098.0,1.0,1.0,20.0,29,8,23,8,1,16,3,3,2,1,,0,16,10,5,5,int
4608,376954,redisOpArrayFree,1,redisOpArrayFree,void redisOpArrayFree (redisOpArray*),server.c,"void redisOpArrayFree(redisOpArray *oa) {
    while(oa->numops) {
        int j;
        redisOp *op;

        oa->numops--;
        op = oa->ops+oa->numops;
        for (j = 0; j < op->argc; j++)
            decrRefCount(op->argv[j]);
        zfree(op->argv);
    }
    /* no need to free the actual op array, we reuse the memory for future commands */
    serverAssert(!oa->numops);
}",3100.0,3113.0,1.0,4.0,14.0,19,10,11,3,1,10,3,4,2,2,,0,8,2,1,1,void
4609,377022,isContainerCommandBySds,1,isContainerCommandBySds,int isContainerCommandBySds (sds),server.c,"int isContainerCommandBySds(sds s) {
    struct redisCommand *base_cmd = dictFetchValue(server.commands, s);
    int has_subcommands = base_cmd && base_cmd->subcommands_dict;
    return has_subcommands;
}",3117.0,3121.0,1.0,1.0,5.0,5,4,7,4,1,4,1,1,0,1,,0,4,2,1,1,int
4610,377045,lookupSubcommand,1,lookupSubcommand,"struct redisCommand lookupSubcommand (redisCommand*,sds)",server.c,"struct redisCommand *lookupSubcommand(struct redisCommand *container, sds sub_name) {
    return dictFetchValue(container->subcommands_dict, sub_name);
}",3123.0,3125.0,1.0,1.0,3.0,1,1,2,2,1,2,1,1,0,1,,0,1,4,2,2,struct redisCommand
4611,377057,lookupCommandLogic,1,lookupCommandLogic,"struct redisCommand lookupCommandLogic (dict*,robj**,int,int)",server.c,"struct redisCommand *lookupCommandLogic(dict *commands, robj **argv, int argc, int strict) {
    struct redisCommand *base_cmd = dictFetchValue(commands, argv[0]->ptr);
    int has_subcommands = base_cmd && base_cmd->subcommands_dict;
    if (argc == 1 || !has_subcommands) {
        if (strict && argc != 1)
            return NULL;
        /* Note: It is possible that base_cmd->proc==NULL (e.g. CONFIG) */
        return base_cmd;
    } else { /* argc > 1 && has_subcommands */
        if (strict && argc != 2)
            return NULL;
        /* Note: Currently we support just one level of subcommands */
        return lookupSubcommand(base_cmd, argv[1]->ptr);
    }
}",3135.0,3149.0,1.0,1.0,15.0,11,8,12,7,4,2,3,4,0,1,,0,2,8,4,4,struct redisCommand
4612,377121,lookupCommand,1,lookupCommand,"struct redisCommand lookupCommand (robj**,int)",server.c,"struct redisCommand *lookupCommand(robj **argv, int argc) {
    return lookupCommandLogic(server.commands,argv,argc,0);
}",3151.0,3153.0,1.0,1.0,3.0,1,1,3,3,8,3,1,1,0,1,,0,2,4,2,2,struct redisCommand
4613,377135,lookupCommandBySdsLogic,1,lookupCommandBySdsLogic,"struct redisCommand lookupCommandBySdsLogic (dict*,sds)",server.c,"struct redisCommand *lookupCommandBySdsLogic(dict *commands, sds s) {
    int argc, j;
    sds *strings = sdssplitlen(s,sdslen(s),""|"",1,&argc);
    if (strings == NULL)
        return NULL;
    if (argc < 1 || argc > 2) {
        /* Currently we support just one level of subcommands */
        sdsfreesplitres(strings,argc);
        return NULL;
    }

    serverAssert(argc > 0); /* Avoid warning `-Wmaybe-uninitialized` in lookupCommandLogic() */
    robj objects[argc];
    robj *argv[argc];
    for (j = 0; j < argc; j++) {
        initStaticStringObject(objects[j],strings[j]);
        argv[j] = &objects[j];
    }

    struct redisCommand *cmd = lookupCommandLogic(commands,argv,argc,1);
    sdsfreesplitres(strings,argc);
    return cmd;
}",3155.0,3177.0,1.0,4.0,23.0,34,13,42,10,3,6,4,4,0,6,,0,3,4,2,2,struct redisCommand
4614,377268,lookupCommandBySds,1,lookupCommandBySds,struct redisCommand lookupCommandBySds (sds),server.c,"struct redisCommand *lookupCommandBySds(sds s) {
    return lookupCommandBySdsLogic(server.commands,s);
}",3179.0,3181.0,1.0,1.0,3.0,1,1,2,2,1,3,1,1,0,1,,0,2,2,1,1,struct redisCommand
4615,377279,lookupCommandByCStringLogic,1,lookupCommandByCStringLogic,"struct redisCommand lookupCommandByCStringLogic (dict*,char*)",server.c,"struct redisCommand *lookupCommandByCStringLogic(dict *commands, const char *s) {
    struct redisCommand *cmd;
    sds name = sdsnew(s);

    cmd = lookupCommandBySdsLogic(commands,name);
    sdsfree(name);
    return cmd;
}",3183.0,3190.0,1.0,1.0,8.0,2,1,7,4,1,3,1,1,0,3,,0,2,4,2,2,struct redisCommand
4616,377300,lookupCommandByCString,1,lookupCommandByCString,struct redisCommand lookupCommandByCString (char*),server.c,"struct redisCommand *lookupCommandByCString(const char *s) {
    return lookupCommandByCStringLogic(server.commands,s);
}",3192.0,3194.0,1.0,1.0,3.0,1,1,2,2,4,3,1,1,0,1,,0,2,2,1,1,struct redisCommand
4617,377311,lookupCommandOrOriginal,1,lookupCommandOrOriginal,"struct redisCommand lookupCommandOrOriginal (robj**,int)",server.c,"struct redisCommand *lookupCommandOrOriginal(robj **argv ,int argc) {
    struct redisCommand *cmd = lookupCommandLogic(server.commands, argv, argc, 0);

    if (!cmd) cmd = lookupCommandLogic(server.orig_commands, argv, argc, 0);
    return cmd;
}",3203.0,3208.0,1.0,1.0,6.0,5,3,10,4,2,6,2,2,0,2,,0,6,4,2,2,struct redisCommand
4618,377342,mustObeyClient,1,mustObeyClient,int mustObeyClient (client*),server.c,"int mustObeyClient(client *c) {
    return c->id == CLIENT_ID_AOF || c->flags & CLIENT_MASTER;
}",3211.0,3213.0,1.0,20.0,3.0,6,5,3,2,12,2,1,1,0,0,,0,2,2,1,1,int
4619,377365,shouldPropagate,1,shouldPropagate,int shouldPropagate (int),server.c,"static int shouldPropagate(int target) {
    if (!server.replication_allowed || target == PROPAGATE_NONE || server.loading)
        return 0;

    if (target & PROPAGATE_AOF) {
        if (server.aof_state != AOF_OFF)
            return 1;
    }
    if (target & PROPAGATE_REPL) {
        if (server.masterhost == NULL && (server.repl_backlog || listLength(server.slaves) != 0))
            return 1;
    }

    return 0;
}",3215.0,3229.0,1.0,49.0,15.0,19,8,11,3,2,14,6,8,14,0,,0,14,2,1,1,int
4620,377441,propagateNow,1,propagateNow,"void propagateNow (int,robj**,int,int)",server.c,"static void propagateNow(int dbid, robj **argv, int argc, int target) {
    if (!shouldPropagate(target))
        return;

    /* This needs to be unreachable since the dataset should be fixed during
     * replica pause (otherwise data may be lost during a failover) */
    serverAssert(!(isPausedActions(PAUSE_ACTION_REPLICA) &&
                   (!server.client_pause_in_transaction)));

    if (server.aof_state != AOF_OFF && target & PROPAGATE_AOF)
        feedAppendOnlyFile(dbid,argv,argc);
    if (target & PROPAGATE_REPL)
        replicationFeedSlaves(server.slaves,dbid,argv,argc);
}",3246.0,3259.0,1.0,4.0,14.0,16,10,12,5,3,11,4,4,3,5,,0,7,8,4,4,void
4621,377511,alsoPropagate,1,alsoPropagate,"void alsoPropagate (int,robj**,int,int)",server.c,"void alsoPropagate(int dbid, robj **argv, int argc, int target) {
    robj **argvcopy;
    int j;

    if (!shouldPropagate(target))
        return;

    argvcopy = zmalloc(sizeof(robj*)*argc);
    for (j = 0; j < argc; j++) {
        argvcopy[j] = argv[j];
        incrRefCount(argv[j]);
    }
    redisOpArrayAppend(&server.also_propagate,dbid,argvcopy,argc,target);
}",3272.0,3285.0,1.0,1.0,14.0,12,8,18,8,7,6,3,3,1,4,,0,4,8,4,4,void
4622,377565,forceCommandPropagation,1,forceCommandPropagation,"void forceCommandPropagation (client*,int)",server.c,"void forceCommandPropagation(client *c, int flags) {
    serverAssert(c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE));
    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;
    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;
}",3290.0,3294.0,1.0,4.0,5.0,16,8,5,2,4,4,3,3,0,1,,0,3,4,2,2,void
4623,377629,preventCommandPropagation,1,preventCommandPropagation,void preventCommandPropagation (client*),server.c,"void preventCommandPropagation(client *c) {
    c->flags |= CLIENT_PREVENT_PROP;
}",3299.0,3301.0,1.0,16.0,3.0,4,3,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
4624,377647,preventCommandAOF,1,preventCommandAOF,void preventCommandAOF (client*),server.c,"void preventCommandAOF(client *c) {
    c->flags |= CLIENT_PREVENT_AOF_PROP;
}",3304.0,3306.0,1.0,16.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
4625,377661,preventCommandReplication,1,preventCommandReplication,void preventCommandReplication (client*),server.c,"void preventCommandReplication(client *c) {
    c->flags |= CLIENT_PREVENT_REPL_PROP;
}",3309.0,3311.0,1.0,16.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
4626,377675,slowlogPushCurrentCommand,1,slowlogPushCurrentCommand,"void slowlogPushCurrentCommand (client*,redisCommand*,ustime_t)",server.c,"void slowlogPushCurrentCommand(client *c, struct redisCommand *cmd, ustime_t duration) {
    /* Some commands may contain sensitive data that should not be available in the slowlog. */
    if (cmd->flags & CMD_SKIP_SLOWLOG)
        return;

    /* If command argument vector was rewritten, use the original
     * arguments. */
    robj **argv = c->original_argv ? c->original_argv : c->argv;
    int argc = c->original_argv ? c->original_argc : c->argc;
    slowlogPushEntryIfNeeded(c,argv,argc,duration);
}",3314.0,3324.0,1.0,21.0,11.0,13,5,13,5,1,8,2,2,1,1,,0,7,6,3,3,void
4627,377725,updateCommandLatencyHistogram,1,updateCommandLatencyHistogram,"void updateCommandLatencyHistogram (hdr_histogram**,int64_t)",server.c,"void updateCommandLatencyHistogram(struct hdr_histogram **latency_histogram, int64_t duration_hist){
    if (duration_hist < LATENCY_HISTOGRAM_MIN_VALUE)
        duration_hist=LATENCY_HISTOGRAM_MIN_VALUE;
    if (duration_hist>LATENCY_HISTOGRAM_MAX_VALUE)
        duration_hist=LATENCY_HISTOGRAM_MAX_VALUE;
    if (*latency_histogram==NULL)
        hdr_init(LATENCY_HISTOGRAM_MIN_VALUE,LATENCY_HISTOGRAM_MAX_VALUE,LATENCY_HISTOGRAM_PRECISION,latency_histogram);
    hdr_record_value(*latency_histogram,duration_hist);
}",3329.0,3337.0,1.0,24.0,9.0,7,5,9,3,1,0,4,4,0,0,,0,0,4,2,2,void
4628,377776,propagatePendingCommands,1,propagatePendingCommands,void propagatePendingCommands (void),server.c,"static void propagatePendingCommands(void) {
    if (server.also_propagate.numops == 0)
        return;

    int j;
    redisOp *rop;

    /* If we got here it means we have finished an execution-unit.
     * If that unit has caused propagation of multiple commands, they
     * should be propagated as a transaction */
    int transaction = server.also_propagate.numops > 1;

    /* In case a command that may modify random keys was run *directly*
     * (i.e. not from within a script, MULTI/EXEC, RM_Call, etc.) we want
     * to avoid using a transaction (much like active-expire) */
    if (server.current_client &&
        server.current_client->cmd &&
        server.current_client->cmd->flags & CMD_TOUCHES_ARBITRARY_KEYS)
    {
        transaction = 0;
    }

    if (transaction) {
        /* We use dbid=-1 to indicate we do not want to replicate SELECT.
         * It'll be inserted together with the next command (inside the MULTI) */
        propagateNow(-1,&shared.multi,1,PROPAGATE...",3342.0,3382.0,1.0,44.0,41.0,47,17,24,5,1,31,6,6,10,5,,0,26,2,1,1,void
4629,377929,postExecutionUnitOperations,1,postExecutionUnitOperations,void postExecutionUnitOperations (void),server.c,"void postExecutionUnitOperations(void) {
    if (server.execution_nesting)
        return;

    firePostExecutionUnitJobs();

    /* If we are at the top-most call() and not inside a an active module
     * context (e.g. within a module timer) we can propagate what we accumulated. */
    propagatePendingCommands();

    /* Module subsystem post-execution-unit logic */
    modulePostExecutionUnitOperations();
}",3398.0,3410.0,1.0,1.0,13.0,1,1,1,1,6,5,2,2,2,3,,0,2,2,1,1,void
4630,377943,incrCommandStatsOnError,1,incrCommandStatsOnError,"int incrCommandStatsOnError (redisCommand*,int)",server.c,"int incrCommandStatsOnError(struct redisCommand *cmd, int flags) {
    /* hold the prev error count captured on the last command execution */
    static long long prev_err_count = 0;
    int res = 0;
    if (cmd) {
        if ((server.stat_total_error_replies - prev_err_count) > 0) {
            if (flags & ERROR_COMMAND_REJECTED) {
                cmd->rejected_calls++;
                res = 1;
            } else if (flags & ERROR_COMMAND_FAILED) {
                cmd->failed_calls++;
                res = 1;
            }
        }
    }
    prev_err_count = server.stat_total_error_replies;
    return res;
}",3421.0,3438.0,1.0,24.0,18.0,12,8,11,5,1,5,4,7,2,0,,0,5,4,2,2,int
4631,378861,rejectCommand,1,rejectCommand,"void rejectCommand (client*,robj*)",server.c,"void rejectCommand(client *c, robj *reply) {
    flagTransaction(c);
    c->duration = 0;
    if (c->cmd) c->cmd->rejected_calls++;
    if (c->cmd && c->cmd->proc == execCommand) {
        execCommandAbort(c, reply->ptr);
    } else {
        /* using addReplyError* rather than addReply so that the error can be logged. */
        addReplyErrorObject(c, reply);
    }
}",3702.0,3712.0,1.0,1.0,11.0,12,5,9,3,7,7,3,3,3,2,,0,5,4,2,2,void
4632,378908,rejectCommandSds,1,rejectCommandSds,"void rejectCommandSds (client*,sds)",server.c,"void rejectCommandSds(client *c, sds s) {
    flagTransaction(c);
    c->duration = 0;
    if (c->cmd) c->cmd->rejected_calls++;
    if (c->cmd && c->cmd->proc == execCommand) {
        execCommandAbort(c, s);
        sdsfree(s);
    } else {
        /* The following frees 's'. */
        addReplyErrorSds(c, s);
    }
}",3714.0,3725.0,1.0,1.0,12.0,11,5,10,3,3,8,3,3,3,3,,0,5,4,2,2,void
4633,378955,rejectCommandFormat,1,rejectCommandFormat,"void rejectCommandFormat (client*,char*...)",server.c,"void rejectCommandFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    sds s = sdscatvprintf(sdsempty(),fmt,ap);
    va_end(ap);
    /* Make sure there are no newlines in the string, otherwise invalid protocol
     * is emitted (The args come from the user, they may contain any character). */
    sdsmapchars(s, ""\r\n"", ""  "",  2);
    rejectCommandSds(c, s);
}",3727.0,3736.0,1.0,1.0,10.0,1,1,9,4,6,4,1,1,0,4,,0,2,4,2,2,void
4634,378982,afterCommand,1,afterCommand,void afterCommand (client*),server.c,"void afterCommand(client *c) {
    UNUSED(c);
    /* Should be done before trackingHandlePendingKeyInvalidations so that we
     * reply to client before invalidating cache (makes more sense) */
    postExecutionUnitOperations();

    /* Flush pending tracking invalidations. */
    trackingHandlePendingKeyInvalidations();

    /* Flush other pending push messages. only when we are not in nested call.
     * So the messages are not interleaved with transaction response. */
    if (!server.execution_nesting)
        listJoin(c->reply, server.pending_push_messages);
}",3739.0,3752.0,1.0,4.0,14.0,5,4,5,2,0,8,2,2,2,3,,0,5,2,1,1,void
4635,379008,commandCheckExistence,1,commandCheckExistence,"int commandCheckExistence (client*,sds*)",server.c,"int commandCheckExistence(client *c, sds *err) {
    if (c->cmd)
        return 1;
    if (!err)
        return 0;
    if (isContainerCommandBySds(c->argv[0]->ptr)) {
        /* If we can't find the command but argv[0] by itself is a command
         * it means we're dealing with an invalid subcommand. Print Help. */
        sds cmd = sdsnew((char *)c->argv[0]->ptr);
        sdstoupper(cmd);
        *err = sdsnew(NULL);
        *err = sdscatprintf(*err, ""unknown subcommand '%.128s'. Try %s HELP."",
                            (char *)c->argv[1]->ptr, cmd);
        sdsfree(cmd);
    } else {
        sds args = sdsempty();
        int i;
        for (i=1; i < c->argc && sdslen(args) < 128; i++)
            args = sdscatprintf(args, ""'%.*s' "", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
        *err = sdsnew(NULL);
        *err = sdscatprintf(*err, ""unknown command '%.128s', with args beginning with: %s"",
                            (char*)c->argv[0]->ptr, args);
        sdsfree(arg...",3756.0,3784.0,1.0,1.0,29.0,20,6,14,4,2,11,4,4,3,7,,0,8,4,2,2,int
4636,379152,commandCheckArity,1,commandCheckArity,"int commandCheckArity (client*,sds*)",server.c,"int commandCheckArity(client *c, sds *err) {
    if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
        (c->argc < -c->cmd->arity))
    {
        if (err) {
            *err = sdsnew(NULL);
            *err = sdscatprintf(*err, ""wrong number of arguments for '%s' command"", c->cmd->fullname);
        }
        return 0;
    }

    return 1;
}",3788.0,3800.0,1.0,1.0,13.0,21,9,11,3,2,8,3,4,5,2,,0,8,4,2,2,int
4637,379212,getCommandFlags,1,getCommandFlags,uint64_t getCommandFlags (client*),server.c,"uint64_t getCommandFlags(client *c) {
    uint64_t cmd_flags = c->cmd->flags;

    if (c->cmd->proc == fcallCommand || c->cmd->proc == fcallroCommand) {
        cmd_flags = fcallGetCommandFlags(c, cmd_flags);
    } else if (c->cmd->proc == evalCommand || c->cmd->proc == evalRoCommand ||
               c->cmd->proc == evalShaCommand || c->cmd->proc == evalShaRoCommand)
    {
        cmd_flags = evalGetCommandFlags(c, cmd_flags);
    }

    return cmd_flags;
}",3805.0,3817.0,1.0,1.0,13.0,11,4,10,4,3,4,2,2,2,1,,0,4,2,1,1,uint64_t
4638,379289,processCommand,1,processCommand,int processCommand (client*),server.c,"int processCommand(client *c) {
    if (!scriptIsTimedout()) {
        /* Both EXEC and scripts call call() directly so there should be
         * no way in_exec or scriptIsRunning() is 1.
         * That is unless lua_timedout, in which case client may run
         * some commands. */
        serverAssert(!server.in_exec);
        serverAssert(!scriptIsRunning());
    }

    /* in case we are starting to ProcessCommand and we already have a command we assume
     * this is a reprocessing of this command, so we do not want to perform some of the actions again. */
    int client_reprocessing_command = c->cmd ? 1 : 0;

    /* only run command filter if not reprocessing command */
    if (!client_reprocessing_command) {
        moduleCallCommandFilters(c);
        reqresAppendRequest(c);
    }

    /* Handle possible security attacks. */
    if (!strcasecmp(c->argv[0]->ptr,""host:"") || !strcasecmp(c->argv[0]->ptr,""post"")) {
        securityWarningCommand(c);
        return C_ERR;
    }
...",3827.0,4168.0,1.0,8.0,342.0,406,19,239,38,1,193,37,53,94,54,,0,159,2,1,1,int
4639,380657,incrementErrorCount,1,incrementErrorCount,"void incrementErrorCount (char*,size_t)",server.c,"void incrementErrorCount(const char *fullerr, size_t namelen) {
    struct redisError *error = raxFind(server.errors,(unsigned char*)fullerr,namelen);
    if (error == raxNotFound) {
        error = zmalloc(sizeof(*error));
        error->count = 0;
        raxInsert(server.errors,(unsigned char*)fullerr,namelen,error,NULL);
    }
    error->count++;
}",4172.0,4180.0,1.0,1.0,9.0,13,8,15,6,1,9,2,2,0,3,,0,8,4,2,2,void
4640,380704,closeListeningSockets,1,closeListeningSockets,void closeListeningSockets (int),server.c,"void closeListeningSockets(int unlink_unix_socket) {
    int j;

    for (int i = 0; i < CONN_TYPE_MAX; i++) {
        connListener *listener = &server.listeners[i];
        if (listener->ct == NULL)
            continue;

        for (j = 0; j < listener->count; j++) close(listener->fd[j]);
    }

    if (server.cluster_enabled)
        for (j = 0; j < server.clistener.count; j++) close(server.clistener.fd[j]);
    if (unlink_unix_socket && server.unixsocket) {
        serverLog(LL_NOTICE,""Removing the unix socket file."");
        if (unlink(server.unixsocket) != 0)
            serverLog(LL_WARNING,""Error removing the unix socket file: %s"",strerror(errno));
    }
}",4186.0,4204.0,1.0,24.0,19.0,26,10,20,7,1,18,9,12,10,2,,0,16,2,1,1,void
4641,380839,prepareForShutdown,1,prepareForShutdown,int prepareForShutdown (int),server.c,"int prepareForShutdown(int flags) {
    if (isShutdownInitiated()) return C_ERR;

    /* When SHUTDOWN is called while the server is loading a dataset in
     * memory we need to make sure no attempt is performed to save
     * the dataset on shutdown (otherwise it could overwrite the current DB
     * with half-read data).
     *
     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */
    if (server.loading || server.sentinel_mode)
        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;

    server.shutdown_flags = flags;

    serverLog(LL_NOTICE,""User requested shutdown..."");
    if (server.supervised_mode == SUPERVISED_SYSTEMD)
        redisCommunicateSystemd(""STOPPING=1\n"");

    /* If we have any replicas, let them catch up the replication offset before
     * we shut down, to avoid data loss. */
    if (!(flags & SHUTDOWN_NOW) &&
        server.shutdown_timeout != 0 &&
        !isReadyToShutdown())
    {
        server.shutdown_mstime = server.mstime + s...",4229.0,4263.0,1.0,38.0,35.0,41,15,16,4,4,29,6,7,11,9,,0,23,2,1,1,int
4642,381063,cancelShutdown,1,cancelShutdown,void cancelShutdown (void),server.c,"static void cancelShutdown(void) {
    server.shutdown_asap = 0;
    server.shutdown_flags = 0;
    server.shutdown_mstime = 0;
    server.last_sig_received = 0;
    replyToClientsBlockedOnShutdown();
    unpauseActions(PAUSE_DURING_SHUTDOWN);
}",4285.0,4292.0,1.0,1.0,8.0,8,2,5,2,1,10,1,1,0,2,,0,8,2,1,1,void
4643,381091,abortShutdown,1,abortShutdown,int abortShutdown (void),server.c,"int abortShutdown(void) {
    if (isShutdownInitiated()) {
        cancelShutdown();
    } else if (server.shutdown_asap) {
        /* Signal handler has requested shutdown, but it hasn't been initiated
         * yet. Just clear the flag. */
        server.shutdown_asap = 0;
    } else {
        /* Shutdown neither initiated nor requested. */
        return C_ERR;
    }
    serverLog(LL_NOTICE, ""Shutdown manually aborted."");
    return C_OK;
}",4295.0,4308.0,1.0,15.0,14.0,3,3,1,1,1,5,2,2,1,3,,0,3,2,1,1,int
4644,381760,writeCommandsDeniedByDiskError,1,writeCommandsDeniedByDiskError,int writeCommandsDeniedByDiskError (void),server.c,"int writeCommandsDeniedByDiskError(void) {
    if (server.stop_writes_on_bgsave_err &&
        server.saveparamslen > 0 &&
        server.lastbgsave_status == C_ERR)
    {
        return DISK_ERROR_TYPE_RDB;
    } else if (server.aof_state != AOF_OFF) {
        if (server.aof_last_write_status == C_ERR) {
            return DISK_ERROR_TYPE_AOF;
        }
        /* AOF fsync error. */
        int aof_bio_fsync_status;
        atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);
        if (aof_bio_fsync_status == C_ERR) {
            atomicGet(server.aof_bio_fsync_errno,server.aof_last_write_errno);
            return DISK_ERROR_TYPE_AOF;
        }
    }

    return DISK_ERROR_TYPE_NONE;
}",4475.0,4495.0,1.0,36.0,21.0,8,5,3,1,4,6,2,2,6,0,,0,6,2,1,1,int
4645,381843,writeCommandsGetDiskErrorMessage,1,writeCommandsGetDiskErrorMessage,sds writeCommandsGetDiskErrorMessage (int),server.c,"sds writeCommandsGetDiskErrorMessage(int error_code) {
    sds ret = NULL;
    if (error_code == DISK_ERROR_TYPE_RDB) {
        ret = sdsdup(shared.bgsaveerr->ptr);
    } else {
        ret = sdscatfmt(sdsempty(),
                ""-MISCONF Errors writing to the AOF file: %s\r\n"",
                strerror(server.aof_last_write_errno));
    }
    return ret;
}",4497.0,4507.0,1.0,22.0,11.0,5,4,6,4,2,3,2,2,0,1,,0,3,2,1,1,sds
4646,381880,pingCommand,1,pingCommand,void pingCommand (client*),server.c,"void pingCommand(client *c) {
    /* The command takes zero or one arguments. */
    if (c->argc > 2) {
        addReplyErrorArity(c);
        return;
    }

    if (c->flags & CLIENT_PUBSUB && c->resp == 2) {
        addReply(c,shared.mbulkhdr[2]);
        addReplyBulkCBuffer(c,""pong"",4);
        if (c->argc == 1)
            addReplyBulkCBuffer(c,"""",0);
        else
            addReplyBulk(c,c->argv[1]);
    } else {
        if (c->argc == 1)
            addReply(c,shared.pong);
        else
            addReplyBulk(c,c->argv[1]);
    }
}",4511.0,4531.0,1.0,19.0,21.0,12,8,9,2,0,10,4,5,4,4,,0,6,2,1,1,void
4647,381966,echoCommand,1,echoCommand,void echoCommand (client*),server.c,"void echoCommand(client *c) {
    addReplyBulk(c,c->argv[1]);
}",4533.0,4535.0,1.0,1.0,3.0,2,2,2,1,0,2,1,1,0,1,,0,1,2,1,1,void
4648,381978,timeCommand,1,timeCommand,void timeCommand (client*),server.c,"void timeCommand(client *c) {
    addReplyArrayLen(c,2);
    addReplyBulkLongLong(c, server.unixtime);
    addReplyBulkLongLong(c, server.ustime-((long long)server.unixtime)*1000000);
}",4537.0,4541.0,1.0,1.0,5.0,6,4,6,2,0,9,1,1,0,3,,0,6,2,1,1,void
4649,382008,addReplyCommandFlags,1,addReplyCommandFlags,"void addReplyCommandFlags (client*,uint64_t,replyFlagNames*)",server.c,"void addReplyCommandFlags(client *c, uint64_t flags, replyFlagNames *replyFlags) {
    int count = 0, j=0;
    /* Count them so we don't have to use deferred reply. */
    while (replyFlags[j].name) {
        if (flags & replyFlags[j].flag)
            count++;
        j++;
    }

    addReplySetLen(c, count);
    j = 0;
    while (replyFlags[j].name) {
        if (flags & replyFlags[j].flag)
            addReplyStatus(c, replyFlags[j].name);
        j++;
    }
}",4549.0,4565.0,1.0,1.0,17.0,18,5,21,5,4,2,5,7,0,2,,0,0,6,3,3,void
4650,382074,addReplyFlagsForCommand,1,addReplyFlagsForCommand,"void addReplyFlagsForCommand (client*,redisCommand*)",server.c,"void addReplyFlagsForCommand(client *c, struct redisCommand *cmd) {
    replyFlagNames flagNames[] = {
        {CMD_WRITE,             ""write""},
        {CMD_READONLY,          ""readonly""},
        {CMD_DENYOOM,           ""denyoom""},
        {CMD_MODULE,            ""module""},
        {CMD_ADMIN,             ""admin""},
        {CMD_PUBSUB,            ""pubsub""},
        {CMD_NOSCRIPT,          ""noscript""},
        {CMD_BLOCKING,          ""blocking""},
        {CMD_LOADING,           ""loading""},
        {CMD_STALE,             ""stale""},
        {CMD_SKIP_MONITOR,      ""skip_monitor""},
        {CMD_SKIP_SLOWLOG,      ""skip_slowlog""},
        {CMD_ASKING,            ""asking""},
        {CMD_FAST,              ""fast""},
        {CMD_NO_AUTH,           ""no_auth""},
        /* {CMD_MAY_REPLICATE,     ""may_replicate""},, Hidden on purpose */
        /* {CMD_SENTINEL,          ""sentinel""}, Hidden on purpose */
        /* {CMD_ONLY_SENTINEL,     ""only_sentinel""}, Hidden on purpose */
        {CMD_NO...",4567.0,4597.0,1.0,9.0,31.0,44,4,5,4,0,2,1,1,0,1,,0,1,4,2,2,void
4651,382233,addReplyDocFlagsForCommand,1,addReplyDocFlagsForCommand,"void addReplyDocFlagsForCommand (client*,redisCommand*)",server.c,"void addReplyDocFlagsForCommand(client *c, struct redisCommand *cmd) {
    replyFlagNames docFlagNames[] = {
        {CMD_DOC_DEPRECATED,         ""deprecated""},
        {CMD_DOC_SYSCMD,             ""syscmd""},
        {0,NULL}
    };
    addReplyCommandFlags(c, cmd->doc_flags, docFlagNames);
}",4599.0,4606.0,1.0,9.0,8.0,8,4,5,4,1,2,1,1,0,1,,0,1,4,2,2,void
4652,382266,addReplyFlagsForKeyArgs,1,addReplyFlagsForKeyArgs,"void addReplyFlagsForKeyArgs (client*,uint64_t)",server.c,"void addReplyFlagsForKeyArgs(client *c, uint64_t flags) {
    replyFlagNames docFlagNames[] = {
        {CMD_KEY_RO,              ""RO""},
        {CMD_KEY_RW,              ""RW""},
        {CMD_KEY_OW,              ""OW""},
        {CMD_KEY_RM,              ""RM""},
        {CMD_KEY_ACCESS,          ""access""},
        {CMD_KEY_UPDATE,          ""update""},
        {CMD_KEY_INSERT,          ""insert""},
        {CMD_KEY_DELETE,          ""delete""},
        {CMD_KEY_NOT_KEY,         ""not_key""},
        {CMD_KEY_INCOMPLETE,      ""incomplete""},
        {CMD_KEY_VARIABLE_FLAGS,  ""variable_flags""},
        {0,NULL}
    };
    addReplyCommandFlags(c, flags, docFlagNames);
}",4608.0,4624.0,1.0,9.0,17.0,25,3,5,4,1,1,1,1,0,1,,0,0,4,2,2,void
4653,382373,addReplyFlagsForArg,1,addReplyFlagsForArg,"void addReplyFlagsForArg (client*,uint64_t)",server.c,"void addReplyFlagsForArg(client *c, uint64_t flags) {
    replyFlagNames argFlagNames[] = {
        {CMD_ARG_OPTIONAL,          ""optional""},
        {CMD_ARG_MULTIPLE,          ""multiple""},
        {CMD_ARG_MULTIPLE_TOKEN,    ""multiple_token""},
        {0,NULL}
    };
    addReplyCommandFlags(c, flags, argFlagNames);
}",4639.0,4647.0,1.0,9.0,9.0,9,3,5,4,1,1,1,1,0,1,,0,0,4,2,2,void
4654,382411,addReplyCommandArgList,1,addReplyCommandArgList,"void addReplyCommandArgList (client*,redisCommandArg*,int)",server.c,"void addReplyCommandArgList(client *c, struct redisCommandArg *args, int num_args) {
    addReplyArrayLen(c, num_args);
    for (int j = 0; j<num_args; j++) {
        /* Count our reply len so we don't have to use deferred reply. */
        int has_display_text = 1;
        long maplen = 2;
        if (args[j].key_spec_index != -1) maplen++;
        if (args[j].token) maplen++;
        if (args[j].summary) maplen++;
        if (args[j].since) maplen++;
        if (args[j].deprecated_since) maplen++;
        if (args[j].flags) maplen++;
        if (args[j].type == ARG_TYPE_ONEOF || args[j].type == ARG_TYPE_BLOCK) {
            has_display_text = 0;
            maplen++;
        }
        if (has_display_text) maplen++;
        addReplyMapLen(c, maplen);

        addReplyBulkCString(c, ""name"");
        addReplyBulkCString(c, args[j].name);

        addReplyBulkCString(c, ""type"");
        addReplyBulkCString(c, ARG_TYPE_STR[args[j].type]);

        if (has_display_text) {
            a...",4649.0,4707.0,1.0,1.0,59.0,83,10,103,9,1,22,18,34,0,21,,0,1,6,3,3,void
4655,382711,addReplyCommandHistory,1,addReplyCommandHistory,"void addReplyCommandHistory (client*,redisCommand*)",server.c,"void addReplyCommandHistory(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->num_history);
    for (int j = 0; j<cmd->num_history; j++) {
        addReplyArrayLen(c, 2);
        addReplyBulkCString(c, cmd->history[j].since);
        addReplyBulkCString(c, cmd->history[j].changes);
    }
}",4745.0,4752.0,1.0,1.0,8.0,10,5,12,3,1,8,2,2,1,4,,0,4,4,2,2,void
4656,382757,addReplyCommandTips,1,addReplyCommandTips,"void addReplyCommandTips (client*,redisCommand*)",server.c,"void addReplyCommandTips(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->num_tips);
    for (int j = 0; j<cmd->num_tips; j++) {
        addReplyBulkCString(c, cmd->tips[j]);
    }
}",4754.0,4759.0,1.0,1.0,6.0,6,4,8,3,0,5,2,2,1,2,,0,3,4,2,2,void
4657,382789,addReplyCommandKeySpecs,1,addReplyCommandKeySpecs,"void addReplyCommandKeySpecs (client*,redisCommand*)",server.c,"void addReplyCommandKeySpecs(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->key_specs_num);
    for (int i = 0; i < cmd->key_specs_num; i++) {
        int maplen = 3;
        if (cmd->key_specs[i].notes) maplen++;

        addReplyMapLen(c, maplen);

        if (cmd->key_specs[i].notes) {
            addReplyBulkCString(c, ""notes"");
            addReplyBulkCString(c,cmd->key_specs[i].notes);
        }

        addReplyBulkCString(c, ""flags"");
        addReplyFlagsForKeyArgs(c,cmd->key_specs[i].flags);

        addReplyBulkCString(c, ""begin_search"");
        switch (cmd->key_specs[i].begin_search_type) {
            case KSPEC_BS_UNKNOWN:
                addReplyMapLen(c, 2);
                addReplyBulkCString(c, ""type"");
                addReplyBulkCString(c, ""unknown"");

                addReplyBulkCString(c, ""spec"");
                addReplyMapLen(c, 0);
                break;
            case KSPEC_BS_INDEX:
                addReplyMapLen(c, 2);
              ...",4761.0,4855.0,1.0,16.0,95.0,77,7,103,10,0,77,12,10,5,58,,0,19,4,2,2,void
4658,383173,addReplyCommandSubCommands,1,addReplyCommandSubCommands,"void addReplyCommandSubCommands (client*,redisCommand*,void,int)",server.c,"void addReplyCommandSubCommands(client *c, struct redisCommand *cmd, void (*reply_function)(client*, struct redisCommand*), int use_map) {
    if (!cmd->subcommands_dict) {
        addReplySetLen(c, 0);
        return;
    }

    if (use_map)
        addReplyMapLen(c, dictSize(cmd->subcommands_dict));
    else
        addReplyArrayLen(c, dictSize(cmd->subcommands_dict));
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);
    while((de = dictNext(di)) != NULL) {
        struct redisCommand *sub = (struct redisCommand *)dictGetVal(de);
        if (use_map)
            addReplyBulkCBuffer(c, sub->fullname, sdslen(sub->fullname));
        reply_function(c, sub);
    }
    dictReleaseIterator(di);
}",4858.0,4877.0,1.0,26.0,20.0,18,7,21,7,1,15,5,6,2,8,,0,11,8,4,4,void
4659,383280,addReplyCommandInfo,1,addReplyCommandInfo,"void addReplyCommandInfo (client*,redisCommand*)",server.c,"void addReplyCommandInfo(client *c, struct redisCommand *cmd) {
    if (!cmd) {
        addReplyNull(c);
    } else {
        int firstkey = 0, lastkey = 0, keystep = 0;
        if (cmd->legacy_range_key_spec.begin_search_type != KSPEC_BS_INVALID) {
            firstkey = cmd->legacy_range_key_spec.bs.index.pos;
            lastkey = cmd->legacy_range_key_spec.fk.range.lastkey;
            if (lastkey >= 0)
                lastkey += firstkey;
            keystep = cmd->legacy_range_key_spec.fk.range.keystep;
        }

        addReplyArrayLen(c, 10);
        addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
        addReplyLongLong(c, cmd->arity);
        addReplyFlagsForCommand(c, cmd);
        addReplyLongLong(c, firstkey);
        addReplyLongLong(c, lastkey);
        addReplyLongLong(c, keystep);
        addReplyCommandCategories(c, cmd);
        addReplyCommandTips(c, cmd);
        addReplyCommandKeySpecs(c, cmd);
        addReplyCommandSubCommands(c, cmd, addRepl...",4880.0,4905.0,1.0,1.0,26.0,1,1,2,2,2,1,2,2,0,1,,0,0,4,2,2,void
4660,383399,addReplyCommandDocs,1,addReplyCommandDocs,"void addReplyCommandDocs (client*,redisCommand*)",server.c,"void addReplyCommandDocs(client *c, struct redisCommand *cmd) {
    /* Count our reply len so we don't have to use deferred reply. */
    long maplen = 1;
    if (cmd->summary) maplen++;
    if (cmd->since) maplen++;
    if (cmd->flags & CMD_MODULE) maplen++;
    if (cmd->complexity) maplen++;
    if (cmd->doc_flags) maplen++;
    if (cmd->deprecated_since) maplen++;
    if (cmd->replaced_by) maplen++;
    if (cmd->history) maplen++;
#ifdef LOG_REQ_RES
    if (cmd->reply_schema) maplen++;
#endif
    if (cmd->args) maplen++;
    if (cmd->subcommands_dict) maplen++;
    addReplyMapLen(c, maplen);

    if (cmd->summary) {
        addReplyBulkCString(c, ""summary"");
        addReplyBulkCString(c, cmd->summary);
    }
    if (cmd->since) {
        addReplyBulkCString(c, ""since"");
        addReplyBulkCString(c, cmd->since);
    }

    /* Always have the group, for module commands the group is always ""module"". */
    addReplyBulkCString(c, ""group"");
    addReplyBulkCString(c, commandGroupSt...",4908.0,4977.0,1.0,21.0,70.0,43,5,67,3,1,53,21,21,20,25,,0,30,4,2,2,void
4661,383631,getKeysSubcommandImpl,1,getKeysSubcommandImpl,"void getKeysSubcommandImpl (client*,int)",server.c,"void getKeysSubcommandImpl(client *c, int with_flags) {
    struct redisCommand *cmd = lookupCommand(c->argv+2,c->argc-2);
    getKeysResult result = GETKEYS_RESULT_INIT;
    int j;

    if (!cmd) {
        addReplyError(c,""Invalid command specified"");
        return;
    } else if (!doesCommandHaveKeys(cmd)) {
        addReplyError(c,""The command has no key arguments"");
        return;
    } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||
               ((c->argc-2) < -cmd->arity))
    {
        addReplyError(c,""Invalid number of arguments specified for command"");
        return;
    }

    if (!getKeysFromCommandWithSpecs(cmd,c->argv+2,c->argc-2,GET_KEYSPEC_DEFAULT,&result)) {
        if (cmd->flags & CMD_NO_MANDATORY_KEYS) {
            addReplyArrayLen(c,0);
        } else {
            addReplyError(c,""Invalid arguments specified for command"");
        }
    } else {
        addReplyArrayLen(c,result.numkeys);
        for (j = 0; j < result.numkeys; j++) {
            i...",4980.0,5017.0,1.0,27.0,38.0,20,9,14,4,2,10,4,5,4,5,,0,7,4,2,2,void
4662,383825,commandGetKeysAndFlagsCommand,1,commandGetKeysAndFlagsCommand,void commandGetKeysAndFlagsCommand (client*),server.c,"void commandGetKeysAndFlagsCommand(client *c) {
    getKeysSubcommandImpl(c, 1);
}",5020.0,5022.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
4663,383833,getKeysSubcommand,1,getKeysSubcommand,void getKeysSubcommand (client*),server.c,"void getKeysSubcommand(client *c) {
    getKeysSubcommandImpl(c, 0);
}",5025.0,5027.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
4664,383841,commandCommand,1,commandCommand,void commandCommand (client*),server.c,"void commandCommand(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c, dictSize(server.commands));
    di = dictGetIterator(server.commands);
    while ((de = dictNext(di)) != NULL) {
        addReplyCommandInfo(c, dictGetVal(de));
    }
    dictReleaseIterator(di);
}",5030.0,5040.0,1.0,24.0,11.0,12,6,12,5,0,14,2,2,1,6,,0,11,2,1,1,void
4665,383890,commandCountCommand,1,commandCountCommand,void commandCountCommand (client*),server.c,"void commandCountCommand(client *c) {
    addReplyLongLong(c, dictSize(server.commands));
}",5043.0,5045.0,1.0,24.0,3.0,8,4,4,2,0,7,1,1,0,1,,0,6,2,1,1,void
4666,383933,shouldFilterFromCommandList,1,shouldFilterFromCommandList,"int shouldFilterFromCommandList (redisCommand*,commandListFilter*)",server.c,"int shouldFilterFromCommandList(struct redisCommand *cmd, commandListFilter *filter) {
    switch (filter->type) {
        case (COMMAND_LIST_FILTER_MODULE):
            if (!filter->cache.valid) {
                filter->cache.u.module_handle = moduleGetHandleByName(filter->arg);
                filter->cache.valid = 1;
            }
            return !moduleIsModuleCommand(filter->cache.u.module_handle, cmd);
        case (COMMAND_LIST_FILTER_ACLCAT): {
            if (!filter->cache.valid) {
                filter->cache.u.aclcat = ACLGetCommandCategoryFlagByName(filter->arg);
                filter->cache.valid = 1;
            }
            uint64_t cat = filter->cache.u.aclcat;
            if (cat == 0)
                return 1; /* Invalid ACL category */
            return (!(cmd->acl_categories & cat));
            break;
        }
        case (COMMAND_LIST_FILTER_PATTERN):
            return !stringmatchlen(filter->arg, sdslen(filter->arg), cmd->fullname, sdslen(cmd->full...",5065.0,5089.0,1.0,12.0,25.0,42,7,24,6,1,16,6,8,1,7,,0,13,4,2,2,int
4667,384071,commandListWithFilter,1,commandListWithFilter,"void commandListWithFilter (client*,dict*,commandListFilter,int*)",server.c,"void commandListWithFilter(client *c, dict *commands, commandListFilter filter, int *numcmds) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (!shouldFilterFromCommandList(cmd,&filter)) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            (*numcmds)++;
        }

        if (cmd->subcommands_dict) {
            commandListWithFilter(c, cmd->subcommands_dict, filter, numcmds);
        }
    }
    dictReleaseIterator(di);
}",5092.0,5108.0,1.0,1.0,17.0,12,7,19,8,1,11,4,6,3,7,,0,9,8,4,4,void
4668,384131,commandListWithoutFilter,1,commandListWithoutFilter,"void commandListWithoutFilter (client*,dict*,int*)",server.c,"void commandListWithoutFilter(client *c, dict *commands, int *numcmds) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
        (*numcmds)++;

        if (cmd->subcommands_dict) {
            commandListWithoutFilter(c, cmd->subcommands_dict, numcmds);
        }
    }
    dictReleaseIterator(di);
}",5111.0,5125.0,1.0,1.0,15.0,10,5,16,7,0,10,3,4,2,6,,0,8,6,3,3,void
4669,384182,commandListCommand,1,commandListCommand,void commandListCommand (client*),server.c,"void commandListCommand(client *c) {

    /* Parse options. */
    int i = 2, got_filter = 0;
    commandListFilter filter = {0};
    for (; i < c->argc; i++) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (!strcasecmp(opt,""filterby"") && moreargs == 2) {
            char *filtertype = c->argv[i+1]->ptr;
            if (!strcasecmp(filtertype,""module"")) {
                filter.type = COMMAND_LIST_FILTER_MODULE;
            } else if (!strcasecmp(filtertype,""aclcat"")) {
                filter.type = COMMAND_LIST_FILTER_ACLCAT;
            } else if (!strcasecmp(filtertype,""pattern"")) {
                filter.type = COMMAND_LIST_FILTER_PATTERN;
            } else {
                addReplyErrorObject(c,shared.syntaxerr);
                return;
            }
            got_filter = 1;
            filter.arg = c->argv[i+2]->ptr;
            i += 2;
        } else {
            addReplyErrorObject(c,shared...",5128.0,5167.0,1.0,1.0,40.0,37,13,35,11,0,12,5,8,1,3,,0,10,2,1,1,void
4670,384357,commandInfoCommand,1,commandInfoCommand,void commandInfoCommand (client*),server.c,"void commandInfoCommand(client *c) {
    int i;

    if (c->argc == 2) {
        dictIterator *di;
        dictEntry *de;
        addReplyArrayLen(c, dictSize(server.commands));
        di = dictGetIterator(server.commands);
        while ((de = dictNext(di)) != NULL) {
            addReplyCommandInfo(c, dictGetVal(de));
        }
        dictReleaseIterator(di);
    } else {
        addReplyArrayLen(c, c->argc-2);
        for (i = 2; i < c->argc; i++) {
            addReplyCommandInfo(c, lookupCommandBySds(c->argv[i]->ptr));
        }
    }
}",5170.0,5188.0,1.0,28.0,19.0,14,7,13,5,0,15,3,4,2,6,,0,12,2,1,1,void
4671,384446,commandDocsCommand,1,commandDocsCommand,void commandDocsCommand (client*),server.c,"void commandDocsCommand(client *c) {
    int i;
    if (c->argc == 2) {
        /* Reply with an array of all commands */
        dictIterator *di;
        dictEntry *de;
        addReplyMapLen(c, dictSize(server.commands));
        di = dictGetIterator(server.commands);
        while ((de = dictNext(di)) != NULL) {
            struct redisCommand *cmd = dictGetVal(de);
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            addReplyCommandDocs(c, cmd);
        }
        dictReleaseIterator(di);
    } else {
        /* Reply with an array of the requested commands (if we find them) */
        int numcmds = 0;
        void *replylen = addReplyDeferredLen(c);
        for (i = 2; i < c->argc; i++) {
            struct redisCommand *cmd = lookupCommandBySds(c->argv[i]->ptr);
            if (!cmd)
                continue;
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            addReplyCommandDocs(c, cmd);
            numcmds++;...",5191.0,5219.0,1.0,26.0,29.0,17,7,18,6,0,19,3,4,2,8,,0,15,2,1,1,void
4672,384574,commandGetKeysCommand,1,commandGetKeysCommand,void commandGetKeysCommand (client*),server.c,"void commandGetKeysCommand(client *c) {
    getKeysSubcommand(c);
}",5222.0,5224.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
4673,384581,commandHelpCommand,1,commandHelpCommand,void commandHelpCommand (client*),server.c,"void commandHelpCommand(client *c) {
    const char *help[] = {
""(no subcommand)"",
""    Return details about all Redis commands."",
""COUNT"",
""    Return the total number of commands in this Redis server."",
""LIST"",
""    Return a list of all commands in this Redis server."",
""INFO [<command-name> ...]"",
""    Return details about multiple Redis commands."",
""    If no command names are given, documentation details for all"",
""    commands are returned."",
""DOCS [<command-name> ...]"",
""    Return documentation details about multiple Redis commands."",
""    If no command names are given, documentation details for all"",
""    commands are returned."",
""GETKEYS <full-command>"",
""    Return the keys from a full Redis command."",
""GETKEYSANDFLAGS <full-command>"",
""    Return the keys and the access flags from a full Redis command."",
NULL
    };

    addReplyHelp(c, help);
}",5227.0,5251.0,1.0,1.0,25.0,2,2,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
4674,384782,fillPercentileDistributionLatencies,1,fillPercentileDistributionLatencies,"sds fillPercentileDistributionLatencies (sds,char*,hdr_histogram*)",server.c,"sds fillPercentileDistributionLatencies(sds info, const char* histogram_name, struct hdr_histogram* histogram) {
    info = sdscatfmt(info,""latency_percentiles_usec_%s:"",histogram_name);
    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        char fbuf[128];
        size_t len = snprintf(fbuf, sizeof(fbuf), ""%f"", server.latency_tracking_info_percentiles[j]);
        trimDoubleString(fbuf, len);
        info = sdscatprintf(info,""p%s=%.3f"", fbuf,
            ((double)hdr_value_at_percentile(histogram,server.latency_tracking_info_percentiles[j]))/1000.0f);
        if (j != server.latency_tracking_info_percentiles_len-1)
            info = sdscatlen(info,"","",1);
        }
    info = sdscatprintf(info,""\r\n"");
    return info;
}",5283.0,5296.0,1.0,1.0,14.0,18,9,26,7,1,13,3,4,4,5,,0,12,6,3,3,sds
4675,384906,getSafeInfoString,1,getSafeInfoString,"const char* getSafeInfoString (char*,size_t,char**)",server.c,"const char *getSafeInfoString(const char *s, size_t len, char **tmp) {
    *tmp = NULL;
    if (mempbrk(s, len, unsafe_info_chars,sizeof(unsafe_info_chars)-1)
        == NULL) return s;
    char *new = *tmp = zmalloc(len + 1);
    memcpy(new, s, len);
    new[len] = '\0';
    return memmapchars(new, len, unsafe_info_chars, unsafe_info_chars_substs,
                       sizeof(unsafe_info_chars)-1);
}",5320.0,5329.0,1.0,1.0,10.0,13,7,21,7,5,8,2,2,3,3,,0,7,6,3,3,const char*
4676,384960,genRedisInfoStringCommandStats,1,genRedisInfoStringCommandStats,"sds genRedisInfoStringCommandStats (sds,dict*)",server.c,"sds genRedisInfoStringCommandStats(sds info, dict *commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;
    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        char *tmpsafe;
        c = (struct redisCommand *) dictGetVal(de);
        if (c->calls || c->failed_calls || c->rejected_calls) {
            info = sdscatprintf(info,
                ""cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f""
                "",rejected_calls=%lld,failed_calls=%lld\r\n"",
                getSafeInfoString(c->fullname, sdslen(c->fullname), &tmpsafe), c->calls, c->microseconds,
                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls),
                c->rejected_calls, c->failed_calls);
            if (tmpsafe != NULL) zfree(tmpsafe);
        }
        if (c->subcommands_dict) {
            info = genRedisInfoStringCommandStats(info, c->subcommands_dict);
        }
    }
    dictReleaseIterator(di);

    return info;
}",5331.0,5355.0,1.0,1.0,25.0,29,9,31,7,1,22,5,9,5,8,,0,20,4,2,2,sds
4677,385067,genRedisInfoStringACLStats,1,genRedisInfoStringACLStats,sds genRedisInfoStringACLStats (sds),server.c,"sds genRedisInfoStringACLStats(sds info) {
    info = sdscatprintf(info,
         ""acl_access_denied_auth:%lld\r\n""
         ""acl_access_denied_cmd:%lld\r\n""
         ""acl_access_denied_key:%lld\r\n""
         ""acl_access_denied_channel:%lld\r\n"",
         server.acl_info.user_auth_failures,
         server.acl_info.invalid_cmd_accesses,
         server.acl_info.invalid_key_accesses,
         server.acl_info.invalid_channel_accesses);
    return info;
}",5358.0,5369.0,1.0,1.0,12.0,9,2,7,2,1,9,1,1,0,1,,0,9,2,1,1,sds
4678,385099,genRedisInfoStringLatencyStats,1,genRedisInfoStringLatencyStats,"sds genRedisInfoStringLatencyStats (sds,dict*)",server.c,"sds genRedisInfoStringLatencyStats(sds info, dict *commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;
    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        char *tmpsafe;
        c = (struct redisCommand *) dictGetVal(de);
        if (c->latency_histogram) {
            info = fillPercentileDistributionLatencies(info,
                getSafeInfoString(c->fullname, sdslen(c->fullname), &tmpsafe),
                c->latency_histogram);
            if (tmpsafe != NULL) zfree(tmpsafe);
        }
        if (c->subcommands_dict) {
            info = genRedisInfoStringLatencyStats(info, c->subcommands_dict);
        }
    }
    dictReleaseIterator(di);

    return info;
}",5371.0,5392.0,1.0,1.0,22.0,15,5,23,7,1,14,5,9,3,8,,0,12,4,2,2,sds
4679,385206,releaseInfoSectionDict,1,releaseInfoSectionDict,void releaseInfoSectionDict (dict*),server.c,"void releaseInfoSectionDict(dict *sec) {
    if (sec != cached_default_info_sections)
        dictRelease(sec);
}",5407.0,5410.0,1.0,1.0,4.0,1,1,3,2,5,2,2,2,1,1,,0,1,2,1,1,void
4680,385218,genInfoSectionDict,1,genInfoSectionDict,"dict genInfoSectionDict (robj**,int,char**,int*,int*)",server.c,"dict *genInfoSectionDict(robj **argv, int argc, char **defaults, int *out_all, int *out_everything) {
    char *default_sections[] = {
        ""server"", ""clients"", ""memory"", ""persistence"", ""stats"", ""replication"",
        ""cpu"", ""module_list"", ""errorstats"", ""cluster"", ""keyspace"", NULL};
    if (!defaults)
        defaults = default_sections;

    if (argc == 0) {
        /* In this case we know the dict is not gonna be modified, so we cache
         * it as an optimization for a common case. */
        if (cached_default_info_sections)
            return cached_default_info_sections;
        cached_default_info_sections = dictCreate(&stringSetDictType);
        dictExpand(cached_default_info_sections, 16);
        addInfoSectionsToDict(cached_default_info_sections, defaults);
        return cached_default_info_sections;
    }

    dict *section_dict = dictCreate(&stringSetDictType);
    dictExpand(section_dict, min(argc,16));
    for (int i = 0; i < argc; i++) {
        if (!strcasec...",5417.0,5452.0,1.0,29.0,36.0,16,9,28,9,4,14,6,8,1,6,,0,10,10,5,5,dict
4681,385386,genRedisInfoString,1,genRedisInfoString,"sds genRedisInfoString (dict*,int,int)",server.c,"sds genRedisInfoString(dict *section_dict, int all_sections, int everything) {
    sds info = sdsempty();
    time_t uptime = server.unixtime-server.stat_starttime;
    int j;
    int sections = 0;
    if (everything) all_sections = 1;

    /* Server */
    if (all_sections || (dictFind(section_dict,""server"") != NULL)) {
        static int call_uname = 1;
        static struct utsname name;
        char *mode;
        char *supervised;

        if (server.cluster_enabled) mode = ""cluster"";
        else if (server.sentinel_mode) mode = ""sentinel"";
        else mode = ""standalone"";

        if (server.supervised) {
            if (server.supervised_mode == SUPERVISED_UPSTART) supervised = ""upstart"";
            else if (server.supervised_mode == SUPERVISED_SYSTEMD) supervised = ""systemd"";
            else supervised = ""unknown"";
        } else {
            supervised = ""no"";
        }

        if (sections++) info = sdscat(info,""\r\n"");

        if (call_uname) {
            /* Uname...",5457.0,6261.0,1.0,42.0,805.0,663,21,613,73,4,592,61,121,64,125,,0,576,6,3,3,sds
4682,387730,infoCommand,1,infoCommand,void infoCommand (client*),server.c,"void infoCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelInfoCommand(c);
        return;
    }
    int all_sections = 0;
    int everything = 0;
    dict *sections_dict = genInfoSectionDict(c->argv+1, c->argc-1, NULL, &all_sections, &everything);
    sds info = genRedisInfoString(sections_dict, all_sections, everything);
    addReplyVerbatim(c,info,sdslen(info),""txt"");
    sdsfree(info);
    releaseInfoSectionDict(sections_dict);
    return;
}",6264.0,6277.0,1.0,1.0,14.0,11,6,19,7,0,11,2,2,2,7,,0,7,2,1,1,void
4683,387788,monitorCommand,1,monitorCommand,void monitorCommand (client*),server.c,"void monitorCommand(client *c) {
    if (c->flags & CLIENT_DENY_BLOCKING) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expects a reply per command and so can't execute MONITOR. */
        addReplyError(c, ""MONITOR isn't allowed for DENY BLOCKING client"");
        return;
    }

    /* ignore MONITOR if already slave or in monitor mode */
    if (c->flags & CLIENT_SLAVE) return;

    c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
    listAddNodeTail(server.monitors,c);
    addReply(c,shared.ok);
}",6279.0,6294.0,1.0,19.0,16.0,12,5,8,3,0,10,3,3,2,3,,0,7,2,1,1,void
4684,387845,checkIgnoreWarning,1,checkIgnoreWarning,int checkIgnoreWarning (char*),server.c,"int checkIgnoreWarning(const char *warning) {
    int argc, j;
    sds *argv = sdssplitargs(server.ignore_warnings, &argc);
    if (argv == NULL)
        return 0;

    for (j = 0; j < argc; j++) {
        char *flag = argv[j];
        if (!strcasecmp(flag, warning))
            break;
    }
    sdsfreesplitres(argv,argc);
    return j < argc;
}",6298.0,6311.0,1.0,1.0,14.0,10,7,17,7,0,4,5,5,0,2,,0,3,2,1,1,int
4685,387899,createPidFile,1,createPidFile,void createPidFile (void),server.c,"void createPidFile(void) {
    /* If pidfile requested, but no pidfile defined, use
     * default pidfile path */
    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);

    /* Try to write the pid file in a best-effort way. */
    FILE *fp = fopen(server.pidfile,""w"");
    if (fp) {
        fprintf(fp,""%d\n"",(int)getpid());
        fclose(fp);
    } else {
        serverLog(LL_WARNING, ""Failed to write PID file: %s"", strerror(errno));
    }
}",6348.0,6361.0,1.0,50.0,14.0,7,4,7,2,0,7,3,3,2,1,,0,7,2,1,1,void
4686,388000,version,1,version,void version (void),server.c,"void version(void) {
    printf(""Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n"",
        REDIS_VERSION,
        redisGitSHA1(),
        atoi(redisGitDirty()) > 0,
        ZMALLOC_LIB,
        sizeof(long) == 4 ? 32 : 64,
        (unsigned long long) redisBuildId());
    exit(0);
}",6380.0,6389.0,1.0,8.0,10.0,5,5,1,1,0,3,1,1,0,3,,0,0,2,1,1,void
4687,388088,redisAsciiArt,1,redisAsciiArt,void redisAsciiArt (void),server.c,"void redisAsciiArt(void) {
#include ""asciilogo.h""
    char *buf = zmalloc(1024*16);
    char *mode;

    if (server.cluster_enabled) mode = ""cluster"";
    else if (server.sentinel_mode) mode = ""sentinel"";
    else mode = ""standalone"";

    /* Show the ASCII logo if: log file is stdout AND stdout is a
     * tty AND syslog logging is disabled. Also show logo if the user
     * forced us to do so via redis.conf. */
    int show_logo = ((!server.syslog_enabled &&
                      server.logfile[0] == '\0' &&
                      isatty(fileno(stdout))) ||
                     server.always_show_logo);

    if (!show_logo) {
        serverLog(LL_NOTICE,
            ""Running mode=%s, port=%d."",
            mode, server.port ? server.port : server.tls_port
        );
    } else {
        snprintf(buf,1024*16,ascii_logo,
            REDIS_VERSION,
            redisGitSHA1(),
            strtol(redisGitDirty(),NULL,10) > 0,
            (sizeof(long) == 8) ? ""64"" : ""32"",
            mo...",6412.0,6446.0,1.0,27.0,35.0,23,11,16,6,0,19,3,3,2,3,,0,17,2,1,1,void
4688,388236,listenerByType,1,listenerByType,connListener listenerByType (char*),server.c,"connListener *listenerByType(const char *typename) {
    int conn_index;

    conn_index = connectionIndexByType(typename);
    if (conn_index < 0)
        return NULL;

    return &server.listeners[conn_index];
}",6449.0,6457.0,1.0,1.0,9.0,5,5,6,4,4,3,2,2,0,1,,0,3,2,1,1,connListener
4689,388260,changeListener,1,changeListener,int changeListener (connListener*),server.c,"int changeListener(connListener *listener) {
    /* Close old servers */
    closeListener(listener);

    /* Just close the server if port disabled */
    if (listener->port == 0) {
        if (server.set_proc_title) redisSetProcTitle(NULL);
        return C_OK;
    }

    /* Re-create listener */
    if (connListen(listener) != C_OK) {
        return C_ERR;
    }

    /* Create event handlers */
    if (createSocketAcceptHandler(listener, listener->ct->accept_handler) != C_OK) {
        serverPanic(""Unrecoverable error creating %s accept handler."", listener->ct->get_type(NULL));
    }

    if (server.set_proc_title) redisSetProcTitle(NULL);

    return C_OK;
}",6460.0,6483.0,1.0,15.0,24.0,12,6,11,3,4,13,6,7,8,6,,0,9,2,1,1,int
4690,388337,sigShutdownHandler,1,sigShutdownHandler,void sigShutdownHandler (int),server.c,"static void sigShutdownHandler(int sig) {
    char *msg;

    switch (sig) {
    case SIGINT:
        msg = ""Received SIGINT scheduling shutdown..."";
        break;
    case SIGTERM:
        msg = ""Received SIGTERM scheduling shutdown..."";
        break;
    default:
        msg = ""Received shutdown signal, scheduling shutdown..."";
    };

    /* SIGINT is often delivered via Ctrl+C in an interactive session.
     * If we receive the signal the second time, we interpret this as
     * the user really wanting to quit ASAP without waiting to persist
     * on disk and without waiting for lagging replicas. */
    if (server.shutdown_asap && sig == SIGINT) {
        serverLogFromHandler(LL_WARNING, ""You insist... exiting now."");
        rdbRemoveTempFile(getpid(), 1);
        exit(1); /* Exit with an error since this was not a clean shutdown. */
    } else if (server.loading) {
        msg = ""Received shutdown signal during loading, scheduling shutdown."";
    }

    serverLogFromHandler...",6485.0,6514.0,1.0,29.0,30.0,10,4,13,5,0,9,5,3,2,3,,0,6,2,1,1,void
4691,388406,setupSignalHandlers,1,setupSignalHandlers,void setupSignalHandlers (void),server.c,"void setupSignalHandlers(void) {
    struct sigaction act;

    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
     * Otherwise, sa_handler is used. */
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = sigShutdownHandler;
    sigaction(SIGTERM, &act, NULL);
    sigaction(SIGINT, &act, NULL);

    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = sigsegvHandler;
    if(server.crashlog_enabled) {
        sigaction(SIGSEGV, &act, NULL);
        sigaction(SIGBUS, &act, NULL);
        sigaction(SIGFPE, &act, NULL);
        sigaction(SIGILL, &act, NULL);
        sigaction(SIGABRT, &act, NULL);
    }
    return;
}",6516.0,6538.0,1.0,1.0,23.0,22,4,32,14,2,2,2,2,2,0,,0,2,2,1,1,void
4692,388487,removeSignalHandlers,1,removeSignalHandlers,void removeSignalHandlers (void),server.c,"void removeSignalHandlers(void) {
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND;
    act.sa_handler = SIG_DFL;
    sigaction(SIGSEGV, &act, NULL);
    sigaction(SIGBUS, &act, NULL);
    sigaction(SIGFPE, &act, NULL);
    sigaction(SIGILL, &act, NULL);
    sigaction(SIGABRT, &act, NULL);
}",6540.0,6550.0,1.0,1.0,11.0,12,4,21,10,2,0,1,1,0,0,,0,0,2,1,1,void
4693,388535,sigKillChildHandler,1,sigKillChildHandler,void sigKillChildHandler (int),server.c,"static void sigKillChildHandler(int sig) {
    UNUSED(sig);
    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;
    serverLogFromHandler(level, ""Received SIGUSR1 in child, exiting now."");
    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);
}",6556.0,6561.0,1.0,4.0,6.0,5,5,5,3,0,4,1,1,0,2,,0,2,2,1,1,void
4694,388570,setupChildSignalHandlers,1,setupChildSignalHandlers,void setupChildSignalHandlers (void),server.c,"void setupChildSignalHandlers(void) {
    struct sigaction act;

    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
     * Otherwise, sa_handler is used. */
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = sigKillChildHandler;
    sigaction(SIGUSR1, &act, NULL);
}",6563.0,6572.0,1.0,1.0,10.0,7,3,6,3,1,0,1,1,0,0,,0,0,2,1,1,void
4695,388596,closeChildUnusedResourceAfterFork,1,closeChildUnusedResourceAfterFork,void closeChildUnusedResourceAfterFork (void),server.c,"void closeChildUnusedResourceAfterFork(void) {
    closeListeningSockets(0);
    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1)
        close(server.cluster_config_file_lock_fd);  /* don't care if this fails */

    /* Clear server.pidfile, this is the parent pidfile which should not
     * be touched (or deleted) by the child (on exit / crash) */
    zfree(server.pidfile);
    server.pidfile = NULL;
}",6578.0,6587.0,1.0,1.0,10.0,9,5,6,2,1,12,2,2,4,2,,0,10,2,1,1,void
4696,388628,redisFork,1,redisFork,int redisFork (int),server.c,"int redisFork(int purpose) {
    if (isMutuallyExclusiveChildType(purpose)) {
        if (hasActiveChildProcess()) {
            errno = EEXIST;
            return -1;
        }

        openChildInfoPipe();
    }

    int childpid;
    long long start = ustime();
    if ((childpid = fork()) == 0) {
        /* Child.
         *
         * The order of setting things up follows some reasoning:
         * Setup signal handlers first because a signal could fire at any time.
         * Adjust OOM score before everything else to assist the OOM killer if
         * memory resources are low.
         */
        server.in_fork_child = purpose;
        setupChildSignalHandlers();
        setOOMScoreAdj(CONFIG_OOM_BGCHILD);
        updateDictResizePolicy();
        dismissMemoryInChild();
        closeChildUnusedResourceAfterFork();
        /* Close the reading part, so that if the parent crashes, the child will
         * get a write error and exit. */
        if (server.child_info_pipe[0] !...",6590.0,6658.0,1.0,23.0,69.0,13,6,10,6,5,15,5,7,4,9,,0,9,2,1,1,int
4697,388821,sendChildCowInfo,1,sendChildCowInfo,"void sendChildCowInfo (childInfoType,char*)",server.c,"void sendChildCowInfo(childInfoType info_type, char *pname) {
    sendChildInfoGeneric(info_type, 0, -1, pname);
}",6660.0,6662.0,1.0,1.0,3.0,1,1,2,2,4,1,1,1,0,1,,0,0,4,2,2,void
4698,388833,sendChildInfo,1,sendChildInfo,"void sendChildInfo (childInfoType,size_t,char*)",server.c,"void sendChildInfo(childInfoType info_type, size_t keys, char *pname) {
    sendChildInfoGeneric(info_type, keys, -1, pname);
}",6664.0,6666.0,1.0,1.0,3.0,1,1,3,3,2,1,1,1,0,1,,0,0,6,3,3,void
4699,388846,dismissMemory,1,dismissMemory,"void dismissMemory (void*,size_t)",server.c,"void dismissMemory(void* ptr, size_t size_hint) {
    if (ptr == NULL) return;

    /* madvise(MADV_DONTNEED) can not release pages if the size of memory
     * is too small, we try to release only for the memory which the size
     * is more than half of page size. */
    if (size_hint && size_hint <= server.page_size/2) return;

    zmadvise_dontneed(ptr);
}",6677.0,6686.0,1.0,1.0,10.0,5,5,6,4,12,3,3,3,2,1,,0,2,4,2,2,void
4700,388872,dismissClientMemory,1,dismissClientMemory,void dismissClientMemory (client*),server.c,"void dismissClientMemory(client *c) {
    /* Dismiss client query buffer and static reply buffer. */
    dismissMemory(c->buf, c->buf_usable_size);
    dismissSds(c->querybuf);
    /* Dismiss argv array only if we estimate it contains a big buffer. */
    if (c->argc && c->argv_len_sum/c->argc >= server.page_size) {
        for (int i = 0; i < c->argc; i++) {
            dismissObject(c->argv[i], 0);
        }
    }
    if (c->argc) dismissMemory(c->argv, c->argc*sizeof(robj*));

    /* Dismiss the reply array only if the average buffer size is bigger
     * than a page. */
    if (listLength(c->reply) &&
        c->reply_bytes/listLength(c->reply) >= server.page_size)
    {
        listIter li;
        listNode *ln;
        listRewind(c->reply, &li);
        while ((ln = listNext(&li))) {
            clientReplyBlock *bulk = listNodeValue(ln);
            /* Default bulk size is 16k, actually it has extra data, maybe it
             * occupies 20k according to jemalloc bin size if ...",6689.0,6716.0,1.0,8.0,28.0,38,11,32,7,0,30,7,11,15,7,,0,24,2,1,1,void
4701,389004,dismissMemoryInChild,1,dismissMemoryInChild,void dismissMemoryInChild (void),server.c,"void dismissMemoryInChild(void) {
    /* madvise(MADV_DONTNEED) may not work if Transparent Huge Pages is enabled. */
    if (server.thp_enabled) return;

    /* Currently we use zmadvise_dontneed only when we use jemalloc with Linux.
     * so we avoid these pointless loops when they're not going to do anything. */
#if defined(USE_JEMALLOC) && defined(__linux__)
    listIter li;
    listNode *ln;

    /* Dismiss replication buffer. We don't need to separately dismiss replication
     * backlog and replica' output buffer, because they just reference the global
     * replication buffer but don't cost real memory. */
    listRewind(server.repl_buffer_blocks, &li);
    while((ln = listNext(&li))) {
        replBufBlock *o = listNodeValue(ln);
        dismissMemory(o, o->size);
    }

    /* Dismiss all clients memory. */
    listRewind(server.clients, &li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        dismissClientMemory(c);
    }
#endif
}",6722.0,6748.0,1.0,1.0,27.0,1,1,1,1,1,2,2,2,2,0,,0,2,2,1,1,void
4702,389060,loadDataFromDisk,1,loadDataFromDisk,void loadDataFromDisk (void),server.c,"void loadDataFromDisk(void) {
    long long start = ustime();
    if (server.aof_state == AOF_ON) {
        int ret = loadAppendOnlyFiles(server.aof_manifest);
        if (ret == AOF_FAILED || ret == AOF_OPEN_ERR)
            exit(1);
        if (ret != AOF_NOT_EXIST)
            serverLog(LL_NOTICE, ""DB loaded from append only file: %.3f seconds"", (float)(ustime()-start)/1000000);
    } else {
        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
        int rsi_is_valid = 0;
        errno = 0; /* Prevent a stale value from affecting error checking */
        int rdb_flags = RDBFLAGS_NONE;
        if (iAmMaster()) {
            /* Master may delete expired keys when loading, we should
             * propagate expire to replication backlog. */
            createReplicationBacklog();
            rdb_flags |= RDBFLAGS_FEED_REPL;
        }
        int rdb_load_ret = rdbLoad(server.rdb_filename, &rsi, rdb_flags);
        if (rdb_load_ret == RDB_OK) {
            serverLog(LL_NOTICE,""DB loaded f...",6763.0,6832.0,1.0,28.0,70.0,15,10,9,3,0,10,4,6,2,4,,0,9,2,1,1,void
4703,389375,redisOutOfMemoryHandler,1,redisOutOfMemoryHandler,void redisOutOfMemoryHandler (size_t),server.c,"void redisOutOfMemoryHandler(size_t allocation_size) {
    serverLog(LL_WARNING,""Out Of Memory allocating %zu bytes!"",
        allocation_size);
    serverPanic(""Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"",
        allocation_size);
}",6834.0,6839.0,1.0,4.0,6.0,4,4,3,2,0,4,1,1,0,2,,0,2,2,1,1,void
4704,389408,redisProcTitleGetVariable,1,redisProcTitleGetVariable,"sds redisProcTitleGetVariable (sds,void*)",server.c,"static sds redisProcTitleGetVariable(const sds varname, void *arg)
{
    if (!strcmp(varname, ""title"")) {
        return sdsnew(arg);
    } else if (!strcmp(varname, ""listen-addr"")) {
        if (server.port || server.tls_port)
            return sdscatprintf(sdsempty(), ""%s:%u"",
                                server.bindaddr_count ? server.bindaddr[0] : ""*"",
                                server.port ? server.port : server.tls_port);
        else
            return sdscatprintf(sdsempty(), ""unixsocket:%s"", server.unixsocket);
    } else if (!strcmp(varname, ""server-mode"")) {
        if (server.cluster_enabled) return sdsnew(""[cluster]"");
        else if (server.sentinel_mode) return sdsnew(""[sentinel]"");
        else return sdsempty();
    } else if (!strcmp(varname, ""config-file"")) {
        return sdsnew(server.configfile ? server.configfile : ""-"");
    } else if (!strcmp(varname, ""port"")) {
        return sdscatprintf(sdsempty(), ""%u"", server.port);
    } else if (!strcmp(varn...",6844.0,6869.0,1.0,1.0,26.0,1,1,2,2,0,1,2,2,0,1,,0,0,4,2,2,sds
4705,389568,expandProcTitleTemplate,1,expandProcTitleTemplate,"sds expandProcTitleTemplate (char*,char*)",server.c,"static sds expandProcTitleTemplate(const char *template, const char *title) {
    sds res = sdstemplate(template, redisProcTitleGetVariable, (void *) title);
    if (!res)
        return NULL;
    return sdstrim(res, "" "");
}",6873.0,6878.0,1.0,1.0,6.0,3,3,6,4,1,2,2,2,0,2,,0,1,4,2,2,sds
4706,389593,validateProcTitleTemplate,1,validateProcTitleTemplate,int validateProcTitleTemplate (char*),server.c,"int validateProcTitleTemplate(const char *template) {
    int ok = 1;
    sds res = expandProcTitleTemplate(template, """");
    if (!res)
        return 0;
    if (sdslen(res) == 0) ok = 0;
    sdsfree(res);
    return ok;
}",6880.0,6888.0,1.0,1.0,9.0,5,3,8,3,1,3,3,3,1,3,,0,2,2,1,1,int
4707,389627,redisSetProcTitle,1,redisSetProcTitle,int redisSetProcTitle (char*),server.c,"int redisSetProcTitle(char *title) {
#ifdef USE_SETPROCTITLE
    if (!title) title = server.exec_argv[0];
    sds proc_title = expandProcTitleTemplate(server.proc_title_template, title);
    if (!proc_title) return C_ERR;  /* Not likely, proc_title_template is validated */

    setproctitle(""%s"", proc_title);
    sdsfree(proc_title);
#else
    UNUSED(title);
#endif

    return C_OK;
}",6890.0,6903.0,1.0,4.0,14.0,1,1,2,1,7,0,1,1,0,0,,0,0,2,1,1,int
4708,389642,redisSetCpuAffinity,1,redisSetCpuAffinity,void redisSetCpuAffinity (char*),server.c,"void redisSetCpuAffinity(const char *cpulist) {
#ifdef USE_SETCPUAFFINITY
    setcpuaffinity(cpulist);
#else
    UNUSED(cpulist);
#endif
}",6905.0,6911.0,1.0,4.0,7.0,1,1,2,1,4,0,1,1,0,0,,0,0,2,1,1,void
4709,389653,redisCommunicateSystemd,1,redisCommunicateSystemd,int redisCommunicateSystemd (char*),server.c,"int redisCommunicateSystemd(const char *sd_notify_msg) {
#ifdef HAVE_LIBSYSTEMD
    int ret = sd_notify(0, sd_notify_msg);

    if (ret == 0)
        serverLog(LL_WARNING, ""systemd supervision error: NOTIFY_SOCKET not found!"");
    else if (ret < 0)
        serverLog(LL_WARNING, ""systemd supervision error: sd_notify: %d"", ret);
    return ret;
#else
    UNUSED(sd_notify_msg);
    return 0;
#endif
}",6915.0,6928.0,1.0,4.0,14.0,1,1,2,1,3,0,1,1,0,0,,0,0,2,1,1,int
4710,389666,redisSupervisedUpstart,1,redisSupervisedUpstart,int redisSupervisedUpstart (void),server.c,"static int redisSupervisedUpstart(void) {
    const char *upstart_job = getenv(""UPSTART_JOB"");

    if (!upstart_job) {
        serverLog(LL_WARNING,
                ""upstart supervision requested, but UPSTART_JOB not found!"");
        return 0;
    }

    serverLog(LL_NOTICE, ""supervised by upstart, will stop to signal readiness."");
    raise(SIGSTOP);
    unsetenv(""UPSTART_JOB"");
    return 1;
}",6931.0,6944.0,1.0,8.0,14.0,8,5,5,3,1,6,2,2,0,2,,0,4,2,1,1,int
4711,389724,redisSupervisedSystemd,1,redisSupervisedSystemd,int redisSupervisedSystemd (void),server.c,"static int redisSupervisedSystemd(void) {
#ifndef HAVE_LIBSYSTEMD
    serverLog(LL_WARNING,
            ""systemd supervision requested or auto-detected, but Redis is compiled without libsystemd support!"");
    return 0;
#else
    if (redisCommunicateSystemd(""STATUS=Redis is loading...\n"") <= 0)
        return 0;
    serverLog(LL_NOTICE,
        ""Supervised by systemd. Please make sure you set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit."");
    return 1;
#endif
}",6947.0,6959.0,1.0,4.0,13.0,3,3,1,1,1,3,1,1,0,1,,0,2,2,1,1,int
4712,389749,redisIsSupervised,1,redisIsSupervised,int redisIsSupervised (int),server.c,"int redisIsSupervised(int mode) {
    int ret = 0;

    if (mode == SUPERVISED_AUTODETECT) {
        if (getenv(""UPSTART_JOB"")) {
            serverLog(LL_VERBOSE, ""Upstart supervision detected."");
            mode = SUPERVISED_UPSTART;
        } else if (getenv(""NOTIFY_SOCKET"")) {
            serverLog(LL_VERBOSE, ""Systemd supervision detected."");
            mode = SUPERVISED_SYSTEMD;
        }
    }

    switch (mode) {
        case SUPERVISED_UPSTART:
            ret = redisSupervisedUpstart();
            break;
        case SUPERVISED_SYSTEMD:
            ret = redisSupervisedSystemd();
            break;
        default:
            break;
    }

    if (ret)
        server.supervised_mode = mode;

    return ret;
}",6961.0,6989.0,1.0,16.0,29.0,10,5,11,3,0,7,8,6,0,3,,0,6,2,1,1,int
4713,389852,iAmMaster,1,iAmMaster,int iAmMaster (void),server.c,"int iAmMaster(void) {
    return ((!server.cluster_enabled && server.masterhost == NULL) ||
            (server.cluster_enabled && nodeIsMaster(server.cluster->myself)));
}",6991.0,6994.0,1.0,39.0,4.0,14,7,6,2,2,10,1,1,0,0,,0,10,2,1,1,int
4714,392769,getRandomHexChars,1,getRandomHexChars,"void getRandomHexChars (char*,size_t)",util.c,"void getRandomHexChars(char *p, size_t len) {
    char *charset = ""0123456789abcdef"";
    size_t j;

    getRandomBytes((unsigned char*)p,len);
    for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];
}",928.0,934.0,1.0,1.0,7.0,0,0,0,0,7,0,1,1,0,0,,0,0,4,2,2,void
4715,392775,getRandomBytes,1,getRandomBytes,"void getRandomBytes (unsigned char*,size_t)",util.c,"void getRandomBytes(unsigned char *p, size_t len) {
    /* Global state. */
    static int seed_initialized = 0;
    static unsigned char seed[64]; /* 512 bit internal block size. */
    static uint64_t counter = 0; /* The counter we hash with the seed. */

    if (!seed_initialized) {
        /* Initialize a seed and use SHA1 in counter mode, where we hash
         * the same seed with a progressive counter. For the goals of this
         * function we just need non-colliding strings, there are no
         * cryptographic security needs. */
        FILE *fp = fopen(""/dev/urandom"",""r"");
        if (fp == NULL || fread(seed,sizeof(seed),1,fp) != 1) {
            /* Revert to a weaker seed, and in this case reseed again
             * at every call.*/
            for (unsigned int j = 0; j < sizeof(seed); j++) {
                struct timeval tv;
                gettimeofday(&tv,NULL);
                pid_t pid = getpid();
                seed[j] = tv.tv_sec ^ tv.tv_usec ^ pid ^ (long...",860.0,922.0,1.0,29.0,63.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4716,393179,addListRangeReply,1,addListRangeReply,"void addListRangeReply (client*,robj*,long,long,int)",t_list.c,"void addListRangeReply(client *c, robj *o, long start, long end, int reverse) {
    long rangelen, llen = listTypeLength(o);

    /* Convert negative indexes. */
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;

    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        addReply(c,shared.emptyarray);
        return;
    }
    if (end >= llen) end = llen-1;
    rangelen = (end-start)+1;

    int from = reverse ? end : start;
    if (o->encoding == OBJ_ENCODING_QUICKLIST)
        addListQuicklistRangeReply(c, o, from, rangelen, reverse);
    else if (o->encoding == OBJ_ENCODING_LISTPACK)
        addListListpackRangeReply(c, o, from, rangelen, reverse);
    else
        serverPanic(""Unknown list encoding"");
}",727.0,751.0,1.0,23.0,25.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
4717,393508,disableTracking,1,disableTracking,void disableTracking (client*),tracking.c,"void disableTracking(client *c) {
    /* If this client is in broadcasting mode, we need to unsubscribe it
     * from all the prefixes it is registered to. */
    if (c->flags & CLIENT_TRACKING_BCAST) {
        raxIterator ri;
        raxStart(&ri,c->client_tracking_prefixes);
        raxSeek(&ri,""^"",NULL,0);
        while(raxNext(&ri)) {
            bcastState *bs = raxFind(PrefixTable,ri.key,ri.key_len);
            serverAssert(bs != raxNotFound);
            raxRemove(bs->clients,(unsigned char*)&c,sizeof(c),NULL);
            /* Was it the last client? Remove the prefix from the
             * table. */
            if (raxSize(bs->clients) == 0) {
                raxFree(bs->clients);
                raxFree(bs->keys);
                zfree(bs);
                raxRemove(PrefixTable,ri.key,ri.key_len,NULL);
            }
        }
        raxStop(&ri);
        raxFree(c->client_tracking_prefixes);
        c->client_tracking_prefixes = NULL;
    }

    /* Clear flags and adjust...",67.0,100.0,1.0,19.0,34.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
4718,393519,trackingInvalidateKey,1,trackingInvalidateKey,"void trackingInvalidateKey (client*,robj*,int)",tracking.c,"void trackingInvalidateKey(client *c, robj *keyobj, int bcast) {
    if (TrackingTable == NULL) return;

    unsigned char *key = (unsigned char*)keyobj->ptr;
    size_t keylen = sdslen(keyobj->ptr);

    if (bcast && raxSize(PrefixTable) > 0)
        trackingRememberKeyToBroadcast(c,(char *)key,keylen);

    rax *ids = raxFind(TrackingTable,key,keylen);
    if (ids == raxNotFound) return;

    raxIterator ri;
    raxStart(&ri,ids);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        uint64_t id;
        memcpy(&id,ri.key,sizeof(id));
        client *target = lookupClientByID(id);
        /* Note that if the client is in BCAST mode, we don't want to
         * send invalidation messages that were pending in the case
         * previously the client was not in BCAST mode. This can happen if
         * TRACKING is enabled normally, and then the client switches to
         * BCAST mode. */
        if (target == NULL ||
            !(target->flags & CLIENT_TRACKING)||
       ...",366.0,422.0,1.0,30.0,57.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4719,393532,trackingHandlePendingKeyInvalidations,1,trackingHandlePendingKeyInvalidations,void trackingHandlePendingKeyInvalidations (void),tracking.c,"void trackingHandlePendingKeyInvalidations(void) {
    if (!listLength(server.tracking_pending_keys)) return;

    /* Flush pending invalidation messages only when we are not in nested call.
     * So the messages are not interleaved with transaction response. */
    if (server.execution_nesting) return;

    listNode *ln;
    listIter li;

    listRewind(server.tracking_pending_keys,&li);
    while ((ln = listNext(&li)) != NULL) {
        robj *key = listNodeValue(ln);
        /* current_client maybe freed, so we need to send invalidation
         * message only when current_client is still alive */
        if (server.current_client != NULL) {
            if (key != NULL) {
                sendTrackingMessage(server.current_client,(char *)key->ptr,sdslen(key->ptr),0);
            } else {
                sendTrackingMessage(server.current_client,shared.null[server.current_client->resp]->ptr,
                    sdslen(shared.null[server.current_client->resp]->ptr),1);
            }...",424.0,450.0,1.0,9.0,27.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
4720,393537,trackingInvalidateKeysOnFlush,1,trackingInvalidateKeysOnFlush,void trackingInvalidateKeysOnFlush (int),tracking.c,"void trackingInvalidateKeysOnFlush(int async) {
    if (server.tracking_clients) {
        listNode *ln;
        listIter li;
        listRewind(server.clients,&li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = listNodeValue(ln);
            if (c->flags & CLIENT_TRACKING) {
                if (c == server.current_client) {
                    /* We use a special NULL to indicate that we should send null */
                    listAddNodeTail(server.tracking_pending_keys,NULL);
                } else {
                    sendTrackingMessage(c,shared.null[c->resp]->ptr,sdslen(shared.null[c->resp]->ptr),1);
                }
            }
        }
    }

    /* In case of FLUSHALL, reclaim all the memory used by tracking. */
    if (TrackingTable) {
        if (async) {
            freeTrackingRadixTreeAsync(TrackingTable);
        } else {
            freeTrackingRadixTree(TrackingTable);
        }
        TrackingTable = raxNew();
        TrackingTableTot...",468.0,496.0,1.0,24.0,29.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
4721,393542,freeTrackingRadixTree,1,freeTrackingRadixTree,void freeTrackingRadixTree (rax*),tracking.c,"void freeTrackingRadixTree(rax *rt) {
    raxFreeWithCallback(rt,freeTrackingRadixTreeCallback);
}",463.0,465.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4722,393552,trackingLimitUsedSlots,1,trackingLimitUsedSlots,void trackingLimitUsedSlots (void),tracking.c,"void trackingLimitUsedSlots(void) {
    static unsigned int timeout_counter = 0;
    if (TrackingTable == NULL) return;
    if (server.tracking_table_max_keys == 0) return; /* No limits set. */
    size_t max_keys = server.tracking_table_max_keys;
    if (raxSize(TrackingTable) <= max_keys) {
        timeout_counter = 0;
        return; /* Limit not reached. */
    }

    /* We have to invalidate a few keys to reach the limit again. The effort
     * we do here is proportional to the number of times we entered this
     * function and found that we are still over the limit. */
    int effort = 100 * (timeout_counter+1);

    /* We just remove one key after another by using a random walk. */
    raxIterator ri;
    raxStart(&ri,TrackingTable);
    while(effort > 0) {
        effort--;
        raxSeek(&ri,""^"",NULL,0);
        raxRandomWalk(&ri,0);
        if (raxEOF(&ri)) break;
        robj *keyobj = createStringObject((char*)ri.key,ri.key_len);
        trackingInvalidateKey(NULL,key...",508.0,545.0,1.0,1.0,38.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
4723,393557,trackingGetTotalItems,1,trackingGetTotalItems,uint64_t trackingGetTotalItems (void),tracking.c,"uint64_t trackingGetTotalItems(void) {
    return TrackingTableTotalItems;
}",648.0,650.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
4724,393562,trackingGetTotalKeys,1,trackingGetTotalKeys,uint64_t trackingGetTotalKeys (void),tracking.c,"uint64_t trackingGetTotalKeys(void) {
    if (TrackingTable == NULL) return 0;
    return raxSize(TrackingTable);
}",652.0,655.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
4725,393567,trackingGetTotalPrefixes,1,trackingGetTotalPrefixes,uint64_t trackingGetTotalPrefixes (void),tracking.c,"uint64_t trackingGetTotalPrefixes(void) {
    if (PrefixTable == NULL) return 0;
    return raxSize(PrefixTable);
}",657.0,660.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
4726,393572,trackingBroadcastInvalidationMessages,1,trackingBroadcastInvalidationMessages,void trackingBroadcastInvalidationMessages (void),tracking.c,"void trackingBroadcastInvalidationMessages(void) {
    raxIterator ri, ri2;

    /* Return ASAP if there is nothing to do here. */
    if (TrackingTable == NULL || !server.tracking_clients) return;

    raxStart(&ri,PrefixTable);
    raxSeek(&ri,""^"",NULL,0);

    /* For each prefix... */
    while(raxNext(&ri)) {
        bcastState *bs = ri.data;

        if (raxSize(bs->keys)) {
            /* Generate the common protocol for all the clients that are
             * not using the NOLOOP option. */
            sds proto = trackingBuildBroadcastReply(NULL,bs->keys);

            /* Send this array of keys to every client in the list. */
            raxStart(&ri2,bs->clients);
            raxSeek(&ri2,""^"",NULL,0);
            while(raxNext(&ri2)) {
                client *c;
                memcpy(&c,ri2.key,sizeof(c));
                if (c->flags & CLIENT_TRACKING_NOLOOP) {
                    /* This client may have certain keys excluded. */
                    sds adhoc = trackingB...",598.0,644.0,1.0,31.0,47.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4727,393584,listTypePush,1,listTypePush,"void listTypePush (robj*,robj*,int)",t_list.c,"void listTypePush(robj *subject, robj *value, int where) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;
        if (value->encoding == OBJ_ENCODING_INT) {
            char buf[32];
            ll2string(buf, 32, (long)value->ptr);
            quicklistPush(subject->ptr, buf, strlen(buf), pos);
        } else {
            quicklistPush(subject->ptr, value->ptr, sdslen(value->ptr), pos);
        }
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        if (value->encoding == OBJ_ENCODING_INT) {
            subject->ptr = (where == LIST_HEAD) ?
                lpPrependInteger(subject->ptr, (long)value->ptr) :
                lpAppendInteger(subject->ptr, (long)value->ptr);
        } else {
            subject->ptr = (where == LIST_HEAD) ?
                lpPrepend(subject->ptr, value->ptr, sdslen(value->ptr)) :
                lpAppend(subject->ptr, value->ptr, sdslen(value->ptr));
      ...",166.0,189.0,1.0,29.0,24.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
4728,393591,listTypePop,1,listTypePop,"robj* listTypePop (robj*,int)",t_list.c,"robj *listTypePop(robj *subject, int where) {
    robj *value = NULL;

    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        long long vlong;
        int ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;
        if (quicklistPopCustom(subject->ptr, ql_where, (unsigned char **)&value,
                               NULL, &vlong, listPopSaver)) {
            if (!value)
                value = createStringObjectFromLongLong(vlong);
        }
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p;
        unsigned char *vstr;
        int64_t vlen;
        unsigned char intbuf[LP_INTBUF_SIZE];

        p = (where == LIST_HEAD) ? lpFirst(subject->ptr) : lpLast(subject->ptr);
        if (p) {
            vstr = lpGet(p, &vlen, intbuf);
            value = createStringObject((char*)vstr, vlen);
            subject->ptr = lpDelete(subject->ptr, p, NULL);
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
    retu...",195.0,222.0,1.0,29.0,28.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,robj
4729,393597,listTypeLength,1,listTypeLength,long unsigned listTypeLength (robj*),t_list.c,"unsigned long listTypeLength(const robj *subject) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistCount(subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        return lpLength(subject->ptr);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",224.0,232.0,1.0,29.0,9.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,unsigned long
4730,393602,listTypeInitIterator,1,listTypeInitIterator,"listTypeIterator* listTypeInitIterator (robj*,long,unsigned char)",t_list.c,"listTypeIterator *listTypeInitIterator(robj *subject, long index,
                                       unsigned char direction) {
    listTypeIterator *li = zmalloc(sizeof(listTypeIterator));
    li->subject = subject;
    li->encoding = subject->encoding;
    li->direction = direction;
    li->iter = NULL;
    /* LIST_HEAD means start at TAIL and move *towards* head.
     * LIST_TAIL means start at HEAD and move *towards* tail. */
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        int iter_direction = direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
        li->iter = quicklistGetIteratorAtIdx(li->subject->ptr,
                                             iter_direction, index);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        li->lpi = lpSeek(subject->ptr, index);
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return li;
}",235.0,254.0,1.0,24.0,20.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,listTypeIterator
4731,393609,listTypeReleaseIterator,1,listTypeReleaseIterator,void listTypeReleaseIterator (listTypeIterator*),t_list.c,"void listTypeReleaseIterator(listTypeIterator *li) {
    if (li->encoding == OBJ_ENCODING_QUICKLIST)
        quicklistReleaseIterator(li->iter);
    zfree(li);
}",275.0,279.0,1.0,24.0,5.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
4732,393614,listTypeSetIteratorDirection,1,listTypeSetIteratorDirection,"void listTypeSetIteratorDirection (listTypeIterator*,listTypeEntry*,unsigned char)",t_list.c,"void listTypeSetIteratorDirection(listTypeIterator *li, listTypeEntry *entry, unsigned char direction) {
    if (li->direction == direction) return;

    li->direction = direction;
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        int dir = direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
        quicklistSetDirection(li->iter, dir);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = li->subject->ptr;
        /* Note that the iterator for listpack always points to the next of the current entry,
         * so we need to update position of the iterator depending on the direction. */
        li->lpi = (direction == LIST_TAIL) ? lpNext(lp, entry->lpe) : lpPrev(lp, entry->lpe);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",257.0,272.0,1.0,24.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4733,393621,listTypeNext,1,listTypeNext,"int listTypeNext (listTypeIterator*,listTypeEntry*)",t_list.c,"int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {
    /* Protect from converting when iterating */
    serverAssert(li->subject->encoding == li->encoding);

    entry->li = li;
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistNext(li->iter, &entry->entry);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        entry->lpe = li->lpi;
        if (entry->lpe != NULL) {
            li->lpi = (li->direction == LIST_TAIL) ?
                lpNext(li->subject->ptr,li->lpi) : lpPrev(li->subject->ptr,li->lpi);
            return 1;
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return 0;
}",284.0,302.0,1.0,4.0,19.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int
4734,393627,listTypeGet,1,listTypeGet,robj* listTypeGet (listTypeEntry*),t_list.c,"robj *listTypeGet(listTypeEntry *entry) {
    unsigned char *vstr;
    size_t vlen;
    long long lval;

    vstr = listTypeGetValue(entry, &vlen, &lval);
    if (vstr) 
        return createStringObject((char *)vstr, vlen);
    else
        return createStringObjectFromLongLong(lval);
}",328.0,338.0,1.0,1.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,robj
4735,393632,listTypeGetValue,1,listTypeGetValue,"unsigned char* listTypeGetValue (listTypeEntry*,size_t*,long long*)",t_list.c,"unsigned char *listTypeGetValue(listTypeEntry *entry, size_t *vlen, long long *lval) {
    unsigned char *vstr = NULL;
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        if (entry->entry.value) {
            vstr = entry->entry.value;
            *vlen = entry->entry.sz;
        } else {
            *lval = entry->entry.longval;
        }
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned int slen;
        vstr = lpGetValue(entry->lpe, &slen, lval);
        *vlen = slen;
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return vstr;
}",308.0,325.0,1.0,31.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,unsigned char*
4736,393639,listTypeInsert,1,listTypeInsert,"void listTypeInsert (listTypeEntry*,robj*,int)",t_list.c,"void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
    robj *subject = entry->li->subject;
    value = getDecodedObject(value);
    sds str = value->ptr;
    size_t len = sdslen(str);

    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        if (where == LIST_TAIL) {
            quicklistInsertAfter(entry->li->iter, &entry->entry, str, len);
        } else if (where == LIST_HEAD) {
            quicklistInsertBefore(entry->li->iter, &entry->entry, str, len);
        }
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        int lpw = (where == LIST_TAIL) ? LP_AFTER : LP_BEFORE;
        subject->ptr = lpInsertString(subject->ptr, (unsigned char *)str,
                                      len, entry->lpe, lpw, &entry->lpe);
    } else {
        serverPanic(""Unknown list encoding"");
    }
    decrRefCount(value);
}",340.0,360.0,1.0,31.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4737,393646,listTypeReplace,1,listTypeReplace,"void listTypeReplace (listTypeEntry*,robj*)",t_list.c,"void listTypeReplace(listTypeEntry *entry, robj *value) {
    robj *subject = entry->li->subject;
    value = getDecodedObject(value);
    sds str = value->ptr;
    size_t len = sdslen(str);

    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistReplaceEntry(entry->li->iter, &entry->entry, str, len);
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        subject->ptr = lpReplace(subject->ptr, &entry->lpe, (unsigned char *)str, len);
    } else {
        serverPanic(""Unknown list encoding"");
    }

    decrRefCount(value);
}",363.0,378.0,1.0,31.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4738,393658,listTypeDelete,1,listTypeDelete,"void listTypeDelete (listTypeIterator*,listTypeEntry*)",t_list.c,"void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistDelEntry(iter->iter, &entry->entry);
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p = entry->lpe;
        iter->subject->ptr = lpDelete(iter->subject->ptr,p,&p);

        /* Update position of the iterator depending on the direction */
        if (iter->direction == LIST_TAIL)
            iter->lpi = p;
        else {
            if (p) {
                iter->lpi = lpPrev(iter->subject->ptr,p);
            } else {
                /* We deleted the last element, so we need to set the
                 * iterator to the last element. */
                iter->lpi = lpLast(iter->subject->ptr);
            }
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",420.0,442.0,1.0,31.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4739,393664,listTypeDup,1,listTypeDup,robj* listTypeDup (robj*),t_list.c,"robj *listTypeDup(robj *o) {
    robj *lobj;

    serverAssert(o->type == OBJ_LIST);

    switch (o->encoding) {
        case OBJ_ENCODING_LISTPACK:
            lobj = createObject(OBJ_LIST, lpDup(o->ptr));
            break;
        case OBJ_ENCODING_QUICKLIST:
            lobj = createObject(OBJ_LIST, quicklistDup(o->ptr));
            break;
        default:
            serverPanic(""Unknown list encoding"");
            break;
    }
    lobj->encoding = o->encoding;
    return lobj;
}",449.0,467.0,1.0,4.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
4740,393669,listTypeDelRange,1,listTypeDelRange,"void listTypeDelRange (robj*,long,long)",t_list.c,"void listTypeDelRange(robj *subject, long start, long count) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistDelRange(subject->ptr, start, count);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        subject->ptr = lpDeleteRange(subject->ptr, start, count);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",470.0,478.0,1.0,29.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4741,393682,listElementsRemoved,1,listElementsRemoved,"void listElementsRemoved (client*,robj*,int,robj*,long,int,int*)",t_list.c,"void listElementsRemoved(client *c, robj *key, int where, robj *o, long count, int signal, int *deleted) {
    char *event = (where == LIST_HEAD) ? ""lpop"" : ""rpop"";

    notifyKeyspaceEvent(NOTIFY_LIST, event, key, c->db->id);
    if (listTypeLength(o) == 0) {
        if (deleted) *deleted = 1;

        dbDelete(c->db, key);
        notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", key, c->db->id);
    } else {
        listTypeTryConversion(o, LIST_CONV_SHRINKING, NULL, NULL);
        if (deleted) *deleted = 0;
    }
    if (signal) signalModifiedKey(c, c->db, key);
    server.dirty += count;
}",759.0,774.0,1.0,28.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,14,7,7,void
4742,393703,listTypeTryConversion,1,listTypeTryConversion,"void listTypeTryConversion (robj*,list_conv_type,beforeConvertCB,void*)",t_list.c,"void listTypeTryConversion(robj *o, list_conv_type lct, beforeConvertCB fn, void *data) {
    listTypeTryConversionRaw(o, lct, NULL, 0, 0, fn, data);
}",149.0,151.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
4743,393711,listTypeTryConversionAppend,1,listTypeTryConversionAppend,"void listTypeTryConversionAppend (robj*,robj**,int,int,beforeConvertCB,void*)",t_list.c,"void listTypeTryConversionAppend(robj *o, robj **argv, int start, int end,
                                 beforeConvertCB fn, void *data)
{
    listTypeTryConversionRaw(o, LIST_CONV_GROWING, argv, start, end, fn, data);
}",155.0,159.0,1.0,1.0,5.0,0,0,0,0,5,0,1,1,0,0,,0,0,12,6,6,void
4744,394099,syncWrite,1,syncWrite,"ssize_t syncWrite (int,char*,ssize_t,long long)",syncio.c,"ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nwritten, ret = size;
    long long start = mstime();
    long long remaining = timeout;

    while(1) {
        long long wait = (remaining > SYNCIO__RESOLUTION) ?
                          remaining : SYNCIO__RESOLUTION;
        long long elapsed;

        /* Optimistically try to write before checking if the file descriptor
         * is actually writable. At worst we get EAGAIN. */
        nwritten = write(fd,ptr,size);
        if (nwritten == -1) {
            if (errno != EAGAIN) return -1;
        } else {
            ptr += nwritten;
            size -= nwritten;
        }
        if (size == 0) return ret;

        /* Wait */
        aeWait(fd,AE_WRITABLE,wait);
        elapsed = mstime() - start;
        if (elapsed >= timeout) {
            errno = ETIMEDOUT;
            return -1;
        }
        remaining = timeout - elapsed;
    }
}",49.0,79.0,1.0,38.0,31.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,ssize_t
4745,394107,syncRead,1,syncRead,"ssize_t syncRead (int,char*,ssize_t,long long)",syncio.c,"ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nread, totread = 0;
    long long start = mstime();
    long long remaining = timeout;

    if (size == 0) return 0;
    while(1) {
        long long wait = (remaining > SYNCIO__RESOLUTION) ?
                          remaining : SYNCIO__RESOLUTION;
        long long elapsed;

        /* Optimistically try to read before checking if the file descriptor
         * is actually readable. At worst we get EAGAIN. */
        nread = read(fd,ptr,size);
        if (nread == 0) return -1; /* short read. */
        if (nread == -1) {
            if (errno != EAGAIN) return -1;
        } else {
            ptr += nread;
            size -= nread;
            totread += nread;
        }
        if (size == 0) return totread;

        /* Wait */
        aeWait(fd,AE_READABLE,wait);
        elapsed = mstime() - start;
        if (elapsed >= timeout) {
            errno = ETIMEDOUT;
            return -1;
        }
...",85.0,118.0,1.0,38.0,34.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,ssize_t
4746,394115,syncReadLine,1,syncReadLine,"ssize_t syncReadLine (int,char*,ssize_t,long long)",syncio.c,"ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nread = 0;

    size--;
    while(size) {
        char c;

        if (syncRead(fd,&c,1,timeout) == -1) return -1;
        if (c == '\n') {
            *ptr = '\0';
            if (nread && *(ptr-1) == '\r') *(ptr-1) = '\0';
            return nread;
        } else {
            *ptr++ = c;
            *ptr = '\0';
            nread++;
        }
        size--;
    }
    return nread;
}",125.0,145.0,1.0,1.0,21.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,ssize_t
4747,394759,zslCreate,1,zslCreate,zskiplist* zslCreate (void),t_zset.c,"zskiplist *zslCreate(void) {
    int j;
    zskiplist *zsl;

    zsl = zmalloc(sizeof(*zsl));
    zsl->level = 1;
    zsl->length = 0;
    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {
        zsl->header->level[j].forward = NULL;
        zsl->header->level[j].span = 0;
    }
    zsl->header->backward = NULL;
    zsl->tail = NULL;
    return zsl;
}",82.0,97.0,1.0,32.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,zskiplist
4748,394764,zslFree,1,zslFree,void zslFree (zskiplist*),t_zset.c,"void zslFree(zskiplist *zsl) {
    zskiplistNode *node = zsl->header->level[0].forward, *next;

    zfree(zsl->header);
    while(node) {
        next = node->level[0].forward;
        zslFreeNode(node);
        node = next;
    }
    zfree(zsl);
}",108.0,118.0,1.0,1.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4749,394769,zslInsert,1,zslInsert,"zskiplistNode* zslInsert (zskiplist*,double,sds)",t_zset.c,"zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    /* we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside o...",135.0,190.0,1.0,26.0,56.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,zskiplistNode
4750,394783,zslDelete,1,zslDelete,"int zslDelete (zskiplist*,double,sds,zskiplistNode**)",t_zset.c,"int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                     sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    /* We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object. */
    x = x->level[0].forward;
    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }
    return 0; /* not found */
}",222.0,249.0,1.0,26.0,28.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
4751,394803,zzlGetScore,1,zzlGetScore,double zzlGetScore (unsigned char*),t_zset.c,"double zzlGetScore(unsigned char *sptr) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    double score;

    serverAssert(sptr != NULL);
    vstr = lpGetValue(sptr,&vlen,&vlong);

    if (vstr) {
        score = zzlStrtod(vstr,vlen);
    } else {
        score = vlong;
    }

    return score;
}",733.0,749.0,1.0,4.0,17.0,0,0,0,0,10,0,1,1,0,0,,0,0,2,1,1,double
4752,394808,zzlNext,1,zzlNext,"void zzlNext (unsigned char*,unsigned char**,unsigned char**)",t_zset.c,"void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
    unsigned char *_eptr, *_sptr;
    serverAssert(*eptr != NULL && *sptr != NULL);

    _eptr = lpNext(zl,*sptr);
    if (_eptr != NULL) {
        _sptr = lpNext(zl,_eptr);
        serverAssert(_sptr != NULL);
    } else {
        /* No next entry. */
        _sptr = NULL;
    }

    *eptr = _eptr;
    *sptr = _sptr;
}",794.0,809.0,1.0,4.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
4753,394815,zzlPrev,1,zzlPrev,"void zzlPrev (unsigned char*,unsigned char**,unsigned char**)",t_zset.c,"void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
    unsigned char *_eptr, *_sptr;
    serverAssert(*eptr != NULL && *sptr != NULL);

    _sptr = lpPrev(zl,*eptr);
    if (_sptr != NULL) {
        _eptr = lpPrev(zl,_sptr);
        serverAssert(_eptr != NULL);
    } else {
        /* No previous entry. */
        _eptr = NULL;
    }

    *eptr = _eptr;
    *sptr = _sptr;
}",813.0,828.0,1.0,4.0,16.0,0,0,0,0,5,0,1,1,0,0,,0,0,6,3,3,void
4754,394828,zzlLastInRange,1,zzlLastInRange,"unsigned char* zzlLastInRange (unsigned char*,zrangespec*)",t_zset.c,"unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *eptr = lpSeek(zl,-2), *sptr;
    double score;

    /* If everything is out of range, return early. */
    if (!zzlIsInRange(zl,range)) return NULL;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        score = zzlGetScore(sptr);
        if (zslValueLteMax(score,range)) {
            /* Check if score >= min. */
            if (zslValueGteMin(score,range))
                return eptr;
            return NULL;
        }

        /* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */
        sptr = lpPrev(zl,eptr);
        if (sptr != NULL)
            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);
        else
            eptr = NULL;
    }

    return NULL;
}",886.0,915.0,1.0,8.0,30.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,unsigned char*
4755,394834,zsetLength,1,zsetLength,long unsigned zsetLength (robj*),t_zset.c,"unsigned long zsetLength(const robj *zobj) {
    unsigned long length = 0;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        length = zzlLength(zobj->ptr);
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        length = ((const zset*)zobj->ptr)->zsl->length;
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return length;
}",1157.0,1167.0,1.0,26.0,11.0,0,0,0,0,9,0,1,1,0,0,,0,0,2,1,1,unsigned long
4756,394839,zsetConvert,1,zsetConvert,"void zsetConvert (robj*,int)",t_zset.c,"void zsetConvert(robj *zobj, int encoding) {
    zsetConvertAndExpand(zobj, encoding, zsetLength(zobj));
}",1202.0,1204.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4757,394845,zsetConvertToListpackIfNeeded,1,zsetConvertToListpackIfNeeded,"void zsetConvertToListpackIfNeeded (robj*,size_t,size_t)",t_zset.c,"void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) return;
    zset *zset = zobj->ptr;

    if (zset->zsl->length <= server.zset_max_listpack_entries &&
        maxelelen <= server.zset_max_listpack_value &&
        lpSafeToAdd(NULL, totelelen))
    {
        zsetConvert(zobj,OBJ_ENCODING_LISTPACK);
    }
}",1285.0,1295.0,1.0,26.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4758,394852,zsetScore,1,zsetScore,"int zsetScore (robj*,sds,double*)",t_zset.c,"int zsetScore(robj *zobj, sds member, double *score) {
    if (!zobj || !member) return C_ERR;

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        dictEntry *de = dictFind(zs->dict, member);
        if (de == NULL) return C_ERR;
        *score = *(double*)dictGetVal(de);
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return C_OK;
}",1301.0,1315.0,1.0,33.0,15.0,0,0,0,0,6,0,1,1,0,0,,0,0,6,3,3,int
4759,394866,zsetAdd,1,zsetAdd,"int zsetAdd (robj*,double,sds,int,int*,double*)",t_zset.c,"int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore) {
    /* Turn options into simple to check vars. */
    int incr = (in_flags & ZADD_IN_INCR) != 0;
    int nx = (in_flags & ZADD_IN_NX) != 0;
    int xx = (in_flags & ZADD_IN_XX) != 0;
    int gt = (in_flags & ZADD_IN_GT) != 0;
    int lt = (in_flags & ZADD_IN_LT) != 0;
    *out_flags = 0; /* We'll return our response flags. */
    double curscore;

    /* NaN as input is an error regardless of all the other parameters. */
    if (isnan(score)) {
        *out_flags = ZADD_OUT_NAN;
        return 0;
    }

    /* Update the sorted set according to its encoding. */
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr;

        if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
            /* NX? Return, same element already exists. */
            if (nx) {
                *out_flags |= ZADD_OUT_NOP;
                return 1;
            }

            /* Prepa...",1362.0,1492.0,1.0,27.0,131.0,0,0,0,0,5,0,1,1,0,0,,0,0,12,6,6,int
4760,394876,zsetRank,1,zsetRank,"long zsetRank (robj*,sds,int,double*)",t_zset.c,"long zsetRank(robj *zobj, sds ele, int reverse, double *output_score) {
    unsigned long llen;
    unsigned long rank;

    llen = zsetLength(zobj);

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;

        eptr = lpSeek(zl,0);
        serverAssert(eptr != NULL);
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        rank = 1;
        while(eptr != NULL) {
            if (lpCompare(eptr,(unsigned char*)ele,sdslen(ele)))
                break;
            rank++;
            zzlNext(zl,&eptr,&sptr);
        }

        if (eptr != NULL) {
            if (output_score) 
                *output_score = zzlGetScore(sptr);
            if (reverse)
                return llen-rank;
            else
                return rank-1;
        } else {
            return -1;
        }
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        zskiplist *zsl = z...",1557.0,1614.0,1.0,26.0,58.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,long
4761,394884,zsetDel,1,zsetDel,"int zsetDel (robj*,sds)",t_zset.c,"int zsetDel(robj *zobj, sds ele) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr;

        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {
            zobj->ptr = zzlDelete(zobj->ptr,eptr);
            return 1;
        }
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        if (zsetRemoveFromSkiplist(zs, ele)) {
            if (htNeedsResize(zs->dict)) dictResize(zs->dict);
            return 1;
        }
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return 0; /* No such element found. */
}",1526.0,1544.0,1.0,26.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4762,394890,zsetDup,1,zsetDup,robj* zsetDup (robj*),t_zset.c,"robj *zsetDup(robj *o) {
    robj *zobj;
    zset *zs;
    zset *new_zs;

    serverAssert(o->type == OBJ_ZSET);

    /* Create a new sorted set object that have the same encoding as the original object's encoding */
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        size_t sz = lpBytes(zl);
        unsigned char *new_zl = zmalloc(sz);
        memcpy(new_zl, zl, sz);
        zobj = createObject(OBJ_ZSET, new_zl);
        zobj->encoding = OBJ_ENCODING_LISTPACK;
    } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
        zobj = createZsetObject();
        zs = o->ptr;
        new_zs = zobj->ptr;
        dictExpand(new_zs->dict,dictSize(zs->dict));
        zskiplist *zsl = zs->zsl;
        zskiplistNode *ln;
        sds ele;
        long llen = zsetLength(o);

        /* We copy the skiplist elements from the greatest to the
         * smallest (that's trivial since the elements are already ordered in
         * the skiplist): this improves t...",1621.0,1664.0,1.0,4.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
4763,394895,genericZpopCommand,1,genericZpopCommand,"void genericZpopCommand (client*,robj**,int,int,int,long,int,int,int*)",t_zset.c,"void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey,
                        long count, int use_nested_array, int reply_nil_when_empty, int *deleted) {
    int idx;
    robj *key = NULL;
    robj *zobj = NULL;
    sds ele;
    double score;

    if (deleted) *deleted = 0;

    /* Check type and break on the first error, otherwise identify candidate. */
    idx = 0;
    while (idx < keyc) {
        key = keyv[idx++];
        zobj = lookupKeyWrite(c->db,key);
        if (!zobj) continue;
        if (checkType(c,zobj,OBJ_ZSET)) return;
        break;
    }

    /* No candidate for zpopping, return empty. */
    if (!zobj) {
        if (reply_nil_when_empty) {
            addReplyNullArray(c);
        } else {
            addReply(c,shared.emptyarray);
        }
        return;
    }

    if (count == 0) {
        /* ZPOPMIN/ZPOPMAX with count 0. */
        addReply(c, shared.emptyarray);
        return;
    }

    long result_count = 0;

    /* When count ...",3891.0,4025.0,1.0,29.0,135.0,0,0,0,0,2,0,1,1,0,0,,0,0,18,9,9,void
4764,394908,lpGetObject,1,lpGetObject,sds lpGetObject (unsigned char*),t_zset.c,"sds lpGetObject(unsigned char *sptr) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;

    serverAssert(sptr != NULL);
    vstr = lpGetValue(sptr,&vlen,&vlong);

    if (vstr) {
        return sdsnewlen((char*)vstr,vlen);
    } else {
        return sdsfromlonglong(vlong);
    }
}",752.0,765.0,1.0,4.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sds
4765,394913,zslValueGteMin,1,zslValueGteMin,"int zslValueGteMin (double,zrangespec*)",t_zset.c,"int zslValueGteMin(double value, zrangespec *spec) {
    return spec->minex ? (value > spec->min) : (value >= spec->min);
}",306.0,308.0,1.0,1.0,3.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
4766,394925,zslFreeLexRange,1,zslFreeLexRange,void zslFreeLexRange (zlexrangespec*),t_zset.c,"void zslFreeLexRange(zlexrangespec *spec) {
    if (spec->min != shared.minstring &&
        spec->min != shared.maxstring) sdsfree(spec->min);
    if (spec->max != shared.minstring &&
        spec->max != shared.maxstring) sdsfree(spec->max);
}",602.0,607.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4767,394930,zslParseLexRange,1,zslParseLexRange,"int zslParseLexRange (robj*,robj*,zlexrangespec*)",t_zset.c,"int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
    /* The range can't be valid if objects are integer encoded.
     * Every item must start with ( or [. */
    if (min->encoding == OBJ_ENCODING_INT ||
        max->encoding == OBJ_ENCODING_INT) return C_ERR;

    spec->min = spec->max = NULL;
    if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||
        zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {
        zslFreeLexRange(spec);
        return C_ERR;
    } else {
        return C_OK;
    }
}",614.0,628.0,1.0,25.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
4768,394937,zzlFirstInLexRange,1,zzlFirstInLexRange,"unsigned char* zzlFirstInLexRange (unsigned char*,zlexrangespec*)",t_zset.c,"unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;

    /* If everything is out of range, return early. */
    if (!zzlIsInLexRange(zl,range)) return NULL;

    while (eptr != NULL) {
        if (zzlLexValueGteMin(eptr,range)) {
            /* Check if score <= max. */
            if (zzlLexValueLteMax(eptr,range))
                return eptr;
            return NULL;
        }

        /* Move to next element. */
        sptr = lpNext(zl,eptr); /* This element score. Skip it. */
        serverAssert(sptr != NULL);
        eptr = lpNext(zl,sptr); /* Next element. */
    }

    return NULL;
}",956.0,977.0,1.0,8.0,22.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,unsigned char*
4769,394943,zzlLastInLexRange,1,zzlLastInLexRange,"unsigned char* zzlLastInLexRange (unsigned char*,zlexrangespec*)",t_zset.c,"unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *eptr = lpSeek(zl,-2), *sptr;

    /* If everything is out of range, return early. */
    if (!zzlIsInLexRange(zl,range)) return NULL;

    while (eptr != NULL) {
        if (zzlLexValueLteMax(eptr,range)) {
            /* Check if score >= min. */
            if (zzlLexValueGteMin(eptr,range))
                return eptr;
            return NULL;
        }

        /* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */
        sptr = lpPrev(zl,eptr);
        if (sptr != NULL)
            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);
        else
            eptr = NULL;
    }

    return NULL;
}",981.0,1005.0,1.0,12.0,25.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,unsigned char*
4770,394961,zzlLexValueGteMin,1,zzlLexValueGteMin,"int zzlLexValueGteMin (unsigned char*,zlexrangespec*)",t_zset.c,"int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
    sds value = lpGetObject(p);
    int res = zslLexValueGteMin(value,spec);
    sdsfree(value);
    return res;
}",917.0,922.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4771,394967,zzlLexValueLteMax,1,zzlLexValueLteMax,"int zzlLexValueLteMax (unsigned char*,zlexrangespec*)",t_zset.c,"int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
    sds value = lpGetObject(p);
    int res = zslLexValueLteMax(value,spec);
    sdsfree(value);
    return res;
}",924.0,929.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4772,394973,zslLexValueGteMin,1,zslLexValueGteMin,"int zslLexValueGteMin (sds,zlexrangespec*)",t_zset.c,"int zslLexValueGteMin(sds value, zlexrangespec *spec) {
    return spec->minex ?
        (sdscmplex(value,spec->min) > 0) :
        (sdscmplex(value,spec->min) >= 0);
}",640.0,644.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4773,394979,zslLexValueLteMax,1,zslLexValueLteMax,"int zslLexValueLteMax (sds,zlexrangespec*)",t_zset.c,"int zslLexValueLteMax(sds value, zlexrangespec *spec) {
    return spec->maxex ?
        (sdscmplex(value,spec->max) < 0) :
        (sdscmplex(value,spec->max) <= 0);
}",646.0,650.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4774,395376,setTypeIsMemberAux,1,setTypeIsMemberAux,"int setTypeIsMemberAux (robj*,char*,size_t,int64_t,int)",t_set.c,"int setTypeIsMemberAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds) {
    char tmpbuf[LONG_STR_SIZE];
    if (!str) {
        if (set->encoding == OBJ_ENCODING_INTSET)
            return intsetFind(set->ptr, llval);
        len = ll2string(tmpbuf, sizeof tmpbuf, llval);
        str = tmpbuf;
        str_is_sds = 0;
    }

    if (set->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = set->ptr;
        unsigned char *p = lpFirst(lp);
        return p && lpFind(lp, p, (unsigned char*)str, len, 0);
    } else if (set->encoding == OBJ_ENCODING_INTSET) {
        long long llval;
        return string2ll(str, len, &llval) && intsetFind(set->ptr, llval);
    } else if (set->encoding == OBJ_ENCODING_HT && str_is_sds) {
        return dictFind(set->ptr, (sds)str) != NULL;
    } else if (set->encoding == OBJ_ENCODING_HT) {
        sds sdsval = sdsnewlen(str, len);
        int result = dictFind(set->ptr, sdsval) != NULL;
        sdsfree(sdsval);
        retur...",297.0,324.0,1.0,16.0,28.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,int
4775,395385,setTypeInitIterator,1,setTypeInitIterator,setTypeIterator* setTypeInitIterator (robj*),t_set.c,"setTypeIterator *setTypeInitIterator(robj *subject) {
    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));
    si->subject = subject;
    si->encoding = subject->encoding;
    if (si->encoding == OBJ_ENCODING_HT) {
        si->di = dictGetIterator(subject->ptr);
    } else if (si->encoding == OBJ_ENCODING_INTSET) {
        si->ii = 0;
    } else if (si->encoding == OBJ_ENCODING_LISTPACK) {
        si->lpi = NULL;
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return si;
}",326.0,340.0,1.0,24.0,15.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,setTypeIterator
4776,395390,setTypeReleaseIterator,1,setTypeReleaseIterator,void setTypeReleaseIterator (setTypeIterator*),t_set.c,"void setTypeReleaseIterator(setTypeIterator *si) {
    if (si->encoding == OBJ_ENCODING_HT)
        dictReleaseIterator(si->di);
    zfree(si);
}",342.0,346.0,1.0,24.0,5.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
4777,395395,setTypeNext,1,setTypeNext,"int setTypeNext (setTypeIterator*,char**,size_t*,int64_t*)",t_set.c,"int setTypeNext(setTypeIterator *si, char **str, size_t *len, int64_t *llele) {
    if (si->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictNext(si->di);
        if (de == NULL) return -1;
        *str = dictGetKey(de);
        *len = sdslen(*str);
        *llele = -123456789; /* Not needed. Defensive. */
    } else if (si->encoding == OBJ_ENCODING_INTSET) {
        if (!intsetGet(si->subject->ptr,si->ii++,llele))
            return -1;
        *str = NULL;
    } else if (si->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = si->subject->ptr;
        unsigned char *lpi = si->lpi;
        if (lpi == NULL) {
            lpi = lpFirst(lp);
        } else {
            lpi = lpNext(lp, lpi);
        }
        if (lpi == NULL) return -1;
        si->lpi = lpi;
        unsigned int l;
        *str = (char *)lpGetValue(lpi, &l, (long long *)llele);
        *len = (size_t)l;
    } else {
        serverPanic(""Wrong set encoding in setTypeNext"");
    }
    return si-...",369.0,397.0,1.0,24.0,29.0,0,0,0,0,5,0,1,1,0,0,,0,0,8,4,4,int
4778,395408,setTypeRandomElement,1,setTypeRandomElement,"int setTypeRandomElement (robj*,char**,size_t*,int64_t*)",t_set.c,"int setTypeRandomElement(robj *setobj, char **str, size_t *len, int64_t *llele) {
    if (setobj->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictGetFairRandomKey(setobj->ptr);
        *str = dictGetKey(de);
        *len = sdslen(*str);
        *llele = -123456789; /* Not needed. Defensive. */
    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
        *llele = intsetRandom(setobj->ptr);
        *str = NULL; /* Not needed. Defensive. */
    } else if (setobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = setobj->ptr;
        int r = rand() % lpLength(lp);
        unsigned char *p = lpSeek(lp, r);
        unsigned int l;
        *str = (char *)lpGetValue(p, &l, (long long *)llele);
        *len = (size_t)l;
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return setobj->encoding;
}",429.0,449.0,1.0,28.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
4779,395416,setTypeSize,1,setTypeSize,long unsigned setTypeSize (robj*),t_set.c,"unsigned long setTypeSize(const robj *subject) {
    if (subject->encoding == OBJ_ENCODING_HT) {
        return dictSize((const dict*)subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
        return intsetLen((const intset*)subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        return lpLength((unsigned char *)subject->ptr);
    } else {
        serverPanic(""Unknown set encoding"");
    }
}",480.0,490.0,1.0,29.0,11.0,0,0,0,0,14,0,1,1,0,0,,0,0,2,1,1,unsigned long
4780,395421,setTypeConvert,1,setTypeConvert,"void setTypeConvert (robj*,int)",t_set.c,"void setTypeConvert(robj *setobj, int enc) {
    setTypeConvertAndExpand(setobj, enc, setTypeSize(setobj), 1);
}",495.0,497.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4781,395427,setTypeConvertAndExpand,1,setTypeConvertAndExpand,"int setTypeConvertAndExpand (robj*,int,long unsigned,int)",t_set.c,"int setTypeConvertAndExpand(robj *setobj, int enc, unsigned long cap, int panic) {
    setTypeIterator *si;
    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
                             setobj->encoding != enc);

    if (enc == OBJ_ENCODING_HT) {
        dict *d = dictCreate(&setDictType);
        sds element;

        /* Presize the dict to avoid rehashing */
        if (panic) {
            dictExpand(d, cap);
        } else if (dictTryExpand(d, cap) != DICT_OK) {
            dictRelease(d);
            return C_ERR;
        }

        /* To add the elements we extract integers and create redis objects */
        si = setTypeInitIterator(setobj);
        while ((element = setTypeNextObject(si)) != NULL) {
            serverAssert(dictAdd(d,element,NULL) == DICT_OK);
        }
        setTypeReleaseIterator(si);

        freeSetObject(setobj); /* frees the internals but not setobj itself */
        setobj->encoding = OBJ_ENCODING_HT;
        setobj->ptr = d;
    } el...",503.0,559.0,1.0,4.0,57.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
4782,395435,setTypeDup,1,setTypeDup,robj* setTypeDup (robj*),t_set.c,"robj *setTypeDup(robj *o) {
    robj *set;
    setTypeIterator *si;

    serverAssert(o->type == OBJ_SET);

    /* Create a new set object that have the same encoding as the original object's encoding */
    if (o->encoding == OBJ_ENCODING_INTSET) {
        intset *is = o->ptr;
        size_t size = intsetBlobLen(is);
        intset *newis = zmalloc(size);
        memcpy(newis,is,size);
        set = createObject(OBJ_SET, newis);
        set->encoding = OBJ_ENCODING_INTSET;
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = o->ptr;
        size_t sz = lpBytes(lp);
        unsigned char *new_lp = zmalloc(sz);
        memcpy(new_lp, lp, sz);
        set = createObject(OBJ_SET, new_lp);
        set->encoding = OBJ_ENCODING_LISTPACK;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        set = createSetObject();
        dict *d = o->ptr;
        dictExpand(set->ptr, dictSize(d));
        si = setTypeInitIterator(o);
        char *str;
        size_t len...",566.0,603.0,1.0,4.0,38.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
4783,395446,hashTypeTryConversion,1,hashTypeTryConversion,"void hashTypeTryConversion (robj*,robj**,int,int)",t_hash.c,"void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
    int i;
    size_t sum = 0;

    if (o->encoding != OBJ_ENCODING_LISTPACK) return;

    /* We guess that most of the values in the input are unique, so
     * if there are enough arguments we create a pre-sized hash, which
     * might over allocate memory if there are duplicates. */
    size_t new_fields = (end - start + 1) / 2;
    if (new_fields > server.hash_max_listpack_entries) {
        hashTypeConvert(o, OBJ_ENCODING_HT);
        dictExpand(o->ptr, new_fields);
        return;
    }

    for (i = start; i <= end; i++) {
        if (!sdsEncodedObject(argv[i]))
            continue;
        size_t len = sdslen(argv[i]->ptr);
        if (len > server.hash_max_listpack_value) {
            hashTypeConvert(o, OBJ_ENCODING_HT);
            return;
        }
        sum += len;
    }
    if (!lpSafeToAdd(o->ptr, sum))
        hashTypeConvert(o, OBJ_ENCODING_HT);
}",40.0,68.0,1.0,23.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
4784,395454,hashTypeExists,1,hashTypeExists,"int hashTypeExists (robj*,sds)",t_hash.c,"int hashTypeExists(robj *o, sds field) {
    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    return hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK;
}",171.0,177.0,1.0,61.0,7.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
4785,395460,hashTypeDelete,1,hashTypeDelete,"int hashTypeDelete (robj*,sds)",t_hash.c,"int hashTypeDelete(robj *o, sds field) {
    int deleted = 0;

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl, *fptr;

        zl = o->ptr;
        fptr = lpFirst(zl);
        if (fptr != NULL) {
            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
            if (fptr != NULL) {
                /* Delete both of the key and the value. */
                zl = lpDeleteRangeWithEntry(zl,&fptr,2);
                o->ptr = zl;
                deleted = 1;
            }
        }
    } else if (o->encoding == OBJ_ENCODING_HT) {
        if (dictDelete((dict*)o->ptr, field) == C_OK) {
            deleted = 1;

            /* Always check if the dictionary needs a resize after a delete. */
            if (htNeedsResize(o->ptr)) dictResize(o->ptr);
        }

    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return deleted;
}",275.0,304.0,1.0,23.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4786,395466,hashTypeLength,1,hashTypeLength,long unsigned hashTypeLength (robj*),t_hash.c,"unsigned long hashTypeLength(const robj *o) {
    unsigned long length = ULONG_MAX;

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        length = lpLength(o->ptr) / 2;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        length = dictSize((const dict*)o->ptr);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return length;
}",307.0,318.0,1.0,23.0,12.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,unsigned long
4787,395471,hashTypeInitIterator,1,hashTypeInitIterator,hashTypeIterator* hashTypeInitIterator (robj*),t_hash.c,"hashTypeIterator *hashTypeInitIterator(robj *subject) {
    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));
    hi->subject = subject;
    hi->encoding = subject->encoding;

    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        hi->fptr = NULL;
        hi->vptr = NULL;
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        hi->di = dictGetIterator(subject->ptr);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return hi;
}",320.0,334.0,1.0,24.0,15.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,hashTypeIterator
4788,395476,hashTypeReleaseIterator,1,hashTypeReleaseIterator,void hashTypeReleaseIterator (hashTypeIterator*),t_hash.c,"void hashTypeReleaseIterator(hashTypeIterator *hi) {
    if (hi->encoding == OBJ_ENCODING_HT)
        dictReleaseIterator(hi->di);
    zfree(hi);
}",336.0,340.0,1.0,24.0,5.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
4789,395481,hashTypeNext,1,hashTypeNext,int hashTypeNext (hashTypeIterator*),t_hash.c,"int hashTypeNext(hashTypeIterator *hi) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl;
        unsigned char *fptr, *vptr;

        zl = hi->subject->ptr;
        fptr = hi->fptr;
        vptr = hi->vptr;

        if (fptr == NULL) {
            /* Initialize cursor */
            serverAssert(vptr == NULL);
            fptr = lpFirst(zl);
        } else {
            /* Advance cursor */
            serverAssert(vptr != NULL);
            fptr = lpNext(zl, vptr);
        }
        if (fptr == NULL) return C_ERR;

        /* Grab pointer to the value (fptr points to the field) */
        vptr = lpNext(zl, fptr);
        serverAssert(vptr != NULL);

        /* fptr, vptr now point to the first or next pair */
        hi->fptr = fptr;
        hi->vptr = vptr;
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return C_OK;
}",344.0,377.0,1.0,24.0,34.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,int
4790,395486,hashTypeCurrentFromListpack,1,hashTypeCurrentFromListpack,"void hashTypeCurrentFromListpack (hashTypeIterator*,int,unsigned char**,unsigned int*,long long*)",t_hash.c,"void hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,
                                 unsigned char **vstr,
                                 unsigned int *vlen,
                                 long long *vll)
{
    serverAssert(hi->encoding == OBJ_ENCODING_LISTPACK);

    if (what & OBJ_HASH_KEY) {
        *vstr = lpGetValue(hi->fptr, vlen, vll);
    } else {
        *vstr = lpGetValue(hi->vptr, vlen, vll);
    }
}",381.0,393.0,1.0,4.0,13.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
4791,395510,hashTypeCurrentObjectNewSds,1,hashTypeCurrentObjectNewSds,"sds hashTypeCurrentObjectNewSds (hashTypeIterator*,int)",t_hash.c,"sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vll;

    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);
    if (vstr) return sdsnewlen(vstr,vlen);
    return sdsfromlonglong(vll);
}",433.0,441.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,sds
4792,395522,hashTypeGetValueObject,1,hashTypeGetValueObject,"robj* hashTypeGetValueObject (robj*,sds)",t_hash.c,"robj *hashTypeGetValueObject(robj *o, sds field) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vll;

    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;
    if (vstr) return createStringObject((char*)vstr,vlen);
    else return createStringObjectFromLongLong(vll);
}",144.0,152.0,1.0,54.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,robj
4793,395528,hashTypeSet,1,hashTypeSet,"int hashTypeSet (robj*,sds,sds,int)",t_hash.c,"int hashTypeSet(robj *o, sds field, sds value, int flags) {
    int update = 0;

    /* Check if the field is too long for listpack, and convert before adding the item.
     * This is needed for HINCRBY* case since in other commands this is handled early by
     * hashTypeTryConversion, so this check will be a NOP. */
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        if (sdslen(field) > server.hash_max_listpack_value || sdslen(value) > server.hash_max_listpack_value)
            hashTypeConvert(o, OBJ_ENCODING_HT);
    }
    
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl, *fptr, *vptr;

        zl = o->ptr;
        fptr = lpFirst(zl);
        if (fptr != NULL) {
            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
            if (fptr != NULL) {
                /* Grab pointer to the value (fptr points to the field) */
                vptr = lpNext(zl, fptr);
                serverAssert(vptr != NULL);
                update...",200.0,271.0,1.0,23.0,72.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
4794,395536,hashTypeDup,1,hashTypeDup,robj* hashTypeDup (robj*),t_hash.c,"robj *hashTypeDup(robj *o) {
    robj *hobj;
    hashTypeIterator *hi;

    serverAssert(o->type == OBJ_HASH);

    if(o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        size_t sz = lpBytes(zl);
        unsigned char *new_zl = zmalloc(sz);
        memcpy(new_zl, zl, sz);
        hobj = createObject(OBJ_HASH, new_zl);
        hobj->encoding = OBJ_ENCODING_LISTPACK;
    } else if(o->encoding == OBJ_ENCODING_HT){
        dict *d = dictCreate(&hashDictType);
        dictExpand(d, dictSize((const dict*)o->ptr));

        hi = hashTypeInitIterator(o);
        while (hashTypeNext(hi) != C_ERR) {
            sds field, value;
            sds newfield, newvalue;
            /* Extract a field-value pair from an original hash object.*/
            field = hashTypeCurrentFromHashTable(hi, OBJ_HASH_KEY);
            value = hashTypeCurrentFromHashTable(hi, OBJ_HASH_VALUE);
            newfield = sdsdup(field);
            newvalue = sdsdup(value);

            /...",510.0,548.0,1.0,4.0,39.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
4795,396501,getTimeoutFromObjectOrReply,1,getTimeoutFromObjectOrReply,"int getTimeoutFromObjectOrReply (client*,robj*,mstime_t*,int)",timeout.c,"int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit) {
    long long tval;
    long double ftval;
    mstime_t now = commandTimeSnapshot();

    if (unit == UNIT_SECONDS) {
        if (getLongDoubleFromObjectOrReply(c,object,&ftval,
            ""timeout is not a float or out of range"") != C_OK)
            return C_ERR;

        ftval *= 1000.0;  /* seconds => millisec */
        if (ftval > LLONG_MAX) {
            addReplyError(c, ""timeout is out of range"");
            return C_ERR;
        }
        tval = (long long) ceill(ftval);
    } else {
        if (getLongLongFromObjectOrReply(c,object,&tval,
            ""timeout is not an integer or out of range"") != C_OK)
            return C_ERR;
    }

    if (tval < 0) {
        addReplyError(c,""timeout is negative"");
        return C_ERR;
    }

    if (tval > 0) {
        if  (tval > LLONG_MAX - now) {
            addReplyError(c,""timeout is out of range""); /* 'tval+now' would overflow */
         ...",165.0,202.0,1.0,16.0,38.0,0,0,0,0,4,0,1,1,0,0,,0,0,8,4,4,int
4796,396595,addClientToTimeoutTable,1,addClientToTimeoutTable,void addClientToTimeoutTable (client*),timeout.c,"void addClientToTimeoutTable(client *c) {
    if (c->bstate.timeout == 0) return;
    uint64_t timeout = c->bstate.timeout;
    unsigned char buf[CLIENT_ST_KEYLEN];
    encodeTimeoutKey(buf,timeout,c);
    if (raxTryInsert(server.clients_timeout_table,buf,sizeof(buf),NULL,NULL))
        c->flags |= CLIENT_IN_TO_TABLE;
}",115.0,122.0,1.0,22.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4797,396600,removeClientFromTimeoutTable,1,removeClientFromTimeoutTable,void removeClientFromTimeoutTable (client*),timeout.c,"void removeClientFromTimeoutTable(client *c) {
    if (!(c->flags & CLIENT_IN_TO_TABLE)) return;
    c->flags &= ~CLIENT_IN_TO_TABLE;
    uint64_t timeout = c->bstate.timeout;
    unsigned char buf[CLIENT_ST_KEYLEN];
    encodeTimeoutKey(buf,timeout,c);
    raxRemove(server.clients_timeout_table,buf,sizeof(buf),NULL);
}",126.0,133.0,1.0,21.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4798,396605,handleBlockedClientsTimeout,1,handleBlockedClientsTimeout,void handleBlockedClientsTimeout (void),timeout.c,"void handleBlockedClientsTimeout(void) {
    if (raxSize(server.clients_timeout_table) == 0) return;
    uint64_t now = mstime();
    raxIterator ri;
    raxStart(&ri,server.clients_timeout_table);
    raxSeek(&ri,""^"",NULL,0);

    while(raxNext(&ri)) {
        uint64_t timeout;
        client *c;
        decodeTimeoutKey(ri.key,&timeout,&c);
        if (timeout >= now) break; /* All the timeouts are in the future. */
        c->flags &= ~CLIENT_IN_TO_TABLE;
        checkBlockedClientTimeout(c,now);
        raxRemove(server.clients_timeout_table,ri.key,ri.key_len,NULL);
        raxSeek(&ri,""^"",NULL,0);
    }
    raxStop(&ri);
}",137.0,155.0,1.0,21.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4799,396610,clientsCronHandleTimeout,1,clientsCronHandleTimeout,"int clientsCronHandleTimeout (client*,mstime_t)",timeout.c,"int clientsCronHandleTimeout(client *c, mstime_t now_ms) {
    time_t now = now_ms/1000;

    if (server.maxidletime &&
        /* This handles the idle clients connection timeout if set. */
        !(c->flags & CLIENT_SLAVE) &&   /* No timeout for slaves and monitors */
        !mustObeyClient(c) &&         /* No timeout for masters and AOF */
        !(c->flags & CLIENT_BLOCKED) && /* No timeout for BLPOP */
        !(c->flags & CLIENT_PUBSUB) &&  /* No timeout for Pub/Sub clients */
        (now - c->lastinteraction > server.maxidletime))
    {
        serverLog(LL_VERBOSE,""Closing idle client"");
        freeClient(c);
        return 1;
    } else if (c->flags & CLIENT_BLOCKED) {
        /* Cluster: handle unblock & redirect of clients blocked
         * into keys no longer served by this server. */
        if (server.cluster_enabled) {
            if (clusterRedirectBlockedClientIfNeeded(c))
                unblockClientOnError(c, NULL);
        }
    }
    return 0;
}",56.0,79.0,1.0,21.0,24.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4800,397269,zaddCommand,1,zaddCommand,void zaddCommand (client*),t_zset.c,"void zaddCommand(client *c) {
    zaddGenericCommand(c,ZADD_IN_NONE);
}",1837.0,1839.0,1.0,25.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4801,398232,SHA1Transform,1,SHA1Transform,"void SHA1Transform (uint32_t[5],unsigned char[64])",sha1.c,"void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
{
    uint32_t a, b, c, d, e;
    typedef union {
        unsigned char c[64];
        uint32_t l[16];
    } CHAR64LONG16;
#ifdef SHA1HANDSOFF
    CHAR64LONG16 block[1];  /* use array to appear as a pointer */
    memcpy(block, buffer, 64);
#else
    /* The following had better never be used because it causes the
     * pointer-to-const buffer to be cast into a pointer to non-const.
     * And the result is written through.  I threw a ""const"" in, hoping
     * this will cause a diagnostic.
     */
    CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
#endif
    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,...",56.0,112.0,1.0,4.0,57.0,4102,12,1785,8,2,0,1,1,0,0,,0,0,4,2,2,void
4802,407283,SHA1Init,1,SHA1Init,void SHA1Init (SHA1_CTX*),sha1.c,"void SHA1Init(SHA1_CTX* context)
{
    /* SHA1 initialization constants */
    context->state[0] = 0x67452301;
    context->state[1] = 0xEFCDAB89;
    context->state[2] = 0x98BADCFE;
    context->state[3] = 0x10325476;
    context->state[4] = 0xC3D2E1F0;
    context->count[0] = context->count[1] = 0;
}",117.0,126.0,1.0,1.0,10.0,21,3,7,1,3,7,1,1,0,0,,0,7,2,1,1,void
4803,407336,SHA1Update,1,SHA1Update,"void SHA1Update (SHA1_CTX*,unsigned char*,uint32_t)",sha1.c,"void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
{
    uint32_t i, j;

    j = context->count[0];
    if ((context->count[0] += len << 3) < j)
        context->count[1]++;
    context->count[1] += (len>>29);
    j = (j >> 3) & 63;
    if ((j + len) > 63) {
        memcpy(&context->buffer[j], data, (i = 64-j));
        SHA1Transform(context->state, context->buffer);
        for ( ; i + 63 < len; i += 64) {
            SHA1Transform(context->state, &data[i]);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&context->buffer[j], &data[i], len - i);
}",139.0,158.0,1.0,1.0,20.0,39,13,31,5,6,11,4,5,1,2,,0,9,6,3,3,void
4804,407455,SHA1Final,1,SHA1Final,"void SHA1Final (unsigned char[20],SHA1_CTX*)",sha1.c,"void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
{
    unsigned i;
    unsigned char finalcount[8];
    unsigned char c;

#if 0	/* untested ""improvement"" by DHR */
    /* Convert context->count to a sequence of bytes
     * in finalcount.  Second element first, but
     * big-endian order within element.
     * But we do it all backwards.
     */
    unsigned char *fcp = &finalcount[8];

    for (i = 0; i < 2; i++)
       {
        uint32_t t = context->count[i];
        int j;

        for (j = 0; j < 4; t >>= 8, j++)
	          *--fcp = (unsigned char) t;
    }
#else
    for (i = 0; i < 8; i++) {
        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
    }
#endif
    c = 0200;
    SHA1Update(context, &c, 1);
    while ((context->count[0] & 504) != 448) {
	c = 0000;
        SHA1Update(context, &c, 1);
    }
    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
   ...",166.0,208.0,1.0,1.0,43.0,39,15,27,5,3,6,4,4,1,3,,0,3,4,2,2,void
4805,407701,sha256_transform,1,sha256_transform,"void sha256_transform (SHA256_CTX*,BYTE[])",sha256.c,"void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
{
	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

    for (i = 0, j = 0; i < 16; ++i, j += 4) {
        m[i] = ((WORD) data[j + 0] << 24) |
               ((WORD) data[j + 1] << 16) |
               ((WORD) data[j + 2] << 8) |
               ((WORD) data[j + 3]);
    }

	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];

	for (i = 0; i < 64; ++i) {
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
		t2 = EP0(a) + MAJ(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
}",44.0,88.0,1.0,9.0,45.0,131,15,103,16,2,17,4,4,0,0,,0,17,4,2,2,void
4806,408154,sha256_init,1,sha256_init,void sha256_init (SHA256_CTX*),sha256.c,"void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
	ctx->bitlen = 0;
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}",90.0,102.0,1.0,1.0,13.0,28,3,10,1,1,10,1,1,0,0,,0,10,2,1,1,void
4807,408225,sha256_update,1,sha256_update,"void sha256_update (SHA256_CTX*,BYTE[],size_t)",sha256.c,"void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
{
	WORD i;

	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			sha256_transform(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
}",104.0,117.0,1.0,1.0,14.0,16,7,13,4,1,8,3,4,1,1,,0,7,6,3,3,void
4808,408281,sha256_final,1,sha256_final,"void sha256_final (SHA256_CTX*,BYTE[])",sha256.c,"void sha256_final(SHA256_CTX *ctx, BYTE hash[])
{
	WORD i;

	i = ctx->datalen;

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	sha256_transform(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]     ...",119.0,163.0,1.0,1.0,45.0,126,11,60,3,1,31,4,5,1,1,,0,30,4,2,2,void
4809,410458,slowlogCreateEntry,1,slowlogCreateEntry,"slowlogEntry slowlogCreateEntry (client*,robj**,int,long long)",slowlog.c,"slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {
    slowlogEntry *se = zmalloc(sizeof(*se));
    int j, slargc = argc;

    if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;
    se->argc = slargc;
    se->argv = zmalloc(sizeof(robj*)*slargc);
    for (j = 0; j < slargc; j++) {
        /* Logging too many arguments is a useless memory waste, so we stop
         * at SLOWLOG_ENTRY_MAX_ARGC, but use the last argument to specify
         * how many remaining arguments there were in the original command. */
        if (slargc != argc && j == slargc-1) {
            se->argv[j] = createObject(OBJ_STRING,
                sdscatprintf(sdsempty(),""... (%d more arguments)"",
                argc-slargc+1));
        } else {
            /* Trim too long strings as well... */
            if (argv[j]->type == OBJ_STRING &&
                sdsEncodedObject(argv[j]) &&
                sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)
     ...",48.0,94.0,1.0,17.0,47.0,39,16,34,9,1,19,4,5,0,9,,0,19,8,4,4,slowlogEntry
4810,410706,slowlogFreeEntry,1,slowlogFreeEntry,void slowlogFreeEntry (void*),slowlog.c,"void slowlogFreeEntry(void *septr) {
    slowlogEntry *se = septr;
    int j;

    for (j = 0; j < se->argc; j++)
        decrRefCount(se->argv[j]);
    zfree(se->argv);
    sdsfree(se->peerid);
    sdsfree(se->cname);
    zfree(se);
}",100.0,110.0,1.0,1.0,11.0,7,3,9,3,0,8,2,2,1,4,,0,4,2,1,1,void
4811,410748,slowlogInit,1,slowlogInit,void slowlogInit (void),slowlog.c,"void slowlogInit(void) {
    server.slowlog = listCreate();
    server.slowlog_entry_id = 0;
    listSetFreeMethod(server.slowlog,slowlogFreeEntry);
}",114.0,118.0,1.0,4.0,5.0,8,3,4,1,1,1,1,1,0,1,,0,1,2,1,1,void
4812,410776,slowlogPushEntryIfNeeded,1,slowlogPushEntryIfNeeded,"void slowlogPushEntryIfNeeded (client*,robj**,int,long long)",slowlog.c,"void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {
    if (server.slowlog_log_slower_than < 0) return; /* Slowlog disabled */
    if (duration >= server.slowlog_log_slower_than)
        listAddNodeHead(server.slowlog,
                        slowlogCreateEntry(c,argv,argc,duration));

    /* Remove old entries if needed. */
    while (listLength(server.slowlog) > server.slowlog_max_len)
        listDelNode(server.slowlog,listLast(server.slowlog));
}",123.0,132.0,1.0,11.0,10.0,10,5,11,5,1,2,4,4,0,2,,0,1,8,4,4,void
4813,411198,connCreateSocket,1,connCreateSocket,connection connCreateSocket (void),socket.c,"static connection *connCreateSocket(void) {
    connection *conn = zcalloc(sizeof(connection));
    conn->type = &CT_Socket;
    conn->fd = -1;
    conn->iovcnt = IOV_MAX;

    return conn;
}",77.0,84.0,1.0,1.0,8.0,10,5,8,4,1,5,1,1,0,1,,0,5,2,1,1,connection
4814,411228,connCreateAcceptedSocket,1,connCreateAcceptedSocket,"connection connCreateAcceptedSocket (int,void*)",socket.c,"static connection *connCreateAcceptedSocket(int fd, void *priv) {
    UNUSED(priv);
    connection *conn = connCreateSocket();
    conn->fd = fd;
    conn->state = CONN_STATE_ACCEPTING;
    return conn;
}",96.0,102.0,1.0,4.0,7.0,6,3,8,4,1,3,1,1,0,1,,0,3,4,2,2,connection
4815,411256,connSocketConnect,1,connSocketConnect,"int connSocketConnect (connection*,char*,int,char*,ConnectionCallbackFunc)",socket.c,"static int connSocketConnect(connection *conn, const char *addr, int port, const char *src_addr,
        ConnectionCallbackFunc connect_handler) {
    int fd = anetTcpNonBlockBestEffortBindConnect(NULL,addr,port,src_addr);
    if (fd == -1) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = errno;
        return C_ERR;
    }

    conn->fd = fd;
    conn->state = CONN_STATE_CONNECTING;

    conn->conn_handler = connect_handler;
    aeCreateFileEvent(server.el, conn->fd, AE_WRITABLE,
            conn->type->ae_handler, conn);

    return C_OK;
}",104.0,121.0,1.0,15.0,18.0,18,5,20,11,0,9,2,2,0,2,,0,8,10,5,5,int
4816,411329,connSocketShutdown,1,connSocketShutdown,void connSocketShutdown (connection*),socket.c,"static void connSocketShutdown(connection *conn) {
    if (conn->fd == -1) return;

    shutdown(conn->fd, SHUT_RDWR);
}",129.0,133.0,1.0,1.0,5.0,4,3,3,2,0,2,2,2,1,0,,0,2,2,1,1,void
4817,411348,connSocketClose,1,connSocketClose,void connSocketClose (connection*),socket.c,"static void connSocketClose(connection *conn) {
    if (conn->fd != -1) {
        aeDeleteFileEvent(server.el,conn->fd, AE_READABLE | AE_WRITABLE);
        close(conn->fd);
        conn->fd = -1;
    }

    /* If called from within a handler, schedule the close but
     * keep the connection until the handler returns.
     */
    if (connHasRefs(conn)) {
        conn->flags |= CONN_FLAG_CLOSE_SCHEDULED;
        return;
    }

    zfree(conn);
}",136.0,152.0,1.0,46.0,17.0,12,7,8,2,0,8,3,3,2,3,,0,6,2,1,1,void
4818,411401,connSocketWrite,1,connSocketWrite,"int connSocketWrite (connection*,void*,size_t)",socket.c,"static int connSocketWrite(connection *conn, const void *data, size_t data_len) {
    int ret = write(conn->fd, data, data_len);
    if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",154.0,167.0,1.0,1.0,14.0,13,6,16,9,0,4,3,4,1,0,,0,4,6,3,3,int
4819,411449,connSocketWritev,1,connSocketWritev,"int connSocketWritev (connection*,iovec*,int)",socket.c,"static int connSocketWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    int ret = writev(conn->fd, iov, iovcnt);
    if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",169.0,182.0,1.0,1.0,14.0,13,6,16,9,0,4,3,4,1,0,,0,4,6,3,3,int
4820,411497,connSocketRead,1,connSocketRead,"int connSocketRead (connection*,void*,size_t)",socket.c,"static int connSocketRead(connection *conn, void *buf, size_t buf_len) {
    int ret = read(conn->fd, buf, buf_len);
    if (!ret) {
        conn->state = CONN_STATE_CLOSED;
    } else if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",184.0,199.0,1.0,1.0,16.0,5,3,8,5,0,2,2,2,0,0,,0,2,6,3,3,int
4821,411556,connSocketAccept,1,connSocketAccept,"int connSocketAccept (connection*,ConnectionCallbackFunc)",socket.c,"static int connSocketAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    int ret = C_OK;

    if (conn->state != CONN_STATE_ACCEPTING) return C_ERR;
    conn->state = CONN_STATE_CONNECTED;

    connIncrRefs(conn);
    if (!callHandler(conn, accept_handler)) ret = C_ERR;
    connDecrRefs(conn);

    return ret;
}",201.0,212.0,1.0,14.0,12.0,9,5,11,5,0,5,3,3,2,3,,0,3,4,2,2,int
4822,411603,connSocketSetWriteHandler,1,connSocketSetWriteHandler,"int connSocketSetWriteHandler (connection*,ConnectionCallbackFunc,int)",socket.c,"static int connSocketSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {
    if (func == conn->write_handler) return C_OK;

    conn->write_handler = func;
    if (barrier)
        conn->flags |= CONN_FLAG_WRITE_BARRIER;
    else
        conn->flags &= ~CONN_FLAG_WRITE_BARRIER;
    if (!conn->write_handler)
        aeDeleteFileEvent(server.el,conn->fd,AE_WRITABLE);
    else
        if (aeCreateFileEvent(server.el,conn->fd,AE_WRITABLE,
                    conn->type->ae_handler,conn) == AE_ERR) return C_ERR;
    return C_OK;
}",222.0,236.0,1.0,44.0,15.0,10,6,9,4,0,6,4,4,2,1,,0,5,6,3,3,int
4823,411700,connSocketSetReadHandler,1,connSocketSetReadHandler,"int connSocketSetReadHandler (connection*,ConnectionCallbackFunc)",socket.c,"static int connSocketSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    if (func == conn->read_handler) return C_OK;

    conn->read_handler = func;
    if (!conn->read_handler)
        aeDeleteFileEvent(server.el,conn->fd,AE_READABLE);
    else
        if (aeCreateFileEvent(server.el,conn->fd,
                    AE_READABLE,conn->type->ae_handler,conn) == AE_ERR) return C_ERR;
    return C_OK;
}",241.0,251.0,1.0,43.0,11.0,8,5,7,3,0,5,3,3,2,1,,0,4,4,2,2,int
4824,411772,connSocketGetLastError,1,connSocketGetLastError,const char* connSocketGetLastError (connection*),socket.c,"static const char *connSocketGetLastError(connection *conn) {
    return strerror(conn->last_errno);
}",253.0,255.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,const char*
4825,411782,connSocketEventHandler,1,connSocketEventHandler,"void connSocketEventHandler (aeEventLoop*,int,void*,int)",socket.c,"static void connSocketEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask)
{
    UNUSED(el);
    UNUSED(fd);
    connection *conn = clientData;

    if (conn->state == CONN_STATE_CONNECTING &&
            (mask & AE_WRITABLE) && conn->conn_handler) {

        int conn_error = anetGetError(conn->fd);
        if (conn_error) {
            conn->last_errno = conn_error;
            conn->state = CONN_STATE_ERROR;
        } else {
            conn->state = CONN_STATE_CONNECTED;
        }

        if (!conn->write_handler) aeDeleteFileEvent(server.el,conn->fd,AE_WRITABLE);

        if (!callHandler(conn, conn->conn_handler)) return;
        conn->conn_handler = NULL;
    }

    /* Normally we execute the readable event first, and the writable
     * event later. This is useful as sometimes we may be able
     * to serve the reply of a query immediately after processing the
     * query.
     *
     * However if WRITE_BARRIER is set in the mask, our application is
    ...",257.0,309.0,1.0,4.0,53.0,44,9,43,13,0,21,11,17,11,6,,0,20,8,4,4,void
4826,411957,connSocketAcceptHandler,1,connSocketAcceptHandler,"void connSocketAcceptHandler (aeEventLoop*,int,void*,int)",socket.c,"static void connSocketAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    while(max--) {
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_WARNING,
                    ""Accepting client connection: %s"", server.neterr);
            return;
        }
        serverLog(LL_VERBOSE,""Accepted %s:%d"", cip, cport);
        acceptCommonHandler(connCreateAcceptedSocket(cfd, NULL),0,cip);
    }
}",311.0,329.0,1.0,26.0,19.0,19,11,25,12,0,5,4,7,0,5,,0,2,8,4,4,void
4827,412069,connSocketAddr,1,connSocketAddr,"int connSocketAddr (connection*,char*,size_t,int*,int)",socket.c,"static int connSocketAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    if (anetFdToString(conn->fd, ip, ip_len, port, remote) == 0)
        return C_OK;

    conn->last_errno = errno;
    return C_ERR;
}",331.0,337.0,1.0,15.0,7.0,5,4,7,6,1,3,2,2,2,1,,0,3,10,5,5,int
4828,412104,connSocketIsLocal,1,connSocketIsLocal,int connSocketIsLocal (connection*),socket.c,"static int connSocketIsLocal(connection *conn) {
    char cip[NET_IP_STR_LEN + 1] = { 0 };

    if (connSocketAddr(conn, cip, sizeof(cip) - 1, NULL, 1) == C_ERR)
        return -1;

    return !strncmp(cip, ""127."", 4) || !strcmp(cip, ""::1"");
}",339.0,346.0,1.0,13.0,8.0,10,8,7,3,0,1,2,2,1,1,,0,1,2,1,1,int
4829,412144,connSocketListen,1,connSocketListen,int connSocketListen (connListener*),socket.c,"static int connSocketListen(connListener *listener) {
    return listenToPort(listener);
}",348.0,350.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
4830,412152,connSocketBlockingConnect,1,connSocketBlockingConnect,"int connSocketBlockingConnect (connection*,char*,int,long long)",socket.c,"static int connSocketBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {
    int fd = anetTcpNonBlockConnect(NULL,addr,port);
    if (fd == -1) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = errno;
        return C_ERR;
    }

    if ((aeWait(fd, AE_WRITABLE, timeout) & AE_WRITABLE) == 0) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = ETIMEDOUT;
    }

    conn->fd = fd;
    conn->state = CONN_STATE_CONNECTED;
    return C_OK;
}",352.0,368.0,1.0,15.0,17.0,18,5,19,10,0,8,3,3,1,2,,0,8,8,4,4,int
4831,412226,connSocketSyncWrite,1,connSocketSyncWrite,"ssize_t connSocketSyncWrite (connection*,char*,ssize_t,long long)",socket.c,"static ssize_t connSocketSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncWrite(conn->fd, ptr, size, timeout);
}",374.0,376.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
4832,412242,connSocketSyncRead,1,connSocketSyncRead,"ssize_t connSocketSyncRead (connection*,char*,ssize_t,long long)",socket.c,"static ssize_t connSocketSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncRead(conn->fd, ptr, size, timeout);
}",378.0,380.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
4833,412258,connSocketSyncReadLine,1,connSocketSyncReadLine,"ssize_t connSocketSyncReadLine (connection*,char*,ssize_t,long long)",socket.c,"static ssize_t connSocketSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncReadLine(conn->fd, ptr, size, timeout);
}",382.0,384.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
4834,412579,createSortOperation,1,createSortOperation,"redisSortOperation createSortOperation (int,robj*)",sort.c,"redisSortOperation *createSortOperation(int type, robj *pattern) {
    redisSortOperation *so = zmalloc(sizeof(*so));
    so->type = type;
    so->pattern = pattern;
    return so;
}",38.0,43.0,1.0,1.0,6.0,7,4,7,3,0,1,1,1,0,1,,0,1,4,2,2,redisSortOperation
4835,412604,lookupKeyByPattern,1,lookupKeyByPattern,"robj lookupKeyByPattern (redisDb*,robj*,robj*)",sort.c,"robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
    char *p, *f, *k;
    sds spat, ssub;
    robj *keyobj, *fieldobj = NULL, *o;
    int prefixlen, sublen, postfixlen, fieldlen;

    /* If the pattern is ""#"" return the substitution object itself in order
     * to implement the ""SORT ... GET #"" feature. */
    spat = pattern->ptr;
    if (spat[0] == '#' && spat[1] == '\0') {
        incrRefCount(subst);
        return subst;
    }

    /* The substitution object may be specially encoded. If so we create
     * a decoded object on the fly. Otherwise getDecodedObject will just
     * increment the ref count, that we'll decrement later. */
    subst = getDecodedObject(subst);
    ssub = subst->ptr;

    /* If we can't find '*' in the pattern we return NULL as to GET a
     * fixed key does not make sense. */
    p = strchr(spat,'*');
    if (!p) {
        decrRefCount(subst);
        return NULL;
    }

    /* Find out if we're dealing with a hash dereference. */
  ...",61.0,133.0,1.0,23.0,73.0,50,11,76,16,1,15,11,10,0,15,,0,8,6,3,3,robj
4836,413033,sortCommandGeneric,1,sortCommandGeneric,"void sortCommandGeneric (client*,int)",sort.c,"void sortCommandGeneric(client *c, int readonly) {
    list *operations;
    unsigned int outputlen = 0;
    int desc = 0, alpha = 0;
    long limit_start = 0, limit_count = -1, start, end;
    int j, dontsort = 0, vectorlen;
    int getop = 0; /* GET operation counter */
    int int_conversion_error = 0;
    int syntax_error = 0;
    robj *sortval, *sortby = NULL, *storekey = NULL;
    redisSortObject *vector; /* Resulting vector to sort */
    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */
    /* Create a list of operations to perform for every sorted element.
     * Operations can be GET */
    operations = listCreate();
    listSetFreeMethod(operations,zfree);
    j = 2; /* options start at argv[2] */

    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);

    /* The SORT command has an SQL-alike syntax, parse it */
    while(j < c->argc) {
        int ...",189.0,610.0,1.0,4.0,422.0,208,26,203,29,0,38,31,46,4,27,,0,23,4,2,2,void
4837,414862,createSparklineSequence,1,createSparklineSequence,struct sequence createSparklineSequence (void),sparkline.c,"struct sequence *createSparklineSequence(void) {
    struct sequence *seq = zmalloc(sizeof(*seq));
    seq->length = 0;
    seq->labels = 0;
    seq->samples = NULL;
    seq->min = 0.0f;
    seq->max = 0.0f;
    return seq;
}",57.0,65.0,1.0,1.0,9.0,13,4,9,2,1,6,1,1,0,1,,0,6,2,1,1,struct sequence
4838,414901,sparklineSequenceAddSample,1,sparklineSequenceAddSample,"void sparklineSequenceAddSample (sequence*,double,char*)",sparkline.c,"void sparklineSequenceAddSample(struct sequence *seq, double value, char *label) {
    label = (label == NULL || label[0] == '\0') ? NULL : zstrdup(label);
    if (seq->length == 0) {
        seq->min = seq->max = value;
    } else {
        if (value < seq->min) seq->min = value;
        else if (value > seq->max) seq->max = value;
    }
    seq->samples = zrealloc(seq->samples,sizeof(struct sample)*(seq->length+1));
    seq->samples[seq->length].value = value;
    seq->samples[seq->length].label = label;
    seq->length++;
    if (label) seq->labels++;
}",68.0,81.0,1.0,1.0,14.0,33,11,23,5,1,14,3,3,1,2,,0,14,6,3,3,void
4839,415016,freeSparklineSequence,1,freeSparklineSequence,void freeSparklineSequence (sequence*),sparkline.c,"void freeSparklineSequence(struct sequence *seq) {
    int j;

    for (j = 0; j < seq->length; j++)
        zfree(seq->samples[j].label);
    zfree(seq->samples);
    zfree(seq);
}",84.0,91.0,1.0,1.0,8.0,4,3,5,2,1,4,2,2,1,2,,0,2,2,1,1,void
4840,415048,sparklineRenderRange,1,sparklineRenderRange,"sds sparklineRenderRange (sds,sequence*,int,int,int,int)",sparkline.c,"sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags) {
    int j;
    double relmax = seq->max - seq->min;
    int steps = charset_len*rows;
    int row = 0;
    char *chars = zmalloc(len);
    int loop = 1;
    int opt_fill = flags & SPARKLINE_FILL;
    int opt_log = flags & SPARKLINE_LOG_SCALE;

    if (opt_log) {
        relmax = log(relmax+1);
    } else if (relmax == 0) {
        relmax = 1;
    }

    while(loop) {
        loop = 0;
        memset(chars,' ',len);
        for (j = 0; j < len; j++) {
            struct sample *s = &seq->samples[j+offset];
            double relval = s->value - seq->min;
            int step;

            if (opt_log) relval = log(relval+1);
            step = (int) (relval*steps)/relmax;
            if (step < 0) step = 0;
            if (step >= steps) step = steps-1;

            if (row < rows) {
                /* Print the character needed to create the sparkline */
                int charidx...",100.0,165.0,1.0,27.0,66.0,56,15,72,21,1,14,10,23,1,4,,0,13,12,6,6,sds
4841,415332,sparklineRender,1,sparklineRender,"sds sparklineRender (sds,sequence*,int,int,int)",sparkline.c,"sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags) {
    int j;

    for (j = 0; j < seq->length; j += columns) {
        int sublen = (seq->length-j) < columns ? (seq->length-j) : columns;

        if (j != 0) output = sdscatlen(output,""\n"",1);
        output = sparklineRenderRange(output, seq, rows, j, sublen, flags);
    }
    return output;
}",168.0,178.0,1.0,1.0,11.0,13,6,21,7,1,5,3,4,1,2,,0,5,10,5,5,sds
4842,415521,streamNew,1,streamNew,stream* streamNew (void),t_stream.c,"stream *streamNew(void) {
    stream *s = zmalloc(sizeof(*s));
    s->rax = raxNew();
    s->length = 0;
    s->first_id.ms = 0;
    s->first_id.seq = 0;
    s->last_id.ms = 0;
    s->last_id.seq = 0;
    s->max_deleted_entry_id.seq = 0;
    s->max_deleted_entry_id.ms = 0;
    s->entries_added = 0;
    s->cgroups = NULL; /* Created on demand to save memory when not used. */
    return s;
}",67.0,80.0,1.0,1.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,stream
4843,415526,freeStream,1,freeStream,void freeStream (stream*),t_stream.c,"void freeStream(stream *s) {
    raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);
    if (s->cgroups)
        raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);
    zfree(s);
}",83.0,88.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4844,415531,streamLength,1,streamLength,long unsigned streamLength (robj*),t_stream.c,"unsigned long streamLength(const robj *subject) {
    stream *s = subject->ptr;
    return s->length;
}",91.0,94.0,1.0,1.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,unsigned long
4845,415536,streamReplyWithRange,1,streamReplyWithRange,"size_t streamReplyWithRange (client*,stream*,streamID*,streamID*,size_t,int,streamCG*,streamConsumer*,int,streamPropInfo*)",t_stream.c,"size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {
    void *arraylen_ptr = NULL;
    size_t arraylen = 0;
    streamIterator si;
    int64_t numfields;
    streamID id;
    int propagate_last_id = 0;
    int noack = flags & STREAM_RWR_NOACK;

    /* If the client is asking for some history, we serve it using a
     * different function, so that we return entries *solely* from its
     * own PEL. This ensures each consumer will always and only see
     * the history of messages delivered to it and not yet confirmed
     * as delivered. */
    if (group && (flags & STREAM_RWR_HISTORY)) {
        return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,
                                                   consumer);
    }

    if (!(flags & STREAM_RWR_RAWENTRIES))
        arraylen_ptr = addReplyDeferredLen(c);
    streamIteratorStart(&si,s,start,end,re...",1679.0,1796.0,1.0,24.0,118.0,0,0,0,0,2,0,1,1,0,0,,0,0,20,10,10,size_t
4846,415550,streamIteratorStart,1,streamIteratorStart,"void streamIteratorStart (streamIterator*,stream*,streamID*,streamID*,int)",t_stream.c,"void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {
    /* Initialize the iterator and translates the iteration start/stop
     * elements into a 128 big big-endian number. */
    if (start) {
        streamEncodeID(si->start_key,start);
    } else {
        si->start_key[0] = 0;
        si->start_key[1] = 0;
    }

    if (end) {
        streamEncodeID(si->end_key,end);
    } else {
        si->end_key[0] = UINT64_MAX;
        si->end_key[1] = UINT64_MAX;
    }

    /* Seek the correct node in the radix tree. */
    raxStart(&si->ri,s->rax);
    if (!rev) {
        if (start && (start->ms || start->seq)) {
            raxSeek(&si->ri,""<="",(unsigned char*)si->start_key,
                    sizeof(si->start_key));
            if (raxEOF(&si->ri)) raxSeek(&si->ri,""^"",NULL,0);
        } else {
            raxSeek(&si->ri,""^"",NULL,0);
        }
    } else {
        if (end && (end->ms || end->seq)) {
            raxSeek(&si->ri,""<="",(unsign...",1063.0,1104.0,1.0,1.0,42.0,0,0,0,0,4,0,1,1,0,0,,0,0,10,5,5,void
4847,415559,streamIteratorGetID,1,streamIteratorGetID,"int streamIteratorGetID (streamIterator*,streamID*,int64_t*)",t_stream.c,"int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {
    while(1) { /* Will stop when element > stop_key or end of radix tree. */
        /* If the current listpack is set to NULL, this is the start of the
         * iteration or the previous listpack was completely iterated.
         * Go to the next node. */
        if (si->lp == NULL || si->lp_ele == NULL) {
            if (!si->rev && !raxNext(&si->ri)) return 0;
            else if (si->rev && !raxPrev(&si->ri)) return 0;
            serverAssert(si->ri.key_len == sizeof(streamID));
            /* Get the master ID. */
            streamDecodeID(si->ri.key,&si->master_id);
            /* Get the master fields count. */
            si->lp = si->ri.data;
            si->lp_ele = lpFirst(si->lp);           /* Seek items count */
            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek deleted count. */
            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek num fields. */
            si->master_fi...",1109.0,1247.0,1.0,12.0,139.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,int
4848,415566,streamIteratorGetField,1,streamIteratorGetField,"void streamIteratorGetField (streamIterator*,unsigned char**,unsigned char**,int64_t*,int64_t*)",t_stream.c,"void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {
    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {
        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);
        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);
    } else {
        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);
        si->lp_ele = lpNext(si->lp,si->lp_ele);
    }
    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);
    si->lp_ele = lpNext(si->lp,si->lp_ele);
}",1255.0,1265.0,1.0,26.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
4849,415575,streamIteratorRemoveEntry,1,streamIteratorRemoveEntry,"void streamIteratorRemoveEntry (streamIterator*,streamID*)",t_stream.c,"void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
    unsigned char *lp = si->lp;
    int64_t aux;

    /* We do not really delete the entry here. Instead we mark it as
     * deleted by flagging it, and also incrementing the count of the
     * deleted entries in the listpack header.
     *
     * We start flagging: */
    int64_t flags = lpGetInteger(si->lp_flags);
    flags |= STREAM_ITEM_FLAG_DELETED;
    lp = lpReplaceInteger(lp,&si->lp_flags,flags);

    /* Change the valid/deleted entries count in the master entry. */
    unsigned char *p = lpFirst(lp);
    aux = lpGetInteger(p);

    if (aux == 1) {
        /* If this is the last element in the listpack, we can remove the whole
         * node. */
        lpFree(lp);
        raxRemove(si->stream->rax,si->ri.key,si->ri.key_len,NULL);
    } else {
        /* In the base case we alter the counters of valid/deleted entries. */
        lp = lpReplaceInteger(lp,&p,aux-1);
        p = lpNext(lp,p); /* Seek del...",1277.0,1328.0,1.0,20.0,52.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4850,415581,streamIteratorStop,1,streamIteratorStop,void streamIteratorStop (streamIterator*),t_stream.c,"void streamIteratorStop(streamIterator *si) {
    raxStop(&si->ri);
}",1333.0,1335.0,1.0,1.0,3.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,void
4851,415621,streamDecodeID,1,streamDecodeID,"void streamDecodeID (void*,streamID*)",t_stream.c,"void streamDecodeID(void *buf, streamID *id) {
    uint64_t e[2];
    memcpy(e,buf,sizeof(e));
    id->ms = ntohu64(e[0]);
    id->seq = ntohu64(e[1]);
}",373.0,378.0,1.0,13.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4852,415627,streamCompareID,1,streamCompareID,"int streamCompareID (streamID*,streamID*)",t_stream.c,"int streamCompareID(streamID *a, streamID *b) {
    if (a->ms > b->ms) return 1;
    else if (a->ms < b->ms) return -1;
    /* The ms part is the same. Check the sequence part. */
    else if (a->seq > b->seq) return 1;
    else if (a->seq < b->seq) return -1;
    /* Everything is the same: IDs are equal. */
    return 0;
}",381.0,389.0,1.0,1.0,9.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
4853,415633,streamFreeNACK,1,streamFreeNACK,void streamFreeNACK (streamNACK*),t_stream.c,"void streamFreeNACK(streamNACK *na) {
    zfree(na);
}",2462.0,2464.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4854,415638,streamIncrID,1,streamIncrID,int streamIncrID (streamID*),t_stream.c,"int streamIncrID(streamID *id) {
    int ret = C_OK;
    if (id->seq == UINT64_MAX) {
        if (id->ms == UINT64_MAX) {
            /* Special case where 'id' is the last possible streamID... */
            id->ms = id->seq = 0;
            ret = C_ERR;
        } else {
            id->ms++;
            id->seq = 0;
        }
    } else {
        id->seq++;
    }
    return ret;
}",99.0,114.0,1.0,14.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
4855,415643,streamDecrID,1,streamDecrID,int streamDecrID (streamID*),t_stream.c,"int streamDecrID(streamID *id) {
    int ret = C_OK;
    if (id->seq == 0) {
        if (id->ms == 0) {
            /* Special case where 'id' is the first possible streamID... */
            id->ms = id->seq = UINT64_MAX;
            ret = C_ERR;
        } else {
            id->ms--;
            id->seq = UINT64_MAX;
        }
    } else {
        id->seq--;
    }
    return ret;
}",119.0,134.0,1.0,14.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
4856,415656,streamDup,1,streamDup,robj* streamDup (robj*),t_stream.c,"robj *streamDup(robj *o) {
    robj *sobj;

    serverAssert(o->type == OBJ_STREAM);

    switch (o->encoding) {
        case OBJ_ENCODING_STREAM:
            sobj = createStreamObject();
            break;
        default:
            serverPanic(""Wrong encoding."");
            break;
    }

    stream *s;
    stream *new_s;
    s = o->ptr;
    new_s = sobj->ptr;

    raxIterator ri;
    uint64_t rax_key[2];
    raxStart(&ri, s->rax);
    raxSeek(&ri, ""^"", NULL, 0);
    size_t lp_bytes = 0;      /* Total bytes in the listpack. */
    unsigned char *lp = NULL; /* listpack pointer. */
    /* Get a reference to the listpack node. */
    while (raxNext(&ri)) {
        lp = ri.data;
        lp_bytes = lpBytes(lp);
        unsigned char *new_lp = zmalloc(lp_bytes);
        memcpy(new_lp, lp, lp_bytes);
        memcpy(rax_key, ri.key, sizeof(rax_key));
        raxInsert(new_s->rax, (unsigned char *)&rax_key, sizeof(rax_key),
                  new_lp, NULL);
    }
    new_s->length = s->le...",156.0,258.0,1.0,4.0,103.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
4857,415668,streamParseID,1,streamParseID,"int streamParseID (robj*,streamID*)",t_stream.c,"int streamParseID(const robj *o, streamID *id) {
    return streamGenericParseIDOrReply(NULL,o,id,0,0,NULL);
}",1936.0,1938.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4858,415674,createObjectFromStreamID,1,createObjectFromStreamID,robj* createObjectFromStreamID (streamID*),t_stream.c,"robj *createObjectFromStreamID(streamID *id) {
    return createObject(OBJ_STRING, createStreamIDString(id));
}",1405.0,1407.0,1.0,24.0,3.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,robj
4859,415679,streamAppendItem,1,streamAppendItem,"int streamAppendItem (stream*,robj**,int64_t,streamID*,streamID*,int)",t_stream.c,"int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id, int seq_given) {

    /* Generate the new entry ID. */
    streamID id;
    if (use_id) {
        if (seq_given) {
            id = *use_id;
        } else {
            /* The automatically generated sequence can be either zero (new
             * timestamps) or the incremented sequence of the last ID. In the
             * latter case, we need to prevent an overflow/advancing forward
             * in time. */
            if (s->last_id.ms == use_id->ms) {
                if (s->last_id.seq == UINT64_MAX) {
                    errno = EDOM;
                    return C_ERR;
                }
                id = s->last_id;
                id.seq++;
            } else {
                id = *use_id;
            }
        }
    } else {
        streamNextID(&s->last_id,&id);
    }

    /* Check that the new ID is greater than the last entry ID
     * or return an error. Automatical...",427.0,670.0,1.0,27.0,244.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
4860,415689,streamDeleteItem,1,streamDeleteItem,"int streamDeleteItem (stream*,streamID*)",t_stream.c,"int streamDeleteItem(stream *s, streamID *id) {
    int deleted = 0;
    streamIterator si;
    streamIteratorStart(&si,s,id,id,0);
    streamID myid;
    int64_t numfields;
    if (streamIteratorGetID(&si,&myid,&numfields)) {
        streamIteratorRemoveEntry(&si,&myid);
        deleted = 1;
    }
    streamIteratorStop(&si);
    return deleted;
}",1353.0,1365.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
4861,415709,streamTrimByLength,1,streamTrimByLength,"int64_t streamTrimByLength (stream*,long long,int)",t_stream.c,"int64_t streamTrimByLength(stream *s, long long maxlen, int approx) {
    streamAddTrimArgs args = {
        .trim_strategy = TRIM_STRATEGY_MAXLEN,
        .approx_trim = approx,
        .limit = approx ? 100 * server.stream_node_max_entries : 0,
        .maxlen = maxlen
    };
    return streamTrim(s, &args);
}",881.0,889.0,1.0,25.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int64_t
4862,415716,streamTrimByID,1,streamTrimByID,"int64_t streamTrimByID (stream*,streamID,int)",t_stream.c,"int64_t streamTrimByID(stream *s, streamID minid, int approx) {
    streamAddTrimArgs args = {
        .trim_strategy = TRIM_STRATEGY_MINID,
        .approx_trim = approx,
        .limit = approx ? 100 * server.stream_node_max_entries : 0,
        .minid = minid
    };
    return streamTrim(s, &args);
}",892.0,900.0,1.0,25.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int64_t
4863,415792,redis_strlcat,1,redis_strlcat,"size_t redis_strlcat (char*,char*,size_t)",strl.c,"size_t
redis_strlcat(char *dst, const char *src, size_t dsize)
{
    const char *odst = dst;
    const char *osrc = src;
    size_t n = dsize;
    size_t dlen;

    /* Find the end of dst and adjust bytes left but don't go past end. */
    while (n-- != 0 && *dst != '\0')
        dst++;
    dlen = dst - odst;
    n = dsize - dlen;

    if (n-- == 0)
        return(dlen + strlen(src));
    while (*src != '\0') {
        if (n != 0) {
            *dst++ = *src;
            n--;
        }
        src++;
    }
    *dst = '\0';

    return(dlen + (src - osrc));    /* count does not include NUL */
}",55.0,81.0,1.0,1.0,27.0,28,9,27,7,2,0,5,6,0,0,,0,0,6,3,3,size_t
4864,416231,syscheck,1,syscheck,int syscheck (void),syscheck.c,"int syscheck(void) {
    check *cur_check = checks;
    int ret = 1;
    sds err_msg = NULL;
    while (cur_check->check_fn) {
        int res = cur_check->check_fn(&err_msg);
        printf(""[%s]..."", cur_check->name);
        if (res == 0) {
            printf(""skipped\n"");
        } else if (res == 1) {
            printf(""OK\n"");
        } else {
            printf(""WARNING:\n"");
            printf(""%s\n"", err_msg);
            sdsfree(err_msg);
            ret = 0;
        }
        cur_check++;
    }

    return ret;
}",354.0,375.0,1.0,1.0,22.0,10,5,13,6,0,2,3,4,0,0,,0,2,2,1,1,int
4865,416446,hashTypeGetFromListpack,1,hashTypeGetFromListpack,"int hashTypeGetFromListpack (robj*,sds,unsigned char**,unsigned int*,long long*)",t_hash.c,"int hashTypeGetFromListpack(robj *o, sds field,
                            unsigned char **vstr,
                            unsigned int *vlen,
                            long long *vll)
{
    unsigned char *zl, *fptr = NULL, *vptr = NULL;

    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    zl = o->ptr;
    fptr = lpFirst(zl);
    if (fptr != NULL) {
        fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
        if (fptr != NULL) {
            /* Grab pointer to the value (fptr points to the field) */
            vptr = lpNext(zl, fptr);
            serverAssert(vptr != NULL);
        }
    }

    if (vptr != NULL) {
        *vstr = lpGetValue(vptr, vlen, vll);
        return 0;
    }

    return -1;
}",72.0,98.0,1.0,4.0,27.0,25,10,29,9,1,7,4,5,0,7,,0,5,10,5,5,int
4866,416550,hashTypeGetFromHashTable,1,hashTypeGetFromHashTable,"sds hashTypeGetFromHashTable (robj*,sds)",t_hash.c,"sds hashTypeGetFromHashTable(robj *o, sds field) {
    dictEntry *de;

    serverAssert(o->encoding == OBJ_ENCODING_HT);

    de = dictFind(o->ptr, field);
    if (de == NULL) return NULL;
    return dictGetVal(de);
}",103.0,111.0,1.0,4.0,9.0,9,7,8,4,0,3,2,2,0,3,,0,1,4,2,2,sds
4867,416592,hashTypeGetValue,1,hashTypeGetValue,"int hashTypeGetValue (robj*,sds,unsigned char**,unsigned int*,long long*)",t_hash.c,"int hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        *vstr = NULL;
        if (hashTypeGetFromListpack(o, field, vstr, vlen, vll) == 0)
            return C_OK;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        sds value;
        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {
            *vstr = (unsigned char*) value;
            *vlen = sdslen(value);
            return C_OK;
        }
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return C_ERR;
}",122.0,138.0,1.0,23.0,17.0,6,5,8,6,2,1,3,4,1,1,,0,1,10,5,5,int
4868,416720,hashTypeGetValueLength,1,hashTypeGetValueLength,"size_t hashTypeGetValueLength (robj*,sds)",t_hash.c,"size_t hashTypeGetValueLength(robj *o, sds field) {
    size_t len = 0;
    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK)
        len = vstr ? vlen : sdigits10(vll);

    return len;
}",157.0,167.0,1.0,58.0,11.0,10,4,17,9,0,2,2,2,1,2,,0,2,4,2,2,size_t
4869,417756,hashTypeConvertListpack,1,hashTypeConvertListpack,"void hashTypeConvertListpack (robj*,int)",t_hash.c,"void hashTypeConvertListpack(robj *o, int enc) {
    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    if (enc == OBJ_ENCODING_LISTPACK) {
        /* Nothing to do... */

    } else if (enc == OBJ_ENCODING_HT) {
        hashTypeIterator *hi;
        dict *dict;
        int ret;

        hi = hashTypeInitIterator(o);
        dict = dictCreate(&hashDictType);

        /* Presize the dict to avoid rehashing */
        dictExpand(dict,hashTypeLength(o));

        while (hashTypeNext(hi) != C_ERR) {
            sds key, value;

            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
            ret = dictAdd(dict, key, value);
            if (ret != DICT_OK) {
                sdsfree(key); sdsfree(value); /* Needed for gcc ASAN */
                hashTypeReleaseIterator(hi);  /* Needed for gcc ASAN */
                serverLogHexDump(LL_WARNING,""listpack with dup elements dump"",
                    o->ptr,...",455.0,493.0,1.0,4.0,39.0,7,6,2,2,0,1,2,2,0,1,,0,0,4,2,2,void
4870,418130,hashSdsFromListpackEntry,1,hashSdsFromListpackEntry,sds hashSdsFromListpackEntry (listpackEntry*),t_hash.c,"sds hashSdsFromListpackEntry(listpackEntry *e) {
    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);
}",551.0,553.0,1.0,1.0,3.0,5,2,4,1,0,6,1,1,0,2,,0,4,2,1,1,sds
4871,418151,hashReplyFromListpackEntry,1,hashReplyFromListpackEntry,"void hashReplyFromListpackEntry (client*,listpackEntry*)",t_hash.c,"void hashReplyFromListpackEntry(client *c, listpackEntry *e) {
    if (e->sval)
        addReplyBulkCBuffer(c, e->sval, e->slen);
    else
        addReplyBulkLongLong(c, e->lval);
}",556.0,561.0,1.0,1.0,6.0,3,1,4,2,0,4,2,2,1,1,,0,3,4,2,2,void
4872,418177,hashTypeRandomElement,1,hashTypeRandomElement,"void hashTypeRandomElement (robj*,long unsigned,listpackEntry*,listpackEntry*)",t_hash.c,"void hashTypeRandomElement(robj *hashobj, unsigned long hashsize, listpackEntry *key, listpackEntry *val) {
    if (hashobj->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictGetFairRandomKey(hashobj->ptr);
        sds s = dictGetKey(de);
        key->sval = (unsigned char*)s;
        key->slen = sdslen(s);
        if (val) {
            sds s = dictGetVal(de);
            val->sval = (unsigned char*)s;
            val->slen = sdslen(s);
        }
    } else if (hashobj->encoding == OBJ_ENCODING_LISTPACK) {
        lpRandomPair(hashobj->ptr, hashsize, key, val);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",567.0,583.0,1.0,29.0,17.0,16,4,16,5,0,9,3,4,0,5,,0,9,8,4,4,void
4873,418905,addHashFieldToReply,1,addHashFieldToReply,"void addHashFieldToReply (client*,robj*,sds)",t_hash.c,"static void addHashFieldToReply(client *c, robj *o, sds field) {
    if (o == NULL) {
        addReplyNull(c);
        return;
    }

    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK) {
        if (vstr) {
            addReplyBulkCBuffer(c, vstr, vlen);
        } else {
            addReplyBulkLongLong(c, vll);
        }
    } else {
        addReplyNull(c);
    }
}",722.0,741.0,1.0,58.0,20.0,8,3,18,9,0,3,4,5,1,3,,0,1,6,3,3,void
4874,419281,addHashIteratorCursorToReply,1,addHashIteratorCursorToReply,"void addHashIteratorCursorToReply (client*,hashTypeIterator*,int)",t_hash.c,"static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *vstr = NULL;
        unsigned int vlen = UINT_MAX;
        long long vll = LLONG_MAX;

        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);
        if (vstr)
            addReplyBulkCBuffer(c, vstr, vlen);
        else
            addReplyBulkLongLong(c, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds value = hashTypeCurrentFromHashTable(hi, what);
        addReplyBulkCBuffer(c, value, sdslen(value));
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",812.0,829.0,1.0,24.0,18.0,8,4,16,9,4,3,3,4,1,2,,0,1,6,3,3,void
4875,419362,genericHgetallCommand,1,genericHgetallCommand,"void genericHgetallCommand (client*,int)",t_hash.c,"void genericHgetallCommand(client *c, int flags) {
    robj *o;
    hashTypeIterator *hi;
    int length, count = 0;

    robj *emptyResp = (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) ?
        shared.emptymap[c->resp] : shared.emptyarray;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],emptyResp))
        == NULL || checkType(c,o,OBJ_HASH)) return;

    /* We return a map if the user requested keys and values, like in the
     * HGETALL case. Otherwise to use a flat array makes more sense. */
    length = hashTypeLength(o);
    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) {
        addReplyMapLen(c, length);
    } else {
        addReplyArrayLen(c, length);
    }

    hi = hashTypeInitIterator(o);
    while (hashTypeNext(hi) != C_ERR) {
        if (flags & OBJ_HASH_KEY) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);
            count++;
        }
        if (flags & OBJ_HASH_VALUE) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);
     ...",831.0,867.0,1.0,31.0,37.0,35,16,37,9,0,12,7,9,4,10,,0,7,4,2,2,void
4876,419658,hrandfieldReplyWithListpack,1,hrandfieldReplyWithListpack,"void hrandfieldReplyWithListpack (client*,unsigned int,listpackEntry*,listpackEntry*)",t_hash.c,"static void hrandfieldReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    for (unsigned long i = 0; i < count; i++) {
        if (vals && c->resp > 2)
            addReplyArrayLen(c,2);
        if (keys[i].sval)
            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);
        else
            addReplyBulkLongLong(c, keys[i].lval);
        if (vals) {
            if (vals[i].sval)
                addReplyBulkCBuffer(c, vals[i].sval, vals[i].slen);
            else
                addReplyBulkLongLong(c, vals[i].lval);
        }
    }
}",899.0,914.0,1.0,1.0,16.0,17,7,21,5,1,4,6,11,1,3,,0,1,8,4,4,void
4877,419749,hrandfieldWithCountCommand,1,hrandfieldWithCountCommand,"void hrandfieldWithCountCommand (client*,long,int)",t_hash.c,"void hrandfieldWithCountCommand(client *c, long l, int withvalues) {
    unsigned long count, size;
    int uniq = 1;
    robj *hash;

    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))
        == NULL || checkType(c,hash,OBJ_HASH)) return;
    size = hashTypeLength(hash);

    if(l >= 0) {
        count = (unsigned long) l;
    } else {
        count = -l;
        uniq = 0;
    }

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time.
     * This case is trivial and can be served without auxiliary data
     * structures. This case is the only one that also needs to return the
     * elements in random order. */
    if (!uniq || count == 1) {
        if (withvalues && c->resp == 2)
            addReplyArrayLen(c, count*2);
  ...",926.0,1130.0,1.0,36.0,205.0,100,24,141,21,0,63,26,53,12,54,,0,35,6,3,3,void
4878,420556,listTypeTryConvertListpack,1,listTypeTryConvertListpack,"void listTypeTryConvertListpack (robj*,robj**,int,int,beforeConvertCB,void*)",t_list.c,"static void listTypeTryConvertListpack(robj *o, robj **argv, int start, int end,
                                       beforeConvertCB fn, void *data)
{
    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    size_t add_bytes = 0;
    size_t add_length = 0;

    if (argv) {
        for (int i = start; i <= end; i++) {
            if (!sdsEncodedObject(argv[i]))
                continue;
            add_bytes += sdslen(argv[i]->ptr);
        }
        add_length = end - start + 1;
    }

    if (quicklistNodeExceedsLimit(server.list_max_listpack_size,
            lpBytes(o->ptr) + add_bytes, lpLength(o->ptr) + add_length))
    {
        /* Invoke callback before conversion. */
        if (fn) fn(data);

        quicklist *ql = quicklistCreate();
        quicklistSetOptions(ql, server.list_max_listpack_size, server.list_compress_depth);

        /* Append listpack to quicklist if it's not empty, otherwise release it. */
        if (lpLength(o->ptr))
            quicklistAppendLi...",42.0,76.0,1.0,4.0,35.0,39,15,37,11,0,9,8,12,4,9,,0,5,12,6,6,void
4879,420710,listTypeTryConvertQuicklist,1,listTypeTryConvertQuicklist,"void listTypeTryConvertQuicklist (robj*,int,beforeConvertCB,void*)",t_list.c,"static void listTypeTryConvertQuicklist(robj *o, int shrinking, beforeConvertCB fn, void *data) {
    serverAssert(o->encoding == OBJ_ENCODING_QUICKLIST);

    size_t sz_limit;
    unsigned int count_limit;
    quicklist *ql = o->ptr;

    /* A quicklist can be converted to listpack only if it has only one packed node. */
    if (ql->len != 1 || ql->head->container != QUICKLIST_NODE_CONTAINER_PACKED)
        return;

    /* Check the length or size of the quicklist is below the limit. */
    quicklistNodeLimit(server.list_max_listpack_size, &sz_limit, &count_limit);
    if (shrinking) {
        sz_limit /= 2;
        count_limit /= 2;
    }
    if (ql->head->sz > sz_limit || ql->count > count_limit) return;

    /* Invoke callback before conversion. */
    if (fn) fn(data);

    /* Extract the listpack from the unique quicklist node,
     * then reset it and release the quicklist. */
    o->ptr = ql->head->entry;
    ql->head->entry = NULL;
    quicklistRelease(ql);
    o->encoding ...",87.0,115.0,1.0,4.0,29.0,34,13,23,9,1,9,5,5,4,3,,0,6,8,4,4,void
4880,420825,listTypeTryConversionRaw,1,listTypeTryConversionRaw,"void listTypeTryConversionRaw (robj*,list_conv_type,robj**,int,int,beforeConvertCB,void*)",t_list.c,"static void listTypeTryConversionRaw(robj *o, list_conv_type lct,
                                     robj **argv, int start, int end,
                                     beforeConvertCB fn, void *data)
{
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        if (lct == LIST_CONV_GROWING) return; /* Growing has nothing to do with quicklist */
        listTypeTryConvertQuicklist(o, lct == LIST_CONV_SHRINKING, fn, data);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        if (lct == LIST_CONV_SHRINKING) return; /* Shrinking has nothing to do with listpack */
        listTypeTryConvertListpack(o, argv, start, end, fn, data);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",132.0,145.0,1.0,23.0,14.0,4,2,8,6,0,1,3,4,0,1,,0,0,14,7,7,void
4881,421090,listPopSaver,1,listPopSaver,"void* listPopSaver (unsigned char*,size_t)",t_list.c,"void *listPopSaver(unsigned char *data, size_t sz) {
    return createStringObject((char*)data,sz);
}",191.0,193.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,void*
4882,421974,listTypeReplaceAtIndex,1,listTypeReplaceAtIndex,"int listTypeReplaceAtIndex (robj*,int,robj*)",t_list.c,"int listTypeReplaceAtIndex(robj *o, int index, robj *value) {
    value = getDecodedObject(value);
    sds vstr = value->ptr;
    size_t vlen = sdslen(vstr);
    int replaced = 0;

    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        replaced = quicklistReplaceAtIndex(ql, index, vstr, vlen);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p = lpSeek(o->ptr,index);
        if (p) {
            o->ptr = lpReplace(o->ptr, &p, (unsigned char *)vstr, vlen);
            replaced = 1;
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }

    decrRefCount(value);
    return replaced;
}",384.0,405.0,1.0,23.0,22.0,10,3,17,7,0,4,2,2,0,4,,0,3,6,3,3,int
4883,422410,pushGenericCommand,1,pushGenericCommand,"void pushGenericCommand (client*,int,int)",t_list.c,"void pushGenericCommand(client *c, int where, int xx) {
    int j;

    robj *lobj = lookupKeyWrite(c->db, c->argv[1]);
    if (checkType(c,lobj,OBJ_LIST)) return;
    if (!lobj) {
        if (xx) {
            addReply(c, shared.czero);
            return;
        }

        lobj = createListListpackObject();
        dbAdd(c->db,c->argv[1],lobj);
    }

    listTypeTryConversionAppend(lobj,c->argv,2,c->argc-1,NULL,NULL);
    for (j = 2; j < c->argc; j++) {
        listTypePush(lobj,c->argv[j],where);
        server.dirty++;
    }

    addReplyLongLong(c, listTypeLength(lobj));

    char *event = (where == LIST_HEAD) ? ""lpush"" : ""rpush"";
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
}",486.0,512.0,1.0,25.0,27.0,31,11,36,9,0,23,5,6,2,11,,0,16,6,3,3,void
4884,423019,listPopRangeAndReplyWithKey,1,listPopRangeAndReplyWithKey,"void listPopRangeAndReplyWithKey (client*,robj*,robj*,int,long,int,int*)",t_list.c,"void listPopRangeAndReplyWithKey(client *c, robj *o, robj *key, int where, long count, int signal, int *deleted) {
    long llen = listTypeLength(o);
    long rangelen = (count > llen) ? llen : count;
    long rangestart = (where == LIST_HEAD) ? 0 : -rangelen;
    long rangeend = (where == LIST_HEAD) ? rangelen - 1 : -1;
    int reverse = (where == LIST_HEAD) ? 0 : 1;

    /* We return key-name just once, and an array of elements */
    addReplyArrayLen(c, 2);
    addReplyBulk(c, key);
    addListRangeReply(c, o, rangestart, rangeend, reverse);

    /* Pop these elements. */
    listTypeDelRange(o, rangestart, rangelen);
    /* Maintain the notifications and dirty. */
    listElementsRemoved(c, key, where, o, rangelen, signal, deleted);
}",659.0,675.0,1.0,32.0,17.0,16,6,33,12,2,6,1,1,0,6,,0,1,14,7,7,void
4885,423105,addListQuicklistRangeReply,1,addListQuicklistRangeReply,"void addListQuicklistRangeReply (client*,robj*,int,int,int)",t_list.c,"void addListQuicklistRangeReply(client *c, robj *o, int from, int rangelen, int reverse) {
    /* Return the result in form of a multi-bulk reply */
    addReplyArrayLen(c,rangelen);

    int direction = reverse ? AL_START_TAIL : AL_START_HEAD;
    quicklistIter *iter = quicklistGetIteratorAtIdx(o->ptr, direction, from);
    while(rangelen--) {
        quicklistEntry qe;
        serverAssert(quicklistNext(iter, &qe)); /* fail on corrupt data */
        if (qe.value) {
            addReplyBulkCBuffer(c,qe.value,qe.sz);
        } else {
            addReplyBulkLongLong(c,qe.longval);
        }
    }
    quicklistReleaseIterator(iter);
}",680.0,696.0,1.0,30.0,17.0,13,9,16,8,0,9,3,4,1,6,,0,4,10,5,5,void
4886,423181,addListListpackRangeReply,1,addListListpackRangeReply,"void addListListpackRangeReply (client*,robj*,int,int,int)",t_list.c,"void addListListpackRangeReply(client *c, robj *o, int from, int rangelen, int reverse) {
    unsigned char *p = lpSeek(o->ptr, from);
    unsigned char *vstr;
    unsigned int vlen;
    long long lval;

    /* Return the result in form of a multi-bulk reply */
    addReplyArrayLen(c,rangelen);

    while(rangelen--) {
        serverAssert(p); /* fail on corrupt data */
        vstr = lpGetValue(p, &vlen, &lval);
        if (vstr) {
            addReplyBulkCBuffer(c,vstr,vlen);
        } else {
            addReplyBulkLongLong(c,lval);
        }
        p = reverse ? lpPrev(o->ptr,p) : lpNext(o->ptr,p);
    }
}",701.0,720.0,1.0,8.0,20.0,14,8,22,9,0,7,3,4,0,7,,0,4,10,5,5,void
4887,423694,mpopGenericCommand,1,mpopGenericCommand,"void mpopGenericCommand (client*,robj**,int,int,long)",t_list.c,"void mpopGenericCommand(client *c, robj **keys, int numkeys, int where, long count) {
    int j;
    robj *o;
    robj *key;

    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db, key);

        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c, o, OBJ_LIST)) return;

        long llen = listTypeLength(o);
        /* Empty list, move to next key. */
        if (llen == 0) continue;

        /* Pop a range of elements in a nested arrays way. */
        listPopRangeAndReplyWithKey(c, o, key, where, count, 1, NULL);

        /* Replicate it as [LR]POP COUNT. */
        robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);
        rewriteClientCommandVector(c, 3,
                                   (where == LIST_HEAD) ? shared.lpop : shared.rpop,
                                   key, count_obj);
        decrRefCount(count_obj);
        return;
    }

    /* Look like we ...",834.0,866.0,1.0,28.0,33.0,16,8,35,12,0,9,7,8,1,8,,0,5,10,5,5,void
4888,424749,lmoveHandlePush,1,lmoveHandlePush,"void lmoveHandlePush (client*,robj*,robj*,robj*,int)",t_list.c,"void lmoveHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value,
                     int where) {
    /* Create the list if the key does not exist */
    if (!dstobj) {
        dstobj = createListListpackObject();
        dbAdd(c->db,dstkey,dstobj);
    }
    signalModifiedKey(c,c->db,dstkey);
    listTypeTryConversionAppend(dstobj,&value,0,0,NULL,NULL);
    listTypePush(dstobj,value,where);
    notifyKeyspaceEvent(NOTIFY_LIST,
                        where == LIST_HEAD ? ""lpush"" : ""rpush"",
                        dstkey,
                        c->db->id);
    /* Always send the pushed value to the client. */
    addReplyBulk(c,value);
}",1103.0,1119.0,1.0,24.0,17.0,10,7,20,6,0,10,2,2,0,7,,0,4,10,5,5,void
4889,424812,getListPositionFromObjectOrReply,1,getListPositionFromObjectOrReply,"int getListPositionFromObjectOrReply (client*,robj*,int*)",t_list.c,"int getListPositionFromObjectOrReply(client *c, robj *arg, int *position) {
    if (strcasecmp(arg->ptr,""right"") == 0) {
        *position = LIST_TAIL;
    } else if (strcasecmp(arg->ptr,""left"") == 0) {
        *position = LIST_HEAD;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return C_ERR;
    }
    return C_OK;
}",1121.0,1131.0,1.0,20.0,11.0,4,4,2,2,1,0,2,2,0,0,,0,0,6,3,3,int
4890,424889,lmoveGenericCommand,1,lmoveGenericCommand,"void lmoveGenericCommand (client*,int,int)",t_list.c,"void lmoveGenericCommand(client *c, int wherefrom, int whereto) {
    robj *sobj, *value;
    if ((sobj = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))
        == NULL || checkType(c,sobj,OBJ_LIST)) return;

    if (listTypeLength(sobj) == 0) {
        /* This may only happen after loading very old RDB files. Recent
         * versions of Redis delete keys of empty lists. */
        addReplyNull(c);
    } else {
        robj *dobj = lookupKeyWrite(c->db,c->argv[2]);
        robj *touchedkey = c->argv[1];

        if (checkType(c,dobj,OBJ_LIST)) return;
        value = listTypePop(sobj,wherefrom);
        serverAssert(value); /* assertion for valgrind (avoid NPD) */
        lmoveHandlePush(c,c->argv[2],dobj,value,whereto);
        listElementsRemoved(c,touchedkey,wherefrom,sobj,1,1,NULL);

        /* listTypePop returns an object with its refcount incremented */
        decrRefCount(value);

        if (c->cmd->proc == blmoveCommand) {
            rewriteClientCommandVect...",1142.0,1172.0,1.0,36.0,31.0,9,6,10,4,0,6,3,3,5,4,,0,5,6,3,3,void
4891,425123,blockingPopGenericCommand,1,blockingPopGenericCommand,"void blockingPopGenericCommand (client*,robj**,int,int,int,long)",t_list.c,"void blockingPopGenericCommand(client *c, robj **keys, int numkeys, int where, int timeout_idx, long count) {
    robj *o;
    robj *key;
    mstime_t timeout;
    int j;

    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)
        != C_OK) return;

    /* Traverse all input keys, we take action only based on one key. */
    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db, key);

        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c, o, OBJ_LIST)) return;

        long llen = listTypeLength(o);
        /* Empty list, move to next key. */
        if (llen == 0) continue;

        if (count != -1) {
            /* BLMPOP, non empty list, like a normal [LR]POP with count option.
             * The difference here we pop a range of elements in a nested arrays way. */
            listPopRangeAndReplyWithKey(c, o, key, where, count, 1, NULL);

            /* Replicat...",1212.0,1275.0,1.0,68.0,64.0,35,16,67,16,1,21,10,12,4,18,,0,9,12,6,6,void
4892,425382,blmoveGenericCommand,1,blmoveGenericCommand,"void blmoveGenericCommand (client*,int,int,mstime_t)",t_list.c,"void blmoveGenericCommand(client *c, int wherefrom, int whereto, mstime_t timeout) {
    robj *key = lookupKeyWrite(c->db, c->argv[1]);
    if (checkType(c,key,OBJ_LIST)) return;

    if (key == NULL) {
        if (c->flags & CLIENT_DENY_BLOCKING) {
            /* Blocking against an empty list when blocking is not allowed
             * returns immediately. */
            addReplyNull(c);
        } else {
            /* The list is empty and the client blocks. */
            blockForKeys(c,BLOCKED_LIST,c->argv + 1,1,timeout,0);
        }
    } else {
        /* The list exists and has elements, so
         * the regular lmoveCommand is executed. */
        serverAssertWithInfo(c,key,listTypeLength(key) > 0);
        lmoveGenericCommand(c,wherefrom,whereto);
    }
}",1287.0,1306.0,1.0,24.0,20.0,8,6,9,3,0,6,4,5,2,3,,0,5,8,4,4,void
4893,425567,lmpopGenericCommand,1,lmpopGenericCommand,"void lmpopGenericCommand (client*,int,int)",t_list.c,"void lmpopGenericCommand(client *c, int numkeys_idx, int is_block) {
    long j;
    long numkeys = 0;      /* Number of keys. */
    int where = 0;         /* HEAD for LEFT, TAIL for RIGHT. */
    long count = -1;       /* Reply will consist of up to count elements, depending on the list's length. */

    /* Parse the numkeys. */
    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;

    /* Parse the where. where_idx: the index of where in the c->argv. */
    long where_idx = numkeys_idx + numkeys + 1;
    if (where_idx >= c->argc) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    if (getListPositionFromObjectOrReply(c, c->argv[where_idx], &where) != C_OK)
        return;

    /* Parse the optional arguments. */
    for (j = where_idx + 1; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->arg...",1333.0,1378.0,1.0,87.0,46.0,46,15,47,12,0,13,9,12,8,5,,0,11,6,3,3,void
4894,425787,sunionDiffGenericCommand,1,sunionDiffGenericCommand,"void sunionDiffGenericCommand (client*,robj**,int,robj*,int)",t_set.c,"void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
                              robj *dstkey, int op) {
    robj **sets = zmalloc(sizeof(robj*)*setnum);
    setTypeIterator *si;
    robj *dstset = NULL;
    char *str;
    size_t len;
    int64_t llval;
    int encoding;
    int j, cardinality = 0;
    int diff_algo = 1;
    int sameset = 0; 

    for (j = 0; j < setnum; j++) {
        robj *setobj = lookupKeyRead(c->db, setkeys[j]);
        if (!setobj) {
            sets[j] = NULL;
            continue;
        }
        if (checkType(c,setobj,OBJ_SET)) {
            zfree(sets);
            return;
        }
        sets[j] = setobj;
        if (j > 0 && sets[0] == sets[j]) {
            sameset = 1; 
        }
    }

    /* Select what DIFF algorithm to use.
     *
     * Algorithm 1 is O(N*M) where N is the size of the element first set
     * and M the total number of sets.
     *
     * Algorithm 2 is O(N) where N is the total number of elements in all
     ...",1482.0,1650.0,1.0,31.0,169.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
4895,425839,setTypeMaybeConvert,1,setTypeMaybeConvert,"void setTypeMaybeConvert (robj*,size_t)",t_set.c,"void setTypeMaybeConvert(robj *set, size_t size_hint) {
    if ((set->encoding == OBJ_ENCODING_LISTPACK && size_hint > server.set_max_listpack_entries)
        || (set->encoding == OBJ_ENCODING_INTSET && size_hint > server.set_max_intset_entries))
    {
        setTypeConvertAndExpand(set, OBJ_ENCODING_HT, size_hint, 1);
    }
}",61.0,67.0,1.0,26.0,7.0,11,6,8,3,0,1,2,2,0,1,,0,0,4,2,2,void
4896,425881,intsetMaxEntries,1,intsetMaxEntries,size_t intsetMaxEntries (void),t_set.c,"static size_t intsetMaxEntries(void) {
    size_t max_entries = server.set_max_intset_entries;
    /* limit to 1G entries due to intset internals. */
    if (max_entries >= 1<<30) max_entries = 1<<30;
    return max_entries;
}",70.0,75.0,1.0,1.0,6.0,6,4,5,2,2,0,2,2,0,0,,0,0,2,1,1,size_t
4897,425906,maybeConvertIntset,1,maybeConvertIntset,void maybeConvertIntset (robj*),t_set.c,"static void maybeConvertIntset(robj *subject) {
    serverAssert(subject->encoding == OBJ_ENCODING_INTSET);
    if (intsetLen(subject->ptr) > intsetMaxEntries())
        setTypeConvert(subject,OBJ_ENCODING_HT);
}",78.0,82.0,1.0,4.0,5.0,8,7,3,1,0,4,2,2,2,4,,0,2,2,1,1,void
4898,425942,maybeConvertToIntset,1,maybeConvertToIntset,void maybeConvertToIntset (robj*),t_set.c,"static void maybeConvertToIntset(robj *set) {
    if (set->encoding == OBJ_ENCODING_INTSET) return; /* already intset */
    if (setTypeSize(set) > intsetMaxEntries()) return; /* can't use intset */
    intset *is = intsetNew();
    char *str;
    size_t len;
    int64_t llval;
    setTypeIterator *si = setTypeInitIterator(set);
    while (setTypeNext(si, &str, &len, &llval) != -1) {
        if (str) {
            /* If the element is returned as a string, we may be able to convert
             * it to integer. This happens for OBJ_ENCODING_HT. */
            serverAssert(string2ll(str, len, (long long *)&llval));
        }
        uint8_t success = 0;
        is = intsetAdd(is, llval, &success);
        serverAssert(success);
    }
    setTypeReleaseIterator(si);
    freeSetObject(set); /* frees the internals but not robj itself */
    set->ptr = is;
    set->encoding = OBJ_ENCODING_INTSET;
}",87.0,109.0,1.0,25.0,23.0,27,11,25,7,0,11,5,6,3,11,,0,6,2,1,1,void
4899,427392,setTypePopRandom,1,setTypePopRandom,robj setTypePopRandom (robj*),t_set.c,"robj *setTypePopRandom(robj *set) {
    robj *obj;
    if (set->encoding == OBJ_ENCODING_LISTPACK) {
        /* Find random and delete it without re-seeking the listpack. */
        unsigned int i = 0;
        unsigned char *p = lpNextRandom(set->ptr, lpFirst(set->ptr), &i, 1, 0);
        unsigned int len = 0; /* initialize to silence warning */
        long long llele = 0; /* initialize to silence warning */
        char *str = (char *)lpGetValue(p, &len, &llele);
        if (str)
            obj = createStringObject(str, len);
        else
            obj = createStringObjectFromLongLong(llele);
        set->ptr = lpDelete(set->ptr, p, NULL);
    } else {
        char *str;
        size_t len = 0;
        int64_t llele = 0;
        int encoding = setTypeRandomElement(set, &str, &len, &llele);
        if (str)
            obj = createStringObject(str, len);
        else
            obj = createStringObjectFromLongLong(llele);
        setTypeRemoveAux(set, str, len, llele, encoding ...",452.0,478.0,1.0,25.0,27.0,17,5,21,8,0,5,3,4,0,5,,0,5,2,1,1,robj
4900,428719,spopWithCountCommand,1,spopWithCountCommand,void spopWithCountCommand (client*),t_set.c,"void spopWithCountCommand(client *c) {
    long l;
    unsigned long count, size;
    robj *set;

    /* Get the count argument */
    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
    count = (unsigned long) l;

    /* Make sure a key with the name inputted exists, and that it's type is
     * indeed a set. Otherwise, return nil */
    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.emptyset[c->resp]))
        == NULL || checkType(c,set,OBJ_SET)) return;

    /* If count is zero, serve an empty set ASAP to avoid special
     * cases later. */
    if (count == 0) {
        addReply(c,shared.emptyset[c->resp]);
        return;
    }

    size = setTypeSize(set);

    /* Generate an SPOP keyspace notification */
    notifyKeyspaceEvent(NOTIFY_SET,""spop"",c->argv[1],c->db->id);
    server.dirty += (count >= size) ? size : count;

    /* CASE 1:
     * The number of requested elements is greater than or equal to
     * the number of elements inside the ...",761.0,966.0,1.0,66.0,206.0,118,22,134,24,0,48,12,21,6,29,,0,31,2,1,1,void
4901,429649,srandmemberWithCountCommand,1,srandmemberWithCountCommand,void srandmemberWithCountCommand (client*),t_set.c,"void srandmemberWithCountCommand(client *c) {
    long l;
    unsigned long count, size;
    int uniq = 1;
    robj *set;
    char *str;
    size_t len;
    int64_t llele;

    dict *d;

    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;
    if (l >= 0) {
        count = (unsigned long) l;
    } else {
        /* A negative count means: return the same elements multiple times
         * (i.e. don't remove the extracted element after every extraction). */
        count = -l;
        uniq = 0;
    }

    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))
        == NULL || checkType(c,set,OBJ_SET)) return;
    size = setTypeSize(set);

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time...",1020.0,1222.0,1.0,82.0,203.0,120,26,153,25,0,50,27,53,10,44,,0,27,2,1,1,void
4902,430333,qsortCompareSetsByCardinality,1,qsortCompareSetsByCardinality,"int qsortCompareSetsByCardinality (void*,void*)",t_set.c,"int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
    return 0;
}",1251.0,1255.0,1.0,1.0,5.0,11,5,4,2,0,4,3,3,4,4,,0,4,4,2,2,int
4903,430372,qsortCompareSetsByRevCardinality,1,qsortCompareSetsByRevCardinality,"int qsortCompareSetsByRevCardinality (void*,void*)",t_set.c,"int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
    unsigned long first = o1 ? setTypeSize(o1) : 0;
    unsigned long second = o2 ? setTypeSize(o2) : 0;

    if (first < second) return 1;
    if (first > second) return -1;
    return 0;
}",1259.0,1267.0,1.0,1.0,9.0,13,7,14,6,0,2,3,3,0,2,,0,2,4,2,2,int
4904,430425,sinterGenericCommand,1,sinterGenericCommand,"void sinterGenericCommand (client*,robj**,long unsigned,robj*,int,long unsigned)",t_set.c,"void sinterGenericCommand(client *c, robj **setkeys,
                          unsigned long setnum, robj *dstkey,
                          int cardinality_only, unsigned long limit) {
    robj **sets = zmalloc(sizeof(robj*)*setnum);
    setTypeIterator *si;
    robj *dstset = NULL;
    char *str;
    size_t len;
    int64_t intobj;
    void *replylen = NULL;
    unsigned long j, cardinality = 0;
    int encoding, empty = 0;

    for (j = 0; j < setnum; j++) {
        robj *setobj = lookupKeyRead(c->db, setkeys[j]);
        if (!setobj) {
            /* A NULL is considered an empty set */
            empty += 1;
            sets[j] = NULL;
            continue;
        }
        if (checkType(c,setobj,OBJ_SET)) {
            zfree(sets);
            return;
        }
        sets[j] = setobj;
    }

    /* Set intersection with an empty set always results in an empty set.
     * Return ASAP if there is an empty set. */
    if (empty > 0) {
        zfree(sets);
        if (dstkey) ...",1277.0,1438.0,1.0,31.0,162.0,53,18,78,23,0,20,21,34,5,16,,0,12,12,6,6,void
4905,431865,streamParseStrictIDOrReply,1,streamParseStrictIDOrReply,"int streamParseStrictIDOrReply (client*,robj*,streamID*,uint64_t,int*)",t_stream.c,"int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given) {
    return streamGenericParseIDOrReply(c,o,id,missing_seq,1,seq_given);
}",1949.0,1951.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
4906,432117,streamNextID,1,streamNextID,"void streamNextID (streamID*,streamID*)",t_stream.c,"void streamNextID(streamID *last_id, streamID *new_id) {
    uint64_t ms = commandTimeSnapshot();
    if (ms > last_id->ms) {
        new_id->ms = ms;
        new_id->seq = 0;
    } else {
        *new_id = *last_id;
        streamIncrID(new_id);
    }
}",140.0,149.0,1.0,1.0,10.0,7,3,6,3,0,4,2,2,1,1,,0,4,4,2,2,void
4907,432586,lpGetIntegerIfValid,1,lpGetIntegerIfValid,"int64_t lpGetIntegerIfValid (unsigned char*,int*)",t_stream.c,"static inline int64_t lpGetIntegerIfValid(unsigned char *ele, int *valid) {
    int64_t v;
    unsigned char *e = lpGet(ele,&v,NULL);
    if (e == NULL) {
        if (valid)
            *valid = 1;
        return v;
    }
    /* The following code path should never be used for how listpacks work:
     * they should always be able to store an int64_t value in integer
     * encoded form. However the implementation may change. */
    long long ll;
    int ret = string2ll((char*)e,v,&ll);
    if (valid)
        *valid = ret;
    else
        serverAssert(ret != 0);
    v = ll;
    return v;
}",266.0,285.0,1.0,8.0,20.0,11,5,19,7,9,2,4,5,0,2,,0,2,4,2,2,int64_t
4908,432656,lpGetEdgeStreamID,1,lpGetEdgeStreamID,"int lpGetEdgeStreamID (unsigned char*,int,streamID*,streamID*)",t_stream.c,"int lpGetEdgeStreamID(unsigned char *lp, int first, streamID *master_id, streamID *edge_id)
{
   if (lp == NULL)
       return 0;

   unsigned char *lp_ele;

   /* We need to seek either the first or the last entry depending
    * on the direction of the iteration. */
   if (first) {
       /* Get the master fields count. */
       lp_ele = lpFirst(lp);        /* Seek items count */
       lp_ele = lpNext(lp, lp_ele); /* Seek deleted count. */
       lp_ele = lpNext(lp, lp_ele); /* Seek num fields. */
       int64_t master_fields_count = lpGetInteger(lp_ele);
       lp_ele = lpNext(lp, lp_ele); /* Seek first field. */

       /* If we are iterating in normal order, skip the master fields
        * to seek the first actual entry. */
       for (int64_t i = 0; i < master_fields_count; i++)
           lp_ele = lpNext(lp, lp_ele);

       /* If we are going forward, skip the previous entry's
        * lp-count field (or in case of the master entry, the zero
        * term field) */
    ...",291.0,346.0,1.0,37.0,56.0,20,6,44,9,0,12,5,7,0,10,,0,10,8,4,4,int
4909,432802,streamLogListpackContent,1,streamLogListpackContent,void streamLogListpackContent (unsigned char*),t_stream.c,"void streamLogListpackContent(unsigned char *lp) {
    unsigned char *p = lpFirst(lp);
    while(p) {
        unsigned char buf[LP_INTBUF_SIZE];
        int64_t v;
        unsigned char *ele = lpGet(p,&v,buf);
        serverLog(LL_WARNING,""- [%d] '%.*s'"", (int)v, (int)v, ele);
        p = lpNext(lp,p);
    }
}",350.0,359.0,1.0,26.0,10.0,9,6,14,6,0,4,2,2,0,4,,0,3,2,1,1,void
4910,432855,streamEncodeID,1,streamEncodeID,"void streamEncodeID (void*,streamID*)",t_stream.c,"void streamEncodeID(void *buf, streamID *id) {
    uint64_t e[2];
    e[0] = htonu64(id->ms);
    e[1] = htonu64(id->seq);
    memcpy(buf,e,sizeof(e));
}",363.0,368.0,1.0,11.0,6.0,9,4,9,3,0,6,1,1,0,2,,0,6,4,2,2,void
4911,433807,streamTrim,1,streamTrim,"int64_t streamTrim (stream*,streamAddTrimArgs*)",t_stream.c,"int64_t streamTrim(stream *s, streamAddTrimArgs *args) {
    size_t maxlen = args->maxlen;
    streamID *id = &args->minid;
    int approx = args->approx_trim;
    int64_t limit = args->limit;
    int trim_strategy = args->trim_strategy;

    if (trim_strategy == TRIM_STRATEGY_NONE)
        return 0;

    raxIterator ri;
    raxStart(&ri,s->rax);
    raxSeek(&ri,""^"",NULL,0);

    int64_t deleted = 0;
    while (raxNext(&ri)) {
        if (trim_strategy == TRIM_STRATEGY_MAXLEN && s->length <= maxlen)
            break;

        unsigned char *lp = ri.data, *p = lpFirst(lp);
        int64_t entries = lpGetInteger(p);

        /* Check if we exceeded the amount of work we could do */
        if (limit && (deleted + entries) > limit)
            break;

        /* Check if we can remove the whole node. */
        int remove_node;
        streamID master_id = {0}; /* For MINID */
        if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
            remove_node = s->length - entries >= maxlen;...",719.0,878.0,1.0,25.0,160.0,122,21,172,27,0,56,24,38,3,29,,0,49,4,2,2,int64_t
4912,434448,streamParseAddOrTrimArgsOrReply,1,streamParseAddOrTrimArgsOrReply,"int streamParseAddOrTrimArgsOrReply (client*,streamAddTrimArgs*,int)",t_stream.c,"static int streamParseAddOrTrimArgsOrReply(client *c, streamAddTrimArgs *args, int xadd) {
    /* Initialize arguments to defaults */
    memset(args, 0, sizeof(*args));

    /* Parse options. */
    int i = 2; /* This is the first argument position where we could
                  find an option, or the ID. */
    int limit_given = 0;
    for (; i < c->argc; i++) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (xadd && opt[0] == '*' && opt[1] == '\0') {
            /* This is just a fast path for the common case of auto-ID
             * creation. */
            break;
        } else if (!strcasecmp(opt,""maxlen"") && moreargs) {
            if (args->trim_strategy != TRIM_STRATEGY_NONE) {
                addReplyError(c,""syntax error, MAXLEN and MINID options at the same time are not compatible"");
                return -1;
            }
            args->approx_trim = 0;
            char *next = c->argv...",908.0,1040.0,1.0,39.0,133.0,32,11,24,7,0,10,7,7,5,3,,0,8,6,3,3,int
4913,436153,streamEntryExists,1,streamEntryExists,"int streamEntryExists (stream*,streamID*)",t_stream.c,"int streamEntryExists(stream *s, streamID *id) {
    streamIterator si;
    streamIteratorStart(&si,s,id,id,0);
    streamID myid;
    int64_t numfields;
    int found = streamIteratorGetID(&si,&myid,&numfields);
    streamIteratorStop(&si);
    if (!found)
        return 0;
    serverAssert(streamCompareID(id,&myid) == 0);
    return 1;
}",1338.0,1349.0,1.0,4.0,12.0,13,8,12,6,0,5,2,2,0,5,,0,1,4,2,2,int
4914,436251,streamLastValidID,1,streamLastValidID,"void streamLastValidID (stream*,streamID*)",t_stream.c,"void streamLastValidID(stream *s, streamID *maxid)
{
    streamIterator si;
    streamIteratorStart(&si,s,NULL,NULL,1);
    int64_t numfields;
    if (!streamIteratorGetID(&si,maxid,&numfields) && s->length)
        serverPanic(""Corrupt stream, length is %llu, but no max id"", (unsigned long long)s->length);
    streamIteratorStop(&si);
}",1368.0,1376.0,1.0,8.0,9.0,10,6,10,5,0,6,2,2,2,4,,0,3,4,2,2,void
4915,436295,createStreamIDString,1,createStreamIDString,sds createStreamIDString (streamID*),t_stream.c,"sds createStreamIDString(streamID *id) {
    /* Optimization: pre-allocate a big enough buffer to avoid reallocs. */
    sds str = sdsnewlen(SDS_NOINIT, STREAM_ID_STR_LEN);
    sdssetlen(str, 0);
    return sdscatfmt(str,""%U-%U"", id->ms,id->seq);
}",1385.0,1390.0,1.0,36.0,6.0,3,2,6,3,2,5,1,1,0,3,,0,3,2,1,1,sds
4916,436321,addReplyStreamID,1,addReplyStreamID,"void addReplyStreamID (client*,streamID*)",t_stream.c,"void addReplyStreamID(client *c, streamID *id) {
    addReplyBulkSds(c,createStreamIDString(id));
}",1395.0,1397.0,1.0,1.0,3.0,0,0,2,2,3,2,1,1,0,2,,0,1,4,2,2,void
4917,436331,setDeferredReplyStreamID,1,setDeferredReplyStreamID,"void setDeferredReplyStreamID (client*,void*,streamID*)",t_stream.c,"void setDeferredReplyStreamID(client *c, void *dr, streamID *id) {
    setDeferredReplyBulkSds(c, dr, createStreamIDString(id));
}",1399.0,1401.0,1.0,1.0,3.0,0,0,3,3,0,2,1,1,0,2,,0,1,6,3,3,void
4918,436355,streamIDEqZero,1,streamIDEqZero,int streamIDEqZero (streamID*),t_stream.c,"int streamIDEqZero(streamID *id) {
    return !(id->ms || id->seq);
}",1410.0,1412.0,1.0,1.0,3.0,4,3,2,1,1,2,1,1,0,0,,0,2,2,1,1,int
4919,436369,streamRangeHasTombstones,1,streamRangeHasTombstones,"int streamRangeHasTombstones (stream*,streamID*,streamID*)",t_stream.c,"int streamRangeHasTombstones(stream *s, streamID *start, streamID *end) {
    streamID start_id, end_id;

    if (!s->length || streamIDEqZero(&s->max_deleted_entry_id)) {
        /* The stream is empty or has no tombstones. */
        return 0;
    }

    if (streamCompareID(&s->first_id,&s->max_deleted_entry_id) > 0) {
        /* The latest tombstone is before the first entry. */
        return 0;
    }

    if (start) {
        start_id = *start;
    } else {
        start_id.ms = 0;
        start_id.seq = 0;
    }

    if (end) {
        end_id = *end;
    } else {
        end_id.ms = UINT64_MAX;
        end_id.seq = UINT64_MAX;
    }

    if (streamCompareID(&start_id,&s->max_deleted_entry_id) <= 0 &&
        streamCompareID(&s->max_deleted_entry_id,&end_id) <= 0)
    {
        /* start_id <= max_deleted_entry_id <= end_id: The range does include a tombstone. */
        return 1;
    }

    /* The range doesn't includes a tombstone. */
    return 0;
}",1419.0,1455.0,1.0,1.0,37.0,23,9,14,5,0,10,6,6,10,4,,0,10,6,3,3,int
4920,436470,streamReplyWithCGLag,1,streamReplyWithCGLag,"void streamReplyWithCGLag (client*,stream*,streamCG*)",t_stream.c,"void streamReplyWithCGLag(client *c, stream *s, streamCG *cg) {
    int valid = 0;
    long long lag = 0;

    if (!s->entries_added) {
        /* The lag of a newly-initialized stream is 0. */
        lag = 0;
        valid = 1;
    } else if (cg->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&cg->last_id,NULL)) {
        /* No fragmentation ahead means that the group's logical reads counter
         * is valid for performing the lag calculation. */
        lag = (long long)s->entries_added - cg->entries_read;
        valid = 1;
    } else {
        /* Attempt to retrieve the group's last ID logical read counter. */
        long long entries_read = streamEstimateDistanceFromFirstEverEntry(s,&cg->last_id);
        if (entries_read != SCG_INVALID_ENTRIES_READ) {
            /* A valid counter was obtained. */
            lag = (long long)s->entries_added - entries_read;
            valid = 1;
        }
    }

    if (valid) {
        addReplyLongLong(c,lag);...",1460.0,1488.0,1.0,35.0,29.0,6,3,8,4,0,2,3,3,1,1,,0,1,6,3,3,void
4921,436703,streamPropagateXCLAIM,1,streamPropagateXCLAIM,"void streamPropagateXCLAIM (client*,robj*,streamCG*,robj*,robj*,streamNACK*)",t_stream.c,"void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {
    /* We need to generate an XCLAIM that will work in a idempotent fashion:
     *
     * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
     *        RETRYCOUNT <count> FORCE JUSTID LASTID <id>.
     *
     * Note that JUSTID is useful in order to avoid that XCLAIM will do
     * useless work in the slave side, trying to fetch the stream item. */
    robj *argv[14];
    argv[0] = shared.xclaim;
    argv[1] = key;
    argv[2] = groupname;
    argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));
    argv[4] = shared.integers[0];
    argv[5] = id;
    argv[6] = shared.time;
    argv[7] = createStringObjectFromLongLong(nack->delivery_time);
    argv[8] = shared.retrycount;
    argv[9] = createStringObjectFromLongLong(nack->delivery_count);
    argv[10] = shared.force;
    argv[11] = shared.justid;
    argv[12] = shared.lasti...",1554.0,1584.0,1.0,36.0,31.0,51,6,35,8,0,16,1,1,0,10,,0,11,12,6,6,void
4922,436852,streamPropagateGroupID,1,streamPropagateGroupID,"void streamPropagateGroupID (client*,robj*,streamCG*,robj*)",t_stream.c,"void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {
    robj *argv[7];
    argv[0] = shared.xgroup;
    argv[1] = shared.setid;
    argv[2] = key;
    argv[3] = groupname;
    argv[4] = createObjectFromStreamID(&group->last_id);
    argv[5] = shared.entriesread;
    argv[6] = createStringObjectFromLongLong(group->entries_read);

    alsoPropagate(c->db->id,argv,7,PROPAGATE_AOF|PROPAGATE_REPL);

    decrRefCount(argv[4]);
    decrRefCount(argv[6]);
}",1592.0,1606.0,1.0,35.0,15.0,25,6,18,6,0,8,1,1,0,5,,0,5,8,4,4,void
4923,437505,streamTypeLookupWriteOrCreate,1,streamTypeLookupWriteOrCreate,"robj streamTypeLookupWriteOrCreate (client*,robj*,int)",t_stream.c,"robj *streamTypeLookupWriteOrCreate(client *c, robj *key, int no_create) {
    robj *o = lookupKeyWrite(c->db,key);
    if (checkType(c,o,OBJ_STREAM)) return NULL;
    if (o == NULL) {
        if (no_create) {
            addReplyNull(c);
            return NULL;
        }
        o = createStreamObject();
        dbAdd(c->db,key,o);
    }
    return o;
}",1854.0,1866.0,1.0,22.0,13.0,5,3,16,5,0,7,4,5,1,5,,0,5,6,3,3,robj
4924,437553,streamGenericParseIDOrReply,1,streamGenericParseIDOrReply,"int streamGenericParseIDOrReply (client*,robj*,streamID*,uint64_t,int,int*)",t_stream.c,"int streamGenericParseIDOrReply(client *c, const robj *o, streamID *id, uint64_t missing_seq, int strict, int *seq_given) {
    char buf[128];
    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;
    memcpy(buf,o->ptr,sdslen(o->ptr)+1);

    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\0')
        goto invalid;

    if (seq_given != NULL) {
        *seq_given = 1;
    }

    /* Handle the ""-"" and ""+"" special cases. */
    if (buf[0] == '-' && buf[1] == '\0') {
        id->ms = 0;
        id->seq = 0;
        return C_OK;
    } else if (buf[0] == '+' && buf[1] == '\0') {
        id->ms = UINT64_MAX;
        id->seq = UINT64_MAX;
        return C_OK;
    }

    /* Parse <ms>-<seq> form. */
    unsigned long long ms, seq;
    char *dot = strchr(buf,'-');
    if (dot) *dot = '\0';
    if (string2ull(buf,&ms) == 0) goto invalid;
    if (dot) {
        size_t seqlen = strlen(dot+1);
        if (seq_given != NULL && seqlen == 1 && *(dot + 1) == '*') {
            /* Handl...",1885.0,1933.0,1.0,15.0,49.0,50,14,37,11,0,8,13,11,2,4,,0,6,12,6,6,int
4925,437822,streamParseIntervalIDOrReply,1,streamParseIntervalIDOrReply,"int streamParseIntervalIDOrReply (client*,robj*,streamID*,int*,uint64_t)",t_stream.c,"int streamParseIntervalIDOrReply(client *c, robj *o, streamID *id, int *exclude, uint64_t missing_seq) {
    char *p = o->ptr;
    size_t len = sdslen(p);
    int invalid = 0;
    
    if (exclude != NULL) *exclude = (len > 1 && p[0] == '(');
    if (exclude != NULL && *exclude) {
        robj *t = createStringObject(p+1,len-1);
        invalid = (streamParseStrictIDOrReply(c,t,id,missing_seq,NULL) == C_ERR);
        decrRefCount(t);
    } else 
        invalid = (streamParseIDOrReply(c,o,id,missing_seq) == C_ERR);
    if (invalid)
        return C_ERR;
    return C_OK;
}",1959.0,1974.0,1.0,74.0,16.0,21,11,24,10,2,4,4,4,0,4,,0,3,10,5,5,int
4926,437922,streamRewriteApproxSpecifier,1,streamRewriteApproxSpecifier,"void streamRewriteApproxSpecifier (client*,int)",t_stream.c,"void streamRewriteApproxSpecifier(client *c, int idx) {
    rewriteClientCommandArgument(c,idx,shared.special_equals);
}",1976.0,1978.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
4927,437934,streamRewriteTrimArgument,1,streamRewriteTrimArgument,"void streamRewriteTrimArgument (client*,stream*,int,int)",t_stream.c,"void streamRewriteTrimArgument(client *c, stream *s, int trim_strategy, int idx) {
    robj *arg;
    if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
        arg = createStringObjectFromLongLong(s->length);
    } else {
        streamID first_id;
        streamGetEdgeID(s,1,0,&first_id);
        arg = createObjectFromStreamID(&first_id);
    }

    rewriteClientCommandArgument(c,idx,arg);
    decrRefCount(arg);
}",1982.0,1994.0,1.0,25.0,13.0,3,3,7,5,0,4,2,2,0,3,,0,2,8,4,4,void
4928,438303,xrangeGenericCommand,1,xrangeGenericCommand,"void xrangeGenericCommand (client*,int)",t_stream.c,"void xrangeGenericCommand(client *c, int rev) {
    robj *o;
    stream *s;
    streamID startid, endid;
    long long count = -1;
    robj *startarg = rev ? c->argv[3] : c->argv[2];
    robj *endarg = rev ? c->argv[2] : c->argv[3];
    int startex = 0, endex = 0;
    
    /* Parse start and end IDs. */
    if (streamParseIntervalIDOrReply(c,startarg,&startid,&startex,0) != C_OK)
        return;
    if (startex && streamIncrID(&startid) != C_OK) {
        addReplyError(c,""invalid start ID for the interval"");
        return;
    }
    if (streamParseIntervalIDOrReply(c,endarg,&endid,&endex,UINT64_MAX) != C_OK)
        return;
    if (endex && streamDecrID(&endid) != C_OK) {
        addReplyError(c,""invalid end ID for the interval"");
        return;
    }

    /* Parse the COUNT option if any. */
    if (c->argc > 4) {
        for (int j = 4; j < c->argc; j++) {
            int additional = c->argc-j-1;
            if (strcasecmp(c->argv[j]->ptr,""COUNT"") == 0 && additional >= 1) {
   ...",2093.0,2144.0,1.0,72.0,52.0,60,17,55,16,0,20,12,21,12,10,,0,17,4,2,2,void
4929,439621,streamFreeConsumer,1,streamFreeConsumer,void streamFreeConsumer (streamConsumer*),t_stream.c,"void streamFreeConsumer(streamConsumer *sc) {
    raxFree(sc->pel); /* No value free callback: the PEL entries are shared
                         between the consumer and the main stream PEL. */
    sdsfree(sc->name);
    zfree(sc);
}",2471.0,2476.0,1.0,1.0,6.0,2,1,3,1,1,5,1,1,0,3,,0,2,2,1,1,void
4930,439910,streamDelConsumer,1,streamDelConsumer,"void streamDelConsumer (streamCG*,streamConsumer*)",t_stream.c,"void streamDelConsumer(streamCG *cg, streamConsumer *consumer) {
    /* Iterate all the consumer pending messages, deleting every corresponding
     * entry from the global entry. */
    raxIterator ri;
    raxStart(&ri,consumer->pel);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        streamNACK *nack = ri.data;
        raxRemove(cg->pel,ri.key,ri.key_len,NULL);
        streamFreeNACK(nack);
    }
    raxStop(&ri);

    /* Deallocate the consumer. */
    raxRemove(cg->consumers,(unsigned char*)consumer->name,
              sdslen(consumer->name),NULL);
    streamFreeConsumer(consumer);
}",2546.0,2563.0,1.0,1.0,18.0,14,5,18,5,0,17,2,2,1,9,,0,10,4,2,2,void
4931,443682,xinfoReplyWithStreamInfo,1,xinfoReplyWithStreamInfo,"void xinfoReplyWithStreamInfo (client*,stream*)",t_stream.c,"void xinfoReplyWithStreamInfo(client *c, stream *s) {
    int full = 1;
    long long count = 10; /* Default COUNT is 10 so we don't block the server */
    robj **optv = c->argv + 3; /* Options start after XINFO STREAM <key> */
    int optc = c->argc - 3;

    /* Parse options. */
    if (optc == 0) {
        full = 0;
    } else {
        /* Valid options are [FULL] or [FULL COUNT <count>] */
        if (optc != 1 && optc != 3) {
            addReplySubcommandSyntaxError(c);
            return;
        }

        /* First option must be ""FULL"" */
        if (strcasecmp(optv[0]->ptr,""full"")) {
            addReplySubcommandSyntaxError(c);
            return;
        }

        if (optc == 3) {
            /* First option must be ""FULL"" */
            if (strcasecmp(optv[1]->ptr,""count"")) {
                addReplySubcommandSyntaxError(c);
                return;
            }
            if (getLongLongFromObjectOrReply(c,optv[2],&count,NULL) == C_ERR)
                return;
     ...",3636.0,3839.0,1.0,71.0,204.0,44,10,63,11,0,40,5,7,0,25,,0,19,4,2,2,void
4932,445129,getGenericCommand,1,getGenericCommand,int getGenericCommand (client*),t_string.c,"int getGenericCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)
        return C_OK;

    if (checkType(c,o,OBJ_STRING)) {
        return C_ERR;
    }

    addReplyBulk(c,o);
    return C_OK;
}",323.0,335.0,1.0,15.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4933,445134,checkStringLength,1,checkStringLength,"int checkStringLength (client*,long long,long long)",t_string.c,"static int checkStringLength(client *c, long long size, long long append) {
    if (mustObeyClient(c))
        return C_OK;
    /* 'uint64_t' cast is there just to prevent undefined behavior on overflow */
    long long total = (uint64_t)size + append;
    /* Test configured max-bulk-len represending a limit of the biggest string object,
     * and also test for overflow. */
    if (total > server.proto_max_bulk_len || total < size || total < append) {
        addReplyError(c,""string exceeds maximum allowed size (proto-max-bulk-len)"");
        return C_ERR;
    }
    return C_OK;
}",40.0,52.0,1.0,15.0,13.0,10,8,11,5,0,2,3,3,1,2,,0,1,6,3,3,int
4934,445184,getExpireMillisecondsOrReply,1,getExpireMillisecondsOrReply,"int getExpireMillisecondsOrReply (client*,robj*,int,int,long long*)",t_string.c,"static int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds) {
    int ret = getLongLongFromObjectOrReply(c, expire, milliseconds, NULL);
    if (ret != C_OK) {
        return ret;
    }

    if (*milliseconds <= 0 || (unit == UNIT_SECONDS && *milliseconds > LLONG_MAX / 1000)) {
        /* Negative value provided or multiplication is gonna overflow. */
        addReplyErrorExpireTime(c);
        return C_ERR;
    }

    if (unit == UNIT_SECONDS) *milliseconds *= 1000;

    if ((flags & OBJ_PX) || (flags & OBJ_EX)) {
        *milliseconds += commandTimeSnapshot();
    }

    if (*milliseconds <= 0) {
        /* Overflow detected. */
        addReplyErrorExpireTime(c);
        return C_ERR;
    }

    return C_OK;
}",164.0,189.0,1.0,15.0,26.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
4935,445193,setGenericCommand,1,setGenericCommand,"void setGenericCommand (client*,int,robj*,robj*,robj*,int,robj*,robj*)",t_string.c,"void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
    long long milliseconds = 0; /* initialized to avoid any harmness warning */
    int found = 0;
    int setkey_flags = 0;

    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {
        return;
    }

    if (flags & OBJ_SET_GET) {
        if (getGenericCommand(c) == C_ERR) return;
    }

    found = (lookupKeyWrite(c->db,key) != NULL);

    if ((flags & OBJ_SET_NX && found) ||
        (flags & OBJ_SET_XX && !found))
    {
        if (!(flags & OBJ_SET_GET)) {
            addReply(c, abort_reply ? abort_reply : shared.null[c->resp]);
        }
        return;
    }

    /* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */
    setkey_flags |= ((flags & OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : 0;
    setkey_flags |= found ? SETKEY_ALR...",84.0,150.0,1.0,89.0,67.0,100,20,89,20,0,26,13,18,3,15,,0,16,16,8,8,void
4936,445648,parseExtendedStringArgumentsOrReply,1,parseExtendedStringArgumentsOrReply,"int parseExtendedStringArgumentsOrReply (client*,int*,int*,robj**,int)",t_string.c,"int parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {

    int j = command_type == COMMAND_GET ? 2 : 3;
    for (; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];

        if ((opt[0] == 'n' || opt[0] == 'N') &&
            (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\0' &&
            !(*flags & OBJ_SET_XX) && (command_type == COMMAND_SET))
        {
            *flags |= OBJ_SET_NX;
        } else if ((opt[0] == 'x' || opt[0] == 'X') &&
                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\0' &&
                   !(*flags & OBJ_SET_NX) && (command_type == COMMAND_SET))
        {
            *flags |= OBJ_SET_XX;
        } else if ((opt[0] == 'g' || opt[0] == 'G') &&
                   (opt[1] == 'e' || opt[1] == 'E') &&
                   (opt[2] == 't' || opt[2] == 'T') && opt[3] == '\0' &&
                   (command_type == COMMAND_SET))
...",209.0,291.0,1.0,28.0,83.0,40,14,21,7,0,4,3,4,1,0,,0,4,10,5,5,int
4937,447700,msetGenericCommand,1,msetGenericCommand,"void msetGenericCommand (client*,int)",t_string.c,"void msetGenericCommand(client *c, int nx) {
    int j;

    if ((c->argc % 2) == 0) {
        addReplyErrorArity(c);
        return;
    }

    /* Handle the NX flag. The MSETNX semantic is to return zero and don't
     * set anything if at least one key already exists. */
    if (nx) {
        for (j = 1; j < c->argc; j += 2) {
            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
                addReply(c, shared.czero);
                return;
            }
        }
    }

    int setkey_flags = nx ? SETKEY_DOESNT_EXIST : 0;
    for (j = 1; j < c->argc; j += 2) {
        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);
        notifyKeyspaceEvent(NOTIFY_STRING,""set"",c->argv[j],c->db->id);
        /* In MSETNX, It could be that we're overriding the same key, we can't be sure it doesn't exist. */
        if (nx)
            setkey_flags = SETKEY_ADD_OR_UPDATE;
    }
    server.dirty += (c->argc-1)/2;
    ad...",561.0,591.0,1.0,28.0,31.0,43,14,39,7,0,20,7,11,6,7,,0,15,4,2,2,void
4938,447874,incrDecrCommand,1,incrDecrCommand,"void incrDecrCommand (client*,long long)",t_string.c,"void incrDecrCommand(client *c, long long incr) {
    long long value, oldvalue;
    robj *o, *new;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return;
    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;

    oldvalue = value;
    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
        addReplyError(c,""increment or decrement would overflow"");
        return;
    }
    value += incr;

    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&
        value >= LONG_MIN && value <= LONG_MAX)
    {
        new = o;
        o->ptr = (void*)((long)value);
    } else {
        new = createStringObjectFromLongLongForValue(value);
        if (o) {
            dbReplaceValue(c->db,c->argv[1],new);
        } else {
            dbAdd(c->db,c->argv[1],new);
        }
    }
    signalModifiedKey(c...",601.0,635.0,1.0,22.0,35.0,50,18,45,12,0,13,5,5,2,7,,0,9,4,2,2,void
4939,449362,zsetConvertAndExpand,1,zsetConvertAndExpand,"void zsetConvertAndExpand (robj*,int,long unsigned)",t_zset.c,"void zsetConvertAndExpand(robj *zobj, int encoding, unsigned long cap) {
    zset *zs;
    zskiplistNode *node, *next;
    sds ele;
    double score;

    if (zobj->encoding == encoding) return;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        if (encoding != OBJ_ENCODING_SKIPLIST)
            serverPanic(""Unknown target encoding"");

        zs = zmalloc(sizeof(*zs));
        zs->dict = dictCreate(&zsetDictType);
        zs->zsl = zslCreate();

        /* Presize the dict to avoid rehashing */
        dictExpand(zs->dict, cap);

        eptr = lpSeek(zl,0);
        if (eptr != NULL) {
            sptr = lpNext(zl,eptr);
            serverAssertWithInfo(NULL,zobj,sptr != NULL);
        }

        while (eptr != NULL) {
            score = zzlGetScore(sptr);
            vstr = lpGetValue(eptr,&vlen,&vlong);
            i...",1207.0,1280.0,1.0,26.0,74.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
4940,449369,zslCreateNode,1,zslCreateNode,"zskiplistNode zslCreateNode (int,double,sds)",t_zset.c,"zskiplistNode *zslCreateNode(int level, double score, sds ele) {
    zskiplistNode *zn =
        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
    zn->score = score;
    zn->ele = ele;
    return zn;
}",73.0,79.0,1.0,1.0,7.0,10,6,9,5,0,3,1,1,0,1,,0,3,6,3,3,zskiplistNode
4941,449482,zslFreeNode,1,zslFreeNode,void zslFreeNode (zskiplistNode*),t_zset.c,"void zslFreeNode(zskiplistNode *node) {
    sdsfree(node->ele);
    zfree(node);
}",102.0,105.0,1.0,1.0,4.0,1,1,2,1,4,3,1,1,0,2,,0,1,2,1,1,void
4942,449924,zslDeleteNode,1,zslDeleteNode,"void zslDeleteNode (zskiplist*,zskiplistNode*,zskiplistNode**)",t_zset.c,"void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;
    for (i = 0; i < zsl->level; i++) {
        if (update[i]->level[i].forward == x) {
            update[i]->level[i].span += x->level[i].span - 1;
            update[i]->level[i].forward = x->level[i].forward;
        } else {
            update[i]->level[i].span -= 1;
        }
    }
    if (x->level[0].forward) {
        x->level[0].forward->backward = x->backward;
    } else {
        zsl->tail = x->backward;
    }
    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
        zsl->level--;
    zsl->length--;
}",194.0,212.0,1.0,1.0,19.0,46,11,25,5,4,10,5,6,5,0,,0,10,6,3,3,void
4943,450206,zslUpdateScore,1,zslUpdateScore,"zskiplistNode zslUpdateScore (zskiplist*,double,sds,double)",t_zset.c,"zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    /* We need to seek to element to update to start: this is useful anyway,
     * we'll have to update or remove it. */
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < curscore ||
                    (x->level[i].forward->score == curscore &&
                     sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    /* Jump to our element: note that this function assumes that the
     * element with the matching score exists. */
    x = x->level[0].forward;
    serverAssert(x && curscore == x->score && sdscmp(x->ele,ele) == 0);

    /* If the node, after the score update, would be still exactly
     * at the same position, we can just update the score w...",262.0,304.0,1.0,26.0,43.0,70,15,51,9,0,23,4,5,9,6,,0,19,8,4,4,zskiplistNode
4944,450443,zslIsInRange,1,zslIsInRange,"int zslIsInRange (zskiplist*,zrangespec*)",t_zset.c,"int zslIsInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;

    /* Test for ranges that will always be empty. */
    if (range->min > range->max ||
            (range->min == range->max && (range->minex || range->maxex)))
        return 0;
    x = zsl->tail;
    if (x == NULL || !zslValueGteMin(x->score,range))
        return 0;
    x = zsl->header->level[0].forward;
    if (x == NULL || !zslValueLteMax(x->score,range))
        return 0;
    return 1;
}",315.0,329.0,1.0,1.0,15.0,26,9,18,4,0,12,4,4,10,2,,0,12,4,2,2,int
4945,450719,zslDeleteRangeByScore,1,zslDeleteRangeByScore,"unsigned long zslDeleteRangeByScore (zskiplist*,zrangespec*,dict*)",t_zset.c,"unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long removed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            !zslValueGteMin(x->level[i].forward->score, range))
                x = x->level[i].forward;
        update[i] = x;
    }

    /* Current node is the last with score < or <= min. */
    x = x->level[0].forward;

    /* Delete nodes while in range. */
    while (x && zslValueLteMax(x->score, range)) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x); /* Here is where x->ele is actually released. */
        removed++;
        x = next;
    }
    return removed;
}",387.0,413.0,1.0,26.0,27.0,31,9,31,8,0,13,4,5,5,5,,0,10,6,3,3,unsigned long
4946,450834,zslDeleteRangeByLex,1,zslDeleteRangeByLex,"unsigned long zslDeleteRangeByLex (zskiplist*,zlexrangespec*,dict*)",t_zset.c,"unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long removed = 0;
    int i;


    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            !zslLexValueGteMin(x->level[i].forward->ele,range))
                x = x->level[i].forward;
        update[i] = x;
    }

    /* Current node is the last with score < or <= min. */
    x = x->level[0].forward;

    /* Delete nodes while in range. */
    while (x && zslLexValueLteMax(x->ele,range)) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x); /* Here is where x->ele is actually released. */
        removed++;
        x = next;
    }
    return removed;
}",415.0,442.0,1.0,26.0,28.0,31,9,31,8,0,13,4,5,5,5,,0,10,6,3,3,unsigned long
4947,450949,zslDeleteRangeByRank,1,zslDeleteRangeByRank,"unsigned long zslDeleteRangeByRank (zskiplist*,unsigned int,unsigned int,dict*)",t_zset.c,"unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long traversed = 0, removed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward && (traversed + x->level[i].span) < start) {
            traversed += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    traversed++;
    x = x->level[0].forward;
    while (x && traversed <= end) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x);
        removed++;
        traversed++;
        x = next;
    }
    return removed;
}",446.0,472.0,1.0,26.0,27.0,42,12,41,10,0,12,4,5,2,3,,0,9,8,4,4,unsigned long
4948,451281,zslParseRange,1,zslParseRange,"int zslParseRange (robj*,robj*,zrangespec*)",t_zset.c,"static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
    char *eptr;
    spec->minex = spec->maxex = 0;

    /* Parse the min-max interval. If one of the values is prefixed
     * by the ""("" character, it's considered ""open"". For instance
     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max
     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */
    if (min->encoding == OBJ_ENCODING_INT) {
        spec->min = (long)min->ptr;
    } else {
        if (((char*)min->ptr)[0] == '(') {
            spec->min = strtod((char*)min->ptr+1,&eptr);
            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
            spec->minex = 1;
        } else {
            spec->min = strtod((char*)min->ptr,&eptr);
            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
        }
    }
    if (max->encoding == OBJ_ENCODING_INT) {
        spec->max = (long)max->ptr;
    } else {
        if (((char*)max->ptr)[0] == '(') {
            spec->max = strto...",522.0,556.0,1.0,25.0,35.0,16,4,8,3,0,4,3,3,0,0,,0,4,6,3,3,int
4949,451498,zslParseLexRangeItem,1,zslParseLexRangeItem,"int zslParseLexRangeItem (robj*,sds*,int*)",t_zset.c,"int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
    char *c = item->ptr;

    switch(c[0]) {
    case '+':
        if (c[1] != '\0') return C_ERR;
        *ex = 1;
        *dest = shared.maxstring;
        return C_OK;
    case '-':
        if (c[1] != '\0') return C_ERR;
        *ex = 1;
        *dest = shared.minstring;
        return C_OK;
    case '(':
        *ex = 1;
        *dest = sdsnewlen(c+1,sdslen(c)-1);
        return C_OK;
    case '[':
        *ex = 0;
        *dest = sdsnewlen(c+1,sdslen(c)-1);
        return C_OK;
    default:
        return C_ERR;
    }
}",573.0,598.0,1.0,33.0,26.0,32,9,19,5,0,4,4,6,0,4,,0,4,6,3,3,int
4950,451751,sdscmplex,1,sdscmplex,"int sdscmplex (sds,sds)",t_zset.c,"int sdscmplex(sds a, sds b) {
    if (a == b) return 0;
    if (a == shared.minstring || b == shared.maxstring) return -1;
    if (a == shared.maxstring || b == shared.minstring) return 1;
    return sdscmp(a,b);
}",633.0,638.0,1.0,1.0,6.0,12,4,12,3,2,1,4,4,0,1,,0,0,4,2,2,int
4951,451849,zslIsInLexRange,1,zslIsInLexRange,"int zslIsInLexRange (zskiplist*,zlexrangespec*)",t_zset.c,"int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
    zskiplistNode *x;

    /* Test for ranges that will always be empty. */
    int cmp = sdscmplex(range->min,range->max);
    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
        return 0;
    x = zsl->tail;
    if (x == NULL || !zslLexValueGteMin(x->ele,range))
        return 0;
    x = zsl->header->level[0].forward;
    if (x == NULL || !zslLexValueLteMax(x->ele,range))
        return 0;
    return 1;
}",653.0,667.0,1.0,1.0,15.0,25,9,19,5,0,11,4,4,6,3,,0,11,4,2,2,int
4952,452127,zzlStrtod,1,zzlStrtod,"double zzlStrtod (unsigned char*,unsigned int)",t_zset.c,"double zzlStrtod(unsigned char *vstr, unsigned int vlen) {
    char buf[128];
    if (vlen > sizeof(buf) - 1)
        vlen = sizeof(buf) - 1;
    memcpy(buf,vstr,vlen);
    buf[vlen] = '\0';
    return strtod(buf,NULL);
 }",724.0,731.0,1.0,2.0,8.0,8,5,11,4,1,0,2,2,0,0,,0,0,4,2,2,double
4953,452255,zzlCompareElements,1,zzlCompareElements,"int zzlCompareElements (unsigned char*,unsigned char*,unsigned int)",t_zset.c,"int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    unsigned char vbuf[32];
    int minlen, cmp;

    vstr = lpGetValue(eptr,&vlen,&vlong);
    if (vstr == NULL) {
        /* Store string representation of long long in buf. */
        vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
        vstr = vbuf;
    }

    minlen = (vlen < clen) ? vlen : clen;
    cmp = memcmp(vstr,cstr,minlen);
    if (cmp == 0) return vlen-clen;
    return cmp;
}",768.0,786.0,1.0,1.0,19.0,14,8,25,10,0,2,3,3,0,2,,0,2,6,3,3,int
4954,452318,zzlLength,1,zzlLength,unsigned int zzlLength (unsigned char*),t_zset.c,"unsigned int zzlLength(unsigned char *zl) {
    return lpLength(zl)/2;
}",788.0,790.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,1,,0,0,2,1,1,unsigned int
4955,452480,zzlIsInRange,1,zzlIsInRange,"int zzlIsInRange (unsigned char*,zrangespec*)",t_zset.c,"int zzlIsInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *p;
    double score;

    /* Test for ranges that will always be empty. */
    if (range->min > range->max ||
            (range->min == range->max && (range->minex || range->maxex)))
        return 0;

    p = lpSeek(zl,-1); /* Last score. */
    if (p == NULL) return 0; /* Empty sorted set */
    score = zzlGetScore(p);
    if (!zslValueGteMin(score,range))
        return 0;

    p = lpSeek(zl,1); /* First score. */
    serverAssert(p != NULL);
    score = zzlGetScore(p);
    if (!zslValueLteMax(score,range))
        return 0;

    return 1;
}",832.0,854.0,1.0,4.0,23.0,24,13,22,5,0,13,5,5,8,7,,0,12,4,2,2,int
4956,452794,zzlIsInLexRange,1,zzlIsInLexRange,"int zzlIsInLexRange (unsigned char*,zlexrangespec*)",t_zset.c,"int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *p;

    /* Test for ranges that will always be empty. */
    int cmp = sdscmplex(range->min,range->max);
    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
        return 0;

    p = lpSeek(zl,-2); /* Last element. */
    if (p == NULL) return 0;
    if (!zzlLexValueGteMin(p,range))
        return 0;

    p = lpSeek(zl,0); /* First element. */
    serverAssert(p != NULL);
    if (!zzlLexValueLteMax(p,range))
        return 0;

    return 1;
}",933.0,952.0,1.0,4.0,20.0,21,13,19,5,0,10,5,5,4,6,,0,9,4,2,2,int
4957,453028,zzlFind,1,zzlFind,"unsigned char* zzlFind (unsigned char*,sds,double*)",t_zset.c,"unsigned char *zzlFind(unsigned char *lp, sds ele, double *score) {
    unsigned char *eptr, *sptr;

    if ((eptr = lpFirst(lp)) == NULL) return NULL;
    eptr = lpFind(lp, eptr, (unsigned char*)ele, sdslen(ele), 1);
    if (eptr) {
        sptr = lpNext(lp,eptr);
        serverAssert(sptr != NULL);

        /* Matching element, pull out score. */
        if (score != NULL) *score = zzlGetScore(sptr);
        return eptr;
    }

    return NULL;
}",1007.0,1022.0,1.0,8.0,16.0,13,8,21,6,0,6,4,5,1,6,,0,5,6,3,3,unsigned char*
4958,453096,zzlDelete,1,zzlDelete,"unsigned char* zzlDelete (unsigned char*,unsigned char*)",t_zset.c,"unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
    return lpDeleteRangeWithEntry(zl,&eptr,2);
}",1026.0,1028.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,unsigned char*
4959,453108,zzlInsertAt,1,zzlInsertAt,"unsigned char* zzlInsertAt (unsigned char*,unsigned char*,sds,double)",t_zset.c,"unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
    unsigned char *sptr;
    char scorebuf[MAX_D2STRING_CHARS];
    int scorelen = 0;
    long long lscore;
    int score_is_long = double2ll(score, &lscore);
    if (!score_is_long)
        scorelen = d2string(scorebuf,sizeof(scorebuf),score);
    if (eptr == NULL) {
        zl = lpAppend(zl,(unsigned char*)ele,sdslen(ele));
        if (score_is_long)
            zl = lpAppendInteger(zl,lscore);
        else
            zl = lpAppend(zl,(unsigned char*)scorebuf,scorelen);
    } else {
        /* Insert member before the element 'eptr'. */
        zl = lpInsertString(zl,(unsigned char*)ele,sdslen(ele),eptr,LP_BEFORE,&sptr);

        /* Insert score after the member. */
        if (score_is_long)
            zl = lpInsertInteger(zl,lscore,sptr,LP_AFTER,NULL);
        else
            zl = lpInsertString(zl,(unsigned char*)scorebuf,scorelen,sptr,LP_AFTER,NULL);
    }
    return zl;
}",1030.0,1055.0,1.0,18.0,26.0,10,6,20,9,0,5,4,5,0,5,,0,5,8,4,4,unsigned char*
4960,453323,zzlDeleteRangeByScore,1,zzlDeleteRangeByScore,"unsigned char* zzlDeleteRangeByScore (unsigned char*,zrangespec*,long unsigned*)",t_zset.c,"unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {
    unsigned char *eptr, *sptr;
    double score;
    unsigned long num = 0;

    if (deleted != NULL) *deleted = 0;

    eptr = zzlFirstInRange(zl,range);
    if (eptr == NULL) return zl;

    /* When the tail of the listpack is deleted, eptr will be NULL. */
    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {
        score = zzlGetScore(sptr);
        if (zslValueLteMax(score,range)) {
            /* Delete both the element and the score. */
            zl = lpDeleteRangeWithEntry(zl,&eptr,2);
            num++;
        } else {
            /* No longer in range. */
            break;
        }
    }

    if (deleted != NULL) *deleted = num;
    return zl;
}",1092.0,1117.0,1.0,1.0,26.0,16,7,28,8,1,5,6,7,2,5,,0,5,6,3,3,unsigned char*
4961,453401,zzlDeleteRangeByLex,1,zzlDeleteRangeByLex,"unsigned char* zzlDeleteRangeByLex (unsigned char*,zlexrangespec*,long unsigned*)",t_zset.c,"unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {
    unsigned char *eptr, *sptr;
    unsigned long num = 0;

    if (deleted != NULL) *deleted = 0;

    eptr = zzlFirstInLexRange(zl,range);
    if (eptr == NULL) return zl;

    /* When the tail of the listpack is deleted, eptr will be NULL. */
    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {
        if (zzlLexValueLteMax(eptr,range)) {
            /* Delete both the element and the score. */
            zl = lpDeleteRangeWithEntry(zl,&eptr,2);
            num++;
        } else {
            /* No longer in range. */
            break;
        }
    }

    if (deleted != NULL) *deleted = num;
    return zl;
}",1119.0,1142.0,1.0,1.0,24.0,15,7,26,7,1,4,6,7,2,4,,0,4,6,3,3,unsigned char*
4962,453474,zzlDeleteRangeByRank,1,zzlDeleteRangeByRank,"unsigned char* zzlDeleteRangeByRank (unsigned char*,unsigned int,unsigned int,long unsigned*)",t_zset.c,"unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {
    unsigned int num = (end-start)+1;
    if (deleted) *deleted = num;
    zl = lpDeleteRange(zl,2*(start-1),2*num);
    return zl;
}",1146.0,1151.0,1.0,1.0,6.0,9,5,11,5,1,1,2,2,0,1,,0,1,8,4,4,unsigned char*
4963,453569,zsetTypeCreate,1,zsetTypeCreate,"robj zsetTypeCreate (size_t,size_t)",t_zset.c,"robj *zsetTypeCreate(size_t size_hint, size_t val_len_hint) {
    if (size_hint <= server.zset_max_listpack_entries &&
        val_len_hint <= server.zset_max_listpack_value)
    {
        return createZsetListpackObject();
    }

    robj *zobj = createZsetObject();
    zset *zs = zobj->ptr;
    dictExpand(zs->dict, size_hint);
    return zobj;
}",1176.0,1187.0,1.0,1.0,12.0,9,5,10,5,2,4,2,2,0,3,,0,2,4,2,2,robj
4964,453607,zsetTypeMaybeConvert,1,zsetTypeMaybeConvert,"void zsetTypeMaybeConvert (robj*,size_t)",t_zset.c,"void zsetTypeMaybeConvert(robj *zobj, size_t size_hint) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK &&
        size_hint > server.zset_max_listpack_entries)
    {
        zsetConvertAndExpand(zobj, OBJ_ENCODING_SKIPLIST, size_hint);
    }
}",1191.0,1197.0,1.0,26.0,7.0,5,5,5,3,0,1,2,2,0,1,,0,0,4,2,2,void
4965,454618,zsetRemoveFromSkiplist,1,zsetRemoveFromSkiplist,"int zsetRemoveFromSkiplist (zset*,sds)",t_zset.c,"static int zsetRemoveFromSkiplist(zset *zs, sds ele) {
    dictEntry *de;
    double score;

    de = dictUnlink(zs->dict,ele);
    if (de != NULL) {
        /* Get the score in order to delete from the skiplist later. */
        score = *(double*)dictGetVal(de);

        /* Delete from the hash table and later from the skiplist.
         * Note that the order is important: deleting from the skiplist
         * actually releases the SDS string representing the element,
         * which is shared between the skiplist and the hash table, so
         * we need to delete from the skiplist as the final step. */
        dictFreeUnlinkedEntry(zs->dict,de);

        /* Delete from skiplist. */
        int retval = zslDelete(zs->zsl,score,ele,NULL);
        serverAssert(retval);

        return 1;
    }

    return 0;
}",1498.0,1522.0,1.0,8.0,25.0,13,8,16,6,0,8,2,2,0,5,,0,6,4,2,2,int
4966,455181,zsetSdsFromListpackEntry,1,zsetSdsFromListpackEntry,sds zsetSdsFromListpackEntry (listpackEntry*),t_zset.c,"sds zsetSdsFromListpackEntry(listpackEntry *e) {
    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);
}",1667.0,1669.0,1.0,1.0,3.0,5,2,4,1,0,6,1,1,0,2,,0,4,2,1,1,sds
4967,455202,zsetReplyFromListpackEntry,1,zsetReplyFromListpackEntry,"void zsetReplyFromListpackEntry (client*,listpackEntry*)",t_zset.c,"void zsetReplyFromListpackEntry(client *c, listpackEntry *e) {
    if (e->sval)
        addReplyBulkCBuffer(c, e->sval, e->slen);
    else
        addReplyBulkLongLong(c, e->lval);
}",1672.0,1677.0,1.0,1.0,6.0,3,1,4,2,0,4,2,2,1,1,,0,3,4,2,2,void
4968,455228,zsetTypeRandomElement,1,zsetTypeRandomElement,"void zsetTypeRandomElement (robj*,long unsigned,listpackEntry*,double*)",t_zset.c,"void zsetTypeRandomElement(robj *zsetobj, unsigned long zsetsize, listpackEntry *key, double *score) {
    if (zsetobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zsetobj->ptr;
        dictEntry *de = dictGetFairRandomKey(zs->dict);
        sds s = dictGetKey(de);
        key->sval = (unsigned char*)s;
        key->slen = sdslen(s);
        if (score)
            *score = *(double*)dictGetVal(de);
    } else if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {
        listpackEntry val;
        lpRandomPair(zsetobj->ptr, zsetsize, key, &val);
        if (score) {
            if (val.sval) {
                *score = zzlStrtod(val.sval,val.slen);
            } else {
                *score = (double)val.lval;
            }
        }
    } else {
        serverPanic(""Unknown zset encoding"");
    }
}",1684.0,1706.0,1.0,29.0,23.0,16,5,14,6,0,7,3,4,0,4,,0,7,8,4,4,void
4969,455345,zaddGenericCommand,1,zaddGenericCommand,"void zaddGenericCommand (client*,int)",t_zset.c,"void zaddGenericCommand(client *c, int flags) {
    static char *nanerr = ""resulting score is not a number (NaN)"";
    robj *key = c->argv[1];
    robj *zobj;
    sds ele;
    double score = 0, *scores = NULL;
    int j, elements, ch = 0;
    int scoreidx = 0;
    /* The following vars are used in order to track what the command actually
     * did during the execution, to reply to the client and to trigger the
     * notification of keyspace change. */
    int added = 0;      /* Number of new elements added. */
    int updated = 0;    /* Number of elements with updated score. */
    int processed = 0;  /* Number of elements processed, may remain zero with
                           options like XX. */

    /* Parse options. At the end 'scoreidx' is set to the argument position
     * of the score of the first score-element pair. */
    scoreidx = 2;
    while(scoreidx < c->argc) {
        char *opt = c->argv[scoreidx]->ptr;
        if (!strcasecmp(opt,""nx"")) flags |= ZADD_IN_NX;
  ...",1713.0,1835.0,1.0,44.0,123.0,114,23,124,28,0,28,24,28,4,17,,0,18,4,2,2,void
4970,456036,zremrangeGenericCommand,1,zremrangeGenericCommand,"void zremrangeGenericCommand (client*,zrange_type)",t_zset.c,"void zremrangeGenericCommand(client *c, zrange_type rangetype) {
    robj *key = c->argv[1];
    robj *zobj;
    int keyremoved = 0;
    unsigned long deleted = 0;
    zrangespec range;
    zlexrangespec lexrange;
    long start, end, llen;
    char *notify_type = NULL;

    /* Step 1: Parse the range. */
    if (rangetype == ZRANGE_RANK) {
        notify_type = ""zremrangebyrank"";
        if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||
            (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))
            return;
    } else if (rangetype == ZRANGE_SCORE) {
        notify_type = ""zremrangebyscore"";
        if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
            addReplyError(c,""min or max is not a float"");
            return;
        }
    } else if (rangetype == ZRANGE_LEX) {
        notify_type = ""zremrangebylex"";
        if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {
            addReplyError(c,""min or max not valid...",1880.0,1985.0,1.0,67.0,106.0,71,15,88,19,0,23,21,25,7,16,,0,16,4,2,2,void
4971,456600,zuiInitIterator,1,zuiInitIterator,void zuiInitIterator (zsetopsrc*),t_zset.c,"void zuiInitIterator(zsetopsrc *op) {
    if (op->subject == NULL)
        return;

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            it->is.is = op->subject->ptr;
            it->is.ii = 0;
        } else if (op->encoding == OBJ_ENCODING_HT) {
            it->ht.dict = op->subject->ptr;
            it->ht.di = dictGetIterator(op->subject->ptr);
            it->ht.de = dictNext(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            it->lp.lp = op->subject->ptr;
            it->lp.p = lpFirst(it->lp.lp);
        } else {
            serverPanic(""Unknown set encoding"");
        }
    } else if (op->type == OBJ_ZSET) {
        /* Sorted sets are traversed in reverse order to optimize for
         * the insertion of the elements in a new list as in
         * ZDIFF/ZINTER/ZUNION */
        iterzset *it = &op->iter.zset;
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
      ...",2062.0,2102.0,1.0,20.0,41.0,18,5,9,3,4,5,4,5,3,0,,0,5,2,1,1,void
4972,456905,zuiClearIterator,1,zuiClearIterator,void zuiClearIterator (zsetopsrc*),t_zset.c,"void zuiClearIterator(zsetopsrc *op) {
    if (op->subject == NULL)
        return;

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            UNUSED(it); /* skip */
        } else if (op->encoding == OBJ_ENCODING_HT) {
            dictReleaseIterator(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            UNUSED(it);
        } else {
            serverPanic(""Unknown set encoding"");
        }
    } else if (op->type == OBJ_ZSET) {
        iterzset *it = &op->iter.zset;
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            UNUSED(it); /* skip */
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            UNUSED(it); /* skip */
        } else {
            serverPanic(""Unknown sorted set encoding"");
        }
    } else {
        serverPanic(""Unsupported type"");
    }
}",2104.0,2131.0,1.0,20.0,28.0,11,6,8,3,6,4,4,5,3,0,,0,4,2,1,1,void
4973,457067,zuiDiscardDirtyValue,1,zuiDiscardDirtyValue,void zuiDiscardDirtyValue (zsetopval*),t_zset.c,"void zuiDiscardDirtyValue(zsetopval *val) {
    if (val->flags & OPVAL_DIRTY_SDS) {
        sdsfree(val->ele);
        val->ele = NULL;
        val->flags &= ~OPVAL_DIRTY_SDS;
    }
}",2133.0,2139.0,1.0,21.0,7.0,7,4,5,2,2,5,2,2,1,1,,0,4,2,1,1,void
4974,457098,zuiLength,1,zuiLength,unsigned long zuiLength (zsetopsrc*),t_zset.c,"unsigned long zuiLength(zsetopsrc *op) {
    if (op->subject == NULL)
        return 0;

    if (op->type == OBJ_SET) {
        return setTypeSize(op->subject);
    } else if (op->type == OBJ_ZSET) {
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            return zzlLength(op->subject->ptr);
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            zset *zs = op->subject->ptr;
            return zs->zsl->length;
        } else {
            serverPanic(""Unknown sorted set encoding"");
        }
    } else {
        serverPanic(""Unsupported type"");
    }
}",2141.0,2159.0,1.0,20.0,19.0,5,2,4,2,7,4,3,3,2,1,,0,3,2,1,1,unsigned long
4975,457198,zuiNext,1,zuiNext,"int zuiNext (zsetopsrc*,zsetopval*)",t_zset.c,"int zuiNext(zsetopsrc *op, zsetopval *val) {
    if (op->subject == NULL)
        return 0;

    zuiDiscardDirtyValue(val);

    memset(val,0,sizeof(zsetopval));

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            int64_t ell;

            if (!intsetGet(it->is.is,it->is.ii,&ell))
                return 0;
            val->ell = ell;
            val->score = 1.0;

            /* Move to next element. */
            it->is.ii++;
        } else if (op->encoding == OBJ_ENCODING_HT) {
            if (it->ht.de == NULL)
                return 0;
            val->ele = dictGetKey(it->ht.de);
            val->score = 1.0;

            /* Move to next element. */
            it->ht.de = dictNext(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            if (it->lp.p == NULL)
                return 0;
            val->estr = lpGetValue(it->lp.p, &val->elen, &val->ell);
            val->sc...",2164.0,2229.0,1.0,20.0,66.0,24,8,16,6,5,9,5,8,4,2,,0,8,4,2,2,int
4976,457576,zuiLongLongFromValue,1,zuiLongLongFromValue,int zuiLongLongFromValue (zsetopval*),t_zset.c,"int zuiLongLongFromValue(zsetopval *val) {
    if (!(val->flags & OPVAL_DIRTY_LL)) {
        val->flags |= OPVAL_DIRTY_LL;

        if (val->ele != NULL) {
            if (string2ll(val->ele,sdslen(val->ele),&val->ell))
                val->flags |= OPVAL_VALID_LL;
        } else if (val->estr != NULL) {
            if (string2ll((char*)val->estr,val->elen,&val->ell))
                val->flags |= OPVAL_VALID_LL;
        } else {
            /* The long long was already set, flag as valid. */
            val->flags |= OPVAL_VALID_LL;
        }
    }
    return val->flags & OPVAL_VALID_LL;
}",2231.0,2247.0,1.0,23.0,17.0,13,5,9,2,0,10,4,7,7,2,,0,10,2,1,1,int
4977,457674,zuiSdsFromValue,1,zuiSdsFromValue,sds zuiSdsFromValue (zsetopval*),t_zset.c,"sds zuiSdsFromValue(zsetopval *val) {
    if (val->ele == NULL) {
        if (val->estr != NULL) {
            val->ele = sdsnewlen((char*)val->estr,val->elen);
        } else {
            val->ele = sdsfromlonglong(val->ell);
        }
        val->flags |= OPVAL_DIRTY_SDS;
    }
    return val->ele;
}",2249.0,2259.0,1.0,22.0,11.0,11,5,9,2,0,8,3,4,2,1,,0,8,2,1,1,sds
4978,457727,zuiNewSdsFromValue,1,zuiNewSdsFromValue,sds zuiNewSdsFromValue (zsetopval*),t_zset.c,"sds zuiNewSdsFromValue(zsetopval *val) {
    if (val->flags & OPVAL_DIRTY_SDS) {
        /* We have already one to return! */
        sds ele = val->ele;
        val->flags &= ~OPVAL_DIRTY_SDS;
        val->ele = NULL;
        return ele;
    } else if (val->ele) {
        return sdsdup(val->ele);
    } else if (val->estr) {
        return sdsnewlen((char*)val->estr,val->elen);
    } else {
        return sdsfromlonglong(val->ell);
    }
}",2263.0,2277.0,1.0,21.0,15.0,8,4,7,3,4,4,2,2,1,0,,0,4,2,1,1,sds
4979,457798,zuiBufferFromValue,1,zuiBufferFromValue,int zuiBufferFromValue (zsetopval*),t_zset.c,"int zuiBufferFromValue(zsetopval *val) {
    if (val->estr == NULL) {
        if (val->ele != NULL) {
            val->elen = sdslen(val->ele);
            val->estr = (unsigned char*)val->ele;
        } else {
            val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);
            val->estr = val->_buf;
        }
    }
    return 1;
}",2279.0,2290.0,1.0,1.0,12.0,11,5,8,2,0,7,3,4,2,1,,0,7,2,1,1,int
4980,457862,zuiFind,1,zuiFind,"int zuiFind (zsetopsrc*,zsetopval*,double*)",t_zset.c,"int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
    if (op->subject == NULL)
        return 0;

    if (op->type == OBJ_SET) {
        char *str = val->ele ? val->ele : (char *)val->estr;
        size_t len = val->ele ? sdslen(val->ele) : val->elen;
        if (setTypeIsMemberAux(op->subject, str, len, val->ell, val->ele != NULL)) {
            *score = 1.0;
            return 1;
        } else {
            return 0;
        }
    } else if (op->type == OBJ_ZSET) {
        zuiSdsFromValue(val);

        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {
                /* Score is already set by zzlFind. */
                return 1;
            } else {
                return 0;
            }
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            zset *zs = op->subject->ptr;
            dictEntry *de;
            if ((de = dictFind(zs->dict,val->ele)) != NULL) {
                *score = *(dou...",2294.0,2332.0,1.0,20.0,39.0,21,7,18,6,1,13,4,5,6,2,,0,13,6,3,3,int
4981,458051,zuiCompareByCardinality,1,zuiCompareByCardinality,"int zuiCompareByCardinality (void*,void*)",t_zset.c,"int zuiCompareByCardinality(const void *s1, const void *s2) {
    unsigned long first = zuiLength((zsetopsrc*)s1);
    unsigned long second = zuiLength((zsetopsrc*)s2);
    if (first > second) return 1;
    if (first < second) return -1;
    return 0;
}",2334.0,2340.0,1.0,1.0,7.0,7,5,8,4,1,2,3,3,0,2,,0,2,4,2,2,int
4982,458088,zuiCompareByRevCardinality,1,zuiCompareByRevCardinality,"int zuiCompareByRevCardinality (void*,void*)",t_zset.c,"static int zuiCompareByRevCardinality(const void *s1, const void *s2) {
    return zuiCompareByCardinality(s1, s2) * -1;
}",2342.0,2344.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
4983,458101,zunionInterAggregate,1,zunionInterAggregate,"void zunionInterAggregate (double*,double,int)",t_zset.c,"inline static void zunionInterAggregate(double *target, double val, int aggregate) {
    if (aggregate == REDIS_AGGR_SUM) {
        *target = *target + val;
        /* The result of adding two doubles is NaN when one variable
         * is +inf and the other is -inf. When these numbers are added,
         * we maintain the convention of the result being 0.0. */
        if (isnan(*target)) *target = 0.0;
    } else if (aggregate == REDIS_AGGR_MIN) {
        *target = val < *target ? val : *target;
    } else if (aggregate == REDIS_AGGR_MAX) {
        *target = val > *target ? val : *target;
    } else {
        /* safety net */
        serverPanic(""Unknown ZUNION/INTER aggregate type"");
    }
}",2351.0,2366.0,1.0,21.0,16.0,8,4,6,3,1,0,3,4,0,0,,0,0,6,3,3,void
4984,458181,zsetDictGetMaxElementLength,1,zsetDictGetMaxElementLength,"size_t zsetDictGetMaxElementLength (dict*,size_t*)",t_zset.c,"static size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen) {
    dictIterator *di;
    dictEntry *de;
    size_t maxelelen = 0;

    di = dictGetIterator(d);

    while((de = dictNext(di)) != NULL) {
        sds ele = dictGetKey(de);
        if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);
        if (totallen)
            (*totallen) += sdslen(ele);
    }

    dictReleaseIterator(di);

    return maxelelen;
}",2368.0,2385.0,1.0,1.0,18.0,9,5,17,7,1,7,4,6,2,7,,0,5,4,2,2,size_t
4985,458232,zdiffAlgorithm1,1,zdiffAlgorithm1,"void zdiffAlgorithm1 (zsetopsrc*,long,zset*,size_t*,size_t*)",t_zset.c,"static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* DIFF Algorithm 1:
     *
     * We perform the diff by iterating all the elements of the first set,
     * and only adding it to the target set if the element does not exist
     * into all the other sets.
     *
     * This way we perform at max N*M operations, where N is the size of
     * the first set, and M the number of sets.
     *
     * There is also a O(K*log(K)) cost for adding the resulting elements
     * to the target set, where K is the final size of the target set.
     *
     * The final complexity of this algorithm is O(N*M + K*log(K)). */
    int j;
    zsetopval zval;
    zskiplistNode *znode;
    sds tmp;

    /* With algorithm 1 it is better to order the sets to subtract
     * by decreasing size, so that we are more likely to find
     * duplicated elements ASAP. */
    qsort(src+1,setnum-1,sizeof(zsetopsrc),zuiCompareByRevCardinality);

    m...",2387.0,2439.0,1.0,1.0,53.0,41,15,37,12,1,15,7,12,3,10,,0,11,10,5,5,void
4986,458368,zdiffAlgorithm2,1,zdiffAlgorithm2,"void zdiffAlgorithm2 (zsetopsrc*,long,zset*,size_t*,size_t*)",t_zset.c,"static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* DIFF Algorithm 2:
     *
     * Add all the elements of the first set to the auxiliary set.
     * Then remove all the elements of all the next sets from it.
     *

     * This is O(L + (N-K)log(N)) where L is the sum of all the elements in every
     * set, N is the size of the first set, and K is the size of the result set.
     *
     * Note that from the (L-N) dict searches, (N-K) got to the zsetRemoveFromSkiplist
     * which costs log(N)
     *
     * There is also a O(K) cost at the end for finding the largest element
     * size, but this doesn't change the algorithm complexity since K < L, and
     * O(2L) is the same as O(L). */
    int j;
    int cardinality = 0;
    zsetopval zval;
    zskiplistNode *znode;
    sds tmp;

    for (j = 0; j < setnum; j++) {
        if (zuiLength(&src[j]) == 0) continue;

        memset(&zval, 0, sizeof(zval));
        zui...",2442.0,2497.0,1.0,1.0,56.0,32,10,33,10,0,17,11,15,4,10,,0,13,10,5,5,void
4987,458506,zsetChooseDiffAlgorithm,1,zsetChooseDiffAlgorithm,"int zsetChooseDiffAlgorithm (zsetopsrc*,long)",t_zset.c,"static int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum) {
    int j;

    /* Select what DIFF algorithm to use.
     *
     * Algorithm 1 is O(N*M + K*log(K)) where N is the size of the
     * first set, M the total number of sets, and K is the size of the
     * result set.
     *
     * Algorithm 2 is O(L + (N-K)log(N)) where L is the total number of elements
     * in all the sets, N is the size of the first set, and K is the size of the
     * result set.
     *
     * We compute what is the best bet with the current input here. */
    long long algo_one_work = 0;
    long long algo_two_work = 0;

    for (j = 0; j < setnum; j++) {
        /* If any other set is equal to the first set, there is nothing to be
         * done, since we would remove all elements anyway. */
        if (j > 0 && src[0].subject == src[j].subject) {
            return 0;
        }

        algo_one_work += zuiLength(&src[0]);
        algo_two_work += zuiLength(&src[j]);
    }

    /* Algorithm ...",2499.0,2531.0,1.0,1.0,33.0,20,12,17,5,1,2,3,4,0,2,,0,0,4,2,2,int
4988,458575,zdiff,1,zdiff,"void zdiff (zsetopsrc*,long,zset*,size_t*,size_t*)",t_zset.c,"static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* Skip everything if the smallest input is empty. */
    if (zuiLength(&src[0]) > 0) {
        int diff_algo = zsetChooseDiffAlgorithm(src, setnum);
        if (diff_algo == 1) {
            zdiffAlgorithm1(src, setnum, dstzset, maxelelen, totelelen);
        } else if (diff_algo == 2) {
            zdiffAlgorithm2(src, setnum, dstzset, maxelelen, totelelen);
        } else if (diff_algo != 0) {
            serverPanic(""Unknown algorithm"");
        }
    }
}",2533.0,2545.0,1.0,12.0,13.0,5,5,10,6,0,3,3,4,1,3,,0,2,10,5,5,void
4989,458649,zunionInterDiffGenericCommand,1,zunionInterDiffGenericCommand,"void zunionInterDiffGenericCommand (client*,robj*,int,int,int)",t_zset.c,"void zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, int op,
                                   int cardinality_only) {
    int i, j;
    long setnum;
    int aggregate = REDIS_AGGR_SUM;
    zsetopsrc *src;
    zsetopval zval;
    sds tmp;
    size_t maxelelen = 0, totelelen = 0;
    robj *dstobj = NULL;
    zset *dstzset = NULL;
    zskiplistNode *znode;
    int withscores = 0;
    unsigned long cardinality = 0;
    long limit = 0; /* Stop searching after reaching the limit. 0 means unlimited. */

    /* expect setnum input keys to be given */
    if ((getLongFromObjectOrReply(c, c->argv[numkeysIndex], &setnum, NULL) != C_OK))
        return;

    if (setnum < 1) {
        addReplyErrorFormat(c,
            ""at least 1 input key is needed for '%s' command"", c->cmd->fullname);
        return;
    }

    /* test if the expected number of keys would overflow */
    if (setnum > (c->argc-(numkeysIndex+1))) {
        addReplyErrorObject(c,shared.syntaxerr);
    ...",2569.0,2860.0,1.0,20.0,292.0,136,22,136,26,0,39,25,58,10,23,,0,24,10,5,5,void
4990,459961,zrangeResultBeginClient,1,zrangeResultBeginClient,"void zrangeResultBeginClient (zrange_result_handler*,long)",t_zset.c,"static void zrangeResultBeginClient(zrange_result_handler *handler, long length) {
    if (length > 0) {
        /* In case of WITHSCORES, respond with a single array in RESP2, and
        * nested arrays in RESP3. We can't use a map response type since the
        * client library needs to know to respect the order. */
        if (handler->withscores && (handler->client->resp == 2)) {
            length *= 2;
        }
        addReplyArrayLen(handler->client, length);
        handler->userdata = NULL;
        return;
    }
    handler->userdata = addReplyDeferredLen(handler->client);
}",2942.0,2955.0,1.0,1.0,14.0,13,6,10,3,0,8,3,4,2,2,,0,7,4,2,2,void
4991,460007,zrangeResultEmitCBufferToClient,1,zrangeResultEmitCBufferToClient,"void zrangeResultEmitCBufferToClient (zrange_result_handler*,void*,size_t,double)",t_zset.c,"static void zrangeResultEmitCBufferToClient(zrange_result_handler *handler,
    const void *value, size_t value_length_in_bytes, double score)
{
    if (handler->should_emit_array_length) {
        addReplyArrayLen(handler->client, 2);
    }

    addReplyBulkCBuffer(handler->client, value, value_length_in_bytes);

    if (handler->withscores) {
        addReplyDouble(handler->client, score);
    }
}",2957.0,2969.0,1.0,1.0,13.0,5,1,8,4,0,8,3,3,2,3,,0,5,8,4,4,void
4992,460041,zrangeResultEmitLongLongToClient,1,zrangeResultEmitLongLongToClient,"void zrangeResultEmitLongLongToClient (zrange_result_handler*,long long,double)",t_zset.c,"static void zrangeResultEmitLongLongToClient(zrange_result_handler *handler,
    long long value, double score)
{
    if (handler->should_emit_array_length) {
        addReplyArrayLen(handler->client, 2);
    }

    addReplyBulkLongLong(handler->client, value);

    if (handler->withscores) {
        addReplyDouble(handler->client, score);
    }
}",2971.0,2983.0,1.0,1.0,13.0,5,1,7,3,0,8,3,3,2,3,,0,5,6,3,3,void
4993,460073,zrangeResultFinalizeClient,1,zrangeResultFinalizeClient,"void zrangeResultFinalizeClient (zrange_result_handler*,size_t)",t_zset.c,"static void zrangeResultFinalizeClient(zrange_result_handler *handler,
    size_t result_count)
{
    /* If the reply size was know at start there's nothing left to do */
    if (!handler->userdata)
        return;
    /* In case of WITHSCORES, respond with a single array in RESP2, and
     * nested arrays in RESP3. We can't use a map response type since the
     * client library needs to know to respect the order. */
    if (handler->withscores && (handler->client->resp == 2)) {
        result_count *= 2;
    }

    setDeferredArrayLen(handler->client, handler->userdata, result_count);
}",2985.0,2999.0,1.0,1.0,15.0,10,5,7,2,0,6,3,3,3,1,,0,5,4,2,2,void
4994,460110,zrangeResultBeginStore,1,zrangeResultBeginStore,"void zrangeResultBeginStore (zrange_result_handler*,long)",t_zset.c,"static void zrangeResultBeginStore(zrange_result_handler *handler, long length)
{
    handler->dstobj = zsetTypeCreate(length, 0);
}",3002.0,3005.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,1,,0,2,4,2,2,void
4995,460123,zrangeResultEmitCBufferForStore,1,zrangeResultEmitCBufferForStore,"void zrangeResultEmitCBufferForStore (zrange_result_handler*,void*,size_t,double)",t_zset.c,"static void zrangeResultEmitCBufferForStore(zrange_result_handler *handler,
    const void *value, size_t value_length_in_bytes, double score)
{
    double newscore;
    int retflags = 0;
    sds ele = sdsnewlen(value, value_length_in_bytes);
    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);
    sdsfree(ele);
    serverAssert(retval);
}",3007.0,3016.0,1.0,54.0,10.0,10,7,13,8,0,5,1,1,0,4,,0,3,8,4,4,void
4996,460175,zrangeResultEmitLongLongForStore,1,zrangeResultEmitLongLongForStore,"void zrangeResultEmitLongLongForStore (zrange_result_handler*,long long,double)",t_zset.c,"static void zrangeResultEmitLongLongForStore(zrange_result_handler *handler,
    long long value, double score)
{
    double newscore;
    int retflags = 0;
    sds ele = sdsfromlonglong(value);
    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);
    sdsfree(ele);
    serverAssert(retval);
}",3018.0,3027.0,1.0,54.0,10.0,10,7,12,7,0,5,1,1,0,4,,0,3,6,3,3,void
4997,460225,zrangeResultFinalizeStore,1,zrangeResultFinalizeStore,"void zrangeResultFinalizeStore (zrange_result_handler*,size_t)",t_zset.c,"static void zrangeResultFinalizeStore(zrange_result_handler *handler, size_t result_count)
{
    if (result_count) {
        setKey(handler->client, handler->client->db, handler->dstkey, handler->dstobj, 0);
        addReplyLongLong(handler->client, result_count);
        notifyKeyspaceEvent(NOTIFY_ZSET, ""zrangestore"", handler->dstkey, handler->client->db->id);
        server.dirty++;
    } else {
        addReply(handler->client, shared.czero);
        if (dbDelete(handler->client->db, handler->dstkey)) {
            signalModifiedKey(handler->client, handler->client->db, handler->dstkey);
            notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", handler->dstkey, handler->client->db->id);
            server.dirty++;
        }
    }
    decrRefCount(handler->dstobj);
}",3029.0,3045.0,1.0,28.0,17.0,14,4,11,3,0,12,2,2,0,4,,0,8,4,2,2,void
4998,460333,zrangeResultHandlerInit,1,zrangeResultHandlerInit,"void zrangeResultHandlerInit (zrange_result_handler*,client*,zrange_consumer_type)",t_zset.c,"static void zrangeResultHandlerInit(zrange_result_handler *handler,
    client *client, zrange_consumer_type type)
{
    memset(handler, 0, sizeof(*handler));

    handler->client = client;

    switch (type) {
    case ZRANGE_CONSUMER_TYPE_CLIENT:
        handler->beginResultEmission = zrangeResultBeginClient;
        handler->finalizeResultEmission = zrangeResultFinalizeClient;
        handler->emitResultFromCBuffer = zrangeResultEmitCBufferToClient;
        handler->emitResultFromLongLong = zrangeResultEmitLongLongToClient;
        break;

    case ZRANGE_CONSUMER_TYPE_INTERNAL:
        handler->beginResultEmission = zrangeResultBeginStore;
        handler->finalizeResultEmission = zrangeResultFinalizeStore;
        handler->emitResultFromCBuffer = zrangeResultEmitCBufferForStore;
        handler->emitResultFromLongLong = zrangeResultEmitLongLongForStore;
        break;
    }
}",3048.0,3070.0,1.0,1.0,23.0,20,4,15,5,0,9,4,2,0,0,,0,9,6,3,3,void
4999,460400,zrangeResultHandlerScoreEmissionEnable,1,zrangeResultHandlerScoreEmissionEnable,void zrangeResultHandlerScoreEmissionEnable (zrange_result_handler*),t_zset.c,"static void zrangeResultHandlerScoreEmissionEnable(zrange_result_handler *handler) {
    handler->withscores = 1;
    handler->should_emit_array_length = (handler->client->resp > 2);
}",3072.0,3075.0,1.0,1.0,4.0,7,3,3,1,0,3,1,1,0,0,,0,3,2,1,1,void
5000,460421,zrangeResultHandlerDestinationKeySet,1,zrangeResultHandlerDestinationKeySet,"void zrangeResultHandlerDestinationKeySet (zrange_result_handler*,robj*)",t_zset.c,"static void zrangeResultHandlerDestinationKeySet (zrange_result_handler *handler,
    robj *dstkey)
{
    handler->dstkey = dstkey;
}",3077.0,3081.0,1.0,1.0,5.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
5001,460432,genericZrangebyrankCommand,1,genericZrangebyrankCommand,"void genericZrangebyrankCommand (zrange_result_handler*,robj*,long,long,int,int)",t_zset.c,"void genericZrangebyrankCommand(zrange_result_handler *handler,
    robj *zobj, long start, long end, int withscores, int reverse) {

    client *c = handler->client;
    long llen;
    long rangelen;
    size_t result_cardinality;

    /* Sanitize indexes. */
    llen = zsetLength(zobj);
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;


    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        handler->beginResultEmission(handler, 0);
        handler->finalizeResultEmission(handler, 0);
        return;
    }
    if (end >= llen) end = llen-1;
    rangelen = (end-start)+1;
    result_cardinality = rangelen;

    handler->beginResultEmission(handler, rangelen);
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char ...",3084.0,3173.0,1.0,26.0,90.0,56,19,80,18,0,14,12,20,0,8,,0,11,12,6,6,void
5002,460890,genericZrangebyscoreCommand,1,genericZrangebyscoreCommand,"void genericZrangebyscoreCommand (zrange_result_handler*,zrangespec*,robj*,long,long,int)",t_zset.c,"void genericZrangebyscoreCommand(zrange_result_handler *handler,
    zrangespec *range, robj *zobj, long offset, long limit, 
    int reverse) {
    unsigned long rangelen = 0;

    handler->beginResultEmission(handler, -1);

    /* For invalid offset, return directly. */
    if (offset > 0 && offset >= (long)zsetLength(zobj)) {
        handler->finalizeResultEmission(handler, 0);
        return;
    }

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        /* If reversed, get the last node in range as starting point. */
        if (reverse) {
            eptr = zzlLastInRange(zl,range);
        } else {
            eptr = zzlFirstInRange(zl,range);
        }

        /* Get score pointer for the first element. */
        if (eptr)
            sptr = lpNext(zl,eptr);

        /* If there is an offset, just traverse the numbe...",3199.0,3310.0,1.0,26.0,112.0,31,12,50,15,0,12,13,27,2,8,,0,10,12,6,6,void
5003,461752,genericZrangebylexCommand,1,genericZrangebylexCommand,"void genericZrangebylexCommand (zrange_result_handler*,zlexrangespec*,robj*,int,long,long,int)",t_zset.c,"void genericZrangebylexCommand(zrange_result_handler *handler,
    zlexrangespec *range, robj *zobj, int withscores, long offset, long limit,
    int reverse)
{
    unsigned long rangelen = 0;

    handler->beginResultEmission(handler, -1);

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        /* If reversed, get the last node in range as starting point. */
        if (reverse) {
            eptr = zzlLastInLexRange(zl,range);
        } else {
            eptr = zzlFirstInLexRange(zl,range);
        }

        /* Get score pointer for the first element. */
        if (eptr)
            sptr = lpNext(zl,eptr);

        /* If there is an offset, just traverse the number of elements without
         * checking the score because that is done in the next loop. */
        while (eptr && offset--) {
            if (reverse) {
   ...",3483.0,3591.0,1.0,26.0,109.0,27,9,47,16,0,10,13,29,1,7,,0,8,14,7,7,void
5004,462785,zrankGenericCommand,1,zrankGenericCommand,"void zrankGenericCommand (client*,int)",t_zset.c,"void zrankGenericCommand(client *c, int reverse) {
    robj *key = c->argv[1];
    robj *ele = c->argv[2];
    robj *zobj;
    robj* reply;
    long rank;
    int opt_withscore = 0;
    double score;

    if (c->argc > 4) {
        addReplyErrorArity(c);
        return;
    }
    if (c->argc > 3) {
        if (!strcasecmp(c->argv[3]->ptr, ""withscore"")) {
            opt_withscore = 1;
        } else {
            addReplyErrorObject(c, shared.syntaxerr);
            return;
        }
    }
    reply = opt_withscore ? shared.nullarray[c->resp] : shared.null[c->resp];
    if ((zobj = lookupKeyReadOrReply(c, key, reply)) == NULL || checkType(c, zobj, OBJ_ZSET)) {
        return;
    }
    serverAssertWithInfo(c, ele, sdsEncodedObject(ele));
    rank = zsetRank(zobj, ele->ptr, reverse, opt_withscore ? &score : NULL);
    if (rank >= 0) {
        if (opt_withscore) {
            addReplyArrayLen(c, 2);
        }
        addReplyLongLong(c, rank);
        if (opt_withscore) {
            ...",3808.0,3850.0,1.0,83.0,43.0,41,14,44,11,0,15,8,11,5,8,,0,10,4,2,2,void
5005,463548,zpopMinMaxCommand,1,zpopMinMaxCommand,"void zpopMinMaxCommand (client*,int)",t_zset.c,"void zpopMinMaxCommand(client *c, int where) {
    if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    long count = -1; /* -1 for plain single pop. */
    if (c->argc == 3 && getPositiveLongFromObjectOrReply(c, c->argv[2], &count, NULL) != C_OK)
        return;

    /* Respond with a single (flat) array in RESP2 or if count is -1
     * (returning a single element). In RESP3, when count > 0 use nested array. */
    int use_nested_array = (c->resp > 2 && count != -1);

    genericZpopCommand(c, &c->argv[1], 1, where, 0, count, use_nested_array, 0, NULL);
}",4028.0,4043.0,1.0,89.0,16.0,21,10,18,6,0,8,3,3,4,3,,0,6,4,2,2,void
5006,463643,blockingGenericZpopCommand,1,blockingGenericZpopCommand,"void blockingGenericZpopCommand (client*,robj**,int,int,int,long,int,int)",t_zset.c,"void blockingGenericZpopCommand(client *c, robj **keys, int numkeys, int where,
                                int timeout_idx, long count, int use_nested_array, int reply_nil_when_empty) {
    robj *o;
    robj *key;
    mstime_t timeout;
    int j;

    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)
        != C_OK) return;

    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db,key);
        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c,o,OBJ_ZSET)) return;

        long llen = zsetLength(o);
        /* Empty zset, move to next key. */
        if (llen == 0) continue;

        /* Non empty zset, this is like a normal ZPOP[MIN|MAX]. */
        genericZpopCommand(c, &key, 1, where, 1, count, use_nested_array, reply_nil_when_empty, NULL);

        if (count == -1) {
            /* Replicate it as ZPOP[MIN|MAX] instead of BZPOP[MIN|MAX]. */
            rewriteCli...",4068.0,4119.0,1.0,68.0,52.0,23,12,40,16,1,11,10,12,4,8,,0,7,16,8,8,void
5007,463871,zrandmemberReplyWithListpack,1,zrandmemberReplyWithListpack,"void zrandmemberReplyWithListpack (client*,unsigned int,listpackEntry*,listpackEntry*)",t_zset.c,"static void zrandmemberReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    for (unsigned long i = 0; i < count; i++) {
        if (vals && c->resp > 2)
            addReplyArrayLen(c,2);
        if (keys[i].sval)
            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);
        else
            addReplyBulkLongLong(c, keys[i].lval);
        if (vals) {
            if (vals[i].sval) {
                addReplyDouble(c, zzlStrtod(vals[i].sval,vals[i].slen));
            } else
                addReplyDouble(c, vals[i].lval);
        }
    }
}",4131.0,4146.0,1.0,1.0,16.0,17,7,21,5,1,5,6,11,1,4,,0,2,8,4,4,void
5008,463963,zrandmemberWithCountCommand,1,zrandmemberWithCountCommand,"void zrandmemberWithCountCommand (client*,long,int)",t_zset.c,"void zrandmemberWithCountCommand(client *c, long l, int withscores) {
    unsigned long count, size;
    int uniq = 1;
    robj *zsetobj;

    if ((zsetobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptyarray))
        == NULL || checkType(c, zsetobj, OBJ_ZSET)) return;
    size = zsetLength(zsetobj);

    if(l >= 0) {
        count = (unsigned long) l;
    } else {
        count = -l;
        uniq = 0;
    }

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time.
     * This case is trivial and can be served without auxiliary data
     * structures. This case is the only one that also needs to return the
     * elements in random order. */
    if (!uniq || count == 1) {
        if (withscores && c->resp == 2)
            addReplyArrayLen(c,...",4158.0,4360.0,1.0,41.0,203.0,113,24,141,21,0,67,26,53,12,52,,0,37,6,3,3,void
5009,464759,zmpopGenericCommand,1,zmpopGenericCommand,"void zmpopGenericCommand (client*,int,int)",t_zset.c,"void zmpopGenericCommand(client *c, int numkeys_idx, int is_block) {
    long j;
    long numkeys = 0;      /* Number of keys. */
    int where = 0;         /* ZSET_MIN or ZSET_MAX. */
    long count = -1;       /* Reply will consist of up to count elements, depending on the zset's length. */

    /* Parse the numkeys. */
    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;

    /* Parse the where. where_idx: the index of where in the c->argv. */
    long where_idx = numkeys_idx + numkeys + 1;
    if (where_idx >= c->argc) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    if (!strcasecmp(c->argv[where_idx]->ptr, ""MIN"")) {
        where = ZSET_MIN;
    } else if (!strcasecmp(c->argv[where_idx]->ptr, ""MAX"")) {
        where = ZSET_MAX;
    } else {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }

    /* ...",4399.0,4450.0,1.0,87.0,52.0,47,15,46,12,0,12,9,12,7,4,,0,10,6,3,3,void
5010,465022,checkBlockedClientTimeout,1,checkBlockedClientTimeout,"int checkBlockedClientTimeout (client*,mstime_t)",timeout.c,"int checkBlockedClientTimeout(client *c, mstime_t now) {
    if (c->flags & CLIENT_BLOCKED &&
        c->bstate.timeout != 0
        && c->bstate.timeout < now)
    {
        /* Handle blocking operation specific timeout. */
        unblockClientOnTimeout(c);
        return 1;
    } else {
        return 0;
    }
}",39.0,50.0,1.0,19.0,12.0,11,7,5,2,0,4,2,2,3,1,,0,3,4,2,2,int
5011,465176,encodeTimeoutKey,1,encodeTimeoutKey,"void encodeTimeoutKey (unsigned char*,uint64_t,client*)",timeout.c,"void encodeTimeoutKey(unsigned char *buf, uint64_t timeout, client *c) {
    timeout = htonu64(timeout);
    memcpy(buf,&timeout,sizeof(timeout));
    memcpy(buf+8,&c,sizeof(c));
    if (sizeof(c) == 4) memset(buf+12,0,4); /* Zero padding for 32bit target. */
}",97.0,102.0,1.0,14.0,6.0,9,5,11,3,0,1,2,2,0,1,,0,1,6,3,3,void
5012,465216,decodeTimeoutKey,1,decodeTimeoutKey,"void decodeTimeoutKey (unsigned char*,uint64_t*,client**)",timeout.c,"void decodeTimeoutKey(unsigned char *buf, uint64_t *toptr, client **cptr) {
    memcpy(toptr,buf,sizeof(*toptr));
    *toptr = ntohu64(*toptr);
    memcpy(cptr,buf+8,sizeof(*cptr));
}",106.0,110.0,1.0,13.0,5.0,9,4,9,3,0,1,1,1,0,1,,0,1,6,3,3,void
5013,465985,enableBcastTrackingForPrefix,1,enableBcastTrackingForPrefix,"void enableBcastTrackingForPrefix (client*,char*,size_t)",tracking.c,"void enableBcastTrackingForPrefix(client *c, char *prefix, size_t plen) {
    bcastState *bs = raxFind(PrefixTable,(unsigned char*)prefix,plen);
    /* If this is the first client subscribing to such prefix, create
     * the prefix in the table. */
    if (bs == raxNotFound) {
        bs = zmalloc(sizeof(*bs));
        bs->keys = raxNew();
        bs->clients = raxNew();
        raxInsert(PrefixTable,(unsigned char*)prefix,plen,bs,NULL);
    }
    if (raxTryInsert(bs->clients,(unsigned char*)&c,sizeof(c),NULL,NULL)) {
        if (c->client_tracking_prefixes == NULL)
            c->client_tracking_prefixes = raxNew();
        raxInsert(c->client_tracking_prefixes,
                  (unsigned char*)prefix,plen,NULL,NULL);
    }
}",155.0,171.0,1.0,1.0,17.0,21,7,28,7,0,16,4,5,3,8,,0,14,6,3,3,void
5014,466433,sendTrackingMessage,1,sendTrackingMessage,"void sendTrackingMessage (client*,char*,size_t,int)",tracking.c,"void sendTrackingMessage(client *c, char *keyname, size_t keylen, int proto) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;

    int using_redirection = 0;
    if (c->client_tracking_redirection) {
        client *redir = lookupClientByID(c->client_tracking_redirection);
        if (!redir) {
            c->flags |= CLIENT_TRACKING_BROKEN_REDIR;
            /* We need to signal to the original connection that we
             * are unable to send invalidation messages to the redirected
             * connection, because the client no longer exist. */
            if (c->resp > 2) {
                addReplyPushLen(c,2);
                addReplyBulkCBuffer(c,""tracking-redir-broken"",21);
                addReplyLongLong(c,c->client_tracking_redirection);
            }
            if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
            return;
        }
        if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
        c = redir;
    ...",268.0,324.0,1.0,16.0,57.0,40,7,34,7,0,21,9,15,3,8,,0,14,8,4,4,void
5015,466662,trackingRememberKeyToBroadcast,1,trackingRememberKeyToBroadcast,"void trackingRememberKeyToBroadcast (client*,char*,size_t)",tracking.c,"void trackingRememberKeyToBroadcast(client *c, char *keyname, size_t keylen) {
    raxIterator ri;
    raxStart(&ri,PrefixTable);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        if (ri.key_len > keylen) continue;
        if (ri.key_len != 0 && memcmp(ri.key,keyname,ri.key_len) != 0)
            continue;
        bcastState *bs = ri.data;
        /* We insert the client pointer as associated value in the radix
         * tree. This way we know who was the client that did the last
         * change to the key, and can avoid sending the notification in the
         * case the client is in NOLOOP mode. */
        raxInsert(bs->keys,(unsigned char*)keyname,keylen,c,NULL);
    }
    raxStop(&ri);
}",332.0,348.0,1.0,1.0,17.0,16,8,19,7,0,12,6,6,5,5,,0,8,6,3,3,void
5016,467035,freeTrackingRadixTreeCallback,1,freeTrackingRadixTreeCallback,void freeTrackingRadixTreeCallback (void*),tracking.c,"void freeTrackingRadixTreeCallback(void *rt) {
    raxFree(rt);
}",459.0,461.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
5017,467262,trackingBuildBroadcastReply,1,trackingBuildBroadcastReply,"sds trackingBuildBroadcastReply (client*,rax*)",tracking.c,"sds trackingBuildBroadcastReply(client *c, rax *keys) {
    raxIterator ri;
    uint64_t count;

    if (c == NULL) {
        count = raxSize(keys);
    } else {
        count = 0;
        raxStart(&ri,keys);
        raxSeek(&ri,""^"",NULL,0);
        while(raxNext(&ri)) {
            if (ri.data != c) count++;
        }
        raxStop(&ri);

        if (count == 0) return NULL;
    }

    /* Create the array reply with the list of keys once, then send
    * it to all the clients subscribed to this prefix. */
    char buf[32];
    size_t len = ll2string(buf,sizeof(buf),count);
    sds proto = sdsempty();
    proto = sdsMakeRoomFor(proto,count*15);
    proto = sdscatlen(proto,""*"",1);
    proto = sdscatlen(proto,buf,len);
    proto = sdscatlen(proto,""\r\n"",2);
    raxStart(&ri,keys);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        if (c && ri.data == c) continue;
        len = ll2string(buf,sizeof(buf),ri.key_len);
        proto = sdscatlen(proto,""$"",1);
        proto = ...",553.0,593.0,1.0,1.0,41.0,27,7,48,8,0,21,5,5,2,17,,0,18,4,2,2,sds
5018,467625,connUnixEventHandler,1,connUnixEventHandler,"void connUnixEventHandler (aeEventLoop*,int,void*,int)",unix.c,"static void connUnixEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask) {
    connectionTypeTcp()->ae_handler(el, fd, clientData, mask);
}",38.0,40.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,2,,0,1,8,4,4,void
5019,467641,connUnixAddr,1,connUnixAddr,"int connUnixAddr (connection*,char*,size_t,int*,int)",unix.c,"static int connUnixAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    return connectionTypeTcp()->addr(conn, ip, ip_len, port, remote);
}",42.0,44.0,1.0,1.0,3.0,1,1,5,5,0,2,1,1,0,2,,0,1,10,5,5,int
5020,467673,connUnixListen,1,connUnixListen,int connUnixListen (connListener*),unix.c,"static int connUnixListen(connListener *listener) {
    int fd;
    mode_t *perm = (mode_t *)listener->priv;

    if (listener->bindaddr_count == 0)
        return C_OK;

    /* currently listener->bindaddr_count is always 1, we still use a loop here in case Redis supports multi Unix socket in the future */
    for (int j = 0; j < listener->bindaddr_count; j++) {
        char *addr = listener->bindaddr[j];

        unlink(addr); /* don't care if this fails */
        fd = anetUnixServer(server.neterr, addr, *perm, server.tcp_backlog);
        if (fd == ANET_ERR) {
            serverLog(LL_WARNING, ""Failed opening Unix socket: %s"", server.neterr);
            exit(1);
        }
        anetNonBlock(NULL, fd);
        anetCloexec(fd);
        listener->fd[listener->count++] = fd;
    }

    return C_OK;
}",52.0,75.0,1.0,15.0,24.0,26,11,24,7,0,10,4,5,2,4,,0,7,2,1,1,int
5021,467784,connCreateUnix,1,connCreateUnix,connection connCreateUnix (void),unix.c,"static connection *connCreateUnix(void) {
    connection *conn = zcalloc(sizeof(connection));
    conn->type = &CT_Unix;
    conn->fd = -1;
    conn->iovcnt = IOV_MAX;

    return conn;
}",77.0,84.0,1.0,1.0,8.0,10,5,8,4,1,5,1,1,0,1,,0,5,2,1,1,connection
5022,467814,connCreateAcceptedUnix,1,connCreateAcceptedUnix,"connection connCreateAcceptedUnix (int,void*)",unix.c,"static connection *connCreateAcceptedUnix(int fd, void *priv) {
    UNUSED(priv);
    connection *conn = connCreateUnix();
    conn->fd = fd;
    conn->state = CONN_STATE_ACCEPTING;
    return conn;
}",86.0,92.0,1.0,4.0,7.0,6,3,8,4,1,3,1,1,0,1,,0,3,4,2,2,connection
5023,467842,connUnixAcceptHandler,1,connUnixAcceptHandler,"void connUnixAcceptHandler (aeEventLoop*,int,void*,int)",unix.c,"static void connUnixAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cfd, max = MAX_ACCEPTS_PER_CALL;
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    while(max--) {
        cfd = anetUnixAccept(server.neterr, fd);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_WARNING,
                    ""Accepting client connection: %s"", server.neterr);
            return;
        }
        serverLog(LL_VERBOSE,""Accepted connection to %s"", server.unixsocket);
        acceptCommonHandler(connCreateAcceptedUnix(cfd, NULL),CLIENT_UNIX_SOCKET,NULL);
    }
}",94.0,111.0,1.0,19.0,18.0,19,10,21,10,0,5,4,7,0,5,,0,2,8,4,4,void
5024,467952,connUnixShutdown,1,connUnixShutdown,void connUnixShutdown (connection*),unix.c,"static void connUnixShutdown(connection *conn) {
    connectionTypeTcp()->shutdown(conn);
}",113.0,115.0,1.0,1.0,3.0,1,1,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
5025,467962,connUnixClose,1,connUnixClose,void connUnixClose (connection*),unix.c,"static void connUnixClose(connection *conn) {
    connectionTypeTcp()->close(conn);
}",117.0,119.0,1.0,1.0,3.0,1,1,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
5026,467972,connUnixAccept,1,connUnixAccept,"int connUnixAccept (connection*,ConnectionCallbackFunc)",unix.c,"static int connUnixAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    return connectionTypeTcp()->accept(conn, accept_handler);
}",121.0,123.0,1.0,1.0,3.0,1,1,2,2,0,2,1,1,0,2,,0,1,4,2,2,int
5027,467985,connUnixWrite,1,connUnixWrite,"int connUnixWrite (connection*,void*,size_t)",unix.c,"static int connUnixWrite(connection *conn, const void *data, size_t data_len) {
    return connectionTypeTcp()->write(conn, data, data_len);
}",125.0,127.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
5028,468000,connUnixWritev,1,connUnixWritev,"int connUnixWritev (connection*,iovec*,int)",unix.c,"static int connUnixWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    return connectionTypeTcp()->writev(conn, iov, iovcnt);
}",129.0,131.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
5029,468015,connUnixRead,1,connUnixRead,"int connUnixRead (connection*,void*,size_t)",unix.c,"static int connUnixRead(connection *conn, void *buf, size_t buf_len) {
    return connectionTypeTcp()->read(conn, buf, buf_len);
}",133.0,135.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
5030,468030,connUnixSetWriteHandler,1,connUnixSetWriteHandler,"int connUnixSetWriteHandler (connection*,ConnectionCallbackFunc,int)",unix.c,"static int connUnixSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {
    return connectionTypeTcp()->set_write_handler(conn, func, barrier);
}",137.0,139.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
5031,468045,connUnixSetReadHandler,1,connUnixSetReadHandler,"int connUnixSetReadHandler (connection*,ConnectionCallbackFunc)",unix.c,"static int connUnixSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    return connectionTypeTcp()->set_read_handler(conn, func);
}",141.0,143.0,1.0,1.0,3.0,1,1,2,2,0,2,1,1,0,2,,0,1,4,2,2,int
5032,468058,connUnixGetLastError,1,connUnixGetLastError,const char* connUnixGetLastError (connection*),unix.c,"static const char *connUnixGetLastError(connection *conn) {
    return strerror(conn->last_errno);
}",145.0,147.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,const char*
5033,468068,connUnixSyncWrite,1,connUnixSyncWrite,"ssize_t connUnixSyncWrite (connection*,char*,ssize_t,long long)",unix.c,"static ssize_t connUnixSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncWrite(conn->fd, ptr, size, timeout);
}",149.0,151.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
5034,468084,connUnixSyncRead,1,connUnixSyncRead,"ssize_t connUnixSyncRead (connection*,char*,ssize_t,long long)",unix.c,"static ssize_t connUnixSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncRead(conn->fd, ptr, size, timeout);
}",153.0,155.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
5035,468100,connUnixSyncReadLine,1,connUnixSyncReadLine,"ssize_t connUnixSyncReadLine (connection*,char*,ssize_t,long long)",unix.c,"static ssize_t connUnixSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncReadLine(conn->fd, ptr, size, timeout);
}",157.0,159.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
5036,468290,stringmatchlen_impl,1,stringmatchlen_impl,"int stringmatchlen_impl (char*,int,char*,int,int,int*)",util.c,"static int stringmatchlen_impl(const char *pattern, int patternLen,
        const char *string, int stringLen, int nocase, int *skipLongerMatches)
{
    while(patternLen && stringLen) {
        switch(pattern[0]) {
        case '*':
            while (patternLen && pattern[1] == '*') {
                pattern++;
                patternLen--;
            }
            if (patternLen == 1)
                return 1; /* match */
            while(stringLen) {
                if (stringmatchlen_impl(pattern+1, patternLen-1,
                            string, stringLen, nocase, skipLongerMatches))
                    return 1; /* match */
                if (*skipLongerMatches)
                    return 0; /* no match */
                string++;
                stringLen--;
            }
            /* There was no match for the rest of the pattern starting
             * from anywhere in the rest of the string. If there were
             * any '*' earlier in the pattern, we can termin...",56.0,187.0,1.0,1.0,132.0,61,12,60,8,1,0,25,58,0,0,,0,0,12,6,6,int
5037,468675,stringmatchlen,1,stringmatchlen,"int stringmatchlen (char*,int,char*,int,int)",util.c,"int stringmatchlen(const char *pattern, int patternLen,
        const char *string, int stringLen, int nocase) {
    int skipLongerMatches = 0;
    return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches);
}",189.0,193.0,1.0,1.0,5.0,2,2,7,6,9,1,1,1,0,1,,0,0,10,5,5,int
5038,468697,stringmatch,1,stringmatch,"int stringmatch (char*,char*,int)",util.c,"int stringmatch(const char *pattern, const char *string, int nocase) {
    return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);
}",195.0,197.0,1.0,1.0,3.0,0,0,5,3,2,1,1,1,0,1,,0,0,6,3,3,int
5039,468713,stringmatchlen_fuzz_test,1,stringmatchlen_fuzz_test,int stringmatchlen_fuzz_test (void),util.c,"int stringmatchlen_fuzz_test(void) {
    char str[32];
    char pat[32];
    int cycles = 10000000;
    int total_matches = 0;
    while(cycles--) {
        int strlen = rand() % sizeof(str);
        int patlen = rand() % sizeof(pat);
        for (int j = 0; j < strlen; j++) str[j] = rand() % 128;
        for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;
        total_matches += stringmatchlen(pat, patlen, str, strlen, 0);
    }
    return total_matches;
}",200.0,213.0,1.0,1.0,14.0,14,6,19,7,0,1,4,6,0,1,,0,0,2,1,1,int
5040,468792,memtoull,1,memtoull,"unsigned long long memtoull (char*,int*)",util.c,"unsigned long long memtoull(const char *p, int *err) {
    const char *u;
    char buf[128];
    long mul; /* unit multiplier */
    unsigned long long val;
    unsigned int digits;

    if (err) *err = 0;

    /* Search the first non digit character. */
    u = p;
    if (*u == '-') {
        if (err) *err = 1;
        return 0;
    }
    while(*u && isdigit(*u)) u++;
    if (*u == '\0' || !strcasecmp(u,""b"")) {
        mul = 1;
    } else if (!strcasecmp(u,""k"")) {
        mul = 1000;
    } else if (!strcasecmp(u,""kb"")) {
        mul = 1024;
    } else if (!strcasecmp(u,""m"")) {
        mul = 1000*1000;
    } else if (!strcasecmp(u,""mb"")) {
        mul = 1024*1024;
    } else if (!strcasecmp(u,""g"")) {
        mul = 1000L*1000*1000;
    } else if (!strcasecmp(u,""gb"")) {
        mul = 1024L*1024*1024;
    } else {
        if (err) *err = 1;
        return 0;
    }

    /* Copy the digits into a buffer, we'll use strtoll() to convert
     * the digit (without the unit) into a number. */...",223.0,276.0,1.0,1.0,54.0,35,13,36,10,3,0,10,13,0,0,,0,0,4,2,2,unsigned long long
5041,469007,mempbrk,1,mempbrk,"const char* mempbrk (char*,size_t,char*,size_t)",util.c,"const char *mempbrk(const char *s, size_t len, const char *chars, size_t charslen) {
    for (size_t j = 0; j < len; j++) {
        for (size_t n = 0; n < charslen; n++)
            if (s[j] == chars[n]) return &s[j];
    }

    return NULL;
}",281.0,288.0,1.0,1.0,8.0,4,2,7,5,1,0,3,4,0,0,,0,0,8,4,4,const char*
5042,469054,memmapchars,1,memmapchars,"char* memmapchars (char*,size_t,char*,char*,size_t)",util.c,"char *memmapchars(char *s, size_t len, const char *from, const char *to, size_t setlen) {
    for (size_t j = 0; j < len; j++) {
        for (size_t i = 0; i < setlen; i++) {
            if (s[j] == from[i]) {
                s[j] = to[i];
                break;
            }
        }
    }
    return s;
}",293.0,303.0,1.0,1.0,11.0,10,4,15,7,1,0,5,7,0,0,,0,0,10,5,5,char*
5043,469106,digits10,1,digits10,uint32_t digits10 (uint64_t),util.c,"uint32_t digits10(uint64_t v) {
    if (v < 10) return 1;
    if (v < 100) return 2;
    if (v < 1000) return 3;
    if (v < 1000000000000UL) {
        if (v < 100000000UL) {
            if (v < 1000000) {
                if (v < 10000) return 4;
                return 5 + (v >= 100000);
            }
            return 7 + (v >= 10000000UL);
        }
        if (v < 10000000000UL) {
            return 9 + (v >= 1000000000UL);
        }
        return 11 + (v >= 100000000000UL);
    }
    return 12 + digits10(v / 1000000000000UL);
}",307.0,325.0,1.0,1.0,19.0,18,4,13,1,3,0,9,16,0,0,,0,0,2,1,1,uint32_t
5044,469190,sdigits10,1,sdigits10,uint32_t sdigits10 (int64_t),util.c,"uint32_t sdigits10(int64_t v) {
    if (v < 0) {
        /* Abs value of LLONG_MIN requires special handling. */
        uint64_t uv = (v != LLONG_MIN) ?
                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;
        return digits10(uv)+1; /* +1 for the minus. */
    } else {
        return digits10(v);
    }
}",328.0,337.0,1.0,1.0,10.0,8,7,8,5,1,1,2,2,0,1,,0,0,2,1,1,uint32_t
5045,469225,ll2string,1,ll2string,"int ll2string (char*,size_t,long long)",util.c,"int ll2string(char *dst, size_t dstlen, long long svalue) {
    unsigned long long value;
    int negative = 0;

    /* The ull2string function with 64bit unsigned integers for simplicity, so
     * we convert the number here and remember if it is negative. */
    if (svalue < 0) {
        if (svalue != LLONG_MIN) {
            value = -svalue;
        } else {
            value = ((unsigned long long) LLONG_MAX)+1;
        }
        if (dstlen < 2)
            goto err;
        negative = 1;
        dst[0] = '-';
        dst++;
        dstlen--;
    } else {
        value = svalue;
    }

    /* Converts the unsigned long long value to string*/
    int length = ull2string(dst, dstlen, value);
    if (length == 0) return 0;
    return length + negative;

err:
    /* force add Null termination */
    if (dstlen > 0)
        dst[0] = '\0';
    return 0;
}",342.0,374.0,1.0,1.0,33.0,17,10,20,7,33,1,7,8,0,1,,0,1,6,3,3,int
5046,469314,ull2string,1,ull2string,"int ull2string (char*,size_t,long long unsigned)",util.c,"int ull2string(char *dst, size_t dstlen, unsigned long long value) {
    static const char digits[201] =
        ""0001020304050607080910111213141516171819""
        ""2021222324252627282930313233343536373839""
        ""4041424344454647484950515253545556575859""
        ""6061626364656667686970717273747576777879""
        ""8081828384858687888990919293949596979899"";

    /* Check length. */
    uint32_t length = digits10(value);
    if (length >= dstlen) goto err;;

    /* Null term. */
    uint32_t next = length - 1;
    dst[next + 1] = '\0';
    while (value >= 100) {
        int const i = (value % 100) * 2;
        value /= 100;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
        next -= 2;
    }

    /* Handle last 1-2 digits. */
    if (value < 10) {
        dst[next] = '0' + (uint32_t) value;
    } else {
        int i = (uint32_t) value * 2;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
    }
    return length;
err:
    /* force add N...",384.0,421.0,1.0,1.0,38.0,30,12,29,7,3,1,6,5,0,1,,0,1,6,3,3,int
5047,469443,string2ll,1,string2ll,"int string2ll (char*,size_t,long long*)",util.c,"int string2ll(const char *s, size_t slen, long long *value) {
    const char *p = s;
    size_t plen = 0;
    int negative = 0;
    unsigned long long v;

    /* A string of zero length or excessive length is not a valid number. */
    if (plen == slen || slen >= LONG_STR_SIZE)
        return 0;

    /* Special case: first and only digit is 0. */
    if (slen == 1 && p[0] == '0') {
        if (value != NULL) *value = 0;
        return 1;
    }

    /* Handle negative numbers: just set a flag and continue like if it
     * was a positive number. Later convert into negative. */
    if (p[0] == '-') {
        negative = 1;
        p++; plen++;

        /* Abort on only a negative sign. */
        if (plen == slen)
            return 0;
    }

    /* First digit should be 1-9, otherwise the string should just be 0. */
    if (p[0] >= '1' && p[0] <= '9') {
        v = p[0]-'0';
        p++; plen++;
    } else {
        return 0;
    }

    /* Parse all the other digits, checking for over...",435.0,499.0,1.0,32.0,65.0,58,19,47,10,23,0,14,20,0,0,,0,0,6,3,3,int
5048,469654,string2ull,1,string2ull,"int string2ull (char*,long long unsigned*)",util.c,"int string2ull(const char *s, unsigned long long *value) {
    long long ll;
    if (string2ll(s,strlen(s),&ll)) {
        if (ll < 0) return 0; /* Negative values are out of range. */
        *value = ll;
        return 1;
    }
    errno = 0;
    char *endptr = NULL;
    *value = strtoull(s,&endptr,10);
    if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0'))
        return 0; /* strtoull() failed. */
    return 1; /* Conversion done! */
}",506.0,519.0,1.0,1.0,14.0,19,9,18,8,3,1,4,5,1,1,,0,1,4,2,2,int
5049,469721,string2l,1,string2l,"int string2l (char*,size_t,long*)",util.c,"int string2l(const char *s, size_t slen, long *lval) {
    long long llval;

    if (!string2ll(s,slen,&llval))
        return 0;

    if (llval < LONG_MIN || llval > LONG_MAX)
        return 0;

    *lval = (long)llval;
    return 1;
}",524.0,535.0,1.0,1.0,12.0,8,8,9,6,1,1,3,3,1,1,,0,1,6,3,3,int
5050,469758,string2ld,1,string2ld,"int string2ld (char*,size_t,long double*)",util.c,"int string2ld(const char *s, size_t slen, long double *dp) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    long double value;
    char *eptr;

    if (slen == 0 || slen >= sizeof(buf)) return 0;
    memcpy(buf,s,slen);
    buf[slen] = '\0';

    errno = 0;
    value = strtold(buf, &eptr);
    if (isspace(buf[0]) || eptr[0] != '\0' ||
        (size_t)(eptr-buf) != slen ||
        (errno == ERANGE &&
            (value == HUGE_VAL || value == -HUGE_VAL || fpclassify(value) == FP_ZERO)) ||
        errno == EINVAL ||
        isnan(value))
        return 0;

    if (dp) *dp = value;
    return 1;
}",544.0,565.0,1.0,13.0,22.0,30,12,31,11,2,0,4,4,0,0,,0,0,6,3,3,int
5051,469853,string2d,1,string2d,"int string2d (char*,size_t,double*)",util.c,"int string2d(const char *s, size_t slen, double *dp) {
    errno = 0;
    char *eptr;
    *dp = strtod(s, &eptr);
    if (slen == 0 ||
        isspace(((const char*)s)[0]) ||
        (size_t)(eptr-(char*)s) != slen ||
        (errno == ERANGE &&
            (*dp == HUGE_VAL || *dp == -HUGE_VAL || fpclassify(*dp) == FP_ZERO)) ||
        isnan(*dp))
        return 0;
    return 1;
}",574.0,586.0,1.0,1.0,13.0,26,11,18,8,2,0,2,2,0,0,,0,0,6,3,3,int
5052,469921,double2ll,1,double2ll,"int double2ll (double,long long*)",util.c,"int double2ll(double d, long long *out) {
#if (DBL_MANT_DIG >= 52) && (DBL_MANT_DIG <= 63) && (LLONG_MAX == 0x7fffffffffffffffLL)
    /* Check if the float is in a safe range to be casted into a
     * long long. We are assuming that long long is 64 bit here.
     * Also we are assuming that there are no implementations around where
     * double has precision < 52 bit.
     *
     * Under this assumptions we test if a double is inside a range
     * where casting to long long is safe. Then using two castings we
     * make sure the decimal part is zero. If all this is true we can use
     * integer without precision loss.
     *
     * Note that numbers above 2^52 and below 2^63 use all the fraction bits as real part,
     * and the exponent bits are positive, which means the ""decimal"" part must be 0.
     * i.e. all double values in that range are representable as a long without precision loss,
     * but not all long values in that range can be represented as a double.
     * we ...",590.0,616.0,1.0,1.0,27.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
5053,469929,d2string,1,d2string,"int d2string (char*,size_t,double)",util.c,"int d2string(char *buf, size_t len, double value) {
    if (isnan(value)) {
        /* Libc in some systems will format nan in a different way,
         * like nan, -nan, NAN, nan(char-sequence).
         * So we normalize it and create a single nan form in an explicit way. */
        len = snprintf(buf,len,""nan"");
    } else if (isinf(value)) {
        /* Libc in odd systems (Hi Solaris!) will format infinite in a
         * different way, so better to handle it in an explicit way. */
        if (value < 0)
            len = snprintf(buf,len,""-inf"");
        else
            len = snprintf(buf,len,""inf"");
    } else if (value == 0) {
        /* See: http://en.wikipedia.org/wiki/Signed_zero, ""Comparisons"". */
        if (1.0/value < 0)
            len = snprintf(buf,len,""-0"");
        else
            len = snprintf(buf,len,""0"");
    } else {
        long long lvalue;
        /* Integer printing function is much faster, check if we can safely use it. */
        if (double2ll(value, ...",623.0,654.0,1.0,1.0,32.0,1,1,5,3,3,0,2,2,0,0,,0,0,6,3,3,int
5054,470028,fixedpoint_d2string,1,fixedpoint_d2string,"int fixedpoint_d2string (char*,size_t,double,int)",util.c,"int fixedpoint_d2string(char *dst, size_t dstlen, double dvalue, int fractional_digits) {
    if (fractional_digits < 1 || fractional_digits > 17)
        goto err;
    /* min size of 2 ( due to 0. ) + n fractional_digitits + \0 */
    if ((int)dstlen < (fractional_digits+3))
        goto err;
    if (dvalue == 0) {
        dst[0] = '0';
        dst[1] = '.';
        memset(dst + 2, '0', fractional_digits);
        dst[fractional_digits+2] = '\0';
        return fractional_digits + 2;
    }
    /* scale and round */
    static double powers_of_ten[] = {1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0,
    10000000.0, 100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0,
    10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0,
    100000000000000000.0 };
    long long svalue = llrint(dvalue * powers_of_ten[fractional_digits]);
    unsigned long long value;
    /* write sign */
    int negative = 0;
    if (svalue < 0) {
        if (...",676.0,765.0,1.0,1.0,90.0,77,19,75,15,1,1,17,16,0,1,,0,1,8,4,4,int
5055,470339,trimDoubleString,1,trimDoubleString,"int trimDoubleString (char*,size_t)",util.c,"int trimDoubleString(char *buf, size_t len) {
    if (strchr(buf,'.') != NULL) {
        char *p = buf+len-1;
        while(*p == '0') {
            p--;
            len--;
        }
        if (*p == '.') len--;
    }
    buf[len] = '\0';
    return len;
}",768.0,779.0,1.0,1.0,12.0,13,8,13,4,2,0,4,6,0,0,,0,0,4,2,2,int
5056,470385,ld2string,1,ld2string,"int ld2string (char*,size_t,long double,ld2string_mode)",util.c,"int ld2string(char *buf, size_t len, long double value, ld2string_mode mode) {
    size_t l = 0;

    if (isinf(value)) {
        /* Libc in odd systems (Hi Solaris!) will format infinite in a
         * different way, so better to handle it in an explicit way. */
        if (len < 5) goto err; /* No room. 5 is ""-inf\0"" */
        if (value > 0) {
            memcpy(buf,""inf"",3);
            l = 3;
        } else {
            memcpy(buf,""-inf"",4);
            l = 4;
        }
    } else if (isnan(value)) {
        /* Libc in some systems will format nan in a different way,
         * like nan, -nan, NAN, nan(char-sequence).
         * So we normalize it and create a single nan form in an explicit way. */
        if (len < 4) goto err; /* No room. 4 is ""nan\0"" */
        memcpy(buf, ""nan"", 3);
        l = 3;
    } else {
        switch (mode) {
        case LD_STR_AUTO:
            l = snprintf(buf,len,""%.17Lg"",value);
            if (l+1 > len) goto err;; /* No room. */
           ...",790.0,853.0,1.0,1.0,64.0,9,4,11,4,3,0,6,7,0,0,,0,0,8,4,4,int
5057,470828,getAbsolutePath,1,getAbsolutePath,sds getAbsolutePath (char*),util.c,"sds getAbsolutePath(char *filename) {
    char cwd[1024];
    sds abspath;
    sds relpath = sdsnew(filename);

    relpath = sdstrim(relpath,"" \r\n\t"");
    if (relpath[0] == '/') return relpath; /* Path is already absolute. */

    /* If path is relative, join cwd and relative path. */
    if (getcwd(cwd,sizeof(cwd)) == NULL) {
        sdsfree(relpath);
        return NULL;
    }
    abspath = sdsnew(cwd);
    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/')
        abspath = sdscat(abspath,""/"");

    /* At this point we have the current path always ending with ""/"", and
     * the trimmed relative path. Try to normalize the obvious case of
     * trailing ../ elements at the start of the path.
     *
     * For every ""../"" we find in the filename, we remove it and also remove
     * the last element of the cwd, unless the current cwd is ""/"". */
    while (sdslen(relpath) >= 3 &&
           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')
    {
        sdsrange...",943.0,986.0,1.0,1.0,44.0,35,14,38,7,0,14,7,10,4,14,,0,10,2,1,1,sds
5058,470962,getTimeZone,1,getTimeZone,long getTimeZone (void),util.c,"long getTimeZone(void) {
#if defined(__linux__) || defined(__sun)
    return timezone;
#else
    struct timeval tv;
    struct timezone tz;

    gettimeofday(&tv, &tz);

    return tz.tz_minuteswest * 60L;
#endif
}",992.0,1003.0,1.0,1.0,12.0,4,3,3,2,1,0,1,1,0,0,,0,0,2,1,1,long
5059,470980,pathIsBaseName,1,pathIsBaseName,int pathIsBaseName (char*),util.c,"int pathIsBaseName(char *path) {
    return strchr(path,'/') == NULL && strchr(path,'\\') == NULL;
}",1009.0,1011.0,1.0,1.0,3.0,3,2,4,2,3,0,1,1,0,0,,0,0,2,1,1,int
5060,470997,fileExist,1,fileExist,int fileExist (char*),util.c,"int fileExist(char *filename) {
    struct stat statbuf;
    return stat(filename, &statbuf) == 0 && S_ISREG(statbuf.st_mode);
}",1013.0,1016.0,1.0,1.0,4.0,4,4,3,2,2,0,1,1,0,0,,0,0,2,1,1,int
5061,471015,dirExists,1,dirExists,int dirExists (char*),util.c,"int dirExists(char *dname) {
    struct stat statbuf;
    return stat(dname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode);
}",1018.0,1021.0,1.0,1.0,4.0,4,4,3,2,2,0,1,1,0,0,,0,0,2,1,1,int
5062,471033,dirCreateIfMissing,1,dirCreateIfMissing,int dirCreateIfMissing (char*),util.c,"int dirCreateIfMissing(char *dname) {
    if (mkdir(dname, 0755) != 0) {
        if (errno != EEXIST) {
            return -1;
        } else if (!dirExists(dname)) {
            errno = ENOTDIR;
            return -1;
        }
    }
    return 0;
}",1023.0,1033.0,1.0,1.0,11.0,3,2,3,3,3,0,3,4,0,0,,0,0,2,1,1,int
5063,471203,makePath,1,makePath,"sds makePath (char*,char*)",util.c,"sds makePath(char *path, char *filename) {
    return sdscatfmt(sdsempty(), ""%s/%s"", path, filename);
}",1085.0,1087.0,1.0,1.0,3.0,0,0,2,2,15,2,1,1,0,2,,0,1,4,2,2,sds
5064,471215,fsyncFileDir,1,fsyncFileDir,int fsyncFileDir (char*),util.c,"int fsyncFileDir(const char *filename) {
#ifdef _AIX
    /* AIX is unable to fsync a directory */
    return 0;
#endif
    char temp_filename[PATH_MAX + 1];
    char *dname;
    int dir_fd;

    if (strlen(filename) > PATH_MAX) {
        errno = ENAMETOOLONG;
        return -1;
    }

    /* In the glibc implementation dirname may modify their argument. */
    memcpy(temp_filename, filename, strlen(filename) + 1);
    dname = dirname(temp_filename);

    dir_fd = open(dname, O_RDONLY);
    if (dir_fd == -1) {
        /* Some OSs don't allow us to open directories at all, just
         * ignore the error in that case */
        if (errno == EISDIR) {
            return 0;
        }
        return -1;
    }
    /* Some OSs don't allow us to fsync directories at all, so we can ignore
     * those errors. */
    if (redis_fsync(dir_fd) == -1 && !(errno == EBADF || errno == EINVAL)) {
        int save_errno = errno;
        close(dir_fd);
        errno = save_errno;
        return -1;
  ...",1097.0,1135.0,1.0,8.0,39.0,20,8,27,12,4,0,5,6,0,0,,0,0,2,1,1,int
5065,471302,reclaimFilePageCache,1,reclaimFilePageCache,"int reclaimFilePageCache (int,size_t,size_t)",util.c,"int reclaimFilePageCache(int fd, size_t offset, size_t length) {
#ifdef HAVE_FADVISE
    int ret = posix_fadvise(fd, offset, length, POSIX_FADV_DONTNEED);
    if (ret) return -1;
    return 0;
#else
    UNUSED(fd);
    UNUSED(offset);
    UNUSED(length);
    return 0;
#endif
}",1138.0,1149.0,1.0,4.0,12.0,3,1,6,3,2,0,1,1,0,0,,0,0,6,3,3,int
5066,471592,ziplistSafeToAdd,1,ziplistSafeToAdd,"int ziplistSafeToAdd (unsigned char*,size_t)",ziplist.c,"int ziplistSafeToAdd(unsigned char* zl, size_t add) {
    size_t len = zl? ziplistBlobLen(zl): 0;
    if (len + add > ZIPLIST_MAX_SAFETY_SIZE)
        return 0;
    return 1;
}",273.0,278.0,1.0,20.0,6.0,5,5,5,3,0,1,2,2,0,1,,0,1,4,2,2,int
5067,471630,zipEncodingLenSize,1,zipEncodingLenSize,unsigned int zipEncodingLenSize (unsigned char),ziplist.c,"static inline unsigned int zipEncodingLenSize(unsigned char encoding) {
    if (encoding == ZIP_INT_16B || encoding == ZIP_INT_32B ||
        encoding == ZIP_INT_24B || encoding == ZIP_INT_64B ||
        encoding == ZIP_INT_8B)
        return 1;
    if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
        return 1;
    if (encoding == ZIP_STR_06B)
        return 1;
    if (encoding == ZIP_STR_14B)
        return 2;
    if (encoding == ZIP_STR_32B)
        return 5;
    return ZIP_ENCODING_SIZE_INVALID;
}",321.0,335.0,1.0,20.0,15.0,26,7,10,1,1,0,6,6,0,0,,0,0,2,1,1,unsigned int
5068,471736,zipIntSize,1,zipIntSize,unsigned int zipIntSize (unsigned char),ziplist.c,"static inline unsigned int zipIntSize(unsigned char encoding) {
    switch(encoding) {
    case ZIP_INT_8B:  return 1;
    case ZIP_INT_16B: return 2;
    case ZIP_INT_24B: return 3;
    case ZIP_INT_32B: return 4;
    case ZIP_INT_64B: return 8;
    }
    if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
        return 0; /* 4 bit immediate */
    /* bad encoding, covered by a previous call to ZIP_ASSERT_ENCODING */
    redis_unreachable();
    return 0;
}",342.0,355.0,1.0,9.0,14.0,11,5,3,1,2,0,3,3,0,0,,0,0,2,1,1,unsigned int
5069,471810,zipStoreEntryEncoding,1,zipStoreEntryEncoding,"unsigned int zipStoreEntryEncoding (unsigned char*,unsigned char,unsigned int)",ziplist.c,"unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
    unsigned char len = 1, buf[5];

    if (ZIP_IS_STR(encoding)) {
        /* Although encoding is given it may not be set for strings,
         * so we determine it here using the raw length. */
        if (rawlen <= 0x3f) {
            if (!p) return len;
            buf[0] = ZIP_STR_06B | rawlen;
        } else if (rawlen <= 0x3fff) {
            len += 1;
            if (!p) return len;
            buf[0] = ZIP_STR_14B | ((rawlen >> 8) & 0x3f);
            buf[1] = rawlen & 0xff;
        } else {
            len += 4;
            if (!p) return len;
            buf[0] = ZIP_STR_32B;
            buf[1] = (rawlen >> 24) & 0xff;
            buf[2] = (rawlen >> 16) & 0xff;
            buf[3] = (rawlen >> 8) & 0xff;
            buf[4] = rawlen & 0xff;
        }
    } else {
        /* Implies integer encoding, so length is always 1. */
        if (!p) return len;
        buf[0] = enco...",369.0,401.0,1.0,8.0,33.0,9,8,12,5,4,0,4,7,0,0,,0,0,6,3,3,unsigned int
5070,471965,zipStorePrevEntryLengthLarge,1,zipStorePrevEntryLengthLarge,"int zipStorePrevEntryLengthLarge (unsigned char*,unsigned int)",ziplist.c,"int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
    uint32_t u32;
    if (p != NULL) {
        p[0] = ZIP_BIG_PREVLEN;
        u32 = len;
        memcpy(p+1,&u32,sizeof(u32));
        memrev32ifbe(p+1);
    }
    return 1 + sizeof(uint32_t);
}",444.0,453.0,1.0,15.0,10.0,10,6,10,5,1,1,2,2,0,1,,0,0,4,2,2,int
5071,472006,zipStorePrevEntryLength,1,zipStorePrevEntryLength,"unsigned int zipStorePrevEntryLength (unsigned char*,unsigned int)",ziplist.c,"unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
    if (p == NULL) {
        return (len < ZIP_BIG_PREVLEN) ? 1 : sizeof(uint32_t) + 1;
    } else {
        if (len < ZIP_BIG_PREVLEN) {
            p[0] = len;
            return 1;
        } else {
            return zipStorePrevEntryLengthLarge(p,len);
        }
    }
}",457.0,468.0,1.0,22.0,12.0,5,5,4,4,8,0,2,2,0,0,,0,0,4,2,2,unsigned int
5072,472051,zipPrevLenByteDiff,1,zipPrevLenByteDiff,"int zipPrevLenByteDiff (unsigned char*,unsigned int)",ziplist.c,"int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
    unsigned int prevlensize;
    ZIP_DECODE_PREVLENSIZE(p, prevlensize);
    return zipStorePrevEntryLength(NULL, len) - prevlensize;
}",514.0,518.0,1.0,4.0,5.0,5,4,8,4,2,1,1,1,0,1,,0,0,4,2,2,int
5073,472086,zipTryEncoding,1,zipTryEncoding,"int zipTryEncoding (unsigned char*,unsigned int,long long*,unsigned char*)",ziplist.c,"int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {
    long long value;

    if (entrylen >= 32 || entrylen == 0) return 0;
    if (string2ll((char*)entry,entrylen,&value)) {
        /* Great, the string can be encoded. Check what's the smallest
         * of our encoding types that can hold this value. */
        if (value >= 0 && value <= 12) {
            *encoding = ZIP_INT_IMM_MIN+value;
        } else if (value >= INT8_MIN && value <= INT8_MAX) {
            *encoding = ZIP_INT_8B;
        } else if (value >= INT16_MIN && value <= INT16_MAX) {
            *encoding = ZIP_INT_16B;
        } else if (value >= INT24_MIN && value <= INT24_MAX) {
            *encoding = ZIP_INT_24B;
        } else if (value >= INT32_MIN && value <= INT32_MAX) {
            *encoding = ZIP_INT_32B;
        } else {
            *encoding = ZIP_INT_64B;
        }
        *v = value;
        return 1;
    }
    return 0;
}",522.0,546.0,1.0,24.0,25.0,13,10,11,5,2,1,4,5,1,1,,0,1,8,4,4,int
5074,472616,zipEntry,1,zipEntry,"void zipEntry (unsigned char*,zlentry*)",ziplist.c,"static inline void zipEntry(unsigned char *p, zlentry *e) {
    ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
    ZIP_ENTRY_ENCODING(p + e->prevrawlensize, e->encoding);
    ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
    assert(e->lensize != 0); /* check that encoding was valid. */
    e->headersize = e->prevrawlensize + e->lensize;
    e->p = p;
}",616.0,623.0,1.0,4.0,8.0,149,17,71,2,7,56,1,1,0,1,,0,55,4,2,2,void
5075,473044,zipEntrySafe,1,zipEntrySafe,"int zipEntrySafe (unsigned char*,size_t,unsigned char*,zlentry*,int)",ziplist.c,"static inline int zipEntrySafe(unsigned char* zl, size_t zlbytes, unsigned char *p, zlentry *e, int validate_prevlen) {
    unsigned char *zlfirst = zl + ZIPLIST_HEADER_SIZE;
    unsigned char *zllast = zl + zlbytes - ZIPLIST_END_SIZE;
#define OUT_OF_RANGE(p) (unlikely((p) < zlfirst || (p) > zllast))

    /* If there's no possibility for the header to reach outside the ziplist,
     * take the fast path. (max lensize and prevrawlensize are both 5 bytes) */
    if (p >= zlfirst && p + 10 < zllast) {
        ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
        ZIP_ENTRY_ENCODING(p + e->prevrawlensize, e->encoding);
        ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
        e->headersize = e->prevrawlensize + e->lensize;
        e->p = p;
        /* We didn't call ZIP_ASSERT_ENCODING, so we check lensize was set to 0. */
        if (unlikely(e->lensize == 0))
            return 0;
        /* Make sure the entry doesn't reach outside the edge ...",629.0,689.0,1.0,34.0,61.0,373,17,210,10,8,134,11,14,20,1,,0,134,10,5,5,int
5076,474127,zipRawEntryLengthSafe,1,zipRawEntryLengthSafe,"unsigned int zipRawEntryLengthSafe (unsigned char*,size_t,unsigned char*)",ziplist.c,"static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &e, 0));
    return e.headersize + e.len;
}",692.0,696.0,1.0,4.0,5.0,8,7,6,4,1,4,1,1,0,2,,0,2,6,3,3,unsigned int
5077,474163,zipRawEntryLength,1,zipRawEntryLength,unsigned int zipRawEntryLength (unsigned char*),ziplist.c,"static inline unsigned int zipRawEntryLength(unsigned char *p) {
    zlentry e;
    zipEntry(p, &e);
    return e.headersize + e.len;
}",699.0,703.0,1.0,1.0,5.0,4,3,4,2,1,3,1,1,0,1,,0,2,2,1,1,unsigned int
5078,474181,zipAssertValidEntry,1,zipAssertValidEntry,"void zipAssertValidEntry (unsigned char*,size_t,unsigned char*)",ziplist.c,"static inline void zipAssertValidEntry(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &e, 1));
}",706.0,709.0,1.0,4.0,4.0,5,5,4,4,2,2,1,1,0,2,,0,0,6,3,3,void
5079,474209,ziplistNew,1,ziplistNew,unsigned char* ziplistNew (void),ziplist.c,"unsigned char *ziplistNew(void) {
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
    unsigned char *zl = zmalloc(bytes);
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
    ZIPLIST_LENGTH(zl) = 0;
    zl[bytes-1] = ZIP_END;
    return zl;
}",712.0,720.0,1.0,25.0,9.0,29,8,21,5,0,3,1,1,0,3,,0,3,2,1,1,unsigned char*
5080,474295,ziplistResize,1,ziplistResize,"unsigned char* ziplistResize (unsigned char*,size_t)",ziplist.c,"unsigned char *ziplistResize(unsigned char *zl, size_t len) {
    assert(len < UINT32_MAX);
    zl = zrealloc(zl,len);
    ZIPLIST_BYTES(zl) = intrev32ifbe(len);
    zl[len-1] = ZIP_END;
    return zl;
}",723.0,729.0,1.0,4.0,7.0,12,9,12,3,3,3,1,1,0,3,,0,2,4,2,2,unsigned char*
5081,474346,__ziplistCascadeUpdate,1,__ziplistCascadeUpdate,"unsigned char* __ziplistCascadeUpdate (unsigned char*,unsigned char*)",ziplist.c,"unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    zlentry cur;
    size_t prevlen, prevlensize, prevoffset; /* Informat of the last changed entry. */
    size_t firstentrylen; /* Used to handle insert at head. */
    size_t rawlen, curlen = intrev32ifbe(ZIPLIST_BYTES(zl));
    size_t extra = 0, cnt = 0, offset;
    size_t delta = 4; /* Extra bytes needed to update a entry's prevlen (5-1). */
    unsigned char *tail = zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl));

    /* Empty ziplist */
    if (p[0] == ZIP_END) return zl;

    zipEntry(p, &cur); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    firstentrylen = prevlen = cur.headersize + cur.len;
    prevlensize = zipStorePrevEntryLength(NULL, prevlen);
    prevoffset = p - zl;
    p += prevlen;

    /* Iterate ziplist to find out how many extra bytes do we need to update it. */
    while (p[0] != ZIP_END) {
        assert(zipEntrySafe(zl, curlen,...",751.0,847.0,1.0,28.0,97.0,106,20,115,16,3,30,13,17,4,14,,0,23,4,2,2,unsigned char*
5082,474727,__ziplistDelete,1,__ziplistDelete,"unsigned char* __ziplistDelete (unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
    unsigned int i, totlen, deleted = 0;
    size_t offset;
    int nextdiff = 0;
    zlentry first, tail;
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));

    zipEntry(p, &first); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    for (i = 0; p[0] != ZIP_END && i < num; i++) {
        p += zipRawEntryLengthSafe(zl, zlbytes, p);
        deleted++;
    }

    assert(p >= first.p);
    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */
    if (totlen > 0) {
        uint32_t set_tail;
        if (p[0] != ZIP_END) {
            /* Storing `prevrawlen` in this entry may increase or decrease the
             * number of bytes required compare to the current `prevrawlen`.
             * There always is room to store this, because it was previously
             * stored by an entry that is now being deleted. */
            ne...",850.0,923.0,1.0,21.0,74.0,104,23,90,16,2,26,6,10,2,17,,0,17,6,3,3,unsigned char*
5083,475064,__ziplistInsert,1,__ziplistInsert,"unsigned char* __ziplistInsert (unsigned char*,unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, newlen;
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    int nextdiff = 0;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */
    zlentry tail;

    /* Find out prevlen for the entry that is inserted. */
    if (p[0] != ZIP_END) {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } else {
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        if (ptail[0] != ZIP_END) {
            prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);
        }
    }

    /* See if the entry can be encoded */
    if (zipTryEncoding(s,slen,&value,&encoding)) {
        /* 'encoding' is set to the appropriate int...",926.0,1023.0,1.0,20.0,98.0,120,22,121,18,2,22,9,11,3,20,,0,14,8,4,4,unsigned char*
5084,475531,ziplistMerge,1,ziplistMerge,"unsigned char* ziplistMerge (unsigned char**,unsigned char**)",ziplist.c,"unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
    /* If any params are null, we can't merge, so NULL. */
    if (first == NULL || *first == NULL || second == NULL || *second == NULL)
        return NULL;

    /* Can't merge same list into itself. */
    if (*first == *second)
        return NULL;

    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));

    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));

    int append;
    unsigned char *source, *target;
    size_t target_bytes, source_bytes;
    /* Pick the largest ziplist so we can resize easily in-place.
     * We must also track if we are now appending or prepending to
     * the target ziplist. */
    if (first_len >= second_len) {
        /* retain first, append second to first. */
        target = *first;
        target_bytes = first_bytes;
        sourc...",1040.0,1141.0,1.0,25.0,102.0,116,14,96,21,0,13,6,6,0,13,,0,11,4,2,2,unsigned char*
5085,475922,ziplistPush,1,ziplistPush,"unsigned char* ziplistPush (unsigned char*,unsigned char*,unsigned int,int)",ziplist.c,"unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
    unsigned char *p;
    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
    return __ziplistInsert(zl,p,s,slen);
}",1143.0,1147.0,1.0,18.0,5.0,13,9,14,8,0,2,1,1,0,2,,0,1,8,4,4,unsigned char*
5086,475970,ziplistIndex,1,ziplistIndex,"unsigned char* ziplistIndex (unsigned char*,int)",ziplist.c,"unsigned char *ziplistIndex(unsigned char *zl, int index) {
    unsigned char *p;
    unsigned int prevlensize, prevlen = 0;
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
    if (index < 0) {
        index = (-index)-1;
        p = ZIPLIST_ENTRY_TAIL(zl);
        if (p[0] != ZIP_END) {
            /* No need for ""safe"" check: when going backwards, we know the header
             * we're parsing is in the range, we just need to assert (below) that
             * the size we take doesn't cause p to go outside the allocation. */
            ZIP_DECODE_PREVLENSIZE(p, prevlensize);
            assert(p + prevlensize < zl + zlbytes - ZIPLIST_END_SIZE);
            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            while (prevlen > 0 && index--) {
                p -= prevlen;
                assert(p >= zl + ZIPLIST_HEADER_SIZE && p < zl + zlbytes - ZIPLIST_END_SIZE);
                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            }
        }
    } else {
        p ...",1152.0,1186.0,1.0,21.0,35.0,88,23,69,10,4,5,5,8,0,5,,0,2,4,2,2,unsigned char*
5087,476295,ziplistNext,1,ziplistNext,"unsigned char* ziplistNext (unsigned char*,unsigned char*)",ziplist.c,"unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {
    ((void) zl);
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));

    /* ""p"" could be equal to ZIP_END, caused by ziplistDelete,
     * and we should return NULL. Otherwise, we should return NULL
     * when the *next* element is ZIP_END (there is no next entry). */
    if (p[0] == ZIP_END) {
        return NULL;
    }

    p += zipRawEntryLength(p);
    if (p[0] == ZIP_END) {
        return NULL;
    }

    zipAssertValidEntry(zl, zlbytes, p);
    return p;
}",1194.0,1212.0,1.0,21.0,19.0,9,6,13,4,5,3,3,3,0,3,,0,1,4,2,2,unsigned char*
5088,476346,ziplistPrev,1,ziplistPrev,"unsigned char* ziplistPrev (unsigned char*,unsigned char*)",ziplist.c,"unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {
    unsigned int prevlensize, prevlen = 0;

    /* Iterating backwards from ZIP_END should return the tail. When ""p"" is
     * equal to the first element of the list, we're already at the head,
     * and should return NULL. */
    if (p[0] == ZIP_END) {
        p = ZIPLIST_ENTRY_TAIL(zl);
        return (p[0] == ZIP_END) ? NULL : p;
    } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
        return NULL;
    } else {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
        assert(prevlen > 0);
        p-=prevlen;
        size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
        zipAssertValidEntry(zl, zlbytes, p);
        return p;
    }
}",1215.0,1234.0,1.0,16.0,20.0,12,8,10,5,0,1,2,2,0,1,,0,1,4,2,2,unsigned char*
5089,476510,ziplistGet,1,ziplistGet,"unsigned int ziplistGet (unsigned char*,unsigned char**,unsigned int*,long long*)",ziplist.c,"unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {
    zlentry entry;
    if (p == NULL || p[0] == ZIP_END) return 0;
    if (sstr) *sstr = NULL;

    zipEntry(p, &entry); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    if (ZIP_IS_STR(entry.encoding)) {
        if (sstr) {
            *slen = entry.len;
            *sstr = p+entry.headersize;
        }
    } else {
        if (sval) {
            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
        }
    }
    return 1;
}",1240.0,1257.0,1.0,29.0,18.0,18,10,16,5,9,5,5,6,2,1,,0,4,8,4,4,unsigned int
5090,476595,ziplistInsert,1,ziplistInsert,"unsigned char* ziplistInsert (unsigned char*,unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    return __ziplistInsert(zl,p,s,slen);
}",1260.0,1262.0,1.0,1.0,3.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,unsigned char*
5091,476609,ziplistDelete,1,ziplistDelete,"unsigned char* ziplistDelete (unsigned char*,unsigned char**)",ziplist.c,"unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
    size_t offset = *p-zl;
    zl = __ziplistDelete(zl,*p,1);

    /* Store pointer to current element in p, because ziplistDelete will
     * do a realloc which might result in a different ""zl""-pointer.
     * When the delete direction is back to front, we might delete the last
     * entry and end up with ""p"" pointing to ZIP_END, so check this. */
    *p = zl+offset;
    return zl;
}",1267.0,1277.0,1.0,1.0,11.0,8,4,10,3,0,1,1,1,0,1,,0,1,4,2,2,unsigned char*
5092,476637,ziplistDeleteRange,1,ziplistDeleteRange,"unsigned char* ziplistDeleteRange (unsigned char*,int,unsigned int)",ziplist.c,"unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
    unsigned char *p = ziplistIndex(zl,index);
    return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
}",1280.0,1283.0,1.0,1.0,4.0,3,3,9,5,0,2,1,1,0,2,,0,1,6,3,3,unsigned char*
5093,476660,ziplistReplace,1,ziplistReplace,"unsigned char* ziplistReplace (unsigned char*,unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *ziplistReplace(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {

    /* get metadata of the current entry */
    zlentry entry;
    zipEntry(p, &entry);

    /* compute length of entry to store, excluding prevlen */
    unsigned int reqlen;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. */
    if (zipTryEncoding(s,slen,&value,&encoding)) {
        reqlen = zipIntSize(encoding); /* encoding is set */
    } else {
        reqlen = slen; /* encoding == 0 */
    }
    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

    if (reqlen == entry.lensize + entry.len) {
        /* Simply overwrite the element. */
        p += entry.prevrawlensize;
        p += zipStoreEntryEncoding(p,encoding,slen);
        if (ZIP_IS_STR(encoding)) {
            memcpy(p,s,slen);
        } else {
            zipSaveInteger(p,value,encoding);
        }
    } else {
        /* Fallback. */
        zl = ziplistDelete...",1287.0,1319.0,1.0,12.0,33.0,16,8,29,9,0,8,4,5,3,5,,0,5,8,4,4,unsigned char*
5094,476765,ziplistCompare,1,ziplistCompare,"unsigned int ziplistCompare (unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
    zlentry entry;
    unsigned char sencoding;
    long long zval, sval;
    if (p[0] == ZIP_END) return 0;

    zipEntry(p, &entry); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    if (ZIP_IS_STR(entry.encoding)) {
        /* Raw compare */
        if (entry.len == slen) {
            return memcmp(p+entry.headersize,sstr,slen) == 0;
        } else {
            return 0;
        }
    } else {
        /* Try to compare encoded values. Don't compare encoding because
         * different implementations may encoded integers differently. */
        if (zipTryEncoding(sstr,slen,&sval,&sencoding)) {
          zval = zipLoadInteger(p+entry.headersize,entry.encoding);
          return zval == sval;
        }
    }
    return 0;
}",1323.0,1346.0,1.0,16.0,24.0,12,7,11,4,0,5,4,5,3,1,,0,4,6,3,3,unsigned int
5095,476855,ziplistFind,1,ziplistFind,"unsigned char* ziplistFind (unsigned char*,unsigned char*,unsigned char*,unsigned int,unsigned int)",ziplist.c,"unsigned char *ziplistFind(unsigned char *zl, unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {
    int skipcnt = 0;
    unsigned char vencoding = 0;
    long long vll = 0;
    size_t zlbytes = ziplistBlobLen(zl);

    while (p[0] != ZIP_END) {
        struct zlentry e;
        unsigned char *q;

        assert(zipEntrySafe(zl, zlbytes, p, &e, 1));
        q = p + e.prevrawlensize + e.lensize;

        if (skipcnt == 0) {
            /* Compare current entry with specified entry */
            if (ZIP_IS_STR(e.encoding)) {
                if (e.len == vlen && memcmp(q, vstr, vlen) == 0) {
                    return p;
                }
            } else {
                /* Find out if the searched field can be encoded. Note that
                 * we do it only the first time, once done vencoding is set
                 * to non-zero and vll is set to the integer value. */
                if (vencoding == 0) {
                    if (!zipTryEncoding(vs...",1350.0,1407.0,1.0,19.0,58.0,29,14,29,12,0,9,5,11,3,3,,0,7,10,5,5,unsigned char*
5096,477029,ziplistLen,1,ziplistLen,unsigned int ziplistLen (unsigned char*),ziplist.c,"unsigned int ziplistLen(unsigned char *zl) {
    unsigned int len = 0;
    if (intrev16ifbe(ZIPLIST_LENGTH(zl)) < UINT16_MAX) {
        len = intrev16ifbe(ZIPLIST_LENGTH(zl));
    } else {
        unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
        size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
        while (*p != ZIP_END) {
            p += zipRawEntryLengthSafe(zl, zlbytes, p);
            len++;
        }

        /* Re-store length if small enough */
        if (len < UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
    }
    return len;
}",1410.0,1426.0,1.0,8.0,17.0,13,7,8,4,2,2,2,2,1,2,,0,2,2,1,1,unsigned int
5097,477135,ziplistBlobLen,1,ziplistBlobLen,size_t ziplistBlobLen (unsigned char*),ziplist.c,"size_t ziplistBlobLen(unsigned char *zl) {
    return intrev32ifbe(ZIPLIST_BYTES(zl));
}",1429.0,1431.0,1.0,11.0,3.0,2,2,1,1,3,1,1,1,0,1,,0,0,2,1,1,size_t
5098,477148,ziplistRepr,1,ziplistRepr,void ziplistRepr (unsigned char*),ziplist.c,"void ziplistRepr(unsigned char *zl) {
    unsigned char *p;
    int index = 0;
    zlentry entry;
    size_t zlbytes = ziplistBlobLen(zl);

    printf(
        ""{total bytes %u} ""
        ""{num entries %u}\n""
        ""{tail offset %u}\n"",
        intrev32ifbe(ZIPLIST_BYTES(zl)),
        intrev16ifbe(ZIPLIST_LENGTH(zl)),
        intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
    p = ZIPLIST_ENTRY_HEAD(zl);
    while(*p != ZIP_END) {
        assert(zipEntrySafe(zl, zlbytes, p, &entry, 1));
        printf(
            ""{\n""
                ""\taddr 0x%08lx,\n""
                ""\tindex %2d,\n""
                ""\toffset %5lu,\n""
                ""\thdr+entry len: %5u,\n""
                ""\thdr len%2u,\n""
                ""\tprevrawlen: %5u,\n""
                ""\tprevrawlensize: %2u,\n""
                ""\tpayload %5u\n"",
            (long unsigned)p,
            index,
            (unsigned long) (p-zl),
            entry.headersize+entry.len,
            entry.headersize,
            entry.prevraw...",1433.0,1490.0,1.0,8.0,58.0,54,20,44,9,0,19,6,13,5,6,,0,14,2,1,1,void
5099,477376,ziplistValidateIntegrity,1,ziplistValidateIntegrity,"int ziplistValidateIntegrity (unsigned char*,size_t,int,ziplistValidateEntryCB,void*)",ziplist.c,"int ziplistValidateIntegrity(unsigned char *zl, size_t size, int deep,
    ziplistValidateEntryCB entry_cb, void *cb_userdata) {
    /* check that we can actually read the header. (and ZIP_END) */
    if (size < ZIPLIST_HEADER_SIZE + ZIPLIST_END_SIZE)
        return 0;

    /* check that the encoded size in the header must match the allocated size. */
    size_t bytes = intrev32ifbe(ZIPLIST_BYTES(zl));
    if (bytes != size)
        return 0;

    /* the last byte must be the terminator. */
    if (zl[size - ZIPLIST_END_SIZE] != ZIP_END)
        return 0;

    /* make sure the tail offset isn't reaching outside the allocation. */
    if (intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) > size - ZIPLIST_END_SIZE)
        return 0;

    if (!deep)
        return 1;

    unsigned int count = 0;
    unsigned int header_count = intrev16ifbe(ZIPLIST_LENGTH(zl));
    unsigned char *p = ZIPLIST_ENTRY_HEAD(zl);
    unsigned char *prev = NULL;
    size_t prev_raw_size = 0;
    while(*p != ZIP_END) {
   ...",1495.0,1556.0,1.0,15.0,62.0,71,17,63,17,1,10,13,16,4,5,,0,10,10,5,5,int
5100,477621,ziplistRandomPair,1,ziplistRandomPair,"void ziplistRandomPair (unsigned char*,long unsigned,ziplistEntry*,ziplistEntry*)",ziplist.c,"void ziplistRandomPair(unsigned char *zl, unsigned long total_count, ziplistEntry *key, ziplistEntry *val) {
    int ret;
    unsigned char *p;

    /* Avoid div by zero on corrupt ziplist */
    assert(total_count);

    /* Generate even numbers, because ziplist saved K-V pair */
    int r = (rand() % total_count) * 2;
    p = ziplistIndex(zl, r);
    ret = ziplistGet(p, &key->sval, &key->slen, &key->lval);
    assert(ret != 0);

    if (!val)
        return;
    p = ziplistNext(zl, p);
    ret = ziplistGet(p, &val->sval, &val->slen, &val->lval);
    assert(ret != 0);
}",1562.0,1580.0,1.0,4.0,19.0,34,11,23,7,0,13,2,2,0,7,,0,10,8,4,4,void
5101,477749,ziplistSaveValue,1,ziplistSaveValue,"void ziplistSaveValue (unsigned char*,unsigned int,long long,ziplistEntry*)",ziplist.c,"static inline void ziplistSaveValue(unsigned char *val, unsigned int len, long long lval, ziplistEntry *dest) {
    dest->sval = val;
    dest->slen = len;
    dest->lval = lval;
}",1588.0,1592.0,1.0,1.0,5.0,6,2,6,4,4,3,1,1,0,0,,0,3,8,4,4,void
5102,477772,ziplistRandomPairs,1,ziplistRandomPairs,"void ziplistRandomPairs (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)",ziplist.c,"void ziplistRandomPairs(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {
    unsigned char *p, *key, *value;
    unsigned int klen = 0, vlen = 0;
    long long klval = 0, vlval = 0;

    /* Notice: the index member must be first due to the use in uintCompare */
    typedef struct {
        unsigned int index;
        unsigned int order;
    } rand_pick;
    rand_pick *picks = zmalloc(sizeof(rand_pick)*count);
    unsigned int total_size = ziplistLen(zl)/2;

    /* Avoid div by zero on corrupt ziplist */
    assert(total_size);

    /* create a pool of random indexes (some may be duplicate). */
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = (rand() % total_size) * 2; /* Generate even indexes */
        /* keep track of the order we picked them */
        picks[i].order = i;
    }

    /* sort by indexes. */
    qsort(picks, count, sizeof(rand_pick), uintCompare);

    /* fetch the elements form the ziplist into a output array r...",1598.0,1642.0,1.0,4.0,45.0,57,17,67,18,0,12,5,8,1,12,,0,6,8,4,4,void
5103,477975,ziplistRandomPairsUnique,1,ziplistRandomPairsUnique,"unsigned int ziplistRandomPairsUnique (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)",ziplist.c,"unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {
    unsigned char *p, *key;
    unsigned int klen = 0;
    long long klval = 0;
    unsigned int total_size = ziplistLen(zl)/2;
    unsigned int index = 0;
    if (count > total_size)
        count = total_size;

    /* To only iterate once, every time we try to pick a member, the probability
     * we pick it is the quotient of the count left we want to pick and the
     * count still we haven't visited in the dict, this way, we could make every
     * member be equally picked.*/
    p = ziplistIndex(zl, 0);
    unsigned int picked = 0, remaining = count;
    while (picked < count && p) {
        double randomDouble = ((double)rand()) / RAND_MAX;
        double threshold = ((double)remaining) / (total_size - index);
        if (randomDouble <= threshold) {
            assert(ziplistGet(p, &key, &klen, &klval));
            ziplistSaveValue(key, klen, klval, &keys[p...",1650.0,1687.0,1.0,12.0,38.0,47,15,56,15,0,11,5,8,0,11,,0,4,8,4,4,unsigned int
5104,478345,zipmapNew,1,zipmapNew,unsigned char* zipmapNew (void),zipmap.c,"unsigned char *zipmapNew(void) {
    unsigned char *zm = zmalloc(2);

    zm[0] = 0; /* Length */
    zm[1] = ZIPMAP_END;
    return zm;
}",96.0,102.0,1.0,12.0,7.0,5,2,4,1,0,1,1,1,0,1,,0,1,2,1,1,unsigned char*
5105,478369,zipmapDecodeLength,1,zipmapDecodeLength,unsigned int zipmapDecodeLength (unsigned char*),zipmap.c,"static unsigned int zipmapDecodeLength(unsigned char *p) {
    unsigned int len = *p;

    if (len < ZIPMAP_BIGLEN) return len;
    memcpy(&len,p+1,sizeof(unsigned int));
    memrev32ifbe(&len);
    return len;
}",105.0,112.0,1.0,14.0,8.0,8,6,10,3,9,1,2,2,0,1,,0,0,2,1,1,unsigned int
5106,478405,zipmapGetEncodedLengthSize,1,zipmapGetEncodedLengthSize,unsigned int zipmapGetEncodedLengthSize (unsigned char*),zipmap.c,"static unsigned int zipmapGetEncodedLengthSize(unsigned char *p) {
    return (*p < ZIPMAP_BIGLEN) ? 1: 5;
}",114.0,116.0,1.0,17.0,3.0,3,3,1,1,2,0,1,1,0,0,,0,0,2,1,1,unsigned int
5107,478420,zipmapEncodeLength,1,zipmapEncodeLength,"unsigned int zipmapEncodeLength (unsigned char*,unsigned int)",zipmap.c,"static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {
    if (p == NULL) {
        return ZIPMAP_LEN_BYTES(len);
    } else {
        if (len < ZIPMAP_BIGLEN) {
            p[0] = len;
            return 1;
        } else {
            p[0] = ZIPMAP_BIGLEN;
            memcpy(p+1,&len,sizeof(len));
            memrev32ifbe(p+1);
            return 1+sizeof(len);
        }
    }
}",120.0,134.0,1.0,15.0,15.0,5,5,5,4,6,0,2,2,0,0,,0,0,4,2,2,unsigned int
5108,478488,zipmapLookupRaw,1,zipmapLookupRaw,"unsigned char* zipmapLookupRaw (unsigned char*,unsigned char*,unsigned int,unsigned int*)",zipmap.c,"static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {
    unsigned char *p = zm+1, *k = NULL;
    unsigned int l,llen;

    while(*p != ZIPMAP_END) {
        unsigned char free;

        /* Match or skip the key */
        l = zipmapDecodeLength(p);
        llen = zipmapEncodeLength(NULL,l);
        if (key != NULL && k == NULL && l == klen && !memcmp(p+llen,key,l)) {
            /* Only return when the user doesn't care
             * for the total length of the zipmap. */
            if (totlen != NULL) {
                k = p;
            } else {
                return p;
            }
        }
        p += llen+l;
        /* Skip the value as well */
        l = zipmapDecodeLength(p);
        p += zipmapEncodeLength(NULL,l);
        free = p[0];
        p += l+1+free; /* +1 to skip the free byte */
    }
    if (totlen != NULL) *totlen = (unsigned int)(p-zm)+1;
    return k;
}",142.0,170.0,1.0,16.0,29.0,32,11,43,10,5,4,5,8,0,4,,0,3,8,4,4,unsigned char*
5109,478602,zipmapRequiredLength,1,zipmapRequiredLength,"unsigned long zipmapRequiredLength (unsigned int,unsigned int)",zipmap.c,"static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {
    unsigned int l;

    l = klen+vlen+3;
    if (klen >= ZIPMAP_BIGLEN) l += 4;
    if (vlen >= ZIPMAP_BIGLEN) l += 4;
    return l;
}",172.0,179.0,1.0,16.0,8.0,7,4,8,3,1,0,3,3,0,0,,0,0,4,2,2,unsigned long
5110,478638,zipmapRawKeyLength,1,zipmapRawKeyLength,unsigned int zipmapRawKeyLength (unsigned char*),zipmap.c,"static unsigned int zipmapRawKeyLength(unsigned char *p) {
    unsigned int l = zipmapDecodeLength(p);
    return zipmapEncodeLength(NULL,l) + l;
}",182.0,185.0,1.0,1.0,4.0,2,2,5,3,3,2,1,1,0,2,,0,1,2,1,1,unsigned int
5111,478654,zipmapRawValueLength,1,zipmapRawValueLength,unsigned int zipmapRawValueLength (unsigned char*),zipmap.c,"static unsigned int zipmapRawValueLength(unsigned char *p) {
    unsigned int l = zipmapDecodeLength(p);
    unsigned int used;

    used = zipmapEncodeLength(NULL,l);
    used += p[used] + 1 + l;
    return used;
}",189.0,196.0,1.0,1.0,8.0,6,4,10,4,2,2,1,1,0,2,,0,2,2,1,1,unsigned int
5112,478681,zipmapRawEntryLength,1,zipmapRawEntryLength,unsigned int zipmapRawEntryLength (unsigned char*),zipmap.c,"static unsigned int zipmapRawEntryLength(unsigned char *p) {
    unsigned int l = zipmapRawKeyLength(p);
    return l + zipmapRawValueLength(p+l);
}",201.0,204.0,1.0,1.0,4.0,3,2,5,2,1,2,1,1,0,2,,0,1,2,1,1,unsigned int
5113,478698,zipmapResize,1,zipmapResize,"unsigned char* zipmapResize (unsigned char*,unsigned int)",zipmap.c,"static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {
    zm = zrealloc(zm, len);
    zm[len-1] = ZIPMAP_END;
    return zm;
}",206.0,210.0,1.0,16.0,5.0,4,3,6,2,3,1,1,1,0,1,,0,1,4,2,2,unsigned char*
5114,478720,zipmapSet,1,zipmapSet,"unsigned char* zipmapSet (unsigned char*,unsigned char*,unsigned int,unsigned char*,unsigned int,int*)",zipmap.c,"unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {
    unsigned int zmlen, offset;
    unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen);
    unsigned int empty, vempty;
    unsigned char *p;

    freelen = reqlen;
    if (update) *update = 0;
    p = zipmapLookupRaw(zm,key,klen,&zmlen);
    if (p == NULL) {
        /* Key not found: enlarge */
        zm = zipmapResize(zm, zmlen+reqlen);
        p = zm+zmlen-1;
        zmlen = zmlen+reqlen;

        /* Increase zipmap length (this is an insert) */
        if (zm[0] < ZIPMAP_BIGLEN) zm[0]++;
    } else {
        /* Key found. Is there enough space for the new value? */
        /* Compute the total length: */
        if (update) *update = 1;
        freelen = zipmapRawEntryLength(p);
        if (freelen < reqlen) {
            /* Store the offset of this key within the current zipmap, so
             * it can be resized. Then, move the ...",215.0,281.0,1.0,20.0,67.0,39,12,66,14,0,6,5,6,0,6,,0,4,12,6,6,unsigned char*
5115,478938,zipmapDel,1,zipmapDel,"unsigned char* zipmapDel (unsigned char*,unsigned char*,unsigned int,int*)",zipmap.c,"unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {
    unsigned int zmlen, freelen;
    unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen);
    if (p) {
        freelen = zipmapRawEntryLength(p);
        memmove(p, p+freelen, zmlen-((p-zm)+freelen+1));
        zm = zipmapResize(zm, zmlen-freelen);

        /* Decrease zipmap length */
        if (zm[0] < ZIPMAP_BIGLEN) zm[0]--;

        if (deleted) *deleted = 1;
    } else {
        if (deleted) *deleted = 0;
    }
    return zm;
}",285.0,301.0,1.0,20.0,17.0,16,8,24,7,0,3,4,6,0,3,,0,3,8,4,4,unsigned char*
5116,479025,zipmapNext,1,zipmapNext,"unsigned char* zipmapNext (unsigned char*,unsigned char**,unsigned int*,unsigned char**,unsigned int*)",zipmap.c,"unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {
    if (zm[0] == ZIPMAP_END) return NULL;
    if (key) {
        *key = zm;
        *klen = zipmapDecodeLength(zm);
        *key += ZIPMAP_LEN_BYTES(*klen);
    }
    zm += zipmapRawKeyLength(zm);
    if (value) {
        *value = zm+1;
        *vlen = zipmapDecodeLength(zm);
        *value += ZIPMAP_LEN_BYTES(*vlen);
    }
    zm += zipmapRawValueLength(zm);
    return zm;
}",319.0,334.0,1.0,17.0,16.0,29,9,25,7,0,4,4,4,0,4,,0,2,10,5,5,unsigned char*
5117,479115,zipmapGet,1,zipmapGet,"int zipmapGet (unsigned char*,unsigned char*,unsigned int,unsigned char**,unsigned int*)",zipmap.c,"int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {
    unsigned char *p;

    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) return 0;
    p += zipmapRawKeyLength(p);
    *vlen = zipmapDecodeLength(p);
    *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1;
    return 1;
}",338.0,346.0,1.0,17.0,9.0,15,8,15,8,0,3,2,2,1,3,,0,2,10,5,5,int
5118,479170,zipmapExists,1,zipmapExists,"int zipmapExists (unsigned char*,unsigned char*,unsigned int)",zipmap.c,"int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {
    return zipmapLookupRaw(zm,key,klen,NULL) != NULL;
}",349.0,351.0,1.0,1.0,3.0,1,1,5,4,0,1,1,1,0,1,,0,0,6,3,3,int
5119,479242,zipmapBlobLen,1,zipmapBlobLen,size_t zipmapBlobLen (unsigned char*),zipmap.c,"size_t zipmapBlobLen(unsigned char *zm) {
    unsigned int totlen;
    zipmapLookupRaw(zm,NULL,0,&totlen);
    return totlen;
}",371.0,375.0,1.0,1.0,5.0,1,1,4,3,0,1,1,1,0,1,,0,0,2,1,1,size_t
5120,479256,zipmapValidateIntegrity,1,zipmapValidateIntegrity,"int zipmapValidateIntegrity (unsigned char*,size_t,int)",zipmap.c,"int zipmapValidateIntegrity(unsigned char *zm, size_t size, int deep) {
#define OUT_OF_RANGE(p) ( \
        (p) < zm + 2 || \
        (p) > zm + size - 1)
    unsigned int l, s, e;

    /* check that we can actually read the header (or ZIPMAP_END). */
    if (size < 2)
        return 0;

    /* the last byte must be the terminator. */
    if (zm[size-1] != ZIPMAP_END)
        return 0;

    if (!deep)
        return 1;

    unsigned int count = 0;
    unsigned char *p = zm + 1; /* skip the count */
    while(*p != ZIPMAP_END) {
        /* read the field name length encoding type */
        s = zipmapGetEncodedLengthSize(p);
        /* make sure the entry length doesn't reach outside the edge of the zipmap */
        if (OUT_OF_RANGE(p+s))
            return 0;

        /* read the field name length */
        l = zipmapDecodeLength(p);
        p += s; /* skip the encoded field size */
        p += l; /* skip the field */

        /* make sure the entry doesn't reach outside the edge...",380.0,442.0,1.0,22.0,63.0,57,14,58,8,0,4,11,15,0,4,,0,4,6,3,3,int
5121,479627,zmalloc_oom_handler,1,zmalloc_oom_handler,void zmalloc_oom_handler (ANY),zmalloc.c,static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;,103.0,103.0,13.0,64.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,void
5122,479635,ztrymalloc_usable_internal,1,ztrymalloc_usable_internal,"void* ztrymalloc_usable_internal (size_t,size_t*)",zmalloc.c,"static inline void *ztrymalloc_usable_internal(size_t size, size_t *usable) {
    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) return NULL;
    void *ptr = malloc(MALLOC_MIN_SIZE(size)+PREFIX_SIZE);

    if (!ptr) return NULL;
#ifdef HAVE_MALLOC_SIZE
    size = zmalloc_size(ptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *usable = size;
    return ptr;
#else
    *((size_t*)ptr) = size;
    update_zmalloc_stat_alloc(size+PREFIX_SIZE);
    if (usable) *usable = size;
    return (char*)ptr+PREFIX_SIZE;
#endif
}",114.0,131.0,1.0,23.0,18.0,19,10,21,8,4,1,4,4,0,0,,0,1,4,2,2,void*
5123,479705,ztrymalloc_usable,1,ztrymalloc_usable,"void* ztrymalloc_usable (size_t,size_t*)",zmalloc.c,"void *ztrymalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrymalloc_usable_internal(size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",133.0,141.0,1.0,1.0,9.0,5,3,8,4,3,1,2,2,0,1,,0,1,4,2,2,void*
5124,479731,zmalloc,1,zmalloc,void* zmalloc (size_t),zmalloc.c,"void *zmalloc(size_t size) {
    void *ptr = ztrymalloc_usable_internal(size, NULL);
    if (!ptr) zmalloc_oom_handler(size);
    return ptr;
}",144.0,148.0,1.0,1.0,5.0,2,2,6,3,196,2,2,2,0,2,,0,1,2,1,1,void*
5125,479750,ztrymalloc,1,ztrymalloc,void* ztrymalloc (size_t),zmalloc.c,"void *ztrymalloc(size_t size) {
    void *ptr = ztrymalloc_usable_internal(size, NULL);
    return ptr;
}",151.0,154.0,1.0,1.0,4.0,1,1,4,3,3,1,1,1,0,1,,0,1,2,1,1,void*
5126,479763,zmalloc_usable,1,zmalloc_usable,"void* zmalloc_usable (size_t,size_t*)",zmalloc.c,"void *zmalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrymalloc_usable_internal(size, &usable_size);
    if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",158.0,167.0,1.0,1.0,10.0,6,4,10,4,10,2,3,3,0,2,,0,1,4,2,2,void*
5127,479795,ztrycalloc_usable_internal,1,ztrycalloc_usable_internal,"void* ztrycalloc_usable_internal (size_t,size_t*)",zmalloc.c,"static inline void *ztrycalloc_usable_internal(size_t size, size_t *usable) {
    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) return NULL;
    void *ptr = calloc(1, MALLOC_MIN_SIZE(size)+PREFIX_SIZE);
    if (ptr == NULL) return NULL;

#ifdef HAVE_MALLOC_SIZE
    size = zmalloc_size(ptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *usable = size;
    return ptr;
#else
    *((size_t*)ptr) = size;
    update_zmalloc_stat_alloc(size+PREFIX_SIZE);
    if (usable) *usable = size;
    return (char*)ptr+PREFIX_SIZE;
#endif
}",190.0,207.0,1.0,26.0,18.0,19,10,22,8,5,1,4,4,0,0,,0,1,4,2,2,void*
5128,479867,ztrycalloc_usable,1,ztrycalloc_usable,"void* ztrycalloc_usable (size_t,size_t*)",zmalloc.c,"void *ztrycalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrycalloc_usable_internal(size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",209.0,217.0,1.0,1.0,9.0,5,3,8,4,0,1,2,2,0,1,,0,1,4,2,2,void*
5129,479893,zcalloc_num,1,zcalloc_num,"void* zcalloc_num (size_t,size_t)",zmalloc.c,"void *zcalloc_num(size_t num, size_t size) {
    /* Ensure that the arguments to calloc(), when multiplied, do not wrap.
     * Division operations are susceptible to divide-by-zero errors so we also check it. */
    if ((size == 0) || (num > SIZE_MAX/size)) {
        zmalloc_oom_handler(SIZE_MAX);
        return NULL;
    }
    void *ptr = ztrycalloc_usable_internal(num*size, NULL);
    if (!ptr) zmalloc_oom_handler(num*size);
    return ptr;
}",221.0,231.0,1.0,1.0,11.0,8,7,14,5,0,3,3,3,0,3,,0,1,4,2,2,void*
5130,479932,zcalloc,1,zcalloc,void* zcalloc (size_t),zmalloc.c,"void *zcalloc(size_t size) {
    void *ptr = ztrycalloc_usable_internal(size, NULL);
    if (!ptr) zmalloc_oom_handler(size);
    return ptr;
}",234.0,238.0,1.0,1.0,5.0,2,2,6,3,26,2,2,2,0,2,,0,1,2,1,1,void*
5131,479951,ztrycalloc,1,ztrycalloc,void* ztrycalloc (size_t),zmalloc.c,"void *ztrycalloc(size_t size) {
    void *ptr = ztrycalloc_usable_internal(size, NULL);
    return ptr;
}",241.0,244.0,1.0,1.0,4.0,1,1,4,3,1,1,1,1,0,1,,0,1,2,1,1,void*
5132,479964,zcalloc_usable,1,zcalloc_usable,"void* zcalloc_usable (size_t,size_t*)",zmalloc.c,"void *zcalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrycalloc_usable_internal(size, &usable_size);
    if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",248.0,257.0,1.0,1.0,10.0,6,4,10,4,1,2,3,3,0,2,,0,1,4,2,2,void*
5133,479996,ztryrealloc_usable_internal,1,ztryrealloc_usable_internal,"void* ztryrealloc_usable_internal (void*,size_t,size_t*)",zmalloc.c,"static inline void *ztryrealloc_usable_internal(void *ptr, size_t size, size_t *usable) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
#endif
    size_t oldsize;
    void *newptr;

    /* not allocating anything, just redirect to free. */
    if (size == 0 && ptr != NULL) {
        zfree(ptr);
        if (usable) *usable = 0;
        return NULL;
    }
    /* Not freeing anything, just redirect to malloc. */
    if (ptr == NULL)
        return ztrymalloc_usable(size, usable);

    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) {
        zfree(ptr);
        if (usable) *usable = 0;
        return NULL;
    }

#ifdef HAVE_MALLOC_SIZE
    oldsize = zmalloc_size(ptr);
    newptr = realloc(ptr,size);
    if (newptr == NULL) {
        if (usable) *usable = 0;
        return NULL;
    }

    update_zmalloc_stat_free(oldsize);
    size = zmalloc_size(newptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *u...",261.0,313.0,1.0,25.0,53.0,31,11,44,10,3,5,9,12,0,3,,0,2,6,3,3,void*
5134,480127,ztryrealloc_usable,1,ztryrealloc_usable,"void* ztryrealloc_usable (void*,size_t,size_t*)",zmalloc.c,"void *ztryrealloc_usable(void *ptr, size_t size, size_t *usable) {
    size_t usable_size = 0;
    ptr = ztryrealloc_usable_internal(ptr, size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",315.0,323.0,1.0,1.0,9.0,5,3,9,4,1,1,2,2,0,1,,0,1,6,3,3,void*
5135,480154,zrealloc,1,zrealloc,"void* zrealloc (void*,size_t)",zmalloc.c,"void *zrealloc(void *ptr, size_t size) {
    ptr = ztryrealloc_usable_internal(ptr, size, NULL);
    if (!ptr && size != 0) zmalloc_oom_handler(size);
    return ptr;
}",326.0,330.0,1.0,1.0,5.0,4,4,8,3,45,2,2,2,0,2,,0,1,4,2,2,void*
5136,480178,ztryrealloc,1,ztryrealloc,"void* ztryrealloc (void*,size_t)",zmalloc.c,"void *ztryrealloc(void *ptr, size_t size) {
    ptr = ztryrealloc_usable_internal(ptr, size, NULL);
    return ptr;
}",333.0,336.0,1.0,1.0,4.0,1,1,5,3,0,1,1,1,0,1,,0,1,4,2,2,void*
5137,480192,zrealloc_usable,1,zrealloc_usable,"void* zrealloc_usable (void*,size_t,size_t*)",zmalloc.c,"void *zrealloc_usable(void *ptr, size_t size, size_t *usable) {
    size_t usable_size = 0;
    ptr = ztryrealloc_usable(ptr, size, &usable_size);
    if (!ptr && size != 0) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",340.0,349.0,1.0,1.0,10.0,8,6,12,4,7,2,3,3,0,2,,0,1,6,3,3,void*
5138,480229,zmalloc_size,1,zmalloc_size,size_t zmalloc_size (void*),zmalloc.c,"size_t zmalloc_size(void *ptr) {
    void *realptr = (char*)ptr-PREFIX_SIZE;
    size_t size = *((size_t*)realptr);
    return size+PREFIX_SIZE;
}",355.0,359.0,1.0,31.0,5.0,9,6,7,4,12,0,1,1,0,0,,0,0,2,1,1,size_t
5139,480259,zmalloc_usable_size,1,zmalloc_usable_size,size_t zmalloc_usable_size (void*),zmalloc.c,"size_t zmalloc_usable_size(void *ptr) {
    return zmalloc_size(ptr)-PREFIX_SIZE;
}",360.0,362.0,1.0,29.0,3.0,2,2,2,2,3,1,1,1,0,1,,0,0,2,1,1,size_t
5140,480272,zfree,1,zfree,void zfree (void*),zmalloc.c,"void zfree(void *ptr) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;
#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char*)ptr-PREFIX_SIZE;
    oldsize = *((size_t*)realptr);
    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
    free(realptr);
#endif
}",365.0,381.0,1.0,25.0,17.0,10,7,11,6,309,1,2,2,0,0,,0,1,2,1,1,void
5141,480311,zfree_usable,1,zfree_usable,"void zfree_usable (void*,size_t*)",zmalloc.c,"void zfree_usable(void *ptr, size_t *usable) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;
#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(*usable = zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char*)ptr-PREFIX_SIZE;
    *usable = oldsize = *((size_t*)realptr);
    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
    free(realptr);
#endif
}",384.0,400.0,1.0,25.0,17.0,12,7,12,7,0,1,2,2,0,0,,0,1,4,2,2,void
5142,480354,zstrdup,1,zstrdup,char* zstrdup (char*),zmalloc.c,"char *zstrdup(const char *s) {
    size_t l = strlen(s)+1;
    char *p = zmalloc(l);

    memcpy(p,s,l);
    return p;
}",402.0,408.0,1.0,1.0,7.0,3,2,8,3,28,1,1,1,0,1,,0,1,2,1,1,char*
5143,480377,zmalloc_used_memory,1,zmalloc_used_memory,size_t zmalloc_used_memory (void),zmalloc.c,"size_t zmalloc_used_memory(void) {
    size_t um;
    atomicGet(used_memory,um);
    return um;
}",410.0,414.0,1.0,1.0,5.0,0,0,3,2,20,1,1,1,0,0,,0,1,2,1,1,size_t
5144,480396,zmadvise_dontneed,1,zmadvise_dontneed,void zmadvise_dontneed (void*),zmalloc.c,"void zmadvise_dontneed(void *ptr) {
#if defined(USE_JEMALLOC) && defined(__linux__)
    static size_t page_size = 0;
    if (page_size == 0) page_size = sysconf(_SC_PAGESIZE);
    size_t page_size_mask = page_size - 1;

    size_t real_size = zmalloc_size(ptr);
    if (real_size < page_size) return;

    /* We need to align the pointer upwards according to page size, because
     * the memory address is increased upwards and we only can free memory
     * based on page. */
    char *aligned_ptr = (char *)(((size_t)ptr+page_size_mask) & ~page_size_mask);
    real_size -= (aligned_ptr-(char*)ptr);
    if (real_size >= page_size) {
        madvise((void *)aligned_ptr, real_size&~page_size_mask, MADV_DONTNEED);
    }
#else
    (void)(ptr);
#endif
}",423.0,443.0,1.0,1.0,21.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
5145,480424,zmalloc_get_rss,1,zmalloc_get_rss,size_t zmalloc_get_rss (void),zmalloc.c,"size_t zmalloc_get_rss(void) {
    /* If we can't get the RSS in an OS-specific way for this system just
     * return the memory usage we estimated in zmalloc()..
     *
     * Fragmentation will appear to be always 1 (no fragmentation)
     * of course... */
    return zmalloc_used_memory();
}",618.0,625.0,1.0,1.0,8.0,0,0,0,0,1,1,1,1,0,1,,0,0,2,1,1,size_t
5146,480431,zmalloc_get_allocator_info,1,zmalloc_get_allocator_info,"int zmalloc_get_allocator_info (size_t*,size_t*,size_t*)",zmalloc.c,"int zmalloc_get_allocator_info(size_t *allocated,
                               size_t *active,
                               size_t *resident) {
    *allocated = *resident = *active = 0;
    return 1;
}",674.0,679.0,1.0,1.0,6.0,6,2,3,3,1,0,1,1,0,0,,0,0,6,3,3,int
5147,480450,set_jemalloc_bg_thread,1,set_jemalloc_bg_thread,void set_jemalloc_bg_thread (int),zmalloc.c,"void set_jemalloc_bg_thread(int enable) {
    ((void)(enable));
}",681.0,683.0,1.0,1.0,3.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
5148,480465,zmalloc_get_smap_bytes_by_field,1,zmalloc_get_smap_bytes_by_field,"size_t zmalloc_get_smap_bytes_by_field (char*,long)",zmalloc.c,"size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
#if defined(__APPLE__)
    struct proc_regioninfo pri;
    if (pid == -1) pid = getpid();
    if (proc_pidinfo(pid, PROC_PIDREGIONINFO, 0, &pri,
                     PROC_PIDREGIONINFO_SIZE) == PROC_PIDREGIONINFO_SIZE)
    {
        int pagesize = getpagesize();
        if (!strcmp(field, ""Private_Dirty:"")) {
            return (size_t)pri.pri_pages_dirtied * pagesize;
        } else if (!strcmp(field, ""Rss:"")) {
            return (size_t)pri.pri_pages_resident * pagesize;
        } else if (!strcmp(field, ""AnonHugePages:"")) {
            return 0;
        }
    }
    return 0;
#endif
    ((void) field);
    ((void) pid);
    return 0;
}",745.0,766.0,1.0,1.0,22.0,2,1,2,2,2,0,1,1,0,0,,0,0,4,2,2,size_t
5149,480479,zmalloc_get_private_dirty,1,zmalloc_get_private_dirty,size_t zmalloc_get_private_dirty (long),zmalloc.c,"size_t zmalloc_get_private_dirty(long pid) {
    return zmalloc_get_smap_bytes_by_field(""Private_Dirty:"",pid);
}",774.0,776.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,size_t
5150,480488,zmalloc_get_memory_size,1,zmalloc_get_memory_size,size_t zmalloc_get_memory_size (void),zmalloc.c,"size_t zmalloc_get_memory_size(void) {
#if defined(__unix__) || defined(__unix) || defined(unix) || \
    (defined(__APPLE__) && defined(__MACH__))
#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))
    int mib[2];
    mib[0] = CTL_HW;
#if defined(HW_MEMSIZE)
    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */
#elif defined(HW_PHYSMEM64)
    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */
#endif
    int64_t size = 0;               /* 64-bit */
    size_t len = sizeof(size);
    if (sysctl( mib, 2, &size, &len, NULL, 0) == 0)
        return (size_t)size;
    return 0L;          /* Failed? */

#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)
    /* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */
    return (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);

#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))
    /* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */
    i...",791.0,832.0,1.0,1.0,42.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
5151,39550,myself,2,cluster.c.myself,,cluster.c,clusterNode* myself,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,138,0,1,1,0,0,,0,0,0,0,0,
5152,39923,clusterNodesDictType,2,cluster.c.clusterNodesDictType,,cluster.c,dictType clusterNodesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5153,39934,clusterNodesBlackListDictType,2,cluster.c.clusterNodesBlackListDictType,,cluster.c,dictType clusterNodesBlackListDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5154,39959,clusterSdsToListType,2,cluster.c.clusterSdsToListType,,cluster.c,dictType clusterSdsToListType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5155,40001,auxFieldHandlers,2,cluster.c.auxFieldHandlers,,cluster.c,auxFieldHandler[] auxFieldHandlers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
5156,40444,clusterMsgSendBlock,2,cluster.c.clusterMsgSendBlock,,cluster.c,struct clusterMsgSendBlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5157,67370,maxmemory_policy_enum,2,config.c.maxmemory_policy_enum,,config.c,configEnum[] maxmemory_policy_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5158,67770,clientBufferLimitsDefaults,2,config.c.clientBufferLimitsDefaults,,config.c,clientBufferLimitsConfig[3] clientBufferLimitsDefaults,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5159,67802,configOOMScoreAdjValuesDefaults,2,config.c.configOOMScoreAdjValuesDefaults,,config.c,int[3] configOOMScoreAdjValuesDefaults,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5160,67939,configs,2,config.c.configs,,config.c,dict* configs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
5161,68516,reading_config_file,2,config.c.reading_config_file,,config.c,static int reading_config_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5162,70711,optionToLineDictType,2,config.c.optionToLineDictType,,config.c,dictType optionToLineDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5163,70722,optionSetDictType,2,config.c.optionSetDictType,,config.c,dictType optionSetDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5164,73141,loadbuf,2,config.c.loadbuf,,config.c,char[256] loadbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5165,78522,static_configs,2,config.c.static_configs,,config.c,standardConfig[] static_configs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5166,97486,connTypes,2,connection.c.connTypes,,connection.c,ConnectionType*[8] connTypes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5167,100403,crc64_table,2,crc64.c.crc64_table,,crc64.c,static uint64_t[8][256] crc64_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5168,104367,obj_type_name,2,db.c.obj_type_name,,db.c,char*[7] obj_type_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5169,108301,commands_with_channels,2,db.c.commands_with_channels,,db.c,ChannelSpecs[] commands_with_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5170,116275,dict_can_resize,2,dict.c.dict_can_resize,,dict.c,dictResizeEnable dict_can_resize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5171,116279,dict_force_resize_ratio,2,dict.c.dict_force_resize_ratio,,dict.c,static unsigned int dict_force_resize_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5172,116335,dict_hash_function_seed,2,dict.c.dict_hash_function_seed,,dict.c,static uint8_t[16] dict_hash_function_seed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5173,123352,shaScriptObjectDictType,2,eval.c.shaScriptObjectDictType,,eval.c,dictType shaScriptObjectDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5174,123368,lctx,2,eval.c.lctx,,eval.c,struct luaCtx lctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,
5175,123394,ldb,2,eval.c.ldb,,eval.c,struct ldbState ldb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,87,0,1,1,0,0,,0,0,0,0,0,
5176,128839,EvictionPoolLRU,2,evict.c.EvictionPoolLRU,,evict.c,struct evictionPoolEntry* EvictionPoolLRU,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5177,129766,isEvictionProcRunning,2,evict.c.isEvictionProcRunning,,evict.c,static int isEvictionProcRunning,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5178,131460,slaveKeysWithExpire,2,expire.c.slaveKeysWithExpire,,expire.c,dict* slaveKeysWithExpire,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
5179,133933,engine_cache_memory,2,functions.c.engine_cache_memory,,functions.c,size_t engine_cache_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5180,133974,engineDictType,2,functions.c.engineDictType,,functions.c,dictType engineDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5181,133985,functionDictType,2,functions.c.functionDictType,,functions.c,dictType functionDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5182,133996,engineStatsDictType,2,functions.c.engineStatsDictType,,functions.c,dictType engineStatsDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5183,134007,libraryFunctionDictType,2,functions.c.libraryFunctionDictType,,functions.c,dictType libraryFunctionDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5184,134018,librariesDictType,2,functions.c.librariesDictType,,functions.c,dictType librariesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5185,134029,engines,2,functions.c.engines,,functions.c,dict* engines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
5186,134033,curr_functions_lib_ctx,2,functions.c.curr_functions_lib_ctx,,functions.c,functionsLibCtx* curr_functions_lib_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
5187,142856,EARTH_RADIUS_IN_METERS,2,geohash_helper.c.EARTH_RADIUS_IN_METERS,,geohash_helper.c,const double EARTH_RADIUS_IN_METERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5188,142860,MERCATOR_MAX,2,geohash_helper.c.MERCATOR_MAX,,geohash_helper.c,const double MERCATOR_MAX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5189,144003,invalid_hll_err,2,hyperloglog.c.invalid_hll_err,,hyperloglog.c,static char* invalid_hll_err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5190,150664,latencyTimeSeriesDictType,2,latency.c.latencyTimeSeriesDictType,,latency.c,dictType latencyTimeSeriesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5191,153065,lazyfree_objects,2,server.h.lazyfree_objects,,server.h,size_t lazyfree_objects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
5192,153069,lazyfreed_objects,2,server.h.lazyfreed_objects,,server.h,size_t lazyfreed_objects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
5193,163869,ws,2,memtest.c.ws,,memtest.c,struct winsize ws,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5194,163870,progress_printed,2,memtest.c.progress_printed,,memtest.c,size_t progress_printed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5195,163871,progress_full,2,memtest.c.progress_full,,memtest.c,size_t progress_full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5196,164991,modules,2,module.c.modules,,module.c,dict* modules,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
5197,165119,moduleAuthCallbacks,2,module.c.moduleAuthCallbacks,,module.c,list* moduleAuthCallbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5198,165120,moduleUnblockedClientsMutex,2,module.c.moduleUnblockedClientsMutex,,module.c,pthread_mutex_t moduleUnblockedClientsMutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5199,165124,moduleUnblockedClients,2,module.c.moduleUnblockedClients,,module.c,list* moduleUnblockedClients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
5200,165125,moduleTempClients,2,module.c.moduleTempClients,,module.c,client** moduleTempClients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5201,165126,moduleTempClientCap,2,module.c.moduleTempClientCap,,module.c,size_t moduleTempClientCap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
5202,165130,moduleTempClientCount,2,module.c.moduleTempClientCount,,module.c,size_t moduleTempClientCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
5203,165134,moduleTempClientMinCount,2,module.c.moduleTempClientMinCount,,module.c,size_t moduleTempClientMinCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5204,165138,moduleGIL,2,module.c.moduleGIL,,module.c,pthread_mutex_t moduleGIL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5205,165173,moduleKeyspaceSubscribers,2,module.c.moduleKeyspaceSubscribers,,module.c,list* moduleKeyspaceSubscribers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5206,165174,modulePostExecUnitJobs,2,module.c.modulePostExecUnitJobs,,module.c,list* modulePostExecUnitJobs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5207,165198,moduleCommandFilters,2,module.c.moduleCommandFilters,,module.c,list* moduleCommandFilters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
5208,165209,moduleForkInfo,2,module.c.moduleForkInfo,,module.c,struct RedisModuleForkInfo moduleForkInfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5209,165222,RedisModule_EventListeners,2,module.c.RedisModule_EventListeners,,module.c,list* RedisModule_EventListeners,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
5210,182351,ModuleTypeNameCharSet,2,module.c.ModuleTypeNameCharSet,,module.c,const char* ModuleTypeNameCharSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5211,187495,clusterReceivers,2,module.c.clusterReceivers,,module.c,moduleClusterReceiver*[] clusterReceivers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5212,188210,Timers,2,module.c.Timers,,module.c,rax* Timers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
5213,188211,aeTimer,2,module.c.aeTimer,,module.c,long long aeTimer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5214,188742,moduleEventLoopOneShots,2,module.c.moduleEventLoopOneShots,,module.c,list* moduleEventLoopOneShots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
5215,188743,moduleEventLoopMutex,2,module.c.moduleEventLoopMutex,,module.c,pthread_mutex_t moduleEventLoopMutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5216,193738,moduleEventVersions,2,module.c.moduleEventVersions,,module.c,static uint64_t[] moduleEventVersions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5217,194962,sdsKeyValueHashDictType,2,module.c.sdsKeyValueHashDictType,,module.c,dictType sdsKeyValueHashDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5218,197417,configerr,2,module.c.configerr,,module.c,char[256] configerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5219,203400,global,2,modules\helloacl.c.global,,modules\helloacl.c,RedisModuleUser* global,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
5220,203401,global_auth_client_id,2,modules\helloacl.c.global_auth_client_id,,modules\helloacl.c,uint64_t global_auth_client_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5221,204630,Keyspace,2,modules\hellodict.c.Keyspace,,modules\hellodict.c,RedisModuleDict* Keyspace,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5222,205265,HelloType,2,modules\hellotype.c.HelloType,,modules\hellotype.c,RedisModuleType* HelloType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5223,208099,monotonic_info_string,2,monotonic.h.monotonic_info_string,,monotonic.h,char[32] monotonic_info_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5224,208258,mt,2,mt19937-64.c.mt,,mt19937-64.c,unsigned longlongint[312] mt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
5225,208263,mti,2,mt19937-64.c.mti,,mt19937-64.c,static int mti,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5226,210530,ProcessingEventsWhileBlocked,2,networking.c.ProcessingEventsWhileBlocked,,networking.c,int ProcessingEventsWhileBlocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5227,225366,io_threads,2,networking.c.io_threads,,networking.c,pthread_t[128] io_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5228,225371,io_threads_mutex,2,networking.c.io_threads_mutex,,networking.c,pthread_mutex_t[128] io_threads_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5229,225376,io_threads_pending,2,networking.c.io_threads_pending,,networking.c,threads_pending[128] io_threads_pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5230,225381,io_threads_op,2,networking.c.io_threads_op,,networking.c,int io_threads_op,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5231,225382,io_threads_list,2,networking.c.io_threads_list,,networking.c,list*[128] io_threads_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
5232,235239,pubSubType,2,pubsub.c.pubSubType,,pubsub.c,pubsubtype pubSubType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5233,235283,pubSubShardType,2,pubsub.c.pubSubShardType,,pubsub.c,pubsubtype pubSubShardType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5234,237825,packed_threshold,2,quicklist.c.packed_threshold,,quicklist.c,size_t packed_threshold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5235,244037,x,2,rand.c.x,,rand.c,static uint32_t[3] x,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5236,244038,a,2,rand.c.a,,rand.c,static uint32_t[3] a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5237,244039,c,2,rand.c.c,,rand.c,uint32_t c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5238,244747,raxNotFound,2,rax.c.raxNotFound,,rax.c,void* raxNotFound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5239,244759,raxDebugMsg,2,rax.c.raxDebugMsg,,rax.c,static int raxDebugMsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5240,252067,rdbFileBeingLoaded,2,rdb.c.rdbFileBeingLoaded,,rdb.c,char* rdbFileBeingLoaded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5241,266510,config,2,redis-benchmark.c.config,,redis-benchmark.c,struct config config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,161,0,1,1,0,0,,0,0,0,0,0,
5242,274143,error,2,redis-check-aof.c.error,,redis-check-aof.c,char[1044] error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
5243,274146,epos,2,redis-check-aof.c.epos,,redis-check-aof.c,off_t epos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
5244,274147,line,2,redis-check-aof.c.line,,redis-check-aof.c,static long long line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5245,274151,to_timestamp,2,redis-check-aof.c.to_timestamp,,redis-check-aof.c,time_t to_timestamp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5246,275700,rdbCheckMode,2,redis-check-rdb.c.rdbCheckMode,,redis-check-rdb.c,int rdbCheckMode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5247,275720,rdbstate,2,redis-check-rdb.c.rdbstate,,redis-check-rdb.c,struct rdbstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
5248,277067,spectrum_palette,2,redis-cli.c.spectrum_palette,,redis-cli.c,int* spectrum_palette,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5249,277068,spectrum_palette_size,2,redis-cli.c.spectrum_palette_size,,redis-cli.c,int spectrum_palette_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5250,277069,orig_termios_saved,2,redis-cli.c.orig_termios_saved,,redis-cli.c,static int orig_termios_saved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5251,277074,orig_termios,2,redis-cli.c.orig_termios,,redis-cli.c,struct termios orig_termios,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5252,277200,config,2,redis-cli.c.config,,redis-cli.c,struct config config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,172,0,1,1,0,0,,0,0,0,0,0,
5253,277203,pref,2,redis-cli.c.pref,,redis-cli.c,struct pref pref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5254,277204,force_cancel_loop,2,redis-cli.c.force_cancel_loop,,redis-cli.c,volatile sig_atomic_t force_cancel_loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5255,277566,helpEntry,2,redis-cli.c.helpEntry,,redis-cli.c,struct helpEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5256,277567,helpEntries,2,redis-cli.c.helpEntries,,redis-cli.c,helpEntry* helpEntries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
5257,277571,helpEntriesLen,2,redis-cli.c.helpEntriesLen,,redis-cli.c,static int helpEntriesLen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
5258,289861,cluster_manager,2,redis-cli.c.cluster_manager,,redis-cli.c,struct clusterManager cluster_manager,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
5259,289862,clusterManagerUncoveredSlots,2,redis-cli.c.clusterManagerUncoveredSlots,,redis-cli.c,dict* clusterManagerUncoveredSlots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5260,290176,clusterManagerCommands,2,redis-cli.c.clusterManagerCommands,,redis-cli.c,clusterManagerCommandDef[] clusterManagerCommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5261,310353,typeinfo,2,redis-cli.c.typeinfo,,redis-cli.c,struct typeinfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5262,310354,type_string,2,redis-cli.c.type_string,,redis-cli.c,typeinfo type_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5263,310361,type_list,2,redis-cli.c.type_list,,redis-cli.c,typeinfo type_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5264,310368,type_set,2,redis-cli.c.type_set,,redis-cli.c,typeinfo type_set,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5265,310375,type_hash,2,redis-cli.c.type_hash,,redis-cli.c,typeinfo type_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5266,310382,type_zset,2,redis-cli.c.type_zset,,redis-cli.c,typeinfo type_zset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5267,310389,type_stream,2,redis-cli.c.type_stream,,redis-cli.c,typeinfo type_stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5268,310466,typeinfoDictType,2,redis-cli.c.typeinfoDictType,,redis-cli.c,dictType typeinfoDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5269,320073,RDBGeneratedByReplication,2,replication.c.RDBGeneratedByReplication,,replication.c,int RDBGeneratedByReplication,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5270,334517,rioBufferIO,2,rio.c.rioBufferIO,,rio.c,const rio rioBufferIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5271,334887,rioFileIO,2,rio.c.rioFileIO,,rio.c,const rio rioFileIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5272,335399,rioConnIO,2,rio.c.rioConnIO,,rio.c,const rio rioConnIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5273,335828,rioFdIO,2,rio.c.rioFdIO,,rio.c,const rio rioFdIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5274,336668,curr_run_ctx,2,script.c.curr_run_ctx,,script.c,scriptRunCtx* curr_run_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
5275,338796,allow_lists,2,script_lua.c.allow_lists,,script_lua.c,char**[] allow_lists,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5276,338806,deny_list,2,script_lua.c.deny_list,,script_lua.c,char*[] deny_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5277,339046,DefaultLuaTypeParserCallbacks,2,script_lua.c.DefaultLuaTypeParserCallbacks,,script_lua.c,const ReplyParserCallbacks DefaultLuaTypeParserCallbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5278,340655,lua_argv,2,script_lua.c.lua_argv,,script_lua.c,robj** lua_argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5279,340659,lua_argv_size,2,script_lua.c.lua_argv_size,,script_lua.c,static int lua_argv_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5280,340663,lua_args_cached_objects,2,script_lua.c.lua_args_cached_objects,,script_lua.c,redisObject*[32] lua_args_cached_objects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5281,340668,lua_args_cached_objects_len,2,script_lua.c.lua_args_cached_objects_len,,script_lua.c,static size_t[32] lua_args_cached_objects_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5282,343504,SDS_NOINIT,2,sds.c.SDS_NOINIT,,sds.c,const char* SDS_NOINIT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5283,347983,sentinel_info_period,2,sentinel.c.sentinel_info_period,,sentinel.c,mstime_t sentinel_info_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5284,347987,sentinel_ping_period,2,sentinel.c.sentinel_ping_period,,sentinel.c,mstime_t sentinel_ping_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5285,347993,sentinel_ask_period,2,sentinel.c.sentinel_ask_period,,sentinel.c,mstime_t sentinel_ask_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5286,347997,sentinel_publish_period,2,sentinel.c.sentinel_publish_period,,sentinel.c,mstime_t sentinel_publish_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5287,348001,sentinel_default_down_after,2,sentinel.c.sentinel_default_down_after,,sentinel.c,mstime_t sentinel_default_down_after,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5288,348005,sentinel_tilt_trigger,2,sentinel.c.sentinel_tilt_trigger,,sentinel.c,mstime_t sentinel_tilt_trigger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5289,348009,sentinel_tilt_period,2,sentinel.c.sentinel_tilt_period,,sentinel.c,mstime_t sentinel_tilt_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5290,348017,sentinel_slave_reconf_timeout,2,sentinel.c.sentinel_slave_reconf_timeout,,sentinel.c,mstime_t sentinel_slave_reconf_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5291,348021,sentinel_min_link_reconnect_period,2,sentinel.c.sentinel_min_link_reconnect_period,,sentinel.c,mstime_t sentinel_min_link_reconnect_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5292,348025,sentinel_election_timeout,2,sentinel.c.sentinel_election_timeout,,sentinel.c,mstime_t sentinel_election_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5293,348029,sentinel_script_max_runtime,2,sentinel.c.sentinel_script_max_runtime,,sentinel.c,mstime_t sentinel_script_max_runtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5294,348033,sentinel_script_retry_delay,2,sentinel.c.sentinel_script_retry_delay,,sentinel.c,mstime_t sentinel_script_retry_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5295,348037,sentinel_default_failover_timeout,2,sentinel.c.sentinel_default_failover_timeout,,sentinel.c,mstime_t sentinel_default_failover_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5296,348137,sentinel,2,sentinel.c.sentinel,,sentinel.c,struct sentinelState sentinel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,79,0,1,1,0,0,,0,0,0,0,0,
5297,348622,instancesDictType,2,sentinel.c.instancesDictType,,sentinel.c,dictType instancesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5298,348633,leaderVotesDictType,2,sentinel.c.leaderVotesDictType,,sentinel.c,dictType leaderVotesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5299,348644,renamedCommandsDictType,2,sentinel.c.renamedCommandsDictType,,sentinel.c,dictType renamedCommandsDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5300,348670,preMonitorCfgName,2,sentinel.c.preMonitorCfgName,,sentinel.c,char[] preMonitorCfgName,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5301,366671,shared,2,server.c.shared,,server.c,struct sharedObjectsStruct shared,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
5302,366672,R_Zero,2,server.c.R_Zero,,server.c,double R_Zero,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5303,366673,R_PosInf,2,server.c.R_PosInf,,server.c,double R_PosInf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5304,366674,R_NegInf,2,server.c.R_NegInf,,server.c,double R_NegInf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5305,366675,R_Nan,2,server.c.R_Nan,,server.c,double R_Nan,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5306,366677,server,2,server.c.server,,server.c,struct redisServer server,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,950,0,1,1,0,0,,0,0,0,0,0,
5307,367660,objectKeyPointerValueDictType,2,server.c.objectKeyPointerValueDictType,,server.c,dictType objectKeyPointerValueDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5308,367710,dbDictType,2,server.c.dbDictType,,server.c,dictType dbDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5309,367733,dbExpiresDictType,2,server.c.dbExpiresDictType,,server.c,dictType dbExpiresDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5310,367744,commandTableDictType,2,server.c.commandTableDictType,,server.c,dictType commandTableDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5311,367777,keylistDictType,2,server.c.keylistDictType,,server.c,dictType keylistDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5312,367799,migrateCacheDictType,2,server.c.migrateCacheDictType,,server.c,dictType migrateCacheDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5313,367810,stringSetDictType,2,server.c.stringSetDictType,,server.c,dictType stringSetDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5314,368735,ClientsPeakMemInput,2,server.c.ClientsPeakMemInput,,server.c,size_t[8] ClientsPeakMemInput,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5315,368740,ClientsPeakMemOutput,2,server.c.ClientsPeakMemOutput,,server.c,size_t[8] ClientsPeakMemOutput,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5316,371259,ProcessingEventsWhileBlocked,2,server.c.ProcessingEventsWhileBlocked,,server.c,extern int ProcessingEventsWhileBlocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5317,373313,environ,2,server.c.environ,,server.c,extern char** environ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5318,376674,redisCommandTable,2,server.c.redisCommandTable,,server.c,redisCommand[] redisCommandTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5319,382360,ARG_TYPE_STR,2,server.c.ARG_TYPE_STR,,server.c,char[] ARG_TYPE_STR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5320,384898,unsafe_info_chars,2,server.c.unsafe_info_chars,,server.c,char[] unsafe_info_chars,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5321,384902,unsafe_info_chars_substs,2,server.c.unsafe_info_chars_substs,,server.c,char[] unsafe_info_chars_substs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5322,385202,cached_default_info_sections,2,server.c.cached_default_info_sections,,server.c,dict* cached_default_info_sections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5323,407633,k,2,sha256.c.k,,sha256.c,ANY k,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5324,411197,CT_Socket,2,socket.c.CT_Socket,,socket.c,ConnectionType CT_Socket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5325,414843,charset,2,sparkline.c.charset,,sparkline.c,char[] charset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5326,414847,charset_fill,2,sparkline.c.charset_fill,,sparkline.c,char[] charset_fill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5327,414851,charset_len,2,sparkline.c.charset_len,,sparkline.c,static int charset_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5328,416218,checks,2,syscheck.c.checks,,syscheck.c,check[] checks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5329,456580,zsetopsrc,2,t_zset.c.zsetopsrc,,t_zset.c,struct zsetopsrc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5330,456595,zsetopval,2,t_zset.c.zsetopval,,t_zset.c,struct zsetopval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5331,465621,PrefixTable,2,tracking.c.PrefixTable,,tracking.c,rax* PrefixTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5332,467609,CT_Unix,2,unix.c.CT_Unix,,unix.c,ConnectionType CT_Unix,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5333,479611,used_memory,2,zmalloc.c.used_memory,,zmalloc.c,size_t used_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5334,15,Users,2,acl.c.Users,,acl.c,rax* Users,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
5335,16,DefaultUser,2,acl.c.DefaultUser,,acl.c,user* DefaultUser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5336,17,UsersToLoad,2,acl.c.UsersToLoad,,acl.c,list* UsersToLoad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
5337,18,ACLLog,2,acl.c.ACLLog,,acl.c,list* ACLLog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5338,19,ACLLogEntryCount,2,acl.c.ACLLogEntryCount,,acl.c,long long ACLLogEntryCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5339,23,commandId,2,acl.c.commandId,,acl.c,rax* commandId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
5340,27,nextid,2,acl.c.nextid,,acl.c,static long unsigned nextid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5341,34,ACLCommandCategories,2,acl.c.ACLCommandCategories,,acl.c,ACLCategoryItem[] ACLCommandCategories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5342,191,ACLUserFlags,2,acl.c.ACLUserFlags,,acl.c,ACLUserFlag[] ACLUserFlags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5343,281,aclSelector,2,acl.c.aclSelector,,acl.c,struct aclSelector,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5344,614,keyPattern,2,acl.c.keyPattern,,acl.c,struct keyPattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
5345,14157,evport_debug,2,ae_evport.c.evport_debug,,ae_evport.c,static int evport_debug,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5346,28030,bio_worker_title,2,bio.c.bio_worker_title,,bio.c,char*[] bio_worker_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
5347,28037,bio_job_to_worker,2,bio.c.bio_job_to_worker,,bio.c,unsigned int[] bio_job_to_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5348,28057,bio_threads,2,bio.c.bio_threads,,bio.c,static pthread_t[] bio_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
5349,28067,bio_mutex,2,bio.c.bio_mutex,,bio.c,static pthread_mutex_t[] bio_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
5350,28077,bio_newjob_cond,2,bio.c.bio_newjob_cond,,bio.c,static pthread_cond_t[] bio_newjob_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
5351,28087,bio_jobs,2,bio.c.bio_jobs,,bio.c,list*[] bio_jobs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
5352,28097,bio_jobs_counter,2,bio.c.bio_jobs_counter,,bio.c,unsigned longint[4] bio_jobs_counter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
5353,37156,DefaultParserCallbacks,2,call_reply.c.DefaultParserCallbacks,,call_reply.c,const ReplyParserCallbacks DefaultParserCallbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
